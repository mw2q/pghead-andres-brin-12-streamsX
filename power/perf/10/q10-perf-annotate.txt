
Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   63.64 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782ca0 <CHashBucketScan>:
         :	CHashBucketScan(CHashTable table,
         :	                                CHashPtr *start,
         :	                                uint32 hashcode,
         :	                                const void *key,
         :	                                CHashScanResult *res)
         :	{
    0.00 :	  782ca0:       55                      push   %rbp
    0.00 :	  782ca1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782ca4:       41 57                   push   %r15
    0.00 :	  782ca6:       41 89 d7                mov    %edx,%r15d
    0.00 :	  782ca9:       41 56                   push   %r14
    0.00 :	  782cab:       41 55                   push   %r13
    0.00 :	  782cad:       49 89 fd                mov    %rdi,%r13
    0.00 :	  782cb0:       41 54                   push   %r12
    0.00 :	  782cb2:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  782cb5:       53                      push   %rbx
    0.00 :	  782cb6:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  782cba:       48 89 75 d0             mov    %rsi,-0x30(%rbp)
    0.00 :	  782cbe:       48 89 4d c8             mov    %rcx,-0x38(%rbp)
    0.00 :	  782cc2:       4c 89 45 c0             mov    %r8,-0x40(%rbp)
         :	        CHashPtr   *pointer_to_target;
         :	        CHashNode  *target_node = NULL;
         :
         :	retry:
         :	        pointer_to_target = start;
         :	        target = *pointer_to_target;
    0.00 :	  782cc6:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  782cca:       44 8b 10                mov    (%rax),%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
   18.18 :	  782ccd:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cd1:       0f 87 ff 00 00 00       ja     782dd6 <CHashBucketScan+0x136>
         :	                {
         :	                        res->found = false;
         :	                        break;
    0.00 :	  782cd7:       4c 8b 75 d0             mov    -0x30(%rbp),%r14
    0.00 :	  782cdb:       eb 21                   jmp    782cfe <CHashBucketScan+0x5e>
    0.00 :	  782cdd:       0f 1f 00                nopl   (%rax)
         :	                /*
         :	                 * Bucket chains are kept in order, so that there is exactly one legal
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
    0.00 :	  782ce0:       41 8b 44 24 04          mov    0x4(%r12),%eax
         :	                if (h == hashcode)
    0.00 :	  782ce5:       44 39 f8                cmp    %r15d,%eax
    0.00 :	  782ce8:       74 5e                   je     782d48 <CHashBucketScan+0xa8>
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
         :	                                                 table->desc.key_size);
         :	                else if (h > hashcode)
    0.00 :	  782cea:       41 39 c7                cmp    %eax,%r15d
    0.00 :	  782ced:       0f 1f 00                nopl   (%rax)
    0.00 :	  782cf0:       72 7b                   jb     782d6d <CHashBucketScan+0xcd>
         :	                                break;
         :	                        }
         :	                }
         :
         :	                /* Continue scan from next node. */
         :	                pointer_to_target = &target_node->next;
    0.00 :	  782cf2:       4d 89 e6                mov    %r12,%r14
    0.00 :	  782cf5:       45 89 c2                mov    %r8d,%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782cf8:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cfc:       77 79                   ja     782d77 <CHashBucketScan+0xd7>
         :	                {
         :	                        res->found = false;
         :	                        break;
         :	                }
         :	                target_node = CHashTableGetNode(table, target);
    0.00 :	  782cfe:       44 89 d0                mov    %r10d,%eax
    0.00 :	  782d01:       d1 e8                   shr    %eax
    0.00 :	  782d03:       41 89 c4                mov    %eax,%r12d
    0.00 :	  782d06:       45 0f af 65 1c          imul   0x1c(%r13),%r12d
    0.00 :	  782d0b:       4d 03 65 30             add    0x30(%r13),%r12
         :	                 * target may have been fetched from an arena entry that could be
         :	                 * concurrently modified, so a dependency barrier is required before
         :	                 * dereferencing the derived pointer.
         :	                 */
         :	                pg_read_barrier_depends();
         :	                next = target_node->next;
    0.00 :	  782d0f:       45 8b 04 24             mov    (%r12),%r8d
         :	                 * ensures that delete-marked elements are removed from bucket chains
         :	                 * as quickly as possible and reduces code duplication.  See
         :	                 * CHashDelete for further comments about why delete-marking is
         :	                 * necessary and how it allows safe deletion.
         :	                 */
         :	                if (CHashPtrIsMarked(next))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
   63.64 :	  782d13:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d17:       74 c7                   je     782ce0 <CHashBucketScan+0x40>
         :	                {
         :	zap:
         :	                        if (__sync_bool_compare_and_swap(pointer_to_target,
    0.00 :	  782d19:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  782d1c:       44 89 d0                mov    %r10d,%eax
    0.00 :	  782d1f:       83 e3 fe                and    $0xfffffffe,%ebx
    0.00 :	  782d22:       f0 41 0f b1 1e          lock cmpxchg %ebx,(%r14)
    0.00 :	  782d27:       74 77                   je     782da0 <CHashBucketScan+0x100>
         :	                                 * the node which precedes it before we advance to the next
         :	                                 * node.  That could certainly happen occasionally, but we'd
         :	                                 * have to be pretty unlucky to have it happen even twice in
         :	                                 * a row.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge_Fail);
    0.00 :	  782d29:       49 83 85 88 00 00 00    addq   $0x1,0x88(%r13)
    0.00 :	  782d30:       01 
         :	                                target = *pointer_to_target;
    0.00 :	  782d31:       45 8b 16                mov    (%r14),%r10d
         :	                                if (CHashPtrIsMarked(target))
    0.00 :	  782d34:       41 f6 c2 01             test   $0x1,%r10b
    0.00 :	  782d38:       74 be                   je     782cf8 <CHashBucketScan+0x58>
         :	                                {
         :	                                        CHashTableIncrementStatistic(table, CHS_Scan_Restart);
    0.00 :	  782d3a:       49 83 85 90 00 00 00    addq   $0x1,0x90(%r13)
    0.00 :	  782d41:       01 
         :	                                        goto retry;
    0.00 :	  782d42:       eb 82                   jmp    782cc6 <CHashBucketScan+0x26>
    0.00 :	  782d44:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
         :	                if (h == hashcode)
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
    0.00 :	  782d48:       41 0f b7 4d 0e          movzwl 0xe(%r13),%ecx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    9.09 :	  782d4d:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  782d51:       49 8d 74 24 08          lea    0x8(%r12),%rsi
    0.00 :	  782d56:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  782d59:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
    9.09 :	  782d5b:       0f 97 c0                seta   %al
    0.00 :	  782d5e:       0f 92 c2                setb   %dl
    0.00 :	  782d61:       28 d0                   sub    %dl,%al
    0.00 :	  782d63:       0f be c0                movsbl %al,%eax
         :	                 * the point where we expect to find the key OR someone delete-marked
         :	                 * the item and overwrote the hashcode with a gcnext pointer.  In the
         :	                 * latter case we must take care not to be fooled into stopping the
         :	                 * scan early.
         :	                 */
         :	                if (cmp >= 0)
    0.00 :	  782d66:       83 f8 00                cmp    $0x0,%eax
    0.00 :	  782d69:       7c 87                   jl     782cf2 <CHashBucketScan+0x52>
         :	                {
         :	                        if (cmp == 0)
    0.00 :	  782d6b:       74 5b                   je     782dc8 <CHashBucketScan+0x128>
         :	                                /*
         :	                                 * pg_read_barrier() prevents the reread of the next pointer
         :	                                 * from being speculated ahead of the read of the hash value.
         :	                                 */
         :	                                pg_read_barrier();
         :	                                next = target_node->next;
    0.00 :	  782d6d:       45 8b 04 24             mov    (%r12),%r8d
         :	                                if (CHashPtrIsMarked(next))
    0.00 :	  782d71:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d75:       75 a2                   jne    782d19 <CHashBucketScan+0x79>
         :	                                        goto zap;
         :	                                res->found = false;
    0.00 :	  782d77:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  782d7b:       c6 47 18 00             movb   $0x0,0x18(%rdi)
         :	                pointer_to_target = &target_node->next;
         :	                target = next;
         :	        }
         :
         :	        /* Send results back to caller. */
         :	        res->target = target;
    0.00 :	  782d7f:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  782d83:       44 89 10                mov    %r10d,(%rax)
         :	        res->pointer_to_target = pointer_to_target;
    0.00 :	  782d86:       4c 89 70 08             mov    %r14,0x8(%rax)
         :	        res->target_node = target_node;
    0.00 :	  782d8a:       4c 89 60 10             mov    %r12,0x10(%rax)
         :	}
    0.00 :	  782d8e:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  782d92:       5b                      pop    %rbx
    0.00 :	  782d93:       41 5c                   pop    %r12
    0.00 :	  782d95:       41 5d                   pop    %r13
    0.00 :	  782d97:       41 5e                   pop    %r14
    0.00 :	  782d99:       41 5f                   pop    %r15
    0.00 :	  782d9b:       c9                      leaveq 
    0.00 :	  782d9c:       c3                      retq   
    0.00 :	  782d9d:       0f 1f 00                nopl   (%rax)
         :	                                 * delete-mark has been applied.  Thus, if we just keep
         :	                                 * following the next pointers, we're guaranteed to visit
         :	                                 * all non-deleted items (and possibly some deleted items)
         :	                                 * that were present at the time we began the scan.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge);
    0.00 :	  782da0:       49 83 85 80 00 00 00    addq   $0x1,0x80(%r13)
    0.00 :	  782da7:       01 
         :	                                CHashAddToGarbage(table, hashcode & table->bucket_mask,
    0.00 :	  782da8:       44 89 fe                mov    %r15d,%esi
    0.00 :	  782dab:       41 23 75 10             and    0x10(%r13),%esi
    0.00 :	  782daf:       44 89 d2                mov    %r10d,%edx
    0.00 :	  782db2:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  782db5:       e8 96 fe ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  782dba:       41 89 da                mov    %ebx,%r10d
    0.00 :	  782dbd:       e9 36 ff ff ff          jmpq   782cf8 <CHashBucketScan+0x58>
    0.00 :	  782dc2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 */
         :	                if (cmp >= 0)
         :	                {
         :	                        if (cmp == 0)
         :	                        {
         :	                                res->found = true;
    0.00 :	  782dc8:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  782dcc:       c6 40 18 01             movb   $0x1,0x18(%rax)
         :	                                res->next = next;
    0.00 :	  782dd0:       44 89 40 04             mov    %r8d,0x4(%rax)
         :	                                break;
    0.00 :	  782dd4:       eb a9                   jmp    782d7f <CHashBucketScan+0xdf>
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782dd6:       49 89 c6                mov    %rax,%r14
    0.00 :	  782dd9:       eb 9c                   jmp    782d77 <CHashBucketScan+0xd7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1720
   22.22 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1688
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1706
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000049d220 <heap_hot_search_buffer>:
         :	 */
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
    0.00 :	  49d220:       55                      push   %rbp
    0.00 :	  49d221:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  49d224:       41 57                   push   %r15
    0.00 :	  49d226:       4d 89 cf                mov    %r9,%r15
    0.00 :	  49d229:       41 56                   push   %r14
    0.00 :	  49d22b:       4d 89 c6                mov    %r8,%r14
    0.00 :	  49d22e:       41 55                   push   %r13
    0.00 :	  49d230:       41 54                   push   %r12
    0.00 :	  49d232:       53                      push   %rbx
    0.00 :	  49d233:       48 83 ec 28             sub    $0x28,%rsp
         :	        Page            dp = (Page) BufferGetPage(buffer);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1688
   11.11 :	  49d237:       85 d2                   test   %edx,%edx
         :	 */
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
    0.00 :	  49d239:       48 89 4d b8             mov    %rcx,-0x48(%rbp)
    0.00 :	  49d23d:       48 89 7d d0             mov    %rdi,-0x30(%rbp)
    0.00 :	  49d241:       48 89 75 c8             mov    %rsi,-0x38(%rbp)
    0.00 :	  49d245:       89 55 c4                mov    %edx,-0x3c(%rbp)
    0.00 :	  49d248:       0f b6 4d 10             movzbl 0x10(%rbp),%ecx
         :	        Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  49d24c:       0f 88 5e 02 00 00       js     49d4b0 <heap_hot_search_buffer+0x290>
    0.00 :	  49d252:       8b 45 c4                mov    -0x3c(%rbp),%eax
    0.00 :	  49d255:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49d258:       4c 63 e8                movslq %eax,%r13
    0.00 :	  49d25b:       49 c1 e5 0d             shl    $0xd,%r13
    0.00 :	  49d25f:       4c 03 2d 92 28 72 00    add    0x722892(%rip),%r13        # bbfaf8 <BufferBlocks>
         :	        bool            at_chain_start;
         :	        bool            valid;
         :	        bool            skip;
         :
         :	        /* If this is not the first call, previous call returned a (live!) tuple */
         :	        if (all_dead)
    0.00 :	  49d266:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d269:       74 03                   je     49d26e <heap_hot_search_buffer+0x4e>
         :	                *all_dead = first_call;
    0.00 :	  49d26b:       41 88 0f                mov    %cl,(%r15)
         :
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
    0.00 :	  49d26e:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  49d272:       44 0f b7 60 04          movzwl 0x4(%rax),%r12d
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
         :
         :	        heapTuple->t_self = *tid;
    0.00 :	  49d277:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49d27a:       8b 00                   mov    (%rax),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1706
   11.11 :	  49d27c:       41 89 46 04             mov    %eax,0x4(%r14)
    0.00 :	  49d280:       0f b7 42 04             movzwl 0x4(%rdx),%eax
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d284:       66 45 85 e4             test   %r12w,%r12w
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
         :
         :	        heapTuple->t_self = *tid;
    0.00 :	  49d288:       66 41 89 46 08          mov    %ax,0x8(%r14)
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d28d:       74 4e                   je     49d2dd <heap_hot_search_buffer+0xbd>
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
    0.00 :	  49d28f:       84 c9                   test   %cl,%cl
    0.00 :	  49d291:       89 ce                   mov    %ecx,%esi
    0.00 :	  49d293:       41 0f 94 c0             sete   %r8b
    0.00 :	  49d297:       31 ff                   xor    %edi,%edi
    0.00 :	  49d299:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d2a0:       41 0f b7 55 0c          movzwl 0xc(%r13),%edx
    0.00 :	  49d2a5:       31 c0                   xor    %eax,%eax
    0.00 :	  49d2a7:       41 0f b7 cc             movzwl %r12w,%ecx
    0.00 :	  49d2ab:       66 83 fa 18             cmp    $0x18,%dx
    0.00 :	  49d2af:       76 0b                   jbe    49d2bc <heap_hot_search_buffer+0x9c>
    0.00 :	  49d2b1:       0f b7 c2                movzwl %dx,%eax
    0.00 :	  49d2b4:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  49d2b8:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  49d2bc:       48 39 c8                cmp    %rcx,%rax
    0.00 :	  49d2bf:       72 1c                   jb     49d2dd <heap_hot_search_buffer+0xbd>
         :	                        break;
         :
         :	                lp = PageGetItemId(dp, offnum);
         :
         :	                /* check for unused, dead, or redirected items */
         :	                if (!ItemIdIsNormal(lp))
    0.00 :	  49d2c1:       48 8d 51 03             lea    0x3(%rcx),%rdx
    0.00 :	  49d2c5:       41 8b 44 95 08          mov    0x8(%r13,%rdx,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1720
   33.33 :	  49d2ca:       25 00 80 01 00          and    $0x18000,%eax
    0.00 :	  49d2cf:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  49d2d4:       74 3a                   je     49d310 <heap_hot_search_buffer+0xf0>
         :	                {
         :	                        /* We should only see a redirect at start of chain */
         :	                        if (ItemIdIsRedirected(lp) && at_chain_start)
    0.00 :	  49d2d6:       3d 00 00 01 00          cmp    $0x10000,%eax
    0.00 :	  49d2db:       74 13                   je     49d2f0 <heap_hot_search_buffer+0xd0>
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d2dd:       31 c0                   xor    %eax,%eax
         :	                else
         :	                        break;                          /* end of chain */
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  49d2df:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  49d2e3:       5b                      pop    %rbx
    0.00 :	  49d2e4:       41 5c                   pop    %r12
    0.00 :	  49d2e6:       41 5d                   pop    %r13
    0.00 :	  49d2e8:       41 5e                   pop    %r14
    0.00 :	  49d2ea:       41 5f                   pop    %r15
    0.00 :	  49d2ec:       c9                      leaveq 
    0.00 :	  49d2ed:       c3                      retq   
    0.00 :	  49d2ee:       66 90                   xchg   %ax,%ax
         :
         :	                /* check for unused, dead, or redirected items */
         :	                if (!ItemIdIsNormal(lp))
         :	                {
         :	                        /* We should only see a redirect at start of chain */
         :	                        if (ItemIdIsRedirected(lp) && at_chain_start)
    0.00 :	  49d2f0:       40 84 f6                test   %sil,%sil
    0.00 :	  49d2f3:       74 e8                   je     49d2dd <heap_hot_search_buffer+0xbd>
         :	                        {
         :	                                /* Follow the redirect */
         :	                                offnum = ItemIdGetRedirect(lp);
    0.00 :	  49d2f5:       45 0f b7 64 95 08       movzwl 0x8(%r13,%rdx,4),%r12d
    0.00 :	  49d2fb:       66 41 81 e4 ff 7f       and    $0x7fff,%r12w
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
    0.00 :	  49d301:       31 f6                   xor    %esi,%esi
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d303:       66 45 85 e4             test   %r12w,%r12w
    0.00 :	  49d307:       75 97                   jne    49d2a0 <heap_hot_search_buffer+0x80>
    0.00 :	  49d309:       eb d2                   jmp    49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d30b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
    0.00 :	  49d310:       41 0f b7 44 95 08       movzwl 0x8(%r13,%rdx,4),%eax
    0.00 :	  49d316:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  49d31b:       49 8d 4c 05 00          lea    0x0(%r13,%rax,1),%rcx
    0.00 :	  49d320:       49 89 4e 10             mov    %rcx,0x10(%r14)
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d324:       41 0f b7 44 95 0a       movzwl 0xa(%r13,%rdx,4),%eax
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d32a:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d32e:       66 d1 e8                shr    %ax
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
         :
         :	                /*
         :	                 * Shouldn't see a HEAP_ONLY tuple at chain start.
         :	                 */
         :	                if (at_chain_start && HeapTupleIsHeapOnly(heapTuple))
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
   11.11 :	  49d331:       40 84 f6                test   %sil,%sil
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d334:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  49d337:       41 89 06                mov    %eax,(%r14)
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d33a:       8b 42 40                mov    0x40(%rdx),%eax
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
    0.00 :	  49d33d:       66 45 89 66 08          mov    %r12w,0x8(%r14)
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d342:       41 89 46 0c             mov    %eax,0xc(%r14)
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
         :
         :	                /*
         :	                 * Shouldn't see a HEAP_ONLY tuple at chain start.
         :	                 */
         :	                if (at_chain_start && HeapTupleIsHeapOnly(heapTuple))
    0.00 :	  49d346:       74 07                   je     49d34f <heap_hot_search_buffer+0x12f>
   11.11 :	  49d348:       66 83 79 12 00          cmpw   $0x0,0x12(%rcx)
   22.22 :	  49d34d:       78 8e                   js     49d2dd <heap_hot_search_buffer+0xbd>
         :
         :	                /*
         :	                 * The xmin should match the previous xmax value, else chain is
         :	                 * broken.
         :	                 */
         :	                if (TransactionIdIsValid(prev_xmax) &&
    0.00 :	  49d34f:       85 ff                   test   %edi,%edi
    0.00 :	  49d351:       74 23                   je     49d376 <heap_hot_search_buffer+0x156>
    0.00 :	  49d353:       49 8b 4e 10             mov    0x10(%r14),%rcx
    0.00 :	  49d357:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  49d35c:       0f b7 41 14             movzwl 0x14(%rcx),%eax
    0.00 :	  49d360:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  49d365:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  49d36a:       74 02                   je     49d36e <heap_hot_search_buffer+0x14e>
    0.00 :	  49d36c:       8b 11                   mov    (%rcx),%edx
    0.00 :	  49d36e:       39 fa                   cmp    %edi,%edx
    0.00 :	  49d370:       0f 85 67 ff ff ff       jne    49d2dd <heap_hot_search_buffer+0xbd>
         :	                 * return the first tuple we find.  But on later passes, heapTuple
         :	                 * will initially be pointing to the tuple we returned last time.
         :	                 * Returning it again would be incorrect (and would loop forever), so
         :	                 * we skip it and return the next match we find.
         :	                 */
         :	                if (!skip)
    0.00 :	  49d376:       45 84 c0                test   %r8b,%r8b
    0.00 :	  49d379:       74 65                   je     49d3e0 <heap_hot_search_buffer+0x1c0>
         :	                /*
         :	                 * If we can't see it, maybe no one else can either.  At caller
         :	                 * request, check whether all chain members are dead to all
         :	                 * transactions.
         :	                 */
         :	                if (all_dead && *all_dead &&
    0.00 :	  49d37b:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d37e:       66 90                   xchg   %ax,%ax
    0.00 :	  49d380:       74 0a                   je     49d38c <heap_hot_search_buffer+0x16c>
    0.00 :	  49d382:       41 80 3f 00             cmpb   $0x0,(%r15)
    0.00 :	  49d386:       0f 85 04 01 00 00       jne    49d490 <heap_hot_search_buffer+0x270>
         :
         :	                /*
         :	                 * Check to see if HOT chain continues past this tuple; if so fetch
         :	                 * the next offnum and loop around.
         :	                 */
         :	                if (HeapTupleIsHotUpdated(heapTuple))
    0.00 :	  49d38c:       49 8b 7e 10             mov    0x10(%r14),%rdi
    0.00 :	  49d390:       f6 47 13 40             testb  $0x40,0x13(%rdi)
    0.00 :	  49d394:       0f 84 43 ff ff ff       je     49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d39a:       0f b7 57 14             movzwl 0x14(%rdi),%edx
    0.00 :	  49d39e:       f6 c6 08                test   $0x8,%dh
    0.00 :	  49d3a1:       0f 85 36 ff ff ff       jne    49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d3a7:       89 d0                   mov    %edx,%eax
    0.00 :	  49d3a9:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  49d3ae:       3d 00 02 00 00          cmp    $0x200,%eax
    0.00 :	  49d3b3:       0f 84 24 ff ff ff       je     49d2dd <heap_hot_search_buffer+0xbd>
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d3b9:       89 d0                   mov    %edx,%eax
         :	                 */
         :	                if (HeapTupleIsHotUpdated(heapTuple))
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
    0.00 :	  49d3bb:       44 0f b7 67 10          movzwl 0x10(%rdi),%r12d
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d3c0:       25 00 18 00 00          and    $0x1800,%eax
    0.00 :	  49d3c5:       3d 00 10 00 00          cmp    $0x1000,%eax
    0.00 :	  49d3ca:       0f 84 a8 00 00 00       je     49d478 <heap_hot_search_buffer+0x258>
    0.00 :	  49d3d0:       8b 7f 04                mov    0x4(%rdi),%edi
    0.00 :	  49d3d3:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  49d3d6:       e9 26 ff ff ff          jmpq   49d301 <heap_hot_search_buffer+0xe1>
    0.00 :	  49d3db:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * element of the HOT chain we're currently investigating instead
         :	                         * of the root tuple of the HOT chain. This is important because
         :	                         * the *Satisfies routine for historical mvcc snapshots needs the
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
    0.00 :	  49d3e0:       8b 7d c4                mov    -0x3c(%rbp),%edi
    0.00 :	  49d3e3:       e8 48 6c 1d 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  49d3e8:       8b 7d c4                mov    -0x3c(%rbp),%edi
    0.00 :	  49d3eb:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  49d3ee:       66 41 89 46 04          mov    %ax,0x4(%r14)
    0.00 :	  49d3f3:       e8 38 6c 1d 00          callq  674030 <BufferGetBlockNumber>
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d3f8:       48 8b 75 b8             mov    -0x48(%rbp),%rsi
    0.00 :	  49d3fc:       8b 55 c4                mov    -0x3c(%rbp),%edx
    0.00 :	  49d3ff:       4c 89 f7                mov    %r14,%rdi
         :	                         * element of the HOT chain we're currently investigating instead
         :	                         * of the root tuple of the HOT chain. This is important because
         :	                         * the *Satisfies routine for historical mvcc snapshots needs the
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
    0.00 :	  49d402:       66 41 89 46 06          mov    %ax,0x6(%r14)
    0.00 :	  49d407:       66 45 89 66 08          mov    %r12w,0x8(%r14)
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d40c:       ff 16                   callq  *(%rsi)
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
    0.00 :	  49d40e:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  49d411:       4c 8b 45 b8             mov    -0x48(%rbp),%r8
    0.00 :	  49d415:       0f be f8                movsbl %al,%edi
    0.00 :	  49d418:       48 8b 75 c8             mov    -0x38(%rbp),%rsi
    0.00 :	  49d41c:       4c 89 f2                mov    %r14,%rdx
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d41f:       89 c3                   mov    %eax,%ebx
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
    0.00 :	  49d421:       e8 3a 72 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :	                        /* reset to original, non-redirected, tid */
         :	                        heapTuple->t_self = *tid;
    0.00 :	  49d426:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
         :
         :	                        if (valid)
    0.00 :	  49d42a:       84 db                   test   %bl,%bl
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
         :	                                                                                        buffer, snapshot);
         :	                        /* reset to original, non-redirected, tid */
         :	                        heapTuple->t_self = *tid;
    0.00 :	  49d42c:       8b 01                   mov    (%rcx),%eax
    0.00 :	  49d42e:       41 89 46 04             mov    %eax,0x4(%r14)
    0.00 :	  49d432:       0f b7 41 04             movzwl 0x4(%rcx),%eax
    0.00 :	  49d436:       66 41 89 46 08          mov    %ax,0x8(%r14)
         :
         :	                        if (valid)
    0.00 :	  49d43b:       0f 84 3a ff ff ff       je     49d37b <heap_hot_search_buffer+0x15b>
         :	                        {
         :	                                ItemPointerSetOffsetNumber(tid, offnum);
    0.00 :	  49d441:       66 44 89 61 04          mov    %r12w,0x4(%rcx)
         :	                                PredicateLockTuple(relation, heapTuple, snapshot);
    0.00 :	  49d446:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  49d44a:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  49d44d:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  49d451:       e8 4a 77 1f 00          callq  694ba0 <PredicateLockTuple>
         :	                                if (all_dead)
    0.00 :	  49d456:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d459:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  49d45e:       0f 84 7b fe ff ff       je     49d2df <heap_hot_search_buffer+0xbf>
         :	                                        *all_dead = false;
    0.00 :	  49d464:       41 c6 07 00             movb   $0x0,(%r15)
    0.00 :	  49d468:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  49d46d:       e9 6d fe ff ff          jmpq   49d2df <heap_hot_search_buffer+0xbf>
    0.00 :	  49d472:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d478:       84 d2                   test   %dl,%dl
    0.00 :	  49d47a:       0f 88 50 ff ff ff       js     49d3d0 <heap_hot_search_buffer+0x1b0>
    0.00 :	  49d480:       e8 9b 9c ff ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  49d485:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  49d488:       89 c7                   mov    %eax,%edi
    0.00 :	  49d48a:       e9 72 fe ff ff          jmpq   49d301 <heap_hot_search_buffer+0xe1>
    0.00 :	  49d48f:       90                      nop
         :	                /*
         :	                 * If we can't see it, maybe no one else can either.  At caller
         :	                 * request, check whether all chain members are dead to all
         :	                 * transactions.
         :	                 */
         :	                if (all_dead && *all_dead &&
    0.00 :	  49d490:       8b 35 6a d4 71 00       mov    0x71d46a(%rip),%esi        # bba900 <RecentGlobalXmin>
    0.00 :	  49d496:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49d499:       e8 62 72 30 00          callq  7a4700 <HeapTupleIsSurelyDead>
    0.00 :	  49d49e:       84 c0                   test   %al,%al
    0.00 :	  49d4a0:       0f 85 e6 fe ff ff       jne    49d38c <heap_hot_search_buffer+0x16c>
         :	                        !HeapTupleIsSurelyDead(heapTuple, RecentGlobalXmin))
         :	                        *all_dead = false;
    0.00 :	  49d4a6:       41 c6 07 00             movb   $0x0,(%r15)
    0.00 :	  49d4aa:       e9 dd fe ff ff          jmpq   49d38c <heap_hot_search_buffer+0x16c>
    0.00 :	  49d4af:       90                      nop
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
         :	        Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  49d4b0:       89 d0                   mov    %edx,%eax
    0.00 :	  49d4b2:       48 8b 15 5f fc 6d 00    mov    0x6dfc5f(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49d4b9:       f7 d0                   not    %eax
    0.00 :	  49d4bb:       48 98                   cltq   
    0.00 :	  49d4bd:       4c 8b 2c c2             mov    (%rdx,%rax,8),%r13
    0.00 :	  49d4c1:       e9 a0 fd ff ff          jmpq   49d266 <heap_hot_search_buffer+0x46>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674c30 <PinBuffer>:
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
    0.00 :	  674c30:       55                      push   %rbp
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c31:       ba 01 00 00 00          mov    $0x1,%edx
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
    0.00 :	  674c36:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674c39:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  674c3d:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  674c41:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  674c44:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  674c48:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  674c4c:       48 83 ec 20             sub    $0x20,%rsp
         :	        int                     b = buf->buf_id;
    0.00 :	  674c50:       8b 7f 24                mov    0x24(%rdi),%edi
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
  100.00 :	  674c53:       49 89 f6                mov    %rsi,%r14
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c56:       be 01 00 00 00          mov    $0x1,%esi
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674c5b:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	{
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c61:       83 c7 01                add    $0x1,%edi
    0.00 :	  674c64:       e8 b7 f8 ff ff          callq  674520 <GetPrivateRefCountEntry>
    0.00 :	  674c69:       49 89 c4                mov    %rax,%r12
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674c6c:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  674c6f:       85 c0                   test   %eax,%eax
    0.00 :	  674c71:       75 43                   jne    674cb6 <PinBuffer+0x86>
         :	        {
         :	                LockBufHdr(buf);
    0.00 :	  674c73:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  674c77:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  674c7c:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  674c7f:       84 c0                   test   %al,%al
    0.00 :	  674c81:       75 6d                   jne    674cf0 <PinBuffer+0xc0>
         :	                buf->refcount++;
    0.00 :	  674c83:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674c86:       83 c0 01                add    $0x1,%eax
         :	                if (strategy == NULL)
    0.00 :	  674c89:       4d 85 f6                test   %r14,%r14
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
         :	                buf->refcount++;
    0.00 :	  674c8c:       89 43 18                mov    %eax,0x18(%rbx)
         :	                if (strategy == NULL)
    0.00 :	  674c8f:       74 7c                   je     674d0d <PinBuffer+0xdd>
         :	                        if (buf->usage_count < BM_MAX_USAGE_COUNT)
         :	                                buf->usage_count++;
         :	                }
         :	                else
         :	                {
         :	                        if (buf->usage_count == 0)
    0.00 :	  674c91:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674c95:       66 85 c0                test   %ax,%ax
    0.00 :	  674c98:       75 06                   jne    674ca0 <PinBuffer+0x70>
         :	                                buf->usage_count = 1;
    0.00 :	  674c9a:       66 c7 43 16 01 00       movw   $0x1,0x16(%rbx)
         :	                }
         :	                result = (buf->flags & BM_VALID) != 0;
    0.00 :	  674ca0:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674ca4:       d1 e8                   shr    %eax
    0.00 :	  674ca6:       41 89 c5                mov    %eax,%r13d
    0.00 :	  674ca9:       41 83 e5 01             and    $0x1,%r13d
         :	                UnlockBufHdr(buf);
    0.00 :	  674cad:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  674cb1:       41 8b 44 24 04          mov    0x4(%r12),%eax
         :	        {
         :	                /* If we previously pinned the buffer, it must surely be valid */
         :	                result = true;
         :	        }
         :
         :	        ref->refcount++;
    0.00 :	  674cb6:       83 c0 01                add    $0x1,%eax
    0.00 :	  674cb9:       41 89 44 24 04          mov    %eax,0x4(%r12)
         :	        Assert(ref->refcount > 0);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner,
    0.00 :	  674cbe:       8b 73 24                mov    0x24(%rbx),%esi
    0.00 :	  674cc1:       48 8b 3d f8 5b 54 00    mov    0x545bf8(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674cc8:       83 c6 01                add    $0x1,%esi
    0.00 :	  674ccb:       e8 d0 54 12 00          callq  79a1a0 <ResourceOwnerRememberBuffer>
         :	                                                                BufferDescriptorGetBuffer(buf));
         :	        return result;
         :	}
    0.00 :	  674cd0:       44 89 e8                mov    %r13d,%eax
    0.00 :	  674cd3:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  674cd7:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674cdc:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  674ce1:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  674ce6:       c9                      leaveq 
    0.00 :	  674ce7:       c3                      retq   
    0.00 :	  674ce8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  674cef:       00 
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
    0.00 :	  674cf0:       ba 0c 05 00 00          mov    $0x50c,%edx
    0.00 :	  674cf5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  674cfa:       e8 41 b3 01 00          callq  690040 <s_lock>
         :	                buf->refcount++;
    0.00 :	  674cff:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674d02:       83 c0 01                add    $0x1,%eax
         :	                if (strategy == NULL)
    0.00 :	  674d05:       4d 85 f6                test   %r14,%r14
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
         :	                buf->refcount++;
    0.00 :	  674d08:       89 43 18                mov    %eax,0x18(%rbx)
         :	                if (strategy == NULL)
    0.00 :	  674d0b:       75 84                   jne    674c91 <PinBuffer+0x61>
         :	                {
         :	                        if (buf->usage_count < BM_MAX_USAGE_COUNT)
    0.00 :	  674d0d:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674d11:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  674d15:       77 89                   ja     674ca0 <PinBuffer+0x70>
         :	                                buf->usage_count++;
    0.00 :	  674d17:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674d1b:       83 c0 01                add    $0x1,%eax
    0.00 :	  674d1e:       66 89 43 16             mov    %ax,0x16(%rbx)
    0.00 :	  674d22:       e9 79 ff ff ff          jmpq   674ca0 <PinBuffer+0x70>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   80.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:248
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000677560 <StrategyGetBuffer>:
         :	 *      To ensure that no one else can pin the buffer before we do, we must
         :	 *      return the buffer with the buffer header spinlock still held.
         :	 */
         :	volatile BufferDesc *
         :	StrategyGetBuffer(BufferAccessStrategy strategy)
         :	{
    0.00 :	  677560:       55                      push   %rbp
    0.00 :	  677561:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  677564:       41 57                   push   %r15
    0.00 :	  677566:       41 56                   push   %r14
    0.00 :	  677568:       41 55                   push   %r13
    0.00 :	  67756a:       49 89 fd                mov    %rdi,%r13
    0.00 :	  67756d:       41 54                   push   %r12
    0.00 :	  67756f:       53                      push   %rbx
    0.00 :	  677570:       48 83 ec 08             sub    $0x8,%rsp
         :
         :	        /*
         :	         * If given a strategy object, see whether it can select a buffer. We
         :	         * assume strategy objects don't need buffer_strategy_lock.
         :	         */
         :	        if (strategy != NULL)
    0.00 :	  677574:       48 85 ff                test   %rdi,%rdi
    0.00 :	  677577:       74 65                   je     6775de <StrategyGetBuffer+0x7e>
         :	{
         :	        volatile BufferDesc *buf;
         :	        Buffer          bufnum;
         :
         :	        /* Advance to next ring slot */
         :	        if (++strategy->current >= strategy->ring_size)
    0.00 :	  677579:       8b 47 08                mov    0x8(%rdi),%eax
    0.00 :	  67757c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67757f:       3b 47 04                cmp    0x4(%rdi),%eax
    0.00 :	  677582:       89 47 08                mov    %eax,0x8(%rdi)
    0.00 :	  677585:       7c 09                   jl     677590 <StrategyGetBuffer+0x30>
         :	                strategy->current = 0;
    0.00 :	  677587:       c7 47 08 00 00 00 00    movl   $0x0,0x8(%rdi)
    0.00 :	  67758e:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * If the slot hasn't been filled yet, tell the caller to allocate a new
         :	         * buffer with the normal allocation strategy.  He will then fill this
         :	         * slot by calling AddBufferToRing with the new buffer.
         :	         */
         :	        bufnum = strategy->buffers[strategy->current];
    0.00 :	  677590:       48 98                   cltq   
    0.00 :	  677592:       41 8b 44 85 10          mov    0x10(%r13,%rax,4),%eax
         :	        if (bufnum == InvalidBuffer)
    0.00 :	  677597:       85 c0                   test   %eax,%eax
    0.00 :	  677599:       74 3e                   je     6775d9 <StrategyGetBuffer+0x79>
         :	         * since our own previous usage of the ring element would have left it
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
    0.00 :	  67759b:       48 98                   cltq   
    0.00 :	  67759d:       48 8d 58 ff             lea    -0x1(%rax),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  6775a1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  6775a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6775aa:       48 03 1d 4f 85 54 00    add    0x54854f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	        LockBufHdr(buf);
    0.00 :	  6775b1:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6775b5:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  6775b8:       84 c0                   test   %al,%al
    0.00 :	  6775ba:       0f 85 b8 02 00 00       jne    677878 <StrategyGetBuffer+0x318>
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
    0.00 :	  6775c0:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6775c3:       85 c0                   test   %eax,%eax
    0.00 :	  6775c5:       75 0e                   jne    6775d5 <StrategyGetBuffer+0x75>
    0.00 :	  6775c7:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  6775cb:       66 83 f8 01             cmp    $0x1,%ax
    0.00 :	  6775cf:       0f 86 92 02 00 00       jbe    677867 <StrategyGetBuffer+0x307>
         :	        {
         :	                strategy->current_was_in_ring = true;
         :	                return buf;
         :	        }
         :	        UnlockBufHdr(buf);
    0.00 :	  6775d5:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Tell caller to allocate a new buffer with the normal allocation
         :	         * strategy.  He'll then replace this ring element via AddBufferToRing.
         :	         */
         :	        strategy->current_was_in_ring = false;
    0.00 :	  6775d9:       41 c6 45 0c 00          movb   $0x0,0xc(%r13)
         :	        /*
         :	         * We count buffer allocation requests so that the bgwriter can estimate
         :	         * the rate of buffer consumption.  Note that buffers recycled by a
         :	         * strategy object are intentionally not counted here.
         :	         */
         :	        pg_atomic_fetch_add_u32(&StrategyControl->numBufferAllocs, 1);
    0.00 :	  6775de:       48 8b 05 1b 5b 50 00    mov    0x505b1b(%rip),%rax        # b7d100 <StrategyControl>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  6775e5:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  6775ea:       48 83 c0 14             add    $0x14,%rax
    0.00 :	  6775ee:       f0 0f c1 10             lock xadd %edx,(%rax)
         :	         * Since we're not guaranteed atomic 8 byte reads we need to acquire the
         :	         * spinlock if not null to be sure we get a correct pointer. Because we
         :	         * don't want to set the latch while holding the buffer_strategy_lock we
         :	         * just grab the lock to read and reset the pointer.
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  6775f2:       48 8b 15 07 5b 50 00    mov    0x505b07(%rip),%rdx        # b7d100 <StrategyControl>
         :	        if (bgwriterLatch)
    0.00 :	  6775f9:       48 83 7a 18 00          cmpq   $0x0,0x18(%rdx)
    0.00 :	  6775fe:       74 3e                   je     67763e <StrategyGetBuffer+0xde>
    0.00 :	  677600:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  677605:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677608:       84 c0                   test   %al,%al
    0.00 :	  67760a:       0f 85 21 02 00 00       jne    677831 <StrategyGetBuffer+0x2d1>
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  677610:       48 8b 05 e9 5a 50 00    mov    0x505ae9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677617:       48 8b 78 18             mov    0x18(%rax),%rdi
         :	                StrategyControl->bgwriterLatch = NULL;
    0.00 :	  67761b:       48 c7 40 18 00 00 00    movq   $0x0,0x18(%rax)
    0.00 :	  677622:       00 
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677623:       48 8b 05 d6 5a 50 00    mov    0x505ad6(%rip),%rax        # b7d100 <StrategyControl>
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  67762a:       48 85 ff                test   %rdi,%rdi
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	                StrategyControl->bgwriterLatch = NULL;
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67762d:       c6 00 00                movb   $0x0,(%rax)
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  677630:       74 05                   je     677637 <StrategyGetBuffer+0xd7>
         :	                        SetLatch(bgwriterLatch);
    0.00 :	  677632:       e8 89 1a fc ff          callq  6390c0 <SetLatch>
    0.00 :	  677637:       48 8b 15 c2 5a 50 00    mov    0x505ac2(%rip),%rdx        # b7d100 <StrategyControl>
         :	         *
         :	         * Note that the freeNext fields are considered to be protected by
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
    0.00 :	  67763e:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  677641:       85 c0                   test   %eax,%eax
    0.00 :	  677643:       0f 88 08 01 00 00       js     677751 <StrategyGetBuffer+0x1f1>
    0.00 :	  677649:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  67764e:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677651:       84 c0                   test   %al,%al
    0.00 :	  677653:       0f 85 f3 01 00 00       jne    67784c <StrategyGetBuffer+0x2ec>
    0.00 :	  677659:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  67765f:       eb 30                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677661:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
         :	                        if (buf->refcount == 0 && buf->usage_count == 0)
    0.00 :	  677668:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  67766b:       85 c0                   test   %eax,%eax
    0.00 :	  67766d:       75 0d                   jne    67767c <StrategyGetBuffer+0x11c>
    0.00 :	  67766f:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677673:       66 85 c0                test   %ax,%ax
    0.00 :	  677676:       0f 84 94 00 00 00       je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
    0.00 :	  67767c:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  677680:       44 89 e0                mov    %r12d,%eax
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677683:       48 8b 15 76 5a 50 00    mov    0x505a76(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  67768a:       f0 86 02                lock xchg %al,(%rdx)
    0.00 :	  67768d:       84 c0                   test   %al,%al
    0.00 :	  67768f:       75 5f                   jne    6776f0 <StrategyGetBuffer+0x190>
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :
         :	                while (StrategyControl->firstFreeBuffer >= 0)
    0.00 :	  677691:       48 8b 15 68 5a 50 00    mov    0x505a68(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  677698:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  67769b:       85 c0                   test   %eax,%eax
    0.00 :	  67769d:       0f 88 9d 00 00 00       js     677740 <StrategyGetBuffer+0x1e0>
         :	                {
         :	                        buf = &BufferDescriptors[StrategyControl->firstFreeBuffer];
    0.00 :	  6776a3:       48 63 d8                movslq %eax,%rbx
    0.00 :	  6776a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6776aa:       48 03 1d 4f 84 54 00    add    0x54844f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	                        Assert(buf->freeNext != FREENEXT_NOT_IN_LIST);
         :
         :	                        /* Unconditionally remove buffer from freelist */
         :	                        StrategyControl->firstFreeBuffer = buf->freeNext;
    0.00 :	  6776b1:       8b 43 28                mov    0x28(%rbx),%eax
    0.00 :	  6776b4:       89 42 08                mov    %eax,0x8(%rdx)
         :	                        buf->freeNext = FREENEXT_NOT_IN_LIST;
    0.00 :	  6776b7:       c7 43 28 fe ff ff ff    movl   $0xfffffffe,0x28(%rbx)
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776be:       48 8b 05 3b 5a 50 00    mov    0x505a3b(%rip),%rax        # b7d100 <StrategyControl>
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776c5:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776c9:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  6776cc:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6776cf:       f0 86 07                lock xchg %al,(%rdi)
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776d2:       84 c0                   test   %al,%al
    0.00 :	  6776d4:       74 92                   je     677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776d6:       ba d0 00 00 00          mov    $0xd0,%edx
    0.00 :	  6776db:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  6776e0:       e8 5b 89 01 00          callq  690040 <s_lock>
    0.00 :	  6776e5:       eb 81                   jmp    677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6776ee:       00 00 
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776f0:       48 8b 3d 09 5a 50 00    mov    0x505a09(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  6776f7:       ba da 00 00 00          mov    $0xda,%edx
    0.00 :	  6776fc:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677701:       e8 3a 89 01 00          callq  690040 <s_lock>
    0.00 :	  677706:       eb 89                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677708:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  67770f:       00 
         :	                                trycounter = NBuffers;
         :	                        }
         :	                        else
         :	                        {
         :	                                /* Found a usable buffer */
         :	                                if (strategy != NULL)
    0.00 :	  677710:       4d 85 ed                test   %r13,%r13
    0.00 :	  677713:       74 0f                   je     677724 <StrategyGetBuffer+0x1c4>
         :	 * is called with the spinlock held, it had better be quite cheap.
         :	 */
         :	static void
         :	AddBufferToRing(BufferAccessStrategy strategy, volatile BufferDesc *buf)
         :	{
         :	        strategy->buffers[strategy->current] = BufferDescriptorGetBuffer(buf);
    0.00 :	  677715:       8b 43 24                mov    0x24(%rbx),%eax
    0.00 :	  677718:       49 63 55 08             movslq 0x8(%r13),%rdx
    0.00 :	  67771c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67771f:       41 89 44 95 10          mov    %eax,0x10(%r13,%rdx,4)
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
         :	        }
         :	}
    0.00 :	  677724:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  677728:       48 89 d8                mov    %rbx,%rax
    0.00 :	  67772b:       5b                      pop    %rbx
    0.00 :	  67772c:       41 5c                   pop    %r12
    0.00 :	  67772e:       41 5d                   pop    %r13
    0.00 :	  677730:       41 5e                   pop    %r14
    0.00 :	  677732:       41 5f                   pop    %r15
    0.00 :	  677734:       c9                      leaveq 
    0.00 :	  677735:       c3                      retq   
    0.00 :	  677736:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67773d:       00 00 00 
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                }
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677740:       48 8b 05 b9 59 50 00    mov    0x5059b9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677747:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  67774a:       48 8b 15 af 59 50 00    mov    0x5059af(%rip),%rdx        # b7d100 <StrategyControl>
         :	        }
         :
         :	        /* Nothing on the freelist, so run the "clock sweep" algorithm */
         :	        trycounter = NBuffers;
    0.00 :	  677751:       44 8b 25 c8 13 4f 00    mov    0x4f13c8(%rip),%r12d        # b68b20 <NBuffers>
    0.00 :	  677758:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  67775e:       41 bf 01 00 00 00       mov    $0x1,%r15d
    0.00 :	  677764:       eb 30                   jmp    677796 <StrategyGetBuffer+0x236>
    0.00 :	  677766:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67776d:       00 00 00 
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
         :	                if (buf->refcount == 0)
         :	                {
         :	                        if (buf->usage_count > 0)
    0.00 :	  677770:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677774:       66 85 c0                test   %ax,%ax
    0.00 :	  677777:       74 97                   je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                buf->usage_count--;
    0.00 :	  677779:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  67777d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  677780:       66 89 43 16             mov    %ax,0x16(%rbx)
         :	                                trycounter = NBuffers;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:248
   20.00 :	  677784:       44 8b 25 95 13 4f 00    mov    0x4f1395(%rip),%r12d        # b68b20 <NBuffers>
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
    0.00 :	  67778b:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  67778f:       48 8b 15 6a 59 50 00    mov    0x50596a(%rip),%rdx        # b7d100 <StrategyControl>
         :	        trycounter = NBuffers;
         :	        for (;;)
         :	        {
         :	                int victim;
         :
         :	                victim = pg_atomic_fetch_add_u32(&StrategyControl->nextVictimBuffer, 1);
    0.00 :	  677796:       48 8d 42 04             lea    0x4(%rdx),%rax
    0.00 :	  67779a:       44 89 f2                mov    %r14d,%edx
    0.00 :	  67779d:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                buf = &BufferDescriptors[victim % NBuffers];
    0.00 :	  6777a1:       89 d0                   mov    %edx,%eax
    0.00 :	  6777a3:       c1 fa 1f                sar    $0x1f,%edx
    0.00 :	  6777a6:       f7 3d 74 13 4f 00       idivl  0x4f1374(%rip)        # b68b20 <NBuffers>
    0.00 :	  6777ac:       48 63 da                movslq %edx,%rbx
    0.00 :	  6777af:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6777b3:       48 03 1d 46 83 54 00    add    0x548346(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :
         :	                if (victim % NBuffers == 0)
    0.00 :	  6777ba:       85 d2                   test   %edx,%edx
    0.00 :	  6777bc:       75 12                   jne    6777d0 <StrategyGetBuffer+0x270>
         :	                {
         :	                        pg_atomic_add_fetch_u32(&StrategyControl->completePasses, 1);
    0.00 :	  6777be:       48 8b 05 3b 59 50 00    mov    0x50593b(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  6777c5:       44 89 f2                mov    %r14d,%edx
    0.00 :	  6777c8:       48 83 c0 10             add    $0x10,%rax
    0.00 :	  6777cc:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  6777d0:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6777d4:       44 89 f8                mov    %r15d,%eax
    0.00 :	  6777d7:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
   80.00 :	  6777da:       84 c0                   test   %al,%al
    0.00 :	  6777dc:       75 42                   jne    677820 <StrategyGetBuffer+0x2c0>
         :	                if (buf->refcount == 0)
    0.00 :	  6777de:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6777e1:       85 c0                   test   %eax,%eax
    0.00 :	  6777e3:       74 8b                   je     677770 <StrategyGetBuffer+0x210>
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                }
         :	                else if (--trycounter == 0)
    0.00 :	  6777e5:       41 83 ec 01             sub    $0x1,%r12d
    0.00 :	  6777e9:       75 a0                   jne    67778b <StrategyGetBuffer+0x22b>
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777eb:       ba 80 a1 8a 00          mov    $0x8aa180,%edx
    0.00 :	  6777f0:       be 0c 01 00 00          mov    $0x10c,%esi
    0.00 :	  6777f5:       bf ec a0 8a 00          mov    $0x8aa0ec,%edi
         :	                         * so all the buffers are pinned (or were when we looked at them).
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
    0.00 :	  6777fa:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777fe:       e8 1d 3c 10 00          callq  77b420 <elog_start>
    0.00 :	  677803:       be 0e a1 8a 00          mov    $0x8aa10e,%esi
    0.00 :	  677808:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67780d:       31 c0                   xor    %eax,%eax
    0.00 :	  67780f:       e8 1c 3a 10 00          callq  77b230 <elog_finish>
    0.00 :	  677814:       e8 b7 1c df ff          callq  4694d0 <abort@plt>
    0.00 :	  677819:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  677820:       ba f2 00 00 00          mov    $0xf2,%edx
    0.00 :	  677825:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67782a:       e8 11 88 01 00          callq  690040 <s_lock>
    0.00 :	  67782f:       eb ad                   jmp    6777de <StrategyGetBuffer+0x27e>
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	        if (bgwriterLatch)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677831:       48 8b 3d c8 58 50 00    mov    0x5058c8(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677838:       ba 9f 00 00 00          mov    $0x9f,%edx
    0.00 :	  67783d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677842:       e8 f9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677847:       e9 c4 fd ff ff          jmpq   677610 <StrategyGetBuffer+0xb0>
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67784c:       48 8b 3d ad 58 50 00    mov    0x5058ad(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677853:       ba b8 00 00 00          mov    $0xb8,%edx
    0.00 :	  677858:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67785d:       e8 de 87 01 00          callq  690040 <s_lock>
    0.00 :	  677862:       e9 f2 fd ff ff          jmpq   677659 <StrategyGetBuffer+0xf9>
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
         :	        {
         :	                strategy->current_was_in_ring = true;
    0.00 :	  677867:       41 c6 45 0c 01          movb   $0x1,0xc(%r13)
    0.00 :	  67786c:       e9 b3 fe ff ff          jmpq   677724 <StrategyGetBuffer+0x1c4>
    0.00 :	  677871:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
    0.00 :	  677878:       ba 20 02 00 00          mov    $0x220,%edx
    0.00 :	  67787d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677882:       e8 b9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677887:       e9 34 fd ff ff          jmpq   6775c0 <StrategyGetBuffer+0x60>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000675260 <SyncOneBuffer>:
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675260:       55                      push   %rbp
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  675261:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  675266:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  675269:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  67526d:       48 63 df                movslq %edi,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675270:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  675274:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675278:       48 c1 e3 06             shl    $0x6,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  67527c:       48 83 ec 20             sub    $0x20,%rsp
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675280:       48 03 1d 79 a8 54 00    add    0x54a879(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675287:       41 89 f5                mov    %esi,%r13d
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
    0.00 :	  67528a:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  67528e:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
  100.00 :	  675291:       84 c0                   test   %al,%al
    0.00 :	  675293:       75 5b                   jne    6752f0 <SyncOneBuffer+0x90>
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  675295:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  675298:       85 c0                   test   %eax,%eax
    0.00 :	  67529a:       75 0f                   jne    6752ab <SyncOneBuffer+0x4b>
    0.00 :	  67529c:       0f b7 43 16             movzwl 0x16(%rbx),%eax
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752a0:       41 bc 02 00 00 00       mov    $0x2,%r12d
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  6752a6:       66 85 c0                test   %ax,%ax
    0.00 :	  6752a9:       74 08                   je     6752b3 <SyncOneBuffer+0x53>
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
    0.00 :	  6752ab:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752ae:       45 84 ed                test   %r13b,%r13b
    0.00 :	  6752b1:       75 2d                   jne    6752e0 <SyncOneBuffer+0x80>
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
         :	                return result;
         :	        }
         :
         :	        if (!(bufHdr->flags & BM_VALID) || !(bufHdr->flags & BM_DIRTY))
    0.00 :	  6752b3:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752b7:       a8 02                   test   $0x2,%al
    0.00 :	  6752b9:       74 08                   je     6752c3 <SyncOneBuffer+0x63>
    0.00 :	  6752bb:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752bf:       a8 01                   test   $0x1,%al
    0.00 :	  6752c1:       75 45                   jne    675308 <SyncOneBuffer+0xa8>
         :	        {
         :	                /* It's clean, so nothing to do */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752c3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  6752c7:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6752ca:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  6752ce:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6752d2:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  6752d6:       c9                      leaveq 
    0.00 :	  6752d7:       c3                      retq   
    0.00 :	  6752d8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  6752df:       00 
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752e0:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752e3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  6752e7:       eb de                   jmp    6752c7 <SyncOneBuffer+0x67>
    0.00 :	  6752e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
    0.00 :	  6752f0:       ba 4e 07 00 00          mov    $0x74e,%edx
    0.00 :	  6752f5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6752fa:       e8 41 ad 01 00          callq  690040 <s_lock>
    0.00 :	  6752ff:       eb 94                   jmp    675295 <SyncOneBuffer+0x35>
    0.00 :	  675301:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  675308:       48 89 df                mov    %rbx,%rdi
         :	        FlushBuffer(bufHdr, NULL);
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
    0.00 :	  67530b:       41 83 cc 01             or     $0x1,%r12d
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  67530f:       e8 bc f8 ff ff          callq  674bd0 <PinBuffer_Locked>
         :	        LWLockAcquire(bufHdr->content_lock, LW_SHARED);
    0.00 :	  675314:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675318:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67531d:       e8 ce a7 01 00          callq  68faf0 <LWLockAcquire>
         :
         :	        FlushBuffer(bufHdr, NULL);
    0.00 :	  675322:       31 f6                   xor    %esi,%esi
    0.00 :	  675324:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675327:       e8 24 fc ff ff          callq  674f50 <FlushBuffer>
         :
         :	        LWLockRelease(bufHdr->content_lock);
    0.00 :	  67532c:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675330:       e8 6b a0 01 00          callq  68f3a0 <LWLockRelease>
         :	        UnpinBuffer(bufHdr, true);
    0.00 :	  675335:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67533a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  67533d:       e8 ee f9 ff ff          callq  674d30 <UnpinBuffer>
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  675342:       eb 83                   jmp    6752c7 <SyncOneBuffer+0x67>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046ef10 <slot_deform_tuple>:
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46ef10:       55                      push   %rbp
    0.00 :	  46ef11:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46ef14:       41 57                   push   %r15
    0.00 :	  46ef16:       41 89 f7                mov    %esi,%r15d
    0.00 :	  46ef19:       41 56                   push   %r14
    0.00 :	  46ef1b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  46ef1e:       41 55                   push   %r13
    0.00 :	  46ef20:       41 54                   push   %r12
    0.00 :	  46ef22:       53                      push   %rbx
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef23:       31 db                   xor    %ebx,%ebx
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46ef25:       48 83 ec 28             sub    $0x28,%rsp
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
    0.00 :	  46ef29:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  46ef2d:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46ef31:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
    0.00 :	  46ef35:       8b 77 24                mov    0x24(%rdi),%esi
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
    0.00 :	  46ef38:       4c 8b 5f 30             mov    0x30(%rdi),%r11
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46ef3c:       4c 8b 40 10             mov    0x10(%rax),%r8
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
    0.00 :	  46ef40:       41 0f b7 40 14          movzwl 0x14(%r8),%eax
    0.00 :	  46ef45:       83 e0 01                and    $0x1,%eax
    0.00 :	  46ef48:       41 89 c2                mov    %eax,%r10d
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef4b:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef4f:       31 ff                   xor    %edi,%edi
    0.00 :	  46ef51:       85 f6                   test   %esi,%esi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef53:       4c 8b 48 08             mov    0x8(%rax),%r9
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef57:       74 09                   je     46ef62 <slot_deform_tuple+0x52>
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
    0.00 :	  46ef59:       41 0f b6 7e 07          movzbl 0x7(%r14),%edi
         :	                slow = false;
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
    0.00 :	  46ef5e:       49 8b 5e 58             mov    0x58(%r14),%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef62:       41 0f b6 40 16          movzbl 0x16(%r8),%eax
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46ef67:       44 39 fe                cmp    %r15d,%esi
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef6a:       4d 8d 2c 00             lea    (%r8,%rax,1),%r13
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46ef6e:       0f 8d c0 00 00 00       jge    46f034 <slot_deform_tuple+0x124>
    0.00 :	  46ef74:       41 89 f4                mov    %esi,%r12d
    0.00 :	  46ef77:       eb 40                   jmp    46efb9 <slot_deform_tuple+0xa9>
    0.00 :	  46ef79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46ef80:       44 89 e0                mov    %r12d,%eax
    0.00 :	  46ef83:       44 89 e1                mov    %r12d,%ecx
    0.00 :	  46ef86:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46ef89:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46ef8c:       48 98                   cltq   
    0.00 :	  46ef8e:       41 0f b6 44 00 17       movzbl 0x17(%r8,%rax,1),%eax
    0.00 :	  46ef94:       d3 f8                   sar    %cl,%eax
    0.00 :	  46ef96:       a8 01                   test   $0x1,%al
    0.00 :	  46ef98:       75 2b                   jne    46efc5 <slot_deform_tuple+0xb5>
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46ef9a:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
         :	                        isnull[attnum] = true;
    0.00 :	  46ef9e:       bf 01 00 00 00          mov    $0x1,%edi
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46efa3:       48 c7 04 f2 00 00 00    movq   $0x0,(%rdx,%rsi,8)
    0.00 :	  46efaa:       00 
         :	                        isnull[attnum] = true;
    0.00 :	  46efab:       41 c6 04 33 01          movb   $0x1,(%r11,%rsi,1)
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46efb0:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  46efb4:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46efb7:       7e 78                   jle    46f031 <slot_deform_tuple+0x121>
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
    0.00 :	  46efb9:       49 63 f4                movslq %r12d,%rsi
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46efbc:       45 84 d2                test   %r10b,%r10b
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
    0.00 :	  46efbf:       49 8b 14 f1             mov    (%r9,%rsi,8),%rdx
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46efc3:       75 bb                   jne    46ef80 <slot_deform_tuple+0x70>
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
    0.00 :	  46efc5:       40 84 ff                test   %dil,%dil
         :	                        isnull[attnum] = true;
         :	                        slow = true;            /* can't use attcacheoff anymore */
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
    0.00 :	  46efc8:       41 c6 04 33 00          movb   $0x0,(%r11,%rsi,1)
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
    0.00 :	  46efcd:       0f 85 7d 00 00 00       jne    46f050 <slot_deform_tuple+0x140>
    0.00 :	  46efd3:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  46efd6:       85 c0                   test   %eax,%eax
    0.00 :	  46efd8:       78 76                   js     46f050 <slot_deform_tuple+0x140>
         :	                        off = thisatt->attcacheoff;
    0.00 :	  46efda:       48 63 d8                movslq %eax,%rbx
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
   50.00 :	  46efdd:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  46efe1:       49 8d 44 1d 00          lea    0x0(%r13,%rbx,1),%rax
    0.00 :	  46efe6:       74 28                   je     46f010 <slot_deform_tuple+0x100>
    0.00 :	  46efe8:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    0.00 :	  46efec:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  46eff0:       0f 84 3a 01 00 00       je     46f130 <slot_deform_tuple+0x220>
    0.00 :	  46eff6:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  46effa:       0f 84 90 01 00 00       je     46f190 <slot_deform_tuple+0x280>
    0.00 :	  46f000:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  46f004:       0f 84 a6 01 00 00       je     46f1b0 <slot_deform_tuple+0x2a0>
    0.00 :	  46f00a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
    0.00 :	  46f010:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
    0.00 :	  46f014:       48 89 04 f1             mov    %rax,(%rcx,%rsi,8)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f018:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    0.00 :	  46f01c:       66 85 c0                test   %ax,%ax
    0.00 :	  46f01f:       7e 6f                   jle    46f090 <slot_deform_tuple+0x180>
    0.00 :	  46f021:       48 0f bf c0             movswq %ax,%rax
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
   50.00 :	  46f025:       41 83 c4 01             add    $0x1,%r12d
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f029:       48 01 c3                add    %rax,%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46f02c:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46f02f:       7f 88                   jg     46efb9 <slot_deform_tuple+0xa9>
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46f031:       44 89 fe                mov    %r15d,%esi
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
    0.00 :	  46f034:       49 89 5e 58             mov    %rbx,0x58(%r14)
         :	        }
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
    0.00 :	  46f038:       41 89 76 24             mov    %esi,0x24(%r14)
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
    0.00 :	  46f03c:       41 88 7e 07             mov    %dil,0x7(%r14)
         :	}
    0.00 :	  46f040:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46f044:       5b                      pop    %rbx
    0.00 :	  46f045:       41 5c                   pop    %r12
    0.00 :	  46f047:       41 5d                   pop    %r13
    0.00 :	  46f049:       41 5e                   pop    %r14
    0.00 :	  46f04b:       41 5f                   pop    %r15
    0.00 :	  46f04d:       c9                      leaveq 
    0.00 :	  46f04e:       c3                      retq   
    0.00 :	  46f04f:       90                      nop
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
         :	                        off = thisatt->attcacheoff;
         :	                else if (thisatt->attlen == -1)
    0.00 :	  46f050:       66 83 7a 4c ff          cmpw   $0xffff,0x4c(%rdx)
    0.00 :	  46f055:       74 71                   je     46f0c8 <slot_deform_tuple+0x1b8>
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f057:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f05b:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f05d:       0f 84 1d 01 00 00       je     46f180 <slot_deform_tuple+0x270>
    0.00 :	  46f063:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f065:       74 10                   je     46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f067:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f069:       0f 84 51 01 00 00       je     46f1c0 <slot_deform_tuple+0x2b0>
    0.00 :	  46f06f:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f073:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
         :
         :	                        if (!slow)
    0.00 :	  46f077:       40 84 ff                test   %dil,%dil
    0.00 :	  46f07a:       0f 85 5d ff ff ff       jne    46efdd <slot_deform_tuple+0xcd>
         :	                                thisatt->attcacheoff = off;
    0.00 :	  46f080:       89 5a 54                mov    %ebx,0x54(%rdx)
    0.00 :	  46f083:       e9 55 ff ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f088:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46f08f:       00 
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f090:       66 83 c0 01             add    $0x1,%ax
    0.00 :	  46f094:       0f 85 a6 00 00 00       jne    46f140 <slot_deform_tuple+0x230>
    0.00 :	  46f09a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
    0.00 :	  46f0a0:       3c 01                   cmp    $0x1,%al
    0.00 :	  46f0a2:       0f 84 50 01 00 00       je     46f1f8 <slot_deform_tuple+0x2e8>
    0.00 :	  46f0a8:       a8 01                   test   $0x1,%al
    0.00 :	  46f0aa:       0f 85 20 01 00 00       jne    46f1d0 <slot_deform_tuple+0x2c0>
    0.00 :	  46f0b0:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
    0.00 :	  46f0b5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  46f0b8:       89 c0                   mov    %eax,%eax
    0.00 :	  46f0ba:       48 8d 1c 18             lea    (%rax,%rbx,1),%rbx
    0.00 :	  46f0be:       e9 ad 00 00 00          jmpq   46f170 <slot_deform_tuple+0x260>
    0.00 :	  46f0c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
    0.00 :	  46f0c8:       40 84 ff                test   %dil,%dil
    0.00 :	  46f0cb:       75 26                   jne    46f0f3 <slot_deform_tuple+0x1e3>
    0.00 :	  46f0cd:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f0d1:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f0d3:       0f 84 4f 01 00 00       je     46f228 <slot_deform_tuple+0x318>
    0.00 :	  46f0d9:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f0db:       74 a3                   je     46f080 <slot_deform_tuple+0x170>
    0.00 :	  46f0dd:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f0df:       90                      nop
    0.00 :	  46f0e0:       0f 84 52 01 00 00       je     46f238 <slot_deform_tuple+0x328>
    0.00 :	  46f0e6:       48 8d 43 01             lea    0x1(%rbx),%rax
    0.00 :	  46f0ea:       48 83 e0 fe             and    $0xfffffffffffffffe,%rax
    0.00 :	  46f0ee:       48 39 d8                cmp    %rbx,%rax
    0.00 :	  46f0f1:       74 8d                   je     46f080 <slot_deform_tuple+0x170>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f0f3:       41 80 7c 1d 00 00       cmpb   $0x0,0x0(%r13,%rbx,1)
    0.00 :	  46f0f9:       0f 85 a1 00 00 00       jne    46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f0ff:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f103:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f105:       0f 84 d5 00 00 00       je     46f1e0 <slot_deform_tuple+0x2d0>
    0.00 :	  46f10b:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f10d:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f110:       0f 84 8a 00 00 00       je     46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f116:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f118:       0f 84 27 01 00 00       je     46f245 <slot_deform_tuple+0x335>
    0.00 :	  46f11e:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f122:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f127:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
    0.00 :	  46f12b:       e9 ad fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f130:       49 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%rax
    0.00 :	  46f135:       e9 d6 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f13a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f140:       49 8d 7c 1d 00          lea    0x0(%r13,%rbx,1),%rdi
    0.00 :	  46f145:       4c 89 45 c8             mov    %r8,-0x38(%rbp)
    0.00 :	  46f149:       4c 89 4d c0             mov    %r9,-0x40(%rbp)
    0.00 :	  46f14d:       44 88 55 b8             mov    %r10b,-0x48(%rbp)
    0.00 :	  46f151:       4c 89 5d b0             mov    %r11,-0x50(%rbp)
    0.00 :	  46f155:       e8 f6 a6 ff ff          callq  469850 <strlen@plt>
    0.00 :	  46f15a:       44 0f b6 55 b8          movzbl -0x48(%rbp),%r10d
    0.00 :	  46f15f:       4c 8b 45 c8             mov    -0x38(%rbp),%r8
    0.00 :	  46f163:       48 8d 5c 03 01          lea    0x1(%rbx,%rax,1),%rbx
    0.00 :	  46f168:       4c 8b 4d c0             mov    -0x40(%rbp),%r9
    0.00 :	  46f16c:       4c 8b 5d b0             mov    -0x50(%rbp),%r11
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
         :	}
    0.00 :	  46f170:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f175:       e9 36 fe ff ff          jmpq   46efb0 <slot_deform_tuple+0xa0>
    0.00 :	  46f17a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f180:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f184:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
    0.00 :	  46f188:       e9 ea fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f18d:       0f 1f 00                nopl   (%rax)
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f190:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
    0.00 :	  46f195:       e9 76 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f19a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
    0.00 :	  46f1a0:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1a5:       e9 33 fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f1b0:       41 0f b7 44 1d 00       movzwl 0x0(%r13,%rbx,1),%eax
    0.00 :	  46f1b6:       e9 55 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f1bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f1c0:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f1c4:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f1c8:       e9 aa fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f1cd:       0f 1f 00                nopl   (%rax)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1d0:       d0 e8                   shr    %al
    0.00 :	  46f1d2:       0f b6 c0                movzbl %al,%eax
    0.00 :	  46f1d5:       e9 e0 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f1da:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (!slow &&
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f1e0:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f1e4:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1e9:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
    0.00 :	  46f1ed:       e9 eb fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1f8:       41 0f b6 54 1d 01       movzbl 0x1(%r13,%rbx,1),%edx
    0.00 :	  46f1fe:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  46f203:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  46f206:       0f 84 ae fe ff ff       je     46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f20c:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  46f20f:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  46f214:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  46f219:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  46f21d:       e9 98 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f222:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
    0.00 :	  46f228:       48 8d 43 03             lea    0x3(%rbx),%rax
    0.00 :	  46f22c:       48 83 e0 fc             and    $0xfffffffffffffffc,%rax
    0.00 :	  46f230:       e9 b9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
    0.00 :	  46f235:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f238:       48 8d 43 07             lea    0x7(%rbx),%rax
    0.00 :	  46f23c:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	  46f240:       e9 a9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f245:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f249:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f24e:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f252:       e9 86 fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:645
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:717
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005e3350 <tbm_iterate>:
         :	 * be examined, but the condition must be rechecked anyway.  (For ease of
         :	 * testing, recheck is always set true when ntuples < 0.)
         :	 */
         :	TBMIterateResult *
         :	tbm_iterate(TBMIterator *iterator)
         :	{
    0.00 :	  5e3350:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:645
   50.00 :	  5e3351:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5e3354:       53                      push   %rbx
         :	        TIDBitmap  *tbm = iterator->tbm;
    0.00 :	  5e3355:       4c 8b 1f                mov    (%rdi),%r11
         :
         :	        /*
         :	         * If lossy chunk pages remain, make sure we've advanced schunkptr/
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
    0.00 :	  5e3358:       44 8b 57 0c             mov    0xc(%rdi),%r10d
         :	 */
         :	TBMIterateResult *
         :	tbm_iterate(TBMIterator *iterator)
         :	{
         :	        TIDBitmap  *tbm = iterator->tbm;
         :	        TBMIterateResult *output = &(iterator->output);
    0.00 :	  5e335c:       48 8d 5f 14             lea    0x14(%rdi),%rbx
         :
         :	        /*
         :	         * If lossy chunk pages remain, make sure we've advanced schunkptr/
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
    0.00 :	  5e3360:       45 3b 53 2c             cmp    0x2c(%r11),%r10d
    0.00 :	  5e3364:       0f 8d 9f 00 00 00       jge    5e3409 <tbm_iterate+0xb9>
         :	                while (schunkbit < PAGES_PER_CHUNK)
         :	                {
         :	                        int                     wordnum = WORDNUM(schunkbit);
         :	                        int                     bitnum = BITNUM(schunkbit);
         :
         :	                        if ((chunk->words[wordnum] & ((bitmapword) 1 << bitnum)) != 0)
    0.00 :	  5e336a:       41 b9 01 00 00 00       mov    $0x1,%r9d
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
         :	                int                     schunkbit = iterator->schunkbit;
    0.00 :	  5e3370:       8b 77 10                mov    0x10(%rdi),%esi
         :	         * If lossy chunk pages remain, make sure we've advanced schunkptr/
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
    0.00 :	  5e3373:       49 8b 43 70             mov    0x70(%r11),%rax
    0.00 :	  5e3377:       49 63 d2                movslq %r10d,%rdx
         :	                int                     schunkbit = iterator->schunkbit;
         :
         :	                while (schunkbit < PAGES_PER_CHUNK)
    0.00 :	  5e337a:       81 fe ff 00 00 00       cmp    $0xff,%esi
         :	         * If lossy chunk pages remain, make sure we've advanced schunkptr/
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
    0.00 :	  5e3380:       4c 8b 04 d0             mov    (%rax,%rdx,8),%r8
         :	                int                     schunkbit = iterator->schunkbit;
         :
         :	                while (schunkbit < PAGES_PER_CHUNK)
    0.00 :	  5e3384:       7f 68                   jg     5e33ee <tbm_iterate+0x9e>
         :	                {
         :	                        int                     wordnum = WORDNUM(schunkbit);
         :	                        int                     bitnum = BITNUM(schunkbit);
         :
         :	                        if ((chunk->words[wordnum] & ((bitmapword) 1 << bitnum)) != 0)
    0.00 :	  5e3386:       8d 56 1f                lea    0x1f(%rsi),%edx
    0.00 :	  5e3389:       85 f6                   test   %esi,%esi
    0.00 :	  5e338b:       89 f0                   mov    %esi,%eax
    0.00 :	  5e338d:       0f 49 d6                cmovns %esi,%edx
    0.00 :	  5e3390:       c1 f8 1f                sar    $0x1f,%eax
    0.00 :	  5e3393:       c1 e8 1b                shr    $0x1b,%eax
    0.00 :	  5e3396:       c1 fa 05                sar    $0x5,%edx
    0.00 :	  5e3399:       8d 0c 06                lea    (%rsi,%rax,1),%ecx
    0.00 :	  5e339c:       48 63 d2                movslq %edx,%rdx
    0.00 :	  5e339f:       83 e1 1f                and    $0x1f,%ecx
    0.00 :	  5e33a2:       29 c1                   sub    %eax,%ecx
    0.00 :	  5e33a4:       44 89 c8                mov    %r9d,%eax
    0.00 :	  5e33a7:       d3 e0                   shl    %cl,%eax
    0.00 :	  5e33a9:       41 85 44 90 08          test   %eax,0x8(%r8,%rdx,4)
    0.00 :	  5e33ae:       74 33                   je     5e33e3 <tbm_iterate+0x93>
    0.00 :	  5e33b0:       eb 6e                   jmp    5e3420 <tbm_iterate+0xd0>
    0.00 :	  5e33b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5e33b8:       89 f0                   mov    %esi,%eax
    0.00 :	  5e33ba:       c1 f8 1f                sar    $0x1f,%eax
    0.00 :	  5e33bd:       c1 e8 1b                shr    $0x1b,%eax
    0.00 :	  5e33c0:       8d 0c 06                lea    (%rsi,%rax,1),%ecx
    0.00 :	  5e33c3:       83 e1 1f                and    $0x1f,%ecx
    0.00 :	  5e33c6:       29 c1                   sub    %eax,%ecx
    0.00 :	  5e33c8:       44 89 c8                mov    %r9d,%eax
    0.00 :	  5e33cb:       d3 e0                   shl    %cl,%eax
    0.00 :	  5e33cd:       85 f6                   test   %esi,%esi
    0.00 :	  5e33cf:       89 c1                   mov    %eax,%ecx
    0.00 :	  5e33d1:       8d 46 1f                lea    0x1f(%rsi),%eax
    0.00 :	  5e33d4:       0f 49 c6                cmovns %esi,%eax
    0.00 :	  5e33d7:       c1 f8 05                sar    $0x5,%eax
    0.00 :	  5e33da:       48 98                   cltq   
    0.00 :	  5e33dc:       41 85 4c 80 08          test   %ecx,0x8(%r8,%rax,4)
    0.00 :	  5e33e1:       75 3d                   jne    5e3420 <tbm_iterate+0xd0>
         :	                                break;
         :	                        schunkbit++;
    0.00 :	  5e33e3:       83 c6 01                add    $0x1,%esi
         :	        while (iterator->schunkptr < tbm->nchunks)
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
         :	                int                     schunkbit = iterator->schunkbit;
         :
         :	                while (schunkbit < PAGES_PER_CHUNK)
    0.00 :	  5e33e6:       81 fe 00 01 00 00       cmp    $0x100,%esi
    0.00 :	  5e33ec:       75 ca                   jne    5e33b8 <tbm_iterate+0x68>
         :	                {
         :	                        iterator->schunkbit = schunkbit;
         :	                        break;
         :	                }
         :	                /* advance to next chunk */
         :	                iterator->schunkptr++;
    0.00 :	  5e33ee:       41 8d 42 01             lea    0x1(%r10),%eax
         :	                iterator->schunkbit = 0;
    0.00 :	  5e33f2:       c7 47 10 00 00 00 00    movl   $0x0,0x10(%rdi)
         :	                {
         :	                        iterator->schunkbit = schunkbit;
         :	                        break;
         :	                }
         :	                /* advance to next chunk */
         :	                iterator->schunkptr++;
    0.00 :	  5e33f9:       89 47 0c                mov    %eax,0xc(%rdi)
         :
         :	        /*
         :	         * If lossy chunk pages remain, make sure we've advanced schunkptr/
         :	         * schunkbit to the next set bit.
         :	         */
         :	        while (iterator->schunkptr < tbm->nchunks)
    0.00 :	  5e33fc:       41 3b 43 2c             cmp    0x2c(%r11),%eax
    0.00 :	  5e3400:       41 89 c2                mov    %eax,%r10d
    0.00 :	  5e3403:       0f 8c 67 ff ff ff       jl     5e3370 <tbm_iterate+0x20>
         :	                        iterator->schunkbit++;
         :	                        return output;
         :	                }
         :	        }
         :
         :	        if (iterator->spageptr < tbm->npages)
    0.00 :	  5e3409:       8b 77 08                mov    0x8(%rdi),%esi
    0.00 :	  5e340c:       41 3b 73 28             cmp    0x28(%r11),%esi
    0.00 :	  5e3410:       7c 44                   jl     5e3456 <tbm_iterate+0x106>
    0.00 :	  5e3412:       31 db                   xor    %ebx,%ebx
    0.00 :	  5e3414:       e9 c9 00 00 00          jmpq   5e34e2 <tbm_iterate+0x192>
    0.00 :	  5e3419:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                break;
         :	                        schunkbit++;
         :	                }
         :	                if (schunkbit < PAGES_PER_CHUNK)
         :	                {
         :	                        iterator->schunkbit = schunkbit;
    0.00 :	  5e3420:       89 77 10                mov    %esi,0x10(%rdi)
         :
         :	        /*
         :	         * If both chunk and per-page data remain, must output the numerically
         :	         * earlier page.
         :	         */
         :	        if (iterator->schunkptr < tbm->nchunks)
    0.00 :	  5e3423:       8b 47 0c                mov    0xc(%rdi),%eax
    0.00 :	  5e3426:       41 3b 43 2c             cmp    0x2c(%r11),%eax
    0.00 :	  5e342a:       7d dd                   jge    5e3409 <tbm_iterate+0xb9>
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
         :	                BlockNumber chunk_blockno;
         :
         :	                chunk_blockno = chunk->blockno + iterator->schunkbit;
    0.00 :	  5e342c:       49 8b 53 70             mov    0x70(%r11),%rdx
    0.00 :	  5e3430:       48 98                   cltq   
    0.00 :	  5e3432:       89 f1                   mov    %esi,%ecx
         :	                if (iterator->spageptr >= tbm->npages ||
    0.00 :	  5e3434:       8b 77 08                mov    0x8(%rdi),%esi
         :	        if (iterator->schunkptr < tbm->nchunks)
         :	        {
         :	                PagetableEntry *chunk = tbm->schunks[iterator->schunkptr];
         :	                BlockNumber chunk_blockno;
         :
         :	                chunk_blockno = chunk->blockno + iterator->schunkbit;
    0.00 :	  5e3437:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  5e343b:       03 08                   add    (%rax),%ecx
         :	                if (iterator->spageptr >= tbm->npages ||
    0.00 :	  5e343d:       41 3b 73 28             cmp    0x28(%r11),%esi
    0.00 :	  5e3441:       0f 8d 89 00 00 00       jge    5e34d0 <tbm_iterate+0x180>
    0.00 :	  5e3447:       49 8b 53 68             mov    0x68(%r11),%rdx
    0.00 :	  5e344b:       48 63 c6                movslq %esi,%rax
    0.00 :	  5e344e:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  5e3452:       3b 08                   cmp    (%rax),%ecx
    0.00 :	  5e3454:       72 7a                   jb     5e34d0 <tbm_iterate+0x180>
         :	                PagetableEntry *page;
         :	                int                     ntuples;
         :	                int                     wordnum;
         :
         :	                /* In ONE_PAGE state, we don't allocate an spages[] array */
         :	                if (tbm->status == TBM_ONE_PAGE)
    0.00 :	  5e3456:       41 83 7b 10 01          cmpl   $0x1,0x10(%r11)
         :	                        page = &tbm->entry1;
    0.00 :	  5e345b:       49 8d 53 34             lea    0x34(%r11),%rdx
         :	                PagetableEntry *page;
         :	                int                     ntuples;
         :	                int                     wordnum;
         :
         :	                /* In ONE_PAGE state, we don't allocate an spages[] array */
         :	                if (tbm->status == TBM_ONE_PAGE)
    0.00 :	  5e345f:       74 0b                   je     5e346c <tbm_iterate+0x11c>
         :	                        page = &tbm->entry1;
         :	                else
         :	                        page = tbm->spages[iterator->spageptr];
    0.00 :	  5e3461:       49 8b 43 68             mov    0x68(%r11),%rax
    0.00 :	  5e3465:       48 63 d6                movslq %esi,%rdx
    0.00 :	  5e3468:       48 8b 14 d0             mov    (%rax,%rdx,8),%rdx
    0.00 :	  5e346c:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5e346f:       45 31 c9                xor    %r9d,%r9d
    0.00 :	  5e3472:       41 ba 01 00 00 00       mov    $0x1,%r10d
    0.00 :	  5e3478:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5e347f:       00 
         :
         :	                /* scan bitmap to extract individual offset numbers */
         :	                ntuples = 0;
         :	                for (wordnum = 0; wordnum < WORDS_PER_PAGE; wordnum++)
         :	                {
         :	                        bitmapword      w = page->words[wordnum];
 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:717
   50.00 :	  5e3480:       42 8b 4c 0a 08          mov    0x8(%rdx,%r9,1),%ecx
         :
         :	                        if (w != 0)
    0.00 :	  5e3485:       85 c9                   test   %ecx,%ecx
    0.00 :	  5e3487:       74 1f                   je     5e34a8 <tbm_iterate+0x158>
    0.00 :	  5e3489:       44 89 d6                mov    %r10d,%esi
    0.00 :	  5e348c:       eb 05                   jmp    5e3493 <tbm_iterate+0x143>
    0.00 :	  5e348e:       66 90                   xchg   %ax,%ax
         :
         :	                                while (w != 0)
         :	                                {
         :	                                        if (w & 1)
         :	                                                output->offsets[ntuples++] = (OffsetNumber) off;
         :	                                        off++;
    0.00 :	  5e3490:       83 c6 01                add    $0x1,%esi
         :	                        {
         :	                                int                     off = wordnum * BITS_PER_BITMAPWORD + 1;
         :
         :	                                while (w != 0)
         :	                                {
         :	                                        if (w & 1)
    0.00 :	  5e3493:       f6 c1 01                test   $0x1,%cl
    0.00 :	  5e3496:       74 0c                   je     5e34a4 <tbm_iterate+0x154>
         :	                                                output->offsets[ntuples++] = (OffsetNumber) off;
    0.00 :	  5e3498:       49 63 c0                movslq %r8d,%rax
    0.00 :	  5e349b:       41 83 c0 01             add    $0x1,%r8d
    0.00 :	  5e349f:       66 89 74 47 1e          mov    %si,0x1e(%rdi,%rax,2)
         :
         :	                        if (w != 0)
         :	                        {
         :	                                int                     off = wordnum * BITS_PER_BITMAPWORD + 1;
         :
         :	                                while (w != 0)
    0.00 :	  5e34a4:       d1 e9                   shr    %ecx
    0.00 :	  5e34a6:       75 e8                   jne    5e3490 <tbm_iterate+0x140>
         :	                                {
         :	                                        if (w & 1)
         :	                                                output->offsets[ntuples++] = (OffsetNumber) off;
         :	                                        off++;
    0.00 :	  5e34a8:       49 83 c1 04             add    $0x4,%r9
    0.00 :	  5e34ac:       41 83 c2 20             add    $0x20,%r10d
         :	                else
         :	                        page = tbm->spages[iterator->spageptr];
         :
         :	                /* scan bitmap to extract individual offset numbers */
         :	                ntuples = 0;
         :	                for (wordnum = 0; wordnum < WORDS_PER_PAGE; wordnum++)
    0.00 :	  5e34b0:       49 83 f9 28             cmp    $0x28,%r9
    0.00 :	  5e34b4:       75 ca                   jne    5e3480 <tbm_iterate+0x130>
         :	                                        off++;
         :	                                        w >>= 1;
         :	                                }
         :	                        }
         :	                }
         :	                output->blockno = page->blockno;
    0.00 :	  5e34b6:       8b 02                   mov    (%rdx),%eax
         :	                output->ntuples = ntuples;
    0.00 :	  5e34b8:       44 89 47 18             mov    %r8d,0x18(%rdi)
         :	                                        off++;
         :	                                        w >>= 1;
         :	                                }
         :	                        }
         :	                }
         :	                output->blockno = page->blockno;
    0.00 :	  5e34bc:       89 47 14                mov    %eax,0x14(%rdi)
         :	                output->ntuples = ntuples;
         :	                output->recheck = page->recheck;
    0.00 :	  5e34bf:       0f b6 42 05             movzbl 0x5(%rdx),%eax
         :	                iterator->spageptr++;
    0.00 :	  5e34c3:       83 47 08 01             addl   $0x1,0x8(%rdi)
         :	                                }
         :	                        }
         :	                }
         :	                output->blockno = page->blockno;
         :	                output->ntuples = ntuples;
         :	                output->recheck = page->recheck;
    0.00 :	  5e34c7:       88 47 1c                mov    %al,0x1c(%rdi)
         :	                return output;
         :	        }
         :
         :	        /* Nothing more in the bitmap */
         :	        return NULL;
         :	}
    0.00 :	  5e34ca:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5e34cd:       5b                      pop    %rbx
    0.00 :	  5e34ce:       c9                      leaveq 
    0.00 :	  5e34cf:       c3                      retq   
         :	                {
         :	                        /* Return a lossy page indicator from the chunk */
         :	                        output->blockno = chunk_blockno;
         :	                        output->ntuples = -1;
         :	                        output->recheck = true;
         :	                        iterator->schunkbit++;
    0.00 :	  5e34d0:       83 47 10 01             addl   $0x1,0x10(%rdi)
         :	                chunk_blockno = chunk->blockno + iterator->schunkbit;
         :	                if (iterator->spageptr >= tbm->npages ||
         :	                        chunk_blockno < tbm->spages[iterator->spageptr]->blockno)
         :	                {
         :	                        /* Return a lossy page indicator from the chunk */
         :	                        output->blockno = chunk_blockno;
    0.00 :	  5e34d4:       89 4f 14                mov    %ecx,0x14(%rdi)
         :	                        output->ntuples = -1;
    0.00 :	  5e34d7:       c7 47 18 ff ff ff ff    movl   $0xffffffff,0x18(%rdi)
         :	                        output->recheck = true;
    0.00 :	  5e34de:       c6 47 1c 01             movb   $0x1,0x1c(%rdi)
         :	                return output;
         :	        }
         :
         :	        /* Nothing more in the bitmap */
         :	        return NULL;
         :	}
    0.00 :	  5e34e2:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5e34e5:       5b                      pop    %rbx
    0.00 :	  5e34e6:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:666
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068eec0 <LWLockAttemptLock>:
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
    0.00 :	  68eec0:       55                      push   %rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec1:       48 85 d2                test   %rdx,%rdx
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
    0.00 :	  68eec4:       48 89 e5                mov    %rsp,%rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec7:       74 03                   je     68eecc <LWLockAttemptLock+0xc>
         :	                *potentially_spurious = false;
    0.00 :	  68eec9:       c6 02 00                movb   $0x0,(%rdx)
         :
         :	        if (mode == LW_EXCLUSIVE)
    0.00 :	  68eecc:       85 f6                   test   %esi,%esi
    0.00 :	  68eece:       75 28                   jne    68eef8 <LWLockAttemptLock+0x38>
         :	#ifndef PG_HAVE_ATOMIC_READ_U32
         :	#define PG_HAVE_ATOMIC_READ_U32
         :	static inline uint32
         :	pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
         :	{
         :	        return *(&ptr->value);
    0.00 :	  68eed0:       8b 47 04                mov    0x4(%rdi),%eax
         :	                 * First check whether the variable is free without a atomic
         :	                 * operation; it's often quite a bit cheaper for contended
         :	                 * locks. Doing so can cause a superflous shared-exclusive cacheline
         :	                 * transition, but benchmarks show that it's still worth doing so.
         :	                 */
         :	                expected = pg_atomic_read_u32(&lock->lockcount);
    0.00 :	  68eed3:       48 8d 57 04             lea    0x4(%rdi),%rdx
         :
         :	                if (expected != 0)
    0.00 :	  68eed7:       85 c0                   test   %eax,%eax
    0.00 :	  68eed9:       75 65                   jne    68ef40 <LWLockAttemptLock+0x80>
         :
         :	        /*
         :	         * Perform cmpxchg and use the zero flag which it implicitly sets when
         :	         * equal to measure the success.
         :	         */
         :	        __asm__ __volatile__(
    0.00 :	  68eedb:       b9 00 00 00 40          mov    $0x40000000,%ecx
    0.00 :	  68eee0:       89 f0                   mov    %esi,%eax
    0.00 :	  68eee2:       f0 0f b1 0a             lock cmpxchg %ecx,(%rdx)
    0.00 :	  68eee6:       40 0f 94 c6             sete   %sil
    0.00 :	  68eeea:       40 84 f6                test   %sil,%sil
    0.00 :	  68eeed:       0f 94 c1                sete   %cl
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68eef0:       89 c8                   mov    %ecx,%eax
    0.00 :	  68eef2:       c9                      leaveq 
    0.00 :	  68eef3:       c3                      retq   
    0.00 :	  68eef4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                /*
         :	                 * If the caller is interested in spurious locks, do an unlocked check
         :	                 * first.  This is useful if potentially spurious results have a
         :	                 * noticeable cost.
         :	                 */
         :	                if (potentially_spurious != NULL &&
    0.00 :	  68eef8:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68eefb:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68eeff:       74 0e                   je     68ef0f <LWLockAttemptLock+0x4f>
    0.00 :	  68ef01:       8b 47 04                mov    0x4(%rdi),%eax
    0.00 :	  68ef04:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68ef08:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef0d:       77 31                   ja     68ef40 <LWLockAttemptLock+0x80>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68ef0f:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  68ef14:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                 * might have to back out again if it turns out somebody else has an
         :	                 * exclusive lock.
         :	                 */
         :	                oldstate = pg_atomic_fetch_add_u32(&lock->lockcount, 1);
         :
         :	                if (oldstate >= EXCLUSIVE_LOCK)
  100.00 :	  68ef18:       31 c9                   xor    %ecx,%ecx
    0.00 :	  68ef1a:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef1f:       76 cf                   jbe    68eef0 <LWLockAttemptLock+0x30>
    0.00 :	  68ef21:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68ef26:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                         * problems exist.
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
    0.00 :	  68ef2a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68ef2d:       74 11                   je     68ef40 <LWLockAttemptLock+0x80>
         :	                                *potentially_spurious = true;
    0.00 :	  68ef2f:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  68ef34:       c6 02 01                movb   $0x1,(%rdx)
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef37:       89 c8                   mov    %ecx,%eax
    0.00 :	  68ef39:       c9                      leaveq 
    0.00 :	  68ef3a:       c3                      retq   
    0.00 :	  68ef3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
         :	                                *potentially_spurious = true;
    0.00 :	  68ef40:       b9 01 00 00 00          mov    $0x1,%ecx
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef45:       c9                      leaveq 
    0.00 :	  68ef46:       89 c8                   mov    %ecx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000757d90 <bcTruelen>:
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
    0.00 :	  757d90:       55                      push   %rbp
         :	        char       *s = VARDATA_ANY(arg);
    0.00 :	  757d91:       0f b6 17                movzbl (%rdi),%edx
    0.00 :	  757d94:       48 8d 4f 01             lea    0x1(%rdi),%rcx
    0.00 :	  757d98:       48 8d 47 04             lea    0x4(%rdi),%rax
    0.00 :	  757d9c:       be 01 00 00 00          mov    $0x1,%esi
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
    0.00 :	  757da1:       48 89 e5                mov    %rsp,%rbp
         :	        char       *s = VARDATA_ANY(arg);
    0.00 :	  757da4:       21 d6                   and    %edx,%esi
    0.00 :	  757da6:       48 0f 44 c8             cmove  %rax,%rcx
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
    0.00 :	  757daa:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  757dad:       74 51                   je     757e00 <bcTruelen+0x70>
    0.00 :	  757daf:       85 f6                   test   %esi,%esi
    0.00 :	  757db1:       75 3d                   jne    757df0 <bcTruelen+0x60>
    0.00 :	  757db3:       8b 07                   mov    (%rdi),%eax
    0.00 :	  757db5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  757db8:       83 e8 04                sub    $0x4,%eax
         :	        for (i = len - 1; i >= 0; i--)
    0.00 :	  757dbb:       89 c2                   mov    %eax,%edx
    0.00 :	  757dbd:       83 ea 01                sub    $0x1,%edx
    0.00 :	  757dc0:       78 20                   js     757de2 <bcTruelen+0x52>
    0.00 :	  757dc2:       48 63 f2                movslq %edx,%rsi
         :	        {
         :	                if (s[i] != ' ')
    0.00 :	  757dc5:       80 3c 31 20             cmpb   $0x20,(%rcx,%rsi,1)
   50.00 :	  757dc9:       74 0e                   je     757dd9 <bcTruelen+0x49>
    0.00 :	  757dcb:       eb 15                   jmp    757de2 <bcTruelen+0x52>
    0.00 :	  757dcd:       0f 1f 00                nopl   (%rax)
    0.00 :	  757dd0:       48 63 c2                movslq %edx,%rax
    0.00 :	  757dd3:       80 3c 01 20             cmpb   $0x20,(%rcx,%rax,1)
    0.00 :	  757dd7:       75 09                   jne    757de2 <bcTruelen+0x52>
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
         :	        for (i = len - 1; i >= 0; i--)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
   50.00 :	  757dd9:       83 ea 01                sub    $0x1,%edx
    0.00 :	  757ddc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  757de0:       79 ee                   jns    757dd0 <bcTruelen+0x40>
    0.00 :	  757de2:       8d 42 01                lea    0x1(%rdx),%eax
         :	        {
         :	                if (s[i] != ' ')
         :	                        break;
         :	        }
         :	        return i + 1;
         :	}
    0.00 :	  757de5:       c9                      leaveq 
    0.00 :	  757de6:       c3                      retq   
    0.00 :	  757de7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  757dee:       00 00 
         :	{
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
    0.00 :	  757df0:       d0 ea                   shr    %dl
    0.00 :	  757df2:       0f b6 c2                movzbl %dl,%eax
    0.00 :	  757df5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  757df8:       eb c1                   jmp    757dbb <bcTruelen+0x2b>
    0.00 :	  757dfa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  757e00:       0f b6 7f 01             movzbl 0x1(%rdi),%edi
    0.00 :	  757e04:       ba 07 00 00 00          mov    $0x7,%edx
    0.00 :	  757e09:       be 07 00 00 00          mov    $0x7,%esi
    0.00 :	  757e0e:       40 80 ff 01             cmp    $0x1,%dil
    0.00 :	  757e12:       74 b1                   je     757dc5 <bcTruelen+0x35>
    0.00 :	  757e14:       40 80 ff 12             cmp    $0x12,%dil
    0.00 :	  757e18:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e1d:       ba 0f 00 00 00          mov    $0xf,%edx
    0.00 :	  757e22:       0f 45 d0                cmovne %eax,%edx
    0.00 :	  757e25:       be 0f 00 00 00          mov    $0xf,%esi
    0.00 :	  757e2a:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e2f:       48 0f 45 f0             cmovne %rax,%rsi
    0.00 :	  757e33:       eb 90                   jmp    757dc5 <bcTruelen+0x35>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:444
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:456
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007832f0 <CHashSearch>:
         :	 * from the data in the hash table and return true.  If not, it will return
         :	 * false.
         :	 */
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
    0.00 :	  7832f0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:444
   50.00 :	  7832f1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7832f4:       41 54                   push   %r12
    0.00 :	  7832f6:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7832f9:       53                      push   %rbx
    0.00 :	  7832fa:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7832fd:       48 83 ec 20             sub    $0x20,%rsp
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  783301:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  783305:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  783308:       e8 43 d0 d0 ff          callq  490350 <hash_any>
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  78330d:       0f b6 4b 14             movzbl 0x14(%rbx),%ecx
         :	 */
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  783311:       8b 7b 10                mov    0x10(%rbx),%edi
    0.00 :	  783314:       21 c7                   and    %eax,%edi
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  783316:       89 fe                   mov    %edi,%esi
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783318:       d3 ef                   shr    %cl,%edi
    0.00 :	  78331a:       0f b6 4b 15             movzbl 0x15(%rbx),%ecx
    0.00 :	  78331e:       89 fa                   mov    %edi,%edx
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  783320:       48 c1 e6 02             shl    $0x2,%rsi
    0.00 :	  783324:       48 03 73 20             add    0x20(%rbx),%rsi
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783328:       d3 ea                   shr    %cl,%edx
    0.00 :	  78332a:       48 8b 0d 17 a6 3f 00    mov    0x3fa617(%rip),%rcx        # b7d948 <MyProc>
    0.00 :	  783331:       01 fa                   add    %edi,%edx
    0.00 :	  783333:       48 c1 e2 02             shl    $0x2,%rdx
    0.00 :	  783337:       48 03 53 28             add    0x28(%rbx),%rdx
    0.00 :	  78333b:       48 89 91 e8 02 00 00    mov    %rdx,0x2e8(%rcx)
         :	        pg_memory_barrier();
    0.00 :	  783342:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :
         :	        /* Scan bucket and return data from any matching entry. */
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:456
   50.00 :	  783347:       4c 8d 45 d0             lea    -0x30(%rbp),%r8
    0.00 :	  78334b:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  78334e:       89 c2                   mov    %eax,%edx
    0.00 :	  783350:       48 89 df                mov    %rbx,%rdi
    0.00 :	  783353:       e8 48 f9 ff ff          callq  782ca0 <CHashBucketScan>
         :	        if (scan.found)
    0.00 :	  783358:       80 7d e8 00             cmpb   $0x0,-0x18(%rbp)
    0.00 :	  78335c:       75 32                   jne    783390 <CHashSearch+0xa0>
         :	                           CHashNodeGetItem(scan.target_node) + table->desc.key_size,
         :	                           table->desc.element_size - table->desc.key_size);
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  78335e:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
    0.00 :	  783363:       48 8b 05 de a5 3f 00    mov    0x3fa5de(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  78336a:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  783371:       00 00 00 00 
         :
         :	        CHashTableIncrementStatistic(table, CHS_Search);
         :	        if (!scan.found)
    0.00 :	  783375:       0f b6 45 e8             movzbl -0x18(%rbp),%eax
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
         :	        MyProc->hazard[0] = NULL;
         :
         :	        CHashTableIncrementStatistic(table, CHS_Search);
    0.00 :	  783379:       48 83 43 40 01          addq   $0x1,0x40(%rbx)
         :	        if (!scan.found)
    0.00 :	  78337e:       84 c0                   test   %al,%al
    0.00 :	  783380:       75 05                   jne    783387 <CHashSearch+0x97>
         :	                CHashTableIncrementStatistic(table, CHS_Search_Failed);
    0.00 :	  783382:       48 83 43 48 01          addq   $0x1,0x48(%rbx)
         :	        return scan.found;
         :	}
    0.00 :	  783387:       48 83 c4 20             add    $0x20,%rsp
    0.00 :	  78338b:       5b                      pop    %rbx
    0.00 :	  78338c:       41 5c                   pop    %r12
    0.00 :	  78338e:       c9                      leaveq 
    0.00 :	  78338f:       c3                      retq   
         :	        pg_memory_barrier();
         :
         :	        /* Scan bucket and return data from any matching entry. */
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
         :	        if (scan.found)
         :	                memcpy(((char *) entry) + table->desc.key_size,
    0.00 :	  783390:       0f b7 43 0e             movzwl 0xe(%rbx),%eax
    0.00 :	  783394:       0f b7 53 0c             movzwl 0xc(%rbx),%edx
    0.00 :	  783398:       0f b7 f0                movzwl %ax,%esi
    0.00 :	  78339b:       29 c2                   sub    %eax,%edx
    0.00 :	  78339d:       49 8d 3c 34             lea    (%r12,%rsi,1),%rdi
    0.00 :	  7833a1:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	  7833a5:       48 03 75 e0             add    -0x20(%rbp),%rsi
    0.00 :	  7833a9:       48 63 d2                movslq %edx,%rdx
    0.00 :	  7833ac:       e8 3f 68 ce ff          callq  469bf0 <memcpy@plt>
    0.00 :	  7833b1:       eb ab                   jmp    78335e <CHashSearch+0x6e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5750 <HeapTupleSatisfiesMVCC>:
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
   50.00 :	  7a5750:       55                      push   %rbp
    0.00 :	  7a5751:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7a5754:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7a5758:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7a575c:       41 89 d6                mov    %edx,%r14d
    0.00 :	  7a575f:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  7a5763:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  7a5767:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tuple = htup->t_data;
    0.00 :	  7a576b:       48 8b 5f 10             mov    0x10(%rdi),%rbx
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
    0.00 :	  7a576f:       49 89 f5                mov    %rsi,%r13
         :	        HeapTupleHeader tuple = htup->t_data;
         :
         :	        Assert(ItemPointerIsValid(&htup->t_self));
         :	        Assert(htup->t_tableOid != InvalidOid);
         :
         :	        if (!HeapTupleHeaderXminCommitted(tuple))
    0.00 :	  7a5772:       0f b7 4b 14             movzwl 0x14(%rbx),%ecx
    0.00 :	  7a5776:       0f b7 d1                movzwl %cx,%edx
    0.00 :	  7a5779:       f6 c6 01                test   $0x1,%dh
    0.00 :	  7a577c:       75 72                   jne    7a57f0 <HeapTupleSatisfiesMVCC+0xa0>
         :	        {
         :	                if (HeapTupleHeaderXminInvalid(tuple))
    0.00 :	  7a577e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5780:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a5785:       3d 00 02 00 00          cmp    $0x200,%eax
    0.00 :	  7a578a:       0f 84 06 01 00 00       je     7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :
         :	                /* Used by pre-9.0 binary upgrades */
         :	                if (tuple->t_infomask & HEAP_MOVED_OFF)
    0.00 :	  7a5790:       f6 c6 40                test   $0x40,%dh
    0.00 :	  7a5793:       0f 84 27 01 00 00       je     7a58c0 <HeapTupleSatisfiesMVCC+0x170>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a5799:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a579c:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a57a1:       74 04                   je     7a57a7 <HeapTupleSatisfiesMVCC+0x57>
    0.00 :	  7a57a3:       44 8b 63 08             mov    0x8(%rbx),%r12d
         :
         :	                        if (TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a57a7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57aa:       e8 f1 ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a57af:       84 c0                   test   %al,%al
    0.00 :	  7a57b1:       0f 85 df 00 00 00       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;
         :	                        if (!TransactionIdIsInProgress(xvac))
    0.00 :	  7a57b7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ba:       e8 f1 c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a57bf:       84 c0                   test   %al,%al
    0.00 :	  7a57c1:       0f 85 1f 01 00 00       jne    7a58e6 <HeapTupleSatisfiesMVCC+0x196>
         :	                        {
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a57c7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ca:       e8 11 ab d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a57cf:       84 c0                   test   %al,%al
    0.00 :	  7a57d1:       0f 85 79 02 00 00       jne    7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
         :	                                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a57d7:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a57dc:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a57de:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a57e1:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a57e4:       e8 b7 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a57e9:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a57ed:       0f 1f 00                nopl   (%rax)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a57f0:       89 d0                   mov    %edx,%eax
    0.00 :	  7a57f2:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a57f7:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a57fc:       0f 85 86 00 00 00       jne    7a5888 <HeapTupleSatisfiesMVCC+0x138>
         :	                return false;                   /* treat as still in progress */
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid or aborted */
         :	                return true;
         :
         :	        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))
    0.00 :	  7a5802:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5808:       0f 85 a2 00 00 00       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a580e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5810:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a5815:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5818:       0f 84 92 00 00 00       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                return true;
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a581e:       f6 c6 10                test   $0x10,%dh
    0.00 :	  7a5821:       0f 85 b9 01 00 00       jne    7a59e0 <HeapTupleSatisfiesMVCC+0x290>
         :	                }
         :	                /* it must have aborted or crashed */
         :	                return true;
         :	        }
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
    0.00 :	  7a5827:       80 e6 04                and    $0x4,%dh
    0.00 :	  7a582a:       75 44                   jne    7a5870 <HeapTupleSatisfiesMVCC+0x120>
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a582c:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a582f:       90                      nop
    0.00 :	  7a5830:       e8 6b ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5835:       84 c0                   test   %al,%al
    0.00 :	  7a5837:       0f 85 43 01 00 00       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :
         :	                if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a583d:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5840:       e8 6b c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5845:       84 c0                   test   %al,%al
    0.00 :	  7a5847:       75 67                   jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5849:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a584c:       e8 8f aa d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5851:       84 c0                   test   %al,%al
    0.00 :	  7a5853:       0f 84 20 02 00 00       je     7a5a79 <HeapTupleSatisfiesMVCC+0x329>
         :	                                                InvalidTransactionId);
         :	                        return true;
         :	                }
         :
         :	                /* xmax transaction committed */
         :	                SetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,
    0.00 :	  7a5859:       8b 4b 04                mov    0x4(%rbx),%ecx
    0.00 :	  7a585c:       ba 00 04 00 00          mov    $0x400,%edx
    0.00 :	  7a5861:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5864:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5867:       e8 34 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a586c:       0f 1f 40 00             nopl   0x0(%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5870:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5873:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5876:       e8 85 fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a587b:       84 c0                   test   %al,%al
    0.00 :	  7a587d:       0f 95 c0                setne  %al
    0.00 :	  7a5880:       eb 16                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5882:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a5888:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a588a:       4c 89 ee                mov    %r13,%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
   50.00 :	  7a588d:       e8 6e fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a5892:       84 c0                   test   %al,%al
    0.00 :	  7a5894:       74 6a                   je     7a5900 <HeapTupleSatisfiesMVCC+0x1b0>
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5896:       31 c0                   xor    %eax,%eax
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5898:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  7a589c:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  7a58a1:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  7a58a6:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  7a58ab:       c9                      leaveq 
    0.00 :	  7a58ac:       c3                      retq   
    0.00 :	  7a58ad:       0f 1f 00                nopl   (%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a58b0:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  7a58b5:       eb e1                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a58b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7a58be:       00 00 
         :	                                SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                        InvalidTransactionId);
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
    0.00 :	  7a58c0:       66 85 c9                test   %cx,%cx
    0.00 :	  7a58c3:       79 4b                   jns    7a5910 <HeapTupleSatisfiesMVCC+0x1c0>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a58c5:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a58c8:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a58cd:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a58d0:       0f 85 fa 00 00 00       jne    7a59d0 <HeapTupleSatisfiesMVCC+0x280>
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a58d6:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a58d9:       e8 c2 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a58de:       84 c0                   test   %al,%al
    0.00 :	  7a58e0:       0f 84 4a 01 00 00       je     7a5a30 <HeapTupleSatisfiesMVCC+0x2e0>
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a58e6:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a58ea:       89 d0                   mov    %edx,%eax
    0.00 :	  7a58ec:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a58f1:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a58f6:       0f 84 06 ff ff ff       je     7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a58fc:       eb 8a                   jmp    7a5888 <HeapTupleSatisfiesMVCC+0x138>
    0.00 :	  7a58fe:       66 90                   xchg   %ax,%ax
    0.00 :	  7a5900:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a5904:       e9 f9 fe ff ff          jmpq   7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a5909:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                InvalidTransactionId);
         :	                                        return false;
         :	                                }
         :	                        }
         :	                }
         :	                else if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5910:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a5912:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5918:       e8 83 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a591d:       84 c0                   test   %al,%al
    0.00 :	  7a591f:       90                      nop
    0.00 :	  7a5920:       74 76                   je     7a5998 <HeapTupleSatisfiesMVCC+0x248>
         :	                {
         :	                        if (HeapTupleHeaderGetCmin(tuple) >= snapshot->curcid)
    0.00 :	  7a5922:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5925:       e8 96 eb ff ff          callq  7a44c0 <HeapTupleHeaderGetCmin>
    0.00 :	  7a592a:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a592e:       66 90                   xchg   %ax,%ax
    0.00 :	  7a5930:       0f 83 60 ff ff ff       jae    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;   /* inserted after scan started */
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid */
    0.00 :	  7a5936:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :	                                return true;
         :
         :	                        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))        /* not deleter */
    0.00 :	  7a593a:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5940:       0f 85 6a ff ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5946:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5948:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a594d:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5950:       0f 84 5a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                                return true;
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a5956:       80 e6 10                and    $0x10,%dh
    0.00 :	  7a5959:       0f 84 0a 01 00 00       je     7a5a69 <HeapTupleSatisfiesMVCC+0x319>
         :	                        {
         :	                                TransactionId xmax;
         :
         :	                                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a595f:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5962:       e8 b9 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  7a5967:       89 c7                   mov    %eax,%edi
         :
         :	                                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                                Assert(TransactionIdIsValid(xmax));
         :
         :	                                /* updating subtransaction must have aborted */
         :	                                if (!TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a5969:       e8 32 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a596e:       84 c0                   test   %al,%al
    0.00 :	  7a5970:       0f 84 3a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5976:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a597d:       00 00 00 
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
    0.00 :	  7a5980:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5983:       e8 58 eb ff ff          callq  7a44e0 <HeapTupleHeaderGetCmax>
    0.00 :	  7a5988:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a598c:       0f 93 c0                setae  %al
    0.00 :	  7a598f:       e9 04 ff ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5994:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5998:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a599a:       e8 11 c3 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a599f:       84 c0                   test   %al,%al
    0.00 :	  7a59a1:       0f 85 ef fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a59a7:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a59a9:       e8 32 a9 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a59ae:       84 c0                   test   %al,%al
    0.00 :	  7a59b0:       0f 84 9a 00 00 00       je     7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a59b6:       8b 0b                   mov    (%rbx),%ecx
    0.00 :	  7a59b8:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a59bd:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a59c0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59c3:       e8 d8 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a59c8:       e9 19 ff ff ff          jmpq   7a58e6 <HeapTupleSatisfiesMVCC+0x196>
    0.00 :	  7a59cd:       0f 1f 00                nopl   (%rax)
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a59d0:       44 8b 63 08             mov    0x8(%rbx),%r12d
    0.00 :	  7a59d4:       e9 fd fe ff ff          jmpq   7a58d6 <HeapTupleSatisfiesMVCC+0x186>
    0.00 :	  7a59d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59e0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59e3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a59e8:       e8 33 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59ed:       89 c7                   mov    %eax,%edi
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59ef:       41 89 c4                mov    %eax,%r12d
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59f2:       e8 a9 ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a59f7:       84 c0                   test   %al,%al
    0.00 :	  7a59f9:       75 85                   jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                if (TransactionIdIsInProgress(xmax))
    0.00 :	  7a59fb:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a59fe:       e8 ad c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a03:       84 c0                   test   %al,%al
    0.00 :	  7a5a05:       0f 85 a5 fe ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :	                if (TransactionIdDidCommit(xmax))
    0.00 :	  7a5a0b:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a0e:       e8 cd a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a13:       84 c0                   test   %al,%al
    0.00 :	  7a5a15:       0f 84 95 fe ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                {
         :	                        /* updating transaction committed, but when? */
         :	                        if (XidInMVCCSnapshot(xmax, snapshot))
    0.00 :	  7a5a1b:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5a1e:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a21:       e8 da fb ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a5a26:       84 c0                   test   %al,%al
    0.00 :	  7a5a28:       0f 95 c0                setne  %al
    0.00 :	  7a5a2b:       e9 68 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
    0.00 :	  7a5a30:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a33:       e8 78 c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a38:       84 c0                   test   %al,%al
    0.00 :	  7a5a3a:       0f 85 56 fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a5a40:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a43:       e8 98 a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a48:       84 c0                   test   %al,%al
    0.00 :	  7a5a4a:       0f 85 87 fd ff ff       jne    7a57d7 <HeapTupleSatisfiesMVCC+0x87>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                HeapTupleHeaderGetRawXmin(tuple));
         :	                else
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_INVALID,
    0.00 :	  7a5a50:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a52:       ba 00 02 00 00          mov    $0x200,%edx
    0.00 :	  7a5a57:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a5a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a5d:       e8 3e f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a62:       31 c0                   xor    %eax,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a64:       e9 2f fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                                        return true;    /* updated after scan started */
         :	                                else
         :	                                        return false;           /* updated before scan started */
         :	                        }
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5a69:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5a6c:       e8 2f ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5a71:       84 c0                   test   %al,%al
    0.00 :	  7a5a73:       0f 85 07 ff ff ff       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,
    0.00 :	  7a5a79:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a7b:       ba 00 08 00 00          mov    $0x800,%edx
    0.00 :	  7a5a80:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a83:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a86:       e8 15 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a8b:       b8 01 00 00 00          mov    $0x1,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a90:       e9 03 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f400 <slot_getattr>:
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    0.00 :	  46f400:       55                      push   %rbp
    0.00 :	  46f401:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46f404:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
  100.00 :	  46f408:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  46f40c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  46f40f:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  46f413:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  46f417:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f41b:       85 f6                   test   %esi,%esi
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    0.00 :	  46f41d:       49 89 d4                mov    %rdx,%r12
         :	        HeapTuple       tuple = slot->tts_tuple;
    0.00 :	  46f420:       48 8b 7f 08             mov    0x8(%rdi),%rdi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
    0.00 :	  46f424:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f428:       0f 8e a2 00 00 00       jle    46f4d0 <slot_getattr+0xd0>
         :	        }
         :
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
    0.00 :	  46f42e:       3b 73 24                cmp    0x24(%rbx),%esi
    0.00 :	  46f431:       7e 65                   jle    46f498 <slot_getattr+0x98>
         :	        }
         :
         :	        /*
         :	         * return NULL if attnum is out of range according to the tupdesc
         :	         */
         :	        if (attnum > tupleDesc->natts)
    0.00 :	  46f433:       3b 32                   cmp    (%rdx),%esi
    0.00 :	  46f435:       7f 51                   jg     46f488 <slot_getattr+0x88>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
    0.00 :	  46f437:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f43a:       0f 84 34 01 00 00       je     46f574 <slot_getattr+0x174>
         :	         *
         :	         * (We have to check this separately because of various inheritance and
         :	         * table-alteration scenarios: the tuple could be either longer or shorter
         :	         * than the tupdesc.)
         :	         */
         :	        tup = tuple->t_data;
    0.00 :	  46f440:       48 8b 7f 10             mov    0x10(%rdi),%rdi
         :	        if (attnum > HeapTupleHeaderGetNatts(tup))
    0.00 :	  46f444:       0f b7 47 12             movzwl 0x12(%rdi),%eax
    0.00 :	  46f448:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  46f44d:       39 c6                   cmp    %eax,%esi
    0.00 :	  46f44f:       7f 37                   jg     46f488 <slot_getattr+0x88>
         :	        }
         :
         :	        /*
         :	         * check if target attribute is null: no point in groveling through tuple
         :	         */
         :	        if (HeapTupleHasNulls(tuple) && att_isnull(attnum - 1, tup->t_bits))
    0.00 :	  46f451:       f6 47 14 01             testb  $0x1,0x14(%rdi)
    0.00 :	  46f455:       74 18                   je     46f46f <slot_getattr+0x6f>
    0.00 :	  46f457:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  46f45a:       89 c8                   mov    %ecx,%eax
    0.00 :	  46f45c:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46f45f:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46f462:       48 98                   cltq   
    0.00 :	  46f464:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  46f469:       d3 f8                   sar    %cl,%eax
    0.00 :	  46f46b:       a8 01                   test   $0x1,%al
    0.00 :	  46f46d:       74 19                   je     46f488 <slot_getattr+0x88>
         :	        /*
         :	         * If the attribute's column has been dropped, we force a NULL result.
         :	         * This case should not happen in normal use, but it could happen if we
         :	         * are executing a plan cached before the column was dropped.
         :	         */
         :	        if (tupleDesc->attrs[attnum - 1]->attisdropped)
    0.00 :	  46f46f:       4c 63 ee                movslq %esi,%r13
    0.00 :	  46f472:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  46f476:       4d 8d 75 ff             lea    -0x1(%r13),%r14
    0.00 :	  46f47a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
    0.00 :	  46f47e:       80 78 61 00             cmpb   $0x0,0x61(%rax)
    0.00 :	  46f482:       74 7c                   je     46f500 <slot_getattr+0x100>
    0.00 :	  46f484:       0f 1f 40 00             nopl   0x0(%rax)
         :	        {
         :	                *isnull = true;
    0.00 :	  46f488:       41 c6 04 24 01          movb   $0x1,(%r12)
    0.00 :	  46f48d:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f48f:       eb 20                   jmp    46f4b1 <slot_getattr+0xb1>
    0.00 :	  46f491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
         :	        {
         :	                *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f498:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  46f49c:       48 63 d6                movslq %esi,%rdx
    0.00 :	  46f49f:       0f b6 44 10 ff          movzbl -0x1(%rax,%rdx,1),%eax
    0.00 :	  46f4a4:       41 88 04 24             mov    %al,(%r12)
         :	                return slot->tts_values[attnum - 1];
    0.00 :	  46f4a8:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f4ac:       48 8b 44 d0 f8          mov    -0x8(%rax,%rdx,8),%rax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4b1:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  46f4b5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  46f4ba:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  46f4bf:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  46f4c4:       c9                      leaveq 
    0.00 :	  46f4c5:       c3                      retq   
    0.00 :	  46f4c6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46f4cd:       00 00 00 
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
    0.00 :	  46f4d0:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f4d3:       74 4b                   je     46f520 <slot_getattr+0x120>
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
    0.00 :	  46f4d5:       48 8d 43 40             lea    0x40(%rbx),%rax
    0.00 :	  46f4d9:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  46f4dc:       74 6c                   je     46f54a <slot_getattr+0x14a>
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4de:       4c 89 e1                mov    %r12,%rcx
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4e1:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  46f4e5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  46f4ea:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  46f4ef:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  46f4f4:       c9                      leaveq 
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4f5:       e9 d6 f7 ff ff          jmpq   46ecd0 <heap_getsysattr>
    0.00 :	  46f4fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        }
         :
         :	        /*
         :	         * Extract the attribute, along with any preceding attributes.
         :	         */
         :	        slot_deform_tuple(slot, attnum);
    0.00 :	  46f500:       48 89 df                mov    %rbx,%rdi
    0.00 :	  46f503:       e8 08 fa ff ff          callq  46ef10 <slot_deform_tuple>
         :
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f508:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  46f50c:       42 0f b6 44 28 ff       movzbl -0x1(%rax,%r13,1),%eax
    0.00 :	  46f512:       41 88 04 24             mov    %al,(%r12)
         :	        return slot->tts_values[attnum - 1];
    0.00 :	  46f516:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f51a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
         :	}
    0.00 :	  46f51e:       eb 91                   jmp    46f4b1 <slot_getattr+0xb1>
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
    0.00 :	  46f520:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f525:       be 8f 04 00 00          mov    $0x48f,%esi
    0.00 :	  46f52a:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f52f:       e8 ec be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f534:       be 40 f7 7a 00          mov    $0x7af740,%esi
    0.00 :	  46f539:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f53e:       31 c0                   xor    %eax,%eax
    0.00 :	  46f540:       e8 eb bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f545:       e8 86 9f ff ff          callq  4694d0 <abort@plt>
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
    0.00 :	  46f54a:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f54f:       be 91 04 00 00          mov    $0x491,%esi
    0.00 :	  46f554:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f559:       e8 c2 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f55e:       be 78 f7 7a 00          mov    $0x7af778,%esi
    0.00 :	  46f563:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f568:       31 c0                   xor    %eax,%eax
    0.00 :	  46f56a:       e8 c1 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f56f:       e8 5c 9f ff ff          callq  4694d0 <abort@plt>
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46f574:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f579:       be ac 04 00 00          mov    $0x4ac,%esi
    0.00 :	  46f57e:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f583:       e8 98 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f588:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46f58d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f592:       31 c0                   xor    %eax,%eax
    0.00 :	  46f594:       e8 97 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f599:       e8 32 9f ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:327
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000490350 <hash_any>:
         :	 * by using the final values of both b and c.  b is perhaps a little less
         :	 * well mixed than c, however.
         :	 */
         :	Datum
         :	hash_any(register const unsigned char *k, register int keylen)
         :	{
    0.00 :	  490350:       55                      push   %rbp
    0.00 :	  490351:       41 89 f2                mov    %esi,%r10d
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
         :
         :	        /* If the source pointer is word-aligned, we use word-wide fetches */
         :	        if (((uintptr_t) k & UINT32_ALIGN_MASK) == 0)
    0.00 :	  490354:       40 f6 c7 03             test   $0x3,%dil
         :	                                c,
         :	                                len;
         :
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
    0.00 :	  490358:       45 8d 82 50 56 73 9e    lea    -0x618ca9b0(%r10),%r8d
         :	 * by using the final values of both b and c.  b is perhaps a little less
         :	 * well mixed than c, however.
         :	 */
         :	Datum
         :	hash_any(register const unsigned char *k, register int keylen)
         :	{
    0.00 :	  49035f:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  490362:       53                      push   %rbx
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
         :
         :	        /* If the source pointer is word-aligned, we use word-wide fetches */
         :	        if (((uintptr_t) k & UINT32_ALIGN_MASK) == 0)
    0.00 :	  490363:       0f 84 f7 00 00 00       je     490460 <hash_any+0x110>
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490369:       83 fe 0b                cmp    $0xb,%esi
         :	                                /* fall through */
         :	                        case 2:
         :	                                a += ((uint32) k[1] << 8);
         :	                                /* fall through */
         :	                        case 1:
         :	                                a += k[0];
    0.00 :	  49036c:       45 89 c1                mov    %r8d,%r9d
    0.00 :	  49036f:       44 89 c2                mov    %r8d,%edx
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490372:       0f 86 7e 02 00 00       jbe    4905f6 <hash_any+0x2a6>
    0.00 :	  490378:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49037f:       00 
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  490380:       0f b6 4f 05             movzbl 0x5(%rdi),%ecx
    0.00 :	  490384:       0f b6 47 06             movzbl 0x6(%rdi),%eax
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  490388:       0f b6 77 09             movzbl 0x9(%rdi),%esi
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  49038c:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49038f:       c1 e1 08                shl    $0x8,%ecx
    0.00 :	  490392:       01 c1                   add    %eax,%ecx
    0.00 :	  490394:       0f b6 47 04             movzbl 0x4(%rdi),%eax
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  490398:       c1 e6 08                shl    $0x8,%esi
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  49039b:       01 c1                   add    %eax,%ecx
    0.00 :	  49039d:       0f b6 47 07             movzbl 0x7(%rdi),%eax
    0.00 :	  4903a1:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903a4:       01 c1                   add    %eax,%ecx
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903a6:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  4903aa:       01 d1                   add    %edx,%ecx
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903ac:       0f b6 57 01             movzbl 0x1(%rdi),%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903b0:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4903b3:       01 c6                   add    %eax,%esi
    0.00 :	  4903b5:       0f b6 47 08             movzbl 0x8(%rdi),%eax
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903b9:       c1 e2 08                shl    $0x8,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903bc:       01 c6                   add    %eax,%esi
    0.00 :	  4903be:       0f b6 47 0b             movzbl 0xb(%rdi),%eax
    0.00 :	  4903c2:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903c5:       01 c6                   add    %eax,%esi
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903c7:       0f b6 47 02             movzbl 0x2(%rdi),%eax
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903cb:       44 01 c6                add    %r8d,%esi
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903ce:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4903d1:       01 c2                   add    %eax,%edx
    0.00 :	  4903d3:       0f b6 07                movzbl (%rdi),%eax
    0.00 :	  4903d6:       01 c2                   add    %eax,%edx
    0.00 :	  4903d8:       0f b6 47 03             movzbl 0x3(%rdi),%eax
    0.00 :	  4903dc:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903df:       01 c2                   add    %eax,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  4903e1:       89 f0                   mov    %esi,%eax
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903e3:       44 01 ca                add    %r9d,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  4903e6:       c1 c8 1c                ror    $0x1c,%eax
    0.00 :	  4903e9:       29 f2                   sub    %esi,%edx
    0.00 :	  4903eb:       01 ce                   add    %ecx,%esi
    0.00 :	  4903ed:       31 c2                   xor    %eax,%edx
    0.00 :	  4903ef:       89 d0                   mov    %edx,%eax
    0.00 :	  4903f1:       29 d1                   sub    %edx,%ecx
    0.00 :	  4903f3:       01 f2                   add    %esi,%edx
    0.00 :	  4903f5:       c1 c8 1a                ror    $0x1a,%eax
    0.00 :	  4903f8:       31 c8                   xor    %ecx,%eax
    0.00 :	  4903fa:       89 c1                   mov    %eax,%ecx
    0.00 :	  4903fc:       29 c6                   sub    %eax,%esi
    0.00 :	  4903fe:       01 d0                   add    %edx,%eax
    0.00 :	  490400:       c1 c9 18                ror    $0x18,%ecx
    0.00 :	  490403:       31 f1                   xor    %esi,%ecx
    0.00 :	  490405:       89 ce                   mov    %ecx,%esi
    0.00 :	  490407:       29 ca                   sub    %ecx,%edx
    0.00 :	  490409:       01 c1                   add    %eax,%ecx
    0.00 :	  49040b:       c1 ce 10                ror    $0x10,%esi
         :	                        k += 12;
         :	                        len -= 12;
    0.00 :	  49040e:       41 83 ea 0c             sub    $0xc,%r10d
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
         :	                        k += 12;
    0.00 :	  490412:       48 83 c7 0c             add    $0xc,%rdi
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  490416:       31 d6                   xor    %edx,%esi
    0.00 :	  490418:       89 f2                   mov    %esi,%edx
    0.00 :	  49041a:       29 f0                   sub    %esi,%eax
    0.00 :	  49041c:       44 8d 0c 0e             lea    (%rsi,%rcx,1),%r9d
    0.00 :	  490420:       c1 ca 0d                ror    $0xd,%edx
    0.00 :	  490423:       31 c2                   xor    %eax,%edx
    0.00 :	  490425:       41 89 d0                mov    %edx,%r8d
    0.00 :	  490428:       29 d1                   sub    %edx,%ecx
    0.00 :	  49042a:       44 01 ca                add    %r9d,%edx
    0.00 :	  49042d:       41 c1 c8 1c             ror    $0x1c,%r8d
    0.00 :	  490431:       41 31 c8                xor    %ecx,%r8d
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490434:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  490438:       0f 87 42 ff ff ff       ja     490380 <hash_any+0x30>
    0.00 :	  49043e:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  490441:       89 d6                   mov    %edx,%esi
    0.00 :	  490443:       44 89 c3                mov    %r8d,%ebx
         :	                        case 1:
         :	                                a += ((uint32) k[0] << 24);
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)                    /* all the case statements fall through */
    0.00 :	  490446:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  49044a:       0f 87 01 01 00 00       ja     490551 <hash_any+0x201>
    0.00 :	  490450:       44 89 d0                mov    %r10d,%eax
    0.00 :	  490453:       ff 24 c5 18 22 7b 00    jmpq   *0x7b2218(,%rax,8)
    0.00 :	  49045a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490460:       83 fe 0b                cmp    $0xb,%esi
    0.00 :	  490463:       45 89 c1                mov    %r8d,%r9d
    0.00 :	  490466:       44 89 c1                mov    %r8d,%ecx
    0.00 :	  490469:       0f 86 79 01 00 00       jbe    4905e8 <hash_any+0x298>
    0.00 :	  49046f:       90                      nop
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
    0.00 :	  490470:       44 89 c6                mov    %r8d,%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:327
  100.00 :	  490473:       03 77 08                add    0x8(%rdi),%esi
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
         :	                {
         :	                        a += ka[0];
    0.00 :	  490476:       44 89 c8                mov    %r9d,%eax
    0.00 :	  490479:       03 07                   add    (%rdi),%eax
         :	                        b += ka[1];
    0.00 :	  49047b:       03 4f 04                add    0x4(%rdi),%ecx
         :	                        c += ka[2];
         :	                        mix(a, b, c);
         :	                        ka += 3;
         :	                        len -= 12;
    0.00 :	  49047e:       41 83 ea 0c             sub    $0xc,%r10d
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
         :	                        ka += 3;
    0.00 :	  490482:       48 83 c7 0c             add    $0xc,%rdi
         :	                while (len >= 12)
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
    0.00 :	  490486:       89 f2                   mov    %esi,%edx
    0.00 :	  490488:       29 f0                   sub    %esi,%eax
    0.00 :	  49048a:       c1 ca 1c                ror    $0x1c,%edx
    0.00 :	  49048d:       01 ce                   add    %ecx,%esi
    0.00 :	  49048f:       31 d0                   xor    %edx,%eax
    0.00 :	  490491:       89 c2                   mov    %eax,%edx
    0.00 :	  490493:       29 c1                   sub    %eax,%ecx
    0.00 :	  490495:       01 f0                   add    %esi,%eax
    0.00 :	  490497:       c1 ca 1a                ror    $0x1a,%edx
    0.00 :	  49049a:       31 ca                   xor    %ecx,%edx
    0.00 :	  49049c:       89 d1                   mov    %edx,%ecx
    0.00 :	  49049e:       29 d6                   sub    %edx,%esi
    0.00 :	  4904a0:       01 c2                   add    %eax,%edx
    0.00 :	  4904a2:       c1 c9 18                ror    $0x18,%ecx
    0.00 :	  4904a5:       31 f1                   xor    %esi,%ecx
    0.00 :	  4904a7:       89 ce                   mov    %ecx,%esi
    0.00 :	  4904a9:       29 c8                   sub    %ecx,%eax
    0.00 :	  4904ab:       01 d1                   add    %edx,%ecx
    0.00 :	  4904ad:       c1 ce 10                ror    $0x10,%esi
    0.00 :	  4904b0:       31 c6                   xor    %eax,%esi
    0.00 :	  4904b2:       89 f0                   mov    %esi,%eax
    0.00 :	  4904b4:       29 f2                   sub    %esi,%edx
    0.00 :	  4904b6:       44 8d 0c 0e             lea    (%rsi,%rcx,1),%r9d
    0.00 :	  4904ba:       c1 c8 0d                ror    $0xd,%eax
    0.00 :	  4904bd:       31 d0                   xor    %edx,%eax
    0.00 :	  4904bf:       41 89 c0                mov    %eax,%r8d
    0.00 :	  4904c2:       29 c1                   sub    %eax,%ecx
    0.00 :	  4904c4:       41 c1 c8 1c             ror    $0x1c,%r8d
    0.00 :	  4904c8:       41 31 c8                xor    %ecx,%r8d
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4904cb:       41 83 fa 0b             cmp    $0xb,%r10d
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
    0.00 :	  4904cf:       42 8d 0c 08             lea    (%rax,%r9,1),%ecx
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4904d3:       77 9b                   ja     490470 <hash_any+0x120>
    0.00 :	  4904d5:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  4904d8:       89 ce                   mov    %ecx,%esi
    0.00 :	  4904da:       44 89 c3                mov    %r8d,%ebx
         :	                        case 1:
         :	                                a += ((uint32) k[0] << 24);
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)
    0.00 :	  4904dd:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  4904e1:       77 6e                   ja     490551 <hash_any+0x201>
    0.00 :	  4904e3:       44 89 d0                mov    %r10d,%eax
    0.00 :	  4904e6:       ff 24 c5 78 22 7b 00    jmpq   *0x7b2278(,%rax,8)
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)                    /* all the case statements fall through */
         :	                {
         :	                        case 11:
         :	                                c += ((uint32) k[10] << 24);
    0.00 :	  4904ed:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
    0.00 :	  4904f1:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4904f4:       42 8d 1c 00             lea    (%rax,%r8,1),%ebx
         :	                        case 10:
         :	                                c += ((uint32) k[9] << 16);
    0.00 :	  4904f8:       0f b6 47 09             movzbl 0x9(%rdi),%eax
    0.00 :	  4904fc:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4904ff:       01 c3                   add    %eax,%ebx
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
    0.00 :	  490501:       0f b6 47 08             movzbl 0x8(%rdi),%eax
    0.00 :	  490505:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490508:       01 c3                   add    %eax,%ebx
         :	                                /* the lowest byte of c is reserved for the length */
         :	                        case 8:
         :	                                b += ((uint32) k[7] << 24);
    0.00 :	  49050a:       0f b6 47 07             movzbl 0x7(%rdi),%eax
    0.00 :	  49050e:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  490511:       8d 34 10                lea    (%rax,%rdx,1),%esi
         :	                        case 7:
         :	                                b += ((uint32) k[6] << 16);
    0.00 :	  490514:       0f b6 47 06             movzbl 0x6(%rdi),%eax
    0.00 :	  490518:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49051b:       01 c6                   add    %eax,%esi
         :	                        case 6:
         :	                                b += ((uint32) k[5] << 8);
    0.00 :	  49051d:       0f b6 47 05             movzbl 0x5(%rdi),%eax
    0.00 :	  490521:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490524:       01 c6                   add    %eax,%esi
         :	                        case 5:
         :	                                b += k[4];
    0.00 :	  490526:       0f b6 47 04             movzbl 0x4(%rdi),%eax
    0.00 :	  49052a:       01 c6                   add    %eax,%esi
         :	                        case 4:
         :	                                a += ((uint32) k[3] << 24);
    0.00 :	  49052c:       0f b6 47 03             movzbl 0x3(%rdi),%eax
    0.00 :	  490530:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  490533:       46 8d 1c 08             lea    (%rax,%r9,1),%r11d
         :	                        case 3:
         :	                                a += ((uint32) k[2] << 16);
    0.00 :	  490537:       0f b6 47 02             movzbl 0x2(%rdi),%eax
    0.00 :	  49053b:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49053e:       41 01 c3                add    %eax,%r11d
         :	                        case 2:
         :	                                a += ((uint32) k[1] << 8);
    0.00 :	  490541:       0f b6 47 01             movzbl 0x1(%rdi),%eax
    0.00 :	  490545:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490548:       41 01 c3                add    %eax,%r11d
         :	                        case 1:
         :	                                a += k[0];
    0.00 :	  49054b:       0f b6 07                movzbl (%rdi),%eax
    0.00 :	  49054e:       41 01 c3                add    %eax,%r11d
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#endif   /* WORDS_BIGENDIAN */
         :	        }
         :
         :	        final(a, b, c);
    0.00 :	  490551:       89 da                   mov    %ebx,%edx
    0.00 :	  490553:       89 f0                   mov    %esi,%eax
    0.00 :	  490555:       31 f2                   xor    %esi,%edx
    0.00 :	  490557:       c1 c8 12                ror    $0x12,%eax
    0.00 :	  49055a:       29 c2                   sub    %eax,%edx
    0.00 :	  49055c:       89 d1                   mov    %edx,%ecx
    0.00 :	  49055e:       89 d0                   mov    %edx,%eax
    0.00 :	  490560:       c1 c8 15                ror    $0x15,%eax
    0.00 :	  490563:       44 31 d9                xor    %r11d,%ecx
    0.00 :	  490566:       29 c1                   sub    %eax,%ecx
    0.00 :	  490568:       89 c8                   mov    %ecx,%eax
    0.00 :	  49056a:       31 ce                   xor    %ecx,%esi
    0.00 :	  49056c:       c1 c8 07                ror    $0x7,%eax
    0.00 :	  49056f:       29 c6                   sub    %eax,%esi
    0.00 :	  490571:       89 f0                   mov    %esi,%eax
    0.00 :	  490573:       31 d0                   xor    %edx,%eax
    0.00 :	  490575:       89 f2                   mov    %esi,%edx
    0.00 :	  490577:       c1 ca 10                ror    $0x10,%edx
    0.00 :	  49057a:       29 d0                   sub    %edx,%eax
    0.00 :	  49057c:       89 c2                   mov    %eax,%edx
    0.00 :	  49057e:       31 ca                   xor    %ecx,%edx
    0.00 :	  490580:       89 c1                   mov    %eax,%ecx
    0.00 :	  490582:       c1 c9 1c                ror    $0x1c,%ecx
    0.00 :	  490585:       29 ca                   sub    %ecx,%edx
    0.00 :	  490587:       89 d1                   mov    %edx,%ecx
    0.00 :	  490589:       c1 ca 12                ror    $0x12,%edx
    0.00 :	  49058c:       31 f1                   xor    %esi,%ecx
    0.00 :	  49058e:       29 d1                   sub    %edx,%ecx
    0.00 :	  490590:       31 c8                   xor    %ecx,%eax
    0.00 :	  490592:       c1 c9 08                ror    $0x8,%ecx
    0.00 :	  490595:       29 c8                   sub    %ecx,%eax
         :
         :	        /* report the result */
         :	        return UInt32GetDatum(c);
         :	}
    0.00 :	  490597:       5b                      pop    %rbx
    0.00 :	  490598:       c9                      leaveq 
    0.00 :	  490599:       c3                      retq   
         :	                        case 8:
         :	                                b += ka[1];
         :	                                a += ka[0];
         :	                                break;
         :	                        case 7:
         :	                                b += ((uint32) k[6] << 16);
    0.00 :	  49059a:       0f b6 47 06             movzbl 0x6(%rdi),%eax
    0.00 :	  49059e:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4905a1:       8d 34 08                lea    (%rax,%rcx,1),%esi
         :	                                /* fall through */
         :	                        case 6:
         :	                                b += ((uint32) k[5] << 8);
    0.00 :	  4905a4:       0f b6 47 05             movzbl 0x5(%rdi),%eax
    0.00 :	  4905a8:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  4905ab:       01 c6                   add    %eax,%esi
         :	                                /* fall through */
         :	                        case 5:
         :	                                b += k[4];
    0.00 :	  4905ad:       0f b6 47 04             movzbl 0x4(%rdi),%eax
    0.00 :	  4905b1:       01 c6                   add    %eax,%esi
         :	                                /* fall through */
         :	                        case 4:
         :	                                a += ka[0];
    0.00 :	  4905b3:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  4905b6:       44 03 1f                add    (%rdi),%r11d
         :	                                break;
    0.00 :	  4905b9:       eb 96                   jmp    490551 <hash_any+0x201>
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)
         :	                {
         :	                        case 11:
         :	                                c += ((uint32) k[10] << 24);
    0.00 :	  4905bb:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
    0.00 :	  4905bf:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4905c2:       42 8d 1c 00             lea    (%rax,%r8,1),%ebx
         :	                                /* fall through */
         :	                        case 10:
         :	                                c += ((uint32) k[9] << 16);
    0.00 :	  4905c6:       0f b6 47 09             movzbl 0x9(%rdi),%eax
    0.00 :	  4905ca:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4905cd:       01 c3                   add    %eax,%ebx
         :	                                /* fall through */
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
    0.00 :	  4905cf:       0f b6 47 08             movzbl 0x8(%rdi),%eax
    0.00 :	  4905d3:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  4905d6:       01 c3                   add    %eax,%ebx
         :	                                /* the lowest byte of c is reserved for the length */
         :	                                /* fall through */
         :	                        case 8:
         :	                                b += ka[1];
    0.00 :	  4905d8:       89 ce                   mov    %ecx,%esi
         :	                                a += ka[0];
    0.00 :	  4905da:       45 89 cb                mov    %r9d,%r11d
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
         :	                                /* the lowest byte of c is reserved for the length */
         :	                                /* fall through */
         :	                        case 8:
         :	                                b += ka[1];
    0.00 :	  4905dd:       03 77 04                add    0x4(%rdi),%esi
         :	                                a += ka[0];
    0.00 :	  4905e0:       44 03 1f                add    (%rdi),%r11d
         :	                                break;
    0.00 :	  4905e3:       e9 69 ff ff ff          jmpq   490551 <hash_any+0x201>
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4905e8:       45 89 c3                mov    %r8d,%r11d
    0.00 :	  4905eb:       44 89 c6                mov    %r8d,%esi
    0.00 :	  4905ee:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  4905f1:       e9 e7 fe ff ff          jmpq   4904dd <hash_any+0x18d>
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4905f6:       45 89 c3                mov    %r8d,%r11d
    0.00 :	  4905f9:       44 89 c6                mov    %r8d,%esi
    0.00 :	  4905fc:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  4905ff:       e9 42 fe ff ff          jmpq   490446 <hash_any+0xf6>
         :	                                /* fall through */
         :	                        case 4:
         :	                                a += ka[0];
         :	                                break;
         :	                        case 3:
         :	                                a += ((uint32) k[2] << 16);
    0.00 :	  490604:       0f b6 47 02             movzbl 0x2(%rdi),%eax
    0.00 :	  490608:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49060b:       46 8d 1c 08             lea    (%rax,%r9,1),%r11d
    0.00 :	  49060f:       e9 2d ff ff ff          jmpq   490541 <hash_any+0x1f1>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:109
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000049f650 <heap_page_prune_opt>:
         :	 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD
         :	 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
         :	 */
         :	void
         :	heap_page_prune_opt(Relation relation, Buffer buffer)
         :	{
    0.00 :	  49f650:       55                      push   %rbp
    0.00 :	  49f651:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  49f654:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  49f658:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  49f65c:       41 89 f4                mov    %esi,%r12d
    0.00 :	  49f65f:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  49f663:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  49f667:       49 89 fe                mov    %rdi,%r14
    0.00 :	  49f66a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  49f66e:       48 83 ec 40             sub    $0x40,%rsp
         :	        Page            page = BufferGetPage(buffer);
    0.00 :	  49f672:       85 f6                   test   %esi,%esi
    0.00 :	  49f674:       0f 88 fe 00 00 00       js     49f778 <heap_page_prune_opt+0x128>
    0.00 :	  49f67a:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  49f67f:       48 63 d8                movslq %eax,%rbx
    0.00 :	  49f682:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  49f686:       48 03 1d 6b 04 72 00    add    0x72046b(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        /*
         :	         * We can't write WAL in recovery mode, so there's no point trying to
         :	         * clean the page. The master will likely issue a cleaning WAL record soon
         :	         * anyway, so this is no particular loss.
         :	         */
         :	        if (RecoveryInProgress())
    0.00 :	  49f68d:       e8 2e de 02 00          callq  4cd4c0 <RecoveryInProgress>
    0.00 :	  49f692:       84 c0                   test   %al,%al
    0.00 :	  49f694:       74 1a                   je     49f6b0 <heap_page_prune_opt+0x60>
         :	                }
         :
         :	                /* And release buffer lock */
         :	                LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
         :	        }
         :	}
    0.00 :	  49f696:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  49f69a:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  49f69e:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  49f6a2:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  49f6a6:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  49f6aa:       c9                      leaveq 
    0.00 :	  49f6ab:       c3                      retq   
    0.00 :	  49f6ac:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f6b0:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49f6b3:       e8 28 37 04 00          callq  4e2de0 <IsCatalogRelation>
    0.00 :	  49f6b8:       84 c0                   test   %al,%al
    0.00 :	  49f6ba:       0f 84 d0 00 00 00       je     49f790 <heap_page_prune_opt+0x140>
         :	                RelationIsAccessibleInLogicalDecoding(relation))
         :	                OldestXmin = RecentGlobalXmin;
    0.00 :	  49f6c0:       44 8b 3d 39 b2 71 00    mov    0x71b239(%rip),%r15d        # bba900 <RecentGlobalXmin>
         :	         * Let's see if we really need pruning.
         :	         *
         :	         * Forget it if page is not hinted to contain something prunable that's
         :	         * older than OldestXmin.
         :	         */
         :	        if (!PageIsPrunable(page, OldestXmin))
    0.00 :	  49f6c7:       8b 7b 14                mov    0x14(%rbx),%edi
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:109
  100.00 :	  49f6ca:       85 ff                   test   %edi,%edi
    0.00 :	  49f6cc:       74 c8                   je     49f696 <heap_page_prune_opt+0x46>
    0.00 :	  49f6ce:       44 89 fe                mov    %r15d,%esi
    0.00 :	  49f6d1:       e8 0a 09 02 00          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  49f6d6:       84 c0                   test   %al,%al
    0.00 :	  49f6d8:       74 bc                   je     49f696 <heap_page_prune_opt+0x46>
         :	         * unlikely to be *seriously* wrong, though, since reading either pd_lower
         :	         * or pd_upper is probably atomic.  Avoiding taking a lock seems more
         :	         * important than sometimes getting a wrong answer in what is after all
         :	         * just a heuristic estimate.
         :	         */
         :	        minfree = RelationGetTargetPageFreeSpace(relation,
    0.00 :	  49f6da:       49 8b 96 98 00 00 00    mov    0x98(%r14),%rdx
    0.00 :	  49f6e1:       41 bd 33 03 00 00       mov    $0x333,%r13d
    0.00 :	  49f6e7:       48 85 d2                test   %rdx,%rdx
    0.00 :	  49f6ea:       74 2f                   je     49f71b <heap_page_prune_opt+0xcb>
    0.00 :	  49f6ec:       b9 64 00 00 00          mov    $0x64,%ecx
    0.00 :	  49f6f1:       2b 4a 04                sub    0x4(%rdx),%ecx
    0.00 :	  49f6f4:       ba 1f 85 eb 51          mov    $0x51eb851f,%edx
    0.00 :	  49f6f9:       c1 e1 0d                shl    $0xd,%ecx
    0.00 :	  49f6fc:       89 c8                   mov    %ecx,%eax
    0.00 :	  49f6fe:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  49f701:       f7 ea                   imul   %edx
    0.00 :	  49f703:       b8 33 03 00 00          mov    $0x333,%eax
    0.00 :	  49f708:       c1 fa 05                sar    $0x5,%edx
    0.00 :	  49f70b:       29 ca                   sub    %ecx,%edx
    0.00 :	  49f70d:       4c 63 ea                movslq %edx,%r13
    0.00 :	  49f710:       49 81 fd 33 03 00 00    cmp    $0x333,%r13
    0.00 :	  49f717:       4c 0f 42 e8             cmovb  %rax,%r13
         :	                                                                                         HEAP_DEFAULT_FILLFACTOR);
         :	        minfree = Max(minfree, BLCKSZ / 10);
         :
         :	        if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f71b:       f6 43 0a 02             testb  $0x2,0xa(%rbx)
    0.00 :	  49f71f:       75 11                   jne    49f732 <heap_page_prune_opt+0xe2>
    0.00 :	  49f721:       48 89 df                mov    %rbx,%rdi
    0.00 :	  49f724:       e8 37 56 1f 00          callq  694d60 <PageGetHeapFreeSpace>
    0.00 :	  49f729:       4c 39 e8                cmp    %r13,%rax
    0.00 :	  49f72c:       0f 83 64 ff ff ff       jae    49f696 <heap_page_prune_opt+0x46>
         :	        {
         :	                /* OK, try to get exclusive buffer lock */
         :	                if (!ConditionalLockBufferForCleanup(buffer))
    0.00 :	  49f732:       44 89 e7                mov    %r12d,%edi
    0.00 :	  49f735:       e8 26 78 1d 00          callq  676f60 <ConditionalLockBufferForCleanup>
    0.00 :	  49f73a:       84 c0                   test   %al,%al
    0.00 :	  49f73c:       0f 84 54 ff ff ff       je     49f696 <heap_page_prune_opt+0x46>
         :	                 * Now that we have buffer lock, get accurate information about the
         :	                 * page's free space, and recheck the heuristic about whether to
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f742:       f6 43 0a 02             testb  $0x2,0xa(%rbx)
    0.00 :	  49f746:       74 68                   je     49f7b0 <heap_page_prune_opt+0x160>
         :	                {
         :	                        TransactionId ignore = InvalidTransactionId;            /* return value not
         :	                                                                                                                                 * needed */
         :
         :	                        /* OK to prune */
         :	                        (void) heap_page_prune(relation, buffer, OldestXmin, true, &ignore);
    0.00 :	  49f748:       4c 8d 45 d4             lea    -0x2c(%rbp),%r8
    0.00 :	  49f74c:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  49f751:       44 89 fa                mov    %r15d,%edx
    0.00 :	  49f754:       44 89 e6                mov    %r12d,%esi
    0.00 :	  49f757:       4c 89 f7                mov    %r14,%rdi
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
         :	                {
         :	                        TransactionId ignore = InvalidTransactionId;            /* return value not
    0.00 :	  49f75a:       c7 45 d4 00 00 00 00    movl   $0x0,-0x2c(%rbp)
         :	                                                                                                                                 * needed */
         :
         :	                        /* OK to prune */
         :	                        (void) heap_page_prune(relation, buffer, OldestXmin, true, &ignore);
    0.00 :	  49f761:       e8 5a f4 ff ff          callq  49ebc0 <heap_page_prune>
         :	                }
         :
         :	                /* And release buffer lock */
         :	                LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  49f766:       31 f6                   xor    %esi,%esi
    0.00 :	  49f768:       44 89 e7                mov    %r12d,%edi
    0.00 :	  49f76b:       e8 a0 4f 1d 00          callq  674710 <LockBuffer>
    0.00 :	  49f770:       e9 21 ff ff ff          jmpq   49f696 <heap_page_prune_opt+0x46>
    0.00 :	  49f775:       0f 1f 00                nopl   (%rax)
         :	 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
         :	 */
         :	void
         :	heap_page_prune_opt(Relation relation, Buffer buffer)
         :	{
         :	        Page            page = BufferGetPage(buffer);
    0.00 :	  49f778:       89 f0                   mov    %esi,%eax
    0.00 :	  49f77a:       48 8b 15 97 d9 6d 00    mov    0x6dd997(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49f781:       f7 d0                   not    %eax
    0.00 :	  49f783:       48 98                   cltq   
    0.00 :	  49f785:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  49f789:       e9 ff fe ff ff          jmpq   49f68d <heap_page_prune_opt+0x3d>
    0.00 :	  49f78e:       66 90                   xchg   %ax,%ax
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f790:       83 3d c5 99 6d 00 02    cmpl   $0x2,0x6d99c5(%rip)        # b7915c <wal_level>
    0.00 :	  49f797:       7e 0a                   jle    49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f799:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  49f79d:       80 78 6e 70             cmpb   $0x70,0x6e(%rax)
    0.00 :	  49f7a1:       74 25                   je     49f7c8 <heap_page_prune_opt+0x178>
         :	                RelationIsAccessibleInLogicalDecoding(relation))
         :	                OldestXmin = RecentGlobalXmin;
         :	        else
         :	                OldestXmin = RecentGlobalDataXmin;
    0.00 :	  49f7a3:       44 8b 3d 5a b1 71 00    mov    0x71b15a(%rip),%r15d        # bba904 <RecentGlobalDataXmin>
    0.00 :	  49f7aa:       e9 18 ff ff ff          jmpq   49f6c7 <heap_page_prune_opt+0x77>
    0.00 :	  49f7af:       90                      nop
         :	                 * Now that we have buffer lock, get accurate information about the
         :	                 * page's free space, and recheck the heuristic about whether to
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f7b0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  49f7b3:       e8 a8 55 1f 00          callq  694d60 <PageGetHeapFreeSpace>
    0.00 :	  49f7b8:       4c 39 e8                cmp    %r13,%rax
    0.00 :	  49f7bb:       73 a9                   jae    49f766 <heap_page_prune_opt+0x116>
    0.00 :	  49f7bd:       0f 1f 00                nopl   (%rax)
    0.00 :	  49f7c0:       eb 86                   jmp    49f748 <heap_page_prune_opt+0xf8>
    0.00 :	  49f7c2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f7c8:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49f7cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  49f7d0:       e8 0b 36 04 00          callq  4e2de0 <IsCatalogRelation>
    0.00 :	  49f7d5:       84 c0                   test   %al,%al
    0.00 :	  49f7d7:       0f 85 e3 fe ff ff       jne    49f6c0 <heap_page_prune_opt+0x70>
    0.00 :	  49f7dd:       49 8b 86 98 00 00 00    mov    0x98(%r14),%rax
    0.00 :	  49f7e4:       48 85 c0                test   %rax,%rax
    0.00 :	  49f7e7:       74 ba                   je     49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f7e9:       80 78 48 00             cmpb   $0x0,0x48(%rax)
    0.00 :	  49f7ed:       74 b4                   je     49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f7ef:       90                      nop
    0.00 :	  49f7f0:       e9 cb fe ff ff          jmpq   49f6c0 <heap_page_prune_opt+0x70>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004aac20 <_bt_getroot>:
         :	 *              On successful return, the root page is pinned and read-locked.
         :	 *              The metadata page is not locked or pinned on exit.
         :	 */
         :	Buffer
         :	_bt_getroot(Relation rel, int access)
         :	{
    0.00 :	  4aac20:       55                      push   %rbp
    0.00 :	  4aac21:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4aac24:       41 57                   push   %r15
    0.00 :	  4aac26:       41 56                   push   %r14
    0.00 :	  4aac28:       49 89 fe                mov    %rdi,%r14
    0.00 :	  4aac2b:       41 55                   push   %r13
    0.00 :	  4aac2d:       41 89 f5                mov    %esi,%r13d
    0.00 :	  4aac30:       41 54                   push   %r12
    0.00 :	  4aac32:       53                      push   %rbx
    0.00 :	  4aac33:       48 83 ec 58             sub    $0x58,%rsp
         :	        /*
         :	         * Try to use previously-cached metapage data to find the root.  This
         :	         * normally saves one buffer access per index search, which is a very
         :	         * helpful savings in bufmgr traffic and hence contention.
         :	         */
         :	        if (rel->rd_amcache != NULL)
    0.00 :	  4aac37:       48 8b 87 18 01 00 00    mov    0x118(%rdi),%rax
    0.00 :	  4aac3e:       48 85 c0                test   %rax,%rax
    0.00 :	  4aac41:       74 6a                   je     4aacad <_bt_getroot+0x8d>
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac43:       8b 70 10                mov    0x10(%rax),%esi
    0.00 :	  4aac46:       ba 01 00 00 00          mov    $0x1,%edx
         :	                Assert(metad->btm_version == BTREE_VERSION);
         :	                Assert(metad->btm_root != P_NONE);
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aac4b:       8b 58 14                mov    0x14(%rax),%ebx
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac4e:       e8 fd e3 ff ff          callq  4a9050 <_bt_getbuf>
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aac53:       85 c0                   test   %eax,%eax
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac55:       41 89 c4                mov    %eax,%r12d
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aac58:       0f 88 6a 02 00 00       js     4aaec8 <_bt_getroot+0x2a8>
    0.00 :	  4aac5e:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aac63:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4aac66:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4aac6a:       48 03 15 87 4e 71 00    add    0x714e87(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aac71:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4aac75:       48 01 c2                add    %rax,%rdx
         :	                 * here than normal.  We *must* check that it's not deleted. If it's
         :	                 * not alone on its level, then we reject too --- this may be overly
         :	                 * paranoid but better safe than sorry.  Note we don't check P_ISROOT,
         :	                 * because that's not set in a "fast root".
         :	                 */
         :	                if (!P_IGNORE(rootopaque) &&
    0.00 :	  4aac78:       0f b7 42 0c             movzwl 0xc(%rdx),%eax
    0.00 :	  4aac7c:       a8 14                   test   $0x14,%al
    0.00 :	  4aac7e:       75 09                   jne    4aac89 <_bt_getroot+0x69>
    0.00 :	  4aac80:       39 5a 08                cmp    %ebx,0x8(%rdx)
    0.00 :	  4aac83:       0f 84 57 02 00 00       je     4aaee0 <_bt_getroot+0x2c0>
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aac89:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aac8c:       e8 9f a2 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	                        /* OK, accept cached page as the root */
         :	                        return rootbuf;
         :	                }
         :	                _bt_relbuf(rel, rootbuf);
         :	                /* Cache is stale, throw it away */
         :	                if (rel->rd_amcache)
    0.00 :	  4aac91:       49 8b be 18 01 00 00    mov    0x118(%r14),%rdi
    0.00 :	  4aac98:       48 85 ff                test   %rdi,%rdi
    0.00 :	  4aac9b:       74 05                   je     4aaca2 <_bt_getroot+0x82>
         :	                        pfree(rel->rd_amcache);
    0.00 :	  4aac9d:       e8 de de 2e 00          callq  798b80 <pfree>
         :	                rel->rd_amcache = NULL;
    0.00 :	  4aaca2:       49 c7 86 18 01 00 00    movq   $0x0,0x118(%r14)
    0.00 :	  4aaca9:       00 00 00 00 
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
    0.00 :	  4aacad:       31 f6                   xor    %esi,%esi
    0.00 :	  4aacaf:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4aacb4:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aacb7:       e8 94 e3 ff ff          callq  4a9050 <_bt_getbuf>
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aacbc:       85 c0                   test   %eax,%eax
         :	                if (rel->rd_amcache)
         :	                        pfree(rel->rd_amcache);
         :	                rel->rd_amcache = NULL;
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
    0.00 :	  4aacbe:       41 89 c0                mov    %eax,%r8d
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aacc1:       0f 88 e9 01 00 00       js     4aaeb0 <_bt_getroot+0x290>
    0.00 :	  4aacc7:       41 8d 40 ff             lea    -0x1(%r8),%eax
    0.00 :	  4aaccb:       48 63 d8                movslq %eax,%rbx
    0.00 :	  4aacce:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  4aacd2:       48 03 1d 1f 4e 71 00    add    0x714e1f(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        metaopaque = (BTPageOpaque) PageGetSpecialPointer(metapg);
         :	        metad = BTPageGetMeta(metapg);
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
    0.00 :	  4aacd9:       0f b7 43 10             movzwl 0x10(%rbx),%eax
    0.00 :	  4aacdd:       f6 44 03 0c 08          testb  $0x8,0xc(%rbx,%rax,1)
    0.00 :	  4aace2:       74 0d                   je     4aacf1 <_bt_getroot+0xd1>
    0.00 :	  4aace4:       81 7b 18 62 31 05 00    cmpl   $0x53162,0x18(%rbx)
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
         :	        metapg = BufferGetPage(metabuf);
         :	        metaopaque = (BTPageOpaque) PageGetSpecialPointer(metapg);
         :	        metad = BTPageGetMeta(metapg);
    0.00 :	  4aaceb:       4c 8d 7b 18             lea    0x18(%rbx),%r15
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
    0.00 :	  4aacef:       74 5f                   je     4aad50 <_bt_getroot+0x130>
         :	                metad->btm_magic != BTREE_MAGIC)
         :	                ereport(ERROR,
    0.00 :	  4aacf1:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4aacf4:       b9 50 47 7b 00          mov    $0x7b4750,%ecx
    0.00 :	  4aacf9:       ba a7 00 00 00          mov    $0xa7,%edx
    0.00 :	  4aacfe:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4aad03:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4aad08:       e8 b3 fd 2c 00          callq  77aac0 <errstart>
    0.00 :	  4aad0d:       84 c0                   test   %al,%al
    0.00 :	  4aad0f:       75 0f                   jne    4aad20 <_bt_getroot+0x100>
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aad11:       e8 ba e7 fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4aad16:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4aad1d:       00 00 00 
         :	        metad = BTPageGetMeta(metapg);
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
         :	                metad->btm_magic != BTREE_MAGIC)
         :	                ereport(ERROR,
    0.00 :	  4aad20:       49 8b 76 30             mov    0x30(%r14),%rsi
    0.00 :	  4aad24:       bf 4a 43 7b 00          mov    $0x7b434a,%edi
    0.00 :	  4aad29:       31 c0                   xor    %eax,%eax
    0.00 :	  4aad2b:       e8 70 1b 2d 00          callq  77c8a0 <errmsg>
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
         :	                ereport(ERROR,
    0.00 :	  4aad30:       89 c3                   mov    %eax,%ebx
    0.00 :	  4aad32:       bf 28 0a 00 02          mov    $0x2000a28,%edi
    0.00 :	  4aad37:       e8 14 20 2d 00          callq  77cd50 <errcode>
    0.00 :	  4aad3c:       89 de                   mov    %ebx,%esi
    0.00 :	  4aad3e:       89 c7                   mov    %eax,%edi
    0.00 :	  4aad40:       31 c0                   xor    %eax,%eax
    0.00 :	  4aad42:       e8 99 f8 2c 00          callq  77a5e0 <errfinish>
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aad47:       e8 84 e7 fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4aad4c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                ereport(ERROR,
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
    0.00 :	  4aad50:       41 83 7f 04 02          cmpl   $0x2,0x4(%r15)
    0.00 :	  4aad55:       0f 85 7b 03 00 00       jne    4ab0d6 <_bt_getroot+0x4b6>
         :	                                 errmsg("version mismatch in index \"%s\": file version %d, code version %d",
         :	                                                RelationGetRelationName(rel),
         :	                                                metad->btm_version, BTREE_VERSION)));
         :
         :	        /* if no root page initialized yet, do it */
         :	        if (metad->btm_root == P_NONE)
    0.00 :	  4aad5b:       45 8b 57 08             mov    0x8(%r15),%r10d
    0.00 :	  4aad5f:       45 85 d2                test   %r10d,%r10d
    0.00 :	  4aad62:       0f 85 a8 01 00 00       jne    4aaf10 <_bt_getroot+0x2f0>
         :	        {
         :	                /* If access = BT_READ, caller doesn't want us to create root yet */
         :	                if (access == BT_READ)
    0.00 :	  4aad68:       41 83 fd 01             cmp    $0x1,%r13d
    0.00 :	  4aad6c:       0f 84 8e 01 00 00       je     4aaf00 <_bt_getroot+0x2e0>
         :	                        _bt_relbuf(rel, metabuf);
         :	                        return InvalidBuffer;
         :	                }
         :
         :	                /* trade in our read lock for a write lock */
         :	                LockBuffer(metabuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aad72:       31 f6                   xor    %esi,%esi
    0.00 :	  4aad74:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aad77:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aad7b:       e8 90 99 1c 00          callq  674710 <LockBuffer>
         :	                LockBuffer(metabuf, BT_WRITE);
    0.00 :	  4aad80:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aad84:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  4aad89:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aad8c:       e8 7f 99 1c 00          callq  674710 <LockBuffer>
         :	                /*
         :	                 * Race condition:      if someone else initialized the metadata between
         :	                 * the time we released the read lock and acquired the write lock, we
         :	                 * must avoid doing it again.
         :	                 */
         :	                if (metad->btm_root != P_NONE)
    0.00 :	  4aad91:       45 8b 4f 08             mov    0x8(%r15),%r9d
    0.00 :	  4aad95:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aad99:       45 85 c9                test   %r9d,%r9d
    0.00 :	  4aad9c:       0f 85 66 02 00 00       jne    4ab008 <_bt_getroot+0x3e8>
         :	                /*
         :	                 * Get, initialize, write, and leave a lock of the appropriate type on
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
    0.00 :	  4aada2:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  4aada7:       be ff ff ff ff          mov    $0xffffffff,%esi
    0.00 :	  4aadac:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aadaf:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aadb3:       e8 98 e2 ff ff          callq  4a9050 <_bt_getbuf>
    0.00 :	  4aadb8:       41 89 c4                mov    %eax,%r12d
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
    0.00 :	  4aadbb:       89 c7                   mov    %eax,%edi
    0.00 :	  4aadbd:       e8 6e 92 1c 00          callq  674030 <BufferGetBlockNumber>
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aadc2:       45 85 e4                test   %r12d,%r12d
         :	                 * Get, initialize, write, and leave a lock of the appropriate type on
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
    0.00 :	  4aadc5:       89 45 88                mov    %eax,-0x78(%rbp)
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aadc8:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aadcc:       0f 88 56 02 00 00       js     4ab028 <_bt_getroot+0x408>
    0.00 :	  4aadd2:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aadd7:       4c 63 e8                movslq %eax,%r13
    0.00 :	  4aadda:       49 c1 e5 0d             shl    $0xd,%r13
    0.00 :	  4aadde:       4c 03 2d 13 4d 71 00    add    0x714d13(%rip),%r13        # bbfaf8 <BufferBlocks>
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aade5:       41 0f b7 45 10          movzwl 0x10(%r13),%eax
         :	                metad->btm_root = rootblkno;
         :	                metad->btm_level = 0;
         :	                metad->btm_fastroot = rootblkno;
         :	                metad->btm_fastlevel = 0;
         :
         :	                MarkBufferDirty(rootbuf);
    0.00 :	  4aadea:       44 89 e7                mov    %r12d,%edi
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
         :	                rootpage = BufferGetPage(rootbuf);
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aaded:       49 8d 44 05 00          lea    0x0(%r13,%rax,1),%rax
         :	                rootopaque->btpo_prev = rootopaque->btpo_next = P_NONE;
    0.00 :	  4aadf2:       c7 40 04 00 00 00 00    movl   $0x0,0x4(%rax)
    0.00 :	  4aadf9:       c7 00 00 00 00 00       movl   $0x0,(%rax)
         :	                rootopaque->btpo_flags = (BTP_LEAF | BTP_ROOT);
    0.00 :	  4aadff:       66 c7 40 0c 03 00       movw   $0x3,0xc(%rax)
         :	                rootopaque->btpo.level = 0;
    0.00 :	  4aae05:       c7 40 08 00 00 00 00    movl   $0x0,0x8(%rax)
         :	                rootopaque->btpo_cycleid = 0;
    0.00 :	  4aae0c:       66 c7 40 0e 00 00       movw   $0x0,0xe(%rax)
         :
         :	                /* NO ELOG(ERROR) till meta is updated */
         :	                START_CRIT_SECTION();
    0.00 :	  4aae12:       8b 05 84 f2 70 00       mov    0x70f284(%rip),%eax        # bba09c <CritSectionCount>
    0.00 :	  4aae18:       83 c0 01                add    $0x1,%eax
    0.00 :	  4aae1b:       89 05 7b f2 70 00       mov    %eax,0x70f27b(%rip)        # bba09c <CritSectionCount>
         :
         :	                metad->btm_root = rootblkno;
    0.00 :	  4aae21:       8b 45 88                mov    -0x78(%rbp),%eax
         :	                metad->btm_level = 0;
    0.00 :	  4aae24:       41 c7 47 0c 00 00 00    movl   $0x0,0xc(%r15)
    0.00 :	  4aae2b:       00 
         :	                metad->btm_fastroot = rootblkno;
         :	                metad->btm_fastlevel = 0;
    0.00 :	  4aae2c:       41 c7 47 14 00 00 00    movl   $0x0,0x14(%r15)
    0.00 :	  4aae33:       00 
         :	                rootopaque->btpo_cycleid = 0;
         :
         :	                /* NO ELOG(ERROR) till meta is updated */
         :	                START_CRIT_SECTION();
         :
         :	                metad->btm_root = rootblkno;
    0.00 :	  4aae34:       41 89 47 08             mov    %eax,0x8(%r15)
         :	                metad->btm_level = 0;
         :	                metad->btm_fastroot = rootblkno;
    0.00 :	  4aae38:       41 89 47 10             mov    %eax,0x10(%r15)
         :	                metad->btm_fastlevel = 0;
         :
         :	                MarkBufferDirty(rootbuf);
    0.00 :	  4aae3c:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aae40:       e8 ab 99 1c 00          callq  6747f0 <MarkBufferDirty>
         :	                MarkBufferDirty(metabuf);
    0.00 :	  4aae45:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae49:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aae4c:       e8 9f 99 1c 00          callq  6747f0 <MarkBufferDirty>
         :
         :	                /* XLOG stuff */
         :	                if (RelationNeedsWAL(rel))
    0.00 :	  4aae51:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  4aae55:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae59:       80 78 6e 70             cmpb   $0x70,0x6e(%rax)
    0.00 :	  4aae5d:       0f 84 0a 02 00 00       je     4ab06d <_bt_getroot+0x44d>
         :
         :	                        PageSetLSN(rootpage, recptr);
         :	                        PageSetLSN(metapg, recptr);
         :	                }
         :
         :	                END_CRIT_SECTION();
    0.00 :	  4aae63:       8b 05 33 f2 70 00       mov    0x70f233(%rip),%eax        # bba09c <CritSectionCount>
         :	                /*
         :	                 * swap root write lock for read lock.  There is no danger of anyone
         :	                 * else accessing the new root page while it's unlocked, since no one
         :	                 * else knows where it is yet.
         :	                 */
         :	                LockBuffer(rootbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aae69:       31 f6                   xor    %esi,%esi
    0.00 :	  4aae6b:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aae6e:       44 89 45 80             mov    %r8d,-0x80(%rbp)
         :
         :	                        PageSetLSN(rootpage, recptr);
         :	                        PageSetLSN(metapg, recptr);
         :	                }
         :
         :	                END_CRIT_SECTION();
    0.00 :	  4aae72:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4aae75:       89 05 21 f2 70 00       mov    %eax,0x70f221(%rip)        # bba09c <CritSectionCount>
         :	                /*
         :	                 * swap root write lock for read lock.  There is no danger of anyone
         :	                 * else accessing the new root page while it's unlocked, since no one
         :	                 * else knows where it is yet.
         :	                 */
         :	                LockBuffer(rootbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aae7b:       e8 90 98 1c 00          callq  674710 <LockBuffer>
         :	                LockBuffer(rootbuf, BT_READ);
    0.00 :	  4aae80:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aae83:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4aae88:       e8 83 98 1c 00          callq  674710 <LockBuffer>
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aae8d:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae91:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aae94:       e8 97 a0 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4aae99:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  4aae9d:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4aaea0:       5b                      pop    %rbx
    0.00 :	  4aaea1:       41 5c                   pop    %r12
    0.00 :	  4aaea3:       41 5d                   pop    %r13
    0.00 :	  4aaea5:       41 5e                   pop    %r14
    0.00 :	  4aaea7:       41 5f                   pop    %r15
    0.00 :	  4aaea9:       c9                      leaveq 
    0.00 :	  4aaeaa:       c3                      retq   
    0.00 :	  4aaeab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        pfree(rel->rd_amcache);
         :	                rel->rd_amcache = NULL;
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aaeb0:       48 8b 15 61 22 6d 00    mov    0x6d2261(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aaeb7:       f7 d0                   not    %eax
    0.00 :	  4aaeb9:       48 98                   cltq   
    0.00 :	  4aaebb:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  4aaebf:       e9 15 fe ff ff          jmpq   4aacd9 <_bt_getroot+0xb9>
    0.00 :	  4aaec4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aaec8:       48 8b 15 49 22 6d 00    mov    0x6d2249(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aaecf:       f7 d0                   not    %eax
    0.00 :	  4aaed1:       48 98                   cltq   
    0.00 :	  4aaed3:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4aaed7:       e9 95 fd ff ff          jmpq   4aac71 <_bt_getroot+0x51>
    0.00 :	  4aaedc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * here than normal.  We *must* check that it's not deleted. If it's
         :	                 * not alone on its level, then we reject too --- this may be overly
         :	                 * paranoid but better safe than sorry.  Note we don't check P_ISROOT,
         :	                 * because that's not set in a "fast root".
         :	                 */
         :	                if (!P_IGNORE(rootopaque) &&
    0.00 :	  4aaee0:       8b 1a                   mov    (%rdx),%ebx
    0.00 :	  4aaee2:       85 db                   test   %ebx,%ebx
    0.00 :	  4aaee4:       0f 85 9f fd ff ff       jne    4aac89 <_bt_getroot+0x69>
    0.00 :	  4aaeea:       44 8b 5a 04             mov    0x4(%rdx),%r11d
    0.00 :	  4aaeee:       45 85 db                test   %r11d,%r11d
    0.00 :	  4aaef1:       0f 85 92 fd ff ff       jne    4aac89 <_bt_getroot+0x69>
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
  100.00 :	  4aaef7:       eb a0                   jmp    4aae99 <_bt_getroot+0x279>
    0.00 :	  4aaef9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aaf00:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aaf03:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  4aaf06:       e8 25 a0 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4aaf0b:       eb 8c                   jmp    4aae99 <_bt_getroot+0x279>
    0.00 :	  4aaf0d:       0f 1f 00                nopl   (%rax)
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aaf10:       41 8b 47 14             mov    0x14(%r15),%eax
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf14:       49 8b be b8 00 00 00    mov    0xb8(%r14),%rdi
    0.00 :	  4aaf1b:       be 18 00 00 00          mov    $0x18,%esi
         :	                /* okay, metadata is correct, release lock on it */
         :	                _bt_relbuf(rel, metabuf);
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
    0.00 :	  4aaf20:       45 8b 6f 10             mov    0x10(%r15),%r13d
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf24:       44 89 45 80             mov    %r8d,-0x80(%rbp)
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aaf28:       89 45 8c                mov    %eax,-0x74(%rbp)
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf2b:       e8 60 df 2e 00          callq  798e90 <MemoryContextAlloc>
    0.00 :	  4aaf30:       49 89 86 18 01 00 00    mov    %rax,0x118(%r14)
         :	                                                                                         sizeof(BTMetaPageData));
         :	                memcpy(rel->rd_amcache, metad, sizeof(BTMetaPageData));
    0.00 :	  4aaf37:       49 8b 17                mov    (%r15),%rdx
    0.00 :	  4aaf3a:       48 89 10                mov    %rdx,(%rax)
    0.00 :	  4aaf3d:       49 8b 57 08             mov    0x8(%r15),%rdx
    0.00 :	  4aaf41:       48 89 50 08             mov    %rdx,0x8(%rax)
    0.00 :	  4aaf45:       49 8b 57 10             mov    0x10(%r15),%rdx
    0.00 :	  4aaf49:       48 89 50 10             mov    %rdx,0x10(%rax)
    0.00 :	  4aaf4d:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aaf51:       45 89 c4                mov    %r8d,%r12d
    0.00 :	  4aaf54:       eb 3a                   jmp    4aaf90 <_bt_getroot+0x370>
    0.00 :	  4aaf56:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4aaf5d:       00 00 00 
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aaf60:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aaf65:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4aaf68:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4aaf6c:       48 03 15 85 4b 71 00    add    0x714b85(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                        rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aaf73:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4aaf77:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
         :
         :	                        if (!P_IGNORE(rootopaque))
    0.00 :	  4aaf7b:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  4aaf7f:       a8 14                   test   $0x14,%al
    0.00 :	  4aaf81:       74 3d                   je     4aafc0 <_bt_getroot+0x3a0>
         :	                                break;
         :
         :	                        /* it's dead, Jim.  step right one page */
         :	                        if (P_RIGHTMOST(rootopaque))
    0.00 :	  4aaf83:       44 8b 6b 04             mov    0x4(%rbx),%r13d
    0.00 :	  4aaf87:       45 85 ed                test   %r13d,%r13d
    0.00 :	  4aaf8a:       0f 84 af 00 00 00       je     4ab03f <_bt_getroot+0x41f>
         :	                 */
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
    0.00 :	  4aaf90:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4aaf93:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4aaf98:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4aaf9b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aaf9e:       e8 3d e0 ff ff          callq  4a8fe0 <_bt_relandgetbuf>
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aafa3:       85 c0                   test   %eax,%eax
         :	                 */
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
    0.00 :	  4aafa5:       41 89 c4                mov    %eax,%r12d
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aafa8:       79 b6                   jns    4aaf60 <_bt_getroot+0x340>
    0.00 :	  4aafaa:       48 8b 15 67 21 6d 00    mov    0x6d2167(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aafb1:       f7 d0                   not    %eax
    0.00 :	  4aafb3:       48 98                   cltq   
    0.00 :	  4aafb5:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4aafb9:       eb b8                   jmp    4aaf73 <_bt_getroot+0x353>
    0.00 :	  4aafbb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                         RelationGetRelationName(rel));
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
    0.00 :	  4aafc0:       8b 45 8c                mov    -0x74(%rbp),%eax
    0.00 :	  4aafc3:       39 43 08                cmp    %eax,0x8(%rbx)
    0.00 :	  4aafc6:       0f 84 cd fe ff ff       je     4aae99 <_bt_getroot+0x279>
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aafcc:       ba 50 47 7b 00          mov    $0x7b4750,%edx
    0.00 :	  4aafd1:       be 32 01 00 00          mov    $0x132,%esi
    0.00 :	  4aafd6:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4aafdb:       e8 40 04 2d 00          callq  77b420 <elog_start>
    0.00 :	  4aafe0:       49 8b 4e 30             mov    0x30(%r14),%rcx
    0.00 :	  4aafe4:       44 8b 4d 8c             mov    -0x74(%rbp),%r9d
    0.00 :	  4aafe8:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4aafeb:       44 8b 43 08             mov    0x8(%rbx),%r8d
    0.00 :	  4aafef:       be 58 46 7b 00          mov    $0x7b4658,%esi
    0.00 :	  4aaff4:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4aaff9:       31 c0                   xor    %eax,%eax
    0.00 :	  4aaffb:       e8 30 02 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4ab000:       e9 0c fd ff ff          jmpq   4aad11 <_bt_getroot+0xf1>
    0.00 :	  4ab005:       0f 1f 00                nopl   (%rax)
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4ab008:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4ab00b:       e8 20 9f 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	                         * deadlocks, we have to release the metadata page and start all
         :	                         * over again.  (Is that really true? But it's hardly worth trying
         :	                         * to optimize this case.)
         :	                         */
         :	                        _bt_relbuf(rel, metabuf);
         :	                        return _bt_getroot(rel, access);
    0.00 :	  4ab010:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4ab013:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4ab016:       e8 05 fc ff ff          callq  4aac20 <_bt_getroot>
    0.00 :	  4ab01b:       41 89 c4                mov    %eax,%r12d
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4ab01e:       e9 76 fe ff ff          jmpq   4aae99 <_bt_getroot+0x279>
    0.00 :	  4ab023:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4ab028:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4ab02b:       48 8b 15 e6 20 6d 00    mov    0x6d20e6(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ab032:       f7 d0                   not    %eax
    0.00 :	  4ab034:       48 98                   cltq   
    0.00 :	  4ab036:       4c 8b 2c c2             mov    (%rdx,%rax,8),%r13
    0.00 :	  4ab03a:       e9 a6 fd ff ff          jmpq   4aade5 <_bt_getroot+0x1c5>
         :	                        if (!P_IGNORE(rootopaque))
         :	                                break;
         :
         :	                        /* it's dead, Jim.  step right one page */
         :	                        if (P_RIGHTMOST(rootopaque))
         :	                                elog(ERROR, "no live root page found in index \"%s\"",
    0.00 :	  4ab03f:       ba 50 47 7b 00          mov    $0x7b4750,%edx
    0.00 :	  4ab044:       be 2a 01 00 00          mov    $0x12a,%esi
    0.00 :	  4ab049:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4ab04e:       e8 cd 03 2d 00          callq  77b420 <elog_start>
    0.00 :	  4ab053:       49 8b 56 30             mov    0x30(%r14),%rdx
    0.00 :	  4ab057:       be 30 46 7b 00          mov    $0x7b4630,%esi
    0.00 :	  4ab05c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ab061:       31 c0                   xor    %eax,%eax
    0.00 :	  4ab063:       e8 c8 01 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4ab068:       e8 63 e4 fb ff          callq  4694d0 <abort@plt>
         :	                {
         :	                        xl_btree_newroot xlrec;
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
    0.00 :	  4ab06d:       49 8b 06                mov    (%r14),%rax
         :	                        rdata.data = (char *) &xlrec;
         :	                        rdata.len = SizeOfBtreeNewroot;
         :	                        rdata.buffer = InvalidBuffer;
         :	                        rdata.next = NULL;
         :
         :	                        recptr = XLogInsert(RM_BTREE_ID, XLOG_BTREE_NEWROOT, &rdata);
    0.00 :	  4ab070:       48 8d 55 90             lea    -0x70(%rbp),%rdx
    0.00 :	  4ab074:       be a0 00 00 00          mov    $0xa0,%esi
    0.00 :	  4ab079:       bf 0b 00 00 00          mov    $0xb,%edi
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
         :	                        xlrec.rootblk = rootblkno;
         :	                        xlrec.level = 0;
    0.00 :	  4ab07e:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
         :
         :	                        rdata.data = (char *) &xlrec;
         :	                        rdata.len = SizeOfBtreeNewroot;
    0.00 :	  4ab085:       c7 45 98 14 00 00 00    movl   $0x14,-0x68(%rbp)
         :	                        rdata.buffer = InvalidBuffer;
    0.00 :	  4ab08c:       c7 45 9c 00 00 00 00    movl   $0x0,-0x64(%rbp)
         :	                        rdata.next = NULL;
    0.00 :	  4ab093:       48 c7 45 a8 00 00 00    movq   $0x0,-0x58(%rbp)
    0.00 :	  4ab09a:       00 
         :	                {
         :	                        xl_btree_newroot xlrec;
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
    0.00 :	  4ab09b:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  4ab09f:       41 8b 46 08             mov    0x8(%r14),%eax
    0.00 :	  4ab0a3:       89 45 b8                mov    %eax,-0x48(%rbp)
         :	                        xlrec.rootblk = rootblkno;
    0.00 :	  4ab0a6:       8b 45 88                mov    -0x78(%rbp),%eax
    0.00 :	  4ab0a9:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	                        xlrec.level = 0;
         :
         :	                        rdata.data = (char *) &xlrec;
    0.00 :	  4ab0ac:       48 8d 45 b0             lea    -0x50(%rbp),%rax
    0.00 :	  4ab0b0:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	                        rdata.len = SizeOfBtreeNewroot;
         :	                        rdata.buffer = InvalidBuffer;
         :	                        rdata.next = NULL;
         :
         :	                        recptr = XLogInsert(RM_BTREE_ID, XLOG_BTREE_NEWROOT, &rdata);
    0.00 :	  4ab0b4:       e8 67 9e 02 00          callq  4d4f20 <XLogInsert>
         :
         :	                        PageSetLSN(rootpage, recptr);
    0.00 :	  4ab0b9:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4ab0bc:       41 89 45 04             mov    %eax,0x4(%r13)
    0.00 :	  4ab0c0:       48 c1 ea 20             shr    $0x20,%rdx
    0.00 :	  4ab0c4:       41 89 55 00             mov    %edx,0x0(%r13)
         :	                        PageSetLSN(metapg, recptr);
    0.00 :	  4ab0c8:       89 13                   mov    %edx,(%rbx)
    0.00 :	  4ab0ca:       89 43 04                mov    %eax,0x4(%rbx)
    0.00 :	  4ab0cd:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4ab0d1:       e9 8d fd ff ff          jmpq   4aae63 <_bt_getroot+0x243>
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
         :	                ereport(ERROR,
    0.00 :	  4ab0d6:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4ab0d9:       b9 50 47 7b 00          mov    $0x7b4750,%ecx
    0.00 :	  4ab0de:       ba ae 00 00 00          mov    $0xae,%edx
    0.00 :	  4ab0e3:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4ab0e8:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ab0ed:       e8 ce f9 2c 00          callq  77aac0 <errstart>
    0.00 :	  4ab0f2:       84 c0                   test   %al,%al
    0.00 :	  4ab0f4:       0f 84 17 fc ff ff       je     4aad11 <_bt_getroot+0xf1>
    0.00 :	  4ab0fa:       41 8b 57 04             mov    0x4(%r15),%edx
    0.00 :	  4ab0fe:       49 8b 76 30             mov    0x30(%r14),%rsi
    0.00 :	  4ab102:       b9 02 00 00 00          mov    $0x2,%ecx
    0.00 :	  4ab107:       bf e8 45 7b 00          mov    $0x7b45e8,%edi
    0.00 :	  4ab10c:       31 c0                   xor    %eax,%eax
    0.00 :	  4ab10e:       e8 8d 17 2d 00          callq  77c8a0 <errmsg>
    0.00 :	  4ab113:       e9 18 fc ff ff          jmpq   4aad30 <_bt_getroot+0x110>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ace60 <_bt_binsrch>:
         :	_bt_binsrch(Relation rel,
         :	                        Buffer buf,
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        bool nextkey)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
  100.00 :	  4ace60:       55                      push   %rbp
    0.00 :	  4ace61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ace64:       41 57                   push   %r15
    0.00 :	  4ace66:       41 56                   push   %r14
    0.00 :	  4ace68:       41 55                   push   %r13
    0.00 :	  4ace6a:       41 54                   push   %r12
    0.00 :	  4ace6c:       53                      push   %rbx
    0.00 :	  4ace6d:       48 83 ec 28             sub    $0x28,%rsp
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4ace71:       85 f6                   test   %esi,%esi
         :	_bt_binsrch(Relation rel,
         :	                        Buffer buf,
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        bool nextkey)
         :	{
    0.00 :	  4ace73:       48 89 4d b0             mov    %rcx,-0x50(%rbp)
    0.00 :	  4ace77:       48 89 7d c0             mov    %rdi,-0x40(%rbp)
    0.00 :	  4ace7b:       89 55 bc                mov    %edx,-0x44(%rbp)
    0.00 :	  4ace7e:       44 89 c1                mov    %r8d,%ecx
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4ace81:       0f 88 c9 00 00 00       js     4acf50 <_bt_binsrch+0xf0>
    0.00 :	  4ace87:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ace8a:       4c 63 f0                movslq %eax,%r14
    0.00 :	  4ace8d:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  4ace91:       4c 03 35 60 2c 71 00    add    0x712c60(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ace98:       41 0f b7 46 10          movzwl 0x10(%r14),%eax
    0.00 :	  4ace9d:       49 8d 04 06             lea    (%r14,%rax,1),%rax
    0.00 :	  4acea1:       48 89 45 c8             mov    %rax,-0x38(%rbp)
         :
         :	        low = P_FIRSTDATAKEY(opaque);
    0.00 :	  4acea5:       83 78 04 01             cmpl   $0x1,0x4(%rax)
         :	        high = PageGetMaxOffsetNumber(page);
    0.00 :	  4acea9:       41 0f b7 46 0c          movzwl 0xc(%r14),%eax
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :
         :	        low = P_FIRSTDATAKEY(opaque);
    0.00 :	  4aceae:       45 19 ed                sbb    %r13d,%r13d
    0.00 :	  4aceb1:       41 83 c5 02             add    $0x2,%r13d
         :	        high = PageGetMaxOffsetNumber(page);
    0.00 :	  4aceb5:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4aceb9:       0f 86 7f 00 00 00       jbe    4acf3e <_bt_binsrch+0xde>
    0.00 :	  4acebf:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4acec2:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4acec6:       48 c1 e8 02             shr    $0x2,%rax
         :	         * this covers two cases: the page is really empty (no keys), or it
         :	         * contains only a high key.  The latter case is possible after vacuuming.
         :	         * This can never happen on an internal page, however, since they are
         :	         * never empty (an internal page must have children).
         :	         */
         :	        if (high < low)
    0.00 :	  4aceca:       66 41 39 c5             cmp    %ax,%r13w
    0.00 :	  4acece:       77 6e                   ja     4acf3e <_bt_binsrch+0xde>
         :	         * For nextkey=true (cmpval=0), the loop invariant is: all slots before
         :	         * 'low' are <= scan key, all slots at or after 'high' are > scan key.
         :	         *
         :	         * We can fall out when high == low.
         :	         */
         :	        high++;                                         /* establish the loop invariant for high */
    0.00 :	  4aced0:       44 8d 60 01             lea    0x1(%rax),%r12d
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
    0.00 :	  4aced4:       31 c0                   xor    %eax,%eax
    0.00 :	  4aced6:       84 c9                   test   %cl,%cl
    0.00 :	  4aced8:       0f 94 c0                sete   %al
    0.00 :	  4acedb:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :
         :	        while (high > low)
    0.00 :	  4acede:       66 45 39 e5             cmp    %r12w,%r13w
    0.00 :	  4acee2:       73 4c                   jae    4acf30 <_bt_binsrch+0xd0>
    0.00 :	  4acee4:       45 0f b7 fd             movzwl %r13w,%r15d
    0.00 :	  4acee8:       eb 0f                   jmp    4acef9 <_bt_binsrch+0x99>
    0.00 :	  4aceea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  4acef0:       66 44 39 eb             cmp    %r13w,%bx
    0.00 :	  4acef4:       41 89 dc                mov    %ebx,%r12d
    0.00 :	  4acef7:       76 37                   jbe    4acf30 <_bt_binsrch+0xd0>
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
    0.00 :	  4acef9:       41 0f b7 c4             movzwl %r12w,%eax
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
    0.00 :	  4acefd:       8b 75 bc                mov    -0x44(%rbp),%esi
    0.00 :	  4acf00:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
         :
         :	        while (high > low)
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
    0.00 :	  4acf04:       44 29 f8                sub    %r15d,%eax
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
    0.00 :	  4acf07:       4c 89 f1                mov    %r14,%rcx
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
         :
         :	        while (high > low)
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
    0.00 :	  4acf0a:       89 c2                   mov    %eax,%edx
    0.00 :	  4acf0c:       c1 ea 1f                shr    $0x1f,%edx
    0.00 :	  4acf0f:       01 c2                   add    %eax,%edx
    0.00 :	  4acf11:       d1 fa                   sar    %edx
    0.00 :	  4acf13:       41 8d 5c 15 00          lea    0x0(%r13,%rdx,1),%ebx
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
    0.00 :	  4acf18:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  4acf1c:       44 0f b7 c3             movzwl %bx,%r8d
    0.00 :	  4acf20:       e8 2b fd ff ff          callq  4acc50 <_bt_compare>
         :
         :	                if (result >= cmpval)
    0.00 :	  4acf25:       39 45 d4                cmp    %eax,-0x2c(%rbp)
    0.00 :	  4acf28:       7f c6                   jg     4acef0 <_bt_binsrch+0x90>
         :	                        low = mid + 1;
    0.00 :	  4acf2a:       44 8d 6b 01             lea    0x1(%rbx),%r13d
    0.00 :	  4acf2e:       eb ae                   jmp    4acede <_bt_binsrch+0x7e>
         :	         * past the last slot on the page.
         :	         *
         :	         * On a leaf page, we always return the first key >= scan key (resp. >
         :	         * scan key), which could be the last slot + 1.
         :	         */
         :	        if (P_ISLEAF(opaque))
    0.00 :	  4acf30:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4acf34:       f6 40 0c 01             testb  $0x1,0xc(%rax)
    0.00 :	  4acf38:       75 04                   jne    4acf3e <_bt_binsrch+0xde>
         :	         * On a non-leaf page, return the last key < scan key (resp. <= scan key).
         :	         * There must be one if _bt_compare() is playing by the rules.
         :	         */
         :	        Assert(low > P_FIRSTDATAKEY(opaque));
         :
         :	        return OffsetNumberPrev(low);
    0.00 :	  4acf3a:       41 83 ed 01             sub    $0x1,%r13d
         :	}
    0.00 :	  4acf3e:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  4acf42:       44 89 e8                mov    %r13d,%eax
    0.00 :	  4acf45:       5b                      pop    %rbx
    0.00 :	  4acf46:       41 5c                   pop    %r12
    0.00 :	  4acf48:       41 5d                   pop    %r13
    0.00 :	  4acf4a:       41 5e                   pop    %r14
    0.00 :	  4acf4c:       41 5f                   pop    %r15
    0.00 :	  4acf4e:       c9                      leaveq 
    0.00 :	  4acf4f:       c3                      retq   
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4acf50:       48 8b 05 c1 01 6d 00    mov    0x6d01c1(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4acf57:       f7 d6                   not    %esi
    0.00 :	  4acf59:       48 63 d6                movslq %esi,%rdx
    0.00 :	  4acf5c:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  4acf60:       e9 33 ff ff ff          jmpq   4ace98 <_bt_binsrch+0x38>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1281
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004add60 <_bt_fix_scankey_strategy>:
         :	 * there shouldn't be any problem, since the index's indoptions are certainly
         :	 * not going to change while the scankey survives.
         :	 */
         :	static bool
         :	_bt_fix_scankey_strategy(ScanKey skey, int16 *indoption)
         :	{
    0.00 :	  4add60:       55                      push   %rbp
         :	        int                     addflags;
         :
         :	        addflags = indoption[skey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
    0.00 :	  4add61:       48 0f bf 47 04          movswq 0x4(%rdi),%rax
         :	         *
         :	         * Note: someday we might have to fill in sk_collation from the index
         :	         * column's collation.  At the moment this is a non-issue because we'll
         :	         * never actually call the comparison operator on a NULL.
         :	         */
         :	        if (skey->sk_flags & SK_ISNULL)
    0.00 :	  4add66:       8b 0f                   mov    (%rdi),%ecx
         :	 * there shouldn't be any problem, since the index's indoptions are certainly
         :	 * not going to change while the scankey survives.
         :	 */
         :	static bool
         :	_bt_fix_scankey_strategy(ScanKey skey, int16 *indoption)
         :	{
    0.00 :	  4add68:       48 89 e5                mov    %rsp,%rbp
         :	        int                     addflags;
         :
         :	        addflags = indoption[skey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
    0.00 :	  4add6b:       0f bf 54 46 fe          movswl -0x2(%rsi,%rax,2),%edx
    0.00 :	  4add70:       c1 e2 18                shl    $0x18,%edx
         :	         *
         :	         * Note: someday we might have to fill in sk_collation from the index
         :	         * column's collation.  At the moment this is a non-issue because we'll
         :	         * never actually call the comparison operator on a NULL.
         :	         */
         :	        if (skey->sk_flags & SK_ISNULL)
    0.00 :	  4add73:       f6 c1 01                test   $0x1,%cl
    0.00 :	  4add76:       74 40                   je     4addb8 <_bt_fix_scankey_strategy+0x58>
         :	        {
         :	                /* SK_ISNULL shouldn't be set in a row header scankey */
         :	                Assert(!(skey->sk_flags & SK_ROW_HEADER));
         :
         :	                /* Set indoption flags in scankey (might be done already) */
         :	                skey->sk_flags |= addflags;
    0.00 :	  4add78:       09 ca                   or     %ecx,%edx
         :
         :	                /* Set correct strategy for IS NULL or NOT NULL search */
         :	                if (skey->sk_flags & SK_SEARCHNULL)
    0.00 :	  4add7a:       f6 c2 40                test   $0x40,%dl
         :	        {
         :	                /* SK_ISNULL shouldn't be set in a row header scankey */
         :	                Assert(!(skey->sk_flags & SK_ROW_HEADER));
         :
         :	                /* Set indoption flags in scankey (might be done already) */
         :	                skey->sk_flags |= addflags;
    0.00 :	  4add7d:       89 17                   mov    %edx,(%rdi)
         :
         :	                /* Set correct strategy for IS NULL or NOT NULL search */
         :	                if (skey->sk_flags & SK_SEARCHNULL)
    0.00 :	  4add7f:       0f 85 bb 00 00 00       jne    4ade40 <_bt_fix_scankey_strategy+0xe0>
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
         :	                        subkey->sk_flags |= addflags;
         :	                        if (subkey->sk_flags & SK_ROW_END)
         :	                                break;
         :	                        subkey++;
         :	                }
    0.00 :	  4add85:       31 c0                   xor    %eax,%eax
         :	                {
         :	                        skey->sk_strategy = BTEqualStrategyNumber;
         :	                        skey->sk_subtype = InvalidOid;
         :	                        skey->sk_collation = InvalidOid;
         :	                }
         :	                else if (skey->sk_flags & SK_SEARCHNOTNULL)
    0.00 :	  4add87:       84 d2                   test   %dl,%dl
    0.00 :	  4add89:       79 28                   jns    4addb3 <_bt_fix_scankey_strategy+0x53>
         :	                {
         :	                        if (skey->sk_flags & SK_BT_NULLS_FIRST)
    0.00 :	  4add8b:       81 e2 00 00 00 02       and    $0x2000000,%edx
         :	                                skey->sk_strategy = BTGreaterStrategyNumber;
         :	                        else
         :	                                skey->sk_strategy = BTLessStrategyNumber;
         :	                        skey->sk_subtype = InvalidOid;
    0.00 :	  4add91:       c7 47 08 00 00 00 00    movl   $0x0,0x8(%rdi)
         :	                        skey->sk_collation = InvalidOid;
    0.00 :	  4add98:       c7 47 0c 00 00 00 00    movl   $0x0,0xc(%rdi)
         :	                        skey->sk_collation = InvalidOid;
         :	                }
         :	                else if (skey->sk_flags & SK_SEARCHNOTNULL)
         :	                {
         :	                        if (skey->sk_flags & SK_BT_NULLS_FIRST)
         :	                                skey->sk_strategy = BTGreaterStrategyNumber;
    0.00 :	  4add9f:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  4adda2:       19 c0                   sbb    %eax,%eax
    0.00 :	  4adda4:       83 e0 fc                and    $0xfffffffc,%eax
    0.00 :	  4adda7:       83 c0 05                add    $0x5,%eax
    0.00 :	  4addaa:       66 89 47 06             mov    %ax,0x6(%rdi)
         :	                        else
         :	                                skey->sk_strategy = BTLessStrategyNumber;
         :	                        skey->sk_subtype = InvalidOid;
         :	                        skey->sk_collation = InvalidOid;
    0.00 :	  4addae:       b8 01 00 00 00          mov    $0x1,%eax
         :	                        subkey++;
         :	                }
         :	        }
         :
         :	        return true;
         :	}
    0.00 :	  4addb3:       c9                      leaveq 
    0.00 :	  4addb4:       c3                      retq   
    0.00 :	  4addb5:       0f 1f 00                nopl   (%rax)
         :	                /* Needn't do the rest */
         :	                return true;
         :	        }
         :
         :	        /* Adjust strategy for DESC, if we didn't already */
         :	        if ((addflags & SK_BT_DESC) && !(skey->sk_flags & SK_BT_DESC))
    0.00 :	  4addb8:       f7 c2 00 00 00 01       test   $0x1000000,%edx
    0.00 :	  4addbe:       74 15                   je     4addd5 <_bt_fix_scankey_strategy+0x75>
    0.00 :	  4addc0:       f7 c1 00 00 00 01       test   $0x1000000,%ecx
    0.00 :	  4addc6:       75 0d                   jne    4addd5 <_bt_fix_scankey_strategy+0x75>
         :	                skey->sk_strategy = BTCommuteStrategyNumber(skey->sk_strategy);
    0.00 :	  4addc8:       b8 06 00 00 00          mov    $0x6,%eax
    0.00 :	  4addcd:       66 2b 47 06             sub    0x6(%rdi),%ax
    0.00 :	  4addd1:       66 89 47 06             mov    %ax,0x6(%rdi)
         :	        skey->sk_flags |= addflags;
    0.00 :	  4addd5:       89 c8                   mov    %ecx,%eax
    0.00 :	  4addd7:       09 d0                   or     %edx,%eax
         :
         :	        /* If it's a row header, fix row member flags and strategies similarly */
         :	        if (skey->sk_flags & SK_ROW_HEADER)
    0.00 :	  4addd9:       a8 04                   test   $0x4,%al
         :	        }
         :
         :	        /* Adjust strategy for DESC, if we didn't already */
         :	        if ((addflags & SK_BT_DESC) && !(skey->sk_flags & SK_BT_DESC))
         :	                skey->sk_strategy = BTCommuteStrategyNumber(skey->sk_strategy);
         :	        skey->sk_flags |= addflags;
    0.00 :	  4adddb:       89 07                   mov    %eax,(%rdi)
         :
         :	        /* If it's a row header, fix row member flags and strategies similarly */
         :	        if (skey->sk_flags & SK_ROW_HEADER)
    0.00 :	  4adddd:       74 59                   je     4ade38 <_bt_fix_scankey_strategy+0xd8>
         :	        {
         :	                ScanKey         subkey = (ScanKey) DatumGetPointer(skey->sk_argument);
    0.00 :	  4adddf:       48 8b 57 40             mov    0x40(%rdi),%rdx
         :	                for (;;)
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        addflags = indoption[subkey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
         :	                        if ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
    0.00 :	  4adde3:       41 b8 06 00 00 00       mov    $0x6,%r8d
    0.00 :	  4adde9:       eb 15                   jmp    4ade00 <_bt_fix_scankey_strategy+0xa0>
    0.00 :	  4addeb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	                for (;;)
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        addflags = indoption[subkey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
         :	                        if ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))
    0.00 :	  4addf0:       8b 3a                   mov    (%rdx),%edi
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4addf2:       89 f8                   mov    %edi,%eax
    0.00 :	  4addf4:       09 c8                   or     %ecx,%eax
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4addf6:       a8 10                   test   $0x10,%al
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        addflags = indoption[subkey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
         :	                        if ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4addf8:       89 02                   mov    %eax,(%rdx)
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4addfa:       75 3c                   jne    4ade38 <_bt_fix_scankey_strategy+0xd8>
         :	                                break;
         :	                        subkey++;
    0.00 :	  4addfc:       48 83 c2 48             add    $0x48,%rdx
         :	                ScanKey         subkey = (ScanKey) DatumGetPointer(skey->sk_argument);
         :
         :	                for (;;)
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        addflags = indoption[subkey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
    0.00 :	  4ade00:       48 0f bf 42 04          movswq 0x4(%rdx),%rax
    0.00 :	  4ade05:       0f bf 4c 46 fe          movswl -0x2(%rsi,%rax,2),%ecx
    0.00 :	  4ade0a:       c1 e1 18                shl    $0x18,%ecx
         :	                        if ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))
    0.00 :	  4ade0d:       f7 c1 00 00 00 01       test   $0x1000000,%ecx
    0.00 :	  4ade13:       74 db                   je     4addf0 <_bt_fix_scankey_strategy+0x90>
    0.00 :	  4ade15:       8b 3a                   mov    (%rdx),%edi
    0.00 :	  4ade17:       f7 c7 00 00 00 01       test   $0x1000000,%edi
    0.00 :	  4ade1d:       75 d3                   jne    4addf2 <_bt_fix_scankey_strategy+0x92>
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
    0.00 :	  4ade1f:       44 89 c0                mov    %r8d,%eax
    0.00 :	  4ade22:       66 2b 42 06             sub    0x6(%rdx),%ax
    0.00 :	  4ade26:       66 89 42 06             mov    %ax,0x6(%rdx)
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4ade2a:       89 f8                   mov    %edi,%eax
    0.00 :	  4ade2c:       09 c8                   or     %ecx,%eax
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ade2e:       a8 10                   test   $0x10,%al
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        addflags = indoption[subkey->sk_attno - 1] << SK_BT_INDOPTION_SHIFT;
         :	                        if ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))
         :	                                subkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4ade30:       89 02                   mov    %eax,(%rdx)
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ade32:       74 c8                   je     4addfc <_bt_fix_scankey_strategy+0x9c>
    0.00 :	  4ade34:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                break;
         :	                        subkey++;
         :	                }
    0.00 :	  4ade38:       b8 01 00 00 00          mov    $0x1,%eax
         :	        }
         :
         :	        return true;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1281
  100.00 :	  4ade3d:       c9                      leaveq 
    0.00 :	  4ade3e:       c3                      retq   
    0.00 :	  4ade3f:       90                      nop
         :	                skey->sk_flags |= addflags;
         :
         :	                /* Set correct strategy for IS NULL or NOT NULL search */
         :	                if (skey->sk_flags & SK_SEARCHNULL)
         :	                {
         :	                        skey->sk_strategy = BTEqualStrategyNumber;
    0.00 :	  4ade40:       66 c7 47 06 03 00       movw   $0x3,0x6(%rdi)
         :	                        skey->sk_subtype = InvalidOid;
    0.00 :	  4ade46:       c7 47 08 00 00 00 00    movl   $0x0,0x8(%rdi)
         :	                        skey->sk_collation = InvalidOid;
    0.00 :	  4ade4d:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  4ade52:       c7 47 0c 00 00 00 00    movl   $0x0,0xc(%rdi)
         :	                        subkey++;
         :	                }
         :	        }
         :
         :	        return true;
         :	}
    0.00 :	  4ade59:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xact.c:710
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004c0c50 <GetCurrentTransactionNestLevel>:
         :	 * Note: this will return zero when not inside any transaction, one when
         :	 * inside a top-level transaction, etc.
         :	 */
         :	int
         :	GetCurrentTransactionNestLevel(void)
         :	{
    0.00 :	  4c0c50:       48 8b 05 d1 71 6a 00    mov    0x6a71d1(%rip),%rax        # b67e28 <CurrentTransactionState>
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xact.c:710
  100.00 :	  4c0c57:       55                      push   %rbp
    0.00 :	  4c0c58:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4c0c5b:       8b 40 1c                mov    0x1c(%rax),%eax
         :	        TransactionState s = CurrentTransactionState;
         :
         :	        return s->nestingLevel;
         :	}
    0.00 :	  4c0c5e:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:4648
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ccfc0 <DataChecksumsEnabled>:
         :	/*
         :	 * Are checksums enabled for data pages?
         :	 */
         :	bool
         :	DataChecksumsEnabled(void)
         :	{
    0.00 :	  4ccfc0:       48 8b 05 d9 c1 6a 00    mov    0x6ac1d9(%rip),%rax        # b791a0 <ControlFile>
  100.00 :	  4ccfc7:       55                      push   %rbp
    0.00 :	  4ccfc8:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ccfcb:       8b 80 ec 00 00 00       mov    0xec(%rax),%eax
         :	        Assert(ControlFile != NULL);
         :	        return (ControlFile->data_checksum_version > 0);
         :	}
    0.00 :	  4ccfd1:       c9                      leaveq 
         :	/*
         :	 * Are checksums enabled for data pages?
         :	 */
         :	bool
         :	DataChecksumsEnabled(void)
         :	{
    0.00 :	  4ccfd2:       85 c0                   test   %eax,%eax
    0.00 :	  4ccfd4:       0f 95 c0                setne  %al

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5161
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005acf10 <ExecQual>:
         :	 *
         :	 * ----------------------------------------------------------------
         :	 */
         :	bool
         :	ExecQual(List *qual, ExprContext *econtext, bool resultForNull)
         :	{
    0.00 :	  5acf10:       55                      push   %rbp
    0.00 :	  5acf11:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5acf14:       41 57                   push   %r15
    0.00 :	  5acf16:       41 56                   push   %r14
    0.00 :	  5acf18:       41 89 d6                mov    %edx,%r14d
    0.00 :	  5acf1b:       41 55                   push   %r13
    0.00 :	  5acf1d:       41 54                   push   %r12
    0.00 :	  5acf1f:       49 89 f4                mov    %rsi,%r12
    0.00 :	  5acf22:       53                      push   %rbx
    0.00 :	  5acf23:       48 83 ec 18             sub    $0x18,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf27:       48 8b 46 28             mov    0x28(%rsi),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5acf2b:       48 85 ff                test   %rdi,%rdi
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5acf2e:       4c 8b 3d 2b d9 60 00    mov    0x60d92b(%rip),%r15        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf35:       48 89 05 24 d9 60 00    mov    %rax,0x60d924(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5acf3c:       74 4a                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf3e:       48 8b 5f 08             mov    0x8(%rdi),%rbx
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
  100.00 :	  5acf42:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf45:       74 41                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf47:       4c 8d 6d d7             lea    -0x29(%rbp),%r13
    0.00 :	  5acf4b:       eb 11                   jmp    5acf5e <ExecQual+0x4e>
    0.00 :	  5acf4d:       0f 1f 00                nopl   (%rax)
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
         :
         :	                if (isNull)
         :	                {
         :	                        if (resultForNull == false)
    0.00 :	  5acf50:       45 84 f6                test   %r14b,%r14b
    0.00 :	  5acf53:       74 24                   je     5acf79 <ExecQual+0x69>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf55:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5acf59:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf5c:       74 2a                   je     5acf88 <ExecQual+0x78>
         :	        {
         :	                ExprState  *clause = (ExprState *) lfirst(l);
    0.00 :	  5acf5e:       48 8b 03                mov    (%rbx),%rax
         :	                Datum           expr_value;
         :	                bool            isNull;
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
    0.00 :	  5acf61:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5acf63:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  5acf66:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5acf69:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5acf6c:       ff 50 10                callq  *0x10(%rax)
         :
         :	                if (isNull)
    0.00 :	  5acf6f:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  5acf73:       75 db                   jne    5acf50 <ExecQual+0x40>
         :	                                break;
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        if (!DatumGetBool(expr_value))
    0.00 :	  5acf75:       84 c0                   test   %al,%al
    0.00 :	  5acf77:       75 dc                   jne    5acf55 <ExecQual+0x45>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf79:       31 c0                   xor    %eax,%eax
    0.00 :	  5acf7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5acf80:       eb 0b                   jmp    5acf8d <ExecQual+0x7d>
    0.00 :	  5acf82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5acf88:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5acf8d:       4c 89 3d cc d8 60 00    mov    %r15,0x60d8cc(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return result;
         :	}
    0.00 :	  5acf94:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5acf98:       5b                      pop    %rbx
    0.00 :	  5acf99:       41 5c                   pop    %r12
    0.00 :	  5acf9b:       41 5d                   pop    %r13
    0.00 :	  5acf9d:       41 5e                   pop    %r14
    0.00 :	  5acf9f:       41 5f                   pop    %r15
    0.00 :	  5acfa1:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2672
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b0d90 <ExecEvalScalarArrayOp>:
         :	 */
         :	static Datum
         :	ExecEvalScalarArrayOp(ScalarArrayOpExprState *sstate,
         :	                                          ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5b0d90:       55                      push   %rbp
    0.00 :	  5b0d91:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b0d94:       41 57                   push   %r15
    0.00 :	  5b0d96:       41 56                   push   %r14
    0.00 :	  5b0d98:       41 55                   push   %r13
    0.00 :	  5b0d9a:       41 54                   push   %r12
    0.00 :	  5b0d9c:       49 89 f4                mov    %rsi,%r12
    0.00 :	  5b0d9f:       53                      push   %rbx
    0.00 :	  5b0da0:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b0da3:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  5b0da7:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        ScalarArrayOpExpr *opexpr = (ScalarArrayOpExpr *) sstate->fxprstate.xprstate.expr;
    0.00 :	  5b0dab:       48 8b 47 08             mov    0x8(%rdi),%rax
         :	        bits8      *bitmap;
         :	        int                     bitmask;
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
         :	        if (isDone)
    0.00 :	  5b0daf:       48 85 c9                test   %rcx,%rcx
         :	ExecEvalScalarArrayOp(ScalarArrayOpExprState *sstate,
         :	                                          ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        ScalarArrayOpExpr *opexpr = (ScalarArrayOpExpr *) sstate->fxprstate.xprstate.expr;
         :	        bool            useOr = opexpr->useOr;
    0.00 :	  5b0db2:       0f b6 50 0c             movzbl 0xc(%rax),%edx
    0.00 :	  5b0db6:       88 55 bf                mov    %dl,-0x41(%rbp)
         :	        char       *s;
         :	        bits8      *bitmap;
         :	        int                     bitmask;
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
    0.00 :	  5b0db9:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b0dbd:       c6 02 00                movb   $0x0,(%rdx)
         :	        if (isDone)
    0.00 :	  5b0dc0:       74 06                   je     5b0dc8 <ExecEvalScalarArrayOp+0x38>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b0dc2:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /*
         :	         * Initialize function cache if first time through
         :	         */
         :	        if (sstate->fxprstate.func.fn_oid == InvalidOid)
    0.00 :	  5b0dc8:       44 8b 43 28             mov    0x28(%rbx),%r8d
    0.00 :	  5b0dcc:       45 85 c0                test   %r8d,%r8d
    0.00 :	  5b0dcf:       0f 84 43 02 00 00       je     5b1018 <ExecEvalScalarArrayOp+0x288>
         :	        }
         :
         :	        /*
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
    0.00 :	  5b0dd5:       48 8d 4b 70             lea    0x70(%rbx),%rcx
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
    0.00 :	  5b0dd9:       4c 89 e2                mov    %r12,%rdx
         :	        }
         :
         :	        /*
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
    0.00 :	  5b0ddc:       48 89 4d c8             mov    %rcx,-0x38(%rbp)
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
    0.00 :	  5b0de0:       48 8b 73 18             mov    0x18(%rbx),%rsi
    0.00 :	  5b0de4:       48 89 cf                mov    %rcx,%rdi
    0.00 :	  5b0de7:       e8 44 c6 ff ff          callq  5ad430 <ExecEvalFuncArgs>
         :	        if (argDone != ExprSingleResult)
    0.00 :	  5b0dec:       85 c0                   test   %eax,%eax
    0.00 :	  5b0dee:       0f 85 a0 03 00 00       jne    5b1194 <ExecEvalScalarArrayOp+0x404>
         :
         :	        /*
         :	         * If the array is NULL then we return NULL --- it's not very meaningful
         :	         * to do anything else, even if the operator isn't strict.
         :	         */
         :	        if (fcinfo->argnull[1])
    0.00 :	  5b0df4:       80 bb b1 03 00 00 00    cmpb   $0x0,0x3b1(%rbx)
    0.00 :	  5b0dfb:       74 1b                   je     5b0e18 <ExecEvalScalarArrayOp+0x88>
         :	        {
         :	                *isNull = true;
    0.00 :	  5b0dfd:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5b0e01:       c6 00 01                movb   $0x1,(%rax)
    0.00 :	  5b0e04:       31 c0                   xor    %eax,%eax
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b0e06:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5b0e0a:       5b                      pop    %rbx
    0.00 :	  5b0e0b:       41 5c                   pop    %r12
    0.00 :	  5b0e0d:       41 5d                   pop    %r13
    0.00 :	  5b0e0f:       41 5e                   pop    %r14
    0.00 :	  5b0e11:       41 5f                   pop    %r15
    0.00 :	  5b0e13:       c9                      leaveq 
    0.00 :	  5b0e14:       c3                      retq   
    0.00 :	  5b0e15:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                *isNull = true;
         :	                return (Datum) 0;
         :	        }
         :	        /* Else okay to fetch and detoast the array */
         :	        arr = DatumGetArrayTypeP(fcinfo->arg[1]);
    0.00 :	  5b0e18:       48 8b bb 98 00 00 00    mov    0x98(%rbx),%rdi
    0.00 :	  5b0e1f:       e8 ec de 1c 00          callq  77ed10 <pg_detoast_datum>
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e24:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  5b0e27:       48 8d 70 10             lea    0x10(%rax),%rsi
         :	        {
         :	                *isNull = true;
         :	                return (Datum) 0;
         :	        }
         :	        /* Else okay to fetch and detoast the array */
         :	        arr = DatumGetArrayTypeP(fcinfo->arg[1]);
    0.00 :	  5b0e2b:       49 89 c5                mov    %rax,%r13
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e2e:       e8 1d 35 11 00          callq  6c4350 <ArrayGetNItems>
         :	        if (nitems <= 0)
    0.00 :	  5b0e33:       85 c0                   test   %eax,%eax
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e35:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	        if (nitems <= 0)
    0.00 :	  5b0e38:       0f 8e 3a 03 00 00       jle    5b1178 <ExecEvalScalarArrayOp+0x3e8>
         :
         :	        /*
         :	         * If the scalar is NULL, and the function is strict, return NULL; no
         :	         * point in iterating the loop.
         :	         */
         :	        if (fcinfo->argnull[0] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0e3e:       80 bb b0 03 00 00 00    cmpb   $0x0,0x3b0(%rbx)
    0.00 :	  5b0e45:       0f 85 f5 01 00 00       jne    5b1040 <ExecEvalScalarArrayOp+0x2b0>
         :
         :	        /*
         :	         * We arrange to look up info about the element type only once per series
         :	         * of calls, assuming the element type doesn't change underneath us.
         :	         */
         :	        if (sstate->element_type != ARR_ELEMTYPE(arr))
    0.00 :	  5b0e4b:       41 8b 7d 0c             mov    0xc(%r13),%edi
    0.00 :	  5b0e4f:       39 bb 18 04 00 00       cmp    %edi,0x418(%rbx)
    0.00 :	  5b0e55:       74 24                   je     5b0e7b <ExecEvalScalarArrayOp+0xeb>
         :	        {
         :	                get_typlenbyvalalign(ARR_ELEMTYPE(arr),
    0.00 :	  5b0e57:       48 8d 8b 1f 04 00 00    lea    0x41f(%rbx),%rcx
    0.00 :	  5b0e5e:       48 8d 93 1e 04 00 00    lea    0x41e(%rbx),%rdx
    0.00 :	  5b0e65:       48 8d b3 1c 04 00 00    lea    0x41c(%rbx),%rsi
    0.00 :	  5b0e6c:       e8 ff 1f 1c 00          callq  772e70 <get_typlenbyvalalign>
         :	                                                         &sstate->typlen,
         :	                                                         &sstate->typbyval,
         :	                                                         &sstate->typalign);
         :	                sstate->element_type = ARR_ELEMTYPE(arr);
    0.00 :	  5b0e71:       41 8b 45 0c             mov    0xc(%r13),%eax
    0.00 :	  5b0e75:       89 83 18 04 00 00       mov    %eax,0x418(%rbx)
         :	        }
         :	        typlen = sstate->typlen;
    0.00 :	  5b0e7b:       0f b7 8b 1c 04 00 00    movzwl 0x41c(%rbx),%ecx
    0.00 :	  5b0e82:       66 89 4d d4             mov    %cx,-0x2c(%rbp)
         :	        typbyval = sstate->typbyval;
    0.00 :	  5b0e86:       0f b6 83 1e 04 00 00    movzbl 0x41e(%rbx),%eax
    0.00 :	  5b0e8d:       88 45 d6                mov    %al,-0x2a(%rbp)
         :	        typalign = sstate->typalign;
    0.00 :	  5b0e90:       0f b6 93 1f 04 00 00    movzbl 0x41f(%rbx),%edx
    0.00 :	  5b0e97:       88 55 d7                mov    %dl,-0x29(%rbp)
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b0e9a:       41 8b 45 08             mov    0x8(%r13),%eax
    0.00 :	  5b0e9e:       85 c0                   test   %eax,%eax
    0.00 :	  5b0ea0:       0f 84 ba 02 00 00       je     5b1160 <ExecEvalScalarArrayOp+0x3d0>
    0.00 :	  5b0ea6:       48 98                   cltq   
    0.00 :	  5b0ea8:       4d 8d 64 05 00          lea    0x0(%r13,%rax,1),%r12
         :	        bitmap = ARR_NULLBITMAP(arr);
    0.00 :	  5b0ead:       49 63 45 04             movslq 0x4(%r13),%rax
    0.00 :	  5b0eb1:       4d 8d 7c c5 10          lea    0x10(%r13,%rax,8),%r15
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0eb6:       48 0f bf 4d d4          movswq -0x2c(%rbp),%rcx
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b0ebb:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b0ebf:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5b0ec2:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0ec8:       48 89 4d a8             mov    %rcx,-0x58(%rbp)
    0.00 :	  5b0ecc:       eb 47                   jmp    5b0f15 <ExecEvalScalarArrayOp+0x185>
    0.00 :	  5b0ece:       66 90                   xchg   %ax,%ax
         :	                        fcinfo->arg[1] = elt;
         :	                        fcinfo->argnull[1] = false;
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0ed0:       80 7b 2e 00             cmpb   $0x0,0x2e(%rbx)
         :	                Datum           thisresult;
         :
         :	                /* Get array element, checking for NULL */
         :	                if (bitmap && (*bitmap & bitmask) == 0)
         :	                {
         :	                        fcinfo->arg[1] = (Datum) 0;
    0.00 :	  5b0ed4:       48 c7 83 98 00 00 00    movq   $0x0,0x98(%rbx)
    0.00 :	  5b0edb:       00 00 00 00 
         :	                        fcinfo->argnull[1] = true;
    0.00 :	  5b0edf:       c6 83 b1 03 00 00 01    movb   $0x1,0x3b1(%rbx)
         :	                        fcinfo->arg[1] = elt;
         :	                        fcinfo->argnull[1] = false;
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0ee6:       0f 84 a5 00 00 00       je     5b0f91 <ExecEvalScalarArrayOp+0x201>
         :	                }
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
    0.00 :	  5b0eec:       45 01 ed                add    %r13d,%r13d
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
         :	                {
         :	                        fcinfo->isnull = true;
    0.00 :	  5b0eef:       c6 83 8c 00 00 00 01    movb   $0x1,0x8c(%rbx)
    0.00 :	  5b0ef6:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
         :	                        if (bitmask == 0x100)
    0.00 :	  5b0efa:       41 81 fd 00 01 00 00    cmp    $0x100,%r13d
    0.00 :	  5b0f01:       0f 84 d3 00 00 00       je     5b0fda <ExecEvalScalarArrayOp+0x24a>
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0f07:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5b0f0b:       44 39 75 c0             cmp    %r14d,-0x40(%rbp)
    0.00 :	  5b0f0f:       0f 8e dc 00 00 00       jle    5b0ff1 <ExecEvalScalarArrayOp+0x261>
         :	        {
         :	                Datum           elt;
         :	                Datum           thisresult;
         :
         :	                /* Get array element, checking for NULL */
         :	                if (bitmap && (*bitmap & bitmask) == 0)
    0.00 :	  5b0f15:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b0f18:       74 09                   je     5b0f23 <ExecEvalScalarArrayOp+0x193>
    0.00 :	  5b0f1a:       41 0f b6 07             movzbl (%r15),%eax
    0.00 :	  5b0f1e:       44 85 e8                test   %r13d,%eax
    0.00 :	  5b0f21:       74 ad                   je     5b0ed0 <ExecEvalScalarArrayOp+0x140>
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
    0.00 :	  5b0f23:       80 7d d6 00             cmpb   $0x0,-0x2a(%rbp)
    0.00 :	  5b0f27:       4d 89 e0                mov    %r12,%r8
    0.00 :	  5b0f2a:       74 26                   je     5b0f52 <ExecEvalScalarArrayOp+0x1c2>
    0.00 :	  5b0f2c:       66 83 7d d4 08          cmpw   $0x8,-0x2c(%rbp)
    0.00 :	  5b0f31:       0f 84 89 01 00 00       je     5b10c0 <ExecEvalScalarArrayOp+0x330>
    0.00 :	  5b0f37:       66 83 7d d4 04          cmpw   $0x4,-0x2c(%rbp)
    0.00 :	  5b0f3c:       0f 84 be 01 00 00       je     5b1100 <ExecEvalScalarArrayOp+0x370>
    0.00 :	  5b0f42:       66 83 7d d4 02          cmpw   $0x2,-0x2c(%rbp)
    0.00 :	  5b0f47:       0f 84 c3 01 00 00       je     5b1110 <ExecEvalScalarArrayOp+0x380>
    0.00 :	  5b0f4d:       45 0f b6 04 24          movzbl (%r12),%r8d
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0f52:       66 83 7d d4 00          cmpw   $0x0,-0x2c(%rbp)
    0.00 :	  5b0f57:       0f 8e 23 01 00 00       jle    5b1080 <ExecEvalScalarArrayOp+0x2f0>
    0.00 :	  5b0f5d:       4c 03 65 a8             add    -0x58(%rbp),%r12
         :	                        s = (char *) att_align_nominal(s, typalign);
    0.00 :	  5b0f61:       80 7d d7 69             cmpb   $0x69,-0x29(%rbp)
    0.00 :	  5b0f65:       0f 84 05 01 00 00       je     5b1070 <ExecEvalScalarArrayOp+0x2e0>
    0.00 :	  5b0f6b:       80 7d d7 63             cmpb   $0x63,-0x29(%rbp)
    0.00 :	  5b0f6f:       74 12                   je     5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b0f71:       80 7d d7 64             cmpb   $0x64,-0x29(%rbp)
    0.00 :	  5b0f75:       0f 84 75 01 00 00       je     5b10f0 <ExecEvalScalarArrayOp+0x360>
    0.00 :	  5b0f7b:       49 83 c4 01             add    $0x1,%r12
    0.00 :	  5b0f7f:       49 83 e4 fe             and    $0xfffffffffffffffe,%r12
         :	                        fcinfo->arg[1] = elt;
    0.00 :	  5b0f83:       4c 89 83 98 00 00 00    mov    %r8,0x98(%rbx)
         :	                        fcinfo->argnull[1] = false;
    0.00 :	  5b0f8a:       c6 83 b1 03 00 00 00    movb   $0x0,0x3b1(%rbx)
         :	                        thisresult = (Datum) 0;
         :	                }
         :	                else
         :	                {
         :	                        fcinfo->isnull = false;
         :	                        thisresult = FunctionCallInvoke(fcinfo);
    0.00 :	  5b0f91:       48 8b 43 70             mov    0x70(%rbx),%rax
         :	                        fcinfo->isnull = true;
         :	                        thisresult = (Datum) 0;
         :	                }
         :	                else
         :	                {
         :	                        fcinfo->isnull = false;
    0.00 :	  5b0f95:       c6 83 8c 00 00 00 00    movb   $0x0,0x8c(%rbx)
         :	                        thisresult = FunctionCallInvoke(fcinfo);
    0.00 :	  5b0f9c:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  5b0fa0:       ff 10                   callq  *(%rax)
         :	                }
         :
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
    0.00 :	  5b0fa2:       80 bb 8c 00 00 00 00    cmpb   $0x0,0x8c(%rbx)
    0.00 :	  5b0fa9:       0f 85 01 01 00 00       jne    5b10b0 <ExecEvalScalarArrayOp+0x320>
         :	                        resultnull = true;
         :	                else if (useOr)
    0.00 :	  5b0faf:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  5b0fb3:       0f 84 a7 00 00 00       je     5b1060 <ExecEvalScalarArrayOp+0x2d0>
         :	                {
         :	                        if (DatumGetBool(thisresult))
    0.00 :	  5b0fb9:       84 c0                   test   %al,%al
    0.00 :	  5b0fbb:       0f 85 c5 01 00 00       jne    5b1186 <ExecEvalScalarArrayOp+0x3f6>
         :	                                break;                  /* needn't look at any more elements */
         :	                        }
         :	                }
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
    0.00 :	  5b0fc1:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b0fc4:       0f 84 3d ff ff ff       je     5b0f07 <ExecEvalScalarArrayOp+0x177>
         :	                {
         :	                        bitmask <<= 1;
    0.00 :	  5b0fca:       45 01 ed                add    %r13d,%r13d
         :	                        if (bitmask == 0x100)
    0.00 :	  5b0fcd:       41 81 fd 00 01 00 00    cmp    $0x100,%r13d
    0.00 :	  5b0fd4:       0f 85 2d ff ff ff       jne    5b0f07 <ExecEvalScalarArrayOp+0x177>
         :	                        {
         :	                                bitmap++;
    0.00 :	  5b0fda:       49 83 c7 01             add    $0x1,%r15
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0fde:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5b0fe2:       44 39 75 c0             cmp    %r14d,-0x40(%rbp)
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
         :	                        if (bitmask == 0x100)
         :	                        {
         :	                                bitmap++;
    0.00 :	  5b0fe6:       66 41 bd 01 00          mov    $0x1,%r13w
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0feb:       0f 8f 24 ff ff ff       jg     5b0f15 <ExecEvalScalarArrayOp+0x185>
         :	        }
         :	        typlen = sstate->typlen;
         :	        typbyval = sstate->typbyval;
         :	        typalign = sstate->typalign;
         :
         :	        result = BoolGetDatum(!useOr);
    0.00 :	  5b0ff1:       31 c0                   xor    %eax,%eax
    0.00 :	  5b0ff3:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  5b0ff7:       0f 94 c0                sete   %al
         :	                                bitmask = 1;
         :	                        }
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
    0.00 :	  5b0ffa:       0f b6 4d c7             movzbl -0x39(%rbp),%ecx
    0.00 :	  5b0ffe:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b1002:       88 0a                   mov    %cl,(%rdx)
         :	        return result;
         :	}
    0.00 :	  5b1004:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5b1008:       5b                      pop    %rbx
    0.00 :	  5b1009:       41 5c                   pop    %r12
    0.00 :	  5b100b:       41 5d                   pop    %r13
    0.00 :	  5b100d:       41 5e                   pop    %r14
    0.00 :	  5b100f:       41 5f                   pop    %r15
    0.00 :	  5b1011:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2672
  100.00 :	  5b1012:       c3                      retq   
    0.00 :	  5b1013:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /*
         :	         * Initialize function cache if first time through
         :	         */
         :	        if (sstate->fxprstate.func.fn_oid == InvalidOid)
         :	        {
         :	                init_fcache(opexpr->opfuncid, opexpr->inputcollid, &sstate->fxprstate,
    0.00 :	  5b1018:       49 8b 4c 24 20          mov    0x20(%r12),%rcx
    0.00 :	  5b101d:       8b 70 10                mov    0x10(%rax),%esi
    0.00 :	  5b1020:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  5b1026:       8b 78 08                mov    0x8(%rax),%edi
    0.00 :	  5b1029:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5b102c:       e8 ff fa ff ff          callq  5b0b30 <init_fcache>
    0.00 :	  5b1031:       e9 9f fd ff ff          jmpq   5b0dd5 <ExecEvalScalarArrayOp+0x45>
    0.00 :	  5b1036:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b103d:       00 00 00 
         :
         :	        /*
         :	         * If the scalar is NULL, and the function is strict, return NULL; no
         :	         * point in iterating the loop.
         :	         */
         :	        if (fcinfo->argnull[0] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b1040:       80 7b 2e 00             cmpb   $0x0,0x2e(%rbx)
    0.00 :	  5b1044:       0f 84 01 fe ff ff       je     5b0e4b <ExecEvalScalarArrayOp+0xbb>
         :	        {
         :	                *isNull = true;
    0.00 :	  5b104a:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b104e:       31 c0                   xor    %eax,%eax
    0.00 :	  5b1050:       c6 02 01                movb   $0x1,(%rdx)
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b1053:       e9 ae fd ff ff          jmpq   5b0e06 <ExecEvalScalarArrayOp+0x76>
    0.00 :	  5b1058:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b105f:       00 
         :	                                break;                  /* needn't look at any more elements */
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        if (!DatumGetBool(thisresult))
    0.00 :	  5b1060:       84 c0                   test   %al,%al
    0.00 :	  5b1062:       0f 85 59 ff ff ff       jne    5b0fc1 <ExecEvalScalarArrayOp+0x231>
    0.00 :	  5b1068:       31 c0                   xor    %eax,%eax
    0.00 :	  5b106a:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b106e:       eb 8a                   jmp    5b0ffa <ExecEvalScalarArrayOp+0x26a>
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
         :	                        s = (char *) att_align_nominal(s, typalign);
    0.00 :	  5b1070:       49 83 c4 03             add    $0x3,%r12
    0.00 :	  5b1074:       49 83 e4 fc             and    $0xfffffffffffffffc,%r12
    0.00 :	  5b1078:       e9 06 ff ff ff          jmpq   5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b107d:       0f 1f 00                nopl   (%rax)
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b1080:       66 83 7d d4 ff          cmpw   $0xffff,-0x2c(%rbp)
    0.00 :	  5b1085:       75 49                   jne    5b10d0 <ExecEvalScalarArrayOp+0x340>
    0.00 :	  5b1087:       41 0f b6 04 24          movzbl (%r12),%eax
    0.00 :	  5b108c:       3c 01                   cmp    $0x1,%al
    0.00 :	  5b108e:       0f 84 9c 00 00 00       je     5b1130 <ExecEvalScalarArrayOp+0x3a0>
    0.00 :	  5b1094:       a8 01                   test   $0x1,%al
    0.00 :	  5b1096:       0f 84 84 00 00 00       je     5b1120 <ExecEvalScalarArrayOp+0x390>
    0.00 :	  5b109c:       d0 e8                   shr    %al
    0.00 :	  5b109e:       0f b6 c0                movzbl %al,%eax
    0.00 :	  5b10a1:       49 01 c4                add    %rax,%r12
    0.00 :	  5b10a4:       e9 b8 fe ff ff          jmpq   5b0f61 <ExecEvalScalarArrayOp+0x1d1>
    0.00 :	  5b10a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        fcinfo->isnull = false;
         :	                        thisresult = FunctionCallInvoke(fcinfo);
         :	                }
         :
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
    0.00 :	  5b10b0:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
    0.00 :	  5b10b4:       e9 08 ff ff ff          jmpq   5b0fc1 <ExecEvalScalarArrayOp+0x231>
    0.00 :	  5b10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
    0.00 :	  5b10c0:       4d 8b 04 24             mov    (%r12),%r8
    0.00 :	  5b10c4:       e9 94 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b10c9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b10d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b10d3:       4c 89 45 a0             mov    %r8,-0x60(%rbp)
    0.00 :	  5b10d7:       e8 74 87 eb ff          callq  469850 <strlen@plt>
    0.00 :	  5b10dc:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  5b10e0:       4d 8d 64 04 01          lea    0x1(%r12,%rax,1),%r12
    0.00 :	  5b10e5:       e9 77 fe ff ff          jmpq   5b0f61 <ExecEvalScalarArrayOp+0x1d1>
    0.00 :	  5b10ea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        s = (char *) att_align_nominal(s, typalign);
    0.00 :	  5b10f0:       49 83 c4 07             add    $0x7,%r12
    0.00 :	  5b10f4:       49 83 e4 f8             and    $0xfffffffffffffff8,%r12
    0.00 :	  5b10f8:       e9 86 fe ff ff          jmpq   5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b10fd:       0f 1f 00                nopl   (%rax)
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
    0.00 :	  5b1100:       45 8b 04 24             mov    (%r12),%r8d
    0.00 :	  5b1104:       e9 54 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b1109:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5b1110:       45 0f b7 04 24          movzwl (%r12),%r8d
    0.00 :	  5b1115:       e9 43 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b111a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b1120:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  5b1124:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  5b1127:       89 c0                   mov    %eax,%eax
    0.00 :	  5b1129:       e9 73 ff ff ff          jmpq   5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b112e:       66 90                   xchg   %ax,%ax
    0.00 :	  5b1130:       41 0f b6 54 24 01       movzbl 0x1(%r12),%edx
    0.00 :	  5b1136:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  5b113b:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  5b113e:       0f 84 5d ff ff ff       je     5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b1144:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  5b1147:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  5b114c:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  5b1151:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  5b1155:       e9 47 ff ff ff          jmpq   5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b115a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b1160:       49 63 45 04             movslq 0x4(%r13),%rax
    0.00 :	  5b1164:       45 31 ff                xor    %r15d,%r15d
    0.00 :	  5b1167:       4d 8d 64 c5 10          lea    0x10(%r13,%rax,8),%r12
    0.00 :	  5b116c:       e9 45 fd ff ff          jmpq   5b0eb6 <ExecEvalScalarArrayOp+0x126>
    0.00 :	  5b1171:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
         :	        if (nitems <= 0)
         :	                return BoolGetDatum(!useOr);
    0.00 :	  5b1178:       31 c0                   xor    %eax,%eax
    0.00 :	  5b117a:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  5b117e:       0f 94 c0                sete   %al
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b1181:       e9 80 fc ff ff          jmpq   5b0e06 <ExecEvalScalarArrayOp+0x76>
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
         :	                        resultnull = true;
         :	                else if (useOr)
         :	                {
         :	                        if (DatumGetBool(thisresult))
    0.00 :	  5b1186:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5b118b:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b118f:       e9 66 fe ff ff          jmpq   5b0ffa <ExecEvalScalarArrayOp+0x26a>
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
         :	        if (argDone != ExprSingleResult)
         :	                ereport(ERROR,
    0.00 :	  5b1194:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5b1197:       b9 e0 ae 88 00          mov    $0x88aee0,%ecx
    0.00 :	  5b119c:       ba f1 09 00 00          mov    $0x9f1,%edx
    0.00 :	  5b11a1:       be fc a3 88 00          mov    $0x88a3fc,%esi
    0.00 :	  5b11a6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b11ab:       e8 10 99 1c 00          callq  77aac0 <errstart>
    0.00 :	  5b11b0:       84 c0                   test   %al,%al
    0.00 :	  5b11b2:       75 05                   jne    5b11b9 <ExecEvalScalarArrayOp+0x429>
    0.00 :	  5b11b4:       e8 17 83 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5b11b9:       bf 10 a9 88 00          mov    $0x88a910,%edi
    0.00 :	  5b11be:       31 c0                   xor    %eax,%eax
    0.00 :	  5b11c0:       e8 db b6 1c 00          callq  77c8a0 <errmsg>
    0.00 :	  5b11c5:       bf 84 80 00 04          mov    $0x4008084,%edi
    0.00 :	  5b11ca:       89 c3                   mov    %eax,%ebx
    0.00 :	  5b11cc:       e8 7f bb 1c 00          callq  77cd50 <errcode>
    0.00 :	  5b11d1:       89 de                   mov    %ebx,%esi
    0.00 :	  5b11d3:       89 c7                   mov    %eax,%edi
    0.00 :	  5b11d5:       31 c0                   xor    %eax,%eax
    0.00 :	  5b11d7:       e8 04 94 1c 00          callq  77a5e0 <errfinish>
    0.00 :	  5b11dc:       eb d6                   jmp    5b11b4 <ExecEvalScalarArrayOp+0x424>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:406
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005baf80 <BitmapHeapNext>:
         :	 *              Retrieve next tuple from the BitmapHeapScan node's currentRelation
         :	 * ----------------------------------------------------------------
         :	 */
         :	static TupleTableSlot *
         :	BitmapHeapNext(BitmapHeapScanState *node)
         :	{
    0.00 :	  5baf80:       55                      push   %rbp
    0.00 :	  5baf81:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5baf84:       41 57                   push   %r15
    0.00 :	  5baf86:       41 56                   push   %r14
    0.00 :	  5baf88:       41 55                   push   %r13
    0.00 :	  5baf8a:       41 54                   push   %r12
    0.00 :	  5baf8c:       53                      push   %rbx
    0.00 :	  5baf8d:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5baf90:       48 81 ec d8 00 00 00    sub    $0xd8,%rsp
         :	        TupleTableSlot *slot;
         :
         :	        /*
         :	         * extract necessary information from index scan node
         :	         */
         :	        econtext = node->ss.ps.ps_ExprContext;
    0.00 :	  5baf97:       48 8b 47 60             mov    0x60(%rdi),%rax
    0.00 :	  5baf9b:       48 89 85 28 ff ff ff    mov    %rax,-0xd8(%rbp)
         :	        slot = node->ss.ss_ScanTupleSlot;
    0.00 :	  5bafa2:       48 8b 97 88 00 00 00    mov    0x88(%rdi),%rdx
    0.00 :	  5bafa9:       48 89 95 38 ff ff ff    mov    %rdx,-0xc8(%rbp)
         :	        scan = node->ss.ss_currentScanDesc;
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
    0.00 :	  5bafb0:       48 8b 8f a0 00 00 00    mov    0xa0(%rdi),%rcx
         :	        /*
         :	         * extract necessary information from index scan node
         :	         */
         :	        econtext = node->ss.ps.ps_ExprContext;
         :	        slot = node->ss.ss_ScanTupleSlot;
         :	        scan = node->ss.ss_currentScanDesc;
    0.00 :	  5bafb7:       4c 8b a7 80 00 00 00    mov    0x80(%rdi),%r12
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
    0.00 :	  5bafbe:       48 89 8d 30 ff ff ff    mov    %rcx,-0xd0(%rbp)
         :	         * desired prefetch distance, which starts small and increases up to the
         :	         * GUC-controlled maximum, target_prefetch_pages.  This is to avoid doing
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
    0.00 :	  5bafc5:       48 83 bf 98 00 00 00    cmpq   $0x0,0x98(%rdi)
    0.00 :	  5bafcc:       00 
         :	        econtext = node->ss.ps.ps_ExprContext;
         :	        slot = node->ss.ss_ScanTupleSlot;
         :	        scan = node->ss.ss_currentScanDesc;
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
         :	        tbmres = node->tbmres;
    0.00 :	  5bafcd:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
         :	#ifdef USE_PREFETCH
         :	        prefetch_iterator = node->prefetch_iterator;
    0.00 :	  5bafd4:       4c 8b bf c0 00 00 00    mov    0xc0(%rdi),%r15
         :	         * desired prefetch distance, which starts small and increases up to the
         :	         * GUC-controlled maximum, target_prefetch_pages.  This is to avoid doing
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
    0.00 :	  5bafdb:       0f 84 11 06 00 00       je     5bb5f2 <BitmapHeapNext+0x672>
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bafe1:       49 8d 44 24 48          lea    0x48(%r12),%rax
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5bafe6:       48 85 d2                test   %rdx,%rdx
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bafe9:       48 89 85 20 ff ff ff    mov    %rax,-0xe0(%rbp)
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5baff0:       0f 84 c4 01 00 00       je     5bb1ba <BitmapHeapNext+0x23a>
    0.00 :	  5baff6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5baffd:       00 00 00 
         :	                else
         :	                {
         :	                        /*
         :	                         * Continuing in previously obtained page; advance rs_cindex
         :	                         */
         :	                        scan->rs_cindex++;
    0.00 :	  5bb000:       41 83 44 24 70 01       addl   $0x1,0x70(%r12)
         :
         :	                        /*
         :	                         * Try to prefetch at least a few pages even before we get to the
         :	                         * second page if we don't stop reading after the first tuple.
         :	                         */
         :	                        if (node->prefetch_target < target_prefetch_pages)
    0.00 :	  5bb006:       49 89 d5                mov    %rdx,%r13
    0.00 :	  5bb009:       8b 83 cc 00 00 00       mov    0xcc(%rbx),%eax
    0.00 :	  5bb00f:       3b 05 4f 20 5c 00       cmp    0x5c204f(%rip),%eax        # b7d064 <target_prefetch_pages>
    0.00 :	  5bb015:       7d 0c                   jge    5bb023 <BitmapHeapNext+0xa3>
         :	                                node->prefetch_target++;
    0.00 :	  5bb017:       83 c0 01                add    $0x1,%eax
    0.00 :	  5bb01a:       49 89 d5                mov    %rdx,%r13
    0.00 :	  5bb01d:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
         :	                }
         :
         :	                /*
         :	                 * Out of range?  If so, nothing more to look at on this page
         :	                 */
         :	                if (scan->rs_cindex < 0 || scan->rs_cindex >= scan->rs_ntuples)
    0.00 :	  5bb023:       41 8b 44 24 70          mov    0x70(%r12),%eax
    0.00 :	  5bb028:       85 c0                   test   %eax,%eax
    0.00 :	  5bb02a:       0f 88 e0 01 00 00       js     5bb210 <BitmapHeapNext+0x290>
    0.00 :	  5bb030:       41 3b 44 24 78          cmp    0x78(%r12),%eax
    0.00 :	  5bb035:       0f 8d d5 01 00 00       jge    5bb210 <BitmapHeapNext+0x290>
         :	                 * to avoid having prefetching interfere with the main I/O. Also, this
         :	                 * should happen only when we have determined there is still something
         :	                 * to do on the current page, else we may uselessly prefetch the same
         :	                 * page we are just about to request for real.
         :	                 */
         :	                if (prefetch_iterator)
    0.00 :	  5bb03b:       4d 85 ff                test   %r15,%r15
    0.00 :	  5bb03e:       74 55                   je     5bb095 <BitmapHeapNext+0x115>
         :	                {
         :	                        while (node->prefetch_pages < node->prefetch_target)
    0.00 :	  5bb040:       8b 83 cc 00 00 00       mov    0xcc(%rbx),%eax
    0.00 :	  5bb046:       3b 83 c8 00 00 00       cmp    0xc8(%rbx),%eax
    0.00 :	  5bb04c:       7f 24                   jg     5bb072 <BitmapHeapNext+0xf2>
    0.00 :	  5bb04e:       eb 45                   jmp    5bb095 <BitmapHeapNext+0x115>
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
         :	                                        break;
         :	                                }
         :	                                node->prefetch_pages++;
    0.00 :	  5bb050:       83 83 c8 00 00 00 01    addl   $0x1,0xc8(%rbx)
         :	                                PrefetchBuffer(scan->rs_rd, MAIN_FORKNUM, tbmpre->blockno);
    0.00 :	  5bb057:       31 f6                   xor    %esi,%esi
    0.00 :	  5bb059:       8b 10                   mov    (%rax),%edx
    0.00 :	  5bb05b:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb05f:       e8 6c b7 0b 00          callq  6767d0 <PrefetchBuffer>
         :	                 * to do on the current page, else we may uselessly prefetch the same
         :	                 * page we are just about to request for real.
         :	                 */
         :	                if (prefetch_iterator)
         :	                {
         :	                        while (node->prefetch_pages < node->prefetch_target)
    0.00 :	  5bb064:       8b 83 c8 00 00 00       mov    0xc8(%rbx),%eax
    0.00 :	  5bb06a:       3b 83 cc 00 00 00       cmp    0xcc(%rbx),%eax
    0.00 :	  5bb070:       7d 23                   jge    5bb095 <BitmapHeapNext+0x115>
         :	                        {
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
    0.00 :	  5bb072:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bb075:       e8 d6 82 02 00          callq  5e3350 <tbm_iterate>
         :
         :	                                if (tbmpre == NULL)
    0.00 :	  5bb07a:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb07d:       75 d1                   jne    5bb050 <BitmapHeapNext+0xd0>
         :	                                {
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
    0.00 :	  5bb07f:       4c 89 ff                mov    %r15,%rdi
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
    0.00 :	  5bb082:       45 31 ff                xor    %r15d,%r15d
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
         :
         :	                                if (tbmpre == NULL)
         :	                                {
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
    0.00 :	  5bb085:       e8 86 84 02 00          callq  5e3510 <tbm_end_iterate>
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
    0.00 :	  5bb08a:       48 c7 83 c0 00 00 00    movq   $0x0,0xc0(%rbx)
    0.00 :	  5bb091:       00 00 00 00 
         :	#endif   /* USE_PREFETCH */
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
    0.00 :	  5bb095:       49 63 44 24 70          movslq 0x70(%r12),%rax
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb09a:       41 8b 74 24 64          mov    0x64(%r12),%esi
    0.00 :	  5bb09f:       85 f6                   test   %esi,%esi
         :	#endif   /* USE_PREFETCH */
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
    0.00 :	  5bb0a1:       41 0f b7 7c 44 7c       movzwl 0x7c(%r12,%rax,2),%edi
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb0a7:       0f 88 73 01 00 00       js     5bb220 <BitmapHeapNext+0x2a0>
    0.00 :	  5bb0ad:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  5bb0b0:       48 63 c8                movslq %eax,%rcx
    0.00 :	  5bb0b3:       48 c1 e1 0d             shl    $0xd,%rcx
    0.00 :	  5bb0b7:       48 03 0d 3a 4a 60 00    add    0x604a3a(%rip),%rcx        # bbfaf8 <BufferBlocks>
         :	                lp = PageGetItemId(dp, targoffset);
    0.00 :	  5bb0be:       0f b7 d7                movzwl %di,%edx
         :	                Assert(ItemIdIsNormal(lp));
         :
         :	                scan->rs_ctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb0c1:       48 83 c2 03             add    $0x3,%rdx
    0.00 :	  5bb0c5:       0f b7 44 91 08          movzwl 0x8(%rcx,%rdx,4),%eax
    0.00 :	  5bb0ca:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  5bb0cf:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5bb0d3:       49 89 44 24 58          mov    %rax,0x58(%r12)
         :	                scan->rs_ctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb0d8:       0f b7 44 91 0a          movzwl 0xa(%rcx,%rdx,4),%eax
         :	                scan->rs_ctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb0dd:       49 8b 14 24             mov    (%r12),%rdx
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lp = PageGetItemId(dp, targoffset);
         :	                Assert(ItemIdIsNormal(lp));
         :
         :	                scan->rs_ctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                scan->rs_ctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb0e1:       66 d1 e8                shr    %ax
    0.00 :	  5bb0e4:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb0e7:       41 89 44 24 48          mov    %eax,0x48(%r12)
         :	                scan->rs_ctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb0ec:       8b 42 40                mov    0x40(%rdx),%eax
    0.00 :	  5bb0ef:       41 89 44 24 54          mov    %eax,0x54(%r12)
         :	                ItemPointerSet(&scan->rs_ctup.t_self, tbmres->blockno, targoffset);
    0.00 :	  5bb0f4:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  5bb0f8:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  5bb0fb:       66 41 89 44 24 4c       mov    %ax,0x4c(%r12)
    0.00 :	  5bb101:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  5bb105:       66 41 89 7c 24 50       mov    %di,0x50(%r12)
    0.00 :	  5bb10b:       66 41 89 44 24 4e       mov    %ax,0x4e(%r12)
         :
         :	                pgstat_count_heap_fetch(scan->rs_rd);
    0.00 :	  5bb111:       48 8b 82 38 01 00 00    mov    0x138(%rdx),%rax
    0.00 :	  5bb118:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb11b:       74 0a                   je     5bb127 <BitmapHeapNext+0x1a7>
    0.00 :	  5bb11d:       48 83 40 20 01          addq   $0x1,0x20(%rax)
    0.00 :	  5bb122:       41 8b 74 24 64          mov    0x64(%r12),%esi
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bb127:       89 f2                   mov    %esi,%edx
    0.00 :	  5bb129:       48 8b bd 20 ff ff ff    mov    -0xe0(%rbp),%rdi
    0.00 :	  5bb130:       48 8b b5 38 ff ff ff    mov    -0xc8(%rbp),%rsi
    0.00 :	  5bb137:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5bb139:       e8 42 93 ff ff          callq  5b4480 <ExecStoreTuple>
         :
         :	                /*
         :	                 * If we are using lossy info, we have to recheck the qual conditions
         :	                 * at every tuple.
         :	                 */
         :	                if (tbmres->recheck)
    0.00 :	  5bb13e:       41 80 7d 08 00          cmpb   $0x0,0x8(%r13)
    0.00 :	  5bb143:       0f 84 b1 02 00 00       je     5bb3fa <BitmapHeapNext+0x47a>
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
    0.00 :	  5bb149:       48 8b 95 28 ff ff ff    mov    -0xd8(%rbp),%rdx
    0.00 :	  5bb150:       48 8b 8d 38 ff ff ff    mov    -0xc8(%rbp),%rcx
         :	                        ResetExprContext(econtext);
    0.00 :	  5bb157:       48 8b 7a 28             mov    0x28(%rdx),%rdi
         :	                 * If we are using lossy info, we have to recheck the qual conditions
         :	                 * at every tuple.
         :	                 */
         :	                if (tbmres->recheck)
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
    0.00 :	  5bb15b:       48 89 4a 08             mov    %rcx,0x8(%rdx)
         :	                        ResetExprContext(econtext);
    0.00 :	  5bb15f:       e8 4c d8 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                        if (!ExecQual(node->bitmapqualorig, econtext, false))
    0.00 :	  5bb164:       48 8b bb 90 00 00 00    mov    0x90(%rbx),%rdi
    0.00 :	  5bb16b:       48 8b b5 28 ff ff ff    mov    -0xd8(%rbp),%rsi
    0.00 :	  5bb172:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb174:       e8 97 1d ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5bb179:       84 c0                   test   %al,%al
    0.00 :	  5bb17b:       0f 85 79 02 00 00       jne    5bb3fa <BitmapHeapNext+0x47a>
         :	                        {
         :	                                /* Fails recheck, so drop it and loop back for another */
         :	                                InstrCountFiltered2(node, 1);
    0.00 :	  5bb181:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  5bb185:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb188:       74 18                   je     5bb1a2 <BitmapHeapNext+0x222>
    0.00 :	  5bb18a:       f2 0f 10 05 c6 3f 1f    movsd  0x1f3fc6(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bb191:       00 
    0.00 :	  5bb192:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5bb199:       00 
    0.00 :	  5bb19a:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5bb1a1:       00 
         :	                                ExecClearTuple(slot);
    0.00 :	  5bb1a2:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  5bb1a9:       e8 62 8f ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bb1ae:       4c 89 ea                mov    %r13,%rdx
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5bb1b1:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5bb1b4:       0f 85 46 fe ff ff       jne    5bb000 <BitmapHeapNext+0x80>
         :	                {
         :	                        node->tbmres = tbmres = tbm_iterate(tbmiterator);
    0.00 :	  5bb1ba:       48 8b bd 30 ff ff ff    mov    -0xd0(%rbp),%rdi
    0.00 :	  5bb1c1:       e8 8a 81 02 00          callq  5e3350 <tbm_iterate>
         :	                        if (tbmres == NULL)
    0.00 :	  5bb1c6:       48 85 c0                test   %rax,%rax
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
         :	                {
         :	                        node->tbmres = tbmres = tbm_iterate(tbmiterator);
    0.00 :	  5bb1c9:       49 89 c5                mov    %rax,%r13
    0.00 :	  5bb1cc:       48 89 83 a8 00 00 00    mov    %rax,0xa8(%rbx)
         :	                        if (tbmres == NULL)
    0.00 :	  5bb1d3:       0f 84 0e 02 00 00       je     5bb3e7 <BitmapHeapNext+0x467>
         :	                                /* no more entries in the bitmap */
         :	                                break;
         :	                        }
         :
         :	#ifdef USE_PREFETCH
         :	                        if (node->prefetch_pages > 0)
    0.00 :	  5bb1d9:       8b 83 c8 00 00 00       mov    0xc8(%rbx),%eax
    0.00 :	  5bb1df:       85 c0                   test   %eax,%eax
    0.00 :	  5bb1e1:       0f 8e ae 01 00 00       jle    5bb395 <BitmapHeapNext+0x415>
         :	                        {
         :	                                /* The main iterator has closed the distance by one page */
         :	                                node->prefetch_pages--;
    0.00 :	  5bb1e7:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bb1ea:       89 83 c8 00 00 00       mov    %eax,0xc8(%rbx)
    0.00 :	  5bb1f0:       41 8b 55 00             mov    0x0(%r13),%edx
    0.00 :	  5bb1f4:       89 95 7c ff ff ff       mov    %edx,-0x84(%rbp)
         :	                         * Ignore any claimed entries past what we think is the end of the
         :	                         * relation.  (This is probably not necessary given that we got at
         :	                         * least AccessShareLock on the table before performing any of the
         :	                         * indexscans, but let's be safe.)
         :	                         */
         :	                        if (tbmres->blockno >= scan->rs_nblocks)
    0.00 :	  5bb1fa:       8b 85 7c ff ff ff       mov    -0x84(%rbp),%eax
    0.00 :	  5bb200:       41 39 44 24 28          cmp    %eax,0x28(%r12)
    0.00 :	  5bb205:       77 2f                   ja     5bb236 <BitmapHeapNext+0x2b6>
    0.00 :	  5bb207:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bb20e:       00 00 
         :	                /*
         :	                 * Out of range?  If so, nothing more to look at on this page
         :	                 */
         :	                if (scan->rs_cindex < 0 || scan->rs_cindex >= scan->rs_ntuples)
         :	                {
         :	                        node->tbmres = tbmres = NULL;
    0.00 :	  5bb210:       48 c7 83 a8 00 00 00    movq   $0x0,0xa8(%rbx)
    0.00 :	  5bb217:       00 00 00 00 
    0.00 :	  5bb21b:       45 31 ed                xor    %r13d,%r13d
         :	                        continue;
    0.00 :	  5bb21e:       eb 8e                   jmp    5bb1ae <BitmapHeapNext+0x22e>
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb220:       89 f0                   mov    %esi,%eax
    0.00 :	  5bb222:       48 8b 15 ef 1e 5c 00    mov    0x5c1eef(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  5bb229:       f7 d0                   not    %eax
    0.00 :	  5bb22b:       48 98                   cltq   
    0.00 :	  5bb22d:       48 8b 0c c2             mov    (%rdx,%rax,8),%rcx
    0.00 :	  5bb231:       e9 88 fe ff ff          jmpq   5bb0be <BitmapHeapNext+0x13e>
         :	        /*
         :	         * Acquire pin on the target heap page, trading in any pin we held before.
         :	         */
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        scan->rs_cbuf = ReleaseAndReadBuffer(scan->rs_cbuf,
    0.00 :	  5bb236:       41 8b 7c 24 64          mov    0x64(%r12),%edi
    0.00 :	  5bb23b:       8b 95 7c ff ff ff       mov    -0x84(%rbp),%edx
    0.00 :	  5bb241:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb245:       e8 76 b4 0b 00          callq  6766c0 <ReleaseAndReadBuffer>
    0.00 :	  5bb24a:       89 85 78 ff ff ff       mov    %eax,-0x88(%rbp)
         :	                                                                                 scan->rs_rd,
         :	                                                                                 page);
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  5bb250:       49 8b 54 24 08          mov    0x8(%r12),%rdx
         :	        ntup = 0;
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  5bb255:       89 c6                   mov    %eax,%esi
         :	        /*
         :	         * Acquire pin on the target heap page, trading in any pin we held before.
         :	         */
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        scan->rs_cbuf = ReleaseAndReadBuffer(scan->rs_cbuf,
    0.00 :	  5bb257:       41 89 44 24 64          mov    %eax,0x64(%r12)
         :	                                                                                 scan->rs_rd,
         :	                                                                                 page);
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  5bb25c:       48 89 95 58 ff ff ff    mov    %rdx,-0xa8(%rbp)
         :	        ntup = 0;
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  5bb263:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb267:       e8 e4 43 ee ff          callq  49f650 <heap_page_prune_opt>
         :	        /*
         :	         * We must hold share lock on the buffer content while examining tuple
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
    0.00 :	  5bb26c:       8b bd 78 ff ff ff       mov    -0x88(%rbp),%edi
    0.00 :	  5bb272:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5bb277:       e8 94 94 0b 00          callq  674710 <LockBuffer>
         :
         :	        /*
         :	         * We need two separate strategies for lossy and non-lossy cases.
         :	         */
         :	        if (tbmres->ntuples >= 0)
    0.00 :	  5bb27c:       41 83 7d 04 00          cmpl   $0x0,0x4(%r13)
    0.00 :	  5bb281:       0f 8c 97 01 00 00       jl     5bb41e <BitmapHeapNext+0x49e>
         :	                 * tbmres; but we have to follow any HOT chain starting at each such
         :	                 * offset.
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
    0.00 :	  5bb287:       0f 84 c1 01 00 00       je     5bb44e <BitmapHeapNext+0x4ce>
    0.00 :	  5bb28d:       8b 8d 7c ff ff ff       mov    -0x84(%rbp),%ecx
    0.00 :	  5bb293:       0f b7 85 7c ff ff ff    movzwl -0x84(%rbp),%eax
    0.00 :	  5bb29a:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5bb29d:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb2a4:       00 00 00 
    0.00 :	  5bb2a7:       c1 e9 10                shr    $0x10,%ecx
    0.00 :	  5bb2aa:       66 89 4d 80             mov    %cx,-0x80(%rbp)
    0.00 :	  5bb2ae:       66 89 45 9e             mov    %ax,-0x62(%rbp)
    0.00 :	  5bb2b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
    0.00 :	  5bb2b8:       49 63 c6                movslq %r14d,%rax
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
    0.00 :	  5bb2bb:       0f b7 55 80             movzwl -0x80(%rbp),%edx
    0.00 :	  5bb2bf:       0f b7 4d 9e             movzwl -0x62(%rbp),%ecx
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
    0.00 :	  5bb2c3:       41 0f b7 44 45 0a       movzwl 0xa(%r13,%rax,2),%eax
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
         :	                        if (heap_hot_search_buffer(&tid, scan->rs_rd, buffer, snapshot,
    0.00 :	  5bb2c9:       c7 04 24 01 00 00 00    movl   $0x1,(%rsp)
    0.00 :	  5bb2d0:       4c 8d 45 a0             lea    -0x60(%rbp),%r8
    0.00 :	  5bb2d4:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
    0.00 :	  5bb2d8:       45 31 c9                xor    %r9d,%r9d
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
    0.00 :	  5bb2db:       66 89 55 c0             mov    %dx,-0x40(%rbp)
    0.00 :	  5bb2df:       66 89 4d c2             mov    %cx,-0x3e(%rbp)
    0.00 :	  5bb2e3:       66 89 45 c4             mov    %ax,-0x3c(%rbp)
         :	                        if (heap_hot_search_buffer(&tid, scan->rs_rd, buffer, snapshot,
    0.00 :	  5bb2e7:       48 8b 8d 58 ff ff ff    mov    -0xa8(%rbp),%rcx
    0.00 :	  5bb2ee:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
    0.00 :	  5bb2f4:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb2f8:       e8 23 1f ee ff          callq  49d220 <heap_hot_search_buffer>
    0.00 :	  5bb2fd:       84 c0                   test   %al,%al
    0.00 :	  5bb2ff:       74 18                   je     5bb319 <BitmapHeapNext+0x399>
         :	                                                                           &heapTuple, NULL, true))
         :	                                scan->rs_vistuples[ntup++] = ItemPointerGetOffsetNumber(&tid);
    0.00 :	  5bb301:       48 63 95 54 ff ff ff    movslq -0xac(%rbp),%rdx
    0.00 :	  5bb308:       0f b7 45 c4             movzwl -0x3c(%rbp),%eax
    0.00 :	  5bb30c:       66 41 89 44 54 7c       mov    %ax,0x7c(%r12,%rdx,2)
    0.00 :	  5bb312:       83 85 54 ff ff ff 01    addl   $0x1,-0xac(%rbp)
         :	                 * tbmres; but we have to follow any HOT chain starting at each such
         :	                 * offset.
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
    0.00 :	  5bb319:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5bb31d:       45 3b 75 04             cmp    0x4(%r13),%r14d
    0.00 :	  5bb321:       7c 95                   jl     5bb2b8 <BitmapHeapNext+0x338>
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
         :	                                                                                        buffer, snapshot);
         :	                }
         :	        }
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  5bb323:       8b bd 78 ff ff ff       mov    -0x88(%rbp),%edi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:406
  100.00 :	  5bb329:       31 f6                   xor    %esi,%esi
    0.00 :	  5bb32b:       e8 e0 93 0b 00          callq  674710 <LockBuffer>
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
    0.00 :	  5bb330:       8b 85 54 ff ff ff       mov    -0xac(%rbp),%eax
    0.00 :	  5bb336:       41 89 44 24 78          mov    %eax,0x78(%r12)
         :	                        /*
         :	                         * Fetch the current heap page and identify candidate tuples.
         :	                         */
         :	                        bitgetpage(scan, tbmres);
         :
         :	                        if (tbmres->ntuples >= 0)
    0.00 :	  5bb33b:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  5bb33f:       85 c0                   test   %eax,%eax
    0.00 :	  5bb341:       0f 88 16 01 00 00       js     5bb45d <BitmapHeapNext+0x4dd>
         :	                                node->exact_pages++;
    0.00 :	  5bb347:       48 83 83 b0 00 00 00    addq   $0x1,0xb0(%rbx)
    0.00 :	  5bb34e:       01 
         :	                                node->lossy_pages++;
         :
         :	                        /*
         :	                         * Set rs_cindex to first slot to examine
         :	                         */
         :	                        scan->rs_cindex = 0;
    0.00 :	  5bb34f:       41 c7 44 24 70 00 00    movl   $0x0,0x70(%r12)
    0.00 :	  5bb356:       00 00 
         :	                         * Increase prefetch target if it's not yet at the max.  Note that
         :	                         * we will increase it to zero after fetching the very first
         :	                         * page/tuple, then to one after the second tuple is fetched, then
         :	                         * it doubles as later pages are fetched.
         :	                         */
         :	                        if (node->prefetch_target >= target_prefetch_pages)
    0.00 :	  5bb358:       8b 8b cc 00 00 00       mov    0xcc(%rbx),%ecx
    0.00 :	  5bb35e:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb360:       8b 15 fe 1c 5c 00       mov    0x5c1cfe(%rip),%edx        # b7d064 <target_prefetch_pages>
    0.00 :	  5bb366:       39 d1                   cmp    %edx,%ecx
    0.00 :	  5bb368:       0f 8d c2 fc ff ff       jge    5bb030 <BitmapHeapNext+0xb0>
         :	                                 /* don't increase any further */ ;
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
    0.00 :	  5bb36e:       89 d0                   mov    %edx,%eax
    0.00 :	  5bb370:       c1 e8 1f                shr    $0x1f,%eax
    0.00 :	  5bb373:       01 d0                   add    %edx,%eax
    0.00 :	  5bb375:       d1 f8                   sar    %eax
    0.00 :	  5bb377:       39 c1                   cmp    %eax,%ecx
    0.00 :	  5bb379:       0f 8d 94 00 00 00       jge    5bb413 <BitmapHeapNext+0x493>
         :	                                node->prefetch_target = target_prefetch_pages;
         :	                        else if (node->prefetch_target > 0)
    0.00 :	  5bb37f:       85 c9                   test   %ecx,%ecx
    0.00 :	  5bb381:       0f 8e 5d 02 00 00       jle    5bb5e4 <BitmapHeapNext+0x664>
         :	                                node->prefetch_target *= 2;
    0.00 :	  5bb387:       8d 04 09                lea    (%rcx,%rcx,1),%eax
    0.00 :	  5bb38a:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
    0.00 :	  5bb390:       e9 8e fc ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	                        if (node->prefetch_pages > 0)
         :	                        {
         :	                                /* The main iterator has closed the distance by one page */
         :	                                node->prefetch_pages--;
         :	                        }
         :	                        else if (prefetch_iterator)
    0.00 :	  5bb395:       4d 85 ff                test   %r15,%r15
    0.00 :	  5bb398:       0f 84 cc 00 00 00       je     5bb46a <BitmapHeapNext+0x4ea>
         :	                        {
         :	                                /* Do not let the prefetch iterator get behind the main one */
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
    0.00 :	  5bb39e:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bb3a1:       e8 aa 7f 02 00          callq  5e3350 <tbm_iterate>
         :
         :	                                if (tbmpre == NULL || tbmpre->blockno != tbmres->blockno)
    0.00 :	  5bb3a6:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb3a9:       74 12                   je     5bb3bd <BitmapHeapNext+0x43d>
    0.00 :	  5bb3ab:       8b 00                   mov    (%rax),%eax
    0.00 :	  5bb3ad:       89 85 7c ff ff ff       mov    %eax,-0x84(%rbp)
    0.00 :	  5bb3b3:       41 3b 45 00             cmp    0x0(%r13),%eax
    0.00 :	  5bb3b7:       0f 84 3d fe ff ff       je     5bb1fa <BitmapHeapNext+0x27a>
         :	                                        elog(ERROR, "prefetch and main iterators are out of sync");
    0.00 :	  5bb3bd:       ba b4 b8 88 00          mov    $0x88b8b4,%edx
    0.00 :	  5bb3c2:       be 98 00 00 00          mov    $0x98,%esi
    0.00 :	  5bb3c7:       bf 72 b8 88 00          mov    $0x88b872,%edi
    0.00 :	  5bb3cc:       e8 4f 00 1c 00          callq  77b420 <elog_start>
    0.00 :	  5bb3d1:       be 88 b8 88 00          mov    $0x88b888,%esi
    0.00 :	  5bb3d6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bb3db:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb3dd:       e8 4e fe 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bb3e2:       e8 e9 e0 ea ff          callq  4694d0 <abort@plt>
         :	        }
         :
         :	        /*
         :	         * if we get here it means we are at the end of the scan..
         :	         */
         :	        return ExecClearTuple(slot);
    0.00 :	  5bb3e7:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  5bb3ee:       e8 1d 8d ff ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5bb3f3:       48 89 85 38 ff ff ff    mov    %rax,-0xc8(%rbp)
         :	}
    0.00 :	  5bb3fa:       48 8b 85 38 ff ff ff    mov    -0xc8(%rbp),%rax
    0.00 :	  5bb401:       48 81 c4 d8 00 00 00    add    $0xd8,%rsp
    0.00 :	  5bb408:       5b                      pop    %rbx
    0.00 :	  5bb409:       41 5c                   pop    %r12
    0.00 :	  5bb40b:       41 5d                   pop    %r13
    0.00 :	  5bb40d:       41 5e                   pop    %r14
    0.00 :	  5bb40f:       41 5f                   pop    %r15
    0.00 :	  5bb411:       c9                      leaveq 
    0.00 :	  5bb412:       c3                      retq   
         :	                         * it doubles as later pages are fetched.
         :	                         */
         :	                        if (node->prefetch_target >= target_prefetch_pages)
         :	                                 /* don't increase any further */ ;
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
         :	                                node->prefetch_target = target_prefetch_pages;
    0.00 :	  5bb413:       89 93 cc 00 00 00       mov    %edx,0xcc(%rbx)
    0.00 :	  5bb419:       e9 05 fc ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	        {
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  5bb41e:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
    0.00 :	  5bb424:       85 d2                   test   %edx,%edx
    0.00 :	  5bb426:       0f 88 9e 01 00 00       js     5bb5ca <BitmapHeapNext+0x64a>
    0.00 :	  5bb42c:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
    0.00 :	  5bb432:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bb435:       4c 63 c8                movslq %eax,%r9
    0.00 :	  5bb438:       49 c1 e1 0d             shl    $0xd,%r9
    0.00 :	  5bb43c:       4c 03 0d b5 46 60 00    add    0x6046b5(%rip),%r9        # bbfaf8 <BufferBlocks>
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb443:       41 0f b7 41 0c          movzwl 0xc(%r9),%eax
    0.00 :	  5bb448:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  5bb44c:       77 2b                   ja     5bb479 <BitmapHeapNext+0x4f9>
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb44e:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb455:       00 00 00 
    0.00 :	  5bb458:       e9 c6 fe ff ff          jmpq   5bb323 <BitmapHeapNext+0x3a3>
         :	                        bitgetpage(scan, tbmres);
         :
         :	                        if (tbmres->ntuples >= 0)
         :	                                node->exact_pages++;
         :	                        else
         :	                                node->lossy_pages++;
    0.00 :	  5bb45d:       48 83 83 b8 00 00 00    addq   $0x1,0xb8(%rbx)
    0.00 :	  5bb464:       01 
    0.00 :	  5bb465:       e9 e5 fe ff ff          jmpq   5bb34f <BitmapHeapNext+0x3cf>
         :	                        {
         :	                                /* Do not let the prefetch iterator get behind the main one */
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
         :
         :	                                if (tbmpre == NULL || tbmpre->blockno != tbmres->blockno)
         :	                                        elog(ERROR, "prefetch and main iterators are out of sync");
    0.00 :	  5bb46a:       41 8b 4d 00             mov    0x0(%r13),%ecx
    0.00 :	  5bb46e:       89 8d 7c ff ff ff       mov    %ecx,-0x84(%rbp)
    0.00 :	  5bb474:       e9 81 fd ff ff          jmpq   5bb1fa <BitmapHeapNext+0x27a>
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb479:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb47c:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  5bb480:       48 c1 e8 02             shr    $0x2,%rax
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb484:       66 85 c0                test   %ax,%ax
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb487:       66 89 85 40 ff ff ff    mov    %ax,-0xc0(%rbp)
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb48e:       74 be                   je     5bb44e <BitmapHeapNext+0x4ce>
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb490:       8b 85 7c ff ff ff       mov    -0x84(%rbp),%eax
    0.00 :	  5bb496:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  5bb49c:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb4a3:       00 00 00 
    0.00 :	  5bb4a6:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  5bb4a9:       66 89 85 60 ff ff ff    mov    %ax,-0xa0(%rbp)
    0.00 :	  5bb4b0:       eb 18                   jmp    5bb4ca <BitmapHeapNext+0x54a>
    0.00 :	  5bb4b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
         :	                        }
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  5bb4b8:       41 83 c6 01             add    $0x1,%r14d
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb4bc:       66 44 3b b5 40 ff ff    cmp    -0xc0(%rbp),%r14w
    0.00 :	  5bb4c3:       ff 
    0.00 :	  5bb4c4:       0f 87 59 fe ff ff       ja     5bb323 <BitmapHeapNext+0x3a3>
         :	                {
         :	                        ItemId          lp;
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        lp = PageGetItemId(dp, offnum);
    0.00 :	  5bb4ca:       41 0f b7 c6             movzwl %r14w,%eax
         :	                        if (!ItemIdIsNormal(lp))
    0.00 :	  5bb4ce:       48 8d 50 03             lea    0x3(%rax),%rdx
    0.00 :	  5bb4d2:       41 8b 44 91 08          mov    0x8(%r9,%rdx,4),%eax
    0.00 :	  5bb4d7:       25 00 80 01 00          and    $0x18000,%eax
    0.00 :	  5bb4dc:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  5bb4e1:       75 d5                   jne    5bb4b8 <BitmapHeapNext+0x538>
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb4e3:       41 0f b7 44 91 08       movzwl 0x8(%r9,%rdx,4),%eax
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb4e9:       0f b7 8d 7c ff ff ff    movzwl -0x84(%rbp),%ecx
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb4f0:       48 8d 7d a0             lea    -0x60(%rbp),%rdi
    0.00 :	  5bb4f4:       48 8b b5 58 ff ff ff    mov    -0xa8(%rbp),%rsi
         :	                        bool            valid;
         :
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb4fb:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  5bb500:       49 8d 04 01             lea    (%r9,%rax,1),%rax
    0.00 :	  5bb504:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	                        loctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb508:       41 0f b7 44 91 0a       movzwl 0xa(%r9,%rdx,4),%eax
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb50e:       0f b7 95 60 ff ff ff    movzwl -0xa0(%rbp),%edx
         :
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb515:       66 d1 e8                shr    %ax
    0.00 :	  5bb518:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb51b:       89 45 a0                mov    %eax,-0x60(%rbp)
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb51e:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  5bb522:       8b 40 40                mov    0x40(%rax),%eax
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb525:       66 89 55 a4             mov    %dx,-0x5c(%rbp)
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb529:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb530:       66 89 4d a6             mov    %cx,-0x5a(%rbp)
    0.00 :	  5bb534:       66 44 89 75 a8          mov    %r14w,-0x58(%rbp)
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb539:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb53f:       89 45 ac                mov    %eax,-0x54(%rbp)
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb542:       ff 16                   callq  *(%rsi)
         :	                        if (valid)
    0.00 :	  5bb544:       84 c0                   test   %al,%al
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb546:       41 89 c0                mov    %eax,%r8d
         :	                        if (valid)
    0.00 :	  5bb549:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb550:       75 31                   jne    5bb583 <BitmapHeapNext+0x603>
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
         :	                        }
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  5bb552:       41 0f be f8             movsbl %r8b,%edi
    0.00 :	  5bb556:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb55a:       4c 8b 85 58 ff ff ff    mov    -0xa8(%rbp),%r8
    0.00 :	  5bb561:       8b 8d 78 ff ff ff       mov    -0x88(%rbp),%ecx
    0.00 :	  5bb567:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
    0.00 :	  5bb56b:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
    0.00 :	  5bb572:       e8 e9 90 0d 00          callq  694660 <CheckForSerializableConflictOut>
    0.00 :	  5bb577:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb57e:       e9 35 ff ff ff          jmpq   5bb4b8 <BitmapHeapNext+0x538>
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
    0.00 :	  5bb583:       48 63 85 54 ff ff ff    movslq -0xac(%rbp),%rax
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
    0.00 :	  5bb58a:       48 8d 75 a0             lea    -0x60(%rbp),%rsi
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
    0.00 :	  5bb58e:       66 45 89 74 44 7c       mov    %r14w,0x7c(%r12,%rax,2)
    0.00 :	  5bb594:       83 85 54 ff ff ff 01    addl   $0x1,-0xac(%rbp)
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
    0.00 :	  5bb59b:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb59f:       48 8b 95 58 ff ff ff    mov    -0xa8(%rbp),%rdx
    0.00 :	  5bb5a6:       44 88 85 18 ff ff ff    mov    %r8b,-0xe8(%rbp)
    0.00 :	  5bb5ad:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
    0.00 :	  5bb5b4:       e8 e7 95 0d 00          callq  694ba0 <PredicateLockTuple>
    0.00 :	  5bb5b9:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb5c0:       44 0f b6 85 18 ff ff    movzbl -0xe8(%rbp),%r8d
    0.00 :	  5bb5c7:       ff 
    0.00 :	  5bb5c8:       eb 88                   jmp    5bb552 <BitmapHeapNext+0x5d2>
         :	        {
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  5bb5ca:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
    0.00 :	  5bb5d0:       48 8b 15 41 1b 5c 00    mov    0x5c1b41(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  5bb5d7:       f7 d0                   not    %eax
    0.00 :	  5bb5d9:       48 98                   cltq   
    0.00 :	  5bb5db:       4c 8b 0c c2             mov    (%rdx,%rax,8),%r9
    0.00 :	  5bb5df:       e9 5f fe ff ff          jmpq   5bb443 <BitmapHeapNext+0x4c3>
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
         :	                                node->prefetch_target = target_prefetch_pages;
         :	                        else if (node->prefetch_target > 0)
         :	                                node->prefetch_target *= 2;
         :	                        else
         :	                                node->prefetch_target++;
    0.00 :	  5bb5e4:       8d 41 01                lea    0x1(%rcx),%eax
    0.00 :	  5bb5e7:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
    0.00 :	  5bb5ed:       e9 31 fa ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
         :	        {
         :	                tbm = (TIDBitmap *) MultiExecProcNode(outerPlanState(node));
    0.00 :	  5bb5f2:       48 8b 7f 30             mov    0x30(%rdi),%rdi
    0.00 :	  5bb5f6:       e8 d5 0d ff ff          callq  5ac3d0 <MultiExecProcNode>
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
    0.00 :	  5bb5fb:       48 85 c0                test   %rax,%rax
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
         :	        {
         :	                tbm = (TIDBitmap *) MultiExecProcNode(outerPlanState(node));
    0.00 :	  5bb5fe:       49 89 c5                mov    %rax,%r13
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
    0.00 :	  5bb601:       74 08                   je     5bb60b <BitmapHeapNext+0x68b>
    0.00 :	  5bb603:       81 38 ba 03 00 00       cmpl   $0x3ba,(%rax)
    0.00 :	  5bb609:       74 2a                   je     5bb635 <BitmapHeapNext+0x6b5>
         :	                        elog(ERROR, "unrecognized result from subplan");
    0.00 :	  5bb60b:       ba b4 b8 88 00          mov    $0x88b8b4,%edx
    0.00 :	  5bb610:       be 6b 00 00 00          mov    $0x6b,%esi
    0.00 :	  5bb615:       bf 72 b8 88 00          mov    $0x88b872,%edi
    0.00 :	  5bb61a:       e8 01 fe 1b 00          callq  77b420 <elog_start>
    0.00 :	  5bb61f:       be c0 b7 88 00          mov    $0x88b7c0,%esi
    0.00 :	  5bb624:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bb629:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb62b:       e8 00 fc 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bb630:       e8 9b de ea ff          callq  4694d0 <abort@plt>
         :
         :	                node->tbm = tbm;
    0.00 :	  5bb635:       48 89 83 98 00 00 00    mov    %rax,0x98(%rbx)
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb63c:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5bb63f:       e8 dc 7e 02 00          callq  5e3520 <tbm_begin_iterate>
         :	                node->tbmres = tbmres = NULL;
    0.00 :	  5bb644:       48 c7 83 a8 00 00 00    movq   $0x0,0xa8(%rbx)
    0.00 :	  5bb64b:       00 00 00 00 
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
         :	                        elog(ERROR, "unrecognized result from subplan");
         :
         :	                node->tbm = tbm;
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb64f:       48 89 83 a0 00 00 00    mov    %rax,0xa0(%rbx)
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
    0.00 :	  5bb656:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb658:       8b 0d 06 1a 5c 00       mov    0x5c1a06(%rip),%ecx        # b7d064 <target_prefetch_pages>
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
         :	                        elog(ERROR, "unrecognized result from subplan");
         :
         :	                node->tbm = tbm;
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb65e:       48 89 85 30 ff ff ff    mov    %rax,-0xd0(%rbp)
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
    0.00 :	  5bb665:       85 c9                   test   %ecx,%ecx
    0.00 :	  5bb667:       0f 8e 74 f9 ff ff       jle    5bafe1 <BitmapHeapNext+0x61>
         :	                {
         :	                        node->prefetch_iterator = prefetch_iterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb66d:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5bb670:       e8 ab 7e 02 00          callq  5e3520 <tbm_begin_iterate>
         :	                        node->prefetch_pages = 0;
    0.00 :	  5bb675:       c7 83 c8 00 00 00 00    movl   $0x0,0xc8(%rbx)
    0.00 :	  5bb67c:       00 00 00 
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
         :	                {
         :	                        node->prefetch_iterator = prefetch_iterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb67f:       49 89 c7                mov    %rax,%r15
    0.00 :	  5bb682:       48 89 83 c0 00 00 00    mov    %rax,0xc0(%rbx)
         :	                        node->prefetch_pages = 0;
         :	                        node->prefetch_target = -1;
    0.00 :	  5bb689:       c7 83 cc 00 00 00 ff    movl   $0xffffffff,0xcc(%rbx)
    0.00 :	  5bb690:       ff ff ff 
    0.00 :	  5bb693:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb695:       e9 47 f9 ff ff          jmpq   5bafe1 <BitmapHeapNext+0x61>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapIndexscan.c:117
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bb8c0 <ExecReScanBitmapIndexScan>:
         :	 *              information known at runtime, then rescans the indexed relation.
         :	 * ----------------------------------------------------------------
         :	 */
         :	void
         :	ExecReScanBitmapIndexScan(BitmapIndexScanState *node)
         :	{
    0.00 :	  5bb8c0:       55                      push   %rbp
    0.00 :	  5bb8c1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bb8c4:       41 54                   push   %r12
    0.00 :	  5bb8c6:       53                      push   %rbx
         :	        ExprContext *econtext = node->biss_RuntimeContext;
    0.00 :	  5bb8c7:       4c 8b a7 c8 00 00 00    mov    0xc8(%rdi),%r12
         :	 *              information known at runtime, then rescans the indexed relation.
         :	 * ----------------------------------------------------------------
         :	 */
         :	void
         :	ExecReScanBitmapIndexScan(BitmapIndexScanState *node)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapIndexscan.c:117
  100.00 :	  5bb8ce:       48 89 fb                mov    %rdi,%rbx
         :	        /*
         :	         * Reset the runtime-key context so we don't leak memory as each outer
         :	         * tuple is scanned.  Note this assumes that we will recalculate *all*
         :	         * runtime keys on each call.
         :	         */
         :	        if (econtext)
    0.00 :	  5bb8d1:       4d 85 e4                test   %r12,%r12
    0.00 :	  5bb8d4:       74 0a                   je     5bb8e0 <ExecReScanBitmapIndexScan+0x20>
         :	                ResetExprContext(econtext);
    0.00 :	  5bb8d6:       49 8b 7c 24 28          mov    0x28(%r12),%rdi
    0.00 :	  5bb8db:       e8 d0 d0 1d 00          callq  7989b0 <MemoryContextReset>
         :	         *
         :	         * Array keys are also treated as runtime keys; note that if we return
         :	         * with biss_RuntimeKeysReady still false, then there is an empty array
         :	         * key so no index scan is needed.
         :	         */
         :	        if (node->biss_NumRuntimeKeys != 0)
    0.00 :	  5bb8e0:       8b 93 b0 00 00 00       mov    0xb0(%rbx),%edx
    0.00 :	  5bb8e6:       85 d2                   test   %edx,%edx
    0.00 :	  5bb8e8:       75 36                   jne    5bb920 <ExecReScanBitmapIndexScan+0x60>
         :	                ExecIndexEvalRuntimeKeys(econtext,
         :	                                                                 node->biss_RuntimeKeys,
         :	                                                                 node->biss_NumRuntimeKeys);
         :	        if (node->biss_NumArrayKeys != 0)
    0.00 :	  5bb8ea:       8b 93 c0 00 00 00       mov    0xc0(%rbx),%edx
    0.00 :	  5bb8f0:       85 d2                   test   %edx,%edx
    0.00 :	  5bb8f2:       75 45                   jne    5bb939 <ExecReScanBitmapIndexScan+0x79>
         :	                node->biss_RuntimeKeysReady =
         :	                        ExecIndexEvalArrayKeys(econtext,
         :	                                                                   node->biss_ArrayKeys,
         :	                                                                   node->biss_NumArrayKeys);
         :	        else
         :	                node->biss_RuntimeKeysReady = true;
    0.00 :	  5bb8f4:       c6 83 c4 00 00 00 01    movb   $0x1,0xc4(%rbx)
         :
         :	        /* reset index scan */
         :	        if (node->biss_RuntimeKeysReady)
         :	                index_rescan(node->biss_ScanDesc,
    0.00 :	  5bb8fb:       8b 93 a0 00 00 00       mov    0xa0(%rbx),%edx
    0.00 :	  5bb901:       48 8b b3 98 00 00 00    mov    0x98(%rbx),%rsi
    0.00 :	  5bb908:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5bb90b:       48 8b bb d8 00 00 00    mov    0xd8(%rbx),%rdi
    0.00 :	  5bb912:       31 c9                   xor    %ecx,%ecx
         :	                                         node->biss_ScanKeys, node->biss_NumScanKeys,
         :	                                         NULL, 0);
         :	}
    0.00 :	  5bb914:       5b                      pop    %rbx
    0.00 :	  5bb915:       41 5c                   pop    %r12
    0.00 :	  5bb917:       c9                      leaveq 
         :	        else
         :	                node->biss_RuntimeKeysReady = true;
         :
         :	        /* reset index scan */
         :	        if (node->biss_RuntimeKeysReady)
         :	                index_rescan(node->biss_ScanDesc,
    0.00 :	  5bb918:       e9 f3 9e ee ff          jmpq   4a5810 <index_rescan>
    0.00 :	  5bb91d:       0f 1f 00                nopl   (%rax)
         :	         * Array keys are also treated as runtime keys; note that if we return
         :	         * with biss_RuntimeKeysReady still false, then there is an empty array
         :	         * key so no index scan is needed.
         :	         */
         :	        if (node->biss_NumRuntimeKeys != 0)
         :	                ExecIndexEvalRuntimeKeys(econtext,
    0.00 :	  5bb920:       48 8b b3 a8 00 00 00    mov    0xa8(%rbx),%rsi
    0.00 :	  5bb927:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5bb92a:       e8 21 39 00 00          callq  5bf250 <ExecIndexEvalRuntimeKeys>
         :	                                                                 node->biss_RuntimeKeys,
         :	                                                                 node->biss_NumRuntimeKeys);
         :	        if (node->biss_NumArrayKeys != 0)
    0.00 :	  5bb92f:       8b 93 c0 00 00 00       mov    0xc0(%rbx),%edx
    0.00 :	  5bb935:       85 d2                   test   %edx,%edx
    0.00 :	  5bb937:       74 bb                   je     5bb8f4 <ExecReScanBitmapIndexScan+0x34>
         :	                node->biss_RuntimeKeysReady =
    0.00 :	  5bb939:       48 8b b3 b8 00 00 00    mov    0xb8(%rbx),%rsi
    0.00 :	  5bb940:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5bb943:       e8 c8 39 00 00          callq  5bf310 <ExecIndexEvalArrayKeys>
         :	                                                                   node->biss_NumArrayKeys);
         :	        else
         :	                node->biss_RuntimeKeysReady = true;
         :
         :	        /* reset index scan */
         :	        if (node->biss_RuntimeKeysReady)
    0.00 :	  5bb948:       84 c0                   test   %al,%al
         :	        if (node->biss_NumRuntimeKeys != 0)
         :	                ExecIndexEvalRuntimeKeys(econtext,
         :	                                                                 node->biss_RuntimeKeys,
         :	                                                                 node->biss_NumRuntimeKeys);
         :	        if (node->biss_NumArrayKeys != 0)
         :	                node->biss_RuntimeKeysReady =
    0.00 :	  5bb94a:       88 83 c4 00 00 00       mov    %al,0xc4(%rbx)
         :	                                                                   node->biss_NumArrayKeys);
         :	        else
         :	                node->biss_RuntimeKeysReady = true;
         :
         :	        /* reset index scan */
         :	        if (node->biss_RuntimeKeysReady)
    0.00 :	  5bb950:       75 a9                   jne    5bb8fb <ExecReScanBitmapIndexScan+0x3b>
         :	                index_rescan(node->biss_ScanDesc,
         :	                                         node->biss_ScanKeys, node->biss_NumScanKeys,
         :	                                         NULL, 0);
         :	}
    0.00 :	  5bb952:       5b                      pop    %rbx
    0.00 :	  5bb953:       41 5c                   pop    %r12
    0.00 :	  5bb955:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:181
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c4240 <ExecNestLoop>:
         :	 *                         are prepared to return the first tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecNestLoop(NestLoopState *node)
         :	{
    0.00 :	  5c4240:       55                      push   %rbp
    0.00 :	  5c4241:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c4244:       41 57                   push   %r15
    0.00 :	  5c4246:       41 56                   push   %r14
    0.00 :	  5c4248:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5c424b:       41 55                   push   %r13
    0.00 :	  5c424d:       41 54                   push   %r12
    0.00 :	  5c424f:       53                      push   %rbx
    0.00 :	  5c4250:       48 83 ec 48             sub    $0x48,%rsp
         :	        /*
         :	         * get information from the node
         :	         */
         :	        ENL1_printf("getting info from node");
         :
         :	        nl = (NestLoop *) node->js.ps.plan;
    0.00 :	  5c4254:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5c4258:       48 89 45 98             mov    %rax,-0x68(%rbp)
         :	        joinqual = node->js.joinqual;
    0.00 :	  5c425c:       48 8b 97 80 00 00 00    mov    0x80(%rdi),%rdx
    0.00 :	  5c4263:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        otherqual = node->js.ps.qual;
    0.00 :	  5c4267:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  5c426b:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        outerPlan = outerPlanState(node);
    0.00 :	  5c426f:       48 8b 57 30             mov    0x30(%rdi),%rdx
    0.00 :	  5c4273:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	        innerPlan = innerPlanState(node);
    0.00 :	  5c4277:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  5c427b:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5c427f:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
         :	        nl = (NestLoop *) node->js.ps.plan;
         :	        joinqual = node->js.joinqual;
         :	        otherqual = node->js.ps.qual;
         :	        outerPlan = outerPlanState(node);
         :	        innerPlan = innerPlanState(node);
         :	        econtext = node->js.ps.ps_ExprContext;
    0.00 :	  5c4283:       4c 8b 7f 60             mov    0x60(%rdi),%r15
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5c4287:       74 1f                   je     5c42a8 <ExecNestLoop+0x68>
         :	        {
         :	                TupleTableSlot *result;
         :	                ExprDoneCond isDone;
         :
         :	                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c4289:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5c428d:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c4291:       e8 6a 8d fe ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5c4296:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5c429a:       0f 84 71 01 00 00       je     5c4411 <ExecNestLoop+0x1d1>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->js.ps.ps_TupFromTlist = false;
    0.00 :	  5c42a0:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
    0.00 :	  5c42a5:       0f 1f 00                nopl   (%rax)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a join tuple.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5c42a8:       49 8b 7f 28             mov    0x28(%r15),%rdi
    0.00 :	  5c42ac:       e8 ff 46 1d 00          callq  7989b0 <MemoryContextReset>
         :	        {
         :	                /*
         :	                 * If we don't have an outer tuple, get the next one and reset the
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
    0.00 :	  5c42b1:       41 80 be 88 00 00 00    cmpb   $0x0,0x88(%r14)
    0.00 :	  5c42b8:       00 
    0.00 :	  5c42b9:       0f 85 a1 00 00 00       jne    5c4360 <ExecNestLoop+0x120>
         :	                /*
         :	                 * we have an outerTuple, try to get the next inner tuple.
         :	                 */
         :	                ENL1_printf("getting new inner tuple");
         :
         :	                innerTupleSlot = ExecProcNode(innerPlan);
    0.00 :	  5c42bf:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5c42c3:       e8 d8 81 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                econtext->ecxt_innertuple = innerTupleSlot;
         :
         :	                if (TupIsNull(innerTupleSlot))
    0.00 :	  5c42c8:       48 85 c0                test   %rax,%rax
         :	                 * we have an outerTuple, try to get the next inner tuple.
         :	                 */
         :	                ENL1_printf("getting new inner tuple");
         :
         :	                innerTupleSlot = ExecProcNode(innerPlan);
         :	                econtext->ecxt_innertuple = innerTupleSlot;
    0.00 :	  5c42cb:       49 89 47 10             mov    %rax,0x10(%r15)
         :
         :	                if (TupIsNull(innerTupleSlot))
    0.00 :	  5c42cf:       74 0a                   je     5c42db <ExecNestLoop+0x9b>
    0.00 :	  5c42d1:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c42d5:       0f 84 45 01 00 00       je     5c4420 <ExecNestLoop+0x1e0>
         :	                {
         :	                        ENL1_printf("no inner tuple, need new outer tuple");
         :
         :	                        node->nl_NeedNewOuter = true;
         :
         :	                        if (!node->nl_MatchedOuter &&
    0.00 :	  5c42db:       41 80 be 89 00 00 00    cmpb   $0x0,0x89(%r14)
    0.00 :	  5c42e2:       00 
         :
         :	                if (TupIsNull(innerTupleSlot))
         :	                {
         :	                        ENL1_printf("no inner tuple, need new outer tuple");
         :
         :	                        node->nl_NeedNewOuter = true;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:181
  100.00 :	  5c42e3:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c42ea:       01 
         :
         :	                        if (!node->nl_MatchedOuter &&
    0.00 :	  5c42eb:       75 c4                   jne    5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c42ed:       41 8b 46 78             mov    0x78(%r14),%eax
    0.00 :	  5c42f1:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  5c42f4:       74 05                   je     5c42fb <ExecNestLoop+0xbb>
    0.00 :	  5c42f6:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5c42f9:       75 b6                   jne    5c42b1 <ExecNestLoop+0x71>
         :	                                 * We are doing an outer join and there were no join matches
         :	                                 * for this outer tuple.  Generate a fake join tuple with
         :	                                 * nulls for the inner tuple, and return it if it passes the
         :	                                 * non-join quals.
         :	                                 */
         :	                                econtext->ecxt_innertuple = node->nl_NullInnerTupleSlot;
    0.00 :	  5c42fb:       49 8b 86 90 00 00 00    mov    0x90(%r14),%rax
    0.00 :	  5c4302:       49 89 47 10             mov    %rax,0x10(%r15)
         :
         :	                                ENL1_printf("testing qualification for outer-join tuple");
         :
         :	                                if (otherqual == NIL || ExecQual(otherqual, econtext, false))
    0.00 :	  5c4306:       48 83 7d c0 00          cmpq   $0x0,-0x40(%rbp)
    0.00 :	  5c430b:       0f 84 bf 01 00 00       je     5c44d0 <ExecNestLoop+0x290>
    0.00 :	  5c4311:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5c4315:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4317:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c431a:       e8 f1 8b fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c431f:       84 c0                   test   %al,%al
    0.00 :	  5c4321:       0f 85 a9 01 00 00       jne    5c44d0 <ExecNestLoop+0x290>
         :	                                                        (isDone == ExprMultipleResult);
         :	                                                return result;
         :	                                        }
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered2(node, 1);
    0.00 :	  5c4327:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c432b:       48 85 c0                test   %rax,%rax
    0.00 :	  5c432e:       74 81                   je     5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c4330:       f2 0f 10 05 20 ae 1e    movsd  0x1eae20(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c4337:       00 
    0.00 :	  5c4338:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5c433f:       00 
    0.00 :	  5c4340:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5c4347:       00 
         :	        {
         :	                /*
         :	                 * If we don't have an outer tuple, get the next one and reset the
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
    0.00 :	  5c4348:       41 80 be 88 00 00 00    cmpb   $0x0,0x88(%r14)
    0.00 :	  5c434f:       00 
    0.00 :	  5c4350:       0f 84 69 ff ff ff       je     5c42bf <ExecNestLoop+0x7f>
    0.00 :	  5c4356:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5c435d:       00 00 00 
         :	                {
         :	                        ENL1_printf("getting new outer tuple");
         :	                        outerTupleSlot = ExecProcNode(outerPlan);
    0.00 :	  5c4360:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5c4364:       e8 37 81 fe ff          callq  5ac4a0 <ExecProcNode>
         :
         :	                        /*
         :	                         * if there are no more outer tuples, then the join is complete..
         :	                         */
         :	                        if (TupIsNull(outerTupleSlot))
    0.00 :	  5c4369:       48 85 c0                test   %rax,%rax
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
         :	                {
         :	                        ENL1_printf("getting new outer tuple");
         :	                        outerTupleSlot = ExecProcNode(outerPlan);
    0.00 :	  5c436c:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :
         :	                        /*
         :	                         * if there are no more outer tuples, then the join is complete..
         :	                         */
         :	                        if (TupIsNull(outerTupleSlot))
    0.00 :	  5c4370:       0f 84 99 00 00 00       je     5c440f <ExecNestLoop+0x1cf>
    0.00 :	  5c4376:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c437a:       0f 85 8f 00 00 00       jne    5c440f <ExecNestLoop+0x1cf>
         :	                                ENL1_printf("no outer tuple, ending join");
         :	                                return NULL;
         :	                        }
         :
         :	                        ENL1_printf("saving new outer tuple information");
         :	                        econtext->ecxt_outertuple = outerTupleSlot;
    0.00 :	  5c4380:       49 89 47 18             mov    %rax,0x18(%r15)
         :	                        node->nl_NeedNewOuter = false;
    0.00 :	  5c4384:       41 c6 86 88 00 00 00    movb   $0x0,0x88(%r14)
    0.00 :	  5c438b:       00 
         :	                        node->nl_MatchedOuter = false;
    0.00 :	  5c438c:       41 c6 86 89 00 00 00    movb   $0x0,0x89(%r14)
    0.00 :	  5c4393:       00 
         :
         :	                        /*
         :	                         * fetch the values of any outer Vars that must be passed to the
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
    0.00 :	  5c4394:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5c4398:       48 8b 42 70             mov    0x70(%rdx),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5c439c:       48 85 c0                test   %rax,%rax
    0.00 :	  5c439f:       74 60                   je     5c4401 <ExecNestLoop+0x1c1>
    0.00 :	  5c43a1:       4c 8b 68 08             mov    0x8(%rax),%r13
    0.00 :	  5c43a5:       4d 85 ed                test   %r13,%r13
    0.00 :	  5c43a8:       74 57                   je     5c4401 <ExecNestLoop+0x1c1>
    0.00 :	  5c43aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
    0.00 :	  5c43b0:       49 8b 45 00             mov    0x0(%r13),%rax
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43b4:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
    0.00 :	  5c43b8:       44 8b 60 04             mov    0x4(%rax),%r12d
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43bc:       48 8b 40 08             mov    0x8(%rax),%rax
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
         :	                                ParamExecData *prm;
         :
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
    0.00 :	  5c43c0:       49 63 dc                movslq %r12d,%rbx
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43c3:       0f bf 70 08             movswl 0x8(%rax),%esi
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
         :	                                ParamExecData *prm;
         :
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
    0.00 :	  5c43c7:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  5c43cb:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  5c43cf:       49 03 5f 30             add    0x30(%r15),%rbx
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43d3:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	  5c43d7:       e8 24 b0 ea ff          callq  46f400 <slot_getattr>
    0.00 :	  5c43dc:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	                                                                                  nlp->paramval->varattno,
         :	                                                                                  &(prm->isnull));
         :	                                /* Flag parameter value as changed */
         :	                                innerPlan->chgParam = bms_add_member(innerPlan->chgParam,
    0.00 :	  5c43e0:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  5c43e4:       44 89 e6                mov    %r12d,%esi
    0.00 :	  5c43e7:       48 8b 78 50             mov    0x50(%rax),%rdi
    0.00 :	  5c43eb:       e8 10 ec 01 00          callq  5e3000 <bms_add_member>
    0.00 :	  5c43f0:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5c43f4:       48 89 42 50             mov    %rax,0x50(%rdx)
         :
         :	                        /*
         :	                         * fetch the values of any outer Vars that must be passed to the
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
    0.00 :	  5c43f8:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5c43fc:       4d 85 ed                test   %r13,%r13
    0.00 :	  5c43ff:       75 af                   jne    5c43b0 <ExecNestLoop+0x170>
         :
         :	                        /*
         :	                         * now rescan the inner plan
         :	                         */
         :	                        ENL1_printf("rescanning inner plan");
         :	                        ExecReScan(innerPlan);
    0.00 :	  5c4401:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5c4405:       e8 96 40 fe ff          callq  5a84a0 <ExecReScan>
    0.00 :	  5c440a:       e9 b0 fe ff ff          jmpq   5c42bf <ExecNestLoop+0x7f>
         :	                        InstrCountFiltered1(node, 1);
         :
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
    0.00 :	  5c440f:       31 c0                   xor    %eax,%eax
         :
         :	                ENL1_printf("qualification failed, looping");
         :	        }
         :	}
    0.00 :	  5c4411:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5c4415:       5b                      pop    %rbx
    0.00 :	  5c4416:       41 5c                   pop    %r12
    0.00 :	  5c4418:       41 5d                   pop    %r13
    0.00 :	  5c441a:       41 5e                   pop    %r14
    0.00 :	  5c441c:       41 5f                   pop    %r15
    0.00 :	  5c441e:       c9                      leaveq 
    0.00 :	  5c441f:       c3                      retq   
         :	                 * Only the joinquals determine MatchedOuter status, but all quals
         :	                 * must pass to actually return the tuple.
         :	                 */
         :	                ENL1_printf("testing qualification");
         :
         :	                if (ExecQual(joinqual, econtext, false))
    0.00 :	  5c4420:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5c4424:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4426:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c4429:       e8 e2 8a fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c442e:       84 c0                   test   %al,%al
    0.00 :	  5c4430:       74 6e                   je     5c44a0 <ExecNestLoop+0x260>
         :	                {
         :	                        node->nl_MatchedOuter = true;
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
    0.00 :	  5c4432:       41 8b 46 78             mov    0x78(%r14),%eax
         :	                 */
         :	                ENL1_printf("testing qualification");
         :
         :	                if (ExecQual(joinqual, econtext, false))
         :	                {
         :	                        node->nl_MatchedOuter = true;
    0.00 :	  5c4436:       41 c6 86 89 00 00 00    movb   $0x1,0x89(%r14)
    0.00 :	  5c443d:       01 
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
    0.00 :	  5c443e:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5c4441:       0f 84 e1 00 00 00       je     5c4528 <ExecNestLoop+0x2e8>
         :
         :	                        /*
         :	                         * In a semijoin, we'll consider returning the first match, but
         :	                         * after that we're done with this outer tuple.
         :	                         */
         :	                        if (node->js.jointype == JOIN_SEMI)
    0.00 :	  5c4447:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  5c444a:       0f 84 e8 00 00 00       je     5c4538 <ExecNestLoop+0x2f8>
         :	                                node->nl_NeedNewOuter = true;
         :
         :	                        if (otherqual == NIL || ExecQual(otherqual, econtext, false))
    0.00 :	  5c4450:       48 83 7d c0 00          cmpq   $0x0,-0x40(%rbp)
    0.00 :	  5c4455:       0f 84 a5 00 00 00       je     5c4500 <ExecNestLoop+0x2c0>
    0.00 :	  5c445b:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5c445f:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4461:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c4464:       e8 a7 8a fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c4469:       84 c0                   test   %al,%al
    0.00 :	  5c446b:       0f 85 8f 00 00 00       jne    5c4500 <ExecNestLoop+0x2c0>
         :	                                                (isDone == ExprMultipleResult);
         :	                                        return result;
         :	                                }
         :	                        }
         :	                        else
         :	                                InstrCountFiltered2(node, 1);
    0.00 :	  5c4471:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c4475:       48 85 c0                test   %rax,%rax
    0.00 :	  5c4478:       0f 84 2a fe ff ff       je     5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c447e:       f2 0f 10 05 d2 ac 1e    movsd  0x1eacd2(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c4485:       00 
    0.00 :	  5c4486:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5c448d:       00 
    0.00 :	  5c448e:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5c4495:       00 
    0.00 :	  5c4496:       e9 0d fe ff ff          jmpq   5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c449b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                }
         :	                else
         :	                        InstrCountFiltered1(node, 1);
    0.00 :	  5c44a0:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c44a4:       48 85 c0                test   %rax,%rax
    0.00 :	  5c44a7:       0f 84 fb fd ff ff       je     5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c44ad:       f2 0f 10 05 a3 ac 1e    movsd  0x1eaca3(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c44b4:       00 
    0.00 :	  5c44b5:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5c44bc:       00 
    0.00 :	  5c44bd:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5c44c4:       00 
    0.00 :	  5c44c5:       e9 de fd ff ff          jmpq   5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c44ca:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        TupleTableSlot *result;
         :	                                        ExprDoneCond isDone;
         :
         :	                                        ENL1_printf("qualification succeeded, projecting tuple");
         :
         :	                                        result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c44d0:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5c44d4:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c44d8:       e8 23 8b fe ff          callq  5ad000 <ExecProject>
         :
         :	                                        if (isDone != ExprEndResult)
    0.00 :	  5c44dd:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5c44e0:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5c44e3:       0f 84 c8 fd ff ff       je     5c42b1 <ExecNestLoop+0x71>
         :
         :	                                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
         :
         :	                                if (isDone != ExprEndResult)
         :	                                {
         :	                                        node->js.ps.ps_TupFromTlist =
    0.00 :	  5c44e9:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5c44ec:       41 0f 94 46 70          sete   0x70(%r14)
         :	                 */
         :	                ResetExprContext(econtext);
         :
         :	                ENL1_printf("qualification failed, looping");
         :	        }
         :	}
    0.00 :	  5c44f1:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5c44f5:       5b                      pop    %rbx
    0.00 :	  5c44f6:       41 5c                   pop    %r12
    0.00 :	  5c44f8:       41 5d                   pop    %r13
    0.00 :	  5c44fa:       41 5e                   pop    %r14
    0.00 :	  5c44fc:       41 5f                   pop    %r15
    0.00 :	  5c44fe:       c9                      leaveq 
    0.00 :	  5c44ff:       c3                      retq   
         :	                                TupleTableSlot *result;
         :	                                ExprDoneCond isDone;
         :
         :	                                ENL1_printf("qualification succeeded, projecting tuple");
         :
         :	                                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c4500:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5c4504:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c4508:       e8 f3 8a fe ff          callq  5ad000 <ExecProject>
         :
         :	                                if (isDone != ExprEndResult)
    0.00 :	  5c450d:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5c4510:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5c4513:       0f 84 8f fd ff ff       je     5c42a8 <ExecNestLoop+0x68>
         :	                                {
         :	                                        node->js.ps.ps_TupFromTlist =
    0.00 :	  5c4519:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5c451c:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5c4521:       eb ce                   jmp    5c44f1 <ExecNestLoop+0x2b1>
    0.00 :	  5c4523:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        node->nl_MatchedOuter = true;
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
         :	                        {
         :	                                node->nl_NeedNewOuter = true;
    0.00 :	  5c4528:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c452f:       01 
         :	                                continue;               /* return to top of loop */
    0.00 :	  5c4530:       e9 7c fd ff ff          jmpq   5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c4535:       0f 1f 00                nopl   (%rax)
         :	                        /*
         :	                         * In a semijoin, we'll consider returning the first match, but
         :	                         * after that we're done with this outer tuple.
         :	                         */
         :	                        if (node->js.jointype == JOIN_SEMI)
         :	                                node->nl_NeedNewOuter = true;
    0.00 :	  5c4538:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c453f:       01 
    0.00 :	  5c4540:       e9 0b ff ff ff          jmpq   5c4450 <ExecNestLoop+0x210>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:1013
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005e34f0 <tbm_comparator>:
         :	 * qsort comparator to handle PagetableEntry pointers.
         :	 */
         :	static int
         :	tbm_comparator(const void *left, const void *right)
         :	{
         :	        BlockNumber l = (*((PagetableEntry *const *) left))->blockno;
    0.00 :	  5e34f0:       48 8b 17                mov    (%rdi),%rdx
         :	        BlockNumber r = (*((PagetableEntry *const *) right))->blockno;
    0.00 :	  5e34f3:       48 8b 06                mov    (%rsi),%rax
         :
         :	        if (l < r)
    0.00 :	  5e34f6:       b9 ff ff ff ff          mov    $0xffffffff,%ecx
         :	/*
         :	 * qsort comparator to handle PagetableEntry pointers.
         :	 */
         :	static int
         :	tbm_comparator(const void *left, const void *right)
         :	{
    0.00 :	  5e34fb:       55                      push   %rbp
         :	        BlockNumber l = (*((PagetableEntry *const *) left))->blockno;
         :	        BlockNumber r = (*((PagetableEntry *const *) right))->blockno;
    0.00 :	  5e34fc:       8b 00                   mov    (%rax),%eax
         :
         :	        if (l < r)
    0.00 :	  5e34fe:       39 02                   cmp    %eax,(%rdx)
         :	/*
         :	 * qsort comparator to handle PagetableEntry pointers.
         :	 */
         :	static int
         :	tbm_comparator(const void *left, const void *right)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/nodes/tidbitmap.c:1013
  100.00 :	  5e3500:       48 89 e5                mov    %rsp,%rbp
         :	        BlockNumber l = (*((PagetableEntry *const *) left))->blockno;
         :	        BlockNumber r = (*((PagetableEntry *const *) right))->blockno;
         :
         :	        if (l < r)
    0.00 :	  5e3503:       72 06                   jb     5e350b <tbm_comparator+0x1b>
    0.00 :	  5e3505:       0f 97 c0                seta   %al
    0.00 :	  5e3508:       0f b6 c8                movzbl %al,%ecx
         :	                return -1;
         :	        else if (l > r)
         :	                return 1;
         :	        return 0;
         :	}
    0.00 :	  5e350b:       89 c8                   mov    %ecx,%eax
    0.00 :	  5e350d:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2112
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674030 <BufferGetBlockNumber>:
         :	 *              Assumes that the buffer is valid and pinned, else the
         :	 *              value may be obsolete immediately...
         :	 */
         :	BlockNumber
         :	BufferGetBlockNumber(Buffer buffer)
         :	{
    0.00 :	  674030:       55                      push   %rbp
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674031:       85 ff                   test   %edi,%edi
         :	 *              Assumes that the buffer is valid and pinned, else the
         :	 *              value may be obsolete immediately...
         :	 */
         :	BlockNumber
         :	BufferGetBlockNumber(Buffer buffer)
         :	{
    0.00 :	  674033:       48 89 e5                mov    %rsp,%rbp
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674036:       78 18                   js     674050 <BufferGetBlockNumber+0x20>
         :	                bufHdr = &(LocalBufferDescriptors[-buffer - 1]);
         :	        else
         :	                bufHdr = &BufferDescriptors[buffer - 1];
    0.00 :	  674038:       48 63 c7                movslq %edi,%rax
    0.00 :	  67403b:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  67403f:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674043:       48 03 05 b6 ba 54 00    add    0x54bab6(%rip),%rax        # bbfb00 <BufferDescriptors>
         :
         :	        /* pinned, so OK to read tag without spinlock */
         :	        return bufHdr->tag.blockNum;
    0.00 :	  67404a:       8b 40 10                mov    0x10(%rax),%eax
         :	}
    0.00 :	  67404d:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2112
  100.00 :	  67404e:       c3                      retq   
    0.00 :	  67404f:       90                      nop
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
         :	                bufHdr = &(LocalBufferDescriptors[-buffer - 1]);
    0.00 :	  674050:       f7 d7                   not    %edi
    0.00 :	  674052:       48 63 c7                movslq %edi,%rax
    0.00 :	  674055:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674059:       48 03 05 b0 90 50 00    add    0x5090b0(%rip),%rax        # b7d110 <LocalBufferDescriptors>
         :	        else
         :	                bufHdr = &BufferDescriptors[buffer - 1];
         :
         :	        /* pinned, so OK to read tag without spinlock */
         :	        return bufHdr->tag.blockNum;
    0.00 :	  674060:       8b 40 10                mov    0x10(%rax),%eax
         :	}
    0.00 :	  674063:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2784
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674e60 <ReleaseBuffer>:
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e60:       55                      push   %rbp
    0.00 :	  674e61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674e64:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  674e68:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  674e6c:       48 83 ec 10             sub    $0x10,%rsp
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e70:       85 ff                   test   %edi,%edi
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e72:       89 fb                   mov    %edi,%ebx
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e74:       74 7f                   je     674ef5 <ReleaseBuffer+0x95>
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
         :
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
    0.00 :	  674e76:       89 fe                   mov    %edi,%esi
    0.00 :	  674e78:       48 8b 3d 41 5a 54 00    mov    0x545a41(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674e7f:       e8 7c 5a 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674e84:       85 db                   test   %ebx,%ebx
    0.00 :	  674e86:       78 38                   js     674ec0 <ReleaseBuffer+0x60>
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
    0.00 :	  674e88:       31 d2                   xor    %edx,%edx
    0.00 :	  674e8a:       31 f6                   xor    %esi,%esi
    0.00 :	  674e8c:       89 df                   mov    %ebx,%edi
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
    0.00 :	  674e8e:       4c 8b 25 6b ac 54 00    mov    0x54ac6b(%rip),%r12        # bbfb00 <BufferDescriptors>
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
    0.00 :	  674e95:       e8 86 f6 ff ff          callq  674520 <GetPrivateRefCountEntry>
    0.00 :	  674e9a:       48 89 c2                mov    %rax,%rdx
         :	        Assert(ref != NULL);
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2784
  100.00 :	  674e9d:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  674ea0:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  674ea3:       7e 33                   jle    674ed8 <ReleaseBuffer+0x78>
         :	                ref->refcount--;
    0.00 :	  674ea5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674ea8:       89 42 04                mov    %eax,0x4(%rdx)
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674eab:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  674eaf:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eb4:       c9                      leaveq 
    0.00 :	  674eb5:       c3                      retq   
    0.00 :	  674eb6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  674ebd:       00 00 00 
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
         :
         :	        if (BufferIsLocal(buffer))
         :	        {
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
    0.00 :	  674ec0:       f7 d3                   not    %ebx
    0.00 :	  674ec2:       48 63 c3                movslq %ebx,%rax
    0.00 :	  674ec5:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  674ec9:       48 03 05 50 82 50 00    add    0x508250(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  674ed0:       83 28 01                subl   $0x1,(%rax)
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674ed3:       eb d6                   jmp    674eab <ReleaseBuffer+0x4b>
    0.00 :	  674ed5:       0f 1f 00                nopl   (%rax)
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ed8:       48 63 c3                movslq %ebx,%rax
         :	}
    0.00 :	  674edb:       48 8b 1c 24             mov    (%rsp),%rbx
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674edf:       31 f6                   xor    %esi,%esi
    0.00 :	  674ee1:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674ee5:       49 8d 7c 04 c0          lea    -0x40(%r12,%rax,1),%rdi
         :	}
    0.00 :	  674eea:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eef:       c9                      leaveq 
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ef0:       e9 3b fe ff ff          jmpq   674d30 <UnpinBuffer>
         :	{
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
    0.00 :	  674ef5:       ba 34 a0 8a 00          mov    $0x8aa034,%edx
    0.00 :	  674efa:       be cf 0a 00 00          mov    $0xacf,%esi
    0.00 :	  674eff:       bf 53 9d 8a 00          mov    $0x8a9d53,%edi
    0.00 :	  674f04:       e8 17 65 10 00          callq  77b420 <elog_start>
    0.00 :	  674f09:       31 d2                   xor    %edx,%edx
    0.00 :	  674f0b:       be 5c 9d 8a 00          mov    $0x8a9d5c,%esi
    0.00 :	  674f10:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  674f15:       31 c0                   xor    %eax,%eax
    0.00 :	  674f17:       e8 14 63 10 00          callq  77b230 <elog_finish>
    0.00 :	  674f1c:       e8 af 45 df ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1779
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006756f0 <BgBufferSync>:
         :	 * or if the bgwriter has been effectively disabled by setting
         :	 * bgwriter_lru_maxpages to 0.)
         :	 */
         :	bool
         :	BgBufferSync(void)
         :	{
    0.00 :	  6756f0:       55                      push   %rbp
    0.00 :	  6756f1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6756f4:       41 57                   push   %r15
         :
         :	        /*
         :	         * Find out where the freelist clock sweep currently is, and how many
         :	         * buffer allocations have happened since our last call.
         :	         */
         :	        strategy_buf_id = StrategySyncStart(&strategy_passes, &recent_alloc);
    0.00 :	  6756f6:       48 8d 75 d0             lea    -0x30(%rbp),%rsi
    0.00 :	  6756fa:       48 8d 7d d4             lea    -0x2c(%rbp),%rdi
         :	 * or if the bgwriter has been effectively disabled by setting
         :	 * bgwriter_lru_maxpages to 0.)
         :	 */
         :	bool
         :	BgBufferSync(void)
         :	{
    0.00 :	  6756fe:       41 56                   push   %r14
    0.00 :	  675700:       41 55                   push   %r13
    0.00 :	  675702:       41 54                   push   %r12
    0.00 :	  675704:       53                      push   %rbx
    0.00 :	  675705:       48 83 ec 18             sub    $0x18,%rsp
         :
         :	        /*
         :	         * Find out where the freelist clock sweep currently is, and how many
         :	         * buffer allocations have happened since our last call.
         :	         */
         :	        strategy_buf_id = StrategySyncStart(&strategy_passes, &recent_alloc);
    0.00 :	  675709:       e8 22 1d 00 00          callq  677430 <StrategySyncStart>
         :
         :	        /* Report buffer alloc counts to pgstat */
         :	        BgWriterStats.m_buf_alloc += recent_alloc;
    0.00 :	  67570e:       44 8b 55 d0             mov    -0x30(%rbp),%r10d
         :	        /*
         :	         * If we're not running the LRU scan, just stop after doing the stats
         :	         * stuff.  We mark the saved state invalid so that we can recover sanely
         :	         * if LRU scan is turned back on later.
         :	         */
         :	        if (bgwriter_lru_maxpages <= 0)
    0.00 :	  675712:       44 8b 1d 77 2f 4f 00    mov    0x4f2f77(%rip),%r11d        # b68690 <bgwriter_lru_maxpages>
         :
         :	        /*
         :	         * Find out where the freelist clock sweep currently is, and how many
         :	         * buffer allocations have happened since our last call.
         :	         */
         :	        strategy_buf_id = StrategySyncStart(&strategy_passes, &recent_alloc);
    0.00 :	  675719:       89 c6                   mov    %eax,%esi
         :
         :	        /* Report buffer alloc counts to pgstat */
         :	        BgWriterStats.m_buf_alloc += recent_alloc;
    0.00 :	  67571b:       45 89 d1                mov    %r10d,%r9d
    0.00 :	  67571e:       4c 01 0d 5b a3 54 00    add    %r9,0x54a35b(%rip)        # bbfa80 <BgWriterStats+0x40>
         :	        /*
         :	         * If we're not running the LRU scan, just stop after doing the stats
         :	         * stuff.  We mark the saved state invalid so that we can recover sanely
         :	         * if LRU scan is turned back on later.
         :	         */
         :	        if (bgwriter_lru_maxpages <= 0)
    0.00 :	  675725:       45 85 db                test   %r11d,%r11d
    0.00 :	  675728:       0f 8e a2 02 00 00       jle    6759d0 <BgBufferSync+0x2e0>
         :	         * see if we are still ahead of the clock sweep, and if so, how many
         :	         * buffers we could scan before we'd catch up with it and "lap" it. Note:
         :	         * weird-looking coding of xxx_passes comparisons are to avoid bogus
         :	         * behavior when the passes counts wrap around.
         :	         */
         :	        if (saved_info_valid)
    0.00 :	  67572e:       80 3d 6f 79 50 00 00    cmpb   $0x0,0x50796f(%rip)        # b7d0a4 <saved_info_valid.17628>
    0.00 :	  675735:       0f 85 4d 01 00 00       jne    675888 <BgBufferSync+0x198>
         :	        }
         :
         :	        /* Update saved info for next time */
         :	        prev_strategy_buf_id = strategy_buf_id;
         :	        prev_strategy_passes = strategy_passes;
         :	        saved_info_valid = true;
    0.00 :	  67573b:       f3 49 0f 2a d1          cvtsi2ss %r9,%xmm2
         :	#ifdef BGW_DEBUG
         :	                elog(DEBUG2, "bgwriter initializing: strategy %u-%u",
         :	                         strategy_passes, strategy_buf_id);
         :	#endif
         :	                strategy_delta = 0;
         :	                next_to_clean = strategy_buf_id;
    0.00 :	  675740:       89 05 52 79 50 00       mov    %eax,0x507952(%rip)        # b7d098 <next_to_clean.17631>
         :	                next_passes = strategy_passes;
         :	                bufs_to_lap = NBuffers;
    0.00 :	  675746:       8b 3d d4 33 4f 00       mov    0x4f33d4(%rip),%edi        # b68b20 <NBuffers>
         :	                elog(DEBUG2, "bgwriter initializing: strategy %u-%u",
         :	                         strategy_passes, strategy_buf_id);
         :	#endif
         :	                strategy_delta = 0;
         :	                next_to_clean = strategy_buf_id;
         :	                next_passes = strategy_passes;
    0.00 :	  67574c:       8b 45 d4                mov    -0x2c(%rbp),%eax
         :	                bufs_to_lap = NBuffers;
         :	        }
         :
         :	        /* Update saved info for next time */
         :	        prev_strategy_buf_id = strategy_buf_id;
    0.00 :	  67574f:       89 35 4b 79 50 00       mov    %esi,0x50794b(%rip)        # b7d0a0 <prev_strategy_buf_id.17629>
         :	        prev_strategy_passes = strategy_passes;
         :	        saved_info_valid = true;
    0.00 :	  675755:       c6 05 48 79 50 00 01    movb   $0x1,0x507948(%rip)        # b7d0a4 <saved_info_valid.17628>
         :	                         strategy_passes, strategy_buf_id);
         :	#endif
         :	                strategy_delta = 0;
         :	                next_to_clean = strategy_buf_id;
         :	                next_passes = strategy_passes;
         :	                bufs_to_lap = NBuffers;
    0.00 :	  67575c:       89 7d c4                mov    %edi,-0x3c(%rbp)
         :	                elog(DEBUG2, "bgwriter initializing: strategy %u-%u",
         :	                         strategy_passes, strategy_buf_id);
         :	#endif
         :	                strategy_delta = 0;
         :	                next_to_clean = strategy_buf_id;
         :	                next_passes = strategy_passes;
    0.00 :	  67575f:       89 05 2f 79 50 00       mov    %eax,0x50792f(%rip)        # b7d094 <next_passes.17632>
         :	                bufs_to_lap = NBuffers;
         :	        }
         :
         :	        /* Update saved info for next time */
         :	        prev_strategy_buf_id = strategy_buf_id;
         :	        prev_strategy_passes = strategy_passes;
    0.00 :	  675765:       89 05 31 79 50 00       mov    %eax,0x507931(%rip)        # b7d09c <prev_strategy_passes.17630>
         :	         * Estimate how many reusable buffers there are between the current
         :	         * strategy point and where we've scanned ahead to, based on the smoothed
         :	         * density estimate.
         :	         */
         :	        bufs_ahead = NBuffers - bufs_to_lap;
         :	        reusable_buffers_est = (float) bufs_ahead / smoothed_density;
    0.00 :	  67576b:       89 f8                   mov    %edi,%eax
    0.00 :	  67576d:       2b 45 c4                sub    -0x3c(%rbp),%eax
    0.00 :	  675770:       f3 0f 2a c0             cvtsi2ss %eax,%xmm0
    0.00 :	  675774:       f3 0f 5e 05 24 2f 4f    divss  0x4f2f24(%rip),%xmm0        # b686a0 <smoothed_density.17634>
    0.00 :	  67577b:       00 
    0.00 :	  67577c:       f3 44 0f 2c f8          cvttss2si %xmm0,%r15d
         :	        /*
         :	         * Track a moving average of recent buffer allocations.  Here, rather than
         :	         * a true average we want a fast-attack, slow-decline behavior: we
         :	         * immediately follow any increase.
         :	         */
         :	        if (smoothed_alloc <= (float) recent_alloc)
    0.00 :	  675781:       f3 0f 10 05 07 79 50    movss  0x507907(%rip),%xmm0        # b7d090 <smoothed_alloc.17633>
    0.00 :	  675788:       00 
    0.00 :	  675789:       0f 2e d0                ucomiss %xmm0,%xmm2
    0.00 :	  67578c:       0f 82 1e 02 00 00       jb     6759b0 <BgBufferSync+0x2c0>
         :	                smoothed_alloc = recent_alloc;
    0.00 :	  675792:       f3 0f 11 15 f6 78 50    movss  %xmm2,0x5078f6(%rip)        # b7d090 <smoothed_alloc.17633>
    0.00 :	  675799:       00 
         :	        else
         :	                smoothed_alloc += ((float) recent_alloc - smoothed_alloc) /
         :	                        smoothing_samples;
         :
         :	        /* Scale the estimate by a GUC to allow more aggressive tuning. */
         :	        upcoming_alloc_est = (int) (smoothed_alloc * bgwriter_lru_multiplier);
    0.00 :	  67579a:       f3 0f 10 05 ee 78 50    movss  0x5078ee(%rip),%xmm0        # b7d090 <smoothed_alloc.17633>
    0.00 :	  6757a1:       00 
    0.00 :	  6757a2:       0f 5a c0                cvtps2pd %xmm0,%xmm0
    0.00 :	  6757a5:       f2 0f 59 05 eb 2e 4f    mulsd  0x4f2eeb(%rip),%xmm0        # b68698 <bgwriter_lru_multiplier>
    0.00 :	  6757ac:       00 
    0.00 :	  6757ad:       f2 0f 2c d0             cvttsd2si %xmm0,%edx
         :	         * kernel warnings on some platforms.  Once upcoming_alloc_est has gone to
         :	         * zero, there's no point in tracking smaller and smaller values of
         :	         * smoothed_alloc, so just reset it to exactly zero to avoid this
         :	         * syndrome.  It will pop back up as soon as recent_alloc increases.
         :	         */
         :	        if (upcoming_alloc_est == 0)
    0.00 :	  6757b1:       85 d2                   test   %edx,%edx
    0.00 :	  6757b3:       75 0a                   jne    6757bf <BgBufferSync+0xcf>
         :	                smoothed_alloc = 0;
    0.00 :	  6757b5:       c7 05 d1 78 50 00 00    movl   $0x0,0x5078d1(%rip)        # b7d090 <smoothed_alloc.17633>
    0.00 :	  6757bc:       00 00 00 
    0.00 :	  6757bf:       f3 0f 2a 15 29 2e 4f    cvtsi2ssl 0x4f2e29(%rip),%xmm2        # b685f0 <BgWriterDelay>
    0.00 :	  6757c6:       00 
         :	         * enough buffers to match our estimate of the next cycle's allocation
         :	         * requirements, or hit the bgwriter_lru_maxpages limit.
         :	         */
         :
         :	        /* Make sure we can handle the pin inside SyncOneBuffer */
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  6757c7:       45 89 fc                mov    %r15d,%r12d
         :	         * zero, there's no point in tracking smaller and smaller values of
         :	         * smoothed_alloc, so just reset it to exactly zero to avoid this
         :	         * syndrome.  It will pop back up as soon as recent_alloc increases.
         :	         */
         :	        if (upcoming_alloc_est == 0)
         :	                smoothed_alloc = 0;
    0.00 :	  6757ca:       f3 0f 10 05 16 49 23    movss  0x234916(%rip),%xmm0        # 8aa0e8 <__func__.17063+0x15>
    0.00 :	  6757d1:       00 
    0.00 :	  6757d2:       f3 0f 2a cf             cvtsi2ss %edi,%xmm1
         :	         * enough buffers to match our estimate of the next cycle's allocation
         :	         * requirements, or hit the bgwriter_lru_maxpages limit.
         :	         */
         :
         :	        /* Make sure we can handle the pin inside SyncOneBuffer */
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  6757d6:       48 8b 3d e3 50 54 00    mov    0x5450e3(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
         :	         * zero, there's no point in tracking smaller and smaller values of
         :	         * smoothed_alloc, so just reset it to exactly zero to avoid this
         :	         * syndrome.  It will pop back up as soon as recent_alloc increases.
         :	         */
         :	        if (upcoming_alloc_est == 0)
         :	                smoothed_alloc = 0;
    0.00 :	  6757dd:       f3 0f 5e c2             divss  %xmm2,%xmm0
    0.00 :	  6757e1:       f3 0f 5e c8             divss  %xmm0,%xmm1
    0.00 :	  6757e5:       f3 0f 2c c1             cvttss2si %xmm1,%eax
    0.00 :	  6757e9:       45 8d 34 07             lea    (%r15,%rax,1),%r14d
    0.00 :	  6757ed:       41 39 d6                cmp    %edx,%r14d
    0.00 :	  6757f0:       44 0f 4c f2             cmovl  %edx,%r14d
         :	         * enough buffers to match our estimate of the next cycle's allocation
         :	         * requirements, or hit the bgwriter_lru_maxpages limit.
         :	         */
         :
         :	        /* Make sure we can handle the pin inside SyncOneBuffer */
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  6757f4:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  6757f7:       e8 74 56 12 00          callq  79ae70 <ResourceOwnerEnlargeBuffers>
    0.00 :	  6757fc:       8b 5d c4                mov    -0x3c(%rbp),%ebx
    0.00 :	  6757ff:       90                      nop
         :	        num_to_scan = bufs_to_lap;
         :	        num_written = 0;
         :	        reusable_buffers = reusable_buffers_est;
         :
         :	        /* Execute the LRU scan */
         :	        while (num_to_scan > 0 && reusable_buffers < upcoming_alloc_est)
    0.00 :	  675800:       85 db                   test   %ebx,%ebx
    0.00 :	  675802:       7e 09                   jle    67580d <BgBufferSync+0x11d>
    0.00 :	  675804:       45 39 e6                cmp    %r12d,%r14d
    0.00 :	  675807:       0f 8f 23 01 00 00       jg     675930 <BgBufferSync+0x240>
         :	                }
         :	                else if (buffer_state & BUF_REUSABLE)
         :	                        reusable_buffers++;
         :	        }
         :
         :	        BgWriterStats.m_buf_written_clean += num_written;
    0.00 :	  67580d:       49 63 c5                movslq %r13d,%rax
    0.00 :	  675810:       48 01 05 49 a2 54 00    add    %rax,0x54a249(%rip)        # bbfa60 <BgWriterStats+0x20>
         :	         * effectively halves the moving average period in cases where both the
         :	         * strategy and the background writer are doing some useful scanning,
         :	         * which is helpful because a long memory isn't as desirable on the
         :	         * density estimates.
         :	         */
         :	        new_strategy_delta = bufs_to_lap - num_to_scan;
    0.00 :	  675817:       8b 45 c4                mov    -0x3c(%rbp),%eax
         :	        new_recent_alloc = reusable_buffers - reusable_buffers_est;
    0.00 :	  67581a:       44 89 e2                mov    %r12d,%edx
    0.00 :	  67581d:       44 29 fa                sub    %r15d,%edx
         :	         * effectively halves the moving average period in cases where both the
         :	         * strategy and the background writer are doing some useful scanning,
         :	         * which is helpful because a long memory isn't as desirable on the
         :	         * density estimates.
         :	         */
         :	        new_strategy_delta = bufs_to_lap - num_to_scan;
    0.00 :	  675820:       29 d8                   sub    %ebx,%eax
    0.00 :	  675822:       48 98                   cltq   
         :	        new_recent_alloc = reusable_buffers - reusable_buffers_est;
         :	        if (new_strategy_delta > 0 && new_recent_alloc > 0)
    0.00 :	  675824:       48 85 c0                test   %rax,%rax
    0.00 :	  675827:       7e 34                   jle    67585d <BgBufferSync+0x16d>
    0.00 :	  675829:       85 d2                   test   %edx,%edx
    0.00 :	  67582b:       74 30                   je     67585d <BgBufferSync+0x16d>
         :	        {
         :	                scans_per_alloc = (float) new_strategy_delta / (float) new_recent_alloc;
         :	                smoothed_density += (scans_per_alloc - smoothed_density) /
    0.00 :	  67582d:       f3 48 0f 2a c0          cvtsi2ss %rax,%xmm0
    0.00 :	  675832:       89 d0                   mov    %edx,%eax
    0.00 :	  675834:       f3 48 0f 2a c8          cvtsi2ss %rax,%xmm1
    0.00 :	  675839:       f3 0f 10 15 5f 2e 4f    movss  0x4f2e5f(%rip),%xmm2        # b686a0 <smoothed_density.17634>
    0.00 :	  675840:       00 
    0.00 :	  675841:       f3 0f 5e c1             divss  %xmm1,%xmm0
    0.00 :	  675845:       f3 0f 5c c2             subss  %xmm2,%xmm0
    0.00 :	  675849:       f3 0f 59 05 93 48 23    mulss  0x234893(%rip),%xmm0        # 8aa0e4 <__func__.17063+0x11>
    0.00 :	  675850:       00 
    0.00 :	  675851:       f3 0f 58 d0             addss  %xmm0,%xmm2
    0.00 :	  675855:       f3 0f 11 15 43 2e 4f    movss  %xmm2,0x4f2e43(%rip)        # b686a0 <smoothed_density.17634>
    0.00 :	  67585c:       00 
         :	                         scans_per_alloc, smoothed_density);
         :	#endif
         :	        }
         :
         :	        /* Return true if OK to hibernate */
         :	        return (bufs_to_lap == 0 && recent_alloc == 0);
    0.00 :	  67585d:       44 8b 55 c4             mov    -0x3c(%rbp),%r10d
    0.00 :	  675861:       31 c0                   xor    %eax,%eax
    0.00 :	  675863:       45 85 d2                test   %r10d,%r10d
    0.00 :	  675866:       75 0a                   jne    675872 <BgBufferSync+0x182>
    0.00 :	  675868:       44 8b 4d d0             mov    -0x30(%rbp),%r9d
    0.00 :	  67586c:       45 85 c9                test   %r9d,%r9d
    0.00 :	  67586f:       0f 94 c0                sete   %al
         :	}
    0.00 :	  675872:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  675876:       5b                      pop    %rbx
    0.00 :	  675877:       41 5c                   pop    %r12
    0.00 :	  675879:       41 5d                   pop    %r13
    0.00 :	  67587b:       41 5e                   pop    %r14
    0.00 :	  67587d:       41 5f                   pop    %r15
    0.00 :	  67587f:       c9                      leaveq 
    0.00 :	  675880:       c3                      retq   
    0.00 :	  675881:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * weird-looking coding of xxx_passes comparisons are to avoid bogus
         :	         * behavior when the passes counts wrap around.
         :	         */
         :	        if (saved_info_valid)
         :	        {
         :	                int32           passes_delta = strategy_passes - prev_strategy_passes;
    0.00 :	  675888:       44 8b 45 d4             mov    -0x2c(%rbp),%r8d
         :
         :	                strategy_delta = strategy_buf_id - prev_strategy_buf_id;
    0.00 :	  67588c:       89 c1                   mov    %eax,%ecx
         :	                strategy_delta += (long) passes_delta *NBuffers;
    0.00 :	  67588e:       8b 3d 8c 32 4f 00       mov    0x4f328c(%rip),%edi        # b68b20 <NBuffers>
         :	         */
         :	        if (saved_info_valid)
         :	        {
         :	                int32           passes_delta = strategy_passes - prev_strategy_passes;
         :
         :	                strategy_delta = strategy_buf_id - prev_strategy_buf_id;
    0.00 :	  675894:       2b 0d 06 78 50 00       sub    0x507806(%rip),%ecx        # b7d0a0 <prev_strategy_buf_id.17629>
         :	                strategy_delta += (long) passes_delta *NBuffers;
    0.00 :	  67589a:       44 89 c0                mov    %r8d,%eax
    0.00 :	  67589d:       2b 05 f9 77 50 00       sub    0x5077f9(%rip),%eax        # b7d09c <prev_strategy_passes.17630>
    0.00 :	  6758a3:       48 63 d7                movslq %edi,%rdx
    0.00 :	  6758a6:       89 7d c4                mov    %edi,-0x3c(%rbp)
         :	         */
         :	        if (saved_info_valid)
         :	        {
         :	                int32           passes_delta = strategy_passes - prev_strategy_passes;
         :
         :	                strategy_delta = strategy_buf_id - prev_strategy_buf_id;
    0.00 :	  6758a9:       48 63 c9                movslq %ecx,%rcx
         :	                strategy_delta += (long) passes_delta *NBuffers;
    0.00 :	  6758ac:       48 98                   cltq   
    0.00 :	  6758ae:       48 0f af c2             imul   %rdx,%rax
         :
         :	                Assert(strategy_delta >= 0);
         :
         :	                if ((int32) (next_passes - strategy_passes) > 0)
    0.00 :	  6758b2:       8b 15 dc 77 50 00       mov    0x5077dc(%rip),%edx        # b7d094 <next_passes.17632>
         :	        if (saved_info_valid)
         :	        {
         :	                int32           passes_delta = strategy_passes - prev_strategy_passes;
         :
         :	                strategy_delta = strategy_buf_id - prev_strategy_buf_id;
         :	                strategy_delta += (long) passes_delta *NBuffers;
    0.00 :	  6758b8:       48 01 c1                add    %rax,%rcx
         :
         :	                Assert(strategy_delta >= 0);
         :
         :	                if ((int32) (next_passes - strategy_passes) > 0)
    0.00 :	  6758bb:       89 d0                   mov    %edx,%eax
    0.00 :	  6758bd:       44 29 c0                sub    %r8d,%eax
    0.00 :	  6758c0:       85 c0                   test   %eax,%eax
    0.00 :	  6758c2:       0f 8e 23 01 00 00       jle    6759eb <BgBufferSync+0x2fb>
         :	                {
         :	                        /* we're one pass ahead of the strategy point */
         :	                        bufs_to_lap = strategy_buf_id - next_to_clean;
    0.00 :	  6758c8:       89 f0                   mov    %esi,%eax
    0.00 :	  6758ca:       2b 05 c8 77 50 00       sub    0x5077c8(%rip),%eax        # b7d098 <next_to_clean.17631>
    0.00 :	  6758d0:       89 45 c4                mov    %eax,-0x3c(%rbp)
         :	         * Compute how many buffers had to be scanned for each new allocation, ie,
         :	         * 1/density of reusable buffers, and track a moving average of that.
         :	         *
         :	         * If the strategy point didn't move, we don't update the density estimate
         :	         */
         :	        if (strategy_delta > 0 && recent_alloc > 0)
    0.00 :	  6758d3:       48 85 c9                test   %rcx,%rcx
         :	                next_passes = strategy_passes;
         :	                bufs_to_lap = NBuffers;
         :	        }
         :
         :	        /* Update saved info for next time */
         :	        prev_strategy_buf_id = strategy_buf_id;
    0.00 :	  6758d6:       89 35 c4 77 50 00       mov    %esi,0x5077c4(%rip)        # b7d0a0 <prev_strategy_buf_id.17629>
         :	        prev_strategy_passes = strategy_passes;
    0.00 :	  6758dc:       44 89 05 b9 77 50 00    mov    %r8d,0x5077b9(%rip)        # b7d09c <prev_strategy_passes.17630>
         :	        saved_info_valid = true;
    0.00 :	  6758e3:       c6 05 ba 77 50 00 01    movb   $0x1,0x5077ba(%rip)        # b7d0a4 <saved_info_valid.17628>
         :	         * Compute how many buffers had to be scanned for each new allocation, ie,
         :	         * 1/density of reusable buffers, and track a moving average of that.
         :	         *
         :	         * If the strategy point didn't move, we don't update the density estimate
         :	         */
         :	        if (strategy_delta > 0 && recent_alloc > 0)
    0.00 :	  6758ea:       0f 8e 2c 01 00 00       jle    675a1c <BgBufferSync+0x32c>
    0.00 :	  6758f0:       45 85 d2                test   %r10d,%r10d
    0.00 :	  6758f3:       0f 57 d2                xorps  %xmm2,%xmm2
    0.00 :	  6758f6:       0f 84 6f fe ff ff       je     67576b <BgBufferSync+0x7b>
         :	        {
         :	                scans_per_alloc = (float) strategy_delta / (float) recent_alloc;
    0.00 :	  6758fc:       f3 49 0f 2a d1          cvtsi2ss %r9,%xmm2
         :	                smoothed_density += (scans_per_alloc - smoothed_density) /
    0.00 :	  675901:       f3 48 0f 2a c1          cvtsi2ss %rcx,%xmm0
    0.00 :	  675906:       f3 0f 10 0d 92 2d 4f    movss  0x4f2d92(%rip),%xmm1        # b686a0 <smoothed_density.17634>
    0.00 :	  67590d:       00 
    0.00 :	  67590e:       f3 0f 5e c2             divss  %xmm2,%xmm0
    0.00 :	  675912:       f3 0f 5c c1             subss  %xmm1,%xmm0
    0.00 :	  675916:       f3 0f 59 05 c6 47 23    mulss  0x2347c6(%rip),%xmm0        # 8aa0e4 <__func__.17063+0x11>
    0.00 :	  67591d:       00 
    0.00 :	  67591e:       f3 0f 58 c8             addss  %xmm0,%xmm1
    0.00 :	  675922:       f3 0f 11 0d 76 2d 4f    movss  %xmm1,0x4f2d76(%rip)        # b686a0 <smoothed_density.17634>
    0.00 :	  675929:       00 
    0.00 :	  67592a:       e9 3c fe ff ff          jmpq   67576b <BgBufferSync+0x7b>
    0.00 :	  67592f:       90                      nop
         :	        reusable_buffers = reusable_buffers_est;
         :
         :	        /* Execute the LRU scan */
         :	        while (num_to_scan > 0 && reusable_buffers < upcoming_alloc_est)
         :	        {
         :	                int                     buffer_state = SyncOneBuffer(next_to_clean, true);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1779
  100.00 :	  675930:       8b 3d 62 77 50 00       mov    0x507762(%rip),%edi        # b7d098 <next_to_clean.17631>
    0.00 :	  675936:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67593b:       e8 20 f9 ff ff          callq  675260 <SyncOneBuffer>
    0.00 :	  675940:       89 c2                   mov    %eax,%edx
         :
         :	                if (++next_to_clean >= NBuffers)
    0.00 :	  675942:       8b 05 50 77 50 00       mov    0x507750(%rip),%eax        # b7d098 <next_to_clean.17631>
    0.00 :	  675948:       83 c0 01                add    $0x1,%eax
    0.00 :	  67594b:       3b 05 cf 31 4f 00       cmp    0x4f31cf(%rip),%eax        # b68b20 <NBuffers>
    0.00 :	  675951:       89 05 41 77 50 00       mov    %eax,0x507741(%rip)        # b7d098 <next_to_clean.17631>
    0.00 :	  675957:       7c 11                   jl     67596a <BgBufferSync+0x27a>
         :	                {
         :	                        next_to_clean = 0;
         :	                        next_passes++;
    0.00 :	  675959:       83 05 34 77 50 00 01    addl   $0x1,0x507734(%rip)        # b7d094 <next_passes.17632>
         :	        {
         :	                int                     buffer_state = SyncOneBuffer(next_to_clean, true);
         :
         :	                if (++next_to_clean >= NBuffers)
         :	                {
         :	                        next_to_clean = 0;
    0.00 :	  675960:       c7 05 2e 77 50 00 00    movl   $0x0,0x50772e(%rip)        # b7d098 <next_to_clean.17631>
    0.00 :	  675967:       00 00 00 
         :	                        next_passes++;
         :	                }
         :	                num_to_scan--;
    0.00 :	  67596a:       83 eb 01                sub    $0x1,%ebx
         :
         :	                if (buffer_state & BUF_WRITTEN)
    0.00 :	  67596d:       f6 c2 01                test   $0x1,%dl
    0.00 :	  675970:       74 26                   je     675998 <BgBufferSync+0x2a8>
         :	                {
         :	                        reusable_buffers++;
    0.00 :	  675972:       41 83 c4 01             add    $0x1,%r12d
         :	                        if (++num_written >= bgwriter_lru_maxpages)
    0.00 :	  675976:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  67597a:       44 3b 2d 0f 2d 4f 00    cmp    0x4f2d0f(%rip),%r13d        # b68690 <bgwriter_lru_maxpages>
    0.00 :	  675981:       0f 8c 79 fe ff ff       jl     675800 <BgBufferSync+0x110>
         :	                        {
         :	                                BgWriterStats.m_maxwritten_clean++;
    0.00 :	  675987:       48 83 05 d9 a0 54 00    addq   $0x1,0x54a0d9(%rip)        # bbfa68 <BgWriterStats+0x28>
    0.00 :	  67598e:       01 
         :	                                break;
    0.00 :	  67598f:       e9 79 fe ff ff          jmpq   67580d <BgBufferSync+0x11d>
    0.00 :	  675994:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        }
         :	                }
         :	                else if (buffer_state & BUF_REUSABLE)
    0.00 :	  675998:       83 e2 02                and    $0x2,%edx
         :	                        reusable_buffers++;
    0.00 :	  67599b:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  67599e:       41 83 dc ff             sbb    $0xffffffff,%r12d
    0.00 :	  6759a2:       e9 59 fe ff ff          jmpq   675800 <BgBufferSync+0x110>
    0.00 :	  6759a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6759ae:       00 00 
         :	         * immediately follow any increase.
         :	         */
         :	        if (smoothed_alloc <= (float) recent_alloc)
         :	                smoothed_alloc = recent_alloc;
         :	        else
         :	                smoothed_alloc += ((float) recent_alloc - smoothed_alloc) /
    0.00 :	  6759b0:       f3 0f 5c d0             subss  %xmm0,%xmm2
    0.00 :	  6759b4:       f3 0f 59 15 28 47 23    mulss  0x234728(%rip),%xmm2        # 8aa0e4 <__func__.17063+0x11>
    0.00 :	  6759bb:       00 
    0.00 :	  6759bc:       f3 0f 58 c2             addss  %xmm2,%xmm0
    0.00 :	  6759c0:       f3 0f 11 05 c8 76 50    movss  %xmm0,0x5076c8(%rip)        # b7d090 <smoothed_alloc.17633>
    0.00 :	  6759c7:       00 
    0.00 :	  6759c8:       e9 cd fd ff ff          jmpq   67579a <BgBufferSync+0xaa>
    0.00 :	  6759cd:       0f 1f 00                nopl   (%rax)
         :	         * stuff.  We mark the saved state invalid so that we can recover sanely
         :	         * if LRU scan is turned back on later.
         :	         */
         :	        if (bgwriter_lru_maxpages <= 0)
         :	        {
         :	                saved_info_valid = false;
    0.00 :	  6759d0:       c6 05 cd 76 50 00 00    movb   $0x0,0x5076cd(%rip)        # b7d0a4 <saved_info_valid.17628>
         :	#endif
         :	        }
         :
         :	        /* Return true if OK to hibernate */
         :	        return (bufs_to_lap == 0 && recent_alloc == 0);
         :	}
    0.00 :	  6759d7:       48 83 c4 18             add    $0x18,%rsp
         :	         * stuff.  We mark the saved state invalid so that we can recover sanely
         :	         * if LRU scan is turned back on later.
         :	         */
         :	        if (bgwriter_lru_maxpages <= 0)
         :	        {
         :	                saved_info_valid = false;
    0.00 :	  6759db:       b8 01 00 00 00          mov    $0x1,%eax
         :	#endif
         :	        }
         :
         :	        /* Return true if OK to hibernate */
         :	        return (bufs_to_lap == 0 && recent_alloc == 0);
         :	}
    0.00 :	  6759e0:       5b                      pop    %rbx
    0.00 :	  6759e1:       41 5c                   pop    %r12
    0.00 :	  6759e3:       41 5d                   pop    %r13
    0.00 :	  6759e5:       41 5e                   pop    %r14
    0.00 :	  6759e7:       41 5f                   pop    %r15
    0.00 :	  6759e9:       c9                      leaveq 
    0.00 :	  6759ea:       c3                      retq   
         :	                                 next_passes, next_to_clean,
         :	                                 strategy_passes, strategy_buf_id,
         :	                                 strategy_delta, bufs_to_lap);
         :	#endif
         :	                }
         :	                else if (next_passes == strategy_passes &&
    0.00 :	  6759eb:       41 39 d0                cmp    %edx,%r8d
    0.00 :	  6759ee:       74 12                   je     675a02 <BgBufferSync+0x312>
         :	                        elog(DEBUG2, "bgwriter behind: bgw %u-%u strategy %u-%u delta=%ld",
         :	                                 next_passes, next_to_clean,
         :	                                 strategy_passes, strategy_buf_id,
         :	                                 strategy_delta);
         :	#endif
         :	                        next_to_clean = strategy_buf_id;
    0.00 :	  6759f0:       89 35 a2 76 50 00       mov    %esi,0x5076a2(%rip)        # b7d098 <next_to_clean.17631>
         :	                        next_passes = strategy_passes;
    0.00 :	  6759f6:       44 89 05 97 76 50 00    mov    %r8d,0x507697(%rip)        # b7d094 <next_passes.17632>
    0.00 :	  6759fd:       e9 d1 fe ff ff          jmpq   6758d3 <BgBufferSync+0x1e3>
         :	                                 next_passes, next_to_clean,
         :	                                 strategy_passes, strategy_buf_id,
         :	                                 strategy_delta, bufs_to_lap);
         :	#endif
         :	                }
         :	                else if (next_passes == strategy_passes &&
    0.00 :	  675a02:       8b 05 90 76 50 00       mov    0x507690(%rip),%eax        # b7d098 <next_to_clean.17631>
    0.00 :	  675a08:       39 c6                   cmp    %eax,%esi
    0.00 :	  675a0a:       7f e4                   jg     6759f0 <BgBufferSync+0x300>
         :	                                 next_to_clean >= strategy_buf_id)
         :	                {
         :	                        /* on same pass, but ahead or at least not behind */
         :	                        bufs_to_lap = NBuffers - (next_to_clean - strategy_buf_id);
    0.00 :	  675a0c:       89 fa                   mov    %edi,%edx
    0.00 :	  675a0e:       29 c2                   sub    %eax,%edx
    0.00 :	  675a10:       89 d0                   mov    %edx,%eax
    0.00 :	  675a12:       01 f0                   add    %esi,%eax
    0.00 :	  675a14:       89 45 c4                mov    %eax,-0x3c(%rbp)
         :	                                 next_passes, next_to_clean,
         :	                                 strategy_passes, strategy_buf_id,
         :	                                 strategy_delta, bufs_to_lap);
         :	#endif
         :	                }
         :	                else if (next_passes == strategy_passes &&
    0.00 :	  675a17:       e9 b7 fe ff ff          jmpq   6758d3 <BgBufferSync+0x1e3>
         :	         * Compute how many buffers had to be scanned for each new allocation, ie,
         :	         * 1/density of reusable buffers, and track a moving average of that.
         :	         *
         :	         * If the strategy point didn't move, we don't update the density estimate
         :	         */
         :	        if (strategy_delta > 0 && recent_alloc > 0)
    0.00 :	  675a1c:       f3 49 0f 2a d1          cvtsi2ss %r9,%xmm2
    0.00 :	  675a21:       e9 45 fd ff ff          jmpq   67576b <BgBufferSync+0x7b>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:662
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000698d90 <mdprefetch>:
         :	/*
         :	 *      mdprefetch() -- Initiate asynchronous read of the specified block of a relation
         :	 */
         :	void
         :	mdprefetch(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum)
         :	{
    0.00 :	  698d90:       55                      push   %rbp
         :	#ifdef USE_PREFETCH
         :	        off_t           seekpos;
         :	        MdfdVec    *v;
         :
         :	        v = _mdfd_getseg(reln, forknum, blocknum, false, EXTENSION_FAIL);
    0.00 :	  698d91:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  698d94:       31 c9                   xor    %ecx,%ecx
         :	/*
         :	 *      mdprefetch() -- Initiate asynchronous read of the specified block of a relation
         :	 */
         :	void
         :	mdprefetch(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum)
         :	{
    0.00 :	  698d96:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  698d99:       53                      push   %rbx
    0.00 :	  698d9a:       89 d3                   mov    %edx,%ebx
    0.00 :	  698d9c:       48 83 ec 08             sub    $0x8,%rsp
         :	#ifdef USE_PREFETCH
         :	        off_t           seekpos;
         :	        MdfdVec    *v;
         :
         :	        v = _mdfd_getseg(reln, forknum, blocknum, false, EXTENSION_FAIL);
    0.00 :	  698da0:       e8 2b f6 ff ff          callq  6983d0 <_mdfd_getseg>
         :
         :	        seekpos = (off_t) BLCKSZ *(blocknum % ((BlockNumber) RELSEG_SIZE));
         :
         :	        Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
         :
         :	        (void) FilePrefetch(v->mdfd_vfd, seekpos, BLCKSZ);
    0.00 :	  698da5:       48 89 de                mov    %rbx,%rsi
    0.00 :	  698da8:       8b 38                   mov    (%rax),%edi
         :	#endif   /* USE_PREFETCH */
         :	}
    0.00 :	  698daa:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  698dae:       5b                      pop    %rbx
    0.00 :	  698daf:       c9                      leaveq 
         :
         :	        seekpos = (off_t) BLCKSZ *(blocknum % ((BlockNumber) RELSEG_SIZE));
         :
         :	        Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
         :
         :	        (void) FilePrefetch(v->mdfd_vfd, seekpos, BLCKSZ);
    0.00 :	  698db0:       81 e6 ff ff 01 00       and    $0x1ffff,%esi
    0.00 :	  698db6:       48 c1 e6 0d             shl    $0xd,%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:662
  100.00 :	  698dba:       ba 00 20 00 00          mov    $0x2000,%edx
    0.00 :	  698dbf:       e9 cc 10 fe ff          jmpq   679e90 <FilePrefetch>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:721
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000758230 <bpchareq>:
         :	 * need to be so careful.
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  758230:       55                      push   %rbp
    0.00 :	  758231:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  758234:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  758238:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  75823c:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  758240:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  758244:       49 89 fd                mov    %rdi,%r13
    0.00 :	  758247:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  75824b:       48 83 ec 30             sub    $0x30,%rsp
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  75824f:       48 8b 7f 20             mov    0x20(%rdi),%rdi
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  758253:       45 31 f6                xor    %r14d,%r14d
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  758256:       e8 85 6a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75825b:       49 8b 7d 28             mov    0x28(%r13),%rdi
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  75825f:       49 89 c4                mov    %rax,%r12
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  758262:       e8 79 6a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  758267:       4c 89 e7                mov    %r12,%rdi
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75826a:       48 89 c3                mov    %rax,%rbx
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  75826d:       e8 1e fb ff ff          callq  757d90 <bcTruelen>
         :	        len2 = bcTruelen(arg2);
    0.00 :	  758272:       48 89 df                mov    %rbx,%rdi
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  758275:       41 89 c7                mov    %eax,%r15d
         :	        len2 = bcTruelen(arg2);
    0.00 :	  758278:       e8 13 fb ff ff          callq  757d90 <bcTruelen>
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  75827d:       41 39 c7                cmp    %eax,%r15d
    0.00 :	  758280:       74 3e                   je     7582c0 <bpchareq+0x90>
         :	                result = false;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);
         :
         :	        PG_FREE_IF_COPY(arg1, 0);
    0.00 :	  758282:       4d 3b 65 20             cmp    0x20(%r13),%r12
    0.00 :	  758286:       74 0d                   je     758295 <bpchareq+0x65>
    0.00 :	  758288:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75828b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  758290:       e8 eb 08 04 00          callq  798b80 <pfree>
         :	        PG_FREE_IF_COPY(arg2, 1);
    0.00 :	  758295:       49 3b 5d 28             cmp    0x28(%r13),%rbx
    0.00 :	  758299:       74 08                   je     7582a3 <bpchareq+0x73>
    0.00 :	  75829b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  75829e:       e8 dd 08 04 00          callq  798b80 <pfree>
         :
         :	        PG_RETURN_BOOL(result);
         :	}
    0.00 :	  7582a3:       4c 89 f0                mov    %r14,%rax
    0.00 :	  7582a6:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  7582aa:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  7582ae:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  7582b2:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  7582b6:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  7582ba:       c9                      leaveq 
    0.00 :	  7582bb:       c3                      retq   
    0.00 :	  7582bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
         :	                result = false;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);
    0.00 :	  7582c0:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  7582c3:       48 8d 43 04             lea    0x4(%rbx),%rax
    0.00 :	  7582c7:       48 8d 7b 01             lea    0x1(%rbx),%rdi
    0.00 :	  7582cb:       49 8d 74 24 01          lea    0x1(%r12),%rsi
    0.00 :	  7582d0:       49 63 cf                movslq %r15d,%rcx
    0.00 :	  7582d3:       48 0f 44 f8             cmove  %rax,%rdi
    0.00 :	  7582d7:       41 f6 04 24 01          testb  $0x1,(%r12)
    0.00 :	  7582dc:       49 8d 44 24 04          lea    0x4(%r12),%rax
    0.00 :	  7582e1:       48 0f 44 f0             cmove  %rax,%rsi
    0.00 :	  7582e5:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  7582e8:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:721
  100.00 :	  7582ea:       0f 97 c2                seta   %dl
    0.00 :	  7582ed:       0f 92 c0                setb   %al
    0.00 :	  7582f0:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  7582f3:       38 c2                   cmp    %al,%dl
    0.00 :	  7582f5:       41 0f 94 c6             sete   %r14b
    0.00 :	  7582f9:       eb 87                   jmp    758282 <bpchareq+0x52>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:855
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000784050 <hash_search_with_hash_value>:
         :	hash_search_with_hash_value(HTAB *hashp,
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
    0.00 :	  784050:       55                      push   %rbp
    0.00 :	  784051:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  784054:       41 57                   push   %r15
    0.00 :	  784056:       41 89 d7                mov    %edx,%r15d
    0.00 :	  784059:       41 56                   push   %r14
    0.00 :	  78405b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  78405e:       41 55                   push   %r13
    0.00 :	  784060:       41 54                   push   %r12
    0.00 :	  784062:       53                      push   %rbx
    0.00 :	  784063:       48 83 ec 68             sub    $0x68,%rsp
    0.00 :	  784067:       89 8d 7c ff ff ff       mov    %ecx,-0x84(%rbp)
    0.00 :	  78406d:       48 89 75 80             mov    %rsi,-0x80(%rbp)
    0.00 :	  784071:       4c 89 85 70 ff ff ff    mov    %r8,-0x90(%rbp)
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784078:       48 8b 07                mov    (%rdi),%rax
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  78407b:       83 f9 03                cmp    $0x3,%ecx
    0.00 :	  78407e:       0f 94 45 8f             sete   -0x71(%rbp)
    0.00 :	  784082:       83 e9 01                sub    $0x1,%ecx
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784085:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  784089:       0f 84 d9 00 00 00       je     784168 <hash_search_with_hash_value+0x118>
    0.00 :	  78408f:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  784093:       0f 85 cf 00 00 00       jne    784168 <hash_search_with_hash_value+0x118>
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
         :	        *newlink = NULL;
    0.00 :	  784099:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78409c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  7840a0:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7840a4:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  7840a8:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  7840ac:       44 89 fb                mov    %r15d,%ebx
    0.00 :	  7840af:       23 5a 2c                and    0x2c(%rdx),%ebx
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7840b2:       39 f3                   cmp    %esi,%ebx
    0.00 :	  7840b4:       76 03                   jbe    7840b9 <hash_search_with_hash_value+0x69>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7840b6:       23 5a 30                and    0x30(%rdx),%ebx
         :	        bucket = calc_bucket(hctl, hashvalue);
         :
         :	        segment_num = bucket >> hashp->sshift;
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
    0.00 :	  7840b9:       89 d8                   mov    %ebx,%eax
    0.00 :	  7840bb:       49 8b 56 08             mov    0x8(%r14),%rdx
    0.00 :	  7840bf:       d3 e8                   shr    %cl,%eax
    0.00 :	  7840c1:       89 c0                   mov    %eax,%eax
    0.00 :	  7840c3:       4c 8b 24 c2             mov    (%rdx,%rax,8),%r12
         :
         :	        if (segp == NULL)
    0.00 :	  7840c7:       4d 85 e4                test   %r12,%r12
    0.00 :	  7840ca:       0f 84 b7 02 00 00       je     784387 <hash_search_with_hash_value+0x337>
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d0:       89 d8                   mov    %ebx,%eax
    0.00 :	  7840d2:       44 21 e8                and    %r13d,%eax
         :	        currBucket = *prevBucketPtr;
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
    0.00 :	  7840d5:       4d 8b 6e 18             mov    0x18(%r14),%r13
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d9:       4d 8d 24 c4             lea    (%r12,%rax,8),%r12
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
    0.00 :	  7840dd:       49 8b 46 48             mov    0x48(%r14),%rax
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
         :	        currBucket = *prevBucketPtr;
    0.00 :	  7840e1:       49 8b 1c 24             mov    (%r12),%rbx
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
    0.00 :	  7840e5:       48 89 45 98             mov    %rax,-0x68(%rbp)
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840e9:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840ec:       75 0d                   jne    7840fb <hash_search_with_hash_value+0xab>
    0.00 :	  7840ee:       eb 28                   jmp    784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
         :	                        match(ELEMENTKEY(currBucket), keyPtr, keysize) == 0)
         :	                        break;
         :	                prevBucketPtr = &(currBucket->link);
    0.00 :	  7840f0:       49 89 dc                mov    %rbx,%r12
         :	                currBucket = *prevBucketPtr;
    0.00 :	  7840f3:       48 8b 1b                mov    (%rbx),%rbx
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840f6:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840f9:       74 1d                   je     784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
    0.00 :	  7840fb:       44 39 7b 08             cmp    %r15d,0x8(%rbx)
    0.00 :	  7840ff:       90                      nop
    0.00 :	  784100:       75 ee                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784102:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  784106:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  78410a:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78410e:       41 ff d5                callq  *%r13
    0.00 :	  784111:       85 c0                   test   %eax,%eax
    0.00 :	  784113:       75 db                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784115:       0f 1f 00                nopl   (%rax)
         :	                hash_collisions++;
         :	                hctl->collisions++;
         :	#endif
         :	        }
         :
         :	        if (foundPtr)
    0.00 :	  784118:       48 83 bd 70 ff ff ff    cmpq   $0x0,-0x90(%rbp)
    0.00 :	  78411f:       00 
    0.00 :	  784120:       74 0d                   je     78412f <hash_search_with_hash_value+0xdf>
         :	                *foundPtr = (bool) (currBucket != NULL);
    0.00 :	  784122:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  784129:       48 85 db                test   %rbx,%rbx
    0.00 :	  78412c:       0f 95 02                setne  (%rdx)
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  78412f:       83 bd 7c ff ff ff 01    cmpl   $0x1,-0x84(%rbp)
    0.00 :	  784136:       0f 84 5c 01 00 00       je     784298 <hash_search_with_hash_value+0x248>
    0.00 :	  78413c:       0f 83 ee 00 00 00       jae    784230 <hash_search_with_hash_value+0x1e0>
         :	        {
         :	                case HASH_FIND:
         :	                        if (currBucket != NULL)
    0.00 :	  784142:       48 85 db                test   %rbx,%rbx
    0.00 :	  784145:       0f 84 35 02 00 00       je     784380 <hash_search_with_hash_value+0x330>
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
    0.00 :	  78414b:       48 83 c3 10             add    $0x10,%rbx
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  78414f:       48 83 c4 68             add    $0x68,%rsp
    0.00 :	  784153:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784156:       5b                      pop    %rbx
    0.00 :	  784157:       41 5c                   pop    %r12
    0.00 :	  784159:       41 5d                   pop    %r13
    0.00 :	  78415b:       41 5e                   pop    %r14
    0.00 :	  78415d:       41 5f                   pop    %r15
    0.00 :	  78415f:       c9                      leaveq 
    0.00 :	  784160:       c3                      retq   
    0.00 :	  784161:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784168:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78416c:       48 83 7a 48 00          cmpq   $0x0,0x48(%rdx)
    0.00 :	  784171:       0f 85 09 01 00 00       jne    784280 <hash_search_with_hash_value+0x230>
    0.00 :	  784177:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  78417c:       0f 85 e6 01 00 00       jne    784368 <hash_search_with_hash_value+0x318>
    0.00 :	  784182:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784186:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78418a:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78418d:       8d 56 01                lea    0x1(%rsi),%edx
    0.00 :	  784190:       41 89 f0                mov    %esi,%r8d
    0.00 :	  784193:       89 55 d4                mov    %edx,-0x2c(%rbp)
    0.00 :	  784196:       41 89 d4                mov    %edx,%r12d
    0.00 :	  784199:       48 8b 50 08             mov    0x8(%rax),%rdx
    0.00 :	  78419d:       48 89 d0                mov    %rdx,%rax
    0.00 :	  7841a0:       48 c1 fa 3f             sar    $0x3f,%rdx
    0.00 :	  7841a4:       49 f7 fc                idiv   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:855
  100.00 :	  7841a7:       48 3b 43 50             cmp    0x50(%rbx),%rax
    0.00 :	  7841ab:       0f 8c eb fe ff ff       jl     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841b1:       8b 3d 09 5a 43 00       mov    0x435a09(%rip),%edi        # bb9bc0 <num_seq_scans>
    0.00 :	  7841b7:       85 ff                   test   %edi,%edi
    0.00 :	  7841b9:       7e 2c                   jle    7841e7 <hash_search_with_hash_value+0x197>
         :	        {
         :	                if (seq_scan_tables[i] == hashp)
    0.00 :	  7841bb:       31 d2                   xor    %edx,%edx
    0.00 :	  7841bd:       4c 3b 35 1c 5a 43 00    cmp    0x435a1c(%rip),%r14        # bb9be0 <seq_scan_tables>
    0.00 :	  7841c4:       b9 e8 9b bb 00          mov    $0xbb9be8,%ecx
    0.00 :	  7841c9:       75 15                   jne    7841e0 <hash_search_with_hash_value+0x190>
    0.00 :	  7841cb:       e9 cc fe ff ff          jmpq   78409c <hash_search_with_hash_value+0x4c>
    0.00 :	  7841d0:       48 8b 01                mov    (%rcx),%rax
    0.00 :	  7841d3:       48 83 c1 08             add    $0x8,%rcx
    0.00 :	  7841d7:       49 39 c6                cmp    %rax,%r14
    0.00 :	  7841da:       0f 84 bc fe ff ff       je     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841e0:       83 c2 01                add    $0x1,%edx
    0.00 :	  7841e3:       39 fa                   cmp    %edi,%edx
    0.00 :	  7841e5:       7c e9                   jl     7841d0 <hash_search_with_hash_value+0x180>
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841e7:       49 8b 46 50             mov    0x50(%r14),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841eb:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7841ef:       4c 89 e3                mov    %r12,%rbx
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841f2:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  7841f6:       48 8b 45 90             mov    -0x70(%rbp),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841fa:       48 d3 fb                sar    %cl,%rbx
    0.00 :	  7841fd:       48 89 5d c0             mov    %rbx,-0x40(%rbp)
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784201:       48 3b 58 20             cmp    0x20(%rax),%rbx
    0.00 :	  784205:       0f 8c 05 02 00 00       jl     784410 <hash_search_with_hash_value+0x3c0>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
    0.00 :	  78420b:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  78420f:       48 8b 58 18             mov    0x18(%rax),%rbx
    0.00 :	  784213:       48 39 5d c0             cmp    %rbx,-0x40(%rbp)
    0.00 :	  784217:       0f 8c 1d 03 00 00       jl     78453a <hash_search_with_hash_value+0x4ea>
         :	        HASHSEGMENT *old_p;
         :	        long            new_dsize;
         :	        long            old_dirsize;
         :	        long            new_dirsize;
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
    0.00 :	  78421d:       48 83 78 58 ff          cmpq   $0xffffffffffffffff,0x58(%rax)
    0.00 :	  784222:       0f 84 4a 03 00 00       je     784572 <hash_search_with_hash_value+0x522>
         :	                hashp->dir = p;
         :	                hashp->hctl->dsize = new_dsize;
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784228:       44 89 c6                mov    %r8d,%esi
    0.00 :	  78422b:       e9 78 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                *foundPtr = (bool) (currBucket != NULL);
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  784230:       83 bd 7c ff ff ff 02    cmpl   $0x2,-0x84(%rbp)
    0.00 :	  784237:       0f 84 d6 00 00 00       je     784313 <hash_search_with_hash_value+0x2c3>
    0.00 :	  78423d:       83 bd 7c ff ff ff 03    cmpl   $0x3,-0x84(%rbp)
    0.00 :	  784244:       74 52                   je     784298 <hash_search_with_hash_value+0x248>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784246:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  78424b:       be df 03 00 00          mov    $0x3df,%esi
    0.00 :	  784250:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  784255:       e8 c6 71 ff ff          callq  77b420 <elog_start>
    0.00 :	  78425a:       8b 95 7c ff ff ff       mov    -0x84(%rbp),%edx
    0.00 :	  784260:       be f0 5a 8d 00          mov    $0x8d5af0,%esi
    0.00 :	  784265:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78426a:       31 c0                   xor    %eax,%eax
    0.00 :	  78426c:       e8 bf 6f ff ff          callq  77b230 <elog_finish>
    0.00 :	  784271:       e8 5a 52 ce ff          callq  4694d0 <abort@plt>
    0.00 :	  784276:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  78427d:       00 00 00 
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784280:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784284:       8b 72 28                mov    0x28(%rdx),%esi
    0.00 :	  784287:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  78428b:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78428f:       e9 14 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
    0.00 :	  784294:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        Assert(hashp->alloc != DynaHashAlloc);
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
    0.00 :	  784298:       48 85 db                test   %rbx,%rbx
    0.00 :	  78429b:       0f 85 aa fe ff ff       jne    78414b <hash_search_with_hash_value+0xfb>
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
    0.00 :	  7842a1:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  7842a6:       0f 85 a3 03 00 00       jne    78464f <hash_search_with_hash_value+0x5ff>
         :	 */
         :	static HASHBUCKET
         :	get_hash_entry(HTAB *hashp)
         :	{
         :	        /* use volatile pointer to prevent code rearrangement */
         :	        volatile HASHHDR *hctlv = hashp->hctl;
    0.00 :	  7842ac:       49 8b 1e                mov    (%r14),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  7842af:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  7842b5:       eb 35                   jmp    7842ec <hash_search_with_hash_value+0x29c>
    0.00 :	  7842b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7842be:       00 00 
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
         :	                        SpinLockAcquire(&hctlv->mutex);
         :
         :	                /* try to get an entry from the freelist */
         :	                newElement = hctlv->freeList;
    0.00 :	  7842c0:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	                if (newElement != NULL)
    0.00 :	  7842c4:       48 85 d2                test   %rdx,%rdx
    0.00 :	  7842c7:       0f 85 04 02 00 00       jne    7844d1 <hash_search_with_hash_value+0x481>
         :	                        break;
         :
         :	                /* no free elements.  allocate another chunk of buckets */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842cd:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842d1:       48 85 c0                test   %rax,%rax
    0.00 :	  7842d4:       74 03                   je     7842d9 <hash_search_with_hash_value+0x289>
         :	                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  7842d6:       c6 03 00                movb   $0x0,(%rbx)
         :
         :	                if (!element_alloc(hashp, hctlv->nelem_alloc))
    0.00 :	  7842d9:       8b 73 6c                mov    0x6c(%rbx),%esi
    0.00 :	  7842dc:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7842df:       e8 dc fb ff ff          callq  783ec0 <element_alloc>
    0.00 :	  7842e4:       84 c0                   test   %al,%al
    0.00 :	  7842e6:       0f 84 be 00 00 00       je     7843aa <hash_search_with_hash_value+0x35a>
         :	        HASHBUCKET      newElement;
         :
         :	        for (;;)
         :	        {
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842ec:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842f0:       48 85 c0                test   %rax,%rax
    0.00 :	  7842f3:       74 cb                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842f5:       44 89 e8                mov    %r13d,%eax
    0.00 :	  7842f8:       f0 86 03                lock xchg %al,(%rbx)
         :	                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  7842fb:       84 c0                   test   %al,%al
    0.00 :	  7842fd:       74 c1                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842ff:       ba 87 04 00 00          mov    $0x487,%edx
    0.00 :	  784304:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  784309:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78430c:       e8 2f bd f0 ff          callq  690040 <s_lock>
    0.00 :	  784311:       eb ad                   jmp    7842c0 <hash_search_with_hash_value+0x270>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :	                        return NULL;
         :
         :	                case HASH_REMOVE:
         :	                        if (currBucket != NULL)
    0.00 :	  784313:       48 85 db                test   %rbx,%rbx
    0.00 :	  784316:       74 68                   je     784380 <hash_search_with_hash_value+0x330>
         :	                        {
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784318:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78431c:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784320:       48 85 c0                test   %rax,%rax
    0.00 :	  784323:       74 0c                   je     784331 <hash_search_with_hash_value+0x2e1>
    0.00 :	  784325:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  78432a:       f0 86 02                lock xchg %al,(%rdx)
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  78432d:       84 c0                   test   %al,%al
    0.00 :	  78432f:       75 64                   jne    784395 <hash_search_with_hash_value+0x345>
         :
         :	                                Assert(hctlv->nentries > 0);
         :	                                hctlv->nentries--;
    0.00 :	  784331:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784335:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  784339:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78433d:       48 89 42 08             mov    %rax,0x8(%rdx)
         :
         :	                                /* remove record from hash bucket's chain. */
         :	                                *prevBucketPtr = currBucket->link;
    0.00 :	  784341:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  784344:       49 89 04 24             mov    %rax,(%r12)
         :
         :	                                /* add the record to the freelist for this table.  */
         :	                                currBucket->link = hctlv->freeList;
    0.00 :	  784348:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  78434c:       48 89 03                mov    %rax,(%rbx)
         :	                                hctlv->freeList = currBucket;
    0.00 :	  78434f:       48 89 5a 10             mov    %rbx,0x10(%rdx)
         :
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784353:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784357:       48 85 c0                test   %rax,%rax
    0.00 :	  78435a:       0f 84 eb fd ff ff       je     78414b <hash_search_with_hash_value+0xfb>
         :	                                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  784360:       c6 02 00                movb   $0x0,(%rdx)
    0.00 :	  784363:       e9 e3 fd ff ff          jmpq   78414b <hash_search_with_hash_value+0xfb>
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784368:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78436c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784370:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784374:       8b 73 28                mov    0x28(%rbx),%esi
    0.00 :	  784377:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78437b:       e9 28 fd ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784380:       31 db                   xor    %ebx,%ebx
    0.00 :	  784382:       e9 c8 fd ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
    0.00 :	  784387:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  78438a:       e8 01 f8 ff ff          callq  783b90 <hash_corrupted>
    0.00 :	  78438f:       90                      nop
    0.00 :	  784390:       e9 3b fd ff ff          jmpq   7840d0 <hash_search_with_hash_value+0x80>
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  784395:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  784399:       ba 95 03 00 00          mov    $0x395,%edx
    0.00 :	  78439e:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843a3:       e8 98 bc f0 ff          callq  690040 <s_lock>
    0.00 :	  7843a8:       eb 87                   jmp    784331 <hash_search_with_hash_value+0x2e1>
         :
         :	                        currBucket = get_hash_entry(hashp);
         :	                        if (currBucket == NULL)
         :	                        {
         :	                                /* out of memory */
         :	                                if (action == HASH_ENTER_NULL)
    0.00 :	  7843aa:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  7843ae:       75 d0                   jne    784380 <hash_search_with_hash_value+0x330>
         :	                                        return NULL;
         :	                                /* report a generic message */
         :	                                if (hashp->isshared)
    0.00 :	  7843b0:       41 80 7e 40 00          cmpb   $0x0,0x40(%r14)
    0.00 :	  7843b5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7843b8:       0f 84 4a 02 00 00       je     784608 <hash_search_with_hash_value+0x5b8>
         :	                                        ereport(ERROR,
    0.00 :	  7843be:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7843c1:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  7843c6:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  7843cb:       ba c6 03 00 00          mov    $0x3c6,%edx
    0.00 :	  7843d0:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843d5:       e8 e6 66 ff ff          callq  77aac0 <errstart>
    0.00 :	  7843da:       84 c0                   test   %al,%al
    0.00 :	  7843dc:       bf 47 ba 8a 00          mov    $0x8aba47,%edi
    0.00 :	  7843e1:       0f 84 8a fe ff ff       je     784271 <hash_search_with_hash_value+0x221>
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  7843e7:       31 c0                   xor    %eax,%eax
    0.00 :	  7843e9:       e8 b2 84 ff ff          callq  77c8a0 <errmsg>
    0.00 :	  7843ee:       bf c5 20 00 00          mov    $0x20c5,%edi
    0.00 :	  7843f3:       89 c3                   mov    %eax,%ebx
    0.00 :	  7843f5:       e8 56 89 ff ff          callq  77cd50 <errcode>
    0.00 :	  7843fa:       89 de                   mov    %ebx,%esi
    0.00 :	  7843fc:       89 c7                   mov    %eax,%edi
    0.00 :	  7843fe:       31 c0                   xor    %eax,%eax
    0.00 :	  784400:       e8 db 61 ff ff          callq  77a5e0 <errfinish>
    0.00 :	  784405:       e9 67 fe ff ff          jmpq   784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78440a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784410:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  784413:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784417:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  78441b:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  78441f:       4d 89 e1                mov    %r12,%r9
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  784422:       89 43 28                mov    %eax,0x28(%rbx)
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  784425:       8b 43 30                mov    0x30(%rbx),%eax
    0.00 :	  784428:       49 21 c1                and    %rax,%r9
         :
         :	        /*
         :	         * If we crossed a power of 2, readjust masks.
         :	         */
         :	        if ((uint32) new_bucket > hctl->high_mask)
    0.00 :	  78442b:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  78442e:       39 45 d4                cmp    %eax,-0x2c(%rbp)
    0.00 :	  784431:       76 0c                   jbe    78443f <hash_search_with_hash_value+0x3ef>
         :	        {
         :	                hctl->low_mask = hctl->high_mask;
    0.00 :	  784433:       89 43 30                mov    %eax,0x30(%rbx)
         :	                hctl->high_mask = (uint32) new_bucket | hctl->low_mask;
    0.00 :	  784436:       09 45 d4                or     %eax,-0x2c(%rbp)
    0.00 :	  784439:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  78443c:       89 43 2c                mov    %eax,0x2c(%rbx)
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  78443f:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784443:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784447:       4c 89 ca                mov    %r9,%rdx
         :	         * that might not be true!
         :	         */
         :	        old_segnum = old_bucket >> hashp->sshift;
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
    0.00 :	  78444a:       49 8b 76 08             mov    0x8(%r14),%rsi
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78444e:       4d 21 ec                and    %r13,%r12
    0.00 :	  784451:       4a 8d 3c e5 00 00 00    lea    0x0(,%r12,8),%rdi
    0.00 :	  784458:       00 
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  784459:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78445d:       48 d3 fa                sar    %cl,%rdx
    0.00 :	  784460:       4c 21 c8                and    %r9,%rax
    0.00 :	  784463:       4c 8d 04 c5 00 00 00    lea    0x0(,%rax,8),%r8
    0.00 :	  78446a:       00 
    0.00 :	  78446b:       4c 03 04 d6             add    (%rsi,%rdx,8),%r8
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78446f:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  784473:       48 03 3c 16             add    (%rsi,%rdx,1),%rdi
         :
         :	        for (currElement = *oldlink;
    0.00 :	  784477:       49 8b 10                mov    (%r8),%rdx
         :	                 currElement != NULL;
    0.00 :	  78447a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  78447d:       75 17                   jne    784496 <hash_search_with_hash_value+0x446>
    0.00 :	  78447f:       eb 39                   jmp    7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784481:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        *oldlink = currElement;
         :	                        oldlink = &currElement->link;
         :	                }
         :	                else
         :	                {
         :	                        *newlink = currElement;
    0.00 :	  784488:       48 89 17                mov    %rdx,(%rdi)
         :	                        newlink = &currElement->link;
    0.00 :	  78448b:       48 89 d7                mov    %rdx,%rdi
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
    0.00 :	  78448e:       48 85 c9                test   %rcx,%rcx
    0.00 :	  784491:       74 27                   je     7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784493:       48 89 ca                mov    %rcx,%rdx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  784496:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
    0.00 :	  78449a:       48 8b 0a                mov    (%rdx),%rcx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  78449d:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  7844a0:       23 42 08                and    0x8(%rdx),%eax
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7844a3:       3b 43 28                cmp    0x28(%rbx),%eax
    0.00 :	  7844a6:       76 03                   jbe    7844ab <hash_search_with_hash_value+0x45b>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7844a8:       23 43 30                and    0x30(%rbx),%eax
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
         :	                if ((long) calc_bucket(hctl, currElement->hashvalue) == old_bucket)
    0.00 :	  7844ab:       89 c0                   mov    %eax,%eax
    0.00 :	  7844ad:       49 39 c1                cmp    %rax,%r9
    0.00 :	  7844b0:       75 d6                   jne    784488 <hash_search_with_hash_value+0x438>
         :	                {
         :	                        *oldlink = currElement;
    0.00 :	  7844b2:       49 89 10                mov    %rdx,(%r8)
         :	                        oldlink = &currElement->link;
    0.00 :	  7844b5:       49 89 d0                mov    %rdx,%r8
    0.00 :	  7844b8:       eb d4                   jmp    78448e <hash_search_with_hash_value+0x43e>
         :	                        *newlink = currElement;
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
    0.00 :	  7844ba:       49 c7 00 00 00 00 00    movq   $0x0,(%r8)
         :	        *newlink = NULL;
    0.00 :	  7844c1:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7844c8:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  7844cc:       e9 c8 fb ff ff          jmpq   784099 <hash_search_with_hash_value+0x49>
         :	                        return NULL;
         :	                }
         :	        }
         :
         :	        /* remove entry from freelist, bump nentries */
         :	        hctlv->freeList = newElement->link;
    0.00 :	  7844d1:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  7844d4:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	        hctlv->nentries++;
    0.00 :	  7844d8:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7844dc:       48 83 c0 01             add    $0x1,%rax
    0.00 :	  7844e0:       48 89 43 08             mov    %rax,0x8(%rbx)
         :
         :	        if (IS_PARTITIONED(hctlv))
    0.00 :	  7844e4:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7844e8:       48 85 c0                test   %rax,%rax
    0.00 :	  7844eb:       74 03                   je     7844f0 <hash_search_with_hash_value+0x4a0>
         :	                SpinLockRelease(&hctlv->mutex);
    0.00 :	  7844ed:       c6 03 00                movb   $0x0,(%rbx)
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  7844f0:       48 8d 5a 10             lea    0x10(%rdx),%rbx
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
    0.00 :	  7844f4:       49 89 14 24             mov    %rdx,(%r12)
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
    0.00 :	  7844f8:       44 89 7a 08             mov    %r15d,0x8(%rdx)
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
    0.00 :	  7844fc:       48 c7 02 00 00 00 00    movq   $0x0,(%rdx)
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  784503:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  784507:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78450b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78450e:       41 ff 56 20             callq  *0x20(%r14)
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  784512:       e9 38 fc ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  784517:       31 f6                   xor    %esi,%esi
    0.00 :	  784519:       e8 02 4f ce ff          callq  469420 <memset@plt>
         :	                hashp->dir = p;
    0.00 :	  78451e:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  784522:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
         :	                hashp->dir = p;
    0.00 :	  784526:       49 89 46 08             mov    %rax,0x8(%r14)
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  78452a:       49 8b 06                mov    (%r14),%rax
    0.00 :	  78452d:       48 89 50 18             mov    %rdx,0x18(%rax)
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784531:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  784535:       e8 46 46 01 00          callq  798b80 <pfree>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78453a:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  78453e:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  784541:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784545:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
    0.00 :	  784549:       49 03 5e 08             add    0x8(%r14),%rbx
    0.00 :	  78454d:       e8 7e fa ff ff          callq  783fd0 <seg_alloc>
    0.00 :	  784552:       48 85 c0                test   %rax,%rax
    0.00 :	  784555:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  784558:       0f 84 1f 01 00 00       je     78467d <hash_search_with_hash_value+0x62d>
         :	                        return false;
         :	                hctl->nsegs++;
    0.00 :	  78455e:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784562:       8b 42 28                mov    0x28(%rdx),%eax
    0.00 :	  784565:       48 83 42 20 01          addq   $0x1,0x20(%rdx)
    0.00 :	  78456a:       83 c0 01                add    $0x1,%eax
    0.00 :	  78456d:       e9 a9 fe ff ff          jmpq   78441b <hash_search_with_hash_value+0x3cb>
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784572:       48 8d 14 1b             lea    (%rbx,%rbx,1),%rdx
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
    0.00 :	  784576:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784579:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  78457d:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784581:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784585:       49 8b 46 30             mov    0x30(%r14),%rax
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784589:       49 8b 56 08             mov    0x8(%r14),%rdx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78458d:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784591:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784595:       48 89 05 2c 56 43 00    mov    %rax,0x43562c(%rip)        # bb9bc8 <CurrentDynaHashCxt>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78459c:       41 ff 56 28             callq  *0x28(%r14)
         :
         :	        if (p != NULL)
    0.00 :	  7845a0:       48 85 c0                test   %rax,%rax
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  7845a3:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        if (p != NULL)
    0.00 :	  7845a7:       0f 84 89 00 00 00       je     784636 <hash_search_with_hash_value+0x5e6>
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845ad:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845b1:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
    0.00 :	  7845b5:       48 c1 e3 03             shl    $0x3,%rbx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845b9:       48 89 da                mov    %rbx,%rdx
    0.00 :	  7845bc:       e8 2f 56 ce ff          callq  469bf0 <memcpy@plt>
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  7845c1:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845c5:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7845c9:       48 01 df                add    %rbx,%rdi
    0.00 :	  7845cc:       48 29 da                sub    %rbx,%rdx
    0.00 :	  7845cf:       40 f6 c7 07             test   $0x7,%dil
    0.00 :	  7845d3:       0f 85 3e ff ff ff       jne    784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845d9:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	  7845e0:       0f 87 31 ff ff ff       ja     784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845e6:       48 8d 04 17             lea    (%rdi,%rdx,1),%rax
    0.00 :	  7845ea:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  7845ed:       0f 83 2b ff ff ff       jae    78451e <hash_search_with_hash_value+0x4ce>
    0.00 :	  7845f3:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7845fa:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	  7845fe:       48 39 f8                cmp    %rdi,%rax
    0.00 :	  784601:       77 f0                   ja     7845f3 <hash_search_with_hash_value+0x5a3>
    0.00 :	  784603:       e9 16 ff ff ff          jmpq   78451e <hash_search_with_hash_value+0x4ce>
         :	                                if (hashp->isshared)
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  784608:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  78460b:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  784610:       ba ca 03 00 00          mov    $0x3ca,%edx
    0.00 :	  784615:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  78461a:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78461f:       e8 9c 64 ff ff          callq  77aac0 <errstart>
    0.00 :	  784624:       84 c0                   test   %al,%al
    0.00 :	  784626:       0f 84 45 fc ff ff       je     784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78462c:       bf 04 9c 7b 00          mov    $0x7b9c04,%edi
    0.00 :	  784631:       e9 b1 fd ff ff          jmpq   7843e7 <hash_search_with_hash_value+0x397>
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
    0.00 :	  784636:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78463a:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78463e:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784642:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784646:       44 8b 43 28             mov    0x28(%rbx),%r8d
    0.00 :	  78464a:       e9 d9 fb ff ff          jmpq   784228 <hash_search_with_hash_value+0x1d8>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
         :	                                elog(ERROR, "cannot insert into frozen hashtable \"%s\"",
    0.00 :	  78464f:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  784654:       be ba 03 00 00          mov    $0x3ba,%esi
    0.00 :	  784659:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  78465e:       e8 bd 6d ff ff          callq  77b420 <elog_start>
    0.00 :	  784663:       49 8b 56 38             mov    0x38(%r14),%rdx
    0.00 :	  784667:       be c0 5a 8d 00          mov    $0x8d5ac0,%esi
    0.00 :	  78466c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  784671:       31 c0                   xor    %eax,%eax
    0.00 :	  784673:       e8 b8 6b ff ff          callq  77b230 <elog_finish>
    0.00 :	  784678:       e8 53 4e ce ff          callq  4694d0 <abort@plt>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78467d:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784681:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784685:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  784688:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78468c:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784690:       e9 13 fa ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5600 <XidInMVCCSnapshot>:
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
    0.00 :	  7a5600:       55                      push   %rbp
    0.00 :	  7a5601:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7a5604:       41 54                   push   %r12
    0.00 :	  7a5606:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7a5609:       53                      push   %rbx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a560a:       8b 76 08                mov    0x8(%rsi),%esi
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
    0.00 :	  7a560d:       89 fb                   mov    %edi,%ebx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a560f:       e8 cc a9 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5614:       84 c0                   test   %al,%al
    0.00 :	  7a5616:       74 08                   je     7a5620 <XidInMVCCSnapshot+0x20>
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
  100.00 :	  7a5618:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5619:       31 c0                   xor    %eax,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a561b:       41 5c                   pop    %r12
    0.00 :	  7a561d:       c9                      leaveq 
    0.00 :	  7a561e:       c3                      retq   
    0.00 :	  7a561f:       90                      nop
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                return false;
         :	        /* Any xid >= xmax is in-progress */
         :	        if (TransactionIdFollowsOrEquals(xid, snapshot->xmax))
    0.00 :	  7a5620:       41 8b 74 24 0c          mov    0xc(%r12),%esi
    0.00 :	  7a5625:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5627:       e8 44 aa d1 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  7a562c:       84 c0                   test   %al,%al
    0.00 :	  7a562e:       0f 85 7c 00 00 00       jne    7a56b0 <XidInMVCCSnapshot+0xb0>
         :
         :	        /*
         :	         * Snapshot information is stored slightly differently in snapshots taken
         :	         * during recovery.
         :	         */
         :	        if (!snapshot->takenDuringRecovery)
    0.00 :	  7a5634:       41 80 7c 24 29 00       cmpb   $0x0,0x29(%r12)
    0.00 :	  7a563a:       0f 85 80 00 00 00       jne    7a56c0 <XidInMVCCSnapshot+0xc0>
         :	                 * check things is just to compare the given XID against both subxact
         :	                 * XIDs and top-level XIDs.  If the snapshot overflowed, we have to
         :	                 * use pg_subtrans to convert a subxact XID to its parent XID, but
         :	                 * then we need only look at top-level XIDs not subxacts.
         :	                 */
         :	                if (!snapshot->suboverflowed)
    0.00 :	  7a5640:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a5646:       0f 85 b4 00 00 00       jne    7a5700 <XidInMVCCSnapshot+0x100>
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a564c:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a5651:       85 f6                   test   %esi,%esi
    0.00 :	  7a5653:       7e 25                   jle    7a567a <XidInMVCCSnapshot+0x7a>
         :	                        {
         :	                                if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a5655:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a565a:       31 d2                   xor    %edx,%edx
    0.00 :	  7a565c:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a565e:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a5661:       75 10                   jne    7a5673 <XidInMVCCSnapshot+0x73>
    0.00 :	  7a5663:       eb 4b                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5665:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a5668:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a566b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a566f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a5671:       74 3d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                if (!snapshot->suboverflowed)
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5673:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a5676:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a5678:       7c ee                   jl     7a5668 <XidInMVCCSnapshot+0x68>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a567a:       41 8b 74 24 18          mov    0x18(%r12),%esi
    0.00 :	  7a567f:       85 f6                   test   %esi,%esi
    0.00 :	  7a5681:       74 95                   je     7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->xip[i]))
    0.00 :	  7a5683:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  7a5688:       31 d2                   xor    %edx,%edx
    0.00 :	  7a568a:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a568c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a568f:       75 12                   jne    7a56a3 <XidInMVCCSnapshot+0xa3>
    0.00 :	  7a5691:       eb 1d                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5693:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a5698:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a569b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a569f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56a1:       74 0d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a56a3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56a6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56a8:       72 ee                   jb     7a5698 <XidInMVCCSnapshot+0x98>
    0.00 :	  7a56aa:       e9 69 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56af:       90                      nop
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b0:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56b1:       b8 01 00 00 00          mov    $0x1,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b6:       41 5c                   pop    %r12
    0.00 :	  7a56b8:       c9                      leaveq 
    0.00 :	  7a56b9:       c3                      retq   
    0.00 :	  7a56ba:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * far the bigger array, and we mostly don't know which xids are
         :	                 * top-level and which are subxacts. The xip array is empty.
         :	                 *
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
    0.00 :	  7a56c0:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a56c6:       75 60                   jne    7a5728 <XidInMVCCSnapshot+0x128>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56c8:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a56cd:       85 f6                   test   %esi,%esi
    0.00 :	  7a56cf:       0f 8e 43 ff ff ff       jle    7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a56d5:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a56da:       31 d2                   xor    %edx,%edx
    0.00 :	  7a56dc:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a56de:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a56e1:       75 10                   jne    7a56f3 <XidInMVCCSnapshot+0xf3>
    0.00 :	  7a56e3:       eb cb                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a56e5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a56e8:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a56eb:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a56ef:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56f1:       74 bd                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56f3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56f6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56f8:       7c ee                   jl     7a56e8 <XidInMVCCSnapshot+0xe8>
    0.00 :	  7a56fa:       e9 19 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56ff:       90                      nop
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5700:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5702:       e8 e9 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5707:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a570c:       89 c7                   mov    %eax,%edi
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a570e:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5710:       e8 cb a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5715:       84 c0                   test   %al,%al
    0.00 :	  7a5717:       0f 84 5d ff ff ff       je     7a567a <XidInMVCCSnapshot+0x7a>
    0.00 :	  7a571d:       e9 f6 fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a5722:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5728:       89 df                   mov    %ebx,%edi
    0.00 :	  7a572a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5730:       e8 bb 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5735:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a573a:       89 c7                   mov    %eax,%edi
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a573c:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a573e:       e8 9d a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5743:       84 c0                   test   %al,%al
    0.00 :	  7a5745:       74 81                   je     7a56c8 <XidInMVCCSnapshot+0xc8>
    0.00 :	  7a5747:       e9 cc fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/port/qsort.c:181
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007acc70 <pg_qsort>:
         :	                : (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
         :	}
         :
         :	void
         :	pg_qsort(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *))
         :	{
    0.00 :	  7acc70:       55                      push   %rbp
    0.00 :	  7acc71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7acc74:       41 57                   push   %r15
    0.00 :	  7acc76:       41 56                   push   %r14
    0.00 :	  7acc78:       49 89 f6                mov    %rsi,%r14
    0.00 :	  7acc7b:       41 55                   push   %r13
    0.00 :	  7acc7d:       41 54                   push   %r12
    0.00 :	  7acc7f:       53                      push   %rbx
    0.00 :	  7acc80:       48 83 ec 58             sub    $0x58,%rsp
    0.00 :	  7acc84:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
         :	                                 pl -= es)
         :	                                swap(pl, pl - es);
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
    0.00 :	  7acc88:       48 f7 da                neg    %rdx
    0.00 :	  7acc8b:       48 89 55 90             mov    %rdx,-0x70(%rbp)
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
    0.00 :	  7acc8f:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
         :	                : (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
         :	}
         :
         :	void
         :	pg_qsort(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *))
         :	{
    0.00 :	  7acc93:       48 89 7d a8             mov    %rdi,-0x58(%rbp)
    0.00 :	  7acc97:       48 89 4d 98             mov    %rcx,-0x68(%rbp)
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
    0.00 :	  7acc9b:       48 8d 04 52             lea    (%rdx,%rdx,2),%rax
    0.00 :	  7acc9f:       48 01 c0                add    %rax,%rax
    0.00 :	  7acca2:       48 89 45 88             mov    %rax,-0x78(%rbp)
         :	        int                     d,
         :	                                r,
         :	                                swaptype,
         :	                                presorted;
         :
         :	loop:SWAPINIT(a, es);
    0.00 :	  7acca6:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  7accaa:       48 0b 45 a0             or     -0x60(%rbp),%rax
    0.00 :	  7accae:       c7 45 c4 02 00 00 00    movl   $0x2,-0x3c(%rbp)
    0.00 :	  7accb5:       a8 07                   test   $0x7,%al
    0.00 :	  7accb7:       75 0d                   jne    7accc6 <pg_qsort+0x56>
    0.00 :	  7accb9:       31 c0                   xor    %eax,%eax
    0.00 :	  7accbb:       48 83 7d a0 08          cmpq   $0x8,-0x60(%rbp)
    0.00 :	  7accc0:       0f 95 c0                setne  %al
    0.00 :	  7accc3:       89 45 c4                mov    %eax,-0x3c(%rbp)
         :	        if (n < 7)
    0.00 :	  7accc6:       49 83 fe 06             cmp    $0x6,%r14
    0.00 :	  7accca:       0f 86 91 03 00 00       jbe    7ad061 <pg_qsort+0x3f1>
         :	                                 pl -= es)
         :	                                swap(pl, pl - es);
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
    0.00 :	  7accd0:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  7accd4:       4c 8b 7d a8             mov    -0x58(%rbp),%r15
    0.00 :	  7accd8:       4c 03 7d a0             add    -0x60(%rbp),%r15
    0.00 :	  7accdc:       49 0f af c6             imul   %r14,%rax
    0.00 :	  7acce0:       48 03 45 a8             add    -0x58(%rbp),%rax
    0.00 :	  7acce4:       49 39 c7                cmp    %rax,%r15
    0.00 :	  7acce7:       48 89 45 c8             mov    %rax,-0x38(%rbp)
    0.00 :	  7acceb:       0f 83 d5 02 00 00       jae    7acfc6 <pg_qsort+0x356>
    0.00 :	  7accf1:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  7accf5:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  7accf9:       4c 89 fb                mov    %r15,%rbx
    0.00 :	  7accfc:       4d 8d 2c 07             lea    (%r15,%rax,1),%r13
    0.00 :	  7acd00:       4d 8d 24 17             lea    (%r15,%rdx,1),%r12
    0.00 :	  7acd04:       eb 27                   jmp    7acd2d <pg_qsort+0xbd>
    0.00 :	  7acd06:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7acd0d:       00 00 00 
    0.00 :	  7acd10:       4c 03 6d a0             add    -0x60(%rbp),%r13
    0.00 :	  7acd14:       48 03 5d a0             add    -0x60(%rbp),%rbx
    0.00 :	  7acd18:       4c 03 65 a0             add    -0x60(%rbp),%r12
    0.00 :	  7acd1c:       4c 89 e8                mov    %r13,%rax
    0.00 :	  7acd1f:       48 2b 45 a0             sub    -0x60(%rbp),%rax
    0.00 :	  7acd23:       48 39 45 c8             cmp    %rax,-0x38(%rbp)
    0.00 :	  7acd27:       0f 86 99 02 00 00       jbe    7acfc6 <pg_qsort+0x356>
         :	        {
         :	                if (cmp(pm - es, pm) > 0)
    0.00 :	  7acd2d:       48 89 de                mov    %rbx,%rsi
    0.00 :	  7acd30:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7acd33:       ff 55 98                callq  *-0x68(%rbp)
    0.00 :	  7acd36:       85 c0                   test   %eax,%eax
    0.00 :	  7acd38:       7e d6                   jle    7acd10 <pg_qsort+0xa0>
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
    0.00 :	  7acd3a:       4c 89 f0                mov    %r14,%rax
    0.00 :	  7acd3d:       4c 8b 65 a8             mov    -0x58(%rbp),%r12
    0.00 :	  7acd41:       48 d1 e8                shr    %rax
    0.00 :	  7acd44:       48 0f af 45 a0          imul   -0x60(%rbp),%rax
    0.00 :	  7acd49:       49 01 c4                add    %rax,%r12
         :	        if (n > 7)
    0.00 :	  7acd4c:       49 83 fe 07             cmp    $0x7,%r14
    0.00 :	  7acd50:       0f 85 ed 01 00 00       jne    7acf43 <pg_qsort+0x2d3>
    0.00 :	  7acd56:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
         :	                }
         :	                pm = med3(pl, pm, pn, cmp);
         :	        }
         :	        swap(a, pm);
    0.00 :	  7acd5a:       8b 75 c4                mov    -0x3c(%rbp),%esi
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
    0.00 :	  7acd5d:       48 03 4d 88             add    -0x78(%rbp),%rcx
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
         :	                }
         :	                pm = med3(pl, pm, pn, cmp);
         :	        }
         :	        swap(a, pm);
    0.00 :	  7acd61:       85 f6                   test   %esi,%esi
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
    0.00 :	  7acd63:       48 89 4d d0             mov    %rcx,-0x30(%rbp)
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
         :	                }
         :	                pm = med3(pl, pm, pn, cmp);
         :	        }
         :	        swap(a, pm);
    0.00 :	  7acd67:       0f 85 15 02 00 00       jne    7acf82 <pg_qsort+0x312>
    0.00 :	  7acd6d:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  7acd71:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7acd75:       48 8b 10                mov    (%rax),%rdx
    0.00 :	  7acd78:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  7acd7c:       48 89 01                mov    %rax,(%rcx)
    0.00 :	  7acd7f:       49 89 14 24             mov    %rdx,(%r12)
    0.00 :	  7acd83:       4c 8b 6d d0             mov    -0x30(%rbp),%r13
    0.00 :	  7acd87:       4c 89 7d b8             mov    %r15,-0x48(%rbp)
    0.00 :	  7acd8b:       4d 89 fe                mov    %r15,%r14
    0.00 :	  7acd8e:       4d 89 ef                mov    %r13,%r15
    0.00 :	  7acd91:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        pa = pb = (char *) a + es;
         :	        pc = pd = (char *) a + (n - 1) * es;
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp(pb, a)) <= 0)
    0.00 :	  7acd98:       4d 39 ee                cmp    %r13,%r14
    0.00 :	  7acd9b:       0f 86 9f 00 00 00       jbe    7ace40 <pg_qsort+0x1d0>
         :	                swap(pb, pc);
         :	                pb += es;
         :	                pc -= es;
         :	        }
         :	        pn = (char *) a + n * es;
         :	        r = Min(pa - (char *) a, pb - pa);
    0.00 :	  7acda1:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  7acda5:       4c 89 f0                mov    %r14,%rax
    0.00 :	  7acda8:       48 2b 55 a8             sub    -0x58(%rbp),%rdx
    0.00 :	  7acdac:       48 2b 45 b8             sub    -0x48(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/port/qsort.c:181
  100.00 :	  7acdb0:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  7acdb3:       48 0f 4e c2             cmovle %rdx,%rax
         :	        vecswap(a, pb - r, r);
    0.00 :	  7acdb7:       85 c0                   test   %eax,%eax
    0.00 :	  7acdb9:       7e 15                   jle    7acdd0 <pg_qsort+0x160>
    0.00 :	  7acdbb:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acdbe:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7acdc2:       48 63 d0                movslq %eax,%rdx
    0.00 :	  7acdc5:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  7acdc8:       48 29 d6                sub    %rdx,%rsi
    0.00 :	  7acdcb:       e8 a0 fd ff ff          callq  7acb70 <swapfunc>
         :	        r = Min(pd - pc, pn - pd - es);
    0.00 :	  7acdd0:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  7acdd4:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  7acdd7:       4c 29 ea                sub    %r13,%rdx
    0.00 :	  7acdda:       4c 29 f8                sub    %r15,%rax
    0.00 :	  7acddd:       48 2b 45 a0             sub    -0x60(%rbp),%rax
    0.00 :	  7acde1:       48 39 d0                cmp    %rdx,%rax
    0.00 :	  7acde4:       48 0f 47 c2             cmova  %rdx,%rax
         :	        vecswap(pb, pn - r, r);
    0.00 :	  7acde8:       85 c0                   test   %eax,%eax
    0.00 :	  7acdea:       7e 15                   jle    7ace01 <pg_qsort+0x191>
    0.00 :	  7acdec:       48 8b 75 c8             mov    -0x38(%rbp),%rsi
    0.00 :	  7acdf0:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acdf3:       48 63 d0                movslq %eax,%rdx
    0.00 :	  7acdf6:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7acdf9:       48 29 d6                sub    %rdx,%rsi
    0.00 :	  7acdfc:       e8 6f fd ff ff          callq  7acb70 <swapfunc>
         :	        if ((r = pb - pa) > es)
    0.00 :	  7ace01:       44 89 f0                mov    %r14d,%eax
    0.00 :	  7ace04:       2b 45 b8                sub    -0x48(%rbp),%eax
    0.00 :	  7ace07:       48 98                   cltq   
    0.00 :	  7ace09:       48 39 45 a0             cmp    %rax,-0x60(%rbp)
    0.00 :	  7ace0d:       0f 82 87 01 00 00       jb     7acf9a <pg_qsort+0x32a>
         :	                qsort(a, r / es, es, cmp);
         :	        if ((r = pd - pc) > es)
    0.00 :	  7ace13:       44 89 f8                mov    %r15d,%eax
    0.00 :	  7ace16:       44 29 e8                sub    %r13d,%eax
    0.00 :	  7ace19:       48 98                   cltq   
    0.00 :	  7ace1b:       48 39 45 a0             cmp    %rax,-0x60(%rbp)
    0.00 :	  7ace1f:       0f 83 a1 01 00 00       jae    7acfc6 <pg_qsort+0x356>
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
    0.00 :	  7ace25:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  7ace29:       48 29 c2                sub    %rax,%rdx
    0.00 :	  7ace2c:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	                n = r / es;
    0.00 :	  7ace30:       31 d2                   xor    %edx,%edx
    0.00 :	  7ace32:       48 f7 75 a0             divq   -0x60(%rbp)
    0.00 :	  7ace36:       49 89 c6                mov    %rax,%r14
         :	                goto loop;
    0.00 :	  7ace39:       e9 68 fe ff ff          jmpq   7acca6 <pg_qsort+0x36>
    0.00 :	  7ace3e:       66 90                   xchg   %ax,%ax
         :	        swap(a, pm);
         :	        pa = pb = (char *) a + es;
         :	        pc = pd = (char *) a + (n - 1) * es;
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp(pb, a)) <= 0)
    0.00 :	  7ace40:       48 8b 75 a8             mov    -0x58(%rbp),%rsi
    0.00 :	  7ace44:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7ace47:       ff 55 98                callq  *-0x68(%rbp)
    0.00 :	  7ace4a:       83 f8 00                cmp    $0x0,%eax
    0.00 :	  7ace4d:       0f 8e b9 00 00 00       jle    7acf0c <pg_qsort+0x29c>
    0.00 :	  7ace53:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  7ace57:       4d 8d 64 15 00          lea    0x0(%r13,%rdx,1),%r12
    0.00 :	  7ace5c:       4c 89 e3                mov    %r12,%rbx
    0.00 :	  7ace5f:       eb 37                   jmp    7ace98 <pg_qsort+0x228>
    0.00 :	  7ace61:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                }
         :	                while (pb <= pc && (r = cmp(pc, a)) >= 0)
         :	                {
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pc, pd);
    0.00 :	  7ace68:       49 8b 55 00             mov    0x0(%r13),%rdx
    0.00 :	  7ace6c:       49 8b 07                mov    (%r15),%rax
    0.00 :	  7ace6f:       49 89 45 00             mov    %rax,0x0(%r13)
    0.00 :	  7ace73:       49 89 17                mov    %rdx,(%r15)
         :	                                pd -= es;
    0.00 :	  7ace76:       4c 03 7d 90             add    -0x70(%rbp),%r15
         :	                        }
         :	                        pc -= es;
    0.00 :	  7ace7a:       48 03 5d 90             add    -0x70(%rbp),%rbx
    0.00 :	  7ace7e:       4d 89 e5                mov    %r12,%r13
         :	                                swap(pa, pb);
         :	                                pa += es;
         :	                        }
         :	                        pb += es;
         :	                }
         :	                while (pb <= pc && (r = cmp(pc, a)) >= 0)
    0.00 :	  7ace81:       48 89 d8                mov    %rbx,%rax
    0.00 :	  7ace84:       48 2b 45 90             sub    -0x70(%rbp),%rax
    0.00 :	  7ace88:       49 39 c6                cmp    %rax,%r14
    0.00 :	  7ace8b:       0f 87 10 ff ff ff       ja     7acda1 <pg_qsort+0x131>
    0.00 :	  7ace91:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  7ace95:       49 01 cc                add    %rcx,%r12
    0.00 :	  7ace98:       48 8b 75 a8             mov    -0x58(%rbp),%rsi
    0.00 :	  7ace9c:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7ace9f:       ff 55 98                callq  *-0x68(%rbp)
    0.00 :	  7acea2:       83 f8 00                cmp    $0x0,%eax
    0.00 :	  7acea5:       7c 29                   jl     7aced0 <pg_qsort+0x260>
         :	                {
         :	                        if (r == 0)
    0.00 :	  7acea7:       75 d1                   jne    7ace7a <pg_qsort+0x20a>
         :	                        {
         :	                                swap(pc, pd);
    0.00 :	  7acea9:       8b 55 c4                mov    -0x3c(%rbp),%edx
    0.00 :	  7aceac:       85 d2                   test   %edx,%edx
    0.00 :	  7aceae:       66 90                   xchg   %ax,%ax
    0.00 :	  7aceb0:       74 b6                   je     7ace68 <pg_qsort+0x1f8>
    0.00 :	  7aceb2:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7aceb5:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7aceb9:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  7acebc:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7acebf:       e8 ac fc ff ff          callq  7acb70 <swapfunc>
    0.00 :	  7acec4:       eb b0                   jmp    7ace76 <pg_qsort+0x206>
    0.00 :	  7acec6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7acecd:       00 00 00 
         :	                        }
         :	                        pc -= es;
         :	                }
         :	                if (pb > pc)
         :	                        break;
         :	                swap(pb, pc);
    0.00 :	  7aced0:       8b 45 c4                mov    -0x3c(%rbp),%eax
    0.00 :	  7aced3:       85 c0                   test   %eax,%eax
    0.00 :	  7aced5:       75 21                   jne    7acef8 <pg_qsort+0x288>
    0.00 :	  7aced7:       49 8b 16                mov    (%r14),%rdx
    0.00 :	  7aceda:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  7acede:       49 89 06                mov    %rax,(%r14)
    0.00 :	  7acee1:       49 89 55 00             mov    %rdx,0x0(%r13)
         :	                pb += es;
    0.00 :	  7acee5:       4c 03 75 a0             add    -0x60(%rbp),%r14
         :	                pc -= es;
    0.00 :	  7acee9:       4d 89 e5                mov    %r12,%r13
    0.00 :	  7aceec:       e9 a7 fe ff ff          jmpq   7acd98 <pg_qsort+0x128>
    0.00 :	  7acef1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        }
         :	                        pc -= es;
         :	                }
         :	                if (pb > pc)
         :	                        break;
         :	                swap(pb, pc);
    0.00 :	  7acef8:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acefb:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7aceff:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7acf02:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7acf05:       e8 66 fc ff ff          callq  7acb70 <swapfunc>
    0.00 :	  7acf0a:       eb d9                   jmp    7acee5 <pg_qsort+0x275>
         :	        pc = pd = (char *) a + (n - 1) * es;
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp(pb, a)) <= 0)
         :	                {
         :	                        if (r == 0)
    0.00 :	  7acf0c:       75 2c                   jne    7acf3a <pg_qsort+0x2ca>
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  7acf0e:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acf11:       85 c9                   test   %ecx,%ecx
    0.00 :	  7acf13:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7acf18:       0f 85 b7 00 00 00       jne    7acfd5 <pg_qsort+0x365>
    0.00 :	  7acf1e:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  7acf22:       48 8b 4d b8             mov    -0x48(%rbp),%rcx
    0.00 :	  7acf26:       48 8b 10                mov    (%rax),%rdx
    0.00 :	  7acf29:       49 8b 06                mov    (%r14),%rax
    0.00 :	  7acf2c:       48 89 01                mov    %rax,(%rcx)
    0.00 :	  7acf2f:       49 89 16                mov    %rdx,(%r14)
         :	                                pa += es;
    0.00 :	  7acf32:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  7acf36:       48 01 45 b8             add    %rax,-0x48(%rbp)
         :	                        }
         :	                        pb += es;
    0.00 :	  7acf3a:       4c 03 75 a0             add    -0x60(%rbp),%r14
    0.00 :	  7acf3e:       e9 55 fe ff ff          jmpq   7acd98 <pg_qsort+0x128>
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
         :	        {
         :	                pl = (char *) a;
         :	                pn = (char *) a + (n - 1) * es;
    0.00 :	  7acf43:       49 8d 46 ff             lea    -0x1(%r14),%rax
         :	                if (n > 40)
    0.00 :	  7acf47:       4c 8b 45 a8             mov    -0x58(%rbp),%r8
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
         :	        {
         :	                pl = (char *) a;
         :	                pn = (char *) a + (n - 1) * es;
    0.00 :	  7acf4b:       48 0f af 45 a0          imul   -0x60(%rbp),%rax
    0.00 :	  7acf50:       48 03 45 a8             add    -0x58(%rbp),%rax
         :	                if (n > 40)
    0.00 :	  7acf54:       49 83 fe 28             cmp    $0x28,%r14
         :	                return;
         :	        pm = (char *) a + (n / 2) * es;
         :	        if (n > 7)
         :	        {
         :	                pl = (char *) a;
         :	                pn = (char *) a + (n - 1) * es;
    0.00 :	  7acf58:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :	                if (n > 40)
    0.00 :	  7acf5c:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7acf5f:       0f 87 88 00 00 00       ja     7acfed <pg_qsort+0x37d>
         :	                        d = (n / 8) * es;
         :	                        pl = med3(pl, pl + d, pl + 2 * d, cmp);
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
         :	                }
         :	                pm = med3(pl, pm, pn, cmp);
    0.00 :	  7acf65:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  7acf69:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  7acf6c:       4c 89 c7                mov    %r8,%rdi
    0.00 :	  7acf6f:       e8 5c fc ff ff          callq  7acbd0 <med3>
         :	        }
         :	        swap(a, pm);
    0.00 :	  7acf74:       8b 75 c4                mov    -0x3c(%rbp),%esi
         :	                        d = (n / 8) * es;
         :	                        pl = med3(pl, pl + d, pl + 2 * d, cmp);
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
         :	                }
         :	                pm = med3(pl, pm, pn, cmp);
    0.00 :	  7acf77:       49 89 c4                mov    %rax,%r12
         :	        }
         :	        swap(a, pm);
    0.00 :	  7acf7a:       85 f6                   test   %esi,%esi
    0.00 :	  7acf7c:       0f 84 eb fd ff ff       je     7acd6d <pg_qsort+0xfd>
    0.00 :	  7acf82:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acf85:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7acf89:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  7acf8c:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7acf90:       e8 db fb ff ff          callq  7acb70 <swapfunc>
    0.00 :	  7acf95:       e9 e9 fd ff ff          jmpq   7acd83 <pg_qsort+0x113>
         :	        r = Min(pa - (char *) a, pb - pa);
         :	        vecswap(a, pb - r, r);
         :	        r = Min(pd - pc, pn - pd - es);
         :	        vecswap(pb, pn - r, r);
         :	        if ((r = pb - pa) > es)
         :	                qsort(a, r / es, es, cmp);
    0.00 :	  7acf9a:       31 d2                   xor    %edx,%edx
    0.00 :	  7acf9c:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  7acfa0:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7acfa4:       48 f7 75 a0             divq   -0x60(%rbp)
    0.00 :	  7acfa8:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7acfac:       48 89 c6                mov    %rax,%rsi
    0.00 :	  7acfaf:       e8 bc fc ff ff          callq  7acc70 <pg_qsort>
         :	        if ((r = pd - pc) > es)
    0.00 :	  7acfb4:       44 89 f8                mov    %r15d,%eax
    0.00 :	  7acfb7:       44 29 e8                sub    %r13d,%eax
    0.00 :	  7acfba:       48 98                   cltq   
    0.00 :	  7acfbc:       48 39 45 a0             cmp    %rax,-0x60(%rbp)
    0.00 :	  7acfc0:       0f 82 5f fe ff ff       jb     7ace25 <pg_qsort+0x1b5>
         :	                a = pn - r;
         :	                n = r / es;
         :	                goto loop;
         :	        }
         :	/*              qsort(pn - r, r / es, es, cmp);*/
         :	}
    0.00 :	  7acfc6:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  7acfca:       5b                      pop    %rbx
    0.00 :	  7acfcb:       41 5c                   pop    %r12
    0.00 :	  7acfcd:       41 5d                   pop    %r13
    0.00 :	  7acfcf:       41 5e                   pop    %r14
    0.00 :	  7acfd1:       41 5f                   pop    %r15
    0.00 :	  7acfd3:       c9                      leaveq 
    0.00 :	  7acfd4:       c3                      retq   
         :	        {
         :	                while (pb <= pc && (r = cmp(pb, a)) <= 0)
         :	                {
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  7acfd5:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7acfd8:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7acfdc:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  7acfdf:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  7acfe3:       e8 88 fb ff ff          callq  7acb70 <swapfunc>
    0.00 :	  7acfe8:       e9 45 ff ff ff          jmpq   7acf32 <pg_qsort+0x2c2>
         :	        {
         :	                pl = (char *) a;
         :	                pn = (char *) a + (n - 1) * es;
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8) * es;
    0.00 :	  7acfed:       8b 45 a0                mov    -0x60(%rbp),%eax
    0.00 :	  7acff0:       49 c1 ee 03             shr    $0x3,%r14
         :	                        pl = med3(pl, pl + d, pl + 2 * d, cmp);
    0.00 :	  7acff4:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7acff8:       48 8b 75 a8             mov    -0x58(%rbp),%rsi
    0.00 :	  7acffc:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  7ad000:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
         :	        {
         :	                pl = (char *) a;
         :	                pn = (char *) a + (n - 1) * es;
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8) * es;
    0.00 :	  7ad004:       41 0f af c6             imul   %r14d,%eax
         :	                        pl = med3(pl, pl + d, pl + 2 * d, cmp);
    0.00 :	  7ad008:       8d 1c 00                lea    (%rax,%rax,1),%ebx
    0.00 :	  7ad00b:       4c 63 e8                movslq %eax,%r13
    0.00 :	  7ad00e:       4c 01 ee                add    %r13,%rsi
    0.00 :	  7ad011:       48 63 db                movslq %ebx,%rbx
    0.00 :	  7ad014:       48 01 da                add    %rbx,%rdx
    0.00 :	  7ad017:       e8 b4 fb ff ff          callq  7acbd0 <med3>
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
    0.00 :	  7ad01c:       4b 8d 14 2c             lea    (%r12,%r13,1),%rdx
    0.00 :	  7ad020:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  7ad024:       49 f7 dd                neg    %r13
    0.00 :	  7ad027:       4b 8d 3c 2c             lea    (%r12,%r13,1),%rdi
    0.00 :	  7ad02b:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  7ad02e:       48 89 45 80             mov    %rax,-0x80(%rbp)
    0.00 :	  7ad032:       e8 99 fb ff ff          callq  7acbd0 <med3>
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
    0.00 :	  7ad037:       48 8b 75 d0             mov    -0x30(%rbp),%rsi
    0.00 :	  7ad03b:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
         :	                pn = (char *) a + (n - 1) * es;
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8) * es;
         :	                        pl = med3(pl, pl + d, pl + 2 * d, cmp);
         :	                        pm = med3(pm - d, pm, pm + d, cmp);
    0.00 :	  7ad03f:       49 89 c4                mov    %rax,%r12
         :	                        pn = med3(pn - 2 * d, pn - d, pn, cmp);
    0.00 :	  7ad042:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  7ad046:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  7ad04a:       4c 01 ee                add    %r13,%rsi
    0.00 :	  7ad04d:       48 29 df                sub    %rbx,%rdi
    0.00 :	  7ad050:       e8 7b fb ff ff          callq  7acbd0 <med3>
    0.00 :	  7ad055:       4c 8b 45 80             mov    -0x80(%rbp),%r8
    0.00 :	  7ad059:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7ad05c:       e9 04 ff ff ff          jmpq   7acf65 <pg_qsort+0x2f5>
         :	                                presorted;
         :
         :	loop:SWAPINIT(a, es);
         :	        if (n < 7)
         :	        {
         :	                for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
    0.00 :	  7ad061:       4c 0f af 75 a0          imul   -0x60(%rbp),%r14
    0.00 :	  7ad066:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7ad06a:       48 03 7d a0             add    -0x60(%rbp),%rdi
    0.00 :	  7ad06e:       4c 03 75 a8             add    -0x58(%rbp),%r14
    0.00 :	  7ad072:       4c 39 f7                cmp    %r14,%rdi
    0.00 :	  7ad075:       4c 89 75 b0             mov    %r14,-0x50(%rbp)
    0.00 :	  7ad079:       0f 83 47 ff ff ff       jae    7acfc6 <pg_qsort+0x356>
    0.00 :	  7ad07f:       48 8b 4d a0             mov    -0x60(%rbp),%rcx
    0.00 :	  7ad083:       49 89 fd                mov    %rdi,%r13
         :	                        for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
    0.00 :	  7ad086:       49 89 ce                mov    %rcx,%r14
         :	                                presorted;
         :
         :	loop:SWAPINIT(a, es);
         :	        if (n < 7)
         :	        {
         :	                for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
    0.00 :	  7ad089:       4c 8d 3c 0f             lea    (%rdi,%rcx,1),%r15
         :	                        for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
    0.00 :	  7ad08d:       49 f7 de                neg    %r14
    0.00 :	  7ad090:       4c 39 6d a8             cmp    %r13,-0x58(%rbp)
    0.00 :	  7ad094:       4b 8d 5c 35 00          lea    0x0(%r13,%r14,1),%rbx
    0.00 :	  7ad099:       49 89 dc                mov    %rbx,%r12
    0.00 :	  7ad09c:       72 2f                   jb     7ad0cd <pg_qsort+0x45d>
    0.00 :	  7ad09e:       eb 55                   jmp    7ad0f5 <pg_qsort+0x485>
         :	                                 pl -= es)
         :	                                swap(pl, pl - es);
    0.00 :	  7ad0a0:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  7ad0a4:       48 8b 4d a0             mov    -0x60(%rbp),%rcx
    0.00 :	  7ad0a8:       48 8b 14 03             mov    (%rbx,%rax,1),%rdx
    0.00 :	  7ad0ac:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  7ad0b0:       48 89 04 0b             mov    %rax,(%rbx,%rcx,1)
    0.00 :	  7ad0b4:       49 89 14 24             mov    %rdx,(%r12)
    0.00 :	  7ad0b8:       4d 01 f4                add    %r14,%r12
         :
         :	loop:SWAPINIT(a, es);
         :	        if (n < 7)
         :	        {
         :	                for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
         :	                        for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
    0.00 :	  7ad0bb:       4c 89 e0                mov    %r12,%rax
    0.00 :	  7ad0be:       4c 29 f0                sub    %r14,%rax
    0.00 :	  7ad0c1:       48 39 45 a8             cmp    %rax,-0x58(%rbp)
    0.00 :	  7ad0c5:       73 2e                   jae    7ad0f5 <pg_qsort+0x485>
    0.00 :	  7ad0c7:       49 89 dd                mov    %rbx,%r13
    0.00 :	  7ad0ca:       4c 01 f3                add    %r14,%rbx
    0.00 :	  7ad0cd:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7ad0d0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7ad0d3:       ff 55 98                callq  *-0x68(%rbp)
    0.00 :	  7ad0d6:       85 c0                   test   %eax,%eax
    0.00 :	  7ad0d8:       7e 1b                   jle    7ad0f5 <pg_qsort+0x485>
         :	                                 pl -= es)
         :	                                swap(pl, pl - es);
    0.00 :	  7ad0da:       8b 7d c4                mov    -0x3c(%rbp),%edi
    0.00 :	  7ad0dd:       85 ff                   test   %edi,%edi
    0.00 :	  7ad0df:       74 bf                   je     7ad0a0 <pg_qsort+0x430>
    0.00 :	  7ad0e1:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  7ad0e4:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7ad0e8:       48 89 de                mov    %rbx,%rsi
    0.00 :	  7ad0eb:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7ad0ee:       e8 7d fa ff ff          callq  7acb70 <swapfunc>
    0.00 :	  7ad0f3:       eb c3                   jmp    7ad0b8 <pg_qsort+0x448>
         :
         :	loop:SWAPINIT(a, es);
         :	        if (n < 7)
         :	        {
         :	                for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
         :	                        for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
    0.00 :	  7ad0f5:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  7ad0f8:       4c 03 7d a0             add    -0x60(%rbp),%r15
    0.00 :	  7ad0fc:       49 89 fd                mov    %rdi,%r13
         :	                                presorted;
         :
         :	loop:SWAPINIT(a, es);
         :	        if (n < 7)
         :	        {
         :	                for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
    0.00 :	  7ad0ff:       4c 89 f8                mov    %r15,%rax
    0.00 :	  7ad102:       48 2b 45 a0             sub    -0x60(%rbp),%rax
    0.00 :	  7ad106:       48 39 45 b0             cmp    %rax,-0x50(%rbp)
    0.00 :	  7ad10a:       77 84                   ja     7ad090 <pg_qsort+0x420>
         :	                a = pn - r;
         :	                n = r / es;
         :	                goto loop;
         :	        }
         :	/*              qsort(pn - r, r / es, es, cmp);*/
         :	}
    0.00 :	  7ad10c:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  7ad110:       5b                      pop    %rbx
    0.00 :	  7ad111:       41 5c                   pop    %r12
    0.00 :	  7ad113:       41 5d                   pop    %r13
    0.00 :	  7ad115:       41 5e                   pop    %r14
    0.00 :	  7ad117:       41 5f                   pop    %r15
    0.00 :	  7ad119:       c9                      leaveq 

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000cd5c0 <__read>:
    0.00 :	   cd5c0:       83 3d ed a0 2a 00 00    cmpl   $0x0,0x2aa0ed(%rip)        # 3776b4 <__libc_multiple_threads>
    0.00 :	   cd5c7:       75 10                   jne    cd5d9 <__read_nocancel+0x10>
         :
         :	00000000000cd5c9 <__read_nocancel>:
    0.00 :	   cd5c9:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5ce:       0f 05                   syscall 
 ??:0
  100.00 :	   cd5d0:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd5d6:       73 31                   jae    cd609 <__read_nocancel+0x40>
    0.00 :	   cd5d8:       c3                      retq   
    0.00 :	   cd5d9:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   cd5dd:       e8 4e ac 01 00          callq  e8230 <__libc_enable_asynccancel>
    0.00 :	   cd5e2:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	   cd5e6:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5eb:       0f 05                   syscall 
    0.00 :	   cd5ed:       48 8b 3c 24             mov    (%rsp),%rdi
    0.00 :	   cd5f1:       48 89 c2                mov    %rax,%rdx
    0.00 :	   cd5f4:       e8 97 ac 01 00          callq  e8290 <__libc_disable_asynccancel>
    0.00 :	   cd5f9:       48 89 d0                mov    %rdx,%rax
    0.00 :	   cd5fc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   cd600:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd606:       73 01                   jae    cd609 <__read_nocancel+0x40>
    0.00 :	   cd608:       c3                      retq   
    0.00 :	   cd609:       48 8b 0d 28 48 2a 00    mov    0x2a4828(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   cd610:       31 d2                   xor    %edx,%edx
    0.00 :	   cd612:       48 29 c2                sub    %rax,%rdx
    0.00 :	   cd615:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   cd618:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   cd61c:       eb ea                   jmp    cd608 <__read_nocancel+0x3f>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000000700 <igb_update_stats>:
    0.00 :	     700:       53                      push   %rbx
    0.00 :	     731:       48 89 fb 48 83          mov    $0x2b8,%edi
    0.00 :	     736:       ec 10 66                xor    %r10d,%r10d
    0.00 :	     739:       83 bf f8                xor    %r9d,%r9d
    0.00 :	     73c:       03 00                   test   %edi,%edi
    0.00 :	     73e:       00 00                   jle    78c <dma_unmap_page+0x75c>
    0.00 :	     740:       48 8b 87                mov    %rbx,%r8
    0.00 :	     743:       a0 04                   xor    %edi,%edi
    0.00 :	     745:       00 00 74                xor    %r10d,%r10d
    0.00 :	     748:       09 83 b8                xor    %r9d,%r9d
    0.00 :	     74b:       88 00 00 00 01          mov    $0xc030,%ecx
    0.00 :	     750:       74 0e 48                mov    %rcx,%rax
    0.00 :	     753:       83 c4 10 5b c3 0f 1f    add    0x570(%rbx),%rax
    0.00 :	     75a:       84 00                   mov    (%rax),%eax
    0.00 :	     75c:       00 00                   test   %eax,%eax
    0.00 :	     75e:       00 00 8b bf b8 02 00    mov    0x2c0(%r8),%rdx
    0.00 :	     765:       00 45                   je     771 <dma_unmap_page+0x741>
    0.00 :	     767:       31 d2                   mov    %eax,%eax
    0.00 :	     769:       45 31 c9 85             add    %rax,0x68(%rdx)
    0.00 :	     76d:       ff 7e 4c 49             add    %rax,0x70(%rsi)
    0.00 :	     771:       89 d8 31 ff             add    0x60(%rdx),%r10
    0.00 :	     775:       45 31 d2 45             add    0x58(%rdx),%r9
    0.00 :	     779:       31 c9 b9                add    $0x1,%edi
    0.00 :	     77c:       30 c0 00 00             add    $0x40,%rcx
    0.00 :	     780:       48 89 c8 48             add    $0x8,%r8
    0.00 :	     784:       03 83 70 05 00 00       cmp    %edi,0x2b8(%rbx)
    0.00 :	     78a:       8b 00                   jg     750 <dma_unmap_page+0x720>
    0.00 :	     78c:       85 c0 49 8b             mov    %r10,0x10(%rsi)
    0.00 :	     790:       90 c0 02                mov    %r9,(%rsi)
    0.00 :	     793:       00 00                   xor    %edi,%edi
    0.00 :	     795:       74 0a 89 c0 48 01 42    mov    0x234(%rbx),%r8d
    0.00 :	     79c:       68 48                   xor    %ecx,%ecx
    0.00 :	     79e:       01 46 70                test   %r8d,%r8d
    0.00 :	     7a1:       4c 03                   jle    7c9 <dma_unmap_page+0x799>
    0.00 :	     7a3:       52 60                   xor    %edi,%edi
    0.00 :	     7a5:       4c 03                   xor    %ecx,%ecx
    0.00 :	     7a7:       4a 58                   xor    %edx,%edx
    0.00 :	     7a9:       83 c7 01 48 83 c1 40    nopl   0x0(%rax)
    0.00 :	     7b0:       49 83 c0 08 39 bb b8    mov    0x238(%rbx,%rdx,8),%rax
    0.00 :	     7b7:       02 
    0.00 :	     7b8:       00 00 7f c4             add    $0x1,%rdx
    0.00 :	     7bc:       4c 89 56 10             add    0x58(%rax),%rdi
    0.00 :	     7c0:       4c 89 0e 31             add    0x50(%rax),%rcx
    0.00 :	     7c4:       ff 44 8b                cmp    %edx,%r8d
    0.00 :	     7c7:       83 34                   jg     7b0 <dma_unmap_page+0x780>
    0.00 :	     7c9:       02 00 00 31             mov    %rdi,0x18(%rsi)
    0.00 :	     7cd:       c9 45 85 c0             mov    %rcx,0x8(%rsi)
    0.00 :	     7d1:       7e 26 31 ff 31 c9 31    mov    0x570(%rbx),%rax
    0.00 :	     7d8:       d2 0f 1f 80 00 00 00    mov    0x9c8(%rbx),%rdx
    0.00 :	     7df:       00 48 8b 84 d3 38       add    $0x4000,%rax
    0.00 :	     7e5:       02 00                   mov    (%rax),%eax
    0.00 :	     7e7:       00 48                   mov    %eax,%eax
    0.00 :	     7e9:       83 c2 01                add    %rdx,%rax
    0.00 :	     7ec:       48 03 78 58 48 03 48    mov    0xa98(%rbx),%rdx
    0.00 :	     7f3:       50 41 39 d0 7f e7 48    mov    %rax,0x9c8(%rbx)
    0.00 :	     7fa:       89 7e 18 48 89 4e 08    mov    0x570(%rbx),%rax
    0.00 :	     801:       48 8b 83 70 05 00       add    $0x4074,%rax
    0.00 :	     807:       00 48                   mov    (%rax),%eax
    0.00 :	     809:       8b 93                   mov    %eax,%eax
    0.00 :	     80b:       c8 09 00                add    %rdx,%rax
    0.00 :	     80e:       00 48 05 00 40 00 00    mov    0xab8(%rbx),%rdx
    0.00 :	     815:       8b 00 89 c0 48 01 d0    mov    %rax,0xa98(%rbx)
    0.00 :	     81c:       48 8b 93 98 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     823:       48 89 83 c8 09 00       add    $0x4088,%rax
    0.00 :	     829:       00 48                   mov    (%rax),%eax
    0.00 :	     82b:       8b 83                   mov    %eax,%eax
    0.00 :	     82d:       70 05 00                add    %rdx,%rax
    0.00 :	     830:       00 48 05 74 40 00 00    mov    %rax,0xab8(%rbx)
    0.00 :	     837:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     83e:       48 8b 93 b8 0a 00       add    $0x408c,%rax
    0.00 :	     844:       00 48                   mov    (%rax),%eax
    0.00 :	     846:       89 83 98 0a 00 00 48    mov    0x570(%rbx),%rax
    0.00 :	     84d:       8b 83 70 05 00 00 48    mov    0xaa0(%rbx),%rdx
    0.00 :	     854:       05 88 40 00 00 8b       add    $0x4078,%rax
    0.00 :	     85a:       00 89                   mov    (%rax),%eax
    0.00 :	     85c:       c0 48                   mov    %eax,%eax
    0.00 :	     85e:       01 d0 48                add    %rdx,%rax
    0.00 :	     861:       89 83 b8 0a 00 00 48    mov    0xaa8(%rbx),%rdx
    0.00 :	     868:       8b 83 70 05 00 00 48    mov    %rax,0xaa0(%rbx)
    0.00 :	     86f:       05 8c 40 00 00 8b 00    mov    0x570(%rbx),%rax
    0.00 :	     876:       48 8b 83 70 05 00       add    $0x407c,%rax
    0.00 :	     87c:       00 48                   mov    (%rax),%eax
    0.00 :	     87e:       8b 93                   mov    %eax,%eax
    0.00 :	     880:       a0 0a 00                add    %rdx,%rax
    0.00 :	     883:       00 48 05 78 40 00 00    mov    0xae0(%rbx),%rdx
    0.00 :	     88a:       8b 00 89 c0 48 01 d0    mov    %rax,0xaa8(%rbx)
    0.00 :	     891:       48 8b 93 a8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     898:       48 89 83 a0 0a 00       add    $0x40ac,%rax
    0.00 :	     89e:       00 48                   mov    (%rax),%eax
    0.00 :	     8a0:       8b 83                   mov    %eax,%eax
    0.00 :	     8a2:       70 05 00                add    %rdx,%rax
    0.00 :	     8a5:       00 48 05 7c 40 00 00    mov    0xa68(%rbx),%rdx
    0.00 :	     8ac:       8b 00 89 c0 48 01 d0    mov    %rax,0xae0(%rbx)
    0.00 :	     8b3:       48 8b 93 e0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8ba:       48 89 83 a8 0a 00       add    $0x405c,%rax
    0.00 :	     8c0:       00 48                   mov    (%rax),%eax
    0.00 :	     8c2:       8b 83                   mov    %eax,%eax
    0.00 :	     8c4:       70 05 00                add    %rdx,%rax
    0.00 :	     8c7:       00 48 05 ac 40 00 00    mov    0xa70(%rbx),%rdx
    0.00 :	     8ce:       8b 00 89 c0 48 01 d0    mov    %rax,0xa68(%rbx)
    0.00 :	     8d5:       48 8b 93 68 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8dc:       48 89 83 e0 0a 00       add    $0x4060,%rax
    0.00 :	     8e2:       00 48                   mov    (%rax),%eax
    0.00 :	     8e4:       8b 83                   mov    %eax,%eax
    0.00 :	     8e6:       70 05 00                add    %rdx,%rax
    0.00 :	     8e9:       00 48 05 5c 40 00 00    mov    0xa78(%rbx),%rdx
    0.00 :	     8f0:       8b 00 89 c0 48 01 d0    mov    %rax,0xa70(%rbx)
    0.00 :	     8f7:       48 8b 93 70 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8fe:       48 89 83 68 0a 00       add    $0x4064,%rax
    0.00 :	     904:       00 48                   mov    (%rax),%eax
    0.00 :	     906:       8b 83                   mov    %eax,%eax
    0.00 :	     908:       70 05 00                add    %rdx,%rax
    0.00 :	     90b:       00 48 05 60 40 00 00    mov    0xa80(%rbx),%rdx
    0.00 :	     912:       8b 00 89 c0 48 01 d0    mov    %rax,0xa78(%rbx)
    0.00 :	     919:       48 8b 93 78 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     920:       48 89 83 70 0a 00       add    $0x4068,%rax
    0.00 :	     926:       00 48                   mov    (%rax),%eax
    0.00 :	     928:       8b 83                   mov    %eax,%eax
    0.00 :	     92a:       70 05 00                add    %rdx,%rax
    0.00 :	     92d:       00 48 05 64 40 00 00    mov    0xa88(%rbx),%rdx
    0.00 :	     934:       8b 00 89 c0 48 01 d0    mov    %rax,0xa80(%rbx)
    0.00 :	     93b:       48 8b 93 80 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     942:       48 89 83 78 0a 00       add    $0x406c,%rax
    0.00 :	     948:       00 48                   mov    (%rax),%eax
    0.00 :	     94a:       8b 83                   mov    %eax,%eax
    0.00 :	     94c:       70 05 00                add    %rdx,%rax
    0.00 :	     94f:       00 48 05 68 40 00 00    mov    0xa90(%rbx),%rdx
    0.00 :	     956:       8b 00 89 c0 48 01 d0    mov    %rax,0xa88(%rbx)
    0.00 :	     95d:       48 8b 93 88 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     964:       48 89 83 80 0a 00       add    $0x4070,%rax
    0.00 :	     96a:       00 48                   mov    (%rax),%eax
    0.00 :	     96c:       8b 83                   mov    %eax,%eax
    0.00 :	     96e:       70 05 00                add    %rdx,%rax
    0.00 :	     971:       00 48 05 6c 40 00 00    mov    0x9d8(%rbx),%rdx
    0.00 :	     978:       8b 00 89 c0 48 01 d0    mov    %rax,0xa90(%rbx)
    0.00 :	     97f:       48 8b 93 90 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     986:       48 89 83 88 0a 00       add    $0x4008,%rax
    0.00 :	     98c:       00 48                   mov    (%rax),%eax
    0.00 :	     98e:       8b 83                   mov    %eax,%eax
    0.00 :	     990:       70 05 00                add    %rdx,%rax
    0.00 :	     993:       00 48 05 70 40 00 00    mov    0xa28(%rbx),%rdx
    0.00 :	     99a:       8b 00 89 c0 48 01 d0    mov    %rax,0x9d8(%rbx)
    0.00 :	     9a1:       48 8b 93 d8 09 00 00    mov    0x570(%rbx),%rax
    0.00 :	     9a8:       48 89 83 90 0a 00       add    $0x4038,%rax
    0.00 :	     9ae:       00 48                   mov    (%rax),%eax
    0.00 :	     9b0:       8b 83                   mov    %eax,%eax
    0.00 :	     9b2:       70 05 00                add    %rdx,%rax
    0.00 :	     9b5:       00 48 05 08 40 00 00    mov    %rax,0xa28(%rbx)
    0.00 :	     9bc:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     9c3:       48 8b 93 28 0a 00       add    $0x4010,%rax
    0.00 :	     9c9:       00 48                   mov    (%rax),%eax
    0.00 :	     9cb:       89 83                   mov    %eax,%eax
    0.00 :	     9cd:       d8 09 00 00 48 8b 83    add    %rax,0x9e8(%rbx)
    0.00 :	     9d4:       70 05 00 00             add    %rax,0x70(%rsi)
    0.00 :	     9d8:       48 05 38 40 00 00 8b    mov    0x570(%rbx),%rax
    0.00 :	     9df:       00 89 c0 48 01 d0 48    mov    0x9f0(%rbx),%rdx
    0.00 :	     9e6:       89 83 28 0a 00 00       add    $0x4014,%rax
    0.00 :	     9ec:       48 8b                   mov    (%rax),%eax
    0.00 :	     9ee:       83 70                   mov    %eax,%eax
    0.00 :	     9f0:       05 00 00                add    %rdx,%rax
    0.00 :	     9f3:       48 05 10 40 00 00 8b    mov    0x9f8(%rbx),%rdx
    0.00 :	     9fa:       00 89 c0 48 01 83 e8    mov    %rax,0x9f0(%rbx)
    0.00 :	     a01:       09 00 00 48 01 46 70    mov    0x570(%rbx),%rax
    0.00 :	     a08:       48 8b 83 70 05 00       add    $0x4018,%rax
    0.00 :	     a0e:       00 48                   mov    (%rax),%eax
    0.00 :	     a10:       8b 93                   mov    %eax,%eax
    0.00 :	     a12:       f0 09 00                add    %rdx,%rax
    0.00 :	     a15:       00 48 05 14 40 00 00    mov    0xa00(%rbx),%rdx
    0.00 :	     a1c:       8b 00 89 c0 48 01 d0    mov    %rax,0x9f8(%rbx)
    0.00 :	     a23:       48 8b 93 f8 09 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a2a:       48 89 83 f0 09 00       add    $0x401c,%rax
    0.00 :	     a30:       00 48                   mov    (%rax),%eax
    0.00 :	     a32:       8b 83                   mov    %eax,%eax
    0.00 :	     a34:       70 05 00                add    %rdx,%rax
    0.00 :	     a37:       00 48 05 18 40 00 00    mov    0xa08(%rbx),%rdx
    0.00 :	     a3e:       8b 00 89 c0 48 01 d0    mov    %rax,0xa00(%rbx)
    0.00 :	     a45:       48 8b 93 00 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a4c:       48 89 83 f8 09 00       add    $0x4020,%rax
    0.00 :	     a52:       00 48                   mov    (%rax),%eax
    0.00 :	     a54:       8b 83                   mov    %eax,%eax
    0.00 :	     a56:       70 05 00                add    %rdx,%rax
    0.00 :	     a59:       00 48 05 1c 40 00 00    mov    0xa18(%rbx),%rdx
    0.00 :	     a60:       8b 00 89 c0 48 01 d0    mov    %rax,0xa08(%rbx)
    0.00 :	     a67:       48 8b 93 08 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a6e:       48 89 83 00 0a 00       add    $0x4030,%rax
    0.00 :	     a74:       00 48                   mov    (%rax),%eax
    0.00 :	     a76:       8b 83                   mov    %eax,%eax
    0.00 :	     a78:       70 05 00                add    %rdx,%rax
    0.00 :	     a7b:       00 48 05 20 40 00 00    mov    0xa38(%rbx),%rdx
    0.00 :	     a82:       8b 00 89 c0 48 01 d0    mov    %rax,0xa18(%rbx)
    0.00 :	     a89:       48 8b 93 18 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a90:       48 89 83 08 0a 00       add    $0x4040,%rax
    0.00 :	     a96:       00 48                   mov    (%rax),%eax
    0.00 :	     a98:       8b 83                   mov    %eax,%eax
    0.00 :	     a9a:       70 05 00                add    %rdx,%rax
    0.00 :	     a9d:       00 48 05 30 40 00 00    mov    0xa40(%rbx),%rdx
    0.00 :	     aa4:       8b 00 89 c0 48 01 d0    mov    %rax,0xa38(%rbx)
    0.00 :	     aab:       48 8b 93 38 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ab2:       48 89 83 18 0a 00       add    $0x4048,%rax
    0.00 :	     ab8:       00 48                   mov    (%rax),%eax
    0.00 :	     aba:       8b 83                   mov    %eax,%eax
    0.00 :	     abc:       70 05 00                add    %rdx,%rax
    0.00 :	     abf:       00 48 05 40 40 00 00    mov    0xa48(%rbx),%rdx
    0.00 :	     ac6:       8b 00 89 c0 48 01 d0    mov    %rax,0xa40(%rbx)
    0.00 :	     acd:       48 8b 93 40 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ad4:       48 89 83 38 0a 00       add    $0x404c,%rax
    0.00 :	     ada:       00 48                   mov    (%rax),%eax
    0.00 :	     adc:       8b 83                   mov    %eax,%eax
    0.00 :	     ade:       70 05 00                add    %rdx,%rax
    0.00 :	     ae1:       00 48 05 48 40 00 00    mov    0xa50(%rbx),%rdx
    0.00 :	     ae8:       8b 00 89 c0 48 01 d0    mov    %rax,0xa48(%rbx)
    0.00 :	     aef:       48 8b 93 48 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     af6:       48 89 83 40 0a 00       add    $0x4050,%rax
    0.00 :	     afc:       00 48                   mov    (%rax),%eax
    0.00 :	     afe:       8b 83                   mov    %eax,%eax
    0.00 :	     b00:       70 05 00                add    %rdx,%rax
    0.00 :	     b03:       00 48 05 4c 40 00 00    mov    0xa58(%rbx),%rdx
    0.00 :	     b0a:       8b 00 89 c0 48 01 d0    mov    %rax,0xa50(%rbx)
    0.00 :	     b11:       48 8b 93 50 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b18:       48 89 83 48 0a 00       add    $0x4054,%rax
    0.00 :	     b1e:       00 48                   mov    (%rax),%eax
    0.00 :	     b20:       8b 83                   mov    %eax,%eax
    0.00 :	     b22:       70 05 00                add    %rdx,%rax
    0.00 :	     b25:       00 48 05 50 40 00 00    mov    0xa60(%rbx),%rdx
    0.00 :	     b2c:       8b 00 89 c0 48 01 d0    mov    %rax,0xa58(%rbx)
    0.00 :	     b33:       48 8b 93 58 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b3a:       48 89 83 50 0a 00       add    $0x4058,%rax
    0.00 :	     b40:       00 48                   mov    (%rax),%eax
    0.00 :	     b42:       8b 83                   mov    %eax,%eax
    0.00 :	     b44:       70 05 00                add    %rdx,%rax
    0.00 :	     b47:       00 48 05 54 40 00 00    mov    0xab0(%rbx),%rdx
    0.00 :	     b4e:       8b 00 89 c0 48 01 d0    mov    %rax,0xa60(%rbx)
    0.00 :	     b55:       48 8b 93 60 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b5c:       48 89 83 58 0a 00       add    $0x4080,%rax
    0.00 :	     b62:       00 48                   mov    (%rax),%eax
    0.00 :	     b64:       8b 83                   mov    %eax,%eax
    0.00 :	     b66:       70 05 00                add    %rdx,%rax
    0.00 :	     b69:       00 48 05 58 40 00 00    mov    0xac0(%rbx),%rdx
    0.00 :	     b70:       8b 00 89 c0 48 01 d0    mov    %rax,0xab0(%rbx)
    0.00 :	     b77:       48 8b 93 b0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b7e:       48 89 83 60 0a 00       add    $0x4090,%rax
    0.00 :	     b84:       00 48                   mov    (%rax),%eax
    0.00 :	     b86:       8b 83                   mov    %eax,%eax
    0.00 :	     b88:       70 05 00                add    %rdx,%rax
    0.00 :	     b8b:       00 48 05 80 40 00 00    mov    %rax,0xac0(%rbx)
    0.00 :	     b92:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     b99:       48 8b 93 c0 0a 00       add    $0x4094,%rax
    0.00 :	     b9f:       00 48                   mov    (%rax),%eax
    0.00 :	     ba1:       89 83 b0 0a 00 00 48    mov    0x570(%rbx),%rax
    0.00 :	     ba8:       8b 83 70 05 00 00 48    mov    0xac8(%rbx),%rdx
    0.00 :	     baf:       05 90 40 00 00 8b       add    $0x40a0,%rax
    0.00 :	     bb5:       00 89                   mov    (%rax),%eax
    0.00 :	     bb7:       c0 48                   mov    %eax,%eax
    0.00 :	     bb9:       01 d0 48                add    %rdx,%rax
    0.00 :	     bbc:       89 83 c0 0a 00 00 48    mov    0xad0(%rbx),%rdx
    0.00 :	     bc3:       8b 83 70 05 00 00 48    mov    %rax,0xac8(%rbx)
    0.00 :	     bca:       05 94 40 00 00 8b 00    mov    0x570(%rbx),%rax
    0.00 :	     bd1:       48 8b 83 70 05 00       add    $0x40a4,%rax
    0.00 :	     bd7:       00 48                   mov    (%rax),%eax
    0.00 :	     bd9:       8b 93                   mov    %eax,%eax
    0.00 :	     bdb:       c8 0a 00                add    %rdx,%rax
    0.00 :	     bde:       00 48 05 a0 40 00 00    mov    0xad8(%rbx),%rdx
    0.00 :	     be5:       8b 00 89 c0 48 01 d0    mov    %rax,0xad0(%rbx)
    0.00 :	     bec:       48 8b 93 d0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     bf3:       48 89 83 c8 0a 00       add    $0x40a8,%rax
    0.00 :	     bf9:       00 48                   mov    (%rax),%eax
    0.00 :	     bfb:       8b 83                   mov    %eax,%eax
    0.00 :	     bfd:       70 05 00                add    %rdx,%rax
    0.00 :	     c00:       00 48 05 a4 40 00 00    mov    0xae8(%rbx),%rdx
    0.00 :	     c07:       8b 00 89 c0 48 01 d0    mov    %rax,0xad8(%rbx)
    0.00 :	     c0e:       48 8b 93 d8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c15:       48 89 83 d0 0a 00       add    $0x40b0,%rax
    0.00 :	     c1b:       00 48                   mov    (%rax),%eax
    0.00 :	     c1d:       8b 83                   mov    %eax,%eax
    0.00 :	     c1f:       70 05 00                add    %rdx,%rax
    0.00 :	     c22:       00 48 05 a8 40 00 00    mov    0xb08(%rbx),%rdx
    0.00 :	     c29:       8b 00 89 c0 48 01 d0    mov    %rax,0xae8(%rbx)
    0.00 :	     c30:       48 8b 93 e8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c37:       48 89 83 d8 0a 00       add    $0x40c4,%rax
    0.00 :	     c3d:       00 48                   mov    (%rax),%eax
    0.00 :	     c3f:       8b 83                   mov    %eax,%eax
    0.00 :	     c41:       70 05 00                add    %rdx,%rax
    0.00 :	     c44:       00 48 05 b0 40 00 00    mov    0xb10(%rbx),%rdx
    0.00 :	     c4b:       8b 00 89 c0 48 01 d0    mov    %rax,0xb08(%rbx)
    0.00 :	     c52:       48 8b 93 08 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c59:       48 89 83 e8 0a 00       add    $0x40cc,%rax
    0.00 :	     c5f:       00 48                   mov    (%rax),%eax
    0.00 :	     c61:       8b 83                   mov    %eax,%eax
    0.00 :	     c63:       70 05 00                add    %rdx,%rax
    0.00 :	     c66:       00 48 05 c4 40 00 00    mov    0xb18(%rbx),%rdx
    0.00 :	     c6d:       8b 00 89 c0 48 01 d0    mov    %rax,0xb10(%rbx)
    0.00 :	     c74:       48 8b 93 10 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c7b:       48 89 83 08 0b 00       add    $0x40d0,%rax
    0.00 :	     c81:       00 48                   mov    (%rax),%eax
    0.00 :	     c83:       8b 83                   mov    %eax,%eax
    0.00 :	     c85:       70 05 00                add    %rdx,%rax
    0.00 :	     c88:       00 48 05 cc 40 00 00    mov    0xb28(%rbx),%rdx
    0.00 :	     c8f:       8b 00 89 c0 48 01 d0    mov    %rax,0xb18(%rbx)
    0.00 :	     c96:       48 8b 93 18 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c9d:       48 89 83 10 0b 00       add    $0x40d8,%rax
    0.00 :	     ca3:       00 48                   mov    (%rax),%eax
    0.00 :	     ca5:       8b 83                   mov    %eax,%eax
    0.00 :	     ca7:       70 05 00                add    %rdx,%rax
    0.00 :	     caa:       00 48 05 d0 40 00 00    mov    0xb30(%rbx),%rdx
    0.00 :	     cb1:       8b 00 89 c0 48 01 d0    mov    %rax,0xb28(%rbx)
    0.00 :	     cb8:       48 8b 93 28 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     cbf:       48 89 83 18 0b 00       add    $0x40dc,%rax
    0.00 :	     cc5:       00 48                   mov    (%rax),%eax
    0.00 :	     cc7:       8b 83                   mov    %eax,%eax
    0.00 :	     cc9:       70 05 00                add    %rdx,%rax
    0.00 :	     ccc:       00 48 05 d8 40 00 00    mov    0xb38(%rbx),%rdx
    0.00 :	     cd3:       8b 00 89 c0 48 01 d0    mov    %rax,0xb30(%rbx)
    0.00 :	     cda:       48 8b 93 30 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ce1:       48 89 83 28 0b 00       add    $0x40e0,%rax
    0.00 :	     ce7:       00 48                   mov    (%rax),%eax
    0.00 :	     ce9:       8b 83                   mov    %eax,%eax
    0.00 :	     ceb:       70 05 00                add    %rdx,%rax
    0.00 :	     cee:       00 48 05 dc 40 00 00    mov    0xb40(%rbx),%rdx
    0.00 :	     cf5:       8b 00 89 c0 48 01 d0    mov    %rax,0xb38(%rbx)
    0.00 :	     cfc:       48 8b 93 38 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d03:       48 89 83 30 0b 00       add    $0x40e4,%rax
    0.00 :	     d09:       00 48                   mov    (%rax),%eax
    0.00 :	     d0b:       8b 83                   mov    %eax,%eax
    0.00 :	     d0d:       70 05 00                add    %rdx,%rax
    0.00 :	     d10:       00 48 05 e0 40 00 00    mov    0xb48(%rbx),%rdx
    0.00 :	     d17:       8b 00 89 c0 48 01 d0    mov    %rax,0xb40(%rbx)
    0.00 :	     d1e:       48 8b 93 40 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d25:       48 89 83 38 0b 00       add    $0x40e8,%rax
    0.00 :	     d2b:       00 48                   mov    (%rax),%eax
    0.00 :	     d2d:       8b 83                   mov    %eax,%eax
    0.00 :	     d2f:       70 05 00                add    %rdx,%rax
    0.00 :	     d32:       00 48 05 e4 40 00 00    mov    0xb50(%rbx),%rdx
    0.00 :	     d39:       8b 00 89 c0 48 01 d0    mov    %rax,0xb48(%rbx)
    0.00 :	     d40:       48 8b 93 48 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d47:       48 89 83 40 0b 00       add    $0x40ec,%rax
    0.00 :	     d4d:       00 48                   mov    (%rax),%eax
 ??:0
  100.00 :	     d4f:       8b 83                   mov    %eax,%eax
    0.00 :	     d51:       70 05 00                add    %rdx,%rax
    0.00 :	     d54:       00 48 05 e8 40 00 00    mov    0xb58(%rbx),%rdx
    0.00 :	     d5b:       8b 00 89 c0 48 01 d0    mov    %rax,0xb50(%rbx)
    0.00 :	     d62:       48 8b 93 50 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d69:       48 89 83 48 0b 00       add    $0x40f0,%rax
    0.00 :	     d6f:       00 48                   mov    (%rax),%eax
    0.00 :	     d71:       8b 83                   mov    %eax,%eax
    0.00 :	     d73:       70 05 00                add    %rdx,%rax
    0.00 :	     d76:       00 48 05 ec 40 00 00    mov    0xb60(%rbx),%rdx
    0.00 :	     d7d:       8b 00 89 c0 48 01 d0    mov    %rax,0xb58(%rbx)
    0.00 :	     d84:       48 8b 93 58 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d8b:       48 89 83 50 0b 00       add    $0x40f4,%rax
    0.00 :	     d91:       00 48                   mov    (%rax),%eax
    0.00 :	     d93:       8b 83                   mov    %eax,%eax
    0.00 :	     d95:       70 05 00                add    %rdx,%rax
    0.00 :	     d98:       00 48 05 f0 40 00 00    mov    0xb20(%rbx),%rdx
    0.00 :	     d9f:       8b 00 89 c0 48 01 d0    mov    %rax,0xb60(%rbx)
    0.00 :	     da6:       48 8b 93 60 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     dad:       48 89 83 58 0b 00       add    $0x40d4,%rax
    0.00 :	     db3:       00 48                   mov    (%rax),%eax
    0.00 :	     db5:       8b 83                   mov    %eax,%eax
    0.00 :	     db7:       70 05 00                add    %rdx,%rax
    0.00 :	     dba:       00 48 05 f4 40 00 00    mov    0xa10(%rbx),%rdx
    0.00 :	     dc1:       8b 00 89 c0 48 01 d0    mov    %rax,0xb20(%rbx)
    0.00 :	     dc8:       48 8b 93 20 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     dcf:       48 89 83 60 0b 00       add    $0x4028,%rax
    0.00 :	     dd5:       00 48                   mov    (%rax),%eax
    0.00 :	     dd7:       8b 83                   mov    %eax,%eax
    0.00 :	     dd9:       70 05 00                add    %rdx,%rax
    0.00 :	     ddc:       00 48 05 d4 40 00 00    mov    0x9d0(%rbx),%rdx
    0.00 :	     de3:       8b 00 89 c0 48 01 d0    mov    %rax,0xa10(%rbx)
    0.00 :	     dea:       48 8b 93 10 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     df1:       48 89 83 20 0b 00       add    $0x4004,%rax
    0.00 :	     df7:       00 48                   mov    (%rax),%eax
    0.00 :	     df9:       8b 83                   mov    %eax,%eax
    0.00 :	     dfb:       70 05 00                add    %rdx,%rax
    0.00 :	     dfe:       00 48 05 28 40 00 00    mov    %rax,0x9d0(%rbx)
    0.00 :	     e05:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     e0c:       48 8b 93 d0             add    $0x18,%rax
    0.00 :	     e10:       09 00                   mov    (%rax),%eax
    0.00 :	     e12:       00 48 89 83 10          test   $0xc00000,%eax
    0.00 :	     e17:       0a 00                   jne    e6c <dma_unmap_page+0xe3c>
    0.00 :	     e19:       00 48 8b 83 70 05 00    mov    0x570(%rbx),%rax
    0.00 :	     e20:       00 48 05 04 40 00 00    mov    0x9e0(%rbx),%rdx
    0.00 :	     e27:       8b 00 89 c0 48 01       add    $0x400c,%rax
    0.00 :	     e2d:       d0 48                   mov    (%rax),%eax
    0.00 :	     e2f:       89 83                   mov    %eax,%eax
    0.00 :	     e31:       d0 09 00                add    %rdx,%rax
    0.00 :	     e34:       00 48 8b 83 70 05 00    mov    %rax,0x9e0(%rbx)
    0.00 :	     e3b:       00 48 83 c0 18 8b       mov    0x5e4(%rbx),%eax
    0.00 :	     e41:       00 a9 00                sub    $0x5,%eax
    0.00 :	     e44:       00 c0 00                cmp    $0x1,%eax
    0.00 :	     e47:       75 53                   jbe    e6c <dma_unmap_page+0xe3c>
    0.00 :	     e49:       48 8b 83 70 05 00 00    mov    0x570(%rbx),%rdx
    0.00 :	     e50:       48 8b 93 e0 09 00 00    mov    0xa20(%rbx),%rax
    0.00 :	     e57:       48 05 0c 40 00 00 8b    add    $0x4034,%rdx
    0.00 :	     e5e:       00 89                   mov    (%rdx),%edx
    0.00 :	     e60:       c0 48                   mov    %edx,%edx
    0.00 :	     e62:       01 d0 48                add    %rax,%rdx
    0.00 :	     e65:       89 83 e0 09 00 00 8b    mov    %rdx,0xa20(%rbx)
    0.00 :	     e6c:       83 e4 05 00 00 83 e8    mov    0x570(%rbx),%rax
    0.00 :	     e73:       05 83 f8 01 76 23 48    mov    0xb68(%rbx),%rdx
    0.00 :	     e7a:       8b 93 70 05 00 00       add    $0x40f8,%rax
    0.00 :	     e80:       48 8b                   mov    (%rax),%eax
    0.00 :	     e82:       83 20                   mov    %eax,%eax
    0.00 :	     e84:       0a 00 00                add    %rdx,%rax
    0.00 :	     e87:       48 81 c2 34 40 00 00    mov    0xb70(%rbx),%rdx
    0.00 :	     e8e:       8b 12 89 d2 48 01 c2    mov    %rax,0xb68(%rbx)
    0.00 :	     e95:       48 89 93 20 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     e9c:       48 8b 83 70 05 00       add    $0x40fc,%rax
    0.00 :	     ea2:       00 48                   mov    (%rax),%eax
    0.00 :	     ea4:       8b 93                   mov    %eax,%eax
    0.00 :	     ea6:       68 0b 00                add    %rdx,%rax
    0.00 :	     ea9:       00 48 05 f8 40 00 00    mov    0xb78(%rbx),%rdx
    0.00 :	     eb0:       8b 00 89 c0 48 01 d0    mov    %rax,0xb70(%rbx)
    0.00 :	     eb7:       48 8b 93 70 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ebe:       48 89 83 68 0b 00       add    $0x4100,%rax
    0.00 :	     ec4:       00 48                   mov    (%rax),%eax
    0.00 :	     ec6:       8b 83                   mov    %eax,%eax
    0.00 :	     ec8:       70 05 00                add    %rdx,%rax
    0.00 :	     ecb:       00 48 05 fc 40 00 00    mov    0xbb8(%rbx),%rdx
    0.00 :	     ed2:       8b 00 89 c0 48 01 d0    mov    %rax,0xb78(%rbx)
    0.00 :	     ed9:       48 8b 93 78 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ee0:       48 89 83 70 0b 00       add    $0x4124,%rax
    0.00 :	     ee6:       00 48                   mov    (%rax),%eax
    0.00 :	     ee8:       8b 83                   mov    %eax,%eax
    0.00 :	     eea:       70 05 00                add    %rdx,%rax
    0.00 :	     eed:       00 48 05 00 41 00 00    mov    0xb80(%rbx),%rdx
    0.00 :	     ef4:       8b 00 89 c0 48 01 d0    mov    %rax,0xbb8(%rbx)
    0.00 :	     efb:       48 8b 93 b8 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f02:       48 89 83 78 0b 00       add    $0x4104,%rax
    0.00 :	     f08:       00 48                   mov    (%rax),%eax
    0.00 :	     f0a:       8b 83                   mov    %eax,%eax
    0.00 :	     f0c:       70 05 00                add    %rdx,%rax
    0.00 :	     f0f:       00 48 05 24 41 00 00    mov    0xb88(%rbx),%rdx
    0.00 :	     f16:       8b 00 89 c0 48 01 d0    mov    %rax,0xb80(%rbx)
    0.00 :	     f1d:       48 8b 93 80 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f24:       48 89 83 b8 0b 00       add    $0x4108,%rax
    0.00 :	     f2a:       00 48                   mov    (%rax),%eax
    0.00 :	     f2c:       8b 83                   mov    %eax,%eax
    0.00 :	     f2e:       70 05 00                add    %rdx,%rax
    0.00 :	     f31:       00 48 05 04 41 00 00    mov    0xb90(%rbx),%rdx
    0.00 :	     f38:       8b 00 89 c0 48 01 d0    mov    %rax,0xb88(%rbx)
    0.00 :	     f3f:       48 8b 93 88 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f46:       48 89 83 80 0b 00       add    $0x410c,%rax
    0.00 :	     f4c:       00 48                   mov    (%rax),%eax
    0.00 :	     f4e:       8b 83                   mov    %eax,%eax
    0.00 :	     f50:       70 05 00                add    %rdx,%rax
    0.00 :	     f53:       00 48 05 08 41 00 00    mov    0xb98(%rbx),%rdx
    0.00 :	     f5a:       8b 00 89 c0 48 01 d0    mov    %rax,0xb90(%rbx)
    0.00 :	     f61:       48 8b 93 90 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f68:       48 89 83 88 0b 00       add    $0x4110,%rax
    0.00 :	     f6e:       00 48                   mov    (%rax),%eax
    0.00 :	     f70:       8b 83                   mov    %eax,%eax
    0.00 :	     f72:       70 05 00                add    %rdx,%rax
    0.00 :	     f75:       00 48 05 0c 41 00 00    mov    0xba0(%rbx),%rdx
    0.00 :	     f7c:       8b 00 89 c0 48 01 d0    mov    %rax,0xb98(%rbx)
    0.00 :	     f83:       48 8b 93 98 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f8a:       48 89 83 90 0b 00       add    $0x4118,%rax
    0.00 :	     f90:       00 48                   mov    (%rax),%eax
    0.00 :	     f92:       8b 83                   mov    %eax,%eax
    0.00 :	     f94:       70 05 00                add    %rdx,%rax
    0.00 :	     f97:       00 48 05 10 41 00 00    mov    0xba8(%rbx),%rdx
    0.00 :	     f9e:       8b 00 89 c0 48 01 d0    mov    %rax,0xba0(%rbx)
    0.00 :	     fa5:       48 8b 93 a0 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     fac:       48 89 83 98 0b 00       add    $0x411c,%rax
    0.00 :	     fb2:       00 48                   mov    (%rax),%eax
    0.00 :	     fb4:       8b 83                   mov    %eax,%eax
    0.00 :	     fb6:       70 05 00                add    %rdx,%rax
    0.00 :	     fb9:       00 48 05 18 41 00 00    mov    0xbb0(%rbx),%rdx
    0.00 :	     fc0:       8b 00 89 c0 48 01 d0    mov    %rax,0xba8(%rbx)
    0.00 :	     fc7:       48 8b 93 a8 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     fce:       48 89 83 a0 0b 00       add    $0x4120,%rax
    0.00 :	     fd4:       00 48                   mov    (%rax),%eax
    0.00 :	     fd6:       8b 83                   mov    %eax,%eax
    0.00 :	     fd8:       70 05 00                add    %rdx,%rax
    0.00 :	     fdb:       00 48 05 1c 41 00 00    mov    %rax,0xbb0(%rbx)
    0.00 :	     fe2:       8b 00 89 c0 48 01 d0    mov    0xaa8(%rbx),%rax
    0.00 :	     fe9:       48 8b 93 b0             mov    %rax,0x40(%rsi)
    0.00 :	     fed:       0b 00 00 48 89 83 a8    mov    0xa10(%rbx),%rax
    0.00 :	     ff4:       0b 00 00 48             mov    %rax,0x48(%rsi)
    0.00 :	     ff8:       8b 83 70 05 00 00 48    mov    0x9c8(%rbx),%rax
    0.00 :	     fff:       05 20 41 00 00 8b 00    add    0x9e0(%rbx),%rax
    0.00 :	    1006:       89 c0 48 01 d0 48 89    add    0x9d0(%rbx),%rax
    0.00 :	    100d:       83 b0 0b 00 00 48 8b    add    0xad0(%rbx),%rax
    0.00 :	    1014:       83 a8 0a 00 00 48 89    add    0xae0(%rbx),%rax
    0.00 :	    101b:       46 40 48 8b 83 10 0a    add    0xa30(%rbx),%rax
    0.00 :	    1022:       00 00 48 89             mov    %rax,0x20(%rsi)
    0.00 :	    1026:       46 48 48 8b 83 c8 09    mov    0xae0(%rbx),%rax
    0.00 :	    102d:       00 00 48 03 83 e0 09    add    0xad0(%rbx),%rax
    0.00 :	    1034:       00 00 48 03             mov    %rax,0x50(%rsi)
    0.00 :	    1038:       83 d0 09 00 00 48 03    mov    0x9c8(%rbx),%rax
    0.00 :	    103f:       83 d0 0a 00             mov    %rax,0x60(%rsi)
    0.00 :	    1043:       00 48 03 83 e0 0a 00    mov    0x9d0(%rbx),%rax
    0.00 :	    104a:       00 48 03 83             mov    %rax,0x68(%rsi)
    0.00 :	    104e:       30 0a 00 00 48 89 46    mov    0x9e8(%rbx),%rax
    0.00 :	    1055:       20 48 8b 83             mov    %rax,0x78(%rsi)
    0.00 :	    1059:       e0 0a 00 00 48 03 83    mov    0xa08(%rbx),%rax
    0.00 :	    1060:       d0 0a 00 00 48 89 46    add    0x9f8(%rbx),%rax
    0.00 :	    1067:       50 48 8b 83             mov    %rax,0x28(%rsi)
    0.00 :	    106b:       c8 09 00 00 48 89 46    mov    0x9f8(%rbx),%rax
    0.00 :	    1072:       60 48 8b 83 d0 09 00    mov    %rax,0x80(%rsi)
    0.00 :	    1079:       00 48 89 46 68 48 8b    mov    0xa08(%rbx),%rax
    0.00 :	    1080:       83 e8 09 00 00 48 89    mov    %rax,0xa0(%rsi)
    0.00 :	    1087:       46 78 48 8b 83 08 0a    mov    0xa20(%rbx),%rax
    0.00 :	    108e:       00 00 48 03 83 f8 09    mov    %rax,0x88(%rsi)
    0.00 :	    1095:       00 00 48 89 46 28 48    cmpl   $0x1,0x8bc(%rbx)
    0.00 :	    109c:       8b 83 f8 09 00 00       je     11b0 <dma_unmap_page+0x1180>
    0.00 :	    10a2:       48 89 86 80 00 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10a9:       48 8b 83 08 0a 00 00    mov    0xb00(%rbx),%rdx
    0.00 :	    10b0:       48 89 86 a0 00 00       add    $0x40bc,%rax
    0.00 :	    10b6:       00 48                   mov    (%rax),%eax
    0.00 :	    10b8:       8b 83                   mov    %eax,%eax
    0.00 :	    10ba:       20 0a 00                add    %rdx,%rax
    0.00 :	    10bd:       00 48 89 86 88 00 00    mov    0xaf0(%rbx),%rdx
    0.00 :	    10c4:       00 83 bb bc 08 00 00    mov    %rax,0xb00(%rbx)
    0.00 :	    10cb:       01 0f 84 0e 01 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10d2:       48 8b 83 70 05 00       add    $0x40b4,%rax
    0.00 :	    10d8:       00 48                   mov    (%rax),%eax
    0.00 :	    10da:       8b 93                   mov    %eax,%eax
    0.00 :	    10dc:       00 0b 00                add    %rdx,%rax
    0.00 :	    10df:       00 48 05 bc 40 00 00    mov    0xaf8(%rbx),%rdx
    0.00 :	    10e6:       8b 00 89 c0 48 01 d0    mov    %rax,0xaf0(%rbx)
    0.00 :	    10ed:       48 8b 93 f0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10f4:       48 89 83 00 0b 00       add    $0x40b8,%rax
    0.00 :	    10fa:       00 48                   mov    (%rax),%eax
    0.00 :	    10fc:       8b 83                   mov    %eax,%eax
    0.00 :	    10fe:       70 05 00                add    %rdx,%rax
    0.00 :	    1101:       00 48 05 b4 40 00 00    mov    %rax,0xaf8(%rbx)
    0.00 :	    1108:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	    110f:       48 8b 93 f8 0a 00       add    $0x5820,%rax
    0.00 :	    1115:       00 48                   mov    (%rax),%eax
    0.00 :	    1117:       89 83 f0 0a 00          test   $0x10000000,%eax
    0.00 :	    111c:       00 48 8b 83 70 05       je     722 <dma_unmap_page+0x6f2>
    0.00 :	    1122:       00 00 48 05 b8 40 00    mov    0x570(%rbx),%rax
    0.00 :	    1129:       00 8b 00 89 c0 48 01    mov    0xc28(%rbx),%rdx
    0.00 :	    1130:       d0 48 89 83 f8 0a       add    $0x8fe4,%rax
    0.00 :	    1136:       00 00                   mov    (%rax),%eax
    0.00 :	    1138:       48 8b                   mov    %eax,%eax
    0.00 :	    113a:       83 70 05                add    %rdx,%rax
    0.00 :	    113d:       00 00 48 05 20 58 00    mov    0xc30(%rbx),%rdx
    0.00 :	    1144:       00 8b 00 a9 00 00 00    mov    %rax,0xc28(%rbx)
    0.00 :	    114b:       10 0f 84 00 f6 ff ff    mov    0x570(%rbx),%rax
    0.00 :	    1152:       48 8b 83 70 05 00       add    $0x415c,%rax
    0.00 :	    1158:       00 48                   mov    (%rax),%eax
    0.00 :	    115a:       8b 93                   mov    %eax,%eax
    0.00 :	    115c:       28 0c 00                add    %rdx,%rax
    0.00 :	    115f:       00 48 05 e4 8f 00 00    mov    0xc38(%rbx),%rdx
    0.00 :	    1166:       8b 00 89 c0 48 01 d0    mov    %rax,0xc30(%rbx)
    0.00 :	    116d:       48 8b 93 30 0c 00 00    mov    0x570(%rbx),%rax
    0.00 :	    1174:       48 89 83 28 0c 00       add    $0x8fe0,%rax
    0.00 :	    117a:       00 48                   mov    (%rax),%eax
    0.00 :	    117c:       8b 83                   mov    %eax,%eax
    0.00 :	    117e:       70 05 00                add    %rdx,%rax
    0.00 :	    1181:       00 48 05 5c 41 00 00    mov    0xc40(%rbx),%rdx
    0.00 :	    1188:       8b 00 89 c0 48 01 d0    mov    %rax,0xc38(%rbx)
    0.00 :	    118f:       48 8b 93 38 0c 00 00    mov    0x570(%rbx),%rax
    0.00 :	    1196:       48 89 83 30 0c 00       add    $0x4158,%rax
    0.00 :	    119c:       00 48                   mov    (%rax),%eax
    0.00 :	    119e:       8b 83                   mov    %eax,%eax
    0.00 :	    11a0:       70 05 00                add    %rdx,%rax
    0.00 :	    11a3:       00 48 05 e0 8f 00 00    mov    %rax,0xc40(%rbx)
    0.00 :	    11aa:       8b 00 89 c0             add    $0x10,%rsp
    0.00 :	    11ae:       48                      pop    %rbx
    0.00 :	    11af:       01                      retq   
    0.00 :	    11b0:       d0 48 8b 93 40 0c 00    cmpw   $0x3e8,0x3f8(%rbx)
    0.00 :	    11b7:       00 48 
    0.00 :	    11b9:       89 83 38 0c 00 00       jne    10a2 <dma_unmap_page+0x1072>
    0.00 :	    11bf:       48 8b 83 70 05 00 00    mov    0x860(%rbx),%rax
    0.00 :	    11c6:       48 05 58                test   %rax,%rax
    0.00 :	    11c9:       41 00                   je     11e6 <dma_unmap_page+0x11b6>
    0.00 :	    11cb:       00 8b 00 89 c0          lea    0xe(%rsp),%rdx
    0.00 :	    11d0:       48 01 d0 48 89 83 40    lea    0x568(%rbx),%rdi
    0.00 :	    11d7:       0c 00 00 48 83          mov    $0xa,%esi
    0.00 :	    11dc:       c4 10                   callq  *%rax
    0.00 :	    11de:       5b c3                   test   %eax,%eax
    0.00 :	    11e0:       66 81 bb f8 03 00       jne    10a2 <dma_unmap_page+0x1072>
    0.00 :	    11e6:       00 e8 03 0f 85          movzbl 0xe(%rsp),%eax
    0.00 :	    11eb:       e3 fe ff ff 48          mov    %ax,0xe(%rsp)
    0.00 :	    11f0:       8b 83 60                movzwl %ax,%eax
    0.00 :	    11f3:       08 00 00 48 85 c0       add    %eax,0xcf8(%rbx)
    0.00 :	    11f9:       74 1b 48 8d 54          jmpq   10a2 <dma_unmap_page+0x1072>
         :	    11fe:       24 0e                   xchg   %ax,%ax
         :	    1200:       48 8d bb 68             sub    $0x18,%rsp
         :	    1204:       05 00 00 be             mov    %rbx,(%rsp)
         :	    1208:       0a 00 00 00 ff          mov    %rbp,0x8(%rsp)
         :	    120d:       d0 85 c0                mov    %rdi,%rbx
         :	    1210:       0f 85 bc fe ff          mov    %r12,0x10(%rsp)
         :	    1215:       ff 0f b6 44             mov    0x20(%rdi),%rsi
         :	    1219:       24 0e 66                mov    (%rdi),%rbp
         :	    121c:       89 44 24                test   %rsi,%rsi
         :	    121f:       0e 0f b7 c0 01 83       je     13b0 <dma_unmap_page+0x1380>
         :	    1225:       f8 0c 00 00 e9 a4 fe    testb  $0x3,0x220(%rbp)
         :	    122c:       ff ff                   je     127b <dma_unmap_page+0x124b>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------
