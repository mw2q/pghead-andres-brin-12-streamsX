
Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
   23.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1828
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1832
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1815
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1818
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1819
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1832
    1.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1819
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000075e1e0 <bttextfastcmp_c>:
         :	/*
         :	 * sortsupport comparison func (for C locale case)
         :	 */
         :	static int
         :	bttextfastcmp_c(Datum x, Datum y, SortSupport ssup)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1806
    1.67 :	  75e1e0:       55                      push   %rbp
    1.67 :	  75e1e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  75e1e4:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    1.67 :	  75e1e8:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    1.67 :	  75e1ec:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  75e1f0:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  75e1f4:       49 89 f7                mov    %rsi,%r15
    0.00 :	  75e1f7:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    1.67 :	  75e1fb:       48 83 ec 30             sub    $0x30,%rsp
    0.00 :	  75e1ff:       49 89 fe                mov    %rdi,%r14
         :	        text       *arg1 = DatumGetTextPP(x);
    0.00 :	  75e202:       e8 d9 0a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        text       *arg2 = DatumGetTextPP(y);
    0.00 :	  75e207:       4c 89 ff                mov    %r15,%rdi
         :	 * sortsupport comparison func (for C locale case)
         :	 */
         :	static int
         :	bttextfastcmp_c(Datum x, Datum y, SortSupport ssup)
         :	{
         :	        text       *arg1 = DatumGetTextPP(x);
    0.00 :	  75e20a:       49 89 c4                mov    %rax,%r12
         :	        text       *arg2 = DatumGetTextPP(y);
    0.00 :	  75e20d:       e8 ce 0a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	                           *a2p;
         :	        int                     len1,
         :	                                len2,
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
    0.00 :	  75e212:       41 0f b6 14 24          movzbl (%r12),%edx
         :	 */
         :	static int
         :	bttextfastcmp_c(Datum x, Datum y, SortSupport ssup)
         :	{
         :	        text       *arg1 = DatumGetTextPP(x);
         :	        text       *arg2 = DatumGetTextPP(y);
    0.00 :	  75e217:       49 89 c5                mov    %rax,%r13
         :	                           *a2p;
         :	        int                     len1,
         :	                                len2,
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1815
    1.67 :	  75e21a:       4d 8d 4c 24 01          lea    0x1(%r12),%r9
         :	        a2p = VARDATA_ANY(arg2);
    0.00 :	  75e21f:       41 0f b6 4d 00          movzbl 0x0(%r13),%ecx
         :	                           *a2p;
         :	        int                     len1,
         :	                                len2,
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
    0.00 :	  75e224:       49 8d 44 24 04          lea    0x4(%r12),%rax
    0.00 :	  75e229:       be 01 00 00 00          mov    $0x1,%esi
         :	        a2p = VARDATA_ANY(arg2);
    0.00 :	  75e22e:       4d 8d 45 01             lea    0x1(%r13),%r8
    0.00 :	  75e232:       41 ba 01 00 00 00       mov    $0x1,%r10d
         :	                           *a2p;
         :	        int                     len1,
         :	                                len2,
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
    0.00 :	  75e238:       21 d6                   and    %edx,%esi
    0.00 :	  75e23a:       4c 0f 44 c8             cmove  %rax,%r9
         :	        a2p = VARDATA_ANY(arg2);
    0.00 :	  75e23e:       49 8d 45 04             lea    0x4(%r13),%rax
    0.00 :	  75e242:       41 21 ca                and    %ecx,%r10d
    0.00 :	  75e245:       4c 0f 44 c0             cmove  %rax,%r8
         :
         :	        len1 = VARSIZE_ANY_EXHDR(arg1);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1818
    1.67 :	  75e249:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  75e24c:       0f 84 ee 00 00 00       je     75e340 <bttextfastcmp_c+0x160>
    0.00 :	  75e252:       85 f6                   test   %esi,%esi
    0.00 :	  75e254:       0f 85 96 00 00 00       jne    75e2f0 <bttextfastcmp_c+0x110>
    0.00 :	  75e25a:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  75e25e:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  75e261:       83 e8 04                sub    $0x4,%eax
    0.00 :	  75e264:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :	        len2 = VARSIZE_ANY_EXHDR(arg2);
    0.00 :	  75e267:       80 f9 01                cmp    $0x1,%cl
    0.00 :	  75e26a:       0f 84 94 00 00 00       je     75e304 <bttextfastcmp_c+0x124>
    0.00 :	  75e270:       45 85 d2                test   %r10d,%r10d
    0.00 :	  75e273:       0f 84 b7 00 00 00       je     75e330 <bttextfastcmp_c+0x150>
    0.00 :	  75e279:       d0 e9                   shr    %cl
    0.00 :	  75e27b:       0f b6 c1                movzbl %cl,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1819
    1.67 :	  75e27e:       44 8d 58 ff             lea    -0x1(%rax),%r11d
         :
         :	        result = memcmp(a1p, a2p, Min(len1, len2));
    0.00 :	  75e282:       44 3b 5d d4             cmp    -0x2c(%rbp),%r11d
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 :	  75e286:       8b 4d d4                mov    -0x2c(%rbp),%ecx
    0.00 :	  75e289:       4c 89 ce                mov    %r9,%rsi
    3.33 :	  75e28c:       4c 89 c7                mov    %r8,%rdi
    1.67 :	  75e28f:       41 0f 4e cb             cmovle %r11d,%ecx
    0.00 :	  75e293:       48 63 c9                movslq %ecx,%rcx
    1.67 :	  75e296:       48 39 c9                cmp    %rcx,%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
   23.33 :	  75e299:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
   33.33 :	  75e29b:       0f 97 c2                seta   %dl
    6.67 :	  75e29e:       0f 92 c0                setb   %al
    0.00 :	  75e2a1:       89 d3                   mov    %edx,%ebx
    0.00 :	  75e2a3:       28 c3                   sub    %al,%bl
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1821
    3.33 :	  75e2a5:       0f be db                movsbl %bl,%ebx
         :	        if ((result == 0) && (len1 != len2))
    0.00 :	  75e2a8:       85 db                   test   %ebx,%ebx
    0.00 :	  75e2aa:       75 10                   jne    75e2bc <bttextfastcmp_c+0xdc>
    0.00 :	  75e2ac:       44 39 5d d4             cmp    %r11d,-0x2c(%rbp)
    0.00 :	  75e2b0:       74 0a                   je     75e2bc <bttextfastcmp_c+0xdc>
         :	                result = (len1 < len2) ? -1 : 1;
    0.00 :	  75e2b2:       0f 9d c0                setge  %al
    0.00 :	  75e2b5:       0f b6 d8                movzbl %al,%ebx
    0.00 :	  75e2b8:       8d 5c 1b ff             lea    -0x1(%rbx,%rbx,1),%ebx
         :
         :	        /* We can't afford to leak memory here. */
         :	        if (PointerGetDatum(arg1) != x)
    0.00 :	  75e2bc:       4d 39 f4                cmp    %r14,%r12
    0.00 :	  75e2bf:       74 08                   je     75e2c9 <bttextfastcmp_c+0xe9>
         :	                pfree(arg1);
    0.00 :	  75e2c1:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75e2c4:       e8 b7 a8 03 00          callq  798b80 <pfree>
         :	        if (PointerGetDatum(arg2) != y)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1828
    3.33 :	  75e2c9:       4d 39 fd                cmp    %r15,%r13
    0.00 :	  75e2cc:       74 08                   je     75e2d6 <bttextfastcmp_c+0xf6>
         :	                pfree(arg2);
    0.00 :	  75e2ce:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75e2d1:       e8 aa a8 03 00          callq  798b80 <pfree>
         :
         :	        return result;
         :	}
    0.00 :	  75e2d6:       89 d8                   mov    %ebx,%eax
    0.00 :	  75e2d8:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1832
    3.33 :	  75e2dc:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  75e2e0:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  75e2e4:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  75e2e8:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    1.67 :	  75e2ec:       c9                      leaveq 
    0.00 :	  75e2ed:       c3                      retq   
    0.00 :	  75e2ee:       66 90                   xchg   %ax,%ax
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
         :	        a2p = VARDATA_ANY(arg2);
         :
         :	        len1 = VARSIZE_ANY_EXHDR(arg1);
    0.00 :	  75e2f0:       d0 ea                   shr    %dl
    0.00 :	  75e2f2:       0f b6 c2                movzbl %dl,%eax
    0.00 :	  75e2f5:       83 e8 01                sub    $0x1,%eax
         :	        len2 = VARSIZE_ANY_EXHDR(arg2);
    0.00 :	  75e2f8:       80 f9 01                cmp    $0x1,%cl
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
         :	        a2p = VARDATA_ANY(arg2);
         :
         :	        len1 = VARSIZE_ANY_EXHDR(arg1);
    0.00 :	  75e2fb:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :	        len2 = VARSIZE_ANY_EXHDR(arg2);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1819
    1.67 :	  75e2fe:       0f 85 6c ff ff ff       jne    75e270 <bttextfastcmp_c+0x90>
    0.00 :	  75e304:       41 0f b6 45 01          movzbl 0x1(%r13),%eax
    0.00 :	  75e309:       41 bb 08 00 00 00       mov    $0x8,%r11d
    0.00 :	  75e30f:       3c 01                   cmp    $0x1,%al
    0.00 :	  75e311:       0f 84 6b ff ff ff       je     75e282 <bttextfastcmp_c+0xa2>
    0.00 :	  75e317:       3c 12                   cmp    $0x12,%al
    0.00 :	  75e319:       41 bb 01 00 00 00       mov    $0x1,%r11d
    0.00 :	  75e31f:       b8 10 00 00 00          mov    $0x10,%eax
    0.00 :	  75e324:       44 0f 44 d8             cmove  %eax,%r11d
    0.00 :	  75e328:       e9 55 ff ff ff          jmpq   75e282 <bttextfastcmp_c+0xa2>
    0.00 :	  75e32d:       0f 1f 00                nopl   (%rax)
    0.00 :	  75e330:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  75e334:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  75e337:       44 8d 58 fc             lea    -0x4(%rax),%r11d
    0.00 :	  75e33b:       e9 42 ff ff ff          jmpq   75e282 <bttextfastcmp_c+0xa2>
         :	                                result;
         :
         :	        a1p = VARDATA_ANY(arg1);
         :	        a2p = VARDATA_ANY(arg2);
         :
         :	        len1 = VARSIZE_ANY_EXHDR(arg1);
    0.00 :	  75e340:       41 0f b6 44 24 01       movzbl 0x1(%r12),%eax
    0.00 :	  75e346:       c7 45 d4 08 00 00 00    movl   $0x8,-0x2c(%rbp)
    0.00 :	  75e34d:       3c 01                   cmp    $0x1,%al
    0.00 :	  75e34f:       0f 84 12 ff ff ff       je     75e267 <bttextfastcmp_c+0x87>
    0.00 :	  75e355:       c7 45 d4 01 00 00 00    movl   $0x1,-0x2c(%rbp)
    0.00 :	  75e35c:       3c 12                   cmp    $0x12,%al
    0.00 :	  75e35e:       b8 10 00 00 00          mov    $0x10,%eax
    0.00 :	  75e363:       0f 45 45 d4             cmovne -0x2c(%rbp),%eax
    0.00 :	  75e367:       89 45 d4                mov    %eax,-0x2c(%rbp)
    0.00 :	  75e36a:       e9 f8 fe ff ff          jmpq   75e267 <bttextfastcmp_c+0x87>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

    9.80 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    7.84 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:326
    7.84 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:328
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:510
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:326
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:471
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:500
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:374
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:471
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    3.92 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:497
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:327
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:397
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:473
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:374
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:382
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:500
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:486
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:486
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:511
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:397
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:399
    1.96 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:399
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f990 <nocachegetattr>:
         :	 */
         :	Datum
         :	nocachegetattr(HeapTuple tuple,
         :	                           int attnum,
         :	                           TupleDesc tupleDesc)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:326
    3.92 :	  46f990:       55                      push   %rbp
         :	         *       2: Has a null or a var-width AFTER att.
         :	         *       3: Has nulls or var-widths BEFORE att.
         :	         * ----------------
         :	         */
         :
         :	        attnum--;
    0.00 :	  46f991:       44 8d 56 ff             lea    -0x1(%rsi),%r10d
         :	 */
         :	Datum
         :	nocachegetattr(HeapTuple tuple,
         :	                           int attnum,
         :	                           TupleDesc tupleDesc)
         :	{
    0.00 :	  46f995:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:326
    7.84 :	  46f998:       41 57                   push   %r15
    0.00 :	  46f99a:       41 56                   push   %r14
    0.00 :	  46f99c:       41 55                   push   %r13
    0.00 :	  46f99e:       41 54                   push   %r12
    0.00 :	  46f9a0:       53                      push   %rbx
    0.00 :	  46f9a1:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	  46f9a5:       48 89 7d c8             mov    %rdi,-0x38(%rbp)
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46f9a9:       48 8b 45 c8             mov    -0x38(%rbp),%rax
         :	 */
         :	Datum
         :	nocachegetattr(HeapTuple tuple,
         :	                           int attnum,
         :	                           TupleDesc tupleDesc)
         :	{
    0.00 :	  46f9ad:       48 89 d7                mov    %rdx,%rdi
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46f9b0:       4c 8b 40 10             mov    0x10(%rax),%r8
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:327
    1.96 :	  46f9b4:       4c 89 45 d0             mov    %r8,-0x30(%rbp)
         :	         * ----------------
         :	         */
         :
         :	        attnum--;
         :
         :	        if (!HeapTupleNoNulls(tuple))
    0.00 :	  46f9b8:       45 0f b7 48 14          movzwl 0x14(%r8),%r9d
         :	nocachegetattr(HeapTuple tuple,
         :	                           int attnum,
         :	                           TupleDesc tupleDesc)
         :	{
         :	        HeapTupleHeader tup = tuple->t_data;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:328
    7.84 :	  46f9bd:       4c 8b 7a 08             mov    0x8(%rdx),%r15
         :	         * ----------------
         :	         */
         :
         :	        attnum--;
         :
         :	        if (!HeapTupleNoNulls(tuple))
    0.00 :	  46f9c1:       41 f6 c1 01             test   $0x1,%r9b
    0.00 :	  46f9c5:       0f 84 25 01 00 00       je     46faf0 <nocachegetattr+0x160>
         :	                /*
         :	                 * there's a null somewhere in the tuple
         :	                 *
         :	                 * check to see if any preceding bits are null...
         :	                 */
         :	                int                     byte = attnum >> 3;
    0.00 :	  46f9cb:       44 89 d6                mov    %r10d,%esi
         :	                int                     finalbit = attnum & 0x07;
         :
         :	                /* check for nulls "before" final bit of last byte */
         :	                if ((~bp[byte]) & ((1 << finalbit) - 1))
    0.00 :	  46f9ce:       44 89 d1                mov    %r10d,%ecx
         :	                /*
         :	                 * there's a null somewhere in the tuple
         :	                 *
         :	                 * check to see if any preceding bits are null...
         :	                 */
         :	                int                     byte = attnum >> 3;
    0.00 :	  46f9d1:       c1 fe 03                sar    $0x3,%esi
         :	                int                     finalbit = attnum & 0x07;
         :
         :	                /* check for nulls "before" final bit of last byte */
         :	                if ((~bp[byte]) & ((1 << finalbit) - 1))
    0.00 :	  46f9d4:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46f9d7:       48 63 c6                movslq %esi,%rax
    0.00 :	  46f9da:       41 0f b6 54 00 17       movzbl 0x17(%r8,%rax,1),%edx
    0.00 :	  46f9e0:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  46f9e5:       d3 e0                   shl    %cl,%eax
    0.00 :	  46f9e7:       83 e8 01                sub    $0x1,%eax
    0.00 :	  46f9ea:       f7 d2                   not    %edx
    0.00 :	  46f9ec:       85 c2                   test   %eax,%edx
    0.00 :	  46f9ee:       0f 84 cc 00 00 00       je     46fac0 <nocachegetattr+0x130>
         :	                                }
         :	                        }
         :	                }
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46f9f4:       41 0f b6 40 16          movzbl 0x16(%r8),%eax
    0.00 :	  46f9f9:       4d 8d 1c 00             lea    (%r8,%rax,1),%r11
         :	                 */
         :	                if (HeapTupleHasVarWidth(tuple))
         :	                {
         :	                        int                     j;
         :
         :	                        for (j = 0; j <= attnum; j++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:397
    1.96 :	  46f9fd:       31 f6                   xor    %esi,%esi
    0.00 :	  46f9ff:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  46fa05:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  46fa08:       eb 2f                   jmp    46fa39 <nocachegetattr+0xa9>
    0.00 :	  46fa0a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * attcacheoff until we reach either a null or a var-width attribute.
         :	                 */
         :	                off = 0;
         :	                for (i = 0;; i++)               /* loop exit is at "break" */
         :	                {
         :	                        if (HeapTupleHasNulls(tuple) && att_isnull(i, bp))
    0.00 :	  46fa10:       44 89 e8                mov    %r13d,%eax
    0.00 :	  46fa13:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  46fa17:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  46fa1a:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46fa1d:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46fa20:       48 98                   cltq   
    0.00 :	  46fa22:       0f b6 44 02 17          movzbl 0x17(%rdx,%rax,1),%eax
    0.00 :	  46fa27:       d3 f8                   sar    %cl,%eax
    0.00 :	  46fa29:       a8 01                   test   $0x1,%al
    0.00 :	  46fa2b:       75 12                   jne    46fa3f <nocachegetattr+0xaf>
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
         :
         :	                        if (usecache && att[i]->attlen <= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    3.92 :	  46fa2d:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46fa30:       45 0f b7 48 14          movzwl 0x14(%r8),%r9d
         :	                 * then advance over the attr based on its length.  Nulls have no
         :	                 * storage and no alignment padding either.  We can use/set
         :	                 * attcacheoff until we reach either a null or a var-width attribute.
         :	                 */
         :	                off = 0;
         :	                for (i = 0;; i++)               /* loop exit is at "break" */
    0.00 :	  46fa35:       41 83 c5 01             add    $0x1,%r13d
         :	                {
         :	                        if (HeapTupleHasNulls(tuple) && att_isnull(i, bp))
    0.00 :	  46fa39:       41 83 e1 01             and    $0x1,%r9d
    0.00 :	  46fa3d:       75 d1                   jne    46fa10 <nocachegetattr+0x80>
         :	                                usecache = false;
         :	                                continue;               /* this cannot be the target att */
         :	                        }
         :
         :	                        /* If we know the next offset, we can skip the rest */
         :	                        if (usecache && att[i]->attcacheoff >= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:471
    3.92 :	  46fa3f:       45 84 f6                test   %r14b,%r14b
    0.00 :	  46fa42:       0f 85 08 01 00 00       jne    46fb50 <nocachegetattr+0x1c0>
    0.00 :	  46fa48:       49 63 fd                movslq %r13d,%rdi
    0.00 :	  46fa4b:       49 8b 14 ff             mov    (%r15,%rdi,8),%rdx
         :	                                off = att[i]->attcacheoff;
         :	                        else if (att[i]->attlen == -1)
    0.00 :	  46fa4f:       66 83 7a 4c ff          cmpw   $0xffff,0x4c(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:473
    1.96 :	  46fa54:       0f 84 b6 01 00 00       je     46fc10 <nocachegetattr+0x280>
         :	                                }
         :	                        }
         :	                        else
         :	                        {
         :	                                /* not varlena, so safe to use att_align_nominal */
         :	                                off = att_align_nominal(off, att[i]->attalign);
    0.00 :	  46fa5a:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46fa5e:       3c 69                   cmp    $0x69,%al
    0.00 :	  46fa60:       0f 84 2a 02 00 00       je     46fc90 <nocachegetattr+0x300>
    0.00 :	  46fa66:       3c 63                   cmp    $0x63,%al
    0.00 :	  46fa68:       74 0e                   je     46fa78 <nocachegetattr+0xe8>
    0.00 :	  46fa6a:       3c 64                   cmp    $0x64,%al
    0.00 :	  46fa6c:       0f 84 7e 02 00 00       je     46fcf0 <nocachegetattr+0x360>
    0.00 :	  46fa72:       83 c6 01                add    $0x1,%esi
    0.00 :	  46fa75:       83 e6 fe                and    $0xfffffffe,%esi
         :
         :	                                if (usecache)
    0.00 :	  46fa78:       45 84 f6                test   %r14b,%r14b
    0.00 :	  46fa7b:       74 03                   je     46fa80 <nocachegetattr+0xf0>
         :	                                        att[i]->attcacheoff = off;
    0.00 :	  46fa7d:       89 72 54                mov    %esi,0x54(%rdx)
         :	                        }
         :
         :	                        if (i == attnum)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:500
    3.92 :	  46fa80:       45 39 d5                cmp    %r10d,%r13d
    0.00 :	  46fa83:       0f 84 ea 00 00 00       je     46fb73 <nocachegetattr+0x1e3>
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
    0.00 :	  46fa89:       49 8b 04 ff             mov    (%r15,%rdi,8),%rax
    0.00 :	  46fa8d:       44 0f b7 60 4c          movzwl 0x4c(%rax),%r12d
    0.00 :	  46fa92:       66 45 85 e4             test   %r12w,%r12w
    0.00 :	  46fa96:       0f 8e 44 01 00 00       jle    46fbe0 <nocachegetattr+0x250>
    0.00 :	  46fa9c:       41 0f bf c4             movswl %r12w,%eax
    0.00 :	  46faa0:       01 c6                   add    %eax,%esi
         :
         :	                        if (usecache && att[i]->attlen <= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    3.92 :	  46faa2:       45 84 f6                test   %r14b,%r14b
    0.00 :	  46faa5:       0f 85 15 01 00 00       jne    46fbc0 <nocachegetattr+0x230>
    0.00 :	  46faab:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  46faaf:       4c 8b 40 10             mov    0x10(%rax),%r8
    1.96 :	  46fab3:       e9 78 ff ff ff          jmpq   46fa30 <nocachegetattr+0xa0>
    0.00 :	  46fab8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46fabf:       00 
         :	                else
         :	                {
         :	                        /* check for nulls in any "earlier" bytes */
         :	                        int                     i;
         :
         :	                        for (i = 0; i < byte; i++)
    0.00 :	  46fac0:       85 f6                   test   %esi,%esi
    0.00 :	  46fac2:       7e 2c                   jle    46faf0 <nocachegetattr+0x160>
         :	                        {
         :	                                if (bp[i] != 0xFF)
    0.00 :	  46fac4:       31 d2                   xor    %edx,%edx
    0.00 :	  46fac6:       41 80 78 17 ff          cmpb   $0xff,0x17(%r8)
    0.00 :	  46facb:       74 1a                   je     46fae7 <nocachegetattr+0x157>
    0.00 :	  46facd:       0f 1f 00                nopl   (%rax)
    0.00 :	  46fad0:       e9 1f ff ff ff          jmpq   46f9f4 <nocachegetattr+0x64>
    0.00 :	  46fad5:       0f 1f 00                nopl   (%rax)
    0.00 :	  46fad8:       48 63 c2                movslq %edx,%rax
    0.00 :	  46fadb:       41 80 7c 00 17 ff       cmpb   $0xff,0x17(%r8,%rax,1)
    0.00 :	  46fae1:       0f 85 0d ff ff ff       jne    46f9f4 <nocachegetattr+0x64>
         :	                else
         :	                {
         :	                        /* check for nulls in any "earlier" bytes */
         :	                        int                     i;
         :
         :	                        for (i = 0; i < byte; i++)
    0.00 :	  46fae7:       83 c2 01                add    $0x1,%edx
    0.00 :	  46faea:       39 d6                   cmp    %edx,%esi
    0.00 :	  46faec:       7f ea                   jg     46fad8 <nocachegetattr+0x148>
    0.00 :	  46faee:       66 90                   xchg   %ax,%ax
         :	                                }
         :	                        }
         :	                }
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:374
    3.92 :	  46faf0:       41 0f b6 40 16          movzbl 0x16(%r8),%eax
    1.96 :	  46faf5:       4d 8d 1c 00             lea    (%r8,%rax,1),%r11
         :	        {
         :	                /*
         :	                 * If we get here, there are no nulls up to and including the target
         :	                 * attribute.  If we have a cached offset, we can use it.
         :	                 */
         :	                if (att[attnum]->attcacheoff >= 0)
    0.00 :	  46faf9:       49 63 c2                movslq %r10d,%rax
    0.00 :	  46fafc:       49 8d 1c c7             lea    (%r15,%rax,8),%rbx
    0.00 :	  46fb00:       48 8b 13                mov    (%rbx),%rdx
    0.00 :	  46fb03:       8b 42 54                mov    0x54(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:382
    1.96 :	  46fb06:       85 c0                   test   %eax,%eax
    0.00 :	  46fb08:       0f 88 22 02 00 00       js     46fd30 <nocachegetattr+0x3a0>
         :	                {
         :	                        return fetchatt(att[attnum],
    0.00 :	  46fb0e:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  46fb12:       0f 84 e8 01 00 00       je     46fd00 <nocachegetattr+0x370>
    0.00 :	  46fb18:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  46fb1c:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  46fb20:       0f 84 da 03 00 00       je     46ff00 <nocachegetattr+0x570>
    0.00 :	  46fb26:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  46fb2a:       0f 84 08 04 00 00       je     46ff38 <nocachegetattr+0x5a8>
    0.00 :	  46fb30:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  46fb34:       0f 84 09 04 00 00       je     46ff43 <nocachegetattr+0x5b3>
    0.00 :	  46fb3a:       48 98                   cltq   
    0.00 :	  46fb3c:       41 0f b6 04 03          movzbl (%r11,%rax,1),%eax
    0.00 :	  46fb41:       e9 99 01 00 00          jmpq   46fcdf <nocachegetattr+0x34f>
    0.00 :	  46fb46:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46fb4d:       00 00 00 
         :	                                usecache = false;
         :	                                continue;               /* this cannot be the target att */
         :	                        }
         :
         :	                        /* If we know the next offset, we can skip the rest */
         :	                        if (usecache && att[i]->attcacheoff >= 0)
    0.00 :	  46fb50:       49 63 fd                movslq %r13d,%rdi
    0.00 :	  46fb53:       49 8b 14 ff             mov    (%r15,%rdi,8),%rdx
    0.00 :	  46fb57:       8b 42 54                mov    0x54(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:471
    3.92 :	  46fb5a:       85 c0                   test   %eax,%eax
    0.00 :	  46fb5c:       0f 88 ed fe ff ff       js     46fa4f <nocachegetattr+0xbf>
         :
         :	                                if (usecache)
         :	                                        att[i]->attcacheoff = off;
         :	                        }
         :
         :	                        if (i == attnum)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:500
    1.96 :	  46fb62:       45 39 d5                cmp    %r10d,%r13d
         :	                                usecache = false;
         :	                                continue;               /* this cannot be the target att */
         :	                        }
         :
         :	                        /* If we know the next offset, we can skip the rest */
         :	                        if (usecache && att[i]->attcacheoff >= 0)
    0.00 :	  46fb65:       89 c6                   mov    %eax,%esi
    0.00 :	  46fb67:       41 be 01 00 00 00       mov    $0x1,%r14d
         :
         :	                                if (usecache)
         :	                                        att[i]->attcacheoff = off;
         :	                        }
         :
         :	                        if (i == attnum)
    0.00 :	  46fb6d:       0f 85 16 ff ff ff       jne    46fa89 <nocachegetattr+0xf9>
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
         :
         :	                        if (usecache && att[i]->attlen <= 0)
         :	                                usecache = false;
         :	                }
    0.00 :	  46fb73:       49 8b 04 ff             mov    (%r15,%rdi,8),%rax
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
    0.00 :	  46fb77:       80 78 5c 00             cmpb   $0x0,0x5c(%rax)
    0.00 :	  46fb7b:       0f 84 57 01 00 00       je     46fcd8 <nocachegetattr+0x348>
    0.00 :	  46fb81:       0f b7 40 4c             movzwl 0x4c(%rax),%eax
    0.00 :	  46fb85:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  46fb89:       0f 84 31 03 00 00       je     46fec0 <nocachegetattr+0x530>
    0.00 :	  46fb8f:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  46fb93:       0f 84 47 02 00 00       je     46fde0 <nocachegetattr+0x450>
    0.00 :	  46fb99:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  46fb9d:       0f 1f 00                nopl   (%rax)
    0.00 :	  46fba0:       0f 84 77 03 00 00       je     46ff1d <nocachegetattr+0x58d>
    0.00 :	  46fba6:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fba9:       41 0f b6 04 03          movzbl (%r11,%rax,1),%eax
         :	}
    0.00 :	  46fbae:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46fbb2:       5b                      pop    %rbx
    0.00 :	  46fbb3:       41 5c                   pop    %r12
    0.00 :	  46fbb5:       41 5d                   pop    %r13
    0.00 :	  46fbb7:       41 5e                   pop    %r14
    0.00 :	  46fbb9:       41 5f                   pop    %r15
    0.00 :	  46fbbb:       c9                      leaveq 
    0.00 :	  46fbbc:       c3                      retq   
    0.00 :	  46fbbd:       0f 1f 00                nopl   (%rax)
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
         :
         :	                        if (usecache && att[i]->attlen <= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:505
    1.96 :	  46fbc0:       66 45 85 e4             test   %r12w,%r12w
    0.00 :	  46fbc4:       0f 8e fe 00 00 00       jle    46fcc8 <nocachegetattr+0x338>
    0.00 :	  46fbca:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  46fbce:       4c 8b 42 10             mov    0x10(%rdx),%r8
    0.00 :	  46fbd2:       e9 59 fe ff ff          jmpq   46fa30 <nocachegetattr+0xa0>
    0.00 :	  46fbd7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  46fbde:       00 00 
         :	                        }
         :
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    9.80 :	  46fbe0:       66 41 83 fc ff          cmp    $0xffff,%r12w
    0.00 :	  46fbe5:       0f 85 b5 00 00 00       jne    46fca0 <nocachegetattr+0x310>
    0.00 :	  46fbeb:       48 63 d6                movslq %esi,%rdx
    0.00 :	  46fbee:       41 0f b6 04 13          movzbl (%r11,%rdx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    1.96 :	  46fbf3:       3c 01                   cmp    $0x1,%al
    0.00 :	  46fbf5:       0f 84 f5 01 00 00       je     46fdf0 <nocachegetattr+0x460>
    1.96 :	  46fbfb:       a8 01                   test   $0x1,%al
    0.00 :	  46fbfd:       0f 84 15 01 00 00       je     46fd18 <nocachegetattr+0x388>
    0.00 :	  46fc03:       d0 e8                   shr    %al
    0.00 :	  46fc05:       0f b6 c0                movzbl %al,%eax
    0.00 :	  46fc08:       8d 34 30                lea    (%rax,%rsi,1),%esi
    3.92 :	  46fc0b:       e9 92 fe ff ff          jmpq   46faa2 <nocachegetattr+0x112>
         :	                                 * We can only cache the offset for a varlena attribute if the
         :	                                 * offset is already suitably aligned, so that there would be
         :	                                 * no pad bytes in any case: then the offset will be valid for
         :	                                 * either an aligned or unaligned value.
         :	                                 */
         :	                                if (usecache &&
    0.00 :	  46fc10:       45 84 f6                test   %r14b,%r14b
    0.00 :	  46fc13:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fc16:       74 30                   je     46fc48 <nocachegetattr+0x2b8>
    0.00 :	  46fc18:       0f b6 4a 5e             movzbl 0x5e(%rdx),%ecx
    0.00 :	  46fc1c:       80 f9 69                cmp    $0x69,%cl
    0.00 :	  46fc1f:       0f 84 8b 02 00 00       je     46feb0 <nocachegetattr+0x520>
    0.00 :	  46fc25:       80 f9 63                cmp    $0x63,%cl
    0.00 :	  46fc28:       0f 84 9a 01 00 00       je     46fdc8 <nocachegetattr+0x438>
    0.00 :	  46fc2e:       80 f9 64                cmp    $0x64,%cl
    0.00 :	  46fc31:       0f 84 d9 02 00 00       je     46ff10 <nocachegetattr+0x580>
    0.00 :	  46fc37:       48 8d 48 01             lea    0x1(%rax),%rcx
    0.00 :	  46fc3b:       48 83 e1 fe             and    $0xfffffffffffffffe,%rcx
    0.00 :	  46fc3f:       48 39 c1                cmp    %rax,%rcx
    0.00 :	  46fc42:       0f 84 80 01 00 00       je     46fdc8 <nocachegetattr+0x438>
         :	                                        off == att_align_nominal(off, att[i]->attalign))
         :	                                        att[i]->attcacheoff = off;
         :	                                else
         :	                                {
         :	                                        off = att_align_pointer(off, att[i]->attalign, -1,
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:486
    1.96 :	  46fc48:       41 80 3c 03 00          cmpb   $0x0,(%r11,%rax,1)
    1.96 :	  46fc4d:       75 31                   jne    46fc80 <nocachegetattr+0x2f0>
    0.00 :	  46fc4f:       0f b6 52 5e             movzbl 0x5e(%rdx),%edx
    0.00 :	  46fc53:       80 fa 69                cmp    $0x69,%dl
    0.00 :	  46fc56:       0f 84 84 02 00 00       je     46fee0 <nocachegetattr+0x550>
    0.00 :	  46fc5c:       80 fa 63                cmp    $0x63,%dl
    0.00 :	  46fc5f:       90                      nop
    0.00 :	  46fc60:       74 1e                   je     46fc80 <nocachegetattr+0x2f0>
    0.00 :	  46fc62:       80 fa 64                cmp    $0x64,%dl
    0.00 :	  46fc65:       0f 84 bf 02 00 00       je     46ff2a <nocachegetattr+0x59a>
    0.00 :	  46fc6b:       48 83 c0 01             add    $0x1,%rax
    0.00 :	  46fc6f:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46fc72:       89 c6                   mov    %eax,%esi
    0.00 :	  46fc74:       83 e6 fe                and    $0xfffffffe,%esi
    0.00 :	  46fc77:       e9 04 fe ff ff          jmpq   46fa80 <nocachegetattr+0xf0>
    0.00 :	  46fc7c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        {
         :	                                /* not varlena, so safe to use att_align_nominal */
         :	                                off = att_align_nominal(off, att[i]->attalign);
         :
         :	                                if (usecache)
         :	                                        att[i]->attcacheoff = off;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:497
    3.92 :	  46fc80:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46fc83:       e9 f8 fd ff ff          jmpq   46fa80 <nocachegetattr+0xf0>
    0.00 :	  46fc88:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46fc8f:       00 
         :	                                }
         :	                        }
         :	                        else
         :	                        {
         :	                                /* not varlena, so safe to use att_align_nominal */
         :	                                off = att_align_nominal(off, att[i]->attalign);
    0.00 :	  46fc90:       83 c6 03                add    $0x3,%esi
    0.00 :	  46fc93:       83 e6 fc                and    $0xfffffffc,%esi
    0.00 :	  46fc96:       e9 dd fd ff ff          jmpq   46fa78 <nocachegetattr+0xe8>
    0.00 :	  46fc9b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
    0.00 :	  46fca0:       48 63 de                movslq %esi,%rbx
    0.00 :	  46fca3:       44 89 55 c0             mov    %r10d,-0x40(%rbp)
    0.00 :	  46fca7:       4c 89 5d b8             mov    %r11,-0x48(%rbp)
    0.00 :	  46fcab:       49 8d 3c 1b             lea    (%r11,%rbx,1),%rdi
    0.00 :	  46fcaf:       e8 9c 9b ff ff          callq  469850 <strlen@plt>
    0.00 :	  46fcb4:       4c 8b 5d b8             mov    -0x48(%rbp),%r11
    0.00 :	  46fcb8:       8d 74 03 01             lea    0x1(%rbx,%rax,1),%esi
    0.00 :	  46fcbc:       44 8b 55 c0             mov    -0x40(%rbp),%r10d
    0.00 :	  46fcc0:       e9 dd fd ff ff          jmpq   46faa2 <nocachegetattr+0x112>
    0.00 :	  46fcc5:       0f 1f 00                nopl   (%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:503
    1.96 :	  46fcc8:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  46fccc:       4c 8b 40 10             mov    0x10(%rax),%r8
    0.00 :	  46fcd0:       e9 58 fd ff ff          jmpq   46fa2d <nocachegetattr+0x9d>
    0.00 :	  46fcd5:       0f 1f 00                nopl   (%rax)
         :	                        if (usecache && att[i]->attlen <= 0)
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:510
    5.88 :	  46fcd8:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fcdb:       49 8d 04 03             lea    (%r11,%rax,1),%rax
         :	}
    0.00 :	  46fcdf:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46fce3:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:511
    1.96 :	  46fce4:       41 5c                   pop    %r12
    0.00 :	  46fce6:       41 5d                   pop    %r13
    0.00 :	  46fce8:       41 5e                   pop    %r14
    0.00 :	  46fcea:       41 5f                   pop    %r15
    0.00 :	  46fcec:       c9                      leaveq 
    0.00 :	  46fced:       c3                      retq   
    0.00 :	  46fcee:       66 90                   xchg   %ax,%ax
         :	                                }
         :	                        }
         :	                        else
         :	                        {
         :	                                /* not varlena, so safe to use att_align_nominal */
         :	                                off = att_align_nominal(off, att[i]->attalign);
    0.00 :	  46fcf0:       83 c6 07                add    $0x7,%esi
    0.00 :	  46fcf3:       83 e6 f8                and    $0xfffffff8,%esi
    0.00 :	  46fcf6:       e9 7d fd ff ff          jmpq   46fa78 <nocachegetattr+0xe8>
    0.00 :	  46fcfb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
         :	}
    0.00 :	  46fd00:       48 83 c4 28             add    $0x28,%rsp
         :	                 * If we get here, there are no nulls up to and including the target
         :	                 * attribute.  If we have a cached offset, we can use it.
         :	                 */
         :	                if (att[attnum]->attcacheoff >= 0)
         :	                {
         :	                        return fetchatt(att[attnum],
    0.00 :	  46fd04:       48 98                   cltq   
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
         :	}
    0.00 :	  46fd06:       5b                      pop    %rbx
    0.00 :	  46fd07:       41 5c                   pop    %r12
    0.00 :	  46fd09:       41 5d                   pop    %r13
    0.00 :	  46fd0b:       41 5e                   pop    %r14
         :	                 * If we get here, there are no nulls up to and including the target
         :	                 * attribute.  If we have a cached offset, we can use it.
         :	                 */
         :	                if (att[attnum]->attcacheoff >= 0)
         :	                {
         :	                        return fetchatt(att[attnum],
    0.00 :	  46fd0d:       49 8d 04 03             lea    (%r11,%rax,1),%rax
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
         :	}
    0.00 :	  46fd11:       41 5f                   pop    %r15
    0.00 :	  46fd13:       c9                      leaveq 
    0.00 :	  46fd14:       c3                      retq   
    0.00 :	  46fd15:       0f 1f 00                nopl   (%rax)
         :	                        }
         :
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
    0.00 :	  46fd18:       41 8b 04 13             mov    (%r11,%rdx,1),%eax
    0.00 :	  46fd1c:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  46fd1f:       8d 34 30                lea    (%rax,%rsi,1),%esi
    0.00 :	  46fd22:       e9 7b fd ff ff          jmpq   46faa2 <nocachegetattr+0x112>
    0.00 :	  46fd27:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  46fd2e:       00 00 
         :	                /*
         :	                 * Otherwise, check for non-fixed-length attrs up to and including
         :	                 * target.  If there aren't any, it's safe to cheaply initialize the
         :	                 * cached offsets for these attrs.
         :	                 */
         :	                if (HeapTupleHasVarWidth(tuple))
    0.00 :	  46fd30:       41 f6 c1 02             test   $0x2,%r9b
    0.00 :	  46fd34:       0f 84 b6 01 00 00       je     46fef0 <nocachegetattr+0x560>
         :	                {
         :	                        int                     j;
         :
         :	                        for (j = 0; j <= attnum; j++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:397
    1.96 :	  46fd3a:       45 85 d2                test   %r10d,%r10d
    0.00 :	  46fd3d:       0f 88 ad 01 00 00       js     46fef0 <nocachegetattr+0x560>
         :	                        {
         :	                                if (att[j]->attlen <= 0)
    0.00 :	  46fd43:       49 8b 0f                mov    (%r15),%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:399
    1.96 :	  46fd46:       31 d2                   xor    %edx,%edx
    0.00 :	  46fd48:       66 83 79 4c 00          cmpw   $0x0,0x4c(%rcx)
    0.00 :	  46fd4d:       7f 1b                   jg     46fd6a <nocachegetattr+0x3da>
    0.00 :	  46fd4f:       90                      nop
    1.96 :	  46fd50:       e9 a8 fc ff ff          jmpq   46f9fd <nocachegetattr+0x6d>
    0.00 :	  46fd55:       0f 1f 00                nopl   (%rax)
    0.00 :	  46fd58:       48 63 c2                movslq %edx,%rax
    0.00 :	  46fd5b:       49 8b 04 c7             mov    (%r15,%rax,8),%rax
    0.00 :	  46fd5f:       66 83 78 4c 00          cmpw   $0x0,0x4c(%rax)
    0.00 :	  46fd64:       0f 8e 93 fc ff ff       jle    46f9fd <nocachegetattr+0x6d>
         :	                 */
         :	                if (HeapTupleHasVarWidth(tuple))
         :	                {
         :	                        int                     j;
         :
         :	                        for (j = 0; j <= attnum; j++)
    0.00 :	  46fd6a:       83 c2 01                add    $0x1,%edx
    0.00 :	  46fd6d:       41 39 d2                cmp    %edx,%r10d
    0.00 :	  46fd70:       7d e6                   jge    46fd58 <nocachegetattr+0x3c8>
         :	                }
         :	        }
         :
         :	        if (!slow)
         :	        {
         :	                int                     natts = tupleDesc->natts;
    0.00 :	  46fd72:       44 8b 0f                mov    (%rdi),%r9d
         :	                 * it's cheap to compute offsets for fixed-width columns, we take the
         :	                 * opportunity to initialize the cached offsets for *all* the leading
         :	                 * fixed-width columns, in hope of avoiding future visits to this
         :	                 * routine.
         :	                 */
         :	                att[0]->attcacheoff = 0;
    0.00 :	  46fd75:       c7 41 54 00 00 00 00    movl   $0x0,0x54(%rcx)
         :
         :	                /* we might have set some offsets in the slow path previously */
         :	                while (j < natts && att[j]->attcacheoff > 0)
    0.00 :	  46fd7c:       41 83 f9 01             cmp    $0x1,%r9d
    0.00 :	  46fd80:       7e 35                   jle    46fdb7 <nocachegetattr+0x427>
    0.00 :	  46fd82:       49 8b 47 08             mov    0x8(%r15),%rax
    0.00 :	  46fd86:       8b 50 54                mov    0x54(%rax),%edx
    0.00 :	  46fd89:       85 d2                   test   %edx,%edx
    0.00 :	  46fd8b:       0f 8e be 01 00 00       jle    46ff4f <nocachegetattr+0x5bf>
    0.00 :	  46fd91:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  46fd94:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  46fd99:       eb 14                   jmp    46fdaf <nocachegetattr+0x41f>
    0.00 :	  46fd9b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  46fda0:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  46fda4:       48 83 c2 08             add    $0x8,%rdx
    0.00 :	  46fda8:       8b 40 54                mov    0x54(%rax),%eax
    0.00 :	  46fdab:       85 c0                   test   %eax,%eax
    0.00 :	  46fdad:       7e 71                   jle    46fe20 <nocachegetattr+0x490>
         :	                        j++;
    0.00 :	  46fdaf:       83 c6 01                add    $0x1,%esi
         :	                 * routine.
         :	                 */
         :	                att[0]->attcacheoff = 0;
         :
         :	                /* we might have set some offsets in the slow path previously */
         :	                while (j < natts && att[j]->attcacheoff > 0)
    0.00 :	  46fdb2:       41 39 f1                cmp    %esi,%r9d
    0.00 :	  46fdb5:       7f e9                   jg     46fda0 <nocachegetattr+0x410>
         :	                        off += att[j]->attlen;
         :	                }
         :
         :	                Assert(j > attnum);
         :
         :	                off = att[attnum]->attcacheoff;
    0.00 :	  46fdb7:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  46fdba:       8b 70 54                mov    0x54(%rax),%esi
    0.00 :	  46fdbd:       e9 b5 fd ff ff          jmpq   46fb77 <nocachegetattr+0x1e7>
    0.00 :	  46fdc2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                 * no pad bytes in any case: then the offset will be valid for
         :	                                 * either an aligned or unaligned value.
         :	                                 */
         :	                                if (usecache &&
         :	                                        off == att_align_nominal(off, att[i]->attalign))
         :	                                        att[i]->attcacheoff = off;
    0.00 :	  46fdc8:       89 72 54                mov    %esi,0x54(%rdx)
    0.00 :	  46fdcb:       41 be 01 00 00 00       mov    $0x1,%r14d
         :	                                 * We can only cache the offset for a varlena attribute if the
         :	                                 * offset is already suitably aligned, so that there would be
         :	                                 * no pad bytes in any case: then the offset will be valid for
         :	                                 * either an aligned or unaligned value.
         :	                                 */
         :	                                if (usecache &&
    0.00 :	  46fdd1:       e9 aa fc ff ff          jmpq   46fa80 <nocachegetattr+0xf0>
    0.00 :	  46fdd6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46fddd:       00 00 00 
         :	                        if (usecache && att[i]->attlen <= 0)
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
    0.00 :	  46fde0:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fde3:       41 8b 04 03             mov    (%r11,%rax,1),%eax
    0.00 :	  46fde7:       e9 f3 fe ff ff          jmpq   46fcdf <nocachegetattr+0x34f>
    0.00 :	  46fdec:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        }
         :
         :	                        if (i == attnum)
         :	                                break;
         :
         :	                        off = att_addlength_pointer(off, att[i]->attlen, tp + off);
    0.00 :	  46fdf0:       41 0f b6 54 13 01       movzbl 0x1(%r11,%rdx,1),%edx
    0.00 :	  46fdf6:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  46fdfb:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  46fdfe:       0f 84 04 fe ff ff       je     46fc08 <nocachegetattr+0x278>
    0.00 :	  46fe04:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  46fe07:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  46fe0c:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  46fe11:       0f 44 c2                cmove  %edx,%eax
    0.00 :	  46fe14:       8d 34 30                lea    (%rax,%rsi,1),%esi
    0.00 :	  46fe17:       e9 86 fc ff ff          jmpq   46faa2 <nocachegetattr+0x112>
    0.00 :	  46fe1c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * routine.
         :	                 */
         :	                att[0]->attcacheoff = 0;
         :
         :	                /* we might have set some offsets in the slow path previously */
         :	                while (j < natts && att[j]->attcacheoff > 0)
    0.00 :	  46fe20:       89 f0                   mov    %esi,%eax
         :	                        j++;
         :
         :	                off = att[j - 1]->attcacheoff + att[j - 1]->attlen;
    0.00 :	  46fe22:       48 63 d0                movslq %eax,%rdx
    0.00 :	  46fe25:       49 8b 44 d7 f8          mov    -0x8(%r15,%rdx,8),%rax
         :
         :	                for (; j < natts; j++)
         :	                {
         :	                        if (att[j]->attlen <= 0)
    0.00 :	  46fe2a:       49 8d 14 d7             lea    (%r15,%rdx,8),%rdx
    0.00 :	  46fe2e:       48 8b 3a                mov    (%rdx),%rdi
         :
         :	                /* we might have set some offsets in the slow path previously */
         :	                while (j < natts && att[j]->attcacheoff > 0)
         :	                        j++;
         :
         :	                off = att[j - 1]->attcacheoff + att[j - 1]->attlen;
    0.00 :	  46fe31:       8b 48 54                mov    0x54(%rax),%ecx
    0.00 :	  46fe34:       0f b7 40 4c             movzwl 0x4c(%rax),%eax
         :
         :	                for (; j < natts; j++)
         :	                {
         :	                        if (att[j]->attlen <= 0)
    0.00 :	  46fe38:       66 83 7f 4c 00          cmpw   $0x0,0x4c(%rdi)
         :
         :	                /* we might have set some offsets in the slow path previously */
         :	                while (j < natts && att[j]->attcacheoff > 0)
         :	                        j++;
         :
         :	                off = att[j - 1]->attcacheoff + att[j - 1]->attlen;
    0.00 :	  46fe3d:       98                      cwtl   
    0.00 :	  46fe3e:       8d 0c 08                lea    (%rax,%rcx,1),%ecx
         :
         :	                for (; j < natts; j++)
         :	                {
         :	                        if (att[j]->attlen <= 0)
    0.00 :	  46fe41:       7f 4f                   jg     46fe92 <nocachegetattr+0x502>
    0.00 :	  46fe43:       e9 6f ff ff ff          jmpq   46fdb7 <nocachegetattr+0x427>
    0.00 :	  46fe48:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46fe4f:       00 
         :	                                break;
         :
         :	                        off = att_align_nominal(off, att[j]->attalign);
    0.00 :	  46fe50:       3c 63                   cmp    $0x63,%al
    0.00 :	  46fe52:       74 0c                   je     46fe60 <nocachegetattr+0x4d0>
    0.00 :	  46fe54:       3c 64                   cmp    $0x64,%al
    0.00 :	  46fe56:       66 90                   xchg   %ax,%ax
    0.00 :	  46fe58:       74 4e                   je     46fea8 <nocachegetattr+0x518>
    0.00 :	  46fe5a:       83 c1 01                add    $0x1,%ecx
    0.00 :	  46fe5d:       83 e1 fe                and    $0xfffffffe,%ecx
         :
         :	                        att[j]->attcacheoff = off;
    0.00 :	  46fe60:       89 4f 54                mov    %ecx,0x54(%rdi)
         :
         :	                        off += att[j]->attlen;
    0.00 :	  46fe63:       48 8b 02                mov    (%rdx),%rax
         :	                while (j < natts && att[j]->attcacheoff > 0)
         :	                        j++;
         :
         :	                off = att[j - 1]->attcacheoff + att[j - 1]->attlen;
         :
         :	                for (; j < natts; j++)
    0.00 :	  46fe66:       83 c6 01                add    $0x1,%esi
    0.00 :	  46fe69:       41 39 f1                cmp    %esi,%r9d
         :
         :	                        off = att_align_nominal(off, att[j]->attalign);
         :
         :	                        att[j]->attcacheoff = off;
         :
         :	                        off += att[j]->attlen;
    0.00 :	  46fe6c:       44 0f b7 40 4c          movzwl 0x4c(%rax),%r8d
         :	                while (j < natts && att[j]->attcacheoff > 0)
         :	                        j++;
         :
         :	                off = att[j - 1]->attcacheoff + att[j - 1]->attlen;
         :
         :	                for (; j < natts; j++)
    0.00 :	  46fe71:       0f 8e 40 ff ff ff       jle    46fdb7 <nocachegetattr+0x427>
         :	                {
         :	                        if (att[j]->attlen <= 0)
    0.00 :	  46fe77:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fe7a:       49 8d 14 c7             lea    (%r15,%rax,8),%rdx
    0.00 :	  46fe7e:       48 8b 3a                mov    (%rdx),%rdi
    0.00 :	  46fe81:       66 83 7f 4c 00          cmpw   $0x0,0x4c(%rdi)
    0.00 :	  46fe86:       0f 8e 2b ff ff ff       jle    46fdb7 <nocachegetattr+0x427>
         :
         :	                        off = att_align_nominal(off, att[j]->attalign);
         :
         :	                        att[j]->attcacheoff = off;
         :
         :	                        off += att[j]->attlen;
    0.00 :	  46fe8c:       41 0f bf c0             movswl %r8w,%eax
    0.00 :	  46fe90:       01 c1                   add    %eax,%ecx
         :	                for (; j < natts; j++)
         :	                {
         :	                        if (att[j]->attlen <= 0)
         :	                                break;
         :
         :	                        off = att_align_nominal(off, att[j]->attalign);
    0.00 :	  46fe92:       0f b6 47 5e             movzbl 0x5e(%rdi),%eax
    0.00 :	  46fe96:       3c 69                   cmp    $0x69,%al
    0.00 :	  46fe98:       75 b6                   jne    46fe50 <nocachegetattr+0x4c0>
    0.00 :	  46fe9a:       83 c1 03                add    $0x3,%ecx
    0.00 :	  46fe9d:       83 e1 fc                and    $0xfffffffc,%ecx
    0.00 :	  46fea0:       eb be                   jmp    46fe60 <nocachegetattr+0x4d0>
    0.00 :	  46fea2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  46fea8:       83 c1 07                add    $0x7,%ecx
    0.00 :	  46feab:       83 e1 f8                and    $0xfffffff8,%ecx
    0.00 :	  46feae:       eb b0                   jmp    46fe60 <nocachegetattr+0x4d0>
         :	                                 * We can only cache the offset for a varlena attribute if the
         :	                                 * offset is already suitably aligned, so that there would be
         :	                                 * no pad bytes in any case: then the offset will be valid for
         :	                                 * either an aligned or unaligned value.
         :	                                 */
         :	                                if (usecache &&
    0.00 :	  46feb0:       48 8d 48 03             lea    0x3(%rax),%rcx
    0.00 :	  46feb4:       48 83 e1 fc             and    $0xfffffffffffffffc,%rcx
    0.00 :	  46feb8:       e9 82 fd ff ff          jmpq   46fc3f <nocachegetattr+0x2af>
    0.00 :	  46febd:       0f 1f 00                nopl   (%rax)
         :	                        if (usecache && att[i]->attlen <= 0)
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
    0.00 :	  46fec0:       48 63 c6                movslq %esi,%rax
    0.00 :	  46fec3:       49 8b 04 03             mov    (%r11,%rax,1),%rax
         :	}
    0.00 :	  46fec7:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46fecb:       5b                      pop    %rbx
    0.00 :	  46fecc:       41 5c                   pop    %r12
    0.00 :	  46fece:       41 5d                   pop    %r13
    0.00 :	  46fed0:       41 5e                   pop    %r14
    0.00 :	  46fed2:       41 5f                   pop    %r15
    0.00 :	  46fed4:       c9                      leaveq 
    0.00 :	  46fed5:       c3                      retq   
    0.00 :	  46fed6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46fedd:       00 00 00 
         :	                                if (usecache &&
         :	                                        off == att_align_nominal(off, att[i]->attalign))
         :	                                        att[i]->attcacheoff = off;
         :	                                else
         :	                                {
         :	                                        off = att_align_pointer(off, att[i]->attalign, -1,
    0.00 :	  46fee0:       83 c6 03                add    $0x3,%esi
    0.00 :	  46fee3:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46fee6:       83 e6 fc                and    $0xfffffffc,%esi
    0.00 :	  46fee9:       e9 92 fb ff ff          jmpq   46fa80 <nocachegetattr+0xf0>
    0.00 :	  46feee:       66 90                   xchg   %ax,%ax
         :	                 */
         :	                if (HeapTupleHasVarWidth(tuple))
         :	                {
         :	                        int                     j;
         :
         :	                        for (j = 0; j <= attnum; j++)
    0.00 :	  46fef0:       49 8b 0f                mov    (%r15),%rcx
    0.00 :	  46fef3:       e9 7a fe ff ff          jmpq   46fd72 <nocachegetattr+0x3e2>
    0.00 :	  46fef8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46feff:       00 
         :	                 * If we get here, there are no nulls up to and including the target
         :	                 * attribute.  If we have a cached offset, we can use it.
         :	                 */
         :	                if (att[attnum]->attcacheoff >= 0)
         :	                {
         :	                        return fetchatt(att[attnum],
    0.00 :	  46ff00:       48 98                   cltq   
    0.00 :	  46ff02:       49 8b 04 03             mov    (%r11,%rax,1),%rax
    0.00 :	  46ff06:       e9 d4 fd ff ff          jmpq   46fcdf <nocachegetattr+0x34f>
    0.00 :	  46ff0b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                 * We can only cache the offset for a varlena attribute if the
         :	                                 * offset is already suitably aligned, so that there would be
         :	                                 * no pad bytes in any case: then the offset will be valid for
         :	                                 * either an aligned or unaligned value.
         :	                                 */
         :	                                if (usecache &&
    0.00 :	  46ff10:       48 8d 48 07             lea    0x7(%rax),%rcx
    0.00 :	  46ff14:       48 83 e1 f8             and    $0xfffffffffffffff8,%rcx
    0.00 :	  46ff18:       e9 22 fd ff ff          jmpq   46fc3f <nocachegetattr+0x2af>
         :	                        if (usecache && att[i]->attlen <= 0)
         :	                                usecache = false;
         :	                }
         :	        }
         :
         :	        return fetchatt(att[attnum], tp + off);
    0.00 :	  46ff1d:       48 63 c6                movslq %esi,%rax
    0.00 :	  46ff20:       41 0f b7 04 03          movzwl (%r11,%rax,1),%eax
    0.00 :	  46ff25:       e9 b5 fd ff ff          jmpq   46fcdf <nocachegetattr+0x34f>
         :	                                if (usecache &&
         :	                                        off == att_align_nominal(off, att[i]->attalign))
         :	                                        att[i]->attcacheoff = off;
         :	                                else
         :	                                {
         :	                                        off = att_align_pointer(off, att[i]->attalign, -1,
    0.00 :	  46ff2a:       83 c6 07                add    $0x7,%esi
    0.00 :	  46ff2d:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46ff30:       83 e6 f8                and    $0xfffffff8,%esi
    0.00 :	  46ff33:       e9 48 fb ff ff          jmpq   46fa80 <nocachegetattr+0xf0>
         :	                 * If we get here, there are no nulls up to and including the target
         :	                 * attribute.  If we have a cached offset, we can use it.
         :	                 */
         :	                if (att[attnum]->attcacheoff >= 0)
         :	                {
         :	                        return fetchatt(att[attnum],
    0.00 :	  46ff38:       48 98                   cltq   
    0.00 :	  46ff3a:       41 8b 04 03             mov    (%r11,%rax,1),%eax
    0.00 :	  46ff3e:       e9 9c fd ff ff          jmpq   46fcdf <nocachegetattr+0x34f>
    0.00 :	  46ff43:       48 98                   cltq   
    0.00 :	  46ff45:       41 0f b7 04 03          movzwl (%r11,%rax,1),%eax
    0.00 :	  46ff4a:       e9 90 fd ff ff          jmpq   46fcdf <nocachegetattr+0x34f>
         :	                                }
         :	                        }
         :	                }
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ff4f:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  46ff54:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  46ff59:       e9 c4 fe ff ff          jmpq   46fe22 <nocachegetattr+0x492>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   67.39 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2269
    8.70 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    8.70 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2274
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2269
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2274
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077ece0 <pg_detoast_datum_packed>:
         :	        return heap_tuple_untoast_attr_slice(datum, first, count);
         :	}
         :
         :	struct varlena *
         :	pg_detoast_datum_packed(struct varlena * datum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2269
    4.35 :	  77ece0:       55                      push   %rbp
         :	        if (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    2.17 :	  77ece1:       0f b6 17                movzbl (%rdi),%edx
         :	        return heap_tuple_untoast_attr_slice(datum, first, count);
         :	}
         :
         :	struct varlena *
         :	pg_detoast_datum_packed(struct varlena * datum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2269
   67.39 :	  77ece4:       48 89 e5                mov    %rsp,%rbp
         :	        if (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    2.17 :	  77ece7:       89 d0                   mov    %edx,%eax
    4.35 :	  77ece9:       83 e0 03                and    $0x3,%eax
    0.00 :	  77ecec:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  77ecef:       74 0f                   je     77ed00 <pg_detoast_datum_packed+0x20>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2270
    8.70 :	  77ecf1:       80 ea 01                sub    $0x1,%dl
    0.00 :	  77ecf4:       74 0a                   je     77ed00 <pg_detoast_datum_packed+0x20>
         :	                return heap_tuple_untoast_attr(datum);
         :	        else
         :	                return datum;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2274
    2.17 :	  77ecf6:       48 89 f8                mov    %rdi,%rax
    0.00 :	  77ecf9:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:2274
    8.70 :	  77ecfa:       c3                      retq   
    0.00 :	  77ecfb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  77ed00:       c9                      leaveq 
         :
         :	struct varlena *
         :	pg_detoast_datum_packed(struct varlena * datum)
         :	{
         :	        if (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))
         :	                return heap_tuple_untoast_attr(datum);
    0.00 :	  77ed01:       e9 4a 41 d2 ff          jmpq   4a2e50 <heap_tuple_untoast_attr>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   38.64 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
   27.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1376
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1364
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1364
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1547
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1547
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1547
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1547
    2.27 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1376
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000075f6b0 <varstr_cmp>:
         :	 * Returns an integer less than, equal to, or greater than zero, indicating
         :	 * whether arg1 is less than, equal to, or greater than arg2.
         :	 */
         :	int
         :	varstr_cmp(char *arg1, int len1, char *arg2, int len2, Oid collid)
         :	{
    0.00 :	  75f6b0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1364
    2.27 :	  75f6b1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  75f6b4:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  75f6b8:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  75f6bc:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  75f6bf:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  75f6c3:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    2.27 :	  75f6c7:       41 89 f4                mov    %esi,%r12d
    0.00 :	  75f6ca:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  75f6ce:       48 81 ec 60 08 00 00    sub    $0x860,%rsp
    0.00 :	  75f6d5:       48 89 bd c0 f7 ff ff    mov    %rdi,-0x840(%rbp)
         :	         * Unfortunately, there is no strncoll(), so in the non-C locale case we
         :	         * have to do some memory copying.  This turns out to be significantly
         :	         * slower, so we optimize the case where LC_COLLATE is C.  We also try to
         :	         * optimize relatively-short strings by avoiding palloc/pfree overhead.
         :	         */
         :	        if (lc_collate_is_c(collid))
    0.00 :	  75f6dc:       44 89 c7                mov    %r8d,%edi
         :	 * Returns an integer less than, equal to, or greater than zero, indicating
         :	 * whether arg1 is less than, equal to, or greater than arg2.
         :	 */
         :	int
         :	varstr_cmp(char *arg1, int len1, char *arg2, int len2, Oid collid)
         :	{
    0.00 :	  75f6df:       48 89 95 b8 f7 ff ff    mov    %rdx,-0x848(%rbp)
    0.00 :	  75f6e6:       41 89 ce                mov    %ecx,%r14d
         :	         * Unfortunately, there is no strncoll(), so in the non-C locale case we
         :	         * have to do some memory copying.  This turns out to be significantly
         :	         * slower, so we optimize the case where LC_COLLATE is C.  We also try to
         :	         * optimize relatively-short strings by avoiding palloc/pfree overhead.
         :	         */
         :	        if (lc_collate_is_c(collid))
    0.00 :	  75f6e9:       e8 e2 34 fb ff          callq  712bd0 <lc_collate_is_c>
    0.00 :	  75f6ee:       84 c0                   test   %al,%al
    0.00 :	  75f6f0:       0f 85 0a 01 00 00       jne    75f800 <varstr_cmp+0x150>
         :
         :	#ifdef HAVE_LOCALE_T
         :	                pg_locale_t mylocale = 0;
         :	#endif
         :
         :	                if (collid != DEFAULT_COLLATION_OID)
    0.00 :	  75f6f6:       83 fb 64                cmp    $0x64,%ebx
    0.00 :	  75f6f9:       48 c7 85 c8 f7 ff ff    movq   $0x0,-0x838(%rbp)
    0.00 :	  75f700:       00 00 00 00 
    0.00 :	  75f704:       74 16                   je     75f71c <varstr_cmp+0x6c>
         :	                {
         :	                        if (!OidIsValid(collid))
    0.00 :	  75f706:       85 db                   test   %ebx,%ebx
    0.00 :	  75f708:       0f 84 e4 01 00 00       je     75f8f2 <varstr_cmp+0x242>
         :	                                                (errcode(ERRCODE_INDETERMINATE_COLLATION),
         :	                                                 errmsg("could not determine which collation to use for string comparison"),
         :	                                                 errhint("Use the COLLATE clause to set the collation explicitly.")));
         :	                        }
         :	#ifdef HAVE_LOCALE_T
         :	                        mylocale = pg_newlocale_from_collation(collid);
    0.00 :	  75f70e:       89 df                   mov    %ebx,%edi
    0.00 :	  75f710:       e8 ab 32 fb ff          callq  7129c0 <pg_newlocale_from_collation>
    0.00 :	  75f715:       48 89 85 c8 f7 ff ff    mov    %rax,-0x838(%rbp)
         :	                 * strcoll() by itself, so we don't lose much if this doesn't work out
         :	                 * very often, and if it does - for example, because there are many
         :	                 * equal strings in the input - then we win big by avoiding expensive
         :	                 * collation-aware comparisons.
         :	                 */
         :	                if (len1 == len2 && memcmp(arg1, arg2, len1) == 0)
    0.00 :	  75f71c:       45 39 f4                cmp    %r14d,%r12d
    0.00 :	  75f71f:       4d 63 fc                movslq %r12d,%r15
    0.00 :	  75f722:       0f 84 88 01 00 00       je     75f8b0 <varstr_cmp+0x200>
         :
         :	                        return result;
         :	                }
         :	#endif   /* WIN32 */
         :
         :	                if (len1 >= TEXTBUFLEN)
    0.00 :	  75f728:       41 81 fc ff 03 00 00    cmp    $0x3ff,%r12d
    0.00 :	  75f72f:       0f 8f 13 01 00 00       jg     75f848 <varstr_cmp+0x198>
    0.00 :	  75f735:       48 8d 85 d0 fb ff ff    lea    -0x430(%rbp),%rax
         :	                        a1p = (char *) palloc(len1 + 1);
         :	                else
         :	                        a1p = a1buf;
         :	                if (len2 >= TEXTBUFLEN)
    0.00 :	  75f73c:       41 81 fe ff 03 00 00    cmp    $0x3ff,%r14d
         :
         :	                        return result;
         :	                }
         :	#endif   /* WIN32 */
         :
         :	                if (len1 >= TEXTBUFLEN)
    0.00 :	  75f743:       48 89 85 b0 f7 ff ff    mov    %rax,-0x850(%rbp)
    0.00 :	  75f74a:       49 89 c5                mov    %rax,%r13
         :	                        a1p = (char *) palloc(len1 + 1);
         :	                else
         :	                        a1p = a1buf;
         :	                if (len2 >= TEXTBUFLEN)
    0.00 :	  75f74d:       0f 8f 20 01 00 00       jg     75f873 <varstr_cmp+0x1c3>
    0.00 :	  75f753:       48 8d 85 d0 f7 ff ff    lea    -0x830(%rbp),%rax
    0.00 :	  75f75a:       48 89 85 a8 f7 ff ff    mov    %rax,-0x858(%rbp)
    0.00 :	  75f761:       49 89 c4                mov    %rax,%r12
         :	                        a2p = (char *) palloc(len2 + 1);
         :	                else
         :	                        a2p = a2buf;
         :
         :	                memcpy(a1p, arg1, len1);
    0.00 :	  75f764:       48 8b b5 c0 f7 ff ff    mov    -0x840(%rbp),%rsi
    0.00 :	  75f76b:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  75f76e:       4c 89 ef                mov    %r13,%rdi
         :	                a1p[len1] = '\0';
         :	                memcpy(a2p, arg2, len2);
    0.00 :	  75f771:       49 63 de                movslq %r14d,%rbx
         :	                if (len2 >= TEXTBUFLEN)
         :	                        a2p = (char *) palloc(len2 + 1);
         :	                else
         :	                        a2p = a2buf;
         :
         :	                memcpy(a1p, arg1, len1);
    0.00 :	  75f774:       e8 77 a4 d0 ff          callq  469bf0 <memcpy@plt>
         :	                a1p[len1] = '\0';
    0.00 :	  75f779:       43 c6 44 3d 00 00       movb   $0x0,0x0(%r13,%r15,1)
         :	                memcpy(a2p, arg2, len2);
    0.00 :	  75f77f:       48 8b b5 b8 f7 ff ff    mov    -0x848(%rbp),%rsi
    0.00 :	  75f786:       48 89 da                mov    %rbx,%rdx
    0.00 :	  75f789:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75f78c:       e8 5f a4 d0 ff          callq  469bf0 <memcpy@plt>
         :	                a2p[len2] = '\0';
    0.00 :	  75f791:       41 c6 04 1c 00          movb   $0x0,(%r12,%rbx,1)
         :
         :	#ifdef HAVE_LOCALE_T
         :	                if (mylocale)
    0.00 :	  75f796:       48 83 bd c8 f7 ff ff    cmpq   $0x0,-0x838(%rbp)
    0.00 :	  75f79d:       00 
    0.00 :	  75f79e:       0f 84 3c 01 00 00       je     75f8e0 <varstr_cmp+0x230>
         :	                        result = strcoll_l(a1p, a2p, mylocale);
    0.00 :	  75f7a4:       48 8b 95 c8 f7 ff ff    mov    -0x838(%rbp),%rdx
    0.00 :	  75f7ab:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  75f7ae:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75f7b1:       e8 ea 9f d0 ff          callq  4697a0 <strcoll_l@plt>
    0.00 :	  75f7b6:       89 c3                   mov    %eax,%ebx
         :	                 * In some locales strcoll() can claim that nonidentical strings are
         :	                 * equal.  Believing that would be bad news for a number of reasons,
         :	                 * so we follow Perl's lead and sort "equal" strings according to
         :	                 * strcmp().
         :	                 */
         :	                if (result == 0)
    0.00 :	  75f7b8:       85 db                   test   %ebx,%ebx
    0.00 :	  75f7ba:       0f 84 d8 00 00 00       je     75f898 <varstr_cmp+0x1e8>
         :	                        result = strcmp(a1p, a2p);
         :
         :	                if (a1p != a1buf)
    0.00 :	  75f7c0:       4c 3b ad b0 f7 ff ff    cmp    -0x850(%rbp),%r13
    0.00 :	  75f7c7:       74 08                   je     75f7d1 <varstr_cmp+0x121>
         :	                        pfree(a1p);
    0.00 :	  75f7c9:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75f7cc:       e8 af 93 03 00          callq  798b80 <pfree>
         :	                if (a2p != a2buf)
    0.00 :	  75f7d1:       4c 3b a5 a8 f7 ff ff    cmp    -0x858(%rbp),%r12
    0.00 :	  75f7d8:       74 08                   je     75f7e2 <varstr_cmp+0x132>
         :	                        pfree(a2p);
    0.00 :	  75f7da:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75f7dd:       e8 9e 93 03 00          callq  798b80 <pfree>
         :	        }
         :
         :	        return result;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1547
    2.27 :	  75f7e2:       89 d8                   mov    %ebx,%eax
    0.00 :	  75f7e4:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    2.27 :	  75f7e8:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  75f7ec:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    2.27 :	  75f7f0:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  75f7f4:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  75f7f8:       c9                      leaveq 
    2.27 :	  75f7f9:       c3                      retq   
    0.00 :	  75f7fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * slower, so we optimize the case where LC_COLLATE is C.  We also try to
         :	         * optimize relatively-short strings by avoiding palloc/pfree overhead.
         :	         */
         :	        if (lc_collate_is_c(collid))
         :	        {
         :	                result = memcmp(arg1, arg2, Min(len1, len2));
    0.00 :	  75f800:       45 39 e6                cmp    %r12d,%r14d
    0.00 :	  75f803:       44 89 e1                mov    %r12d,%ecx
    0.00 :	  75f806:       48 8b b5 c0 f7 ff ff    mov    -0x840(%rbp),%rsi
    0.00 :	  75f80d:       41 0f 4e ce             cmovle %r14d,%ecx
    0.00 :	  75f811:       48 8b bd b8 f7 ff ff    mov    -0x848(%rbp),%rdi
    0.00 :	  75f818:       48 63 c9                movslq %ecx,%rcx
    0.00 :	  75f81b:       48 39 c9                cmp    %rcx,%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
   27.27 :	  75f81e:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
   38.64 :	  75f820:       0f 97 c2                seta   %dl
    9.09 :	  75f823:       0f 92 c0                setb   %al
    0.00 :	  75f826:       89 d3                   mov    %edx,%ebx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1375
    4.55 :	  75f828:       28 c3                   sub    %al,%bl
    0.00 :	  75f82a:       0f be db                movsbl %bl,%ebx
         :	                if ((result == 0) && (len1 != len2))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1376
    4.55 :	  75f82d:       85 db                   test   %ebx,%ebx
    0.00 :	  75f82f:       75 b1                   jne    75f7e2 <varstr_cmp+0x132>
    2.27 :	  75f831:       45 39 f4                cmp    %r14d,%r12d
    0.00 :	  75f834:       74 ac                   je     75f7e2 <varstr_cmp+0x132>
         :	                        result = (len1 < len2) ? -1 : 1;
    0.00 :	  75f836:       31 db                   xor    %ebx,%ebx
    0.00 :	  75f838:       45 39 e6                cmp    %r12d,%r14d
    0.00 :	  75f83b:       0f 9e c3                setle  %bl
    0.00 :	  75f83e:       8d 5c 1b ff             lea    -0x1(%rbx,%rbx,1),%ebx
    0.00 :	  75f842:       eb 9e                   jmp    75f7e2 <varstr_cmp+0x132>
    0.00 :	  75f844:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        return result;
         :	                }
         :	#endif   /* WIN32 */
         :
         :	                if (len1 >= TEXTBUFLEN)
         :	                        a1p = (char *) palloc(len1 + 1);
    0.00 :	  75f848:       41 8d 7c 24 01          lea    0x1(%r12),%edi
    0.00 :	  75f84d:       48 63 ff                movslq %edi,%rdi
    0.00 :	  75f850:       e8 fb 94 03 00          callq  798d50 <palloc>
    0.00 :	  75f855:       49 89 c5                mov    %rax,%r13
    0.00 :	  75f858:       48 8d 85 d0 fb ff ff    lea    -0x430(%rbp),%rax
         :	                else
         :	                        a1p = a1buf;
         :	                if (len2 >= TEXTBUFLEN)
    0.00 :	  75f85f:       41 81 fe ff 03 00 00    cmp    $0x3ff,%r14d
    0.00 :	  75f866:       48 89 85 b0 f7 ff ff    mov    %rax,-0x850(%rbp)
    0.00 :	  75f86d:       0f 8e e0 fe ff ff       jle    75f753 <varstr_cmp+0xa3>
         :	                        a2p = (char *) palloc(len2 + 1);
    0.00 :	  75f873:       41 8d 7e 01             lea    0x1(%r14),%edi
    0.00 :	  75f877:       48 63 ff                movslq %edi,%rdi
    0.00 :	  75f87a:       e8 d1 94 03 00          callq  798d50 <palloc>
    0.00 :	  75f87f:       49 89 c4                mov    %rax,%r12
    0.00 :	  75f882:       48 8d 85 d0 f7 ff ff    lea    -0x830(%rbp),%rax
    0.00 :	  75f889:       48 89 85 a8 f7 ff ff    mov    %rax,-0x858(%rbp)
    0.00 :	  75f890:       e9 cf fe ff ff          jmpq   75f764 <varstr_cmp+0xb4>
    0.00 :	  75f895:       0f 1f 00                nopl   (%rax)
         :	                 * equal.  Believing that would be bad news for a number of reasons,
         :	                 * so we follow Perl's lead and sort "equal" strings according to
         :	                 * strcmp().
         :	                 */
         :	                if (result == 0)
         :	                        result = strcmp(a1p, a2p);
    0.00 :	  75f898:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  75f89b:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75f89e:       e8 8d a4 d0 ff          callq  469d30 <strcmp@plt>
    0.00 :	  75f8a3:       89 c3                   mov    %eax,%ebx
    0.00 :	  75f8a5:       e9 16 ff ff ff          jmpq   75f7c0 <varstr_cmp+0x110>
    0.00 :	  75f8aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * strcoll() by itself, so we don't lose much if this doesn't work out
         :	                 * very often, and if it does - for example, because there are many
         :	                 * equal strings in the input - then we win big by avoiding expensive
         :	                 * collation-aware comparisons.
         :	                 */
         :	                if (len1 == len2 && memcmp(arg1, arg2, len1) == 0)
    0.00 :	  75f8b0:       48 8b b5 c0 f7 ff ff    mov    -0x840(%rbp),%rsi
    0.00 :	  75f8b7:       48 8b bd b8 f7 ff ff    mov    -0x848(%rbp),%rdi
    0.00 :	  75f8be:       4d 63 fc                movslq %r12d,%r15
    0.00 :	  75f8c1:       4d 39 ff                cmp    %r15,%r15
    0.00 :	  75f8c4:       4c 89 f9                mov    %r15,%rcx
    0.00 :	  75f8c7:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
    0.00 :	  75f8c9:       0f 97 c2                seta   %dl
    0.00 :	  75f8cc:       0f 92 c0                setb   %al
    0.00 :	  75f8cf:       31 db                   xor    %ebx,%ebx
    0.00 :	  75f8d1:       38 c2                   cmp    %al,%dl
    0.00 :	  75f8d3:       0f 85 4f fe ff ff       jne    75f728 <varstr_cmp+0x78>
    0.00 :	  75f8d9:       e9 04 ff ff ff          jmpq   75f7e2 <varstr_cmp+0x132>
    0.00 :	  75f8de:       66 90                   xchg   %ax,%ax
         :	#ifdef HAVE_LOCALE_T
         :	                if (mylocale)
         :	                        result = strcoll_l(a1p, a2p, mylocale);
         :	                else
         :	#endif
         :	                        result = strcoll(a1p, a2p);
    0.00 :	  75f8e0:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  75f8e3:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75f8e6:       e8 25 9b d0 ff          callq  469410 <strcoll@plt>
    0.00 :	  75f8eb:       89 c3                   mov    %eax,%ebx
    0.00 :	  75f8ed:       e9 c6 fe ff ff          jmpq   75f7b8 <varstr_cmp+0x108>
         :	                        {
         :	                                /*
         :	                                 * This typically means that the parser could not resolve a
         :	                                 * conflict of implicit collations, so report it that way.
         :	                                 */
         :	                                ereport(ERROR,
    0.00 :	  75f8f2:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  75f8f5:       b9 f5 bf 8c 00          mov    $0x8cbff5,%ecx
    0.00 :	  75f8fa:       ba 79 05 00 00          mov    $0x579,%edx
    0.00 :	  75f8ff:       be 8b bb 8c 00          mov    $0x8cbb8b,%esi
    0.00 :	  75f904:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  75f909:       e8 b2 b1 01 00          callq  77aac0 <errstart>
    0.00 :	  75f90e:       84 c0                   test   %al,%al
    0.00 :	  75f910:       75 05                   jne    75f917 <varstr_cmp+0x267>
    0.00 :	  75f912:       e8 b9 9b d0 ff          callq  4694d0 <abort@plt>
    0.00 :	  75f917:       bf f0 18 7c 00          mov    $0x7c18f0,%edi
    0.00 :	  75f91c:       31 c0                   xor    %eax,%eax
    0.00 :	  75f91e:       e8 7d c3 01 00          callq  77bca0 <errhint>
    0.00 :	  75f923:       bf f0 bd 8c 00          mov    $0x8cbdf0,%edi
    0.00 :	  75f928:       41 89 c4                mov    %eax,%r12d
    0.00 :	  75f92b:       31 c0                   xor    %eax,%eax
    0.00 :	  75f92d:       e8 6e cf 01 00          callq  77c8a0 <errmsg>
    0.00 :	  75f932:       bf 84 00 0a 02          mov    $0x20a0084,%edi
    0.00 :	  75f937:       89 c3                   mov    %eax,%ebx
    0.00 :	  75f939:       e8 12 d4 01 00          callq  77cd50 <errcode>
    0.00 :	  75f93e:       44 89 e2                mov    %r12d,%edx
    0.00 :	  75f941:       89 c7                   mov    %eax,%edi
    0.00 :	  75f943:       89 de                   mov    %ebx,%esi
    0.00 :	  75f945:       31 c0                   xor    %eax,%eax
    0.00 :	  75f947:       e8 94 ac 01 00          callq  77a5e0 <errfinish>
    0.00 :	  75f94c:       eb c4                   jmp    75f912 <varstr_cmp+0x262>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2874
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2889
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2878
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:143
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2892
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2856
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2856
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2856
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2856
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:125
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2865
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2873
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2872
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2874
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2878
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:134
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2897
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
    2.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2868
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a0b10 <comparetup_heap>:
         :	 * Routines specialized for HeapTuple (actually MinimalTuple) case
         :	 */
         :
         :	static int
         :	comparetup_heap(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)
         :	{
    0.00 :	  7a0b10:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2856
    2.38 :	  7a0b11:       48 89 e5                mov    %rsp,%rbp
    2.38 :	  7a0b14:       41 57                   push   %r15
    2.38 :	  7a0b16:       41 56                   push   %r14
    0.00 :	  7a0b18:       41 55                   push   %r13
    2.38 :	  7a0b1a:       41 54                   push   %r12
    0.00 :	  7a0b1c:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7a0b1f:       53                      push   %rbx
    0.00 :	  7a0b20:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7a0b23:       48 83 ec 58             sub    $0x58,%rsp
    0.00 :	  7a0b27:       48 89 55 80             mov    %rdx,-0x80(%rbp)
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:125
    2.38 :	  7a0b2b:       80 7b 10 00             cmpb   $0x0,0x10(%rbx)
         :	        TupleDesc       tupDesc;
         :	        int                     nkey;
         :	        int32           compare;
         :
         :	        /* Compare the leading sort key */
         :	        compare = ApplySortComparator(a->datum1, a->isnull1,
    0.00 :	  7a0b2f:       0f b6 46 10             movzbl 0x10(%rsi),%eax
         :	 */
         :
         :	static int
         :	comparetup_heap(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)
         :	{
         :	        SortSupport sortKey = state->sortKeys;
    0.00 :	  7a0b33:       4c 8b aa f8 00 00 00    mov    0xf8(%rdx),%r13
         :	        TupleDesc       tupDesc;
         :	        int                     nkey;
         :	        int32           compare;
         :
         :	        /* Compare the leading sort key */
         :	        compare = ApplySortComparator(a->datum1, a->isnull1,
    0.00 :	  7a0b3a:       48 8b 76 08             mov    0x8(%rsi),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2865
    2.38 :	  7a0b3e:       48 8b 7f 08             mov    0x8(%rdi),%rdi
    0.00 :	  7a0b42:       0f 84 e8 02 00 00       je     7a0e30 <comparetup_heap+0x320>
         :	        {
         :	                if (isNull2)
    0.00 :	  7a0b48:       84 c0                   test   %al,%al
    0.00 :	  7a0b4a:       0f 84 70 03 00 00       je     7a0ec0 <comparetup_heap+0x3b0>
         :	                                                                  sortKey);
         :	        if (compare != 0)
         :	                return compare;
         :
         :	        /* Compare additional sort keys */
         :	        ltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  7a0b50:       48 8b 13                mov    (%rbx),%rdx
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0b53:       48 8b 4d 80             mov    -0x80(%rbp),%rcx
         :	                                                                  sortKey);
         :	        if (compare != 0)
         :	                return compare;
         :
         :	        /* Compare additional sort keys */
         :	        ltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  7a0b57:       8b 02                   mov    (%rdx),%eax
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2873
    2.38 :	  7a0b59:       48 83 ea 08             sub    $0x8,%rdx
    0.00 :	  7a0b5d:       48 89 55 c0             mov    %rdx,-0x40(%rbp)
         :	                                                                  sortKey);
         :	        if (compare != 0)
         :	                return compare;
         :
         :	        /* Compare additional sort keys */
         :	        ltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  7a0b61:       83 c0 08                add    $0x8,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2872
    2.38 :	  7a0b64:       89 45 b0                mov    %eax,-0x50(%rbp)
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2874
    2.38 :	  7a0b67:       49 8b 14 24             mov    (%r12),%rdx
    0.00 :	  7a0b6b:       8b 02                   mov    (%rdx),%eax
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
    0.00 :	  7a0b6d:       48 83 ea 08             sub    $0x8,%rdx
    0.00 :	  7a0b71:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
         :	                return compare;
         :
         :	        /* Compare additional sort keys */
         :	        ltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
    4.76 :	  7a0b75:       83 c0 08                add    $0x8,%eax
    0.00 :	  7a0b78:       89 45 90                mov    %eax,-0x70(%rbp)
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
    0.00 :	  7a0b7b:       48 8b 45 80             mov    -0x80(%rbp),%rax
    0.00 :	  7a0b7f:       48 8b 80 f0 00 00 00    mov    0xf0(%rax),%rax
    0.00 :	  7a0b86:       48 89 45 88             mov    %rax,-0x78(%rbp)
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0b8a:       83 79 04 01             cmpl   $0x1,0x4(%rcx)
    0.00 :	  7a0b8e:       0f 8e 74 03 00 00       jle    7a0f08 <comparetup_heap+0x3f8>
         :	        ltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
    0.00 :	  7a0b94:       49 83 c5 20             add    $0x20,%r13
    0.00 :	  7a0b98:       41 bf 01 00 00 00       mov    $0x1,%r15d
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
         :	        {
         :	                AttrNumber      attno = sortKey->ssup_attno;
    0.00 :	  7a0b9e:       41 0f b7 5d 0e          movzwl 0xe(%r13),%ebx
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0ba3:       66 85 db                test   %bx,%bx
    0.00 :	  7a0ba6:       0f 8e 00 01 00 00       jle    7a0cac <comparetup_heap+0x19c>
    0.00 :	  7a0bac:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a0bb0:       48 8b 75 c0             mov    -0x40(%rbp),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 :	  7a0bb4:       44 0f bf e3             movswl %bx,%r12d
    0.00 :	  7a0bb8:       0f b7 46 12             movzwl 0x12(%rsi),%eax
    0.00 :	  7a0bbc:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  7a0bc1:       41 39 c4                cmp    %eax,%r12d
    0.00 :	  7a0bc4:       0f 8f 84 00 00 00       jg     7a0c4e <comparetup_heap+0x13e>
    0.00 :	  7a0bca:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
    0.00 :	  7a0bce:       f6 46 14 01             testb  $0x1,0x14(%rsi)
    0.00 :	  7a0bd2:       75 5c                   jne    7a0c30 <comparetup_heap+0x120>
    0.00 :	  7a0bd4:       48 8b 4d 88             mov    -0x78(%rbp),%rcx
    2.38 :	  7a0bd8:       48 0f bf d3             movswq %bx,%rdx
    0.00 :	  7a0bdc:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  7a0be0:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    7.14 :	  7a0be5:       8b 42 54                mov    0x54(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    4.76 :	  7a0be8:       85 c0                   test   %eax,%eax
    0.00 :	  7a0bea:       0f 88 c8 01 00 00       js     7a0db8 <comparetup_heap+0x2a8>
    0.00 :	  7a0bf0:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  7a0bf4:       0f 84 1e 02 00 00       je     7a0e18 <comparetup_heap+0x308>
    0.00 :	  7a0bfa:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  7a0bfe:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  7a0c02:       0f 84 58 02 00 00       je     7a0e60 <comparetup_heap+0x350>
    0.00 :	  7a0c08:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  7a0c0c:       0f 84 de 02 00 00       je     7a0ef0 <comparetup_heap+0x3e0>
    0.00 :	  7a0c12:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  7a0c16:       0f 84 74 02 00 00       je     7a0e90 <comparetup_heap+0x380>
    0.00 :	  7a0c1c:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0c20:       48 98                   cltq   
    0.00 :	  7a0c22:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0c26:       44 0f b6 34 10          movzbl (%rax,%rdx,1),%r14d
    0.00 :	  7a0c2b:       eb 28                   jmp    7a0c55 <comparetup_heap+0x145>
    0.00 :	  7a0c2d:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a0c30:       41 8d 4c 24 ff          lea    -0x1(%r12),%ecx
    0.00 :	  7a0c35:       89 c8                   mov    %ecx,%eax
    0.00 :	  7a0c37:       83 e1 07                and    $0x7,%ecx
    0.00 :	  7a0c3a:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  7a0c3d:       48 98                   cltq   
    0.00 :	  7a0c3f:       0f b6 44 06 17          movzbl 0x17(%rsi,%rax,1),%eax
    0.00 :	  7a0c44:       d3 f8                   sar    %cl,%eax
    0.00 :	  7a0c46:       a8 01                   test   $0x1,%al
    0.00 :	  7a0c48:       0f 85 6a 01 00 00       jne    7a0db8 <comparetup_heap+0x2a8>
    0.00 :	  7a0c4e:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
    0.00 :	  7a0c52:       45 31 f6                xor    %r14d,%r14d
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    2.38 :	  7a0c55:       48 8b 75 a0             mov    -0x60(%rbp),%rsi
    2.38 :	  7a0c59:       0f b7 46 12             movzwl 0x12(%rsi),%eax
    2.38 :	  7a0c5d:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  7a0c62:       41 39 c4                cmp    %eax,%r12d
    0.00 :	  7a0c65:       0f 8e ad 00 00 00       jle    7a0d18 <comparetup_heap+0x208>
    0.00 :	  7a0c6b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a0c70:       c6 45 ce 01             movb   $0x1,-0x32(%rbp)
    0.00 :	  7a0c74:       31 c0                   xor    %eax,%eax
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a0c76:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :
         :	                compare = ApplySortComparator(datum1, isnull1,
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2889
    4.76 :	  7a0c7a:       0f b6 55 ce             movzbl -0x32(%rbp),%edx
    0.00 :	  7a0c7e:       74 68                   je     7a0ce8 <comparetup_heap+0x1d8>
         :	        {
         :	                if (isNull2)
    0.00 :	  7a0c80:       84 d2                   test   %dl,%dl
    0.00 :	  7a0c82:       0f 84 38 02 00 00       je     7a0ec0 <comparetup_heap+0x3b0>
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0c88:       48 8b 45 80             mov    -0x80(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2878
    2.38 :	  7a0c8c:       41 83 c7 01             add    $0x1,%r15d
    0.00 :	  7a0c90:       44 39 78 04             cmp    %r15d,0x4(%rax)
    0.00 :	  7a0c94:       0f 8e 6e 02 00 00       jle    7a0f08 <comparetup_heap+0x3f8>
    4.76 :	  7a0c9a:       49 83 c5 20             add    $0x20,%r13
         :	        {
         :	                AttrNumber      attno = sortKey->ssup_attno;
    0.00 :	  7a0c9e:       41 0f b7 5d 0e          movzwl 0xe(%r13),%ebx
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0ca3:       66 85 db                test   %bx,%bx
    0.00 :	  7a0ca6:       0f 8f 04 ff ff ff       jg     7a0bb0 <comparetup_heap+0xa0>
    0.00 :	  7a0cac:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  7a0cb0:       0f bf db                movswl %bx,%ebx
    0.00 :	  7a0cb3:       48 8d 4d cf             lea    -0x31(%rbp),%rcx
    0.00 :	  7a0cb7:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  7a0cbb:       89 de                   mov    %ebx,%esi
    0.00 :	  7a0cbd:       e8 0e e0 cc ff          callq  46ecd0 <heap_getsysattr>
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0cc2:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  7a0cc6:       48 8d 4d ce             lea    -0x32(%rbp),%rcx
    0.00 :	  7a0cca:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  7a0cce:       89 de                   mov    %ebx,%esi
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0cd0:       49 89 c6                mov    %rax,%r14
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0cd3:       e8 f8 df cc ff          callq  46ecd0 <heap_getsysattr>
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a0cd8:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :
         :	                compare = ApplySortComparator(datum1, isnull1,
    0.00 :	  7a0cdc:       0f b6 55 ce             movzbl -0x32(%rbp),%edx
    0.00 :	  7a0ce0:       75 9e                   jne    7a0c80 <comparetup_heap+0x170>
    0.00 :	  7a0ce2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:134
    2.38 :	  7a0ce8:       84 d2                   test   %dl,%dl
    0.00 :	  7a0cea:       0f 84 e0 00 00 00       je     7a0dd0 <comparetup_heap+0x2c0>
         :	        {
         :	                if (ssup->ssup_nulls_first)
    0.00 :	  7a0cf0:       41 80 7d 0d 00          cmpb   $0x0,0xd(%r13)
    0.00 :	  7a0cf5:       0f 84 d0 01 00 00       je     7a0ecb <comparetup_heap+0x3bb>
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0cfb:       ba 01 00 00 00          mov    $0x1,%edx
         :	                if (compare != 0)
         :	                        return compare;
         :	        }
         :
         :	        return 0;
         :	}
    0.00 :	  7a0d00:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  7a0d04:       89 d0                   mov    %edx,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2897
    2.38 :	  7a0d06:       5b                      pop    %rbx
    0.00 :	  7a0d07:       41 5c                   pop    %r12
    0.00 :	  7a0d09:       41 5d                   pop    %r13
    0.00 :	  7a0d0b:       41 5e                   pop    %r14
    0.00 :	  7a0d0d:       41 5f                   pop    %r15
    0.00 :	  7a0d0f:       c9                      leaveq 
    0.00 :	  7a0d10:       c3                      retq   
    0.00 :	  7a0d11:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2887
    4.76 :	  7a0d18:       c6 45 ce 00             movb   $0x0,-0x32(%rbp)
    0.00 :	  7a0d1c:       f6 46 14 01             testb  $0x1,0x14(%rsi)
    0.00 :	  7a0d20:       75 5e                   jne    7a0d80 <comparetup_heap+0x270>
    0.00 :	  7a0d22:       48 8b 4d 88             mov    -0x78(%rbp),%rcx
    2.38 :	  7a0d26:       48 0f bf d3             movswq %bx,%rdx
    0.00 :	  7a0d2a:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  7a0d2e:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    2.38 :	  7a0d33:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  7a0d36:       85 c0                   test   %eax,%eax
    0.00 :	  7a0d38:       78 64                   js     7a0d9e <comparetup_heap+0x28e>
    0.00 :	  7a0d3a:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  7a0d3e:       0f 84 bc 00 00 00       je     7a0e00 <comparetup_heap+0x2f0>
    0.00 :	  7a0d44:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  7a0d48:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  7a0d4c:       0f 84 26 01 00 00       je     7a0e78 <comparetup_heap+0x368>
    0.00 :	  7a0d52:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  7a0d56:       0f 84 7c 01 00 00       je     7a0ed8 <comparetup_heap+0x3c8>
    0.00 :	  7a0d5c:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  7a0d60:       0f 84 42 01 00 00       je     7a0ea8 <comparetup_heap+0x398>
    0.00 :	  7a0d66:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0d6a:       48 98                   cltq   
    0.00 :	  7a0d6c:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0d70:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  7a0d74:       e9 fd fe ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0d79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  7a0d80:       41 8d 4c 24 ff          lea    -0x1(%r12),%ecx
    0.00 :	  7a0d85:       89 c8                   mov    %ecx,%eax
    0.00 :	  7a0d87:       83 e1 07                and    $0x7,%ecx
    0.00 :	  7a0d8a:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  7a0d8d:       48 98                   cltq   
    0.00 :	  7a0d8f:       0f b6 44 06 17          movzbl 0x17(%rsi,%rax,1),%eax
    0.00 :	  7a0d94:       d3 f8                   sar    %cl,%eax
    0.00 :	  7a0d96:       a8 01                   test   $0x1,%al
    0.00 :	  7a0d98:       0f 84 d2 fe ff ff       je     7a0c70 <comparetup_heap+0x160>
    0.00 :	  7a0d9e:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  7a0da2:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  7a0da6:       44 89 e6                mov    %r12d,%esi
    0.00 :	  7a0da9:       e8 e2 eb cc ff          callq  46f990 <nocachegetattr>
    0.00 :	  7a0dae:       e9 c3 fe ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0db3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2886
    2.38 :	  7a0db8:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  7a0dbc:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  7a0dc0:       44 89 e6                mov    %r12d,%esi
    0.00 :	  7a0dc3:       e8 c8 eb cc ff          callq  46f990 <nocachegetattr>
    2.38 :	  7a0dc8:       49 89 c6                mov    %rax,%r14
    0.00 :	  7a0dcb:       e9 85 fe ff ff          jmpq   7a0c55 <comparetup_heap+0x145>
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a0dd0:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  7a0dd3:       48 89 c6                mov    %rax,%rsi
    0.00 :	  7a0dd6:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7a0dd9:       41 ff 55 18             callq  *0x18(%r13)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:143
    4.76 :	  7a0ddd:       89 c2                   mov    %eax,%edx
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a0ddf:       f7 d8                   neg    %eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
    2.38 :	  7a0de1:       41 80 7d 0c 00          cmpb   $0x0,0xc(%r13)
    2.38 :	  7a0de6:       0f 45 d0                cmovne %eax,%edx
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
         :
         :	                compare = ApplySortComparator(datum1, isnull1,
         :	                                                                          datum2, isnull2,
         :	                                                                          sortKey);
         :	                if (compare != 0)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2892
    4.76 :	  7a0de9:       85 d2                   test   %edx,%edx
    0.00 :	  7a0deb:       0f 84 97 fe ff ff       je     7a0c88 <comparetup_heap+0x178>
    0.00 :	  7a0df1:       e9 0a ff ff ff          jmpq   7a0d00 <comparetup_heap+0x1f0>
    0.00 :	  7a0df6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a0dfd:       00 00 00 
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0e00:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0e04:       48 98                   cltq   
    0.00 :	  7a0e06:       48 01 d0                add    %rdx,%rax
    0.00 :	  7a0e09:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0e0d:       e9 64 fe ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0e12:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0e18:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0e1c:       48 98                   cltq   
    0.00 :	  7a0e1e:       48 01 d0                add    %rdx,%rax
    0.00 :	  7a0e21:       4c 8d 34 06             lea    (%rsi,%rax,1),%r14
    0.00 :	  7a0e25:       e9 2b fe ff ff          jmpq   7a0c55 <comparetup_heap+0x145>
    0.00 :	  7a0e2a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
    0.00 :	  7a0e30:       84 c0                   test   %al,%al
    0.00 :	  7a0e32:       0f 85 b8 fe ff ff       jne    7a0cf0 <comparetup_heap+0x1e0>
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a0e38:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  7a0e3b:       41 ff 55 18             callq  *0x18(%r13)
    0.00 :	  7a0e3f:       89 c2                   mov    %eax,%edx
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a0e41:       f7 d8                   neg    %eax
    0.00 :	  7a0e43:       41 80 7d 0c 00          cmpb   $0x0,0xc(%r13)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
    2.38 :	  7a0e48:       0f 45 d0                cmovne %eax,%edx
         :
         :	        /* Compare the leading sort key */
         :	        compare = ApplySortComparator(a->datum1, a->isnull1,
         :	                                                                  b->datum1, b->isnull1,
         :	                                                                  sortKey);
         :	        if (compare != 0)
    0.00 :	  7a0e4b:       85 d2                   test   %edx,%edx
    0.00 :	  7a0e4d:       0f 85 ad fe ff ff       jne    7a0d00 <comparetup_heap+0x1f0>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2868
    2.38 :	  7a0e53:       e9 f8 fc ff ff          jmpq   7a0b50 <comparetup_heap+0x40>
    0.00 :	  7a0e58:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  7a0e5f:       00 
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0e60:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0e64:       48 98                   cltq   
    0.00 :	  7a0e66:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0e6a:       4c 8b 34 10             mov    (%rax,%rdx,1),%r14
    0.00 :	  7a0e6e:       e9 e2 fd ff ff          jmpq   7a0c55 <comparetup_heap+0x145>
    0.00 :	  7a0e73:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0e78:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0e7c:       48 98                   cltq   
    0.00 :	  7a0e7e:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0e82:       48 8b 04 10             mov    (%rax,%rdx,1),%rax
    0.00 :	  7a0e86:       e9 eb fd ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0e8b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0e90:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0e94:       48 98                   cltq   
    0.00 :	  7a0e96:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0e9a:       44 0f b7 34 10          movzwl (%rax,%rdx,1),%r14d
    0.00 :	  7a0e9f:       e9 b1 fd ff ff          jmpq   7a0c55 <comparetup_heap+0x145>
    0.00 :	  7a0ea4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0ea8:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0eac:       48 98                   cltq   
    0.00 :	  7a0eae:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0eb2:       0f b7 04 10             movzwl (%rax,%rdx,1),%eax
    0.00 :	  7a0eb6:       e9 bb fd ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0ebb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
         :	                        compare = 0;            /* NULL "=" NULL */
         :	                else if (ssup->ssup_nulls_first)
    0.00 :	  7a0ec0:       41 80 7d 0d 00          cmpb   $0x0,0xd(%r13)
    0.00 :	  7a0ec5:       0f 84 30 fe ff ff       je     7a0cfb <comparetup_heap+0x1eb>
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0ecb:       ba ff ff ff ff          mov    $0xffffffff,%edx
    0.00 :	  7a0ed0:       e9 2b fe ff ff          jmpq   7a0d00 <comparetup_heap+0x1f0>
    0.00 :	  7a0ed5:       0f 1f 00                nopl   (%rax)
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
         :	                datum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);
    0.00 :	  7a0ed8:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0edc:       48 98                   cltq   
    0.00 :	  7a0ede:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0ee2:       8b 04 10                mov    (%rax,%rdx,1),%eax
    0.00 :	  7a0ee5:       e9 8c fd ff ff          jmpq   7a0c76 <comparetup_heap+0x166>
    0.00 :	  7a0eea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                Datum           datum1,
         :	                                        datum2;
         :	                bool            isnull1,
         :	                                        isnull2;
         :
         :	                datum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);
    0.00 :	  7a0ef0:       0f b6 56 16             movzbl 0x16(%rsi),%edx
    0.00 :	  7a0ef4:       48 98                   cltq   
    0.00 :	  7a0ef6:       48 8d 04 06             lea    (%rsi,%rax,1),%rax
    0.00 :	  7a0efa:       44 8b 34 10             mov    (%rax,%rdx,1),%r14d
    0.00 :	  7a0efe:       e9 52 fd ff ff          jmpq   7a0c55 <comparetup_heap+0x145>
    0.00 :	  7a0f03:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        ltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);
         :	        rtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;
         :	        rtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);
         :	        tupDesc = state->tupDesc;
         :	        sortKey++;
         :	        for (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)
    0.00 :	  7a0f08:       31 d2                   xor    %edx,%edx
    0.00 :	  7a0f0a:       e9 f1 fd ff ff          jmpq   7a0d00 <comparetup_heap+0x1f0>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
   32.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1097
    7.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1077
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1056
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1075
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1082
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
    2.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbda0 <ExecScanHashBucket>:
         :	 * for the latter.
         :	 */
         :	bool
         :	ExecScanHashBucket(HashJoinState *hjstate,
         :	                                   ExprContext *econtext)
         :	{
    0.00 :	  5bbda0:       55                      push   %rbp
    0.00 :	  5bbda1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bbda4:       41 57                   push   %r15
    0.00 :	  5bbda6:       41 56                   push   %r14
    0.00 :	  5bbda8:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5bbdab:       41 55                   push   %r13
    0.00 :	  5bbdad:       41 54                   push   %r12
    0.00 :	  5bbdaf:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5bbdb2:       53                      push   %rbx
    0.00 :	  5bbdb3:       48 83 ec 08             sub    $0x8,%rsp
         :	        List       *hjclauses = hjstate->hashclauses;
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
         :	        HashJoinTuple hashTuple = hjstate->hj_CurTuple;
    0.00 :	  5bbdb7:       48 8b 87 c0 00 00 00    mov    0xc0(%rdi),%rax
         :	 */
         :	bool
         :	ExecScanHashBucket(HashJoinState *hjstate,
         :	                                   ExprContext *econtext)
         :	{
         :	        List       *hjclauses = hjstate->hashclauses;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1056
    2.50 :	  5bbdbe:       4c 8b bf 88 00 00 00    mov    0x88(%rdi),%r15
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bbdc5:       48 8b 8f a8 00 00 00    mov    0xa8(%rdi),%rcx
         :	        HashJoinTuple hashTuple = hjstate->hj_CurTuple;
         :	        uint32          hashvalue = hjstate->hj_CurHashValue;
    0.00 :	  5bbdcc:       44 8b af b0 00 00 00    mov    0xb0(%rdi),%r13d
         :	         * bucket, or NULL if it's time to start scanning a new bucket.
         :	         *
         :	         * If the tuple hashed to a skew bucket then scan the skew bucket
         :	         * otherwise scan the standard hashtable bucket.
         :	         */
         :	        if (hashTuple != NULL)
    0.00 :	  5bbdd3:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbdd6:       74 79                   je     5bbe51 <ExecScanHashBucket+0xb1>
         :	                hashTuple = hashTuple->next;
    0.00 :	  5bbdd8:       48 8b 18                mov    (%rax),%rbx
    0.00 :	  5bbddb:       eb 06                   jmp    5bbde3 <ExecScanHashBucket+0x43>
    0.00 :	  5bbddd:       0f 1f 00                nopl   (%rax)
         :	                                hjstate->hj_CurTuple = hashTuple;
         :	                                return true;
         :	                        }
         :	                }
         :
         :	                hashTuple = hashTuple->next;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1097
   32.50 :	  5bbde0:       48 8b 1b                mov    (%rbx),%rbx
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
         :
         :	        while (hashTuple != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1075
    2.50 :	  5bbde3:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbde6:       74 58                   je     5bbe40 <ExecScanHashBucket+0xa0>
         :	        {
         :	                if (hashTuple->hashvalue == hashvalue)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1077
    7.50 :	  5bbde8:       44 39 6b 08             cmp    %r13d,0x8(%rbx)
    0.00 :	  5bbdec:       75 f2                   jne    5bbde0 <ExecScanHashBucket+0x40>
         :	                {
         :	                        TupleTableSlot *inntuple;
         :
         :	                        /* insert hashtable's tuple into exec slot so ExecQual sees it */
         :	                        inntuple = ExecStoreMinimalTuple(HJTUPLE_MINTUPLE(hashTuple),
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1082
    2.50 :	  5bbdee:       49 8b b4 24 d0 00 00    mov    0xd0(%r12),%rsi
    0.00 :	  5bbdf5:       00 
    0.00 :	  5bbdf6:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  5bbdfa:       31 d2                   xor    %edx,%edx
    0.00 :	  5bbdfc:       e8 df 85 ff ff          callq  5b43e0 <ExecStoreMinimalTuple>
         :	                                                                                         hjstate->hj_HashTupleSlot,
         :	                                                                                         false);        /* do not pfree */
         :	                        econtext->ecxt_innertuple = inntuple;
         :
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
    0.00 :	  5bbe01:       49 8b 7e 28             mov    0x28(%r14),%rdi
         :
         :	                        /* insert hashtable's tuple into exec slot so ExecQual sees it */
         :	                        inntuple = ExecStoreMinimalTuple(HJTUPLE_MINTUPLE(hashTuple),
         :	                                                                                         hjstate->hj_HashTupleSlot,
         :	                                                                                         false);        /* do not pfree */
         :	                        econtext->ecxt_innertuple = inntuple;
    0.00 :	  5bbe05:       49 89 46 10             mov    %rax,0x10(%r14)
         :
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
    0.00 :	  5bbe09:       e8 a2 cb 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                        if (ExecQual(hjclauses, econtext, false))
    0.00 :	  5bbe0e:       31 d2                   xor    %edx,%edx
    0.00 :	  5bbe10:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5bbe13:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bbe16:       e8 f5 10 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5bbe1b:       84 c0                   test   %al,%al
    0.00 :	  5bbe1d:       74 c1                   je     5bbde0 <ExecScanHashBucket+0x40>
         :	                        {
         :	                                hjstate->hj_CurTuple = hashTuple;
    0.00 :	  5bbe1f:       49 89 9c 24 c0 00 00    mov    %rbx,0xc0(%r12)
    0.00 :	  5bbe26:       00 
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe27:       48 83 c4 08             add    $0x8,%rsp
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
         :
         :	                        if (ExecQual(hjclauses, econtext, false))
         :	                        {
         :	                                hjstate->hj_CurTuple = hashTuple;
    0.00 :	  5bbe2b:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe30:       5b                      pop    %rbx
    0.00 :	  5bbe31:       41 5c                   pop    %r12
    0.00 :	  5bbe33:       41 5d                   pop    %r13
    0.00 :	  5bbe35:       41 5e                   pop    %r14
    0.00 :	  5bbe37:       41 5f                   pop    %r15
    0.00 :	  5bbe39:       c9                      leaveq 
    0.00 :	  5bbe3a:       c3                      retq   
    0.00 :	  5bbe3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    5.00 :	  5bbe40:       48 83 c4 08             add    $0x8,%rsp
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
         :
         :	        while (hashTuple != NULL)
    0.00 :	  5bbe44:       31 c0                   xor    %eax,%eax
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe46:       5b                      pop    %rbx
    0.00 :	  5bbe47:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    2.50 :	  5bbe49:       41 5d                   pop    %r13
    0.00 :	  5bbe4b:       41 5e                   pop    %r14
    0.00 :	  5bbe4d:       41 5f                   pop    %r15
    0.00 :	  5bbe4f:       c9                      leaveq 
    0.00 :	  5bbe50:       c3                      retq   
         :	         * If the tuple hashed to a skew bucket then scan the skew bucket
         :	         * otherwise scan the standard hashtable bucket.
         :	         */
         :	        if (hashTuple != NULL)
         :	                hashTuple = hashTuple->next;
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
    0.00 :	  5bbe51:       8b 87 b8 00 00 00       mov    0xb8(%rdi),%eax
    0.00 :	  5bbe57:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  5bbe5a:       74 13                   je     5bbe6f <ExecScanHashBucket+0xcf>
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
    0.00 :	  5bbe5c:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  5bbe60:       48 98                   cltq   
    0.00 :	  5bbe62:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  5bbe66:       48 8b 58 08             mov    0x8(%rax),%rbx
    0.00 :	  5bbe6a:       e9 74 ff ff ff          jmpq   5bbde3 <ExecScanHashBucket+0x43>
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
    2.50 :	  5bbe6f:       48 63 97 b4 00 00 00    movslq 0xb4(%rdi),%rdx
    0.00 :	  5bbe76:       48 8b 41 18             mov    0x18(%rcx),%rax
    2.50 :	  5bbe7a:       48 8b 1c d0             mov    (%rax,%rdx,8),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
   40.00 :	  5bbe7e:       e9 60 ff ff ff          jmpq   5bbde3 <ExecScanHashBucket+0x43>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   24.14 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
   10.34 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    6.90 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    6.90 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1052
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1054
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1107
    3.45 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046ef10 <slot_deform_tuple>:
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46ef10:       55                      push   %rbp
    0.00 :	  46ef11:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46ef14:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    3.45 :	  46ef16:       41 89 f7                mov    %esi,%r15d
    0.00 :	  46ef19:       41 56                   push   %r14
    3.45 :	  46ef1b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  46ef1e:       41 55                   push   %r13
    0.00 :	  46ef20:       41 54                   push   %r12
    0.00 :	  46ef22:       53                      push   %rbx
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef23:       31 db                   xor    %ebx,%ebx
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46ef25:       48 83 ec 28             sub    $0x28,%rsp
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
    0.00 :	  46ef29:       48 8b 47 28             mov    0x28(%rdi),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1052
    3.45 :	  46ef2d:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46ef31:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
    0.00 :	  46ef35:       8b 77 24                mov    0x24(%rdi),%esi
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
    0.00 :	  46ef38:       4c 8b 5f 30             mov    0x30(%rdi),%r11
         :	        HeapTupleHeader tup = tuple->t_data;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1054
    3.45 :	  46ef3c:       4c 8b 40 10             mov    0x10(%rax),%r8
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
    0.00 :	  46ef40:       41 0f b7 40 14          movzwl 0x14(%r8),%eax
    0.00 :	  46ef45:       83 e0 01                and    $0x1,%eax
    0.00 :	  46ef48:       41 89 c2                mov    %eax,%r10d
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef4b:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef4f:       31 ff                   xor    %edi,%edi
    0.00 :	  46ef51:       85 f6                   test   %esi,%esi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef53:       4c 8b 48 08             mov    0x8(%rax),%r9
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef57:       74 09                   je     46ef62 <slot_deform_tuple+0x52>
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
    0.00 :	  46ef59:       41 0f b6 7e 07          movzbl 0x7(%r14),%edi
         :	                slow = false;
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
    0.00 :	  46ef5e:       49 8b 5e 58             mov    0x58(%r14),%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef62:       41 0f b6 40 16          movzbl 0x16(%r8),%eax
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46ef67:       44 39 fe                cmp    %r15d,%esi
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef6a:       4d 8d 2c 00             lea    (%r8,%rax,1),%r13
         :
         :	        for (; attnum < natts; attnum++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    3.45 :	  46ef6e:       0f 8d c0 00 00 00       jge    46f034 <slot_deform_tuple+0x124>
    0.00 :	  46ef74:       41 89 f4                mov    %esi,%r12d
    0.00 :	  46ef77:       eb 40                   jmp    46efb9 <slot_deform_tuple+0xa9>
    0.00 :	  46ef79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46ef80:       44 89 e0                mov    %r12d,%eax
    0.00 :	  46ef83:       44 89 e1                mov    %r12d,%ecx
    0.00 :	  46ef86:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46ef89:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46ef8c:       48 98                   cltq   
    0.00 :	  46ef8e:       41 0f b6 44 00 17       movzbl 0x17(%r8,%rax,1),%eax
    0.00 :	  46ef94:       d3 f8                   sar    %cl,%eax
    0.00 :	  46ef96:       a8 01                   test   $0x1,%al
    0.00 :	  46ef98:       75 2b                   jne    46efc5 <slot_deform_tuple+0xb5>
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46ef9a:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
         :	                        isnull[attnum] = true;
    0.00 :	  46ef9e:       bf 01 00 00 00          mov    $0x1,%edi
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46efa3:       48 c7 04 f2 00 00 00    movq   $0x0,(%rdx,%rsi,8)
    0.00 :	  46efaa:       00 
         :	                        isnull[attnum] = true;
    0.00 :	  46efab:       41 c6 04 33 01          movb   $0x1,(%r11,%rsi,1)
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    3.45 :	  46efb0:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  46efb4:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46efb7:       7e 78                   jle    46f031 <slot_deform_tuple+0x121>
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
    0.00 :	  46efb9:       49 63 f4                movslq %r12d,%rsi
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46efbc:       45 84 d2                test   %r10b,%r10b
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
    0.00 :	  46efbf:       49 8b 14 f1             mov    (%r9,%rsi,8),%rdx
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    3.45 :	  46efc3:       75 bb                   jne    46ef80 <slot_deform_tuple+0x70>
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
    0.00 :	  46efc5:       40 84 ff                test   %dil,%dil
         :	                        isnull[attnum] = true;
         :	                        slow = true;            /* can't use attcacheoff anymore */
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
    0.00 :	  46efc8:       41 c6 04 33 00          movb   $0x0,(%r11,%rsi,1)
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    3.45 :	  46efcd:       0f 85 7d 00 00 00       jne    46f050 <slot_deform_tuple+0x140>
    0.00 :	  46efd3:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  46efd6:       85 c0                   test   %eax,%eax
    0.00 :	  46efd8:       78 76                   js     46f050 <slot_deform_tuple+0x140>
         :	                        off = thisatt->attcacheoff;
    0.00 :	  46efda:       48 63 d8                movslq %eax,%rbx
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.45 :	  46efdd:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  46efe1:       49 8d 44 1d 00          lea    0x0(%r13,%rbx,1),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    6.90 :	  46efe6:       74 28                   je     46f010 <slot_deform_tuple+0x100>
    0.00 :	  46efe8:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    0.00 :	  46efec:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  46eff0:       0f 84 3a 01 00 00       je     46f130 <slot_deform_tuple+0x220>
    0.00 :	  46eff6:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  46effa:       0f 84 90 01 00 00       je     46f190 <slot_deform_tuple+0x280>
    0.00 :	  46f000:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  46f004:       0f 84 a6 01 00 00       je     46f1b0 <slot_deform_tuple+0x2a0>
    0.00 :	  46f00a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.45 :	  46f010:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
    0.00 :	  46f014:       48 89 04 f1             mov    %rax,(%rcx,%rsi,8)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
   24.14 :	  46f018:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    0.00 :	  46f01c:       66 85 c0                test   %ax,%ax
    0.00 :	  46f01f:       7e 6f                   jle    46f090 <slot_deform_tuple+0x180>
    0.00 :	  46f021:       48 0f bf c0             movswq %ax,%rax
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46f025:       41 83 c4 01             add    $0x1,%r12d
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f029:       48 01 c3                add    %rax,%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    3.45 :	  46f02c:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46f02f:       7f 88                   jg     46efb9 <slot_deform_tuple+0xa9>
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46f031:       44 89 fe                mov    %r15d,%esi
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
    0.00 :	  46f034:       49 89 5e 58             mov    %rbx,0x58(%r14)
         :	        }
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
    0.00 :	  46f038:       41 89 76 24             mov    %esi,0x24(%r14)
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
    0.00 :	  46f03c:       41 88 7e 07             mov    %dil,0x7(%r14)
         :	}
    0.00 :	  46f040:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46f044:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    3.45 :	  46f045:       41 5c                   pop    %r12
    0.00 :	  46f047:       41 5d                   pop    %r13
    0.00 :	  46f049:       41 5e                   pop    %r14
    0.00 :	  46f04b:       41 5f                   pop    %r15
    0.00 :	  46f04d:       c9                      leaveq 
    0.00 :	  46f04e:       c3                      retq   
    0.00 :	  46f04f:       90                      nop
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
         :	                        off = thisatt->attcacheoff;
         :	                else if (thisatt->attlen == -1)
    0.00 :	  46f050:       66 83 7a 4c ff          cmpw   $0xffff,0x4c(%rdx)
    0.00 :	  46f055:       74 71                   je     46f0c8 <slot_deform_tuple+0x1b8>
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    3.45 :	  46f057:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f05b:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f05d:       0f 84 1d 01 00 00       je     46f180 <slot_deform_tuple+0x270>
    0.00 :	  46f063:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f065:       74 10                   je     46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f067:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f069:       0f 84 51 01 00 00       je     46f1c0 <slot_deform_tuple+0x2b0>
    0.00 :	  46f06f:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f073:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
         :
         :	                        if (!slow)
    0.00 :	  46f077:       40 84 ff                test   %dil,%dil
    0.00 :	  46f07a:       0f 85 5d ff ff ff       jne    46efdd <slot_deform_tuple+0xcd>
         :	                                thisatt->attcacheoff = off;
    0.00 :	  46f080:       89 5a 54                mov    %ebx,0x54(%rdx)
    0.00 :	  46f083:       e9 55 ff ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f088:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46f08f:       00 
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f090:       66 83 c0 01             add    $0x1,%ax
    0.00 :	  46f094:       0f 85 a6 00 00 00       jne    46f140 <slot_deform_tuple+0x230>
    0.00 :	  46f09a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    6.90 :	  46f0a0:       3c 01                   cmp    $0x1,%al
    0.00 :	  46f0a2:       0f 84 50 01 00 00       je     46f1f8 <slot_deform_tuple+0x2e8>
    0.00 :	  46f0a8:       a8 01                   test   $0x1,%al
    0.00 :	  46f0aa:       0f 85 20 01 00 00       jne    46f1d0 <slot_deform_tuple+0x2c0>
    0.00 :	  46f0b0:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
    0.00 :	  46f0b5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  46f0b8:       89 c0                   mov    %eax,%eax
    0.00 :	  46f0ba:       48 8d 1c 18             lea    (%rax,%rbx,1),%rbx
    0.00 :	  46f0be:       e9 ad 00 00 00          jmpq   46f170 <slot_deform_tuple+0x260>
    0.00 :	  46f0c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1107
    3.45 :	  46f0c8:       40 84 ff                test   %dil,%dil
    0.00 :	  46f0cb:       75 26                   jne    46f0f3 <slot_deform_tuple+0x1e3>
    0.00 :	  46f0cd:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f0d1:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f0d3:       0f 84 4f 01 00 00       je     46f228 <slot_deform_tuple+0x318>
    0.00 :	  46f0d9:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f0db:       74 a3                   je     46f080 <slot_deform_tuple+0x170>
    0.00 :	  46f0dd:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f0df:       90                      nop
    0.00 :	  46f0e0:       0f 84 52 01 00 00       je     46f238 <slot_deform_tuple+0x328>
    0.00 :	  46f0e6:       48 8d 43 01             lea    0x1(%rbx),%rax
    0.00 :	  46f0ea:       48 83 e0 fe             and    $0xfffffffffffffffe,%rax
    0.00 :	  46f0ee:       48 39 d8                cmp    %rbx,%rax
    0.00 :	  46f0f1:       74 8d                   je     46f080 <slot_deform_tuple+0x170>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f0f3:       41 80 7c 1d 00 00       cmpb   $0x0,0x0(%r13,%rbx,1)
    0.00 :	  46f0f9:       0f 85 a1 00 00 00       jne    46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f0ff:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f103:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f105:       0f 84 d5 00 00 00       je     46f1e0 <slot_deform_tuple+0x2d0>
    0.00 :	  46f10b:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f10d:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f110:       0f 84 8a 00 00 00       je     46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f116:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f118:       0f 84 27 01 00 00       je     46f245 <slot_deform_tuple+0x335>
    0.00 :	  46f11e:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f122:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f127:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
    0.00 :	  46f12b:       e9 ad fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f130:       49 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%rax
    0.00 :	  46f135:       e9 d6 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f13a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f140:       49 8d 7c 1d 00          lea    0x0(%r13,%rbx,1),%rdi
    0.00 :	  46f145:       4c 89 45 c8             mov    %r8,-0x38(%rbp)
    0.00 :	  46f149:       4c 89 4d c0             mov    %r9,-0x40(%rbp)
    0.00 :	  46f14d:       44 88 55 b8             mov    %r10b,-0x48(%rbp)
    0.00 :	  46f151:       4c 89 5d b0             mov    %r11,-0x50(%rbp)
    0.00 :	  46f155:       e8 f6 a6 ff ff          callq  469850 <strlen@plt>
    0.00 :	  46f15a:       44 0f b6 55 b8          movzbl -0x48(%rbp),%r10d
    0.00 :	  46f15f:       4c 8b 45 c8             mov    -0x38(%rbp),%r8
    0.00 :	  46f163:       48 8d 5c 03 01          lea    0x1(%rbx,%rax,1),%rbx
    0.00 :	  46f168:       4c 8b 4d c0             mov    -0x40(%rbp),%r9
    0.00 :	  46f16c:       4c 8b 5d b0             mov    -0x50(%rbp),%r11
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    3.45 :	  46f170:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f175:       e9 36 fe ff ff          jmpq   46efb0 <slot_deform_tuple+0xa0>
    0.00 :	  46f17a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f180:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f184:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
    0.00 :	  46f188:       e9 ea fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f18d:       0f 1f 00                nopl   (%rax)
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f190:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
   10.34 :	  46f195:       e9 76 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f19a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
    0.00 :	  46f1a0:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1a5:       e9 33 fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f1b0:       41 0f b7 44 1d 00       movzwl 0x0(%r13,%rbx,1),%eax
    0.00 :	  46f1b6:       e9 55 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f1bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f1c0:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f1c4:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f1c8:       e9 aa fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f1cd:       0f 1f 00                nopl   (%rax)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1d0:       d0 e8                   shr    %al
    0.00 :	  46f1d2:       0f b6 c0                movzbl %al,%eax
    0.00 :	  46f1d5:       e9 e0 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f1da:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (!slow &&
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f1e0:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f1e4:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1e9:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
    0.00 :	  46f1ed:       e9 eb fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1f8:       41 0f b6 54 1d 01       movzbl 0x1(%r13,%rbx,1),%edx
    0.00 :	  46f1fe:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  46f203:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  46f206:       0f 84 ae fe ff ff       je     46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f20c:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  46f20f:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  46f214:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  46f219:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  46f21d:       e9 98 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f222:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
    0.00 :	  46f228:       48 8d 43 03             lea    0x3(%rbx),%rax
    0.00 :	  46f22c:       48 83 e0 fc             and    $0xfffffffffffffffc,%rax
    0.00 :	  46f230:       e9 b9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
    0.00 :	  46f235:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f238:       48 8d 43 07             lea    0x7(%rbx),%rax
    0.00 :	  46f23c:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	  46f240:       e9 a9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f245:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f249:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f24e:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f252:       e9 86 fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

    7.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:141
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:79
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:82
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:89
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:94
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:137
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:138
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:140
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:142
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:144
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b7bd0 <InstrStopNode>:
         :	}
         :
         :	/* Exit from a plan node */
         :	void
         :	InstrStopNode(Instrumentation *instr, double nTuples)
         :	{
    0.00 :	  5b7bd0:       55                      push   %rbp
    0.00 :	  5b7bd1:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    3.70 :	  5b7bd4:       53                      push   %rbx
    0.00 :	  5b7bd5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b7bd8:       48 83 ec 18             sub    $0x18,%rsp
         :
         :	        /* count the returned tuples */
         :	        instr->tuplecount += nTuples;
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    3.70 :	  5b7bdc:       80 3f 00                cmpb   $0x0,(%rdi)
         :	InstrStopNode(Instrumentation *instr, double nTuples)
         :	{
         :	        instr_time      endtime;
         :
         :	        /* count the returned tuples */
         :	        instr->tuplecount += nTuples;
    0.00 :	  5b7bdf:       f2 0f 58 47 30          addsd  0x30(%rdi),%xmm0
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
    3.70 :	  5b7be4:       f2 0f 11 47 30          movsd  %xmm0,0x30(%rdi)
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    3.70 :	  5b7be9:       0f 84 90 00 00 00       je     5b7c7f <InstrStopNode+0xaf>
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
    0.00 :	  5b7bef:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:79
    3.70 :	  5b7bf4:       75 0b                   jne    5b7c01 <InstrStopNode+0x31>
    0.00 :	  5b7bf6:       48 83 7f 08 00          cmpq   $0x0,0x8(%rdi)
    0.00 :	  5b7bfb:       0f 84 d1 02 00 00       je     5b7ed2 <InstrStopNode+0x302>
         :	                        elog(ERROR, "InstrStopNode called without start");
         :
         :	                INSTR_TIME_SET_CURRENT(endtime);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:82
    3.70 :	  5b7c01:       48 8d 7d e0             lea    -0x20(%rbp),%rdi
    0.00 :	  5b7c05:       31 f6                   xor    %esi,%esi
    0.00 :	  5b7c07:       e8 b4 19 eb ff          callq  4695c0 <gettimeofday@plt>
         :	                INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
    0.00 :	  5b7c0c:       48 8b 45 e0             mov    -0x20(%rbp),%rax
    0.00 :	  5b7c10:       48 03 43 18             add    0x18(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    3.70 :	  5b7c14:       48 2b 43 08             sub    0x8(%rbx),%rax
    0.00 :	  5b7c18:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	  5b7c1c:       48 8b 45 e8             mov    -0x18(%rbp),%rax
    3.70 :	  5b7c20:       48 03 43 20             add    0x20(%rbx),%rax
    0.00 :	  5b7c24:       48 2b 43 10             sub    0x10(%rbx),%rax
    3.70 :	  5b7c28:       48 85 c0                test   %rax,%rax
    3.70 :	  5b7c2b:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  5b7c2f:       79 36                   jns    5b7c67 <InstrStopNode+0x97>
    0.00 :	  5b7c31:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5b7c38:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7c3e:       48 83 6b 18 01          subq   $0x1,0x18(%rbx)
    0.00 :	  5b7c43:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7c46:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  5b7c4a:       78 ec                   js     5b7c38 <InstrStopNode+0x68>
    0.00 :	  5b7c4c:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7c52:       7e 1b                   jle    5b7c6f <InstrStopNode+0x9f>
    0.00 :	  5b7c54:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5b7c58:       48 83 43 18 01          addq   $0x1,0x18(%rbx)
    0.00 :	  5b7c5d:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7c63:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  5b7c67:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7c6d:       7f e9                   jg     5b7c58 <InstrStopNode+0x88>
         :
         :	                INSTR_TIME_SET_ZERO(instr->starttime);
    0.00 :	  5b7c6f:       48 c7 43 08 00 00 00    movq   $0x0,0x8(%rbx)
    0.00 :	  5b7c76:       00 
    0.00 :	  5b7c77:       48 c7 43 10 00 00 00    movq   $0x0,0x10(%rbx)
    0.00 :	  5b7c7e:       00 
         :	        }
         :
         :	        /* Add delta of buffer usage since entry to node's totals */
         :	        if (instr->need_bufusage)
    0.00 :	  5b7c7f:       80 7b 01 00             cmpb   $0x0,0x1(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:89
    3.70 :	  5b7c83:       75 33                   jne    5b7cb8 <InstrStopNode+0xe8>
         :	                BufferUsageAccumDiff(&instr->bufusage,
         :	                                                         &pgBufferUsage, &instr->bufusage_start);
         :
         :	        /* Is this the first tuple of this cycle? */
         :	        if (!instr->running)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:94
    3.70 :	  5b7c85:       80 7b 02 00             cmpb   $0x0,0x2(%rbx)
    0.00 :	  5b7c89:       75 21                   jne    5b7cac <InstrStopNode+0xdc>
         :	        {
         :	                instr->running = true;
         :	                instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7c8b:       f2 48 0f 2a 43 20       cvtsi2sdq 0x20(%rbx),%xmm0
    0.00 :	  5b7c91:       f2 0f 5e 05 47 49 2c    divsd  0x2c4947(%rip),%xmm0        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  5b7c98:       00 
    0.00 :	  5b7c99:       f2 48 0f 2a 4b 18       cvtsi2sdq 0x18(%rbx),%xmm1
         :	                                                         &pgBufferUsage, &instr->bufusage_start);
         :
         :	        /* Is this the first tuple of this cycle? */
         :	        if (!instr->running)
         :	        {
         :	                instr->running = true;
    0.00 :	  5b7c9f:       c6 43 02 01             movb   $0x1,0x2(%rbx)
         :	                instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7ca3:       f2 0f 58 c8             addsd  %xmm0,%xmm1
    0.00 :	  5b7ca7:       f2 0f 11 4b 28          movsd  %xmm1,0x28(%rbx)
         :	        }
         :	}
    0.00 :	  5b7cac:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5b7cb0:       5b                      pop    %rbx
    0.00 :	  5b7cb1:       c9                      leaveq 
    0.00 :	  5b7cb2:       c3                      retq   
    0.00 :	  5b7cb3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	static void
         :	BufferUsageAccumDiff(BufferUsage *dst,
         :	                                         const BufferUsage *add,
         :	                                         const BufferUsage *sub)
         :	{
         :	        dst->shared_blks_hit += add->shared_blks_hit - sub->shared_blks_hit;
    0.00 :	  5b7cb8:       48 8b 05 a1 7a 60 00    mov    0x607aa1(%rip),%rax        # bbf760 <pgBufferUsage>
    0.00 :	  5b7cbf:       48 03 83 d8 00 00 00    add    0xd8(%rbx),%rax
    0.00 :	  5b7cc6:       48 2b 43 38             sub    0x38(%rbx),%rax
    0.00 :	  5b7cca:       48 89 83 d8 00 00 00    mov    %rax,0xd8(%rbx)
         :	        dst->shared_blks_read += add->shared_blks_read - sub->shared_blks_read;
    0.00 :	  5b7cd1:       48 8b 05 90 7a 60 00    mov    0x607a90(%rip),%rax        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  5b7cd8:       48 03 83 e0 00 00 00    add    0xe0(%rbx),%rax
    0.00 :	  5b7cdf:       48 2b 43 40             sub    0x40(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:137
    3.70 :	  5b7ce3:       48 89 83 e0 00 00 00    mov    %rax,0xe0(%rbx)
         :	        dst->shared_blks_dirtied += add->shared_blks_dirtied - sub->shared_blks_dirtied;
    0.00 :	  5b7cea:       48 8b 05 7f 7a 60 00    mov    0x607a7f(%rip),%rax        # bbf770 <pgBufferUsage+0x10>
    0.00 :	  5b7cf1:       48 03 83 e8 00 00 00    add    0xe8(%rbx),%rax
    0.00 :	  5b7cf8:       48 2b 43 48             sub    0x48(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:138
    3.70 :	  5b7cfc:       48 89 83 e8 00 00 00    mov    %rax,0xe8(%rbx)
         :	        dst->shared_blks_written += add->shared_blks_written - sub->shared_blks_written;
    0.00 :	  5b7d03:       48 8b 05 6e 7a 60 00    mov    0x607a6e(%rip),%rax        # bbf778 <pgBufferUsage+0x18>
    0.00 :	  5b7d0a:       48 03 83 f0 00 00 00    add    0xf0(%rbx),%rax
    0.00 :	  5b7d11:       48 2b 43 50             sub    0x50(%rbx),%rax
    0.00 :	  5b7d15:       48 89 83 f0 00 00 00    mov    %rax,0xf0(%rbx)
         :	        dst->local_blks_hit += add->local_blks_hit - sub->local_blks_hit;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:140
    3.70 :	  5b7d1c:       48 8b 05 5d 7a 60 00    mov    0x607a5d(%rip),%rax        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  5b7d23:       48 03 83 f8 00 00 00    add    0xf8(%rbx),%rax
    0.00 :	  5b7d2a:       48 2b 43 58             sub    0x58(%rbx),%rax
    0.00 :	  5b7d2e:       48 89 83 f8 00 00 00    mov    %rax,0xf8(%rbx)
         :	        dst->local_blks_read += add->local_blks_read - sub->local_blks_read;
    0.00 :	  5b7d35:       48 8b 05 4c 7a 60 00    mov    0x607a4c(%rip),%rax        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  5b7d3c:       48 03 83 00 01 00 00    add    0x100(%rbx),%rax
    0.00 :	  5b7d43:       48 2b 43 60             sub    0x60(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:141
    7.41 :	  5b7d47:       48 89 83 00 01 00 00    mov    %rax,0x100(%rbx)
         :	        dst->local_blks_dirtied += add->local_blks_dirtied - sub->local_blks_dirtied;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:142
    3.70 :	  5b7d4e:       48 8b 05 3b 7a 60 00    mov    0x607a3b(%rip),%rax        # bbf790 <pgBufferUsage+0x30>
    0.00 :	  5b7d55:       48 03 83 08 01 00 00    add    0x108(%rbx),%rax
    0.00 :	  5b7d5c:       48 2b 43 68             sub    0x68(%rbx),%rax
    0.00 :	  5b7d60:       48 89 83 08 01 00 00    mov    %rax,0x108(%rbx)
         :	        dst->local_blks_written += add->local_blks_written - sub->local_blks_written;
    0.00 :	  5b7d67:       48 8b 05 2a 7a 60 00    mov    0x607a2a(%rip),%rax        # bbf798 <pgBufferUsage+0x38>
    0.00 :	  5b7d6e:       48 03 83 10 01 00 00    add    0x110(%rbx),%rax
    0.00 :	  5b7d75:       48 2b 43 70             sub    0x70(%rbx),%rax
    0.00 :	  5b7d79:       48 89 83 10 01 00 00    mov    %rax,0x110(%rbx)
         :	        dst->temp_blks_read += add->temp_blks_read - sub->temp_blks_read;
    0.00 :	  5b7d80:       48 8b 05 19 7a 60 00    mov    0x607a19(%rip),%rax        # bbf7a0 <pgBufferUsage+0x40>
    0.00 :	  5b7d87:       48 03 83 18 01 00 00    add    0x118(%rbx),%rax
    0.00 :	  5b7d8e:       48 2b 43 78             sub    0x78(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:144
    3.70 :	  5b7d92:       48 89 83 18 01 00 00    mov    %rax,0x118(%rbx)
         :	        dst->temp_blks_written += add->temp_blks_written - sub->temp_blks_written;
    0.00 :	  5b7d99:       48 8b 05 08 7a 60 00    mov    0x607a08(%rip),%rax        # bbf7a8 <pgBufferUsage+0x48>
    0.00 :	  5b7da0:       48 03 83 20 01 00 00    add    0x120(%rbx),%rax
    0.00 :	  5b7da7:       48 2b 83 80 00 00 00    sub    0x80(%rbx),%rax
    0.00 :	  5b7dae:       48 89 83 20 01 00 00    mov    %rax,0x120(%rbx)
         :	        INSTR_TIME_ACCUM_DIFF(dst->blk_read_time,
    0.00 :	  5b7db5:       48 8b 05 f4 79 60 00    mov    0x6079f4(%rip),%rax        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  5b7dbc:       48 03 83 28 01 00 00    add    0x128(%rbx),%rax
    0.00 :	  5b7dc3:       48 2b 83 88 00 00 00    sub    0x88(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    3.70 :	  5b7dca:       48 89 83 28 01 00 00    mov    %rax,0x128(%rbx)
    3.70 :	  5b7dd1:       48 8b 05 e0 79 60 00    mov    0x6079e0(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  5b7dd8:       48 03 83 30 01 00 00    add    0x130(%rbx),%rax
    0.00 :	  5b7ddf:       48 2b 83 90 00 00 00    sub    0x90(%rbx),%rax
    3.70 :	  5b7de6:       48 85 c0                test   %rax,%rax
    3.70 :	  5b7de9:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7df0:       79 43                   jns    5b7e35 <InstrStopNode+0x265>
    0.00 :	  5b7df2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7df8:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7dfe:       48 83 ab 28 01 00 00    subq   $0x1,0x128(%rbx)
    0.00 :	  5b7e05:       01 
    0.00 :	  5b7e06:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e09:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7e10:       78 e6                   js     5b7df8 <InstrStopNode+0x228>
    0.00 :	  5b7e12:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7e18:       7e 23                   jle    5b7e3d <InstrStopNode+0x26d>
    0.00 :	  5b7e1a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7e20:       48 83 83 28 01 00 00    addq   $0x1,0x128(%rbx)
    0.00 :	  5b7e27:       01 
    0.00 :	  5b7e28:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7e2e:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7e35:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7e3b:       7f e3                   jg     5b7e20 <InstrStopNode+0x250>
         :	                                                  add->blk_read_time, sub->blk_read_time);
         :	        INSTR_TIME_ACCUM_DIFF(dst->blk_write_time,
    0.00 :	  5b7e3d:       48 8b 05 7c 79 60 00    mov    0x60797c(%rip),%rax        # bbf7c0 <pgBufferUsage+0x60>
    0.00 :	  5b7e44:       48 03 83 38 01 00 00    add    0x138(%rbx),%rax
    0.00 :	  5b7e4b:       48 2b 83 98 00 00 00    sub    0x98(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    3.70 :	  5b7e52:       48 89 83 38 01 00 00    mov    %rax,0x138(%rbx)
    0.00 :	  5b7e59:       48 8b 05 68 79 60 00    mov    0x607968(%rip),%rax        # bbf7c8 <pgBufferUsage+0x68>
    3.70 :	  5b7e60:       48 03 83 40 01 00 00    add    0x140(%rbx),%rax
    0.00 :	  5b7e67:       48 2b 83 a0 00 00 00    sub    0xa0(%rbx),%rax
    3.70 :	  5b7e6e:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e71:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    0.00 :	  5b7e78:       79 4b                   jns    5b7ec5 <InstrStopNode+0x2f5>
    0.00 :	  5b7e7a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7e80:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7e86:       48 83 ab 38 01 00 00    subq   $0x1,0x138(%rbx)
    0.00 :	  5b7e8d:       01 
    0.00 :	  5b7e8e:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e91:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    0.00 :	  5b7e98:       78 e6                   js     5b7e80 <InstrStopNode+0x2b0>
    0.00 :	  5b7e9a:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7ea0:       0f 8e df fd ff ff       jle    5b7c85 <InstrStopNode+0xb5>
    0.00 :	  5b7ea6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b7ead:       00 00 00 
    0.00 :	  5b7eb0:       48 83 83 38 01 00 00    addq   $0x1,0x138(%rbx)
    0.00 :	  5b7eb7:       01 
    0.00 :	  5b7eb8:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7ebe:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    3.70 :	  5b7ec5:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7ecb:       7f e3                   jg     5b7eb0 <InstrStopNode+0x2e0>
    0.00 :	  5b7ecd:       e9 b3 fd ff ff          jmpq   5b7c85 <InstrStopNode+0xb5>
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
         :	                        elog(ERROR, "InstrStopNode called without start");
    0.00 :	  5b7ed2:       ba 8a b6 88 00          mov    $0x88b68a,%edx
    0.00 :	  5b7ed7:       be 50 00 00 00          mov    $0x50,%esi
    0.00 :	  5b7edc:       bf fa b5 88 00          mov    $0x88b5fa,%edi
    0.00 :	  5b7ee1:       e8 3a 35 1c 00          callq  77b420 <elog_start>
    0.00 :	  5b7ee6:       be 30 b6 88 00          mov    $0x88b630,%esi
    0.00 :	  5b7eeb:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b7ef0:       31 c0                   xor    %eax,%eax
    0.00 :	  5b7ef2:       e8 39 33 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5b7ef7:       e8 d4 15 eb ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   15.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:659
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:654
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:666
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:659
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:659
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000757d90 <bcTruelen>:
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:654
   10.00 :	  757d90:       55                      push   %rbp
         :	        char       *s = VARDATA_ANY(arg);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
    5.00 :	  757d91:       0f b6 17                movzbl (%rdi),%edx
    0.00 :	  757d94:       48 8d 4f 01             lea    0x1(%rdi),%rcx
    0.00 :	  757d98:       48 8d 47 04             lea    0x4(%rdi),%rax
    5.00 :	  757d9c:       be 01 00 00 00          mov    $0x1,%esi
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
    0.00 :	  757da1:       48 89 e5                mov    %rsp,%rbp
         :	        char       *s = VARDATA_ANY(arg);
    0.00 :	  757da4:       21 d6                   and    %edx,%esi
    5.00 :	  757da6:       48 0f 44 c8             cmove  %rax,%rcx
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
    0.00 :	  757daa:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  757dad:       74 51                   je     757e00 <bcTruelen+0x70>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:659
    5.00 :	  757daf:       85 f6                   test   %esi,%esi
    0.00 :	  757db1:       75 3d                   jne    757df0 <bcTruelen+0x60>
    0.00 :	  757db3:       8b 07                   mov    (%rdi),%eax
    0.00 :	  757db5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  757db8:       83 e8 04                sub    $0x4,%eax
         :	        for (i = len - 1; i >= 0; i--)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 :	  757dbb:       89 c2                   mov    %eax,%edx
    0.00 :	  757dbd:       83 ea 01                sub    $0x1,%edx
    0.00 :	  757dc0:       78 20                   js     757de2 <bcTruelen+0x52>
    0.00 :	  757dc2:       48 63 f2                movslq %edx,%rsi
         :	        {
         :	                if (s[i] != ' ')
    0.00 :	  757dc5:       80 3c 31 20             cmpb   $0x20,(%rcx,%rsi,1)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:662
    5.00 :	  757dc9:       74 0e                   je     757dd9 <bcTruelen+0x49>
    0.00 :	  757dcb:       eb 15                   jmp    757de2 <bcTruelen+0x52>
    0.00 :	  757dcd:       0f 1f 00                nopl   (%rax)
    5.00 :	  757dd0:       48 63 c2                movslq %edx,%rax
    5.00 :	  757dd3:       80 3c 01 20             cmpb   $0x20,(%rcx,%rax,1)
    5.00 :	  757dd7:       75 09                   jne    757de2 <bcTruelen+0x52>
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
         :	        for (i = len - 1; i >= 0; i--)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:660
    5.00 :	  757dd9:       83 ea 01                sub    $0x1,%edx
    5.00 :	  757ddc:       0f 1f 40 00             nopl   0x0(%rax)
    5.00 :	  757de0:       79 ee                   jns    757dd0 <bcTruelen+0x40>
    0.00 :	  757de2:       8d 42 01                lea    0x1(%rdx),%eax
         :	        {
         :	                if (s[i] != ' ')
         :	                        break;
         :	        }
         :	        return i + 1;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:666
   10.00 :	  757de5:       c9                      leaveq 
    0.00 :	  757de6:       c3                      retq   
    0.00 :	  757de7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  757dee:       00 00 
         :	{
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:659
    5.00 :	  757df0:       d0 ea                   shr    %dl
   15.00 :	  757df2:       0f b6 c2                movzbl %dl,%eax
    0.00 :	  757df5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  757df8:       eb c1                   jmp    757dbb <bcTruelen+0x2b>
    0.00 :	  757dfa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  757e00:       0f b6 7f 01             movzbl 0x1(%rdi),%edi
    0.00 :	  757e04:       ba 07 00 00 00          mov    $0x7,%edx
    0.00 :	  757e09:       be 07 00 00 00          mov    $0x7,%esi
    0.00 :	  757e0e:       40 80 ff 01             cmp    $0x1,%dil
    0.00 :	  757e12:       74 b1                   je     757dc5 <bcTruelen+0x35>
    0.00 :	  757e14:       40 80 ff 12             cmp    $0x12,%dil
    0.00 :	  757e18:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e1d:       ba 0f 00 00 00          mov    $0xf,%edx
    0.00 :	  757e22:       0f 45 d0                cmovne %eax,%edx
    0.00 :	  757e25:       be 0f 00 00 00          mov    $0xf,%esi
    0.00 :	  757e2a:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e2f:       48 0f 45 f0             cmovne %rax,%rsi
    0.00 :	  757e33:       eb 90                   jmp    757dc5 <bcTruelen+0x35>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   26.32 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
   15.79 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5432
   15.79 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5436
   10.53 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5386
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5403
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5437
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5494
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5493
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005ad000 <ExecProject>:
         :	 *              data will be valid, he must call ExecMaterializeSlot on the
         :	 *              result slot.
         :	 */
         :	TupleTableSlot *
         :	ExecProject(ProjectionInfo *projInfo, ExprDoneCond *isDone)
         :	{
    0.00 :	  5ad000:       55                      push   %rbp
    0.00 :	  5ad001:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5ad004:       41 57                   push   %r15
    0.00 :	  5ad006:       41 56                   push   %r14
    0.00 :	  5ad008:       41 55                   push   %r13
    0.00 :	  5ad00a:       41 54                   push   %r12
    0.00 :	  5ad00c:       53                      push   %rbx
    0.00 :	  5ad00d:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5ad010:       48 83 ec 48             sub    $0x48,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5386
    5.26 :	  5ad014:       48 89 75 90             mov    %rsi,-0x70(%rbp)
         :	        Assert(projInfo != NULL);
         :
         :	        /*
         :	         * get the projection info we want
         :	         */
         :	        slot = projInfo->pi_slot;
    0.00 :	  5ad018:       48 8b 47 18             mov    0x18(%rdi),%rax
         :	        econtext = projInfo->pi_exprContext;
         :
         :	        /* Assume single result row until proven otherwise */
         :	        if (isDone)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5403
    5.26 :	  5ad01c:       48 85 f6                test   %rsi,%rsi
         :	        Assert(projInfo != NULL);
         :
         :	        /*
         :	         * get the projection info we want
         :	         */
         :	        slot = projInfo->pi_slot;
    0.00 :	  5ad01f:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	        econtext = projInfo->pi_exprContext;
    0.00 :	  5ad023:       4c 8b 77 10             mov    0x10(%rdi),%r14
         :
         :	        /* Assume single result row until proven otherwise */
         :	        if (isDone)
    0.00 :	  5ad027:       74 06                   je     5ad02f <ExecProject+0x2f>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5ad029:       c7 06 00 00 00 00       movl   $0x0,(%rsi)
         :	        /*
         :	         * Clear any former contents of the result slot.  This makes it safe for
         :	         * us to use the slot's Datum/isnull arrays as workspace. (Also, we can
         :	         * return the slot as-is if we decide no rows can be projected.)
         :	         */
         :	        ExecClearTuple(slot);
    0.00 :	  5ad02f:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  5ad033:       e8 d8 70 00 00          callq  5b4110 <ExecClearTuple>
         :	        /*
         :	         * Force extraction of all input values that we'll need.  The
         :	         * Var-extraction loops below depend on this, and we are also prefetching
         :	         * all attributes that will be referenced in the generic expressions.
         :	         */
         :	        if (projInfo->pi_lastInnerVar > 0)
    0.00 :	  5ad038:       8b 73 48                mov    0x48(%rbx),%esi
    0.00 :	  5ad03b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad03d:       7e 09                   jle    5ad048 <ExecProject+0x48>
         :	                slot_getsomeattrs(econtext->ecxt_innertuple,
    0.00 :	  5ad03f:       49 8b 7e 10             mov    0x10(%r14),%rdi
    0.00 :	  5ad043:       e8 18 22 ec ff          callq  46f260 <slot_getsomeattrs>
         :	                                                  projInfo->pi_lastInnerVar);
         :	        if (projInfo->pi_lastOuterVar > 0)
    0.00 :	  5ad048:       8b 73 4c                mov    0x4c(%rbx),%esi
    0.00 :	  5ad04b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad04d:       7e 09                   jle    5ad058 <ExecProject+0x58>
         :	                slot_getsomeattrs(econtext->ecxt_outertuple,
    0.00 :	  5ad04f:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	  5ad053:       e8 08 22 ec ff          callq  46f260 <slot_getsomeattrs>
         :	                                                  projInfo->pi_lastOuterVar);
         :	        if (projInfo->pi_lastScanVar > 0)
    0.00 :	  5ad058:       8b 73 50                mov    0x50(%rbx),%esi
    0.00 :	  5ad05b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad05d:       7e 09                   jle    5ad068 <ExecProject+0x68>
         :	                slot_getsomeattrs(econtext->ecxt_scantuple,
    0.00 :	  5ad05f:       49 8b 7e 08             mov    0x8(%r14),%rdi
    0.00 :	  5ad063:       e8 f8 21 ec ff          callq  46f260 <slot_getsomeattrs>
         :
         :	        /*
         :	         * Assign simple Vars to result by direct extraction of fields from source
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5432
   15.79 :	  5ad068:       44 8b 43 2c             mov    0x2c(%rbx),%r8d
         :	        if (numSimpleVars > 0)
    0.00 :	  5ad06c:       45 85 c0                test   %r8d,%r8d
    0.00 :	  5ad06f:       7e 5d                   jle    5ad0ce <ExecProject+0xce>
         :	                bool       *isnull = slot->tts_isnull;
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
         :	                int                *varNumbers = projInfo->pi_varNumbers;
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
    0.00 :	  5ad071:       80 7b 28 00             cmpb   $0x0,0x28(%rbx)
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
         :	        if (numSimpleVars > 0)
         :	        {
         :	                Datum      *values = slot->tts_values;
    0.00 :	  5ad075:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
         :	                bool       *isnull = slot->tts_isnull;
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5437
    5.26 :	  5ad079:       4c 8b 5b 30             mov    0x30(%rbx),%r11
         :	                int                *varNumbers = projInfo->pi_varNumbers;
    0.00 :	  5ad07d:       4c 8b 53 38             mov    0x38(%rbx),%r10
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
         :	        if (numSimpleVars > 0)
         :	        {
         :	                Datum      *values = slot->tts_values;
    0.00 :	  5ad081:       4c 8b 6a 28             mov    0x28(%rdx),%r13
         :	                bool       *isnull = slot->tts_isnull;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5436
   15.79 :	  5ad085:       4c 8b 62 30             mov    0x30(%rdx),%r12
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
         :	                int                *varNumbers = projInfo->pi_varNumbers;
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
    0.00 :	  5ad089:       0f 84 e1 01 00 00       je     5ad270 <ExecProject+0x270>
    0.00 :	  5ad08f:       4c 89 df                mov    %r11,%rdi
    0.00 :	  5ad092:       31 f6                   xor    %esi,%esi
    0.00 :	  5ad094:       0f 1f 40 00             nopl   0x0(%rax)
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad098:       48 63 07                movslq (%rdi),%rax
         :	                                int                     varNumber = varNumbers[i] - 1;
         :
         :	                                values[i] = varSlot->tts_values[varNumber];
         :	                                isnull[i] = varSlot->tts_isnull[varNumber];
    0.00 :	  5ad09b:       48 83 c7 04             add    $0x4,%rdi
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad09f:       49 8b 0c 06             mov    (%r14,%rax,1),%rcx
         :	                                int                     varNumber = varNumbers[i] - 1;
         :
         :	                                values[i] = varSlot->tts_values[varNumber];
    0.00 :	  5ad0a3:       41 8b 04 b2             mov    (%r10,%rsi,4),%eax
    0.00 :	  5ad0a7:       48 8b 51 28             mov    0x28(%rcx),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
    5.26 :	  5ad0ab:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad0ae:       48 98                   cltq   
    0.00 :	  5ad0b0:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
   26.32 :	  5ad0b4:       49 89 54 f5 00          mov    %rdx,0x0(%r13,%rsi,8)
         :	                                isnull[i] = varSlot->tts_isnull[varNumber];
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
   10.53 :	  5ad0b9:       48 8b 51 30             mov    0x30(%rcx),%rdx
    0.00 :	  5ad0bd:       0f b6 04 02             movzbl (%rdx,%rax,1),%eax
    0.00 :	  5ad0c1:       41 88 04 34             mov    %al,(%r12,%rsi,1)
    0.00 :	  5ad0c5:       48 83 c6 01             add    $0x1,%rsi
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad0c9:       41 39 f0                cmp    %esi,%r8d
    0.00 :	  5ad0cc:       7f ca                   jg     5ad098 <ExecProject+0x98>
         :	         * If there are any generic expressions, evaluate them.  It's possible
         :	         * that there are set-returning functions in such expressions; if so and
         :	         * we have reached the end of the set, we return the result slot, which we
         :	         * already marked empty.
         :	         */
         :	        if (projInfo->pi_targetlist)
    0.00 :	  5ad0ce:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  5ad0d2:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad0d5:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	  5ad0d9:       0f 84 fc 00 00 00       je     5ad1db <ExecProject+0x1db>
         :	        {
         :	                if (!ExecTargetList(projInfo->pi_targetlist,
    0.00 :	  5ad0df:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5ad0e3:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5ad0e7:       4c 8b 7b 20             mov    0x20(%rbx),%r15
    0.00 :	  5ad0eb:       48 8b 52 30             mov    0x30(%rdx),%rdx
    0.00 :	  5ad0ef:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ad0f3:       48 8b 15 66 d7 60 00    mov    0x60d766(%rip),%rdx        # bba860 <CurrentMemoryContext>
    0.00 :	  5ad0fa:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ad0fe:       48 89 55 c8             mov    %rdx,-0x38(%rbp)
    0.00 :	  5ad102:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ad106:       49 8b 46 28             mov    0x28(%r14),%rax
    0.00 :	  5ad10a:       48 89 05 4f d7 60 00    mov    %rax,0x60d74f(%rip)        # bba860 <CurrentMemoryContext>
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5ad111:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5ad115:       4c 8b 68 08             mov    0x8(%rax),%r13
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad119:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad11c:       0f 84 ae 00 00 00       je     5ad1d0 <ExecProject+0x1d0>
    0.00 :	  5ad122:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5ad126:       eb 15                   jmp    5ad13d <ExecProject+0x13d>
    0.00 :	  5ad128:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ad12f:       00 
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
         :	                                ereport(ERROR,
         :	                                                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
         :	                                                 errmsg("set-valued function called in context that cannot accept a set")));
         :	                        if (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad130:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad134:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad138:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad13b:       74 63                   je     5ad1a0 <ExecProject+0x1a0>
         :	        {
         :	                GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad13d:       49 8b 55 00             mov    0x0(%r13),%rdx
         :	                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                AttrNumber      resind = tle->resno - 1;
         :
         :	                values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad141:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad144:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ad148:       0f b7 58 10             movzwl 0x10(%rax),%ebx
    0.00 :	  5ad14c:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad150:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ad154:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad157:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  5ad15a:       48 0f bf db             movswq %bx,%rbx
    0.00 :	  5ad15e:       4d 8d 24 9f             lea    (%r15,%rbx,4),%r12
    0.00 :	  5ad162:       48 01 da                add    %rbx,%rdx
    0.00 :	  5ad165:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  5ad168:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad16b:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad16f:       48 89 04 da             mov    %rax,(%rdx,%rbx,8)
         :	                                                                          econtext,
         :	                                                                          &isnull[resind],
         :	                                                                          &itemIsDone[resind]);
         :
         :	                if (itemIsDone[resind] != ExprSingleResult)
    0.00 :	  5ad173:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  5ad177:       85 c0                   test   %eax,%eax
    0.00 :	  5ad179:       74 b9                   je     5ad134 <ExecProject+0x134>
         :	                {
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
    0.00 :	  5ad17b:       48 83 7d 90 00          cmpq   $0x0,-0x70(%rbp)
    0.00 :	  5ad180:       0f 84 fd 01 00 00       je     5ad383 <ExecProject+0x383>
         :	                                ereport(ERROR,
         :	                                                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
         :	                                                 errmsg("set-valued function called in context that cannot accept a set")));
         :	                        if (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad186:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad189:       75 a5                   jne    5ad130 <ExecProject+0x130>
         :	                        {
         :	                                /* we have undone sets in the tlist, set flag */
         :	                                *isDone = ExprMultipleResult;
    0.00 :	  5ad18b:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  5ad18f:       c7 00 01 00 00 00       movl   $0x1,(%rax)
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad195:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad199:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad19c:       75 9f                   jne    5ad13d <ExecProject+0x13d>
    0.00 :	  5ad19e:       66 90                   xchg   %ax,%ax
         :	                                haveDoneSets = true;
         :	                        }
         :	                }
         :	        }
         :
         :	        if (haveDoneSets)
    0.00 :	  5ad1a0:       80 7d c7 00             cmpb   $0x0,-0x39(%rbp)
    0.00 :	  5ad1a4:       74 2a                   je     5ad1d0 <ExecProject+0x1d0>
         :	        {
         :	                /*
         :	                 * note: can't get here unless we verified isDone != NULL
         :	                 */
         :	                if (*isDone == ExprSingleResult)
    0.00 :	  5ad1a6:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  5ad1aa:       8b 02                   mov    (%rdx),%eax
    0.00 :	  5ad1ac:       85 c0                   test   %eax,%eax
    0.00 :	  5ad1ae:       0f 84 bc 01 00 00       je     5ad370 <ExecProject+0x370>
    0.00 :	  5ad1b4:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5ad1b8:       4c 8b 6a 08             mov    0x8(%rdx),%r13
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad1bc:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad1bf:       75 6f                   jne    5ad230 <ExecProject+0x230>
         :	                         * have to cycle the nonempty sets to completion, else resources
         :	                         * will not be released from subplans etc.
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
    0.00 :	  5ad1c1:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5ad1c4:       0f 84 02 01 00 00       je     5ad2cc <ExecProject+0x2cc>
    0.00 :	  5ad1ca:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5ad1d0:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  5ad1d4:       48 89 05 85 d6 60 00    mov    %rax,0x60d685(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
    0.00 :	  5ad1db:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
         :	}
    0.00 :	  5ad1df:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5ad1e3:       5b                      pop    %rbx
    0.00 :	  5ad1e4:       41 5c                   pop    %r12
    0.00 :	  5ad1e6:       41 5d                   pop    %r13
    0.00 :	  5ad1e8:       41 5e                   pop    %r14
    0.00 :	  5ad1ea:       41 5f                   pop    %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5494
    5.26 :	  5ad1ec:       c9                      leaveq 
         :
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5493
    5.26 :	  5ad1ed:       e9 2e 68 00 00          jmpq   5b3a20 <ExecStoreVirtualTuple>
    0.00 :	  5ad1f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                AttrNumber      resind = tle->resno - 1;
         :
         :	                                if (itemIsDone[resind] == ExprEndResult)
         :	                                {
         :	                                        values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad1f8:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad1fc:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ad200:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  5ad203:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad206:       48 01 da                add    %rbx,%rdx
    0.00 :	  5ad209:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad20c:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad20f:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad213:       48 89 04 da             mov    %rax,(%rdx,%rbx,8)
         :	                                                                                                  econtext,
         :	                                                                                                  &isnull[resind],
         :	                                                                                                  &itemIsDone[resind]);
         :
         :	                                        if (itemIsDone[resind] == ExprEndResult)
    0.00 :	  5ad217:       41 83 3c 24 02          cmpl   $0x2,(%r12)
    0.00 :	  5ad21c:       0f 84 a0 00 00 00       je     5ad2c2 <ExecProject+0x2c2>
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad222:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad226:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad229:       74 2c                   je     5ad257 <ExecProject+0x257>
    0.00 :	  5ad22b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        {
         :	                                GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad230:       49 8b 55 00             mov    0x0(%r13),%rdx
         :	                                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                AttrNumber      resind = tle->resno - 1;
         :
         :	                                if (itemIsDone[resind] == ExprEndResult)
    0.00 :	  5ad234:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ad238:       0f b7 40 10             movzwl 0x10(%rax),%eax
    0.00 :	  5ad23c:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad23f:       48 0f bf d8             movswq %ax,%rbx
    0.00 :	  5ad243:       4d 8d 24 9f             lea    (%r15,%rbx,4),%r12
    0.00 :	  5ad247:       41 83 3c 24 02          cmpl   $0x2,(%r12)
    0.00 :	  5ad24c:       74 aa                   je     5ad1f8 <ExecProject+0x1f8>
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad24e:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad252:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad255:       75 d9                   jne    5ad230 <ExecProject+0x230>
    0.00 :	  5ad257:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  5ad25b:       8b 02                   mov    (%rdx),%eax
         :	                         * have to cycle the nonempty sets to completion, else resources
         :	                         * will not be released from subplans etc.
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
    0.00 :	  5ad25d:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5ad260:       0f 85 6a ff ff ff       jne    5ad1d0 <ExecProject+0x1d0>
    0.00 :	  5ad266:       eb 64                   jmp    5ad2cc <ExecProject+0x2cc>
    0.00 :	  5ad268:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ad26f:       00 
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
    0.00 :	  5ad270:       4c 8b 4b 40             mov    0x40(%rbx),%r9
    0.00 :	  5ad274:       31 ff                   xor    %edi,%edi
    0.00 :	  5ad276:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5ad27d:       00 00 00 
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad280:       49 63 04 bb             movslq (%r11,%rdi,4),%rax
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad284:       41 8b 0c b9             mov    (%r9,%rdi,4),%ecx
    0.00 :	  5ad288:       83 e9 01                sub    $0x1,%ecx
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad28b:       49 8b 34 06             mov    (%r14,%rax,1),%rsi
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad28f:       41 8b 04 ba             mov    (%r10,%rdi,4),%eax
    0.00 :	  5ad293:       48 63 c9                movslq %ecx,%rcx
         :	                                isnull[varOutputCol] = varSlot->tts_isnull[varNumber];
    0.00 :	  5ad296:       48 83 c7 01             add    $0x1,%rdi
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad29a:       48 8b 56 28             mov    0x28(%rsi),%rdx
    0.00 :	  5ad29e:       83 e8 01                sub    $0x1,%eax
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad2a1:       41 39 f8                cmp    %edi,%r8d
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad2a4:       48 98                   cltq   
    0.00 :	  5ad2a6:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  5ad2aa:       49 89 54 cd 00          mov    %rdx,0x0(%r13,%rcx,8)
         :	                                isnull[varOutputCol] = varSlot->tts_isnull[varNumber];
    0.00 :	  5ad2af:       48 8b 56 30             mov    0x30(%rsi),%rdx
    0.00 :	  5ad2b3:       0f b6 04 02             movzbl (%rdx,%rax,1),%eax
    0.00 :	  5ad2b7:       41 88 04 0c             mov    %al,(%r12,%rcx,1)
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad2bb:       7f c3                   jg     5ad280 <ExecProject+0x280>
    0.00 :	  5ad2bd:       e9 0c fe ff ff          jmpq   5ad0ce <ExecProject+0xce>
         :	                                        {
         :	                                                /*
         :	                                                 * Oh dear, this item is returning an empty set. Guess
         :	                                                 * we can't make a tuple after all.
         :	                                                 */
         :	                                                *isDone = ExprEndResult;
    0.00 :	  5ad2c2:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  5ad2c6:       c7 00 02 00 00 00       movl   $0x2,(%rax)
    0.00 :	  5ad2cc:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5ad2d0:       48 8b 40 08             mov    0x8(%rax),%rax
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
         :	                        {
         :	                                foreach(tl, targetlist)
    0.00 :	  5ad2d4:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad2d7:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5ad2db:       74 6c                   je     5ad349 <ExecProject+0x349>
    0.00 :	  5ad2dd:       0f 1f 00                nopl   (%rax)
         :	                                {
         :	                                        GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad2e0:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  5ad2e4:       48 8b 12                mov    (%rdx),%rdx
    0.00 :	  5ad2e7:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	                                        TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                        AttrNumber      resind = tle->resno - 1;
         :
         :	                                        while (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad2eb:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ad2ef:       0f b7 40 10             movzwl 0x10(%rax),%eax
    0.00 :	  5ad2f3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad2f6:       48 0f bf c0             movswq %ax,%rax
    0.00 :	  5ad2fa:       49 8d 1c 87             lea    (%r15,%rax,4),%rbx
    0.00 :	  5ad2fe:       83 3b 01                cmpl   $0x1,(%rbx)
    0.00 :	  5ad301:       75 35                   jne    5ad338 <ExecProject+0x338>
    0.00 :	  5ad303:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad307:       4c 8b 65 a0             mov    -0x60(%rbp),%r12
    0.00 :	  5ad30b:       4c 8d 2c c2             lea    (%rdx,%rax,8),%r13
    0.00 :	  5ad30f:       49 01 c4                add    %rax,%r12
    0.00 :	  5ad312:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        {
         :	                                                values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad318:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  5ad31c:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  5ad31f:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad322:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad326:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  5ad329:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad32c:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad32f:       49 89 45 00             mov    %rax,0x0(%r13)
         :	                                {
         :	                                        GenericExprState *gstate = (GenericExprState *) lfirst(tl);
         :	                                        TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                        AttrNumber      resind = tle->resno - 1;
         :
         :	                                        while (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad333:       83 3b 01                cmpl   $0x1,(%rbx)
    0.00 :	  5ad336:       74 e0                   je     5ad318 <ExecProject+0x318>
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
         :	                        {
         :	                                foreach(tl, targetlist)
    0.00 :	  5ad338:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  5ad33c:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	  5ad340:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad343:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5ad347:       75 97                   jne    5ad2e0 <ExecProject+0x2e0>
    0.00 :	  5ad349:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  5ad34d:       48 89 15 0c d5 60 00    mov    %rdx,0x60d50c(%rip)        # bba860 <CurrentMemoryContext>
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
         :	}
    0.00 :	  5ad354:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5ad358:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5ad35c:       5b                      pop    %rbx
    0.00 :	  5ad35d:       41 5c                   pop    %r12
    0.00 :	  5ad35f:       41 5d                   pop    %r13
    0.00 :	  5ad361:       41 5e                   pop    %r14
    0.00 :	  5ad363:       41 5f                   pop    %r15
    0.00 :	  5ad365:       c9                      leaveq 
    0.00 :	  5ad366:       c3                      retq   
    0.00 :	  5ad367:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5ad36e:       00 00 
         :	                if (*isDone == ExprSingleResult)
         :	                {
         :	                        /*
         :	                         * all sets are done, so report that tlist expansion is complete.
         :	                         */
         :	                        *isDone = ExprEndResult;
    0.00 :	  5ad370:       c7 02 02 00 00 00       movl   $0x2,(%rdx)
    0.00 :	  5ad376:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  5ad37a:       48 89 05 df d4 60 00    mov    %rax,0x60d4df(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5ad381:       eb d1                   jmp    5ad354 <ExecProject+0x354>
         :
         :	                if (itemIsDone[resind] != ExprSingleResult)
         :	                {
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
         :	                                ereport(ERROR,
    0.00 :	  5ad383:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5ad386:       b9 f0 ad 88 00          mov    $0x88adf0,%ecx
    0.00 :	  5ad38b:       ba 9c 14 00 00          mov    $0x149c,%edx
    0.00 :	  5ad390:       be fc a3 88 00          mov    $0x88a3fc,%esi
    0.00 :	  5ad395:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5ad39a:       e8 21 d7 1c 00          callq  77aac0 <errstart>
    0.00 :	  5ad39f:       84 c0                   test   %al,%al
    0.00 :	  5ad3a1:       75 05                   jne    5ad3a8 <ExecProject+0x3a8>
    0.00 :	  5ad3a3:       e8 28 c1 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5ad3a8:       bf 30 b3 87 00          mov    $0x87b330,%edi
    0.00 :	  5ad3ad:       31 c0                   xor    %eax,%eax
    0.00 :	  5ad3af:       e8 ec f4 1c 00          callq  77c8a0 <errmsg>
    0.00 :	  5ad3b4:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  5ad3b9:       89 c3                   mov    %eax,%ebx
    0.00 :	  5ad3bb:       e8 90 f9 1c 00          callq  77cd50 <errcode>
    0.00 :	  5ad3c0:       89 de                   mov    %ebx,%esi
    0.00 :	  5ad3c2:       89 c7                   mov    %eax,%edi
    0.00 :	  5ad3c4:       31 c0                   xor    %eax,%eax
    0.00 :	  5ad3c6:       e8 15 d2 1c 00          callq  77a5e0 <errfinish>
    0.00 :	  5ad3cb:       eb d6                   jmp    5ad3a3 <ExecProject+0x3a3>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1178
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1179
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1157
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1158
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1176
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1206
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1215
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1178
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f400 <slot_getattr>:
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    0.00 :	  46f400:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    5.56 :	  46f401:       48 89 e5                mov    %rsp,%rbp
   11.11 :	  46f404:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    5.56 :	  46f408:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    5.56 :	  46f40c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  46f40f:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  46f413:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  46f417:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f41b:       85 f6                   test   %esi,%esi
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    0.00 :	  46f41d:       49 89 d4                mov    %rdx,%r12
         :	        HeapTuple       tuple = slot->tts_tuple;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1157
    5.56 :	  46f420:       48 8b 7f 08             mov    0x8(%rdi),%rdi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1158
    5.56 :	  46f424:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f428:       0f 8e a2 00 00 00       jle    46f4d0 <slot_getattr+0xd0>
         :	        }
         :
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1176
    5.56 :	  46f42e:       3b 73 24                cmp    0x24(%rbx),%esi
    0.00 :	  46f431:       7e 65                   jle    46f498 <slot_getattr+0x98>
         :	        }
         :
         :	        /*
         :	         * return NULL if attnum is out of range according to the tupdesc
         :	         */
         :	        if (attnum > tupleDesc->natts)
    0.00 :	  46f433:       3b 32                   cmp    (%rdx),%esi
    0.00 :	  46f435:       7f 51                   jg     46f488 <slot_getattr+0x88>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
    0.00 :	  46f437:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f43a:       0f 84 34 01 00 00       je     46f574 <slot_getattr+0x174>
         :	         *
         :	         * (We have to check this separately because of various inheritance and
         :	         * table-alteration scenarios: the tuple could be either longer or shorter
         :	         * than the tupdesc.)
         :	         */
         :	        tup = tuple->t_data;
    0.00 :	  46f440:       48 8b 7f 10             mov    0x10(%rdi),%rdi
         :	        if (attnum > HeapTupleHeaderGetNatts(tup))
    0.00 :	  46f444:       0f b7 47 12             movzwl 0x12(%rdi),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1206
    5.56 :	  46f448:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  46f44d:       39 c6                   cmp    %eax,%esi
    0.00 :	  46f44f:       7f 37                   jg     46f488 <slot_getattr+0x88>
         :	        }
         :
         :	        /*
         :	         * check if target attribute is null: no point in groveling through tuple
         :	         */
         :	        if (HeapTupleHasNulls(tuple) && att_isnull(attnum - 1, tup->t_bits))
    0.00 :	  46f451:       f6 47 14 01             testb  $0x1,0x14(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1215
    5.56 :	  46f455:       74 18                   je     46f46f <slot_getattr+0x6f>
    0.00 :	  46f457:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  46f45a:       89 c8                   mov    %ecx,%eax
    0.00 :	  46f45c:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46f45f:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46f462:       48 98                   cltq   
    0.00 :	  46f464:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  46f469:       d3 f8                   sar    %cl,%eax
    0.00 :	  46f46b:       a8 01                   test   $0x1,%al
    0.00 :	  46f46d:       74 19                   je     46f488 <slot_getattr+0x88>
         :	        /*
         :	         * If the attribute's column has been dropped, we force a NULL result.
         :	         * This case should not happen in normal use, but it could happen if we
         :	         * are executing a plan cached before the column was dropped.
         :	         */
         :	        if (tupleDesc->attrs[attnum - 1]->attisdropped)
    0.00 :	  46f46f:       4c 63 ee                movslq %esi,%r13
    0.00 :	  46f472:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  46f476:       4d 8d 75 ff             lea    -0x1(%r13),%r14
    0.00 :	  46f47a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
    0.00 :	  46f47e:       80 78 61 00             cmpb   $0x0,0x61(%rax)
    0.00 :	  46f482:       74 7c                   je     46f500 <slot_getattr+0x100>
    0.00 :	  46f484:       0f 1f 40 00             nopl   0x0(%rax)
         :	        {
         :	                *isnull = true;
    0.00 :	  46f488:       41 c6 04 24 01          movb   $0x1,(%r12)
    0.00 :	  46f48d:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f48f:       eb 20                   jmp    46f4b1 <slot_getattr+0xb1>
    0.00 :	  46f491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
         :	        {
         :	                *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f498:       48 8b 43 30             mov    0x30(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1178
    5.56 :	  46f49c:       48 63 d6                movslq %esi,%rdx
    0.00 :	  46f49f:       0f b6 44 10 ff          movzbl -0x1(%rax,%rdx,1),%eax
   11.11 :	  46f4a4:       41 88 04 24             mov    %al,(%r12)
         :	                return slot->tts_values[attnum - 1];
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1179
   11.11 :	  46f4a8:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f4ac:       48 8b 44 d0 f8          mov    -0x8(%rax,%rdx,8),%rax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4b1:       48 8b 1c 24             mov    (%rsp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
   11.11 :	  46f4b5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  46f4ba:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    5.56 :	  46f4bf:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  46f4c4:       c9                      leaveq 
    0.00 :	  46f4c5:       c3                      retq   
    0.00 :	  46f4c6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46f4cd:       00 00 00 
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
    0.00 :	  46f4d0:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f4d3:       74 4b                   je     46f520 <slot_getattr+0x120>
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
    0.00 :	  46f4d5:       48 8d 43 40             lea    0x40(%rbx),%rax
    0.00 :	  46f4d9:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  46f4dc:       74 6c                   je     46f54a <slot_getattr+0x14a>
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4de:       4c 89 e1                mov    %r12,%rcx
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4e1:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  46f4e5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  46f4ea:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  46f4ef:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  46f4f4:       c9                      leaveq 
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4f5:       e9 d6 f7 ff ff          jmpq   46ecd0 <heap_getsysattr>
    0.00 :	  46f4fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        }
         :
         :	        /*
         :	         * Extract the attribute, along with any preceding attributes.
         :	         */
         :	        slot_deform_tuple(slot, attnum);
    0.00 :	  46f500:       48 89 df                mov    %rbx,%rdi
    0.00 :	  46f503:       e8 08 fa ff ff          callq  46ef10 <slot_deform_tuple>
         :
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f508:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  46f50c:       42 0f b6 44 28 ff       movzbl -0x1(%rax,%r13,1),%eax
    0.00 :	  46f512:       41 88 04 24             mov    %al,(%r12)
         :	        return slot->tts_values[attnum - 1];
    0.00 :	  46f516:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f51a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
         :	}
    0.00 :	  46f51e:       eb 91                   jmp    46f4b1 <slot_getattr+0xb1>
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
    0.00 :	  46f520:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f525:       be 8f 04 00 00          mov    $0x48f,%esi
    0.00 :	  46f52a:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f52f:       e8 ec be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f534:       be 40 f7 7a 00          mov    $0x7af740,%esi
    0.00 :	  46f539:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f53e:       31 c0                   xor    %eax,%eax
    0.00 :	  46f540:       e8 eb bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f545:       e8 86 9f ff ff          callq  4694d0 <abort@plt>
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
    0.00 :	  46f54a:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f54f:       be 91 04 00 00          mov    $0x491,%esi
    0.00 :	  46f554:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f559:       e8 c2 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f55e:       be 78 f7 7a 00          mov    $0x7af778,%esi
    0.00 :	  46f563:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f568:       31 c0                   xor    %eax,%eax
    0.00 :	  46f56a:       e8 c1 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f56f:       e8 5c 9f ff ff          callq  4694d0 <abort@plt>
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46f574:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f579:       be ac 04 00 00          mov    $0x4ac,%esi
    0.00 :	  46f57e:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f583:       e8 98 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f588:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46f58d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f592:       31 c0                   xor    %eax,%eax
    0.00 :	  46f594:       e8 97 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f599:       e8 32 9f ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   17.65 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:281
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:63
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:63
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:113
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:672
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:235
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:234
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:277
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:277
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:426
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:213
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bdaa0 <ExecHashJoin>:
         :	 *                        the other one is "outer".
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *                                /* return: a tuple or NULL */
         :	ExecHashJoin(HashJoinState *node)
         :	{
    0.00 :	  5bdaa0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:63
    5.88 :	  5bdaa1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bdaa4:       41 57                   push   %r15
    0.00 :	  5bdaa6:       41 56                   push   %r14
    0.00 :	  5bdaa8:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5bdaab:       41 55                   push   %r13
    5.88 :	  5bdaad:       41 54                   push   %r12
    0.00 :	  5bdaaf:       53                      push   %rbx
    0.00 :	  5bdab0:       48 83 ec 58             sub    $0x58,%rsp
         :	        int                     batchno;
         :
         :	        /*
         :	         * get information from HashJoin node
         :	         */
         :	        joinqual = node->js.joinqual;
    0.00 :	  5bdab4:       48 8b 87 80 00 00 00    mov    0x80(%rdi),%rax
    0.00 :	  5bdabb:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	        otherqual = node->js.ps.qual;
    0.00 :	  5bdabf:       48 8b 57 28             mov    0x28(%rdi),%rdx
    0.00 :	  5bdac3:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	        hashNode = (HashState *) innerPlanState(node);
    0.00 :	  5bdac7:       48 8b 4f 38             mov    0x38(%rdi),%rcx
    0.00 :	  5bdacb:       48 89 4d 98             mov    %rcx,-0x68(%rbp)
         :	        outerNode = outerPlanState(node);
    0.00 :	  5bdacf:       48 8b 47 30             mov    0x30(%rdi),%rax
    0.00 :	  5bdad3:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	        hashtable = node->hj_HashTable;
    0.00 :	  5bdad7:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
    0.00 :	  5bdade:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        econtext = node->js.ps.ps_ExprContext;
    0.00 :	  5bdae2:       48 8b 4f 60             mov    0x60(%rdi),%rcx
    0.00 :	  5bdae6:       48 89 4d b0             mov    %rcx,-0x50(%rbp)
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5bdaea:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
    0.00 :	  5bdaee:       74 1c                   je     5bdb0c <ExecHashJoin+0x6c>
         :	        {
         :	                TupleTableSlot *result;
         :
         :	                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5bdaf0:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5bdaf4:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5bdaf8:       e8 03 f5 fe ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5bdafd:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5bdb01:       0f 84 91 04 00 00       je     5bdf98 <ExecHashJoin+0x4f8>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->js.ps.ps_TupFromTlist = false;
    0.00 :	  5bdb07:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a join tuple.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5bdb0c:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5bdb10:       48 8b 78 28             mov    0x28(%rax),%rdi
    0.00 :	  5bdb14:       e8 97 ae 1d 00          callq  7989b0 <MemoryContextReset>
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
    0.00 :	  5bdb19:       49 8d 96 b4 00 00 00    lea    0xb4(%r14),%rdx
    0.00 :	  5bdb20:       48 89 55 88             mov    %rdx,-0x78(%rbp)
    0.00 :	  5bdb24:       0f 1f 40 00             nopl   0x0(%rax)
         :	        /*
         :	         * run the hash join state machine
         :	         */
         :	        for (;;)
         :	        {
         :	                switch (node->hj_JoinState)
    0.00 :	  5bdb28:       41 83 be f0 00 00 00    cmpl   $0x6,0xf0(%r14)
    0.00 :	  5bdb2f:       06 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:113
    5.88 :	  5bdb30:       76 36                   jbe    5bdb68 <ExecHashJoin+0xc8>
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :	                                break;
         :
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
    0.00 :	  5bdb32:       ba c1 ba 88 00          mov    $0x88bac1,%edx
    0.00 :	  5bdb37:       be a7 01 00 00          mov    $0x1a7,%esi
    0.00 :	  5bdb3c:       bf 58 b9 88 00          mov    $0x88b958,%edi
    0.00 :	  5bdb41:       e8 da d8 1b 00          callq  77b420 <elog_start>
    0.00 :	  5bdb46:       41 8b 96 f0 00 00 00    mov    0xf0(%r14),%edx
    0.00 :	  5bdb4d:       be 00 ba 88 00          mov    $0x88ba00,%esi
    0.00 :	  5bdb52:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bdb57:       31 c0                   xor    %eax,%eax
    0.00 :	  5bdb59:       e8 d2 d6 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bdb5e:       e8 6d b9 ea ff          callq  4694d0 <abort@plt>
    0.00 :	  5bdb63:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /*
         :	         * run the hash join state machine
         :	         */
         :	        for (;;)
         :	        {
         :	                switch (node->hj_JoinState)
    0.00 :	  5bdb68:       41 8b 86 f0 00 00 00    mov    0xf0(%r14),%eax
    0.00 :	  5bdb6f:       ff 24 c5 50 ba 88 00    jmpq   *0x88ba50(,%rax,8)
    0.00 :	  5bdb76:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bdb7d:       00 00 00 
         :	                                 *
         :	                                 * The only way to make the check is to try to fetch a tuple
         :	                                 * from the outer plan node.  If we succeed, we have to stash
         :	                                 * it away for later consumption by ExecHashJoinOuterGetTuple.
         :	                                 */
         :	                                if (HJ_FILL_INNER(node))
    0.00 :	  5bdb80:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdb87:       00 
    0.00 :	  5bdb88:       0f 84 da 05 00 00       je     5be168 <ExecHashJoin+0x6c8>
         :	                                        }
         :	                                        else
         :	                                                node->hj_OuterNotEmpty = true;
         :	                                }
         :	                                else
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
    0.00 :	  5bdb8e:       49 c7 86 e8 00 00 00    movq   $0x0,0xe8(%r14)
    0.00 :	  5bdb95:       00 00 00 00 
         :
         :	                                /*
         :	                                 * create the hash table
         :	                                 */
         :	                                hashtable = ExecHashTableCreate((Hash *) hashNode->ps.plan,
    0.00 :	  5bdb99:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5bdb9d:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdb9f:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdba6:       00 
    0.00 :	  5bdba7:       49 8b b6 a0 00 00 00    mov    0xa0(%r14),%rsi
    0.00 :	  5bdbae:       48 8b 78 08             mov    0x8(%rax),%rdi
    0.00 :	  5bdbb2:       0f 95 c2                setne  %dl
    0.00 :	  5bdbb5:       e8 e6 ec ff ff          callq  5bc8a0 <ExecHashTableCreate>
         :	                                node->hj_HashTable = hashtable;
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
    0.00 :	  5bdbba:       48 8b 55 98             mov    -0x68(%rbp),%rdx
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :
         :	                                /*
         :	                                 * create the hash table
         :	                                 */
         :	                                hashtable = ExecHashTableCreate((Hash *) hashNode->ps.plan,
    0.00 :	  5bdbbe:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :	                                                                                                node->hj_HashOperators,
         :	                                                                                                HJ_FILL_INNER(node));
         :	                                node->hj_HashTable = hashtable;
    0.00 :	  5bdbc2:       49 89 86 a8 00 00 00    mov    %rax,0xa8(%r14)
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
         :	                                (void) MultiExecProcNode((PlanState *) hashNode);
    0.00 :	  5bdbc9:       48 89 d7                mov    %rdx,%rdi
         :	                                node->hj_HashTable = hashtable;
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
    0.00 :	  5bdbcc:       48 89 42 78             mov    %rax,0x78(%rdx)
         :	                                (void) MultiExecProcNode((PlanState *) hashNode);
    0.00 :	  5bdbd0:       e8 fb e7 fe ff          callq  5ac3d0 <MultiExecProcNode>
         :	                                /*
         :	                                 * If the inner relation is completely empty, and we're not
         :	                                 * doing a left outer join, we can quit without scanning the
         :	                                 * outer relation.
         :	                                 */
         :	                                if (hashtable->totalTuples == 0 && !HJ_FILL_OUTER(node))
    0.00 :	  5bdbd5:       66 0f 57 c0             xorpd  %xmm0,%xmm0
    0.00 :	  5bdbd9:       48 8b 4d b8             mov    -0x48(%rbp),%rcx
    0.00 :	  5bdbdd:       66 0f 2e 41 58          ucomisd 0x58(%rcx),%xmm0
    0.00 :	  5bdbe2:       0f 84 6b 06 00 00       je     5be253 <ExecHashJoin+0x7b3>
         :
         :	                                /*
         :	                                 * need to remember whether nbatch has increased since we
         :	                                 * began scanning the outer relation
         :	                                 */
         :	                                hashtable->nbatch_outstart = hashtable->nbatch;
    0.00 :	  5bdbe8:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  5bdbec:       8b 42 40                mov    0x40(%rdx),%eax
    0.00 :	  5bdbef:       89 42 4c                mov    %eax,0x4c(%rdx)
         :	                                /*
         :	                                 * Reset OuterNotEmpty for scan.  (It's OK if we fetched a
         :	                                 * tuple above, because ExecHashJoinOuterGetTuple will
         :	                                 * immediately set it again.)
         :	                                 */
         :	                                node->hj_OuterNotEmpty = false;
    0.00 :	  5bdbf2:       41 c6 86 f5 00 00 00    movb   $0x0,0xf5(%r14)
    0.00 :	  5bdbf9:       00 
         :
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5bdbfa:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5bdc01:       02 00 00 00 
         :	static TupleTableSlot *
         :	ExecHashJoinOuterGetTuple(PlanState *outerNode,
         :	                                                  HashJoinState *hjstate,
         :	                                                  uint32 *hashvalue)
         :	{
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bdc05:       49 8b 9e a8 00 00 00    mov    0xa8(%r14),%rbx
         :	        int                     curbatch = hashtable->curbatch;
    0.00 :	  5bdc0c:       8b 43 44                mov    0x44(%rbx),%eax
         :	        TupleTableSlot *slot;
         :
         :	        if (curbatch == 0)                      /* if it is the first pass */
    0.00 :	  5bdc0f:       85 c0                   test   %eax,%eax
    0.00 :	  5bdc11:       0f 85 a9 00 00 00       jne    5bdcc0 <ExecHashJoin+0x220>
         :	        {
         :	                /*
         :	                 * Check to see if first outer tuple was already fetched by
         :	                 * ExecHashJoin() and not used yet.
         :	                 */
         :	                slot = hjstate->hj_FirstOuterTupleSlot;
    0.00 :	  5bdc17:       4d 8b a6 e8 00 00 00    mov    0xe8(%r14),%r12
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdc1e:       4d 85 e4                test   %r12,%r12
    0.00 :	  5bdc21:       74 5d                   je     5bdc80 <ExecHashJoin+0x1e0>
    0.00 :	  5bdc23:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
    0.00 :	  5bdc29:       75 55                   jne    5bdc80 <ExecHashJoin+0x1e0>
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
    0.00 :	  5bdc2b:       49 c7 86 e8 00 00 00    movq   $0x0,0xe8(%r14)
    0.00 :	  5bdc32:       00 00 00 00 
    0.00 :	  5bdc36:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bdc3d:       00 00 00 
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
    0.00 :	  5bdc40:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
   11.76 :	  5bdc46:       75 50                   jne    5bdc98 <ExecHashJoin+0x1f8>
         :	                {
         :	                        /*
         :	                         * We have to compute the tuple's hash value.
         :	                         */
         :	                        ExprContext *econtext = hjstate->js.ps.ps_ExprContext;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:672
    5.88 :	  5bdc48:       49 8b 76 60             mov    0x60(%r14),%rsi
         :
         :	                        econtext->ecxt_outertuple = slot;
         :	                        if (ExecHashGetHashValue(hashtable, econtext,
    0.00 :	  5bdc4c:       4c 8d 4d d0             lea    -0x30(%rbp),%r9
    0.00 :	  5bdc50:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  5bdc55:       48 89 df                mov    %rbx,%rdi
         :	                        /*
         :	                         * We have to compute the tuple's hash value.
         :	                         */
         :	                        ExprContext *econtext = hjstate->js.ps.ps_ExprContext;
         :
         :	                        econtext->ecxt_outertuple = slot;
    0.00 :	  5bdc58:       4c 89 66 18             mov    %r12,0x18(%rsi)
         :	                        if (ExecHashGetHashValue(hashtable, econtext,
    0.00 :	  5bdc5c:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5bdc63:       00 
    0.00 :	  5bdc64:       49 8b 96 90 00 00 00    mov    0x90(%r14),%rdx
    0.00 :	  5bdc6b:       41 0f 95 c0             setne  %r8b
    0.00 :	  5bdc6f:       41 83 e0 01             and    $0x1,%r8d
    0.00 :	  5bdc73:       e8 18 e2 ff ff          callq  5bbe90 <ExecHashGetHashValue>
    0.00 :	  5bdc78:       84 c0                   test   %al,%al
    0.00 :	  5bdc7a:       0f 85 90 04 00 00       jne    5be110 <ExecHashJoin+0x670>
         :
         :	                        /*
         :	                         * That tuple couldn't match because of a NULL, so discard it and
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
    0.00 :	  5bdc80:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  5bdc84:       e8 17 e8 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                if (!TupIsNull(slot))
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
   11.76 :	  5bdc89:       48 85 c0                test   %rax,%rax
         :
         :	                        /*
         :	                         * That tuple couldn't match because of a NULL, so discard it and
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
    0.00 :	  5bdc8c:       49 89 c4                mov    %rax,%r12
         :	                if (!TupIsNull(slot))
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
    0.00 :	  5bdc8f:       75 af                   jne    5bdc40 <ExecHashJoin+0x1a0>
    0.00 :	  5bdc91:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                                                                   node,
         :	                                                                                                                   &hashvalue);
         :	                                if (TupIsNull(outerTupleSlot))
         :	                                {
         :	                                        /* end of batch, or maybe whole join */
         :	                                        if (HJ_FILL_INNER(node))
    0.00 :	  5bdc98:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdc9f:       00 
    0.00 :	  5bdca0:       0f 84 0a 03 00 00       je     5bdfb0 <ExecHashJoin+0x510>
         :	                                        {
         :	                                                /* set up to scan for unmatched inner tuples */
         :	                                                ExecPrepHashTableForUnmatched(node);
    0.00 :	  5bdca6:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdca9:       e8 52 de ff ff          callq  5bbb00 <ExecPrepHashTableForUnmatched>
         :	                                                node->hj_JoinState = HJ_FILL_INNER_TUPLES;
    0.00 :	  5bdcae:       41 c7 86 f0 00 00 00    movl   $0x5,0xf0(%r14)
    0.00 :	  5bdcb5:       05 00 00 00 
    0.00 :	  5bdcb9:       e9 6a fe ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdcbe:       66 90                   xchg   %ax,%ax
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
         :	                }
         :	        }
         :	        else if (curbatch < hashtable->nbatch)
    0.00 :	  5bdcc0:       3b 43 40                cmp    0x40(%rbx),%eax
    0.00 :	  5bdcc3:       7d d3                   jge    5bdc98 <ExecHashJoin+0x1f8>
         :	        {
         :	                BufFile    *file = hashtable->outerBatchFile[curbatch];
    0.00 :	  5bdcc5:       48 63 d0                movslq %eax,%rdx
    0.00 :	  5bdcc8:       48 8b 43 70             mov    0x70(%rbx),%rax
    0.00 :	  5bdccc:       48 8b 34 d0             mov    (%rax,%rdx,8),%rsi
         :
         :	                /*
         :	                 * In outer-join cases, we could get here even though the batch file
         :	                 * is empty.
         :	                 */
         :	                if (file == NULL)
    0.00 :	  5bdcd0:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5bdcd3:       74 c3                   je     5bdc98 <ExecHashJoin+0x1f8>
         :	                        return NULL;
         :
         :	                slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5bdcd5:       49 8b 8e c8 00 00 00    mov    0xc8(%r14),%rcx
    0.00 :	  5bdcdc:       48 8d 55 d0             lea    -0x30(%rbp),%rdx
    0.00 :	  5bdce0:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdce3:       e8 c8 fc ff ff          callq  5bd9b0 <ExecHashJoinGetSavedTuple>
         :	                                                                                 file,
         :	                                                                                 hashvalue,
         :	                                                                                 hjstate->hj_OuterTupleSlot);
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdce8:       48 85 c0                test   %rax,%rax
         :	                 * is empty.
         :	                 */
         :	                if (file == NULL)
         :	                        return NULL;
         :
         :	                slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5bdceb:       49 89 c4                mov    %rax,%r12
         :	                                                                                 file,
         :	                                                                                 hashvalue,
         :	                                                                                 hjstate->hj_OuterTupleSlot);
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdcee:       74 a8                   je     5bdc98 <ExecHashJoin+0x1f8>
    0.00 :	  5bdcf0:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5bdcf4:       75 a2                   jne    5bdc98 <ExecHashJoin+0x1f8>
         :	                                        else
         :	                                                node->hj_JoinState = HJ_NEED_NEW_BATCH;
         :	                                        continue;
         :	                                }
         :
         :	                                econtext->ecxt_outertuple = outerTupleSlot;
    0.00 :	  5bdcf6:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
    0.00 :	  5bdcfa:       4c 89 61 18             mov    %r12,0x18(%rcx)
         :
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
    0.00 :	  5bdcfe:       8b 75 d0                mov    -0x30(%rbp),%esi
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:235
    5.88 :	  5bdd01:       48 8d 4d cc             lea    -0x34(%rbp),%rcx
    0.00 :	  5bdd05:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  5bdd09:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
         :	                                                node->hj_JoinState = HJ_NEED_NEW_BATCH;
         :	                                        continue;
         :	                                }
         :
         :	                                econtext->ecxt_outertuple = outerTupleSlot;
         :	                                node->hj_MatchedOuter = false;
    0.00 :	  5bdd0d:       41 c6 86 f4 00 00 00    movb   $0x0,0xf4(%r14)
    0.00 :	  5bdd14:       00 
         :
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:234
    5.88 :	  5bdd15:       41 89 b6 b0 00 00 00    mov    %esi,0xb0(%r14)
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
    0.00 :	  5bdd1c:       e8 9f dd ff ff          callq  5bbac0 <ExecHashGetBucketAndBatch>
         :	                                                                                  &node->hj_CurBucketNo, &batchno);
         :	                                node->hj_CurSkewBucketNo = ExecHashGetSkewBucket(hashtable,
    0.00 :	  5bdd21:       8b 75 d0                mov    -0x30(%rbp),%esi
    0.00 :	  5bdd24:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5bdd28:       e8 83 de ff ff          callq  5bbbb0 <ExecHashGetSkewBucket>
         :
         :	                                /*
         :	                                 * The tuple might not belong to the current batch (where
         :	                                 * "current batch" includes the skew buckets if any).
         :	                                 */
         :	                                if (batchno != hashtable->curbatch &&
    0.00 :	  5bdd2d:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
         :	                                                                                  &node->hj_CurBucketNo, &batchno);
         :	                                node->hj_CurSkewBucketNo = ExecHashGetSkewBucket(hashtable,
    0.00 :	  5bdd31:       41 89 86 b8 00 00 00    mov    %eax,0xb8(%r14)
         :	                                                                                                                                 hashvalue);
         :	                                node->hj_CurTuple = NULL;
    0.00 :	  5bdd38:       49 c7 86 c0 00 00 00    movq   $0x0,0xc0(%r14)
    0.00 :	  5bdd3f:       00 00 00 00 
         :
         :	                                /*
         :	                                 * The tuple might not belong to the current batch (where
         :	                                 * "current batch" includes the skew buckets if any).
         :	                                 */
         :	                                if (batchno != hashtable->curbatch &&
    0.00 :	  5bdd43:       8b 45 cc                mov    -0x34(%rbp),%eax
    0.00 :	  5bdd46:       39 42 44                cmp    %eax,0x44(%rdx)
    0.00 :	  5bdd49:       74 0e                   je     5bdd59 <ExecHashJoin+0x2b9>
    0.00 :	  5bdd4b:       41 83 be b8 00 00 00    cmpl   $0xffffffff,0xb8(%r14)
    0.00 :	  5bdd52:       ff 
    0.00 :	  5bdd53:       0f 84 4d 04 00 00       je     5be1a6 <ExecHashJoin+0x706>
         :	                                        /* Loop around, staying in HJ_NEED_NEW_OUTER state */
         :	                                        continue;
         :	                                }
         :
         :	                                /* OK, let's scan the bucket for matches */
         :	                                node->hj_JoinState = HJ_SCAN_BUCKET;
    0.00 :	  5bdd59:       41 c7 86 f0 00 00 00    movl   $0x3,0xf0(%r14)
    0.00 :	  5bdd60:       03 00 00 00 
         :	                                /*
         :	                                 * We check for interrupts here because this corresponds to
         :	                                 * where we'd fetch a row from a child plan node in other join
         :	                                 * types.
         :	                                 */
         :	                                CHECK_FOR_INTERRUPTS();
    0.00 :	  5bdd64:       0f b6 05 25 c3 5f 00    movzbl 0x5fc325(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  5bdd6b:       84 c0                   test   %al,%al
    0.00 :	  5bdd6d:       0f 85 8d 03 00 00       jne    5be100 <ExecHashJoin+0x660>
         :
         :	                                /*
         :	                                 * Scan the selected hash bucket for matches to current outer
         :	                                 */
         :	                                if (!ExecScanHashBucket(node, econtext))
    0.00 :	  5bdd73:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:277
    5.88 :	  5bdd77:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdd7a:       e8 21 e0 ff ff          callq  5bbda0 <ExecScanHashBucket>
    5.88 :	  5bdd7f:       84 c0                   test   %al,%al
    0.00 :	  5bdd81:       0f 85 39 02 00 00       jne    5bdfc0 <ExecHashJoin+0x520>
         :	                                {
         :	                                        /* out of matches; check for possible outer-join fill */
         :	                                        node->hj_JoinState = HJ_FILL_OUTER_TUPLE;
    0.00 :	  5bdd87:       41 c7 86 f0 00 00 00    movl   $0x4,0xf0(%r14)
    0.00 :	  5bdd8e:       04 00 00 00 
         :	                                        continue;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:281
   17.65 :	  5bdd92:       e9 91 fd ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdd97:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bdd9e:       00 00 
         :	 * Returns true if successful, false if there are no more batches.
         :	 */
         :	static bool
         :	ExecHashJoinNewBatch(HashJoinState *hjstate)
         :	{
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bdda0:       4d 8b a6 a8 00 00 00    mov    0xa8(%r14),%r12
         :	        BufFile    *innerFile;
         :	        TupleTableSlot *slot;
         :	        uint32          hashvalue;
         :
         :	        nbatch = hashtable->nbatch;
         :	        curbatch = hashtable->curbatch;
    0.00 :	  5bdda7:       41 8b 5c 24 44          mov    0x44(%r12),%ebx
         :	        int                     curbatch;
         :	        BufFile    *innerFile;
         :	        TupleTableSlot *slot;
         :	        uint32          hashvalue;
         :
         :	        nbatch = hashtable->nbatch;
    0.00 :	  5bddac:       45 8b 7c 24 40          mov    0x40(%r12),%r15d
         :	        curbatch = hashtable->curbatch;
         :
         :	        if (curbatch > 0)
    0.00 :	  5bddb1:       85 db                   test   %ebx,%ebx
    0.00 :	  5bddb3:       0f 8e 77 03 00 00       jle    5be130 <ExecHashJoin+0x690>
         :	        {
         :	                /*
         :	                 * We no longer need the previous outer batch file; close it right
         :	                 * away to free disk space.
         :	                 */
         :	                if (hashtable->outerBatchFile[curbatch])
    0.00 :	  5bddb9:       48 63 c3                movslq %ebx,%rax
    0.00 :	  5bddbc:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  5bddc3:       00 
    0.00 :	  5bddc4:       4c 89 e8                mov    %r13,%rax
    0.00 :	  5bddc7:       49 03 44 24 70          add    0x70(%r12),%rax
    0.00 :	  5bddcc:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5bddcf:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bddd2:       74 0d                   je     5bdde1 <ExecHashJoin+0x341>
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
    0.00 :	  5bddd4:       e8 d7 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bddd9:       4c 89 e8                mov    %r13,%rax
    0.00 :	  5bdddc:       49 03 44 24 70          add    0x70(%r12),%rax
         :	                hashtable->outerBatchFile[curbatch] = NULL;
    0.00 :	  5bdde1:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
         :	         *
         :	         * 3. Similarly, if we have increased nbatch since starting the outer
         :	         * scan, we have to rescan outer batches in case they contain tuples that
         :	         * need to be reassigned.
         :	         */
         :	        curbatch++;
    0.00 :	  5bdde8:       44 8d 6b 01             lea    0x1(%rbx),%r13d
         :	        while (curbatch < nbatch &&
    0.00 :	  5bddec:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  5bddef:       7f 73                   jg     5bde64 <ExecHashJoin+0x3c4>
    0.00 :	  5bddf1:       e9 7a 04 00 00          jmpq   5be270 <ExecHashJoin+0x7d0>
    0.00 :	  5bddf6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bddfd:       00 00 00 
    0.00 :	  5bde00:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bde05:       48 83 3c d8 00          cmpq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde0a:       0f 85 38 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                   (hashtable->outerBatchFile[curbatch] == NULL ||
         :	                        hashtable->innerBatchFile[curbatch] == NULL))
         :	        {
         :	                if (hashtable->outerBatchFile[curbatch] &&
    0.00 :	  5bde10:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5bde17:       00 
    0.00 :	  5bde18:       0f 85 2a 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        HJ_FILL_INNER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
         :	                        nbatch != hashtable->nbatch_original)
         :	                        break;                          /* must process due to rule 2 */
         :	                if (hashtable->outerBatchFile[curbatch] &&
    0.00 :	  5bde1e:       45 3b 7c 24 4c          cmp    0x4c(%r12),%r15d
    0.00 :	  5bde23:       0f 85 1f 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        break;                          /* must process due to rule 3 */
         :	                /* We can ignore this batch. */
         :	                /* Release associated temp files right away. */
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
         :	                hashtable->innerBatchFile[curbatch] = NULL;
    0.00 :	  5bde29:       48 c7 04 d8 00 00 00    movq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde30:       00 
         :	                if (hashtable->outerBatchFile[curbatch])
    0.00 :	  5bde31:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bde35:       49 03 44 24 70          add    0x70(%r12),%rax
    0.00 :	  5bde3a:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5bde3d:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bde40:       74 0e                   je     5bde50 <ExecHashJoin+0x3b0>
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
    0.00 :	  5bde42:       e8 69 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bde47:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bde4b:       49 03 44 24 70          add    0x70(%r12),%rax
         :	                hashtable->outerBatchFile[curbatch] = NULL;
         :	                curbatch++;
    0.00 :	  5bde50:       41 83 c5 01             add    $0x1,%r13d
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
         :	                hashtable->innerBatchFile[curbatch] = NULL;
         :	                if (hashtable->outerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
         :	                hashtable->outerBatchFile[curbatch] = NULL;
    0.00 :	  5bde54:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
         :	         * 3. Similarly, if we have increased nbatch since starting the outer
         :	         * scan, we have to rescan outer batches in case they contain tuples that
         :	         * need to be reassigned.
         :	         */
         :	        curbatch++;
         :	        while (curbatch < nbatch &&
    0.00 :	  5bde5b:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  5bde5e:       0f 8e 0c 04 00 00       jle    5be270 <ExecHashJoin+0x7d0>
    0.00 :	  5bde64:       49 63 dd                movslq %r13d,%rbx
    0.00 :	  5bde67:       48 8d 0c dd 00 00 00    lea    0x0(,%rbx,8),%rcx
    0.00 :	  5bde6e:       00 
    0.00 :	  5bde6f:       48 89 4d c0             mov    %rcx,-0x40(%rbp)
    0.00 :	  5bde73:       49 8b 44 24 70          mov    0x70(%r12),%rax
    0.00 :	  5bde78:       48 83 3c d8 00          cmpq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde7d:       75 81                   jne    5bde00 <ExecHashJoin+0x360>
         :	                        hashtable->innerBatchFile[curbatch] == NULL))
         :	        {
         :	                if (hashtable->outerBatchFile[curbatch] &&
         :	                        HJ_FILL_OUTER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
    0.00 :	  5bde7f:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bde84:       48 8b 3c d8             mov    (%rax,%rbx,8),%rdi
    0.00 :	  5bde88:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bde8b:       74 9c                   je     5bde29 <ExecHashJoin+0x389>
    0.00 :	  5bde8d:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bde94:       00 
    0.00 :	  5bde95:       0f 85 ad 01 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        HJ_FILL_INNER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
    0.00 :	  5bde9b:       45 3b 7c 24 48          cmp    0x48(%r12),%r15d
    0.00 :	  5bdea0:       0f 85 a2 01 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        nbatch != hashtable->nbatch_outstart)
         :	                        break;                          /* must process due to rule 3 */
         :	                /* We can ignore this batch. */
         :	                /* Release associated temp files right away. */
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
    0.00 :	  5bdea6:       e8 05 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bdeab:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bdeb0:       e9 74 ff ff ff          jmpq   5bde29 <ExecHashJoin+0x389>
    0.00 :	  5bdeb5:       0f 1f 00                nopl   (%rax)
         :	                                /*
         :	                                 * We have finished a batch, but we are doing right/full join,
         :	                                 * so any unmatched inner tuples in the hashtable have to be
         :	                                 * emitted before we continue to the next batch.
         :	                                 */
         :	                                if (!ExecScanHashTableForUnmatched(node, econtext))
    0.00 :	  5bdeb8:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdebc:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdebf:       e8 ec dd ff ff          callq  5bbcb0 <ExecScanHashTableForUnmatched>
    0.00 :	  5bdec4:       84 c0                   test   %al,%al
    0.00 :	  5bdec6:       0f 84 e4 00 00 00       je     5bdfb0 <ExecHashJoin+0x510>
         :
         :	                                /*
         :	                                 * Generate a fake join tuple with nulls for the outer tuple,
         :	                                 * and return it if it passes the non-join quals.
         :	                                 */
         :	                                econtext->ecxt_outertuple = node->hj_NullOuterTupleSlot;
    0.00 :	  5bdecc:       49 8b 86 d8 00 00 00    mov    0xd8(%r14),%rax
    0.00 :	  5bded3:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5bded7:       48 89 42 18             mov    %rax,0x18(%rdx)
         :
         :	                                if (otherqual == NIL ||
    0.00 :	  5bdedb:       48 83 7d a8 00          cmpq   $0x0,-0x58(%rbp)
    0.00 :	  5bdee0:       0f 84 8c 00 00 00       je     5bdf72 <ExecHashJoin+0x4d2>
    0.00 :	  5bdee6:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdeea:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5bdeee:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdef0:       e8 1b f0 fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdef5:       84 c0                   test   %al,%al
    0.00 :	  5bdef7:       75 79                   jne    5bdf72 <ExecHashJoin+0x4d2>
         :	                                                        (isDone == ExprMultipleResult);
         :	                                                return result;
         :	                                        }
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered2(node, 1);
    0.00 :	  5bdef9:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5bdefd:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdf00:       0f 84 22 fc ff ff       je     5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf06:       f2 0f 10 05 4a 12 1f    movsd  0x1f124a(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bdf0d:       00 
    0.00 :	  5bdf0e:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5bdf15:       00 
    0.00 :	  5bdf16:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5bdf1d:       00 
    0.00 :	  5bdf1e:       e9 05 fc ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf23:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                 * whether to emit a dummy outer-join tuple.  Whether we emit
         :	                                 * one or not, the next state is NEED_NEW_OUTER.
         :	                                 */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :
         :	                                if (!node->hj_MatchedOuter &&
    0.00 :	  5bdf28:       41 80 be f4 00 00 00    cmpb   $0x0,0xf4(%r14)
    0.00 :	  5bdf2f:       00 
         :	                                /*
         :	                                 * The current outer tuple has run out of matches, so check
         :	                                 * whether to emit a dummy outer-join tuple.  Whether we emit
         :	                                 * one or not, the next state is NEED_NEW_OUTER.
         :	                                 */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5bdf30:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5bdf37:       02 00 00 00 
         :
         :	                                if (!node->hj_MatchedOuter &&
    0.00 :	  5bdf3b:       0f 85 e7 fb ff ff       jne    5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf41:       49 8b 86 e0 00 00 00    mov    0xe0(%r14),%rax
    0.00 :	  5bdf48:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdf4b:       0f 84 d7 fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
         :	                                {
         :	                                        /*
         :	                                         * Generate a fake join tuple with nulls for the inner
         :	                                         * tuple, and return it if it passes the non-join quals.
         :	                                         */
         :	                                        econtext->ecxt_innertuple = node->hj_NullInnerTupleSlot;
    0.00 :	  5bdf51:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
    0.00 :	  5bdf55:       48 89 41 10             mov    %rax,0x10(%rcx)
         :
         :	                                        if (otherqual == NIL ||
    0.00 :	  5bdf59:       48 83 7d a8 00          cmpq   $0x0,-0x58(%rbp)
    0.00 :	  5bdf5e:       74 12                   je     5bdf72 <ExecHashJoin+0x4d2>
    0.00 :	  5bdf60:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5bdf64:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdf66:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  5bdf69:       e8 a2 ef fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdf6e:       84 c0                   test   %al,%al
    0.00 :	  5bdf70:       74 87                   je     5bdef9 <ExecHashJoin+0x459>
         :	                                if (otherqual == NIL ||
         :	                                        ExecQual(otherqual, econtext, false))
         :	                                {
         :	                                        TupleTableSlot *result;
         :
         :	                                        result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5bdf72:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5bdf76:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5bdf7a:       e8 81 f0 fe ff          callq  5ad000 <ExecProject>
         :
         :	                                        if (isDone != ExprEndResult)
    0.00 :	  5bdf7f:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5bdf82:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5bdf85:       0f 84 9d fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
         :	                                        {
         :	                                                node->js.ps.ps_TupFromTlist =
    0.00 :	  5bdf8b:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5bdf8e:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5bdf93:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
         :	                                         (int) node->hj_JoinState);
         :	                }
         :	        }
         :	}
    0.00 :	  5bdf98:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  5bdf9c:       5b                      pop    %rbx
    0.00 :	  5bdf9d:       41 5c                   pop    %r12
    0.00 :	  5bdf9f:       41 5d                   pop    %r13
    0.00 :	  5bdfa1:       41 5e                   pop    %r14
    0.00 :	  5bdfa3:       41 5f                   pop    %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:426
    5.88 :	  5bdfa5:       c9                      leaveq 
    0.00 :	  5bdfa6:       c3                      retq   
    0.00 :	  5bdfa7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bdfae:       00 00 
         :	                                 * emitted before we continue to the next batch.
         :	                                 */
         :	                                if (!ExecScanHashTableForUnmatched(node, econtext))
         :	                                {
         :	                                        /* no more unmatched tuples */
         :	                                        node->hj_JoinState = HJ_NEED_NEW_BATCH;
    0.00 :	  5bdfb0:       41 c7 86 f0 00 00 00    movl   $0x6,0xf0(%r14)
    0.00 :	  5bdfb7:       06 00 00 00 
         :	                                        continue;
    0.00 :	  5bdfbb:       e9 68 fb ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
         :	                                 * table, and return the slot.
         :	                                 *
         :	                                 * Only the joinquals determine tuple match status, but all
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
    0.00 :	  5bdfc0:       48 83 7d a0 00          cmpq   $0x0,-0x60(%rbp)
    0.00 :	  5bdfc5:       74 41                   je     5be008 <ExecHashJoin+0x568>
    0.00 :	  5bdfc7:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdfcb:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5bdfcf:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdfd1:       e8 3a ef fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdfd6:       84 c0                   test   %al,%al
    0.00 :	  5bdfd8:       75 2e                   jne    5be008 <ExecHashJoin+0x568>
         :	                                        }
         :	                                        else
         :	                                                InstrCountFiltered2(node, 1);
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered1(node, 1);
    0.00 :	  5bdfda:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5bdfde:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdfe1:       0f 84 41 fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdfe7:       f2 0f 10 05 69 11 1f    movsd  0x1f1169(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bdfee:       00 
    0.00 :	  5bdfef:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5bdff6:       00 
    0.00 :	  5bdff7:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5bdffe:       00 
    0.00 :	  5bdfff:       e9 24 fb ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5be004:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
         :	                                {
         :	                                        node->hj_MatchedOuter = true;
         :	                                        HeapTupleHeaderSetMatch(HJTUPLE_MINTUPLE(node->hj_CurTuple));
    0.00 :	  5be008:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :	                                 * Only the joinquals determine tuple match status, but all
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
         :	                                {
         :	                                        node->hj_MatchedOuter = true;
    0.00 :	  5be00f:       41 c6 86 f4 00 00 00    movb   $0x1,0xf4(%r14)
    0.00 :	  5be016:       01 
         :	                                        HeapTupleHeaderSetMatch(HJTUPLE_MINTUPLE(node->hj_CurTuple));
    0.00 :	  5be017:       66 81 48 1a 00 80       orw    $0x8000,0x1a(%rax)
         :
         :	                                        /* In an antijoin, we never return a matched tuple */
         :	                                        if (node->js.jointype == JOIN_ANTI)
    0.00 :	  5be01d:       41 8b 46 78             mov    0x78(%r14),%eax
    0.00 :	  5be021:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5be024:       0f 84 bd 00 00 00       je     5be0e7 <ExecHashJoin+0x647>
         :
         :	                                        /*
         :	                                         * In a semijoin, we'll consider returning the first
         :	                                         * match, but after that we're done with this outer tuple.
         :	                                         */
         :	                                        if (node->js.jointype == JOIN_SEMI)
    0.00 :	  5be02a:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  5be02d:       0f 85 a8 fe ff ff       jne    5bdedb <ExecHashJoin+0x43b>
         :	                                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5be033:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5be03a:       02 00 00 00 
    0.00 :	  5be03e:       e9 98 fe ff ff          jmpq   5bdedb <ExecHashJoin+0x43b>
    0.00 :	  5be043:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        }
         :
         :	        if (curbatch >= nbatch)
         :	                return false;                   /* no more batches */
         :
         :	        hashtable->curbatch = curbatch;
    0.00 :	  5be048:       45 89 6c 24 44          mov    %r13d,0x44(%r12)
         :
         :	        /*
         :	         * Reload the hash table with the new inner batch (which could be empty)
         :	         */
         :	        ExecHashTableReset(hashtable);
    0.00 :	  5be04d:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be050:       e8 db db ff ff          callq  5bbc30 <ExecHashTableReset>
         :
         :	        innerFile = hashtable->innerBatchFile[curbatch];
    0.00 :	  5be055:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5be05a:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5be05e:       48 8b 1c 10             mov    (%rax,%rdx,1),%rbx
         :
         :	        if (innerFile != NULL)
    0.00 :	  5be062:       48 85 db                test   %rbx,%rbx
    0.00 :	  5be065:       74 5b                   je     5be0c2 <ExecHashJoin+0x622>
         :	        {
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
    0.00 :	  5be067:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5be069:       31 d2                   xor    %edx,%edx
    0.00 :	  5be06b:       31 f6                   xor    %esi,%esi
    0.00 :	  5be06d:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5be070:       e8 8b ca 0b 00          callq  67ab00 <BufFileSeek>
    0.00 :	  5be075:       85 c0                   test   %eax,%eax
    0.00 :	  5be077:       74 15                   je     5be08e <ExecHashJoin+0x5ee>
    0.00 :	  5be079:       e9 08 02 00 00          jmpq   5be286 <ExecHashJoin+0x7e6>
    0.00 :	  5be07e:       66 90                   xchg   %ax,%ax
         :	                {
         :	                        /*
         :	                         * NOTE: some tuples may be sent to future batches.  Also, it is
         :	                         * possible for hashtable->nbatch to be increased here!
         :	                         */
         :	                        ExecHashTableInsert(hashtable, slot, hashvalue);
    0.00 :	  5be080:       8b 55 c8                mov    -0x38(%rbp),%edx
    0.00 :	  5be083:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5be086:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be089:       e8 82 e3 ff ff          callq  5bc410 <ExecHashTableInsert>
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
         :	                                        (errcode_for_file_access(),
         :	                                   errmsg("could not rewind hash-join temporary file: %m")));
         :
         :	                while ((slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5be08e:       49 8b 8e d0 00 00 00    mov    0xd0(%r14),%rcx
    0.00 :	  5be095:       48 8d 55 c8             lea    -0x38(%rbp),%rdx
    0.00 :	  5be099:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5be09c:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5be09f:       e8 0c f9 ff ff          callq  5bd9b0 <ExecHashJoinGetSavedTuple>
    0.00 :	  5be0a4:       48 85 c0                test   %rax,%rax
    0.00 :	  5be0a7:       75 d7                   jne    5be080 <ExecHashJoin+0x5e0>
         :
         :	                /*
         :	                 * after we build the hash table, the inner batch file is no longer
         :	                 * needed
         :	                 */
         :	                BufFileClose(innerFile);
    0.00 :	  5be0a9:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5be0ac:       e8 ff ce 0b 00          callq  67afb0 <BufFileClose>
         :	                hashtable->innerBatchFile[curbatch] = NULL;
    0.00 :	  5be0b1:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5be0b6:       48 8b 4d c0             mov    -0x40(%rbp),%rcx
    0.00 :	  5be0ba:       48 c7 04 08 00 00 00    movq   $0x0,(%rax,%rcx,1)
    0.00 :	  5be0c1:       00 
         :	        }
         :
         :	        /*
         :	         * Rewind outer batch file (if present), so that we can start reading it.
         :	         */
         :	        if (hashtable->outerBatchFile[curbatch] != NULL)
    0.00 :	  5be0c2:       49 8b 44 24 70          mov    0x70(%r12),%rax
    0.00 :	  5be0c7:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5be0cb:       48 8b 3c 10             mov    (%rax,%rdx,1),%rdi
    0.00 :	  5be0cf:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5be0d2:       74 13                   je     5be0e7 <ExecHashJoin+0x647>
         :	        {
         :	                if (BufFileSeek(hashtable->outerBatchFile[curbatch], 0, 0L, SEEK_SET))
    0.00 :	  5be0d4:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5be0d6:       31 d2                   xor    %edx,%edx
    0.00 :	  5be0d8:       31 f6                   xor    %esi,%esi
    0.00 :	  5be0da:       e8 21 ca 0b 00          callq  67ab00 <BufFileSeek>
    0.00 :	  5be0df:       85 c0                   test   %eax,%eax
    0.00 :	  5be0e1:       0f 85 ea 00 00 00       jne    5be1d1 <ExecHashJoin+0x731>
         :	                                /*
         :	                                 * Try to advance to next batch.  Done if there are no more.
         :	                                 */
         :	                                if (!ExecHashJoinNewBatch(node))
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5be0e7:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5be0ee:       02 00 00 00 
    0.00 :	  5be0f2:       e9 31 fa ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5be0f7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5be0fe:       00 00 
         :	                                /*
         :	                                 * We check for interrupts here because this corresponds to
         :	                                 * where we'd fetch a row from a child plan node in other join
         :	                                 * types.
         :	                                 */
         :	                                CHECK_FOR_INTERRUPTS();
    0.00 :	  5be100:       e8 9b e1 0d 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5be105:       e9 69 fc ff ff          jmpq   5bdd73 <ExecHashJoin+0x2d3>
    0.00 :	  5be10a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                                                         true,          /* outer tuple */
         :	                                                                         HJ_FILL_OUTER(hjstate),
         :	                                                                         hashvalue))
         :	                        {
         :	                                /* remember outer relation is not empty for possible rescan */
         :	                                hjstate->hj_OuterNotEmpty = true;
    0.00 :	  5be110:       41 c6 86 f5 00 00 00    movb   $0x1,0xf5(%r14)
    0.00 :	  5be117:       01 
         :	                                 * We don't have an outer tuple, try to get the next one
         :	                                 */
         :	                                outerTupleSlot = ExecHashJoinOuterGetTuple(outerNode,
         :	                                                                                                                   node,
         :	                                                                                                                   &hashvalue);
         :	                                if (TupIsNull(outerTupleSlot))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:213
    5.88 :	  5be118:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
    0.00 :	  5be11e:       0f 85 74 fb ff ff       jne    5bdc98 <ExecHashJoin+0x1f8>
    0.00 :	  5be124:       e9 cd fb ff ff          jmpq   5bdcf6 <ExecHashJoin+0x256>
    0.00 :	  5be129:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                 * Reset some of the skew optimization state variables, since we no
         :	                 * longer need to consider skew tuples after the first batch. The
         :	                 * memory context reset we are about to do will release the skew
         :	                 * hashtable itself.
         :	                 */
         :	                hashtable->skewEnabled = false;
    0.00 :	  5be130:       41 c6 44 24 21 00       movb   $0x0,0x21(%r12)
         :	                hashtable->skewBucket = NULL;
    0.00 :	  5be136:       49 c7 44 24 28 00 00    movq   $0x0,0x28(%r12)
    0.00 :	  5be13d:       00 00 
         :	                hashtable->skewBucketNums = NULL;
    0.00 :	  5be13f:       49 c7 44 24 38 00 00    movq   $0x0,0x38(%r12)
    0.00 :	  5be146:       00 00 
         :	                hashtable->nSkewBuckets = 0;
    0.00 :	  5be148:       41 c7 44 24 34 00 00    movl   $0x0,0x34(%r12)
    0.00 :	  5be14f:       00 00 
         :	                hashtable->spaceUsedSkew = 0;
    0.00 :	  5be151:       49 c7 84 24 a8 00 00    movq   $0x0,0xa8(%r12)
    0.00 :	  5be158:       00 00 00 00 00 
    0.00 :	  5be15d:       e9 86 fc ff ff          jmpq   5bdde8 <ExecHashJoin+0x348>
    0.00 :	  5be162:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be168:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5be16f:       00 
    0.00 :	  5be170:       0f 84 aa 00 00 00       je     5be220 <ExecHashJoin+0x780>
         :	                                                 (outerNode->plan->startup_cost < hashNode->ps.plan->total_cost &&
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
    0.00 :	  5be176:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  5be17a:       e8 21 e3 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
    0.00 :	  5be17f:       48 85 c0                test   %rax,%rax
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
         :	                                                 (outerNode->plan->startup_cost < hashNode->ps.plan->total_cost &&
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
    0.00 :	  5be182:       49 89 86 e8 00 00 00    mov    %rax,0xe8(%r14)
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
    0.00 :	  5be189:       0f 84 e8 00 00 00       je     5be277 <ExecHashJoin+0x7d7>
    0.00 :	  5be18f:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5be193:       0f 85 de 00 00 00       jne    5be277 <ExecHashJoin+0x7d7>
         :	                                        {
         :	                                                node->hj_OuterNotEmpty = false;
         :	                                                return NULL;
         :	                                        }
         :	                                        else
         :	                                                node->hj_OuterNotEmpty = true;
    0.00 :	  5be199:       41 c6 86 f5 00 00 00    movb   $0x1,0xf5(%r14)
    0.00 :	  5be1a0:       01 
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be1a1:       e9 f3 f9 ff ff          jmpq   5bdb99 <ExecHashJoin+0xf9>
         :	                                        /*
         :	                                         * Need to postpone this outer tuple to a later batch.
         :	                                         * Save it in the corresponding outer-batch file.
         :	                                         */
         :	                                        Assert(batchno > hashtable->curbatch);
         :	                                        ExecHashJoinSaveTuple(ExecFetchSlotMinimalTuple(outerTupleSlot),
    0.00 :	  5be1a6:       48 98                   cltq   
    0.00 :	  5be1a8:       8b 5d d0                mov    -0x30(%rbp),%ebx
    0.00 :	  5be1ab:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be1ae:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  5be1b5:       00 
    0.00 :	  5be1b6:       4c 03 6a 70             add    0x70(%rdx),%r13
    0.00 :	  5be1ba:       e8 91 5d ff ff          callq  5b3f50 <ExecFetchSlotMinimalTuple>
    0.00 :	  5be1bf:       89 de                   mov    %ebx,%esi
    0.00 :	  5be1c1:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5be1c4:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  5be1c7:       e8 94 f3 ff ff          callq  5bd560 <ExecHashJoinSaveTuple>
         :	                                                                                  hashvalue,
         :	                                                                                &hashtable->outerBatchFile[batchno]);
         :	                                        /* Loop around, staying in HJ_NEED_NEW_OUTER state */
         :	                                        continue;
    0.00 :	  5be1cc:       e9 57 f9 ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
         :	         * Rewind outer batch file (if present), so that we can start reading it.
         :	         */
         :	        if (hashtable->outerBatchFile[curbatch] != NULL)
         :	        {
         :	                if (BufFileSeek(hashtable->outerBatchFile[curbatch], 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
    0.00 :	  5be1d1:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5be1d4:       b9 f0 ba 88 00          mov    $0x88baf0,%ecx
    0.00 :	  5be1d9:       ba 55 03 00 00          mov    $0x355,%edx
    0.00 :	  5be1de:       be 58 b9 88 00          mov    $0x88b958,%esi
    0.00 :	  5be1e3:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5be1e8:       e8 d3 c8 1b 00          callq  77aac0 <errstart>
    0.00 :	  5be1ed:       84 c0                   test   %al,%al
    0.00 :	  5be1ef:       0f 84 69 f9 ff ff       je     5bdb5e <ExecHashJoin+0xbe>
    0.00 :	  5be1f5:       bf d0 b9 88 00          mov    $0x88b9d0,%edi
    0.00 :	  5be1fa:       31 c0                   xor    %eax,%eax
    0.00 :	  5be1fc:       e8 9f e6 1b 00          callq  77c8a0 <errmsg>
    0.00 :	  5be201:       89 c3                   mov    %eax,%ebx
    0.00 :	  5be203:       e8 e8 e8 1b 00          callq  77caf0 <errcode_for_file_access>
    0.00 :	  5be208:       89 de                   mov    %ebx,%esi
    0.00 :	  5be20a:       89 c7                   mov    %eax,%edi
    0.00 :	  5be20c:       31 c0                   xor    %eax,%eax
    0.00 :	  5be20e:       e8 cd c3 1b 00          callq  77a5e0 <errfinish>
    0.00 :	  5be213:       e9 46 f9 ff ff          jmpq   5bdb5e <ExecHashJoin+0xbe>
    0.00 :	  5be218:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5be21f:       00 
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be220:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  5be224:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  5be228:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  5be22c:       48 8b 51 08             mov    0x8(%rcx),%rdx
    0.00 :	  5be230:       f2 0f 10 42 10          movsd  0x10(%rdx),%xmm0
    0.00 :	  5be235:       66 0f 2e 40 08          ucomisd 0x8(%rax),%xmm0
    0.00 :	  5be23a:       0f 86 4e f9 ff ff       jbe    5bdb8e <ExecHashJoin+0xee>
    0.00 :	  5be240:       41 80 be f5 00 00 00    cmpb   $0x0,0xf5(%r14)
    0.00 :	  5be247:       00 
    0.00 :	  5be248:       0f 85 40 f9 ff ff       jne    5bdb8e <ExecHashJoin+0xee>
    0.00 :	  5be24e:       e9 23 ff ff ff          jmpq   5be176 <ExecHashJoin+0x6d6>
         :	                                /*
         :	                                 * If the inner relation is completely empty, and we're not
         :	                                 * doing a left outer join, we can quit without scanning the
         :	                                 * outer relation.
         :	                                 */
         :	                                if (hashtable->totalTuples == 0 && !HJ_FILL_OUTER(node))
    0.00 :	  5be253:       0f 8a 8f f9 ff ff       jp     5bdbe8 <ExecHashJoin+0x148>
    0.00 :	  5be259:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5be260:       00 
    0.00 :	  5be261:       0f 85 81 f9 ff ff       jne    5bdbe8 <ExecHashJoin+0x148>
    0.00 :	  5be267:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5be26e:       00 00 
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :	                                break;
         :
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
    0.00 :	  5be270:       31 c0                   xor    %eax,%eax
    0.00 :	  5be272:       e9 21 fd ff ff          jmpq   5bdf98 <ExecHashJoin+0x4f8>
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
         :	                                        {
         :	                                                node->hj_OuterNotEmpty = false;
    0.00 :	  5be277:       41 c6 86 f5 00 00 00    movb   $0x0,0xf5(%r14)
    0.00 :	  5be27e:       00 
    0.00 :	  5be27f:       31 c0                   xor    %eax,%eax
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
         :	                                         (int) node->hj_JoinState);
         :	                }
         :	        }
         :	}
    0.00 :	  5be281:       e9 12 fd ff ff          jmpq   5bdf98 <ExecHashJoin+0x4f8>
         :	        innerFile = hashtable->innerBatchFile[curbatch];
         :
         :	        if (innerFile != NULL)
         :	        {
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
    0.00 :	  5be286:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5be289:       b9 f0 ba 88 00          mov    $0x88baf0,%ecx
    0.00 :	  5be28e:       ba 37 03 00 00          mov    $0x337,%edx
    0.00 :	  5be293:       e9 46 ff ff ff          jmpq   5be1de <ExecHashJoin+0x73e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   17.65 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:881
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:869
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:869
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:885
   11.76 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:885
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:824
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:824
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:848
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:871
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:883
    5.88 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:994
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000784050 <hash_search_with_hash_value>:
         :	hash_search_with_hash_value(HTAB *hashp,
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
    0.00 :	  784050:       55                      push   %rbp
    0.00 :	  784051:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  784054:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:824
    5.88 :	  784056:       41 89 d7                mov    %edx,%r15d
    0.00 :	  784059:       41 56                   push   %r14
    0.00 :	  78405b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  78405e:       41 55                   push   %r13
    5.88 :	  784060:       41 54                   push   %r12
    0.00 :	  784062:       53                      push   %rbx
    0.00 :	  784063:       48 83 ec 68             sub    $0x68,%rsp
    0.00 :	  784067:       89 8d 7c ff ff ff       mov    %ecx,-0x84(%rbp)
    0.00 :	  78406d:       48 89 75 80             mov    %rsi,-0x80(%rbp)
    0.00 :	  784071:       4c 89 85 70 ff ff ff    mov    %r8,-0x90(%rbp)
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784078:       48 8b 07                mov    (%rdi),%rax
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  78407b:       83 f9 03                cmp    $0x3,%ecx
    0.00 :	  78407e:       0f 94 45 8f             sete   -0x71(%rbp)
    0.00 :	  784082:       83 e9 01                sub    $0x1,%ecx
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784085:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  784089:       0f 84 d9 00 00 00       je     784168 <hash_search_with_hash_value+0x118>
    0.00 :	  78408f:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:848
    5.88 :	  784093:       0f 85 cf 00 00 00       jne    784168 <hash_search_with_hash_value+0x118>
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
         :	        *newlink = NULL;
    0.00 :	  784099:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78409c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  7840a0:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7840a4:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  7840a8:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  7840ac:       44 89 fb                mov    %r15d,%ebx
    0.00 :	  7840af:       23 5a 2c                and    0x2c(%rdx),%ebx
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7840b2:       39 f3                   cmp    %esi,%ebx
    0.00 :	  7840b4:       76 03                   jbe    7840b9 <hash_search_with_hash_value+0x69>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7840b6:       23 5a 30                and    0x30(%rdx),%ebx
         :	        bucket = calc_bucket(hctl, hashvalue);
         :
         :	        segment_num = bucket >> hashp->sshift;
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:869
   11.76 :	  7840b9:       89 d8                   mov    %ebx,%eax
   11.76 :	  7840bb:       49 8b 56 08             mov    0x8(%r14),%rdx
    0.00 :	  7840bf:       d3 e8                   shr    %cl,%eax
    0.00 :	  7840c1:       89 c0                   mov    %eax,%eax
    0.00 :	  7840c3:       4c 8b 24 c2             mov    (%rdx,%rax,8),%r12
         :
         :	        if (segp == NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:871
    5.88 :	  7840c7:       4d 85 e4                test   %r12,%r12
    0.00 :	  7840ca:       0f 84 b7 02 00 00       je     784387 <hash_search_with_hash_value+0x337>
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d0:       89 d8                   mov    %ebx,%eax
    0.00 :	  7840d2:       44 21 e8                and    %r13d,%eax
         :	        currBucket = *prevBucketPtr;
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
    0.00 :	  7840d5:       4d 8b 6e 18             mov    0x18(%r14),%r13
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d9:       4d 8d 24 c4             lea    (%r12,%rax,8),%r12
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
    0.00 :	  7840dd:       49 8b 46 48             mov    0x48(%r14),%rax
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
         :	        currBucket = *prevBucketPtr;
    0.00 :	  7840e1:       49 8b 1c 24             mov    (%r12),%rbx
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:881
   17.65 :	  7840e5:       48 89 45 98             mov    %rax,-0x68(%rbp)
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840e9:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840ec:       75 0d                   jne    7840fb <hash_search_with_hash_value+0xab>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:883
    5.88 :	  7840ee:       eb 28                   jmp    784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
         :	                        match(ELEMENTKEY(currBucket), keyPtr, keysize) == 0)
         :	                        break;
         :	                prevBucketPtr = &(currBucket->link);
    0.00 :	  7840f0:       49 89 dc                mov    %rbx,%r12
         :	                currBucket = *prevBucketPtr;
    0.00 :	  7840f3:       48 8b 1b                mov    (%rbx),%rbx
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840f6:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840f9:       74 1d                   je     784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:885
   11.76 :	  7840fb:       44 39 7b 08             cmp    %r15d,0x8(%rbx)
   11.76 :	  7840ff:       90                      nop
    0.00 :	  784100:       75 ee                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784102:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  784106:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  78410a:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78410e:       41 ff d5                callq  *%r13
    0.00 :	  784111:       85 c0                   test   %eax,%eax
    0.00 :	  784113:       75 db                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784115:       0f 1f 00                nopl   (%rax)
         :	                hash_collisions++;
         :	                hctl->collisions++;
         :	#endif
         :	        }
         :
         :	        if (foundPtr)
    0.00 :	  784118:       48 83 bd 70 ff ff ff    cmpq   $0x0,-0x90(%rbp)
    0.00 :	  78411f:       00 
    0.00 :	  784120:       74 0d                   je     78412f <hash_search_with_hash_value+0xdf>
         :	                *foundPtr = (bool) (currBucket != NULL);
    0.00 :	  784122:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  784129:       48 85 db                test   %rbx,%rbx
    0.00 :	  78412c:       0f 95 02                setne  (%rdx)
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  78412f:       83 bd 7c ff ff ff 01    cmpl   $0x1,-0x84(%rbp)
    0.00 :	  784136:       0f 84 5c 01 00 00       je     784298 <hash_search_with_hash_value+0x248>
    0.00 :	  78413c:       0f 83 ee 00 00 00       jae    784230 <hash_search_with_hash_value+0x1e0>
         :	        {
         :	                case HASH_FIND:
         :	                        if (currBucket != NULL)
    0.00 :	  784142:       48 85 db                test   %rbx,%rbx
    0.00 :	  784145:       0f 84 35 02 00 00       je     784380 <hash_search_with_hash_value+0x330>
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
    0.00 :	  78414b:       48 83 c3 10             add    $0x10,%rbx
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  78414f:       48 83 c4 68             add    $0x68,%rsp
    0.00 :	  784153:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784156:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:994
    5.88 :	  784157:       41 5c                   pop    %r12
    0.00 :	  784159:       41 5d                   pop    %r13
    0.00 :	  78415b:       41 5e                   pop    %r14
    0.00 :	  78415d:       41 5f                   pop    %r15
    0.00 :	  78415f:       c9                      leaveq 
    0.00 :	  784160:       c3                      retq   
    0.00 :	  784161:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784168:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78416c:       48 83 7a 48 00          cmpq   $0x0,0x48(%rdx)
    0.00 :	  784171:       0f 85 09 01 00 00       jne    784280 <hash_search_with_hash_value+0x230>
    0.00 :	  784177:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  78417c:       0f 85 e6 01 00 00       jne    784368 <hash_search_with_hash_value+0x318>
    0.00 :	  784182:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784186:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78418a:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78418d:       8d 56 01                lea    0x1(%rsi),%edx
    0.00 :	  784190:       41 89 f0                mov    %esi,%r8d
    0.00 :	  784193:       89 55 d4                mov    %edx,-0x2c(%rbp)
    0.00 :	  784196:       41 89 d4                mov    %edx,%r12d
    0.00 :	  784199:       48 8b 50 08             mov    0x8(%rax),%rdx
    0.00 :	  78419d:       48 89 d0                mov    %rdx,%rax
    0.00 :	  7841a0:       48 c1 fa 3f             sar    $0x3f,%rdx
    0.00 :	  7841a4:       49 f7 fc                idiv   %r12
    0.00 :	  7841a7:       48 3b 43 50             cmp    0x50(%rbx),%rax
    0.00 :	  7841ab:       0f 8c eb fe ff ff       jl     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841b1:       8b 3d 09 5a 43 00       mov    0x435a09(%rip),%edi        # bb9bc0 <num_seq_scans>
    0.00 :	  7841b7:       85 ff                   test   %edi,%edi
    0.00 :	  7841b9:       7e 2c                   jle    7841e7 <hash_search_with_hash_value+0x197>
         :	        {
         :	                if (seq_scan_tables[i] == hashp)
    0.00 :	  7841bb:       31 d2                   xor    %edx,%edx
    0.00 :	  7841bd:       4c 3b 35 1c 5a 43 00    cmp    0x435a1c(%rip),%r14        # bb9be0 <seq_scan_tables>
    0.00 :	  7841c4:       b9 e8 9b bb 00          mov    $0xbb9be8,%ecx
    0.00 :	  7841c9:       75 15                   jne    7841e0 <hash_search_with_hash_value+0x190>
    0.00 :	  7841cb:       e9 cc fe ff ff          jmpq   78409c <hash_search_with_hash_value+0x4c>
    0.00 :	  7841d0:       48 8b 01                mov    (%rcx),%rax
    0.00 :	  7841d3:       48 83 c1 08             add    $0x8,%rcx
    0.00 :	  7841d7:       49 39 c6                cmp    %rax,%r14
    0.00 :	  7841da:       0f 84 bc fe ff ff       je     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841e0:       83 c2 01                add    $0x1,%edx
    0.00 :	  7841e3:       39 fa                   cmp    %edi,%edx
    0.00 :	  7841e5:       7c e9                   jl     7841d0 <hash_search_with_hash_value+0x180>
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841e7:       49 8b 46 50             mov    0x50(%r14),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841eb:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7841ef:       4c 89 e3                mov    %r12,%rbx
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841f2:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  7841f6:       48 8b 45 90             mov    -0x70(%rbp),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841fa:       48 d3 fb                sar    %cl,%rbx
    0.00 :	  7841fd:       48 89 5d c0             mov    %rbx,-0x40(%rbp)
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784201:       48 3b 58 20             cmp    0x20(%rax),%rbx
    0.00 :	  784205:       0f 8c 05 02 00 00       jl     784410 <hash_search_with_hash_value+0x3c0>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
    0.00 :	  78420b:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  78420f:       48 8b 58 18             mov    0x18(%rax),%rbx
    0.00 :	  784213:       48 39 5d c0             cmp    %rbx,-0x40(%rbp)
    0.00 :	  784217:       0f 8c 1d 03 00 00       jl     78453a <hash_search_with_hash_value+0x4ea>
         :	        HASHSEGMENT *old_p;
         :	        long            new_dsize;
         :	        long            old_dirsize;
         :	        long            new_dirsize;
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
    0.00 :	  78421d:       48 83 78 58 ff          cmpq   $0xffffffffffffffff,0x58(%rax)
    0.00 :	  784222:       0f 84 4a 03 00 00       je     784572 <hash_search_with_hash_value+0x522>
         :	                hashp->dir = p;
         :	                hashp->hctl->dsize = new_dsize;
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784228:       44 89 c6                mov    %r8d,%esi
    0.00 :	  78422b:       e9 78 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                *foundPtr = (bool) (currBucket != NULL);
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  784230:       83 bd 7c ff ff ff 02    cmpl   $0x2,-0x84(%rbp)
    0.00 :	  784237:       0f 84 d6 00 00 00       je     784313 <hash_search_with_hash_value+0x2c3>
    0.00 :	  78423d:       83 bd 7c ff ff ff 03    cmpl   $0x3,-0x84(%rbp)
    0.00 :	  784244:       74 52                   je     784298 <hash_search_with_hash_value+0x248>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784246:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  78424b:       be df 03 00 00          mov    $0x3df,%esi
    0.00 :	  784250:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  784255:       e8 c6 71 ff ff          callq  77b420 <elog_start>
    0.00 :	  78425a:       8b 95 7c ff ff ff       mov    -0x84(%rbp),%edx
    0.00 :	  784260:       be f0 5a 8d 00          mov    $0x8d5af0,%esi
    0.00 :	  784265:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78426a:       31 c0                   xor    %eax,%eax
    0.00 :	  78426c:       e8 bf 6f ff ff          callq  77b230 <elog_finish>
    0.00 :	  784271:       e8 5a 52 ce ff          callq  4694d0 <abort@plt>
    0.00 :	  784276:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  78427d:       00 00 00 
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784280:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784284:       8b 72 28                mov    0x28(%rdx),%esi
    0.00 :	  784287:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  78428b:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78428f:       e9 14 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
    0.00 :	  784294:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        Assert(hashp->alloc != DynaHashAlloc);
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
    0.00 :	  784298:       48 85 db                test   %rbx,%rbx
    0.00 :	  78429b:       0f 85 aa fe ff ff       jne    78414b <hash_search_with_hash_value+0xfb>
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
    0.00 :	  7842a1:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  7842a6:       0f 85 a3 03 00 00       jne    78464f <hash_search_with_hash_value+0x5ff>
         :	 */
         :	static HASHBUCKET
         :	get_hash_entry(HTAB *hashp)
         :	{
         :	        /* use volatile pointer to prevent code rearrangement */
         :	        volatile HASHHDR *hctlv = hashp->hctl;
    0.00 :	  7842ac:       49 8b 1e                mov    (%r14),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  7842af:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  7842b5:       eb 35                   jmp    7842ec <hash_search_with_hash_value+0x29c>
    0.00 :	  7842b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7842be:       00 00 
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
         :	                        SpinLockAcquire(&hctlv->mutex);
         :
         :	                /* try to get an entry from the freelist */
         :	                newElement = hctlv->freeList;
    0.00 :	  7842c0:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	                if (newElement != NULL)
    0.00 :	  7842c4:       48 85 d2                test   %rdx,%rdx
    0.00 :	  7842c7:       0f 85 04 02 00 00       jne    7844d1 <hash_search_with_hash_value+0x481>
         :	                        break;
         :
         :	                /* no free elements.  allocate another chunk of buckets */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842cd:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842d1:       48 85 c0                test   %rax,%rax
    0.00 :	  7842d4:       74 03                   je     7842d9 <hash_search_with_hash_value+0x289>
         :	                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  7842d6:       c6 03 00                movb   $0x0,(%rbx)
         :
         :	                if (!element_alloc(hashp, hctlv->nelem_alloc))
    0.00 :	  7842d9:       8b 73 6c                mov    0x6c(%rbx),%esi
    0.00 :	  7842dc:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7842df:       e8 dc fb ff ff          callq  783ec0 <element_alloc>
    0.00 :	  7842e4:       84 c0                   test   %al,%al
    0.00 :	  7842e6:       0f 84 be 00 00 00       je     7843aa <hash_search_with_hash_value+0x35a>
         :	        HASHBUCKET      newElement;
         :
         :	        for (;;)
         :	        {
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842ec:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842f0:       48 85 c0                test   %rax,%rax
    0.00 :	  7842f3:       74 cb                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842f5:       44 89 e8                mov    %r13d,%eax
    0.00 :	  7842f8:       f0 86 03                lock xchg %al,(%rbx)
         :	                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  7842fb:       84 c0                   test   %al,%al
    0.00 :	  7842fd:       74 c1                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842ff:       ba 87 04 00 00          mov    $0x487,%edx
    0.00 :	  784304:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  784309:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78430c:       e8 2f bd f0 ff          callq  690040 <s_lock>
    0.00 :	  784311:       eb ad                   jmp    7842c0 <hash_search_with_hash_value+0x270>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :	                        return NULL;
         :
         :	                case HASH_REMOVE:
         :	                        if (currBucket != NULL)
    0.00 :	  784313:       48 85 db                test   %rbx,%rbx
    0.00 :	  784316:       74 68                   je     784380 <hash_search_with_hash_value+0x330>
         :	                        {
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784318:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78431c:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784320:       48 85 c0                test   %rax,%rax
    0.00 :	  784323:       74 0c                   je     784331 <hash_search_with_hash_value+0x2e1>
    0.00 :	  784325:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  78432a:       f0 86 02                lock xchg %al,(%rdx)
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  78432d:       84 c0                   test   %al,%al
    0.00 :	  78432f:       75 64                   jne    784395 <hash_search_with_hash_value+0x345>
         :
         :	                                Assert(hctlv->nentries > 0);
         :	                                hctlv->nentries--;
    0.00 :	  784331:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784335:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  784339:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78433d:       48 89 42 08             mov    %rax,0x8(%rdx)
         :
         :	                                /* remove record from hash bucket's chain. */
         :	                                *prevBucketPtr = currBucket->link;
    0.00 :	  784341:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  784344:       49 89 04 24             mov    %rax,(%r12)
         :
         :	                                /* add the record to the freelist for this table.  */
         :	                                currBucket->link = hctlv->freeList;
    0.00 :	  784348:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  78434c:       48 89 03                mov    %rax,(%rbx)
         :	                                hctlv->freeList = currBucket;
    0.00 :	  78434f:       48 89 5a 10             mov    %rbx,0x10(%rdx)
         :
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784353:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784357:       48 85 c0                test   %rax,%rax
    0.00 :	  78435a:       0f 84 eb fd ff ff       je     78414b <hash_search_with_hash_value+0xfb>
         :	                                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  784360:       c6 02 00                movb   $0x0,(%rdx)
    0.00 :	  784363:       e9 e3 fd ff ff          jmpq   78414b <hash_search_with_hash_value+0xfb>
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784368:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78436c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784370:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784374:       8b 73 28                mov    0x28(%rbx),%esi
    0.00 :	  784377:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78437b:       e9 28 fd ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784380:       31 db                   xor    %ebx,%ebx
    0.00 :	  784382:       e9 c8 fd ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
    0.00 :	  784387:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  78438a:       e8 01 f8 ff ff          callq  783b90 <hash_corrupted>
    0.00 :	  78438f:       90                      nop
    0.00 :	  784390:       e9 3b fd ff ff          jmpq   7840d0 <hash_search_with_hash_value+0x80>
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  784395:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  784399:       ba 95 03 00 00          mov    $0x395,%edx
    0.00 :	  78439e:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843a3:       e8 98 bc f0 ff          callq  690040 <s_lock>
    0.00 :	  7843a8:       eb 87                   jmp    784331 <hash_search_with_hash_value+0x2e1>
         :
         :	                        currBucket = get_hash_entry(hashp);
         :	                        if (currBucket == NULL)
         :	                        {
         :	                                /* out of memory */
         :	                                if (action == HASH_ENTER_NULL)
    0.00 :	  7843aa:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  7843ae:       75 d0                   jne    784380 <hash_search_with_hash_value+0x330>
         :	                                        return NULL;
         :	                                /* report a generic message */
         :	                                if (hashp->isshared)
    0.00 :	  7843b0:       41 80 7e 40 00          cmpb   $0x0,0x40(%r14)
    0.00 :	  7843b5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7843b8:       0f 84 4a 02 00 00       je     784608 <hash_search_with_hash_value+0x5b8>
         :	                                        ereport(ERROR,
    0.00 :	  7843be:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7843c1:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  7843c6:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  7843cb:       ba c6 03 00 00          mov    $0x3c6,%edx
    0.00 :	  7843d0:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843d5:       e8 e6 66 ff ff          callq  77aac0 <errstart>
    0.00 :	  7843da:       84 c0                   test   %al,%al
    0.00 :	  7843dc:       bf 47 ba 8a 00          mov    $0x8aba47,%edi
    0.00 :	  7843e1:       0f 84 8a fe ff ff       je     784271 <hash_search_with_hash_value+0x221>
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  7843e7:       31 c0                   xor    %eax,%eax
    0.00 :	  7843e9:       e8 b2 84 ff ff          callq  77c8a0 <errmsg>
    0.00 :	  7843ee:       bf c5 20 00 00          mov    $0x20c5,%edi
    0.00 :	  7843f3:       89 c3                   mov    %eax,%ebx
    0.00 :	  7843f5:       e8 56 89 ff ff          callq  77cd50 <errcode>
    0.00 :	  7843fa:       89 de                   mov    %ebx,%esi
    0.00 :	  7843fc:       89 c7                   mov    %eax,%edi
    0.00 :	  7843fe:       31 c0                   xor    %eax,%eax
    0.00 :	  784400:       e8 db 61 ff ff          callq  77a5e0 <errfinish>
    0.00 :	  784405:       e9 67 fe ff ff          jmpq   784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78440a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784410:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  784413:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784417:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  78441b:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  78441f:       4d 89 e1                mov    %r12,%r9
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  784422:       89 43 28                mov    %eax,0x28(%rbx)
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  784425:       8b 43 30                mov    0x30(%rbx),%eax
    0.00 :	  784428:       49 21 c1                and    %rax,%r9
         :
         :	        /*
         :	         * If we crossed a power of 2, readjust masks.
         :	         */
         :	        if ((uint32) new_bucket > hctl->high_mask)
    0.00 :	  78442b:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  78442e:       39 45 d4                cmp    %eax,-0x2c(%rbp)
    0.00 :	  784431:       76 0c                   jbe    78443f <hash_search_with_hash_value+0x3ef>
         :	        {
         :	                hctl->low_mask = hctl->high_mask;
    0.00 :	  784433:       89 43 30                mov    %eax,0x30(%rbx)
         :	                hctl->high_mask = (uint32) new_bucket | hctl->low_mask;
    0.00 :	  784436:       09 45 d4                or     %eax,-0x2c(%rbp)
    0.00 :	  784439:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  78443c:       89 43 2c                mov    %eax,0x2c(%rbx)
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  78443f:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784443:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784447:       4c 89 ca                mov    %r9,%rdx
         :	         * that might not be true!
         :	         */
         :	        old_segnum = old_bucket >> hashp->sshift;
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
    0.00 :	  78444a:       49 8b 76 08             mov    0x8(%r14),%rsi
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78444e:       4d 21 ec                and    %r13,%r12
    0.00 :	  784451:       4a 8d 3c e5 00 00 00    lea    0x0(,%r12,8),%rdi
    0.00 :	  784458:       00 
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  784459:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78445d:       48 d3 fa                sar    %cl,%rdx
    0.00 :	  784460:       4c 21 c8                and    %r9,%rax
    0.00 :	  784463:       4c 8d 04 c5 00 00 00    lea    0x0(,%rax,8),%r8
    0.00 :	  78446a:       00 
    0.00 :	  78446b:       4c 03 04 d6             add    (%rsi,%rdx,8),%r8
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78446f:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  784473:       48 03 3c 16             add    (%rsi,%rdx,1),%rdi
         :
         :	        for (currElement = *oldlink;
    0.00 :	  784477:       49 8b 10                mov    (%r8),%rdx
         :	                 currElement != NULL;
    0.00 :	  78447a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  78447d:       75 17                   jne    784496 <hash_search_with_hash_value+0x446>
    0.00 :	  78447f:       eb 39                   jmp    7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784481:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        *oldlink = currElement;
         :	                        oldlink = &currElement->link;
         :	                }
         :	                else
         :	                {
         :	                        *newlink = currElement;
    0.00 :	  784488:       48 89 17                mov    %rdx,(%rdi)
         :	                        newlink = &currElement->link;
    0.00 :	  78448b:       48 89 d7                mov    %rdx,%rdi
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
    0.00 :	  78448e:       48 85 c9                test   %rcx,%rcx
    0.00 :	  784491:       74 27                   je     7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784493:       48 89 ca                mov    %rcx,%rdx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  784496:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
    0.00 :	  78449a:       48 8b 0a                mov    (%rdx),%rcx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  78449d:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  7844a0:       23 42 08                and    0x8(%rdx),%eax
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7844a3:       3b 43 28                cmp    0x28(%rbx),%eax
    0.00 :	  7844a6:       76 03                   jbe    7844ab <hash_search_with_hash_value+0x45b>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7844a8:       23 43 30                and    0x30(%rbx),%eax
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
         :	                if ((long) calc_bucket(hctl, currElement->hashvalue) == old_bucket)
    0.00 :	  7844ab:       89 c0                   mov    %eax,%eax
    0.00 :	  7844ad:       49 39 c1                cmp    %rax,%r9
    0.00 :	  7844b0:       75 d6                   jne    784488 <hash_search_with_hash_value+0x438>
         :	                {
         :	                        *oldlink = currElement;
    0.00 :	  7844b2:       49 89 10                mov    %rdx,(%r8)
         :	                        oldlink = &currElement->link;
    0.00 :	  7844b5:       49 89 d0                mov    %rdx,%r8
    0.00 :	  7844b8:       eb d4                   jmp    78448e <hash_search_with_hash_value+0x43e>
         :	                        *newlink = currElement;
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
    0.00 :	  7844ba:       49 c7 00 00 00 00 00    movq   $0x0,(%r8)
         :	        *newlink = NULL;
    0.00 :	  7844c1:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7844c8:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  7844cc:       e9 c8 fb ff ff          jmpq   784099 <hash_search_with_hash_value+0x49>
         :	                        return NULL;
         :	                }
         :	        }
         :
         :	        /* remove entry from freelist, bump nentries */
         :	        hctlv->freeList = newElement->link;
    0.00 :	  7844d1:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  7844d4:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	        hctlv->nentries++;
    0.00 :	  7844d8:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7844dc:       48 83 c0 01             add    $0x1,%rax
    0.00 :	  7844e0:       48 89 43 08             mov    %rax,0x8(%rbx)
         :
         :	        if (IS_PARTITIONED(hctlv))
    0.00 :	  7844e4:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7844e8:       48 85 c0                test   %rax,%rax
    0.00 :	  7844eb:       74 03                   je     7844f0 <hash_search_with_hash_value+0x4a0>
         :	                SpinLockRelease(&hctlv->mutex);
    0.00 :	  7844ed:       c6 03 00                movb   $0x0,(%rbx)
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  7844f0:       48 8d 5a 10             lea    0x10(%rdx),%rbx
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
    0.00 :	  7844f4:       49 89 14 24             mov    %rdx,(%r12)
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
    0.00 :	  7844f8:       44 89 7a 08             mov    %r15d,0x8(%rdx)
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
    0.00 :	  7844fc:       48 c7 02 00 00 00 00    movq   $0x0,(%rdx)
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  784503:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  784507:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78450b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78450e:       41 ff 56 20             callq  *0x20(%r14)
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  784512:       e9 38 fc ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  784517:       31 f6                   xor    %esi,%esi
    0.00 :	  784519:       e8 02 4f ce ff          callq  469420 <memset@plt>
         :	                hashp->dir = p;
    0.00 :	  78451e:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  784522:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
         :	                hashp->dir = p;
    0.00 :	  784526:       49 89 46 08             mov    %rax,0x8(%r14)
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  78452a:       49 8b 06                mov    (%r14),%rax
    0.00 :	  78452d:       48 89 50 18             mov    %rdx,0x18(%rax)
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784531:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  784535:       e8 46 46 01 00          callq  798b80 <pfree>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78453a:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  78453e:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  784541:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784545:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
    0.00 :	  784549:       49 03 5e 08             add    0x8(%r14),%rbx
    0.00 :	  78454d:       e8 7e fa ff ff          callq  783fd0 <seg_alloc>
    0.00 :	  784552:       48 85 c0                test   %rax,%rax
    0.00 :	  784555:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  784558:       0f 84 1f 01 00 00       je     78467d <hash_search_with_hash_value+0x62d>
         :	                        return false;
         :	                hctl->nsegs++;
    0.00 :	  78455e:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784562:       8b 42 28                mov    0x28(%rdx),%eax
    0.00 :	  784565:       48 83 42 20 01          addq   $0x1,0x20(%rdx)
    0.00 :	  78456a:       83 c0 01                add    $0x1,%eax
    0.00 :	  78456d:       e9 a9 fe ff ff          jmpq   78441b <hash_search_with_hash_value+0x3cb>
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784572:       48 8d 14 1b             lea    (%rbx,%rbx,1),%rdx
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
    0.00 :	  784576:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784579:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  78457d:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784581:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784585:       49 8b 46 30             mov    0x30(%r14),%rax
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784589:       49 8b 56 08             mov    0x8(%r14),%rdx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78458d:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784591:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784595:       48 89 05 2c 56 43 00    mov    %rax,0x43562c(%rip)        # bb9bc8 <CurrentDynaHashCxt>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78459c:       41 ff 56 28             callq  *0x28(%r14)
         :
         :	        if (p != NULL)
    0.00 :	  7845a0:       48 85 c0                test   %rax,%rax
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  7845a3:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        if (p != NULL)
    0.00 :	  7845a7:       0f 84 89 00 00 00       je     784636 <hash_search_with_hash_value+0x5e6>
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845ad:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845b1:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
    0.00 :	  7845b5:       48 c1 e3 03             shl    $0x3,%rbx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845b9:       48 89 da                mov    %rbx,%rdx
    0.00 :	  7845bc:       e8 2f 56 ce ff          callq  469bf0 <memcpy@plt>
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  7845c1:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845c5:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7845c9:       48 01 df                add    %rbx,%rdi
    0.00 :	  7845cc:       48 29 da                sub    %rbx,%rdx
    0.00 :	  7845cf:       40 f6 c7 07             test   $0x7,%dil
    0.00 :	  7845d3:       0f 85 3e ff ff ff       jne    784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845d9:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	  7845e0:       0f 87 31 ff ff ff       ja     784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845e6:       48 8d 04 17             lea    (%rdi,%rdx,1),%rax
    0.00 :	  7845ea:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  7845ed:       0f 83 2b ff ff ff       jae    78451e <hash_search_with_hash_value+0x4ce>
    0.00 :	  7845f3:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7845fa:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	  7845fe:       48 39 f8                cmp    %rdi,%rax
    0.00 :	  784601:       77 f0                   ja     7845f3 <hash_search_with_hash_value+0x5a3>
    0.00 :	  784603:       e9 16 ff ff ff          jmpq   78451e <hash_search_with_hash_value+0x4ce>
         :	                                if (hashp->isshared)
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  784608:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  78460b:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  784610:       ba ca 03 00 00          mov    $0x3ca,%edx
    0.00 :	  784615:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  78461a:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78461f:       e8 9c 64 ff ff          callq  77aac0 <errstart>
    0.00 :	  784624:       84 c0                   test   %al,%al
    0.00 :	  784626:       0f 84 45 fc ff ff       je     784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78462c:       bf 04 9c 7b 00          mov    $0x7b9c04,%edi
    0.00 :	  784631:       e9 b1 fd ff ff          jmpq   7843e7 <hash_search_with_hash_value+0x397>
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
    0.00 :	  784636:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78463a:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78463e:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784642:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784646:       44 8b 43 28             mov    0x28(%rbx),%r8d
    0.00 :	  78464a:       e9 d9 fb ff ff          jmpq   784228 <hash_search_with_hash_value+0x1d8>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
         :	                                elog(ERROR, "cannot insert into frozen hashtable \"%s\"",
    0.00 :	  78464f:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  784654:       be ba 03 00 00          mov    $0x3ba,%esi
    0.00 :	  784659:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  78465e:       e8 bd 6d ff ff          callq  77b420 <elog_start>
    0.00 :	  784663:       49 8b 56 38             mov    0x38(%r14),%rdx
    0.00 :	  784667:       be c0 5a 8d 00          mov    $0x8d5ac0,%esi
    0.00 :	  78466c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  784671:       31 c0                   xor    %eax,%eax
    0.00 :	  784673:       e8 b8 6b ff ff          callq  77b230 <elog_finish>
    0.00 :	  784678:       e8 53 4e ce ff          callq  4694d0 <abort@plt>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78467d:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784681:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784685:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  784688:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78468c:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784690:       e9 13 fa ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   18.75 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:115
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:93
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:166
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:74
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:83
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:85
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:108
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:115
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:122
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:213
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:157
    6.25 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:157
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c7470 <ExecSubPlan>:
         :	static Datum
         :	ExecSubPlan(SubPlanState *node,
         :	                        ExprContext *econtext,
         :	                        bool *isNull,
         :	                        ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:74
    6.25 :	  5c7470:       55                      push   %rbp
    0.00 :	  5c7471:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c7474:       41 57                   push   %r15
    0.00 :	  5c7476:       49 89 f7                mov    %rsi,%r15
    0.00 :	  5c7479:       41 56                   push   %r14
    0.00 :	  5c747b:       41 55                   push   %r13
    0.00 :	  5c747d:       41 54                   push   %r12
    0.00 :	  5c747f:       53                      push   %rbx
    0.00 :	  5c7480:       48 81 ec 88 00 00 00    sub    $0x88,%rsp
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
         :	        if (isDone)
    0.00 :	  5c7487:       48 85 c9                test   %rcx,%rcx
         :	static Datum
         :	ExecSubPlan(SubPlanState *node,
         :	                        ExprContext *econtext,
         :	                        bool *isNull,
         :	                        ExprDoneCond *isDone)
         :	{
    0.00 :	  5c748a:       48 89 bd 70 ff ff ff    mov    %rdi,-0x90(%rbp)
    0.00 :	  5c7491:       48 89 95 68 ff ff ff    mov    %rdx,-0x98(%rbp)
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
    0.00 :	  5c7498:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
    0.00 :	  5c749c:       c6 02 00                movb   $0x0,(%rdx)
         :	        if (isDone)
    0.00 :	  5c749f:       74 06                   je     5c74a7 <ExecSubPlan+0x37>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5c74a1:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /* Sanity checks */
         :	        if (subplan->subLinkType == CTE_SUBLINK)
    0.00 :	  5c74a7:       8b 50 04                mov    0x4(%rax),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:83
    6.25 :	  5c74aa:       83 fa 07                cmp    $0x7,%edx
    0.00 :	  5c74ad:       0f 84 3c 0a 00 00       je     5c7eef <ExecSubPlan+0xa7f>
         :	                elog(ERROR, "CTE subplans should not be executed via ExecSubPlan");
         :	        if (subplan->setParam != NIL && subplan->subLinkType != MULTIEXPR_SUBLINK)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:85
    6.25 :	  5c74b3:       48 83 78 38 00          cmpq   $0x0,0x38(%rax)
    0.00 :	  5c74b8:       74 09                   je     5c74c3 <ExecSubPlan+0x53>
    0.00 :	  5c74ba:       83 fa 05                cmp    $0x5,%edx
    0.00 :	  5c74bd:       0f 85 56 0a 00 00       jne    5c7f19 <ExecSubPlan+0xaa9>
         :	                elog(ERROR, "cannot set parent params from subquery");
         :
         :	        /* Select appropriate evaluation strategy */
         :	        if (subplan->useHashTable)
    0.00 :	  5c74c3:       80 78 34 00             cmpb   $0x0,0x34(%rax)
    0.00 :	  5c74c7:       0f 85 c3 03 00 00       jne    5c7890 <ExecSubPlan+0x420>
         :	static Datum
         :	ExecScanSubPlan(SubPlanState *node,
         :	                                ExprContext *econtext,
         :	                                bool *isNull)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
    0.00 :	  5c74cd:       48 8b bd 70 ff ff ff    mov    -0x90(%rbp),%rdi
         :	        PlanState  *planstate = node->planstate;
    0.00 :	  5c74d4:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
         :	static Datum
         :	ExecScanSubPlan(SubPlanState *node,
         :	                                ExprContext *econtext,
         :	                                bool *isNull)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
    0.00 :	  5c74db:       48 8b 7f 08             mov    0x8(%rdi),%rdi
    0.00 :	  5c74df:       48 89 7d c0             mov    %rdi,-0x40(%rbp)
         :	        PlanState  *planstate = node->planstate;
    0.00 :	  5c74e3:       48 8b 40 18             mov    0x18(%rax),%rax
    0.00 :	  5c74e7:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :	        SubLinkType subLinkType = subplan->subLinkType;
    0.00 :	  5c74eb:       8b 57 04                mov    0x4(%rdi),%edx
         :	         * cycle.  But in general resjunk tlist items appear after non-resjunk
         :	         * ones, so this should be safe.)  Unlike ExecReScanSetParamPlan, we do
         :	         * *not* set bits in the parent plan node's chgParam, because we don't
         :	         * want to cause a rescan of the parent.
         :	         */
         :	        if (subLinkType == MULTIEXPR_SUBLINK)
    0.00 :	  5c74ee:       83 fa 05                cmp    $0x5,%edx
         :	                                ExprContext *econtext,
         :	                                bool *isNull)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
         :	        PlanState  *planstate = node->planstate;
         :	        SubLinkType subLinkType = subplan->subLinkType;
    0.00 :	  5c74f1:       89 55 b4                mov    %edx,-0x4c(%rbp)
         :	         * cycle.  But in general resjunk tlist items appear after non-resjunk
         :	         * ones, so this should be safe.)  Unlike ExecReScanSetParamPlan, we do
         :	         * *not* set bits in the parent plan node's chgParam, because we don't
         :	         * want to cause a rescan of the parent.
         :	         */
         :	        if (subLinkType == MULTIEXPR_SUBLINK)
    0.00 :	  5c74f4:       0f 84 7b 04 00 00       je     5c7975 <ExecSubPlan+0x505>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5c74fa:       48 8b 05 5f 33 5f 00    mov    0x5f335f(%rip),%rax        # bba860 <CurrentMemoryContext>
         :	         * calculation we have to do is done in the parent econtext, since the
         :	         * Param values don't need to have per-query lifetime.)
         :	         */
         :	        Assert(list_length(subplan->parParam) == list_length(node->args));
         :
         :	        forboth(l, subplan->parParam, pvar, node->args)
    0.00 :	  5c7501:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5c7505:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5c7508:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5c750c:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	  5c7510:       48 89 05 49 33 5f 00    mov    %rax,0x5f3349(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5c7517:       48 8b 42 40             mov    0x40(%rdx),%rax
    0.00 :	  5c751b:       48 85 c0                test   %rax,%rax
    0.00 :	  5c751e:       74 04                   je     5c7524 <ExecSubPlan+0xb4>
    0.00 :	  5c7520:       4c 8b 70 08             mov    0x8(%rax),%r14
    0.00 :	  5c7524:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
    0.00 :	  5c752b:       48 8b 41 30             mov    0x30(%rcx),%rax
    0.00 :	  5c752f:       48 85 c0                test   %rax,%rax
    0.00 :	  5c7532:       74 5a                   je     5c758e <ExecSubPlan+0x11e>
    0.00 :	  5c7534:       4d 85 f6                test   %r14,%r14
    0.00 :	  5c7537:       4c 8b 68 08             mov    0x8(%rax),%r13
    0.00 :	  5c753b:       74 51                   je     5c758e <ExecSubPlan+0x11e>
    0.00 :	  5c753d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5c7540:       4d 85 ed                test   %r13,%r13
    0.00 :	  5c7543:       74 49                   je     5c758e <ExecSubPlan+0x11e>
         :	        {
         :	                int                     paramid = lfirst_int(l);
    0.00 :	  5c7545:       45 8b 26                mov    (%r14),%r12d
         :	                ParamExecData *prm = &(econtext->ecxt_param_exec_vals[paramid]);
         :
         :	                prm->value = ExecEvalExprSwitchContext((ExprState *) lfirst(pvar),
    0.00 :	  5c7548:       49 8b 7d 00             mov    0x0(%r13),%rdi
    0.00 :	  5c754c:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5c754e:       4c 89 fe                mov    %r15,%rsi
         :	        Assert(list_length(subplan->parParam) == list_length(node->args));
         :
         :	        forboth(l, subplan->parParam, pvar, node->args)
         :	        {
         :	                int                     paramid = lfirst_int(l);
         :	                ParamExecData *prm = &(econtext->ecxt_param_exec_vals[paramid]);
    0.00 :	  5c7551:       49 63 dc                movslq %r12d,%rbx
    0.00 :	  5c7554:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  5c7558:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  5c755c:       49 03 5f 30             add    0x30(%r15),%rbx
         :
         :	                prm->value = ExecEvalExprSwitchContext((ExprState *) lfirst(pvar),
    0.00 :	  5c7560:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	  5c7564:       e8 77 59 fe ff          callq  5acee0 <ExecEvalExprSwitchContext>
    0.00 :	  5c7569:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	                                                                                           econtext,
         :	                                                                                           &(prm->isnull),
         :	                                                                                           NULL);
         :	                planstate->chgParam = bms_add_member(planstate->chgParam, paramid);
    0.00 :	  5c756d:       48 8b 5d b8             mov    -0x48(%rbp),%rbx
    0.00 :	  5c7571:       44 89 e6                mov    %r12d,%esi
    0.00 :	  5c7574:       48 8b 7b 50             mov    0x50(%rbx),%rdi
    0.00 :	  5c7578:       e8 83 ba 01 00          callq  5e3000 <bms_add_member>
    0.00 :	  5c757d:       48 89 43 50             mov    %rax,0x50(%rbx)
         :	         * calculation we have to do is done in the parent econtext, since the
         :	         * Param values don't need to have per-query lifetime.)
         :	         */
         :	        Assert(list_length(subplan->parParam) == list_length(node->args));
         :
         :	        forboth(l, subplan->parParam, pvar, node->args)
    0.00 :	  5c7581:       4d 8b 76 08             mov    0x8(%r14),%r14
    0.00 :	  5c7585:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5c7589:       4d 85 f6                test   %r14,%r14
    0.00 :	  5c758c:       75 b2                   jne    5c7540 <ExecSubPlan+0xd0>
         :	        }
         :
         :	        /*
         :	         * Now that we've set up its parameters, we can reset the subplan.
         :	         */
         :	        ExecReScan(planstate);
    0.00 :	  5c758e:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5c7592:       e8 09 0f fe ff          callq  5a84a0 <ExecReScan>
         :	         * For ARRAY_SUBLINK we allow the subplan to produce any number of tuples,
         :	         * and form an array of the first column's values.  Note in particular
         :	         * that we produce a zero-element array if no tuples are produced (this is
         :	         * a change from pre-8.3 behavior of returning NULL).
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
    0.00 :	  5c7597:       31 c0                   xor    %eax,%eax
    0.00 :	  5c7599:       83 7d b4 01             cmpl   $0x1,-0x4c(%rbp)
         :	        *isNull = false;
    0.00 :	  5c759d:       48 8b bd 68 ff ff ff    mov    -0x98(%rbp),%rdi
         :	         * For ARRAY_SUBLINK we allow the subplan to produce any number of tuples,
         :	         * and form an array of the first column's values.  Note in particular
         :	         * that we produce a zero-element array if no tuples are produced (this is
         :	         * a change from pre-8.3 behavior of returning NULL).
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
    0.00 :	  5c75a4:       0f 94 c0                sete   %al
    0.00 :	  5c75a7:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	        *isNull = false;
    0.00 :	  5c75ab:       c6 07 00                movb   $0x0,(%rdi)
         :
         :	        for (slot = ExecProcNode(planstate);
    0.00 :	  5c75ae:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5c75b2:       e8 e9 4e fe ff          callq  5ac4a0 <ExecProcNode>
         :	                 !TupIsNull(slot);
    0.00 :	  5c75b7:       48 85 c0                test   %rax,%rax
         :	         * a change from pre-8.3 behavior of returning NULL).
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
    0.00 :	  5c75ba:       49 89 c6                mov    %rax,%r14
         :	                 !TupIsNull(slot);
    0.00 :	  5c75bd:       0f 84 1d 09 00 00       je     5c7ee0 <ExecSubPlan+0xa70>
    0.00 :	  5c75c3:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c75c7:       0f 85 13 09 00 00       jne    5c7ee0 <ExecSubPlan+0xa70>
         :	                 slot = ExecProcNode(planstate))
         :	        {
         :	                TupleDesc       tdesc = slot->tts_tupleDescriptor;
    0.00 :	  5c75cd:       48 8b 58 10             mov    0x10(%rax),%rbx
         :	                Datum           rowresult;
         :	                bool            rownull;
         :	                int                     col;
         :	                ListCell   *plst;
         :
         :	                if (subLinkType == EXISTS_SUBLINK)
    0.00 :	  5c75d1:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  5c75d4:       85 c0                   test   %eax,%eax
    0.00 :	  5c75d6:       0f 84 67 09 00 00       je     5c7f43 <ExecSubPlan+0xad3>
    0.00 :	  5c75dc:       31 c0                   xor    %eax,%eax
         :	                        found = true;
         :	                        result = BoolGetDatum(true);
         :	                        break;
         :	                }
         :
         :	                if (subLinkType == EXPR_SUBLINK)
    0.00 :	  5c75de:       83 7d b4 04             cmpl   $0x4,-0x4c(%rbp)
         :	                Datum           rowresult;
         :	                bool            rownull;
         :	                int                     col;
         :	                ListCell   *plst;
         :
         :	                if (subLinkType == EXISTS_SUBLINK)
    0.00 :	  5c75e2:       48 c7 45 98 00 00 00    movq   $0x0,-0x68(%rbp)
    0.00 :	  5c75e9:       00 
         :	                        found = true;
         :	                        result = BoolGetDatum(true);
         :	                        break;
         :	                }
         :
         :	                if (subLinkType == EXPR_SUBLINK)
    0.00 :	  5c75ea:       0f 84 d4 00 00 00       je     5c76c4 <ExecSubPlan+0x254>
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
         :	                        /* keep scanning subplan to make sure there's only one tuple */
         :	                        continue;
         :	                }
         :
         :	                if (subLinkType == ARRAY_SUBLINK)
    0.00 :	  5c75f0:       83 7d b4 06             cmpl   $0x6,-0x4c(%rbp)
    0.00 :	  5c75f4:       0f 84 16 02 00 00       je     5c7810 <ExecSubPlan+0x3a0>
         :	                        /* keep scanning subplan to collect all values */
         :	                        continue;
         :	                }
         :
         :	                /* cannot allow multiple input tuples for ROWCOMPARE sublink either */
         :	                if (subLinkType == ROWCOMPARE_SUBLINK && found)
    0.00 :	  5c75fa:       83 7d b4 03             cmpl   $0x3,-0x4c(%rbp)
    0.00 :	  5c75fe:       0f 84 9c 01 00 00       je     5c77a0 <ExecSubPlan+0x330>
         :	                 * For ALL, ANY, and ROWCOMPARE sublinks, load up the Params
         :	                 * representing the columns of the sub-select, and then evaluate the
         :	                 * combining expression.
         :	                 */
         :	                col = 1;
         :	                foreach(plst, subplan->paramIds)
    0.00 :	  5c7604:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5c7608:       48 8b 47 10             mov    0x10(%rdi),%rax
    0.00 :	  5c760c:       48 85 c0                test   %rax,%rax
    0.00 :	  5c760f:       74 40                   je     5c7651 <ExecSubPlan+0x1e1>
    0.00 :	  5c7611:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  5c7615:       4d 85 e4                test   %r12,%r12
    0.00 :	  5c7618:       74 37                   je     5c7651 <ExecSubPlan+0x1e1>
    0.00 :	  5c761a:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	                {
         :	                        int                     paramid = lfirst_int(plst);
         :	                        ParamExecData *prmdata;
         :
         :	                        prmdata = &(econtext->ecxt_param_exec_vals[paramid]);
    0.00 :	  5c7620:       49 63 1c 24             movslq (%r12),%rbx
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col, &(prmdata->isnull));
    0.00 :	  5c7624:       44 89 ee                mov    %r13d,%esi
    0.00 :	  5c7627:       4c 89 f7                mov    %r14,%rdi
         :	                        col++;
    0.00 :	  5c762a:       41 83 c5 01             add    $0x1,%r13d
         :	                foreach(plst, subplan->paramIds)
         :	                {
         :	                        int                     paramid = lfirst_int(plst);
         :	                        ParamExecData *prmdata;
         :
         :	                        prmdata = &(econtext->ecxt_param_exec_vals[paramid]);
    0.00 :	  5c762e:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  5c7632:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  5c7636:       49 03 5f 30             add    0x30(%r15),%rbx
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col, &(prmdata->isnull));
    0.00 :	  5c763a:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	  5c763e:       e8 bd 7d ea ff          callq  46f400 <slot_getattr>
    0.00 :	  5c7643:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	                 * For ALL, ANY, and ROWCOMPARE sublinks, load up the Params
         :	                 * representing the columns of the sub-select, and then evaluate the
         :	                 * combining expression.
         :	                 */
         :	                col = 1;
         :	                foreach(plst, subplan->paramIds)
    0.00 :	  5c7647:       4d 8b 64 24 08          mov    0x8(%r12),%r12
    0.00 :	  5c764c:       4d 85 e4                test   %r12,%r12
    0.00 :	  5c764f:       75 cf                   jne    5c7620 <ExecSubPlan+0x1b0>
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col, &(prmdata->isnull));
         :	                        col++;
         :	                }
         :
         :	                rowresult = ExecEvalExprSwitchContext(node->testexpr, econtext,
    0.00 :	  5c7651:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5c7658:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5c765c:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5c765e:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c7661:       48 8b 78 28             mov    0x28(%rax),%rdi
    0.00 :	  5c7665:       e8 76 58 fe ff          callq  5acee0 <ExecEvalExprSwitchContext>
         :	                                                                                          &rownull, NULL);
         :
         :	                if (subLinkType == ANY_SUBLINK)
    0.00 :	  5c766a:       83 7d b4 02             cmpl   $0x2,-0x4c(%rbp)
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col, &(prmdata->isnull));
         :	                        col++;
         :	                }
         :
         :	                rowresult = ExecEvalExprSwitchContext(node->testexpr, econtext,
    0.00 :	  5c766e:       48 89 c2                mov    %rax,%rdx
         :	                                                                                          &rownull, NULL);
         :
         :	                if (subLinkType == ANY_SUBLINK)
    0.00 :	  5c7671:       0f 84 09 01 00 00       je     5c7780 <ExecSubPlan+0x310>
         :	                                result = BoolGetDatum(true);
         :	                                *isNull = false;
         :	                                break;                  /* needn't look at any more rows */
         :	                        }
         :	                }
         :	                else if (subLinkType == ALL_SUBLINK)
    0.00 :	  5c7677:       83 7d b4 01             cmpl   $0x1,-0x4c(%rbp)
    0.00 :	  5c767b:       0f 84 6f 01 00 00       je     5c77f0 <ExecSubPlan+0x380>
         :	                }
         :	                else
         :	                {
         :	                        /* must be ROWCOMPARE_SUBLINK */
         :	                        result = rowresult;
         :	                        *isNull = rownull;
    0.00 :	  5c7681:       0f b6 45 d7             movzbl -0x29(%rbp),%eax
    0.00 :	  5c7685:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  5c768c:       88 01                   mov    %al,(%rcx)
    0.00 :	  5c768e:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
         :	                 slot = ExecProcNode(planstate))
    0.00 :	  5c7692:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5c7696:       e8 05 4e fe ff          callq  5ac4a0 <ExecProcNode>
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c769b:       48 85 c0                test   %rax,%rax
         :	                 slot = ExecProcNode(planstate))
    0.00 :	  5c769e:       49 89 c6                mov    %rax,%r14
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c76a1:       0f 84 58 03 00 00       je     5c79ff <ExecSubPlan+0x58f>
    0.00 :	  5c76a7:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c76ab:       0f 85 4e 03 00 00       jne    5c79ff <ExecSubPlan+0x58f>
         :	                        found = true;
         :	                        result = BoolGetDatum(true);
         :	                        break;
         :	                }
         :
         :	                if (subLinkType == EXPR_SUBLINK)
    0.00 :	  5c76b1:       83 7d b4 04             cmpl   $0x4,-0x4c(%rbp)
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
         :	                 slot = ExecProcNode(planstate))
         :	        {
         :	                TupleDesc       tdesc = slot->tts_tupleDescriptor;
    0.00 :	  5c76b5:       49 8b 5e 10             mov    0x10(%r14),%rbx
    0.00 :	  5c76b9:       b8 01 00 00 00          mov    $0x1,%eax
         :	                        found = true;
         :	                        result = BoolGetDatum(true);
         :	                        break;
         :	                }
         :
         :	                if (subLinkType == EXPR_SUBLINK)
    0.00 :	  5c76be:       0f 85 2c ff ff ff       jne    5c75f0 <ExecSubPlan+0x180>
         :	                {
         :	                        /* cannot allow multiple input tuples for EXPR sublink */
         :	                        if (found)
    0.00 :	  5c76c4:       84 c0                   test   %al,%al
    0.00 :	  5c76c6:       0f 85 79 07 00 00       jne    5c7e45 <ExecSubPlan+0x9d5>
         :	                         * copied tuple!  Can't use the subplan's instance of the tuple
         :	                         * since it won't still be valid after next ExecProcNode() call.
         :	                         * node->curTuple keeps track of the copied tuple for eventual
         :	                         * freeing.
         :	                         */
         :	                        if (node->curTuple)
    0.00 :	  5c76cc:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5c76d3:       48 8b 78 38             mov    0x38(%rax),%rdi
    0.00 :	  5c76d7:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5c76da:       74 05                   je     5c76e1 <ExecSubPlan+0x271>
         :	                                heap_freetuple(node->curTuple);
    0.00 :	  5c76dc:       e8 df 75 ea ff          callq  46ecc0 <heap_freetuple>
         :	                        node->curTuple = ExecCopySlotTuple(slot);
    0.00 :	  5c76e1:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5c76e4:       e8 c7 c8 fe ff          callq  5b3fb0 <ExecCopySlotTuple>
    0.00 :	  5c76e9:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5c76f0:       48 89 42 38             mov    %rax,0x38(%rdx)
         :
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
    0.00 :	  5c76f4:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  5c76f8:       66 f7 40 12 ff 07       testw  $0x7ff,0x12(%rax)
    0.00 :	  5c76fe:       0f 84 6c 01 00 00       je     5c7870 <ExecSubPlan+0x400>
    0.00 :	  5c7704:       48 8b bd 68 ff ff ff    mov    -0x98(%rbp),%rdi
    0.00 :	  5c770b:       c6 07 00                movb   $0x0,(%rdi)
    0.00 :	  5c770e:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5c7715:       48 8b 78 38             mov    0x38(%rax),%rdi
    0.00 :	  5c7719:       48 8b 4f 10             mov    0x10(%rdi),%rcx
    0.00 :	  5c771d:       f6 41 14 01             testb  $0x1,0x14(%rcx)
    0.00 :	  5c7721:       0f 85 21 01 00 00       jne    5c7848 <ExecSubPlan+0x3d8>
    0.00 :	  5c7727:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  5c772b:       48 8b 00                mov    (%rax),%rax
    0.00 :	  5c772e:       8b 50 54                mov    0x54(%rax),%edx
    0.00 :	  5c7731:       85 d2                   test   %edx,%edx
    0.00 :	  5c7733:       0f 88 0f 02 00 00       js     5c7948 <ExecSubPlan+0x4d8>
    0.00 :	  5c7739:       80 78 5c 00             cmpb   $0x0,0x5c(%rax)
    0.00 :	  5c773d:       0f 84 1b 02 00 00       je     5c795e <ExecSubPlan+0x4ee>
    0.00 :	  5c7743:       0f b7 40 4c             movzwl 0x4c(%rax),%eax
    0.00 :	  5c7747:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  5c774b:       0f 84 96 02 00 00       je     5c79e7 <ExecSubPlan+0x577>
    0.00 :	  5c7751:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  5c7755:       0f 84 bb 06 00 00       je     5c7e16 <ExecSubPlan+0x9a6>
    0.00 :	  5c775b:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  5c775f:       90                      nop
    0.00 :	  5c7760:       0f 84 c7 06 00 00       je     5c7e2d <ExecSubPlan+0x9bd>
    0.00 :	  5c7766:       48 63 c2                movslq %edx,%rax
    0.00 :	  5c7769:       0f b6 51 16             movzbl 0x16(%rcx),%edx
    0.00 :	  5c776d:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5c7771:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  5c7775:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7779:       e9 14 ff ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c777e:       66 90                   xchg   %ax,%ax
         :	                                                                                          &rownull, NULL);
         :
         :	                if (subLinkType == ANY_SUBLINK)
         :	                {
         :	                        /* combine across rows per OR semantics */
         :	                        if (rownull)
    0.00 :	  5c7780:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  5c7784:       0f 84 6e 01 00 00       je     5c78f8 <ExecSubPlan+0x488>
         :	                                *isNull = true;
    0.00 :	  5c778a:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
    0.00 :	  5c7791:       c6 02 01                movb   $0x1,(%rdx)
    0.00 :	  5c7794:       e9 f9 fe ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7799:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        /* keep scanning subplan to collect all values */
         :	                        continue;
         :	                }
         :
         :	                /* cannot allow multiple input tuples for ROWCOMPARE sublink either */
         :	                if (subLinkType == ROWCOMPARE_SUBLINK && found)
    0.00 :	  5c77a0:       84 c0                   test   %al,%al
    0.00 :	  5c77a2:       0f 84 5c fe ff ff       je     5c7604 <ExecSubPlan+0x194>
         :	                        ereport(ERROR,
    0.00 :	  5c77a8:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5c77ab:       b9 a0 c6 88 00          mov    $0x88c6a0,%ecx
    0.00 :	  5c77b0:       ba 7b 01 00 00          mov    $0x17b,%edx
    0.00 :	  5c77b5:       be 01 c4 88 00          mov    $0x88c401,%esi
    0.00 :	  5c77ba:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5c77bf:       e8 fc 32 1b 00          callq  77aac0 <errstart>
    0.00 :	  5c77c4:       84 c0                   test   %al,%al
    0.00 :	  5c77c6:       74 23                   je     5c77eb <ExecSubPlan+0x37b>
    0.00 :	  5c77c8:       bf c8 c4 88 00          mov    $0x88c4c8,%edi
    0.00 :	  5c77cd:       31 c0                   xor    %eax,%eax
    0.00 :	  5c77cf:       e8 cc 50 1b 00          callq  77c8a0 <errmsg>
    0.00 :	  5c77d4:       bf 42 00 00 00          mov    $0x42,%edi
    0.00 :	  5c77d9:       89 c3                   mov    %eax,%ebx
    0.00 :	  5c77db:       e8 70 55 1b 00          callq  77cd50 <errcode>
    0.00 :	  5c77e0:       89 de                   mov    %ebx,%esi
    0.00 :	  5c77e2:       89 c7                   mov    %eax,%edi
    0.00 :	  5c77e4:       31 c0                   xor    %eax,%eax
    0.00 :	  5c77e6:       e8 f5 2d 1b 00          callq  77a5e0 <errfinish>
    0.00 :	  5c77eb:       e8 e0 1c ea ff          callq  4694d0 <abort@plt>
         :	                        }
         :	                }
         :	                else if (subLinkType == ALL_SUBLINK)
         :	                {
         :	                        /* combine across rows per AND semantics */
         :	                        if (rownull)
    0.00 :	  5c77f0:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  5c77f4:       0f 84 2e 01 00 00       je     5c7928 <ExecSubPlan+0x4b8>
         :	                                *isNull = true;
    0.00 :	  5c77fa:       48 8b 9d 68 ff ff ff    mov    -0x98(%rbp),%rbx
    0.00 :	  5c7801:       c6 03 01                movb   $0x1,(%rbx)
    0.00 :	  5c7804:       e9 89 fe ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7809:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        bool            disnull;
         :
         :	                        found = true;
         :	                        /* stash away current value */
         :	                        Assert(subplan->firstColType == tdesc->attrs[0]->atttypid);
         :	                        dvalue = slot_getattr(slot, 1, &disnull);
    0.00 :	  5c7810:       48 8d 55 d6             lea    -0x2a(%rbp),%rdx
    0.00 :	  5c7814:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5c7819:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5c781c:       e8 df 7b ea ff          callq  46f400 <slot_getattr>
         :	                        astate = accumArrayResult(astate, dvalue, disnull,
    0.00 :	  5c7821:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  5c7825:       0f be 55 d6             movsbl -0x2a(%rbp),%edx
         :	                        bool            disnull;
         :
         :	                        found = true;
         :	                        /* stash away current value */
         :	                        Assert(subplan->firstColType == tdesc->attrs[0]->atttypid);
         :	                        dvalue = slot_getattr(slot, 1, &disnull);
    0.00 :	  5c7829:       48 89 c6                mov    %rax,%rsi
         :	                        astate = accumArrayResult(astate, dvalue, disnull,
    0.00 :	  5c782c:       4c 8b 45 a8             mov    -0x58(%rbp),%r8
    0.00 :	  5c7830:       48 8b 7d 98             mov    -0x68(%rbp),%rdi
    0.00 :	  5c7834:       8b 4b 28                mov    0x28(%rbx),%ecx
    0.00 :	  5c7837:       e8 54 48 0f 00          callq  6bc090 <accumArrayResult>
    0.00 :	  5c783c:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	  5c7840:       e9 4d fe ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7845:       0f 1f 00                nopl   (%rax)
         :	                         */
         :	                        if (node->curTuple)
         :	                                heap_freetuple(node->curTuple);
         :	                        node->curTuple = ExecCopySlotTuple(slot);
         :
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
    0.00 :	  5c7848:       f6 41 17 01             testb  $0x1,0x17(%rcx)
    0.00 :	  5c784c:       0f 85 f6 00 00 00       jne    5c7948 <ExecSubPlan+0x4d8>
    0.00 :	  5c7852:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
    0.00 :	  5c7859:       c6 02 01                movb   $0x1,(%rdx)
    0.00 :	  5c785c:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7863:       00 
    0.00 :	  5c7864:       e9 29 fe ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7869:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5c7870:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  5c7877:       c6 01 01                movb   $0x1,(%rcx)
    0.00 :	  5c787a:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7881:       00 
    0.00 :	  5c7882:       e9 0b fe ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7887:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5c788e:       00 00 
         :	static Datum
         :	ExecHashSubPlan(SubPlanState *node,
         :	                                ExprContext *econtext,
         :	                                bool *isNull)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
    0.00 :	  5c7890:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
         :	        PlanState  *planstate = node->planstate;
    0.00 :	  5c7897:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
         :	static Datum
         :	ExecHashSubPlan(SubPlanState *node,
         :	                                ExprContext *econtext,
         :	                                bool *isNull)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
    0.00 :	  5c789e:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	  5c78a2:       48 89 45 80             mov    %rax,-0x80(%rbp)
         :	        PlanState  *planstate = node->planstate;
    0.00 :	  5c78a6:       48 8b 52 18             mov    0x18(%rdx),%rdx
    0.00 :	  5c78aa:       48 89 95 78 ff ff ff    mov    %rdx,-0x88(%rbp)
         :	        TupleTableSlot *slot;
         :
         :	        /* Shouldn't have any direct correlation Vars */
         :	        if (subplan->parParam != NIL || node->args != NIL)
    0.00 :	  5c78b1:       48 83 78 40 00          cmpq   $0x0,0x40(%rax)
    0.00 :	  5c78b6:       75 12                   jne    5c78ca <ExecSubPlan+0x45a>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:108
    6.25 :	  5c78b8:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
    0.00 :	  5c78bf:       48 83 79 30 00          cmpq   $0x0,0x30(%rcx)
    0.00 :	  5c78c4:       0f 84 8e 01 00 00       je     5c7a58 <ExecSubPlan+0x5e8>
         :	                elog(ERROR, "hashed subplan with direct correlation not supported");
    0.00 :	  5c78ca:       ba 90 c6 88 00          mov    $0x88c690,%edx
    0.00 :	  5c78cf:       be 6d 00 00 00          mov    $0x6d,%esi
    0.00 :	  5c78d4:       bf 01 c4 88 00          mov    $0x88c401,%edi
    0.00 :	  5c78d9:       e8 42 3b 1b 00          callq  77b420 <elog_start>
    0.00 :	  5c78de:       be 90 c4 88 00          mov    $0x88c490,%esi
    0.00 :	  5c78e3:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5c78e8:       31 c0                   xor    %eax,%eax
    0.00 :	  5c78ea:       e8 41 39 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5c78ef:       e8 dc 1b ea ff          callq  4694d0 <abort@plt>
    0.00 :	  5c78f4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                if (subLinkType == ANY_SUBLINK)
         :	                {
         :	                        /* combine across rows per OR semantics */
         :	                        if (rownull)
         :	                                *isNull = true;
         :	                        else if (DatumGetBool(rowresult))
    0.00 :	  5c78f8:       84 c0                   test   %al,%al
    0.00 :	  5c78fa:       0f 84 92 fd ff ff       je     5c7692 <ExecSubPlan+0x222>
         :	                        {
         :	                                result = BoolGetDatum(true);
         :	                                *isNull = false;
    0.00 :	  5c7900:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  5c7907:       c6 01 00                movb   $0x0,(%rcx)
    0.00 :	  5c790a:       48 c7 45 a0 01 00 00    movq   $0x1,-0x60(%rbp)
    0.00 :	  5c7911:       00 
    0.00 :	  5c7912:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5c7916:       48 89 15 43 2f 5f 00    mov    %rdx,0x5f2f43(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5c791d:       e9 af 00 00 00          jmpq   5c79d1 <ExecSubPlan+0x561>
    0.00 :	  5c7922:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else if (subLinkType == ALL_SUBLINK)
         :	                {
         :	                        /* combine across rows per AND semantics */
         :	                        if (rownull)
         :	                                *isNull = true;
         :	                        else if (!DatumGetBool(rowresult))
    0.00 :	  5c7928:       84 c0                   test   %al,%al
    0.00 :	  5c792a:       0f 85 62 fd ff ff       jne    5c7692 <ExecSubPlan+0x222>
         :	                        {
         :	                                result = BoolGetDatum(false);
         :	                                *isNull = false;
    0.00 :	  5c7930:       48 8b bd 68 ff ff ff    mov    -0x98(%rbp),%rdi
    0.00 :	  5c7937:       c6 07 00                movb   $0x0,(%rdi)
    0.00 :	  5c793a:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7941:       00 
    0.00 :	  5c7942:       eb ce                   jmp    5c7912 <ExecSubPlan+0x4a2>
    0.00 :	  5c7944:       0f 1f 40 00             nopl   0x0(%rax)
         :	                         */
         :	                        if (node->curTuple)
         :	                                heap_freetuple(node->curTuple);
         :	                        node->curTuple = ExecCopySlotTuple(slot);
         :
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
    0.00 :	  5c7948:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5c794b:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5c7950:       e8 3b 80 ea ff          callq  46f990 <nocachegetattr>
    0.00 :	  5c7955:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7959:       e9 34 fd ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c795e:       48 63 c2                movslq %edx,%rax
    0.00 :	  5c7961:       0f b6 51 16             movzbl 0x16(%rcx),%edx
    0.00 :	  5c7965:       48 01 d0                add    %rdx,%rax
    0.00 :	  5c7968:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5c796c:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7970:       e9 1d fd ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
         :	         * *not* set bits in the parent plan node's chgParam, because we don't
         :	         * want to cause a rescan of the parent.
         :	         */
         :	        if (subLinkType == MULTIEXPR_SUBLINK)
         :	        {
         :	                EState     *estate = node->parent->state;
    0.00 :	  5c7975:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
    0.00 :	  5c797c:       48 8b 41 20             mov    0x20(%rcx),%rax
    0.00 :	  5c7980:       48 8b 70 10             mov    0x10(%rax),%rsi
         :
         :	                foreach(l, subplan->setParam)
    0.00 :	  5c7984:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  5c7988:       48 85 c0                test   %rax,%rax
    0.00 :	  5c798b:       74 32                   je     5c79bf <ExecSubPlan+0x54f>
    0.00 :	  5c798d:       48 8b 48 08             mov    0x8(%rax),%rcx
    0.00 :	  5c7991:       48 85 c9                test   %rcx,%rcx
    0.00 :	  5c7994:       74 29                   je     5c79bf <ExecSubPlan+0x54f>
    0.00 :	  5c7996:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5c799d:       00 00 00 
         :	                {
         :	                        int                     paramid = lfirst_int(l);
         :	                        ParamExecData *prm = &(estate->es_param_exec_vals[paramid]);
         :
         :	                        prm->execPlan = node;
    0.00 :	  5c79a0:       48 63 01                movslq (%rcx),%rax
    0.00 :	  5c79a3:       48 8b 56 78             mov    0x78(%rsi),%rdx
    0.00 :	  5c79a7:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c79ae:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  5c79b2:       48 89 1c c2             mov    %rbx,(%rdx,%rax,8)
         :	         */
         :	        if (subLinkType == MULTIEXPR_SUBLINK)
         :	        {
         :	                EState     *estate = node->parent->state;
         :
         :	                foreach(l, subplan->setParam)
    0.00 :	  5c79b6:       48 8b 49 08             mov    0x8(%rcx),%rcx
    0.00 :	  5c79ba:       48 85 c9                test   %rcx,%rcx
    0.00 :	  5c79bd:       75 e1                   jne    5c79a0 <ExecSubPlan+0x530>
         :	                        int                     paramid = lfirst_int(l);
         :	                        ParamExecData *prm = &(estate->es_param_exec_vals[paramid]);
         :
         :	                        prm->execPlan = node;
         :	                }
         :	                *isNull = true;
    0.00 :	  5c79bf:       48 8b bd 68 ff ff ff    mov    -0x98(%rbp),%rdi
    0.00 :	  5c79c6:       c6 07 01                movb   $0x1,(%rdi)
    0.00 :	  5c79c9:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c79d0:       00 
         :	        /* Select appropriate evaluation strategy */
         :	        if (subplan->useHashTable)
         :	                return ExecHashSubPlan(node, econtext, isNull);
         :	        else
         :	                return ExecScanSubPlan(node, econtext, isNull);
         :	}
    0.00 :	  5c79d1:       48 8b 45 a0             mov    -0x60(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:93
   12.50 :	  5c79d5:       48 81 c4 88 00 00 00    add    $0x88,%rsp
    0.00 :	  5c79dc:       5b                      pop    %rbx
    0.00 :	  5c79dd:       41 5c                   pop    %r12
    0.00 :	  5c79df:       41 5d                   pop    %r13
    0.00 :	  5c79e1:       41 5e                   pop    %r14
    0.00 :	  5c79e3:       41 5f                   pop    %r15
    0.00 :	  5c79e5:       c9                      leaveq 
    0.00 :	  5c79e6:       c3                      retq   
         :	                         */
         :	                        if (node->curTuple)
         :	                                heap_freetuple(node->curTuple);
         :	                        node->curTuple = ExecCopySlotTuple(slot);
         :
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
    0.00 :	  5c79e7:       48 63 c2                movslq %edx,%rax
    0.00 :	  5c79ea:       0f b6 51 16             movzbl 0x16(%rcx),%edx
    0.00 :	  5c79ee:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5c79f2:       48 8b 04 10             mov    (%rax,%rdx,1),%rax
    0.00 :	  5c79f6:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c79fa:       e9 93 fc ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c79ff:       b8 01 00 00 00          mov    $0x1,%eax
         :	                }
         :	        }
         :
         :	        MemoryContextSwitchTo(oldcontext);
         :
         :	        if (subLinkType == ARRAY_SUBLINK)
    0.00 :	  5c7a04:       83 7d b4 06             cmpl   $0x6,-0x4c(%rbp)
    0.00 :	  5c7a08:       48 8b 5d a8             mov    -0x58(%rbp),%rbx
    0.00 :	  5c7a0c:       48 89 1d 4d 2e 5f 00    mov    %rbx,0x5f2e4d(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5c7a13:       75 1d                   jne    5c7a32 <ExecSubPlan+0x5c2>
         :	        {
         :	                /* We return the result in the caller's context */
         :	                if (astate != NULL)
    0.00 :	  5c7a15:       48 83 7d 98 00          cmpq   $0x0,-0x68(%rbp)
    0.00 :	  5c7a1a:       0f 84 37 04 00 00       je     5c7e57 <ExecSubPlan+0x9e7>
         :	                        result = makeArrayResult(astate, oldcontext);
    0.00 :	  5c7a20:       48 8b 7d 98             mov    -0x68(%rbp),%rdi
    0.00 :	  5c7a24:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5c7a27:       e8 24 46 0f 00          callq  6bc050 <makeArrayResult>
    0.00 :	  5c7a2c:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7a30:       eb 9f                   jmp    5c79d1 <ExecSubPlan+0x561>
         :	                else
         :	                        result = PointerGetDatum(construct_empty_array(subplan->firstColType));
         :	        }
         :	        else if (!found)
    0.00 :	  5c7a32:       84 c0                   test   %al,%al
    0.00 :	  5c7a34:       75 9b                   jne    5c79d1 <ExecSubPlan+0x561>
         :	                /*
         :	                 * deal with empty subplan result.  result/isNull were previously
         :	                 * initialized correctly for all sublink types except EXPR and
         :	                 * ROWCOMPARE; for those, return NULL.
         :	                 */
         :	                if (subLinkType == EXPR_SUBLINK ||
    0.00 :	  5c7a36:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  5c7a39:       83 e8 03                sub    $0x3,%eax
    0.00 :	  5c7a3c:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  5c7a3f:       77 90                   ja     5c79d1 <ExecSubPlan+0x561>
         :	                        subLinkType == ROWCOMPARE_SUBLINK)
         :	                {
         :	                        result = (Datum) 0;
         :	                        *isNull = true;
    0.00 :	  5c7a41:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
    0.00 :	  5c7a48:       c6 02 01                movb   $0x1,(%rdx)
    0.00 :	  5c7a4b:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7a52:       00 
    0.00 :	  5c7a53:       e9 79 ff ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
         :
         :	        /*
         :	         * If first time through or we need to rescan the subplan, build the hash
         :	         * table.
         :	         */
         :	        if (node->hashtable == NULL || planstate->chgParam != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:115
    6.25 :	  5c7a58:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7a5f:       48 83 7b 58 00          cmpq   $0x0,0x58(%rbx)
    0.00 :	  5c7a64:       74 12                   je     5c7a78 <ExecSubPlan+0x608>
    0.00 :	  5c7a66:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
    0.00 :	  5c7a6d:       48 83 7f 50 00          cmpq   $0x0,0x50(%rdi)
   18.75 :	  5c7a72:       0f 84 3b 02 00 00       je     5c7cb3 <ExecSubPlan+0x843>
         :	static void
         :	buildSubPlanHash(SubPlanState *node, ExprContext *econtext)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
         :	        PlanState  *planstate = node->planstate;
         :	        int                     ncols = list_length(subplan->paramIds);
    0.00 :	  5c7a78:       48 8b 55 80             mov    -0x80(%rbp),%rdx
         :	}
         :
         :	STATIC_IF_INLINE int
         :	list_length(const List *l)
         :	{
         :	        return l ? l->length : 0;
    0.00 :	  5c7a7c:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  5c7a7f:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  5c7a83:       48 85 c0                test   %rax,%rax
    0.00 :	  5c7a86:       74 04                   je     5c7a8c <ExecSubPlan+0x61c>
    0.00 :	  5c7a88:       44 8b 60 04             mov    0x4(%rax),%r12d
         :	        ExprContext *innerecontext = node->innerecontext;
    0.00 :	  5c7a8c:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
         :	         * searches; see findPartialMatch.)
         :	         *
         :	         * If it's not necessary to distinguish FALSE and UNKNOWN, then we don't
         :	         * need to store subplan output rows that contain NULL.
         :	         */
         :	        MemoryContextReset(node->hashtablecxt);
    0.00 :	  5c7a93:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
         :	buildSubPlanHash(SubPlanState *node, ExprContext *econtext)
         :	{
         :	        SubPlan    *subplan = (SubPlan *) node->xprstate.expr;
         :	        PlanState  *planstate = node->planstate;
         :	        int                     ncols = list_length(subplan->paramIds);
         :	        ExprContext *innerecontext = node->innerecontext;
    0.00 :	  5c7a9a:       48 8b 89 80 00 00 00    mov    0x80(%rcx),%rcx
    0.00 :	  5c7aa1:       48 89 4d 90             mov    %rcx,-0x70(%rbp)
         :	         * searches; see findPartialMatch.)
         :	         *
         :	         * If it's not necessary to distinguish FALSE and UNKNOWN, then we don't
         :	         * need to store subplan output rows that contain NULL.
         :	         */
         :	        MemoryContextReset(node->hashtablecxt);
    0.00 :	  5c7aa5:       48 8b 7b 70             mov    0x70(%rbx),%rdi
    0.00 :	  5c7aa9:       e8 02 0f 1d 00          callq  7989b0 <MemoryContextReset>
         :	        node->hashtable = NULL;
    0.00 :	  5c7aae:       48 c7 43 58 00 00 00    movq   $0x0,0x58(%rbx)
    0.00 :	  5c7ab5:       00 
         :	        node->hashnulls = NULL;
    0.00 :	  5c7ab6:       48 c7 43 60 00 00 00    movq   $0x0,0x60(%rbx)
    0.00 :	  5c7abd:       00 
         :	        node->havehashrows = false;
    0.00 :	  5c7abe:       c6 43 68 00             movb   $0x0,0x68(%rbx)
         :	        node->havenullrows = false;
    0.00 :	  5c7ac2:       c6 43 69 00             movb   $0x0,0x69(%rbx)
         :
         :	        nbuckets = (long) Min(planstate->plan->plan_rows, (double) LONG_MAX);
    0.00 :	  5c7ac6:       48 bb ff ff ff ff ff    movabs $0x7fffffffffffffff,%rbx
    0.00 :	  5c7acd:       ff ff 7f 
    0.00 :	  5c7ad0:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
    0.00 :	  5c7ad7:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5c7adb:       f2 0f 10 40 18          movsd  0x18(%rax),%xmm0
    0.00 :	  5c7ae0:       66 0f 2e 05 40 a5 1e    ucomisd 0x1ea540(%rip),%xmm0        # 7b2028 <__func__.15386+0x18>
    0.00 :	  5c7ae7:       00 
    0.00 :	  5c7ae8:       73 13                   jae    5c7afd <ExecSubPlan+0x68d>
    0.00 :	  5c7aea:       7a 11                   jp     5c7afd <ExecSubPlan+0x68d>
    0.00 :	  5c7aec:       f2 48 0f 2c d8          cvttsd2si %xmm0,%rbx
         :	        if (nbuckets < 1)
    0.00 :	  5c7af1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5c7af6:       48 85 db                test   %rbx,%rbx
    0.00 :	  5c7af9:       48 0f 4e d8             cmovle %rax,%rbx
         :	                nbuckets = 1;
         :
         :	        node->hashtable = BuildTupleHashTable(ncols,
    0.00 :	  5c7afd:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5c7b04:       41 b9 08 00 00 00       mov    $0x8,%r9d
    0.00 :	  5c7b0a:       49 89 d8                mov    %rbx,%r8
    0.00 :	  5c7b0d:       48 8b 88 90 00 00 00    mov    0x90(%rax),%rcx
    0.00 :	  5c7b14:       48 8b 90 98 00 00 00    mov    0x98(%rax),%rdx
    0.00 :	  5c7b1b:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5c7b1e:       48 8b b0 88 00 00 00    mov    0x88(%rax),%rsi
    0.00 :	  5c7b25:       48 8b 40 78             mov    0x78(%rax),%rax
    0.00 :	  5c7b29:       48 89 44 24 08          mov    %rax,0x8(%rsp)
    0.00 :	  5c7b2e:       48 8b 47 70             mov    0x70(%rdi),%rax
    0.00 :	  5c7b32:       44 89 e7                mov    %r12d,%edi
    0.00 :	  5c7b35:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  5c7b39:       e8 a2 14 fe ff          callq  5a8fe0 <BuildTupleHashTable>
    0.00 :	  5c7b3e:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5c7b45:       48 89 42 58             mov    %rax,0x58(%rdx)
         :	                                                                                  nbuckets,
         :	                                                                                  sizeof(TupleHashEntryData),
         :	                                                                                  node->hashtablecxt,
         :	                                                                                  node->hashtempcxt);
         :
         :	        if (!subplan->unknownEqFalse)
    0.00 :	  5c7b49:       48 8b 4d 80             mov    -0x80(%rbp),%rcx
    0.00 :	  5c7b4d:       80 79 35 00             cmpb   $0x0,0x35(%rcx)
    0.00 :	  5c7b51:       0f 84 61 02 00 00       je     5c7db8 <ExecSubPlan+0x948>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5c7b57:       48 8b 3d 02 2d 5f 00    mov    0x5f2d02(%rip),%rdi        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5c7b5e:       49 8b 47 20             mov    0x20(%r15),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5c7b62:       48 89 7d 88             mov    %rdi,-0x78(%rbp)
         :	        oldcontext = MemoryContextSwitchTo(econtext->ecxt_per_query_memory);
         :
         :	        /*
         :	         * Reset subplan to start.
         :	         */
         :	        ExecReScan(planstate);
    0.00 :	  5c7b66:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5c7b6d:       48 89 05 ec 2c 5f 00    mov    %rax,0x5f2cec(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5c7b74:       e8 27 09 fe ff          callq  5a84a0 <ExecReScan>
    0.00 :	  5c7b79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * Scan the subplan and load the hash table(s).  Note that when there are
         :	         * duplicate rows coming out of the sub-select, only one copy is stored.
         :	         */
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
         :	                 slot = ExecProcNode(planstate))
    0.00 :	  5c7b80:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
    0.00 :	  5c7b87:       e8 14 49 fe ff          callq  5ac4a0 <ExecProcNode>
         :	        /*
         :	         * Scan the subplan and load the hash table(s).  Note that when there are
         :	         * duplicate rows coming out of the sub-select, only one copy is stored.
         :	         */
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c7b8c:       48 85 c0                test   %rax,%rax
         :	                 slot = ExecProcNode(planstate))
    0.00 :	  5c7b8f:       49 89 c6                mov    %rax,%r14
         :	        /*
         :	         * Scan the subplan and load the hash table(s).  Note that when there are
         :	         * duplicate rows coming out of the sub-select, only one copy is stored.
         :	         */
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c7b92:       0f 84 fc 00 00 00       je     5c7c94 <ExecSubPlan+0x824>
    0.00 :	  5c7b98:       41 80 7e 04 00          cmpb   $0x0,0x4(%r14)
    0.00 :	  5c7b9d:       0f 85 f1 00 00 00       jne    5c7c94 <ExecSubPlan+0x824>
         :
         :	                /*
         :	                 * Load up the Params representing the raw sub-select outputs, then
         :	                 * form the projection tuple to store in the hashtable.
         :	                 */
         :	                foreach(plst, subplan->paramIds)
    0.00 :	  5c7ba3:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  5c7ba7:       48 8b 42 10             mov    0x10(%rdx),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5c7bab:       48 85 c0                test   %rax,%rax
    0.00 :	  5c7bae:       74 45                   je     5c7bf5 <ExecSubPlan+0x785>
    0.00 :	  5c7bb0:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  5c7bb4:       4d 85 e4                test   %r12,%r12
    0.00 :	  5c7bb7:       74 3c                   je     5c7bf5 <ExecSubPlan+0x785>
    0.00 :	  5c7bb9:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  5c7bbf:       90                      nop
         :	                {
         :	                        int                     paramid = lfirst_int(plst);
         :	                        ParamExecData *prmdata;
         :
         :	                        prmdata = &(innerecontext->ecxt_param_exec_vals[paramid]);
    0.00 :	  5c7bc0:       49 63 1c 24             movslq (%r12),%rbx
    0.00 :	  5c7bc4:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col,
    0.00 :	  5c7bc8:       44 89 ee                mov    %r13d,%esi
    0.00 :	  5c7bcb:       4c 89 f7                mov    %r14,%rdi
         :	                                                                                  &(prmdata->isnull));
         :	                        col++;
    0.00 :	  5c7bce:       41 83 c5 01             add    $0x1,%r13d
         :	                foreach(plst, subplan->paramIds)
         :	                {
         :	                        int                     paramid = lfirst_int(plst);
         :	                        ParamExecData *prmdata;
         :
         :	                        prmdata = &(innerecontext->ecxt_param_exec_vals[paramid]);
    0.00 :	  5c7bd2:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  5c7bd6:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  5c7bda:       48 03 59 30             add    0x30(%rcx),%rbx
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col,
    0.00 :	  5c7bde:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	  5c7be2:       e8 19 78 ea ff          callq  46f400 <slot_getattr>
    0.00 :	  5c7be7:       48 89 43 08             mov    %rax,0x8(%rbx)
         :
         :	                /*
         :	                 * Load up the Params representing the raw sub-select outputs, then
         :	                 * form the projection tuple to store in the hashtable.
         :	                 */
         :	                foreach(plst, subplan->paramIds)
    0.00 :	  5c7beb:       4d 8b 64 24 08          mov    0x8(%r12),%r12
    0.00 :	  5c7bf0:       4d 85 e4                test   %r12,%r12
    0.00 :	  5c7bf3:       75 cb                   jne    5c7bc0 <ExecSubPlan+0x750>
         :	                        Assert(prmdata->execPlan == NULL);
         :	                        prmdata->value = slot_getattr(slot, col,
         :	                                                                                  &(prmdata->isnull));
         :	                        col++;
         :	                }
         :	                slot = ExecProject(node->projRight, NULL);
    0.00 :	  5c7bf5:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7bfc:       31 f6                   xor    %esi,%esi
    0.00 :	  5c7bfe:       48 8b 7b 50             mov    0x50(%rbx),%rdi
    0.00 :	  5c7c02:       e8 f9 53 fe ff          callq  5ad000 <ExecProject>
    0.00 :	  5c7c07:       49 89 c4                mov    %rax,%r12
         :	 * use it on projected tuples.
         :	 */
         :	static bool
         :	slotNoNulls(TupleTableSlot *slot)
         :	{
         :	        int                     ncols = slot->tts_tupleDescriptor->natts;
    0.00 :	  5c7c0a:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  5c7c0e:       44 8b 28                mov    (%rax),%r13d
         :	        int                     i;
         :
         :	        for (i = 1; i <= ncols; i++)
    0.00 :	  5c7c11:       45 85 ed                test   %r13d,%r13d
    0.00 :	  5c7c14:       7e 5a                   jle    5c7c70 <ExecSubPlan+0x800>
    0.00 :	  5c7c16:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  5c7c1b:       eb 0b                   jmp    5c7c28 <ExecSubPlan+0x7b8>
    0.00 :	  5c7c1d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5c7c20:       83 c3 01                add    $0x1,%ebx
    0.00 :	  5c7c23:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  5c7c26:       7c 48                   jl     5c7c70 <ExecSubPlan+0x800>
         :	        {
         :	                if (slot_attisnull(slot, i))
    0.00 :	  5c7c28:       89 de                   mov    %ebx,%esi
    0.00 :	  5c7c2a:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7c2d:       e8 0e 72 ea ff          callq  46ee40 <slot_attisnull>
    0.00 :	  5c7c32:       84 c0                   test   %al,%al
    0.00 :	  5c7c34:       74 ea                   je     5c7c20 <ExecSubPlan+0x7b0>
         :	                if (slotNoNulls(slot))
         :	                {
         :	                        (void) LookupTupleHashEntry(node->hashtable, slot, &isnew);
         :	                        node->havehashrows = true;
         :	                }
         :	                else if (node->hashnulls)
    0.00 :	  5c7c36:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5c7c3d:       48 8b 78 60             mov    0x60(%rax),%rdi
    0.00 :	  5c7c41:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5c7c44:       74 17                   je     5c7c5d <ExecSubPlan+0x7ed>
         :	                {
         :	                        (void) LookupTupleHashEntry(node->hashnulls, slot, &isnew);
    0.00 :	  5c7c46:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5c7c4a:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7c4d:       e8 1e 12 fe ff          callq  5a8e70 <LookupTupleHashEntry>
         :	                        node->havenullrows = true;
    0.00 :	  5c7c52:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5c7c59:       c6 42 69 01             movb   $0x1,0x69(%rdx)
         :
         :	                /*
         :	                 * Reset innerecontext after each inner tuple to free any memory used
         :	                 * during ExecProject.
         :	                 */
         :	                ResetExprContext(innerecontext);
    0.00 :	  5c7c5d:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  5c7c61:       48 8b 79 28             mov    0x28(%rcx),%rdi
    0.00 :	  5c7c65:       e8 46 0d 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5c7c6a:       e9 11 ff ff ff          jmpq   5c7b80 <ExecSubPlan+0x710>
    0.00 :	  5c7c6f:       90                      nop
         :	                /*
         :	                 * If result contains any nulls, store separately or not at all.
         :	                 */
         :	                if (slotNoNulls(slot))
         :	                {
         :	                        (void) LookupTupleHashEntry(node->hashtable, slot, &isnew);
    0.00 :	  5c7c70:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
    0.00 :	  5c7c77:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5c7c7b:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7c7e:       48 8b 79 58             mov    0x58(%rcx),%rdi
    0.00 :	  5c7c82:       e8 e9 11 fe ff          callq  5a8e70 <LookupTupleHashEntry>
         :	                        node->havehashrows = true;
    0.00 :	  5c7c87:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7c8e:       c6 43 68 01             movb   $0x1,0x68(%rbx)
    0.00 :	  5c7c92:       eb c9                   jmp    5c7c5d <ExecSubPlan+0x7ed>
         :	         * main context, we'd better clear the tuple slot before there's any
         :	         * chance of a reset of the sub-query's context.  Else we will have the
         :	         * potential for a double free attempt.  (XXX possibly no longer needed,
         :	         * but can't hurt.)
         :	         */
         :	        ExecClearTuple(node->projRight->pi_slot);
    0.00 :	  5c7c94:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7c9b:       48 8b 43 50             mov    0x50(%rbx),%rax
    0.00 :	  5c7c9f:       48 8b 78 18             mov    0x18(%rax),%rdi
    0.00 :	  5c7ca3:       e8 68 c4 fe ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5c7ca8:       48 8b 7d 88             mov    -0x78(%rbp),%rdi
    0.00 :	  5c7cac:       48 89 3d ad 2b 5f 00    mov    %rdi,0x5f2bad(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        /*
         :	         * The result for an empty subplan is always FALSE; no need to evaluate
         :	         * lefthand side.
         :	         */
         :	        *isNull = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:122
    6.25 :	  5c7cb3:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  5c7cba:       c6 00 00                movb   $0x0,(%rax)
         :	        if (!node->havehashrows && !node->havenullrows)
    0.00 :	  5c7cbd:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5c7cc4:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7ccb:       00 
    0.00 :	  5c7ccc:       66 83 7a 68 00          cmpw   $0x0,0x68(%rdx)
    0.00 :	  5c7cd1:       0f 84 fa fc ff ff       je     5c79d1 <ExecSubPlan+0x561>
         :
         :	        /*
         :	         * Evaluate lefthand expressions and form a projection tuple. First we
         :	         * have to set the econtext to use (hack alert!).
         :	         */
         :	        node->projLeft->pi_exprContext = econtext;
    0.00 :	  5c7cd7:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
         :	        slot = ExecProject(node->projLeft, NULL);
    0.00 :	  5c7cde:       31 f6                   xor    %esi,%esi
         :
         :	        /*
         :	         * Evaluate lefthand expressions and form a projection tuple. First we
         :	         * have to set the econtext to use (hack alert!).
         :	         */
         :	        node->projLeft->pi_exprContext = econtext;
    0.00 :	  5c7ce0:       48 8b 41 48             mov    0x48(%rcx),%rax
    0.00 :	  5c7ce4:       4c 89 78 10             mov    %r15,0x10(%rax)
         :	        slot = ExecProject(node->projLeft, NULL);
    0.00 :	  5c7ce8:       48 8b 79 48             mov    0x48(%rcx),%rdi
    0.00 :	  5c7cec:       e8 0f 53 fe ff          callq  5ad000 <ExecProject>
    0.00 :	  5c7cf1:       49 89 c4                mov    %rax,%r12
         :	 * use it on projected tuples.
         :	 */
         :	static bool
         :	slotNoNulls(TupleTableSlot *slot)
         :	{
         :	        int                     ncols = slot->tts_tupleDescriptor->natts;
    0.00 :	  5c7cf4:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  5c7cf8:       44 8b 28                mov    (%rax),%r13d
         :	        int                     i;
         :
         :	        for (i = 1; i <= ncols; i++)
    0.00 :	  5c7cfb:       45 85 ed                test   %r13d,%r13d
    0.00 :	  5c7cfe:       0f 8e 73 01 00 00       jle    5c7e77 <ExecSubPlan+0xa07>
    0.00 :	  5c7d04:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  5c7d09:       eb 11                   jmp    5c7d1c <ExecSubPlan+0x8ac>
    0.00 :	  5c7d0b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5c7d10:       83 c3 01                add    $0x1,%ebx
    0.00 :	  5c7d13:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  5c7d16:       0f 8c 5b 01 00 00       jl     5c7e77 <ExecSubPlan+0xa07>
         :	        {
         :	                if (slot_attisnull(slot, i))
    0.00 :	  5c7d1c:       89 de                   mov    %ebx,%esi
    0.00 :	  5c7d1e:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7d21:       e8 1a 71 ea ff          callq  46ee40 <slot_attisnull>
    0.00 :	  5c7d26:       84 c0                   test   %al,%al
    0.00 :	  5c7d28:       74 e6                   je     5c7d10 <ExecSubPlan+0x8a0>
         :	         * were empty, but we already handled that case.) Otherwise, we must scan
         :	         * both the main and partly-null tables to see if there are any rows that
         :	         * aren't provably unequal to the LHS; if so, the result is UNKNOWN.
         :	         * Otherwise, the result is FALSE.
         :	         */
         :	        if (node->hashnulls == NULL)
    0.00 :	  5c7d2a:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7d31:       48 83 7b 60 00          cmpq   $0x0,0x60(%rbx)
    0.00 :	  5c7d36:       74 6b                   je     5c7da3 <ExecSubPlan+0x933>
         :	 * use it on projected tuples.
         :	 */
         :	static bool
         :	slotAllNulls(TupleTableSlot *slot)
         :	{
         :	        int                     ncols = slot->tts_tupleDescriptor->natts;
    0.00 :	  5c7d38:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  5c7d3d:       44 8b 28                mov    (%rax),%r13d
         :	        int                     i;
         :
         :	        for (i = 1; i <= ncols; i++)
    0.00 :	  5c7d40:       45 85 ed                test   %r13d,%r13d
    0.00 :	  5c7d43:       0f 8e 07 02 00 00       jle    5c7f50 <ExecSubPlan+0xae0>
    0.00 :	  5c7d49:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  5c7d4e:       eb 0c                   jmp    5c7d5c <ExecSubPlan+0x8ec>
    0.00 :	  5c7d50:       83 c3 01                add    $0x1,%ebx
    0.00 :	  5c7d53:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  5c7d56:       0f 8c f4 01 00 00       jl     5c7f50 <ExecSubPlan+0xae0>
         :	        {
         :	                if (!slot_attisnull(slot, i))
    0.00 :	  5c7d5c:       89 de                   mov    %ebx,%esi
    0.00 :	  5c7d5e:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7d61:       e8 da 70 ea ff          callq  46ee40 <slot_attisnull>
    0.00 :	  5c7d66:       84 c0                   test   %al,%al
    0.00 :	  5c7d68:       75 e6                   jne    5c7d50 <ExecSubPlan+0x8e0>
         :	                ExecClearTuple(slot);
         :	                *isNull = true;
         :	                return BoolGetDatum(false);
         :	        }
         :	        /* Scan partly-null table first, since more likely to get a match */
         :	        if (node->havenullrows &&
    0.00 :	  5c7d6a:       48 8b bd 70 ff ff ff    mov    -0x90(%rbp),%rdi
    0.00 :	  5c7d71:       80 7f 69 00             cmpb   $0x0,0x69(%rdi)
    0.00 :	  5c7d75:       0f 85 33 02 00 00       jne    5c7fae <ExecSubPlan+0xb3e>
         :	        {
         :	                ExecClearTuple(slot);
         :	                *isNull = true;
         :	                return BoolGetDatum(false);
         :	        }
         :	        if (node->havehashrows &&
    0.00 :	  5c7d7b:       48 8b 8d 70 ff ff ff    mov    -0x90(%rbp),%rcx
    0.00 :	  5c7d82:       80 79 68 00             cmpb   $0x0,0x68(%rcx)
    0.00 :	  5c7d86:       74 1b                   je     5c7da3 <ExecSubPlan+0x933>
    0.00 :	  5c7d88:       48 8b 91 a8 00 00 00    mov    0xa8(%rcx),%rdx
    0.00 :	  5c7d8f:       48 8b 79 58             mov    0x58(%rcx),%rdi
    0.00 :	  5c7d93:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7d96:       e8 45 f6 ff ff          callq  5c73e0 <findPartialMatch>
    0.00 :	  5c7d9b:       84 c0                   test   %al,%al
    0.00 :	  5c7d9d:       0f 85 14 01 00 00       jne    5c7eb7 <ExecSubPlan+0xa47>
         :	        {
         :	                ExecClearTuple(slot);
         :	                *isNull = true;
         :	                return BoolGetDatum(false);
         :	        }
         :	        ExecClearTuple(slot);
    0.00 :	  5c7da3:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7da6:       e8 65 c3 fe ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5c7dab:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7db2:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:213
    6.25 :	  5c7db3:       e9 19 fc ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
         :	                                                                                  node->hashtablecxt,
         :	                                                                                  node->hashtempcxt);
         :
         :	        if (!subplan->unknownEqFalse)
         :	        {
         :	                if (ncols == 1)
    0.00 :	  5c7db8:       41 83 fc 01             cmp    $0x1,%r12d
    0.00 :	  5c7dbc:       0f 84 aa 00 00 00       je     5c7e6c <ExecSubPlan+0x9fc>
         :	                        nbuckets = 1;           /* there can only be one entry */
         :	                else
         :	                {
         :	                        nbuckets /= 16;
    0.00 :	  5c7dc2:       49 89 d8                mov    %rbx,%r8
    0.00 :	  5c7dc5:       49 c1 f8 04             sar    $0x4,%r8
         :	                        if (nbuckets < 1)
    0.00 :	  5c7dc9:       4d 85 c0                test   %r8,%r8
    0.00 :	  5c7dcc:       0f 84 9a 00 00 00       je     5c7e6c <ExecSubPlan+0x9fc>
         :	                                nbuckets = 1;
         :	                }
         :	                node->hashnulls = BuildTupleHashTable(ncols,
    0.00 :	  5c7dd2:       48 8b 9d 70 ff ff ff    mov    -0x90(%rbp),%rbx
    0.00 :	  5c7dd9:       41 b9 08 00 00 00       mov    $0x8,%r9d
    0.00 :	  5c7ddf:       44 89 e7                mov    %r12d,%edi
    0.00 :	  5c7de2:       48 8b 43 78             mov    0x78(%rbx),%rax
    0.00 :	  5c7de6:       48 8b 8b 90 00 00 00    mov    0x90(%rbx),%rcx
    0.00 :	  5c7ded:       48 8b 93 98 00 00 00    mov    0x98(%rbx),%rdx
    0.00 :	  5c7df4:       48 8b b3 88 00 00 00    mov    0x88(%rbx),%rsi
    0.00 :	  5c7dfb:       48 89 44 24 08          mov    %rax,0x8(%rsp)
    0.00 :	  5c7e00:       48 8b 43 70             mov    0x70(%rbx),%rax
    0.00 :	  5c7e04:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  5c7e08:       e8 d3 11 fe ff          callq  5a8fe0 <BuildTupleHashTable>
    0.00 :	  5c7e0d:       48 89 43 60             mov    %rax,0x60(%rbx)
    0.00 :	  5c7e11:       e9 41 fd ff ff          jmpq   5c7b57 <ExecSubPlan+0x6e7>
         :	                         */
         :	                        if (node->curTuple)
         :	                                heap_freetuple(node->curTuple);
         :	                        node->curTuple = ExecCopySlotTuple(slot);
         :
         :	                        result = heap_getattr(node->curTuple, 1, tdesc, isNull);
    0.00 :	  5c7e16:       48 63 c2                movslq %edx,%rax
    0.00 :	  5c7e19:       0f b6 51 16             movzbl 0x16(%rcx),%edx
    0.00 :	  5c7e1d:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5c7e21:       8b 04 10                mov    (%rax,%rdx,1),%eax
    0.00 :	  5c7e24:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7e28:       e9 65 f8 ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
    0.00 :	  5c7e2d:       48 63 c2                movslq %edx,%rax
    0.00 :	  5c7e30:       0f b6 51 16             movzbl 0x16(%rcx),%edx
    0.00 :	  5c7e34:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5c7e38:       0f b7 04 10             movzwl (%rax,%rdx,1),%eax
    0.00 :	  5c7e3c:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7e40:       e9 4d f8 ff ff          jmpq   5c7692 <ExecSubPlan+0x222>
         :
         :	                if (subLinkType == EXPR_SUBLINK)
         :	                {
         :	                        /* cannot allow multiple input tuples for EXPR sublink */
         :	                        if (found)
         :	                                ereport(ERROR,
    0.00 :	  5c7e45:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5c7e48:       b9 a0 c6 88 00          mov    $0x88c6a0,%ecx
    0.00 :	  5c7e4d:       ba 54 01 00 00          mov    $0x154,%edx
    0.00 :	  5c7e52:       e9 5e f9 ff ff          jmpq   5c77b5 <ExecSubPlan+0x345>
         :	        {
         :	                /* We return the result in the caller's context */
         :	                if (astate != NULL)
         :	                        result = makeArrayResult(astate, oldcontext);
         :	                else
         :	                        result = PointerGetDatum(construct_empty_array(subplan->firstColType));
    0.00 :	  5c7e57:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5c7e5b:       8b 78 28                mov    0x28(%rax),%edi
    0.00 :	  5c7e5e:       e8 4d 17 0f 00          callq  6b95b0 <construct_empty_array>
    0.00 :	  5c7e63:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  5c7e67:       e9 65 fb ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
         :	                if (ncols == 1)
         :	                        nbuckets = 1;           /* there can only be one entry */
         :	                else
         :	                {
         :	                        nbuckets /= 16;
         :	                        if (nbuckets < 1)
    0.00 :	  5c7e6c:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  5c7e72:       e9 5b ff ff ff          jmpq   5c7dd2 <ExecSubPlan+0x962>
         :	         * LHS to some main-table entry --- which is a comparison we will not even
         :	         * make, unless there's a chance match of hash keys.
         :	         */
         :	        if (slotNoNulls(slot))
         :	        {
         :	                if (node->havehashrows &&
    0.00 :	  5c7e77:       48 8b bd 70 ff ff ff    mov    -0x90(%rbp),%rdi
    0.00 :	  5c7e7e:       80 7f 68 00             cmpb   $0x0,0x68(%rdi)
    0.00 :	  5c7e82:       0f 85 e7 00 00 00       jne    5c7f6f <ExecSubPlan+0xaff>
         :	                                                           node->lhs_hash_funcs) != NULL)
         :	                {
         :	                        ExecClearTuple(slot);
         :	                        return BoolGetDatum(true);
         :	                }
         :	                if (node->havenullrows &&
    0.00 :	  5c7e88:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:166
   12.50 :	  5c7e8f:       80 7a 69 00             cmpb   $0x0,0x69(%rdx)
    0.00 :	  5c7e93:       0f 84 0a ff ff ff       je     5c7da3 <ExecSubPlan+0x933>
    0.00 :	  5c7e99:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  5c7e9c:       48 8b 92 a8 00 00 00    mov    0xa8(%rdx),%rdx
    0.00 :	  5c7ea3:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7ea6:       48 8b 79 60             mov    0x60(%rcx),%rdi
    0.00 :	  5c7eaa:       e8 31 f5 ff ff          callq  5c73e0 <findPartialMatch>
    0.00 :	  5c7eaf:       84 c0                   test   %al,%al
    0.00 :	  5c7eb1:       0f 84 ec fe ff ff       je     5c7da3 <ExecSubPlan+0x933>
         :	                return BoolGetDatum(false);
         :	        }
         :	        if (node->havehashrows &&
         :	                findPartialMatch(node->hashtable, slot, node->cur_eq_funcs))
         :	        {
         :	                ExecClearTuple(slot);
    0.00 :	  5c7eb7:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7eba:       e8 51 c2 fe ff          callq  5b4110 <ExecClearTuple>
         :	                *isNull = true;
    0.00 :	  5c7ebf:       48 8b 9d 68 ff ff ff    mov    -0x98(%rbp),%rbx
    0.00 :	  5c7ec6:       c6 03 01                movb   $0x1,(%rbx)
    0.00 :	  5c7ec9:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7ed0:       00 
    0.00 :	  5c7ed1:       e9 fb fa ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
    0.00 :	  5c7ed6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5c7edd:       00 00 00 
         :	         */
         :	        result = BoolGetDatum(subLinkType == ALL_SUBLINK);
         :	        *isNull = false;
         :
         :	        for (slot = ExecProcNode(planstate);
         :	                 !TupIsNull(slot);
    0.00 :	  5c7ee0:       31 c0                   xor    %eax,%eax
    0.00 :	  5c7ee2:       48 c7 45 98 00 00 00    movq   $0x0,-0x68(%rbp)
    0.00 :	  5c7ee9:       00 
    0.00 :	  5c7eea:       e9 15 fb ff ff          jmpq   5c7a04 <ExecSubPlan+0x594>
         :	        if (isDone)
         :	                *isDone = ExprSingleResult;
         :
         :	        /* Sanity checks */
         :	        if (subplan->subLinkType == CTE_SUBLINK)
         :	                elog(ERROR, "CTE subplans should not be executed via ExecSubPlan");
    0.00 :	  5c7eef:       ba 80 c6 88 00          mov    $0x88c680,%edx
    0.00 :	  5c7ef4:       be 54 00 00 00          mov    $0x54,%esi
    0.00 :	  5c7ef9:       bf 01 c4 88 00          mov    $0x88c401,%edi
    0.00 :	  5c7efe:       e8 1d 35 1b 00          callq  77b420 <elog_start>
    0.00 :	  5c7f03:       be 30 c4 88 00          mov    $0x88c430,%esi
    0.00 :	  5c7f08:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5c7f0d:       31 c0                   xor    %eax,%eax
    0.00 :	  5c7f0f:       e8 1c 33 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5c7f14:       e8 b7 15 ea ff          callq  4694d0 <abort@plt>
         :	        if (subplan->setParam != NIL && subplan->subLinkType != MULTIEXPR_SUBLINK)
         :	                elog(ERROR, "cannot set parent params from subquery");
    0.00 :	  5c7f19:       ba 80 c6 88 00          mov    $0x88c680,%edx
    0.00 :	  5c7f1e:       be 56 00 00 00          mov    $0x56,%esi
    0.00 :	  5c7f23:       bf 01 c4 88 00          mov    $0x88c401,%edi
    0.00 :	  5c7f28:       e8 f3 34 1b 00          callq  77b420 <elog_start>
    0.00 :	  5c7f2d:       be 68 c4 88 00          mov    $0x88c468,%esi
    0.00 :	  5c7f32:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5c7f37:       31 c0                   xor    %eax,%eax
    0.00 :	  5c7f39:       e8 f2 32 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5c7f3e:       e8 8d 15 ea ff          callq  4694d0 <abort@plt>
         :	                return BoolGetDatum(false);
         :	        }
         :	        if (slotAllNulls(slot))
         :	        {
         :	                ExecClearTuple(slot);
         :	                *isNull = true;
    0.00 :	  5c7f43:       48 c7 45 a0 01 00 00    movq   $0x1,-0x60(%rbp)
    0.00 :	  5c7f4a:       00 
    0.00 :	  5c7f4b:       e9 c2 f9 ff ff          jmpq   5c7912 <ExecSubPlan+0x4a2>
         :	                ExecClearTuple(slot);
         :	                return BoolGetDatum(false);
         :	        }
         :	        if (slotAllNulls(slot))
         :	        {
         :	                ExecClearTuple(slot);
    0.00 :	  5c7f50:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7f53:       e8 b8 c1 fe ff          callq  5b4110 <ExecClearTuple>
         :	                *isNull = true;
    0.00 :	  5c7f58:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  5c7f5f:       c6 00 01                movb   $0x1,(%rax)
    0.00 :	  5c7f62:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7f69:       00 
    0.00 :	  5c7f6a:       e9 62 fa ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
         :	         * LHS to some main-table entry --- which is a comparison we will not even
         :	         * make, unless there's a chance match of hash keys.
         :	         */
         :	        if (slotNoNulls(slot))
         :	        {
         :	                if (node->havehashrows &&
    0.00 :	  5c7f6f:       48 8b bd 70 ff ff ff    mov    -0x90(%rbp),%rdi
    0.00 :	  5c7f76:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7f79:       48 8b 8f a0 00 00 00    mov    0xa0(%rdi),%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSubplan.c:157
    6.25 :	  5c7f80:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
    0.00 :	  5c7f87:       48 8b 7f 58             mov    0x58(%rdi),%rdi
    0.00 :	  5c7f8b:       e8 70 0e fe ff          callq  5a8e00 <FindTupleHashEntry>
    6.25 :	  5c7f90:       48 85 c0                test   %rax,%rax
    0.00 :	  5c7f93:       0f 84 ef fe ff ff       je     5c7e88 <ExecSubPlan+0xa18>
         :	                        FindTupleHashEntry(node->hashtable,
         :	                                                           slot,
         :	                                                           node->cur_eq_funcs,
         :	                                                           node->lhs_hash_funcs) != NULL)
         :	                {
         :	                        ExecClearTuple(slot);
    0.00 :	  5c7f99:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7f9c:       e8 6f c1 fe ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5c7fa1:       48 c7 45 a0 01 00 00    movq   $0x1,-0x60(%rbp)
    0.00 :	  5c7fa8:       00 
    0.00 :	  5c7fa9:       e9 23 fa ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>
         :	                ExecClearTuple(slot);
         :	                *isNull = true;
         :	                return BoolGetDatum(false);
         :	        }
         :	        /* Scan partly-null table first, since more likely to get a match */
         :	        if (node->havenullrows &&
    0.00 :	  5c7fae:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
    0.00 :	  5c7fb5:       48 8b 7f 60             mov    0x60(%rdi),%rdi
    0.00 :	  5c7fb9:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5c7fbc:       e8 1f f4 ff ff          callq  5c73e0 <findPartialMatch>
    0.00 :	  5c7fc1:       84 c0                   test   %al,%al
    0.00 :	  5c7fc3:       0f 84 b2 fd ff ff       je     5c7d7b <ExecSubPlan+0x90b>
         :	                findPartialMatch(node->hashnulls, slot, node->cur_eq_funcs))
         :	        {
         :	                ExecClearTuple(slot);
    0.00 :	  5c7fc9:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c7fcc:       e8 3f c1 fe ff          callq  5b4110 <ExecClearTuple>
         :	                *isNull = true;
    0.00 :	  5c7fd1:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
    0.00 :	  5c7fd8:       c6 02 01                movb   $0x1,(%rdx)
    0.00 :	  5c7fdb:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  5c7fe2:       00 
    0.00 :	  5c7fe3:       e9 e9 f9 ff ff          jmpq   5c79d1 <ExecSubPlan+0x561>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000490660 <hash_uint32>:
         :	        register uint32 a,
         :	                                b,
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
    0.00 :	  490660:       81 ef ac a9 8c 61       sub    $0x618ca9ac,%edi
         :	 *              hash_any(&k, sizeof(uint32))
         :	 * but is faster and doesn't force the caller to store k into memory.
         :	 */
         :	Datum
         :	hash_uint32(uint32 k)
         :	{
    0.00 :	  490666:       55                      push   %rbp
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
    0.00 :	  490667:       81 f7 64 d8 6a 2a       xor    $0x2a6ad864,%edi
    0.00 :	  49066d:       81 ef 53 21 c3 56       sub    $0x56c32153,%edi
         :	 *              hash_any(&k, sizeof(uint32))
         :	 * but is faster and doesn't force the caller to store k into memory.
         :	 */
         :	Datum
         :	hash_uint32(uint32 k)
         :	{
    0.00 :	  490673:       48 89 e5                mov    %rsp,%rbp
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
   13.33 :	  490676:       89 fe                   mov    %edi,%esi
    0.00 :	  490678:       89 f8                   mov    %edi,%eax
    0.00 :	  49067a:       c1 c8 07                ror    $0x7,%eax
   13.33 :	  49067d:       81 f6 54 56 73 9e       xor    $0x9e735654,%esi
    0.00 :	  490683:       29 c6                   sub    %eax,%esi
         :
         :	        /* report the result */
         :	        return UInt32GetDatum(c);
         :	}
    0.00 :	  490685:       c9                      leaveq 
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
    0.00 :	  490686:       89 f0                   mov    %esi,%eax
    0.00 :	  490688:       89 f2                   mov    %esi,%edx
    6.67 :	  49068a:       c1 ca 10                ror    $0x10,%edx
    0.00 :	  49068d:       35 64 d8 6a 2a          xor    $0x2a6ad864,%eax
    0.00 :	  490692:       29 d0                   sub    %edx,%eax
    0.00 :	  490694:       89 c2                   mov    %eax,%edx
    0.00 :	  490696:       89 c1                   mov    %eax,%ecx
    0.00 :	  490698:       c1 c9 1c                ror    $0x1c,%ecx
   13.33 :	  49069b:       31 fa                   xor    %edi,%edx
    0.00 :	  49069d:       29 ca                   sub    %ecx,%edx
    6.67 :	  49069f:       89 d1                   mov    %edx,%ecx
    0.00 :	  4906a1:       c1 ca 12                ror    $0x12,%edx
   13.33 :	  4906a4:       31 f1                   xor    %esi,%ecx
    0.00 :	  4906a6:       29 d1                   sub    %edx,%ecx
   13.33 :	  4906a8:       31 c8                   xor    %ecx,%eax
    6.67 :	  4906aa:       c1 c9 08                ror    $0x8,%ecx
   13.33 :	  4906ad:       29 c8                   sub    %ecx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   60.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:427
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:410
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:430
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b43e0 <ExecStoreMinimalTuple>:
         :	 */
         :	TupleTableSlot *
         :	ExecStoreMinimalTuple(MinimalTuple mtup,
         :	                                          TupleTableSlot *slot,
         :	                                          bool shouldFree)
         :	{
    0.00 :	  5b43e0:       55                      push   %rbp
    0.00 :	  5b43e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b43e4:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  5b43e8:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  5b43ec:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  5b43ef:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  5b43f3:       48 83 ec 20             sub    $0x20,%rsp
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b43f7:       80 7e 05 00             cmpb   $0x0,0x5(%rsi)
         :	 */
         :	TupleTableSlot *
         :	ExecStoreMinimalTuple(MinimalTuple mtup,
         :	                                          TupleTableSlot *slot,
         :	                                          bool shouldFree)
         :	{
    0.00 :	  5b43fb:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5b43fe:       41 89 d5                mov    %edx,%r13d
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b4401:       75 6d                   jne    5b4470 <ExecStoreMinimalTuple+0x90>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b4403:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:410
    6.67 :	  5b4407:       75 57                   jne    5b4460 <ExecStoreMinimalTuple+0x80>
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b4409:       8b 7b 20                mov    0x20(%rbx),%edi
    0.00 :	  5b440c:       85 ff                   test   %edi,%edi
    0.00 :	  5b440e:       74 05                   je     5b4415 <ExecStoreMinimalTuple+0x35>
         :	                ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4410:       e8 4b 0a 0c 00          callq  674e60 <ReleaseBuffer>
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
    0.00 :	  5b4415:       48 8d 43 40             lea    0x40(%rbx),%rax
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
    0.00 :	  5b4419:       44 88 6b 06             mov    %r13b,0x6(%rbx)
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
    0.00 :	  5b441d:       4c 89 63 38             mov    %r12,0x38(%rbx)
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
         :	                ReleaseBuffer(slot->tts_buffer);
         :
         :	        slot->tts_buffer = InvalidBuffer;
    0.00 :	  5b4421:       c7 43 20 00 00 00 00    movl   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
    0.00 :	  5b4428:       c6 43 04 00             movb   $0x0,0x4(%rbx)
         :	        slot->tts_shouldFree = false;
    0.00 :	  5b442c:       c6 43 05 00             movb   $0x0,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:427
   13.33 :	  5b4430:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  5b4434:       41 8b 04 24             mov    (%r12),%eax
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
   60.00 :	  5b4438:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
         :	        /* no need to set t_self or t_tableOid since we won't allow access */
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b443c:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  5b4443:       83 c0 08                add    $0x8,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:430
    6.67 :	  5b4446:       89 43 40                mov    %eax,0x40(%rbx)
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
    0.00 :	  5b4449:       49 8d 44 24 f8          lea    -0x8(%r12),%rax
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
    0.00 :	  5b444e:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
    0.00 :	  5b4452:       48 89 43 50             mov    %rax,0x50(%rbx)
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
    6.67 :	  5b4456:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b4459:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  5b445d:       c9                      leaveq 
    6.67 :	  5b445e:       c3                      retq   
    0.00 :	  5b445f:       90                      nop
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4460:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b4464:       e8 47 a8 eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4469:       eb 9e                   jmp    5b4409 <ExecStoreMinimalTuple+0x29>
    0.00 :	  5b446b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4470:       48 8b 7e 08             mov    0x8(%rsi),%rdi
    0.00 :	  5b4474:       e8 47 a8 eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4479:       eb 88                   jmp    5b4403 <ExecStoreMinimalTuple+0x23>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   64.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
   21.43 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:782
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782ca0 <CHashBucketScan>:
         :	CHashBucketScan(CHashTable table,
         :	                                CHashPtr *start,
         :	                                uint32 hashcode,
         :	                                const void *key,
         :	                                CHashScanResult *res)
         :	{
    0.00 :	  782ca0:       55                      push   %rbp
    0.00 :	  782ca1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782ca4:       41 57                   push   %r15
    0.00 :	  782ca6:       41 89 d7                mov    %edx,%r15d
    0.00 :	  782ca9:       41 56                   push   %r14
    0.00 :	  782cab:       41 55                   push   %r13
    0.00 :	  782cad:       49 89 fd                mov    %rdi,%r13
    0.00 :	  782cb0:       41 54                   push   %r12
    0.00 :	  782cb2:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  782cb5:       53                      push   %rbx
    0.00 :	  782cb6:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  782cba:       48 89 75 d0             mov    %rsi,-0x30(%rbp)
    0.00 :	  782cbe:       48 89 4d c8             mov    %rcx,-0x38(%rbp)
    0.00 :	  782cc2:       4c 89 45 c0             mov    %r8,-0x40(%rbp)
         :	        CHashPtr   *pointer_to_target;
         :	        CHashNode  *target_node = NULL;
         :
         :	retry:
         :	        pointer_to_target = start;
         :	        target = *pointer_to_target;
    0.00 :	  782cc6:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  782cca:       44 8b 10                mov    (%rax),%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
   64.29 :	  782ccd:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cd1:       0f 87 ff 00 00 00       ja     782dd6 <CHashBucketScan+0x136>
         :	                {
         :	                        res->found = false;
         :	                        break;
    0.00 :	  782cd7:       4c 8b 75 d0             mov    -0x30(%rbp),%r14
    0.00 :	  782cdb:       eb 21                   jmp    782cfe <CHashBucketScan+0x5e>
    0.00 :	  782cdd:       0f 1f 00                nopl   (%rax)
         :	                /*
         :	                 * Bucket chains are kept in order, so that there is exactly one legal
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
    0.00 :	  782ce0:       41 8b 44 24 04          mov    0x4(%r12),%eax
         :	                if (h == hashcode)
    0.00 :	  782ce5:       44 39 f8                cmp    %r15d,%eax
    0.00 :	  782ce8:       74 5e                   je     782d48 <CHashBucketScan+0xa8>
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
         :	                                                 table->desc.key_size);
         :	                else if (h > hashcode)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:782
    7.14 :	  782cea:       41 39 c7                cmp    %eax,%r15d
    0.00 :	  782ced:       0f 1f 00                nopl   (%rax)
    0.00 :	  782cf0:       72 7b                   jb     782d6d <CHashBucketScan+0xcd>
         :	                                break;
         :	                        }
         :	                }
         :
         :	                /* Continue scan from next node. */
         :	                pointer_to_target = &target_node->next;
    0.00 :	  782cf2:       4d 89 e6                mov    %r12,%r14
    0.00 :	  782cf5:       45 89 c2                mov    %r8d,%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782cf8:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cfc:       77 79                   ja     782d77 <CHashBucketScan+0xd7>
         :	                {
         :	                        res->found = false;
         :	                        break;
         :	                }
         :	                target_node = CHashTableGetNode(table, target);
    0.00 :	  782cfe:       44 89 d0                mov    %r10d,%eax
    0.00 :	  782d01:       d1 e8                   shr    %eax
    0.00 :	  782d03:       41 89 c4                mov    %eax,%r12d
    0.00 :	  782d06:       45 0f af 65 1c          imul   0x1c(%r13),%r12d
    0.00 :	  782d0b:       4d 03 65 30             add    0x30(%r13),%r12
         :	                 * target may have been fetched from an arena entry that could be
         :	                 * concurrently modified, so a dependency barrier is required before
         :	                 * dereferencing the derived pointer.
         :	                 */
         :	                pg_read_barrier_depends();
         :	                next = target_node->next;
    0.00 :	  782d0f:       45 8b 04 24             mov    (%r12),%r8d
         :	                 * ensures that delete-marked elements are removed from bucket chains
         :	                 * as quickly as possible and reduces code duplication.  See
         :	                 * CHashDelete for further comments about why delete-marking is
         :	                 * necessary and how it allows safe deletion.
         :	                 */
         :	                if (CHashPtrIsMarked(next))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
   21.43 :	  782d13:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d17:       74 c7                   je     782ce0 <CHashBucketScan+0x40>
         :	                {
         :	zap:
         :	                        if (__sync_bool_compare_and_swap(pointer_to_target,
    0.00 :	  782d19:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  782d1c:       44 89 d0                mov    %r10d,%eax
    0.00 :	  782d1f:       83 e3 fe                and    $0xfffffffe,%ebx
    0.00 :	  782d22:       f0 41 0f b1 1e          lock cmpxchg %ebx,(%r14)
    0.00 :	  782d27:       74 77                   je     782da0 <CHashBucketScan+0x100>
         :	                                 * the node which precedes it before we advance to the next
         :	                                 * node.  That could certainly happen occasionally, but we'd
         :	                                 * have to be pretty unlucky to have it happen even twice in
         :	                                 * a row.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge_Fail);
    0.00 :	  782d29:       49 83 85 88 00 00 00    addq   $0x1,0x88(%r13)
    0.00 :	  782d30:       01 
         :	                                target = *pointer_to_target;
    0.00 :	  782d31:       45 8b 16                mov    (%r14),%r10d
         :	                                if (CHashPtrIsMarked(target))
    0.00 :	  782d34:       41 f6 c2 01             test   $0x1,%r10b
    0.00 :	  782d38:       74 be                   je     782cf8 <CHashBucketScan+0x58>
         :	                                {
         :	                                        CHashTableIncrementStatistic(table, CHS_Scan_Restart);
    0.00 :	  782d3a:       49 83 85 90 00 00 00    addq   $0x1,0x90(%r13)
    0.00 :	  782d41:       01 
         :	                                        goto retry;
    0.00 :	  782d42:       eb 82                   jmp    782cc6 <CHashBucketScan+0x26>
    0.00 :	  782d44:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
         :	                if (h == hashcode)
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
    0.00 :	  782d48:       41 0f b7 4d 0e          movzwl 0xe(%r13),%ecx
    0.00 :	  782d4d:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  782d51:       49 8d 74 24 08          lea    0x8(%r12),%rsi
    0.00 :	  782d56:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  782d59:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    7.14 :	  782d5b:       0f 97 c0                seta   %al
    0.00 :	  782d5e:       0f 92 c2                setb   %dl
    0.00 :	  782d61:       28 d0                   sub    %dl,%al
    0.00 :	  782d63:       0f be c0                movsbl %al,%eax
         :	                 * the point where we expect to find the key OR someone delete-marked
         :	                 * the item and overwrote the hashcode with a gcnext pointer.  In the
         :	                 * latter case we must take care not to be fooled into stopping the
         :	                 * scan early.
         :	                 */
         :	                if (cmp >= 0)
    0.00 :	  782d66:       83 f8 00                cmp    $0x0,%eax
    0.00 :	  782d69:       7c 87                   jl     782cf2 <CHashBucketScan+0x52>
         :	                {
         :	                        if (cmp == 0)
    0.00 :	  782d6b:       74 5b                   je     782dc8 <CHashBucketScan+0x128>
         :	                                /*
         :	                                 * pg_read_barrier() prevents the reread of the next pointer
         :	                                 * from being speculated ahead of the read of the hash value.
         :	                                 */
         :	                                pg_read_barrier();
         :	                                next = target_node->next;
    0.00 :	  782d6d:       45 8b 04 24             mov    (%r12),%r8d
         :	                                if (CHashPtrIsMarked(next))
    0.00 :	  782d71:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d75:       75 a2                   jne    782d19 <CHashBucketScan+0x79>
         :	                                        goto zap;
         :	                                res->found = false;
    0.00 :	  782d77:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  782d7b:       c6 47 18 00             movb   $0x0,0x18(%rdi)
         :	                pointer_to_target = &target_node->next;
         :	                target = next;
         :	        }
         :
         :	        /* Send results back to caller. */
         :	        res->target = target;
    0.00 :	  782d7f:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  782d83:       44 89 10                mov    %r10d,(%rax)
         :	        res->pointer_to_target = pointer_to_target;
    0.00 :	  782d86:       4c 89 70 08             mov    %r14,0x8(%rax)
         :	        res->target_node = target_node;
    0.00 :	  782d8a:       4c 89 60 10             mov    %r12,0x10(%rax)
         :	}
    0.00 :	  782d8e:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  782d92:       5b                      pop    %rbx
    0.00 :	  782d93:       41 5c                   pop    %r12
    0.00 :	  782d95:       41 5d                   pop    %r13
    0.00 :	  782d97:       41 5e                   pop    %r14
    0.00 :	  782d99:       41 5f                   pop    %r15
    0.00 :	  782d9b:       c9                      leaveq 
    0.00 :	  782d9c:       c3                      retq   
    0.00 :	  782d9d:       0f 1f 00                nopl   (%rax)
         :	                                 * delete-mark has been applied.  Thus, if we just keep
         :	                                 * following the next pointers, we're guaranteed to visit
         :	                                 * all non-deleted items (and possibly some deleted items)
         :	                                 * that were present at the time we began the scan.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge);
    0.00 :	  782da0:       49 83 85 80 00 00 00    addq   $0x1,0x80(%r13)
    0.00 :	  782da7:       01 
         :	                                CHashAddToGarbage(table, hashcode & table->bucket_mask,
    0.00 :	  782da8:       44 89 fe                mov    %r15d,%esi
    0.00 :	  782dab:       41 23 75 10             and    0x10(%r13),%esi
    0.00 :	  782daf:       44 89 d2                mov    %r10d,%edx
    0.00 :	  782db2:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  782db5:       e8 96 fe ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  782dba:       41 89 da                mov    %ebx,%r10d
    0.00 :	  782dbd:       e9 36 ff ff ff          jmpq   782cf8 <CHashBucketScan+0x58>
    0.00 :	  782dc2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 */
         :	                if (cmp >= 0)
         :	                {
         :	                        if (cmp == 0)
         :	                        {
         :	                                res->found = true;
    0.00 :	  782dc8:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  782dcc:       c6 40 18 01             movb   $0x1,0x18(%rax)
         :	                                res->next = next;
    0.00 :	  782dd0:       44 89 40 04             mov    %r8d,0x4(%rax)
         :	                                break;
    0.00 :	  782dd4:       eb a9                   jmp    782d7f <CHashBucketScan+0xdf>
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782dd6:       49 89 c6                mov    %rax,%r14
    0.00 :	  782dd9:       eb 9c                   jmp    782d77 <CHashBucketScan+0xd7>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   15.38 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
   15.38 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:885
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:731
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:871
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:872
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:766
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004960f0 <heapgettup_pagemode>:
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  4960f0:       55                      push   %rbp
         :	        HeapTuple       tuple = &(scan->rs_ctup);
    0.00 :	  4960f1:       48 8d 47 48             lea    0x48(%rdi),%rax
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  4960f5:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4960f8:       41 57                   push   %r15
    0.00 :	  4960fa:       41 56                   push   %r14
    0.00 :	  4960fc:       41 55                   push   %r13
    0.00 :	  4960fe:       49 89 fd                mov    %rdi,%r13
    0.00 :	  496101:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    7.69 :	  496103:       53                      push   %rbx
    0.00 :	  496104:       48 83 ec 48             sub    $0x48,%rsp
         :	        HeapTuple       tuple = &(scan->rs_ctup);
         :	        bool            backward = ScanDirectionIsBackward(dir);
    0.00 :	  496108:       83 fe ff                cmp    $0xffffffff,%esi
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  49610b:       89 55 ac                mov    %edx,-0x54(%rbp)
         :	        HeapTuple       tuple = &(scan->rs_ctup);
         :	        bool            backward = ScanDirectionIsBackward(dir);
    0.00 :	  49610e:       0f 94 45 bf             sete   -0x41(%rbp)
         :	        ItemId          lpp;
         :
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  496112:       83 ee 01                sub    $0x1,%esi
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  496115:       48 89 4d a0             mov    %rcx,-0x60(%rbp)
         :	        HeapTuple       tuple = &(scan->rs_ctup);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:731
    7.69 :	  496119:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	        ItemId          lpp;
         :
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  49611d:       0f 84 fd 02 00 00       je     496420 <heapgettup_pagemode+0x330>
         :	                lines = scan->rs_ntuples;
         :	                /* page and lineindex now reference the next visible tid */
         :
         :	                linesleft = lines - lineindex;
         :	        }
         :	        else if (backward)
    0.00 :	  496123:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  496127:       0f 84 67 02 00 00       je     496394 <heapgettup_pagemode+0x2a4>
         :	        {
         :	                if (!scan->rs_inited)
    0.00 :	  49612d:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
    0.00 :	  496131:       0f 84 2a 03 00 00       je     496461 <heapgettup_pagemode+0x371>
         :	                        heapgetpage(scan, page);
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
    0.00 :	  496137:       44 8b 7f 60             mov    0x60(%rdi),%r15d
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  49613b:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  49613f:       85 c0                   test   %eax,%eax
    0.00 :	  496141:       0f 88 24 05 00 00       js     49666b <heapgettup_pagemode+0x57b>
    0.00 :	  496147:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49614a:       4c 63 f0                movslq %eax,%r14
    0.00 :	  49614d:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  496151:       4c 03 35 a0 99 72 00    add    0x7299a0(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :
         :	                if (!scan->rs_inited)
    0.00 :	  496158:       41 80 7d 41 00          cmpb   $0x0,0x41(%r13)
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lines = scan->rs_ntuples;
    0.00 :	  49615d:       41 8b 45 78             mov    0x78(%r13),%eax
         :
         :	                if (!scan->rs_inited)
    0.00 :	  496161:       0f 85 c6 04 00 00       jne    49662d <heapgettup_pagemode+0x53d>
         :	                {
         :	                        lineindex = lines - 1;
    0.00 :	  496167:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49616a:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	                        scan->rs_inited = true;
    0.00 :	  49616d:       41 c6 45 41 01          movb   $0x1,0x41(%r13)
         :	                {
         :	                        lineindex = scan->rs_cindex - 1;
         :	                }
         :	                /* page and lineindex now reference the previous visible tid */
         :
         :	                linesleft = lineindex + 1;
    0.00 :	  496172:       8b 55 c0                mov    -0x40(%rbp),%edx
    0.00 :	  496175:       83 c2 01                add    $0x1,%edx
    0.00 :	  496178:       89 55 c4                mov    %edx,-0x3c(%rbp)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  49617b:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  49617e:       83 ea 01                sub    $0x1,%edx
    0.00 :	  496181:       89 55 9c                mov    %edx,-0x64(%rbp)
    0.00 :	  496184:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  496188:       44 8b 45 c4             mov    -0x3c(%rbp),%r8d
    0.00 :	  49618c:       45 85 c0                test   %r8d,%r8d
    0.00 :	  49618f:       0f 8e 6b 01 00 00       jle    496300 <heapgettup_pagemode+0x210>
         :	                {
         :	                        lineoff = scan->rs_vistuples[lineindex];
    0.00 :	  496195:       48 63 45 c0             movslq -0x40(%rbp),%rax
    0.00 :	  496199:       41 0f b7 4c 45 7c       movzwl 0x7c(%r13,%rax,2),%ecx
         :	                        lpp = PageGetItemId(dp, lineoff);
    0.00 :	  49619f:       0f b7 d1                movzwl %cx,%edx
         :	                        Assert(ItemIdIsNormal(lpp));
         :
         :	                        tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
    0.00 :	  4961a2:       48 83 c2 03             add    $0x3,%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    7.69 :	  4961a6:       41 0f b7 44 96 08       movzwl 0x8(%r14,%rdx,4),%eax
   15.38 :	  4961ac:       25 ff 7f 00 00          and    $0x7fff,%eax
    7.69 :	  4961b1:       49 8d 04 06             lea    (%r14,%rax,1),%rax
    0.00 :	  4961b5:       49 89 45 58             mov    %rax,0x58(%r13)
         :	                        tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4961b9:       41 0f b7 44 96 0a       movzwl 0xa(%r14,%rdx,4),%eax
         :	                        ItemPointerSet(&(tuple->t_self), page, lineoff);
    0.00 :	  4961bf:       66 45 89 7d 4e          mov    %r15w,0x4e(%r13)
    0.00 :	  4961c4:       66 41 89 4d 50          mov    %cx,0x50(%r13)
         :	                        lineoff = scan->rs_vistuples[lineindex];
         :	                        lpp = PageGetItemId(dp, lineoff);
         :	                        Assert(ItemIdIsNormal(lpp));
         :
         :	                        tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4961c9:       66 d1 e8                shr    %ax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:871
    7.69 :	  4961cc:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4961cf:       41 89 45 48             mov    %eax,0x48(%r13)
         :	                        ItemPointerSet(&(tuple->t_self), page, lineoff);
    0.00 :	  4961d3:       44 89 f8                mov    %r15d,%eax
    0.00 :	  4961d6:       c1 e8 10                shr    $0x10,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:872
    7.69 :	  4961d9:       66 41 89 45 4c          mov    %ax,0x4c(%r13)
         :
         :	                        /*
         :	                         * if current tuple qualifies, return it.
         :	                         */
         :	                        if (key != NULL)
    0.00 :	  4961de:       48 83 7d a0 00          cmpq   $0x0,-0x60(%rbp)
    0.00 :	  4961e3:       0f 84 87 03 00 00       je     496570 <heapgettup_pagemode+0x480>
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4961e9:       44 8b 4d ac             mov    -0x54(%rbp),%r9d
    0.00 :	  4961ed:       45 85 c9                test   %r9d,%r9d
    0.00 :	  4961f0:       0f 84 7a 03 00 00       je     496570 <heapgettup_pagemode+0x480>
    0.00 :	  4961f6:       48 8b 5d a0             mov    -0x60(%rbp),%rbx
    0.00 :	  4961fa:       44 8b 65 9c             mov    -0x64(%rbp),%r12d
    0.00 :	  4961fe:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  496201:       0f 84 a3 00 00 00       je     4962aa <heapgettup_pagemode+0x1ba>
    0.00 :	  496207:       e9 c7 00 00 00          jmpq   4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  49620c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  496210:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
    0.00 :	  496214:       f6 47 14 01             testb  $0x1,0x14(%rdi)
    0.00 :	  496218:       0f 85 9a 02 00 00       jne    4964b8 <heapgettup_pagemode+0x3c8>
    0.00 :	  49621e:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  496222:       48 0f bf d1             movswq %cx,%rdx
    0.00 :	  496226:       4c 8b 40 38             mov    0x38(%rax),%r8
    0.00 :	  49622a:       49 8b 40 08             mov    0x8(%r8),%rax
    0.00 :	  49622e:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    0.00 :	  496233:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  496236:       85 c0                   test   %eax,%eax
    0.00 :	  496238:       0f 88 02 03 00 00       js     496540 <heapgettup_pagemode+0x450>
    0.00 :	  49623e:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  496242:       0f 84 d8 02 00 00       je     496520 <heapgettup_pagemode+0x430>
    0.00 :	  496248:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  49624c:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  496250:       0f 84 02 03 00 00       je     496558 <heapgettup_pagemode+0x468>
    0.00 :	  496256:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  49625a:       0f 84 88 03 00 00       je     4965e8 <heapgettup_pagemode+0x4f8>
    0.00 :	  496260:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  496264:       0f 84 96 03 00 00       je     496600 <heapgettup_pagemode+0x510>
    0.00 :	  49626a:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  49626e:       48 98                   cltq   
    0.00 :	  496270:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  496274:       0f b6 14 10             movzbl (%rax,%rdx,1),%edx
    0.00 :	  496278:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49627f:       00 
    0.00 :	  496280:       48 8b 4b 40             mov    0x40(%rbx),%rcx
    0.00 :	  496284:       8b 73 0c                mov    0xc(%rbx),%esi
    0.00 :	  496287:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  49628b:       e8 a0 7d 2e 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  496290:       84 c0                   test   %al,%al
    0.00 :	  496292:       74 3f                   je     4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  496294:       45 85 e4                test   %r12d,%r12d
    0.00 :	  496297:       0f 84 d3 02 00 00       je     496570 <heapgettup_pagemode+0x480>
    0.00 :	  49629d:       48 83 c3 48             add    $0x48,%rbx
    0.00 :	  4962a1:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  4962a4:       75 2d                   jne    4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  4962a6:       41 83 ec 01             sub    $0x1,%r12d
    0.00 :	  4962aa:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
    0.00 :	  4962ae:       66 85 c9                test   %cx,%cx
    0.00 :	  4962b1:       0f 8e 49 02 00 00       jle    496500 <heapgettup_pagemode+0x410>
    0.00 :	  4962b7:       49 8b 7d 58             mov    0x58(%r13),%rdi
    0.00 :	  4962bb:       0f bf f1                movswl %cx,%esi
    0.00 :	  4962be:       0f b7 47 12             movzwl 0x12(%rdi),%eax
    0.00 :	  4962c2:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  4962c7:       39 c6                   cmp    %eax,%esi
    0.00 :	  4962c9:       0f 8e 41 ff ff ff       jle    496210 <heapgettup_pagemode+0x120>
    0.00 :	  4962cf:       c6 45 d7 01             movb   $0x1,-0x29(%rbp)
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962d3:       8b 55 c0                mov    -0x40(%rbp),%edx
    0.00 :	  4962d6:       8b 45 c0                mov    -0x40(%rbp),%eax
         :	                        }
         :
         :	                        /*
         :	                         * otherwise move to the next item on the page
         :	                         */
         :	                        --linesleft;
    0.00 :	  4962d9:       83 6d c4 01             subl   $0x1,-0x3c(%rbp)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962dd:       44 8b 45 c4             mov    -0x3c(%rbp),%r8d
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962e1:       83 c2 01                add    $0x1,%edx
    0.00 :	  4962e4:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4962e7:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  4962eb:       0f 45 d0                cmovne %eax,%edx
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962ee:       45 85 c0                test   %r8d,%r8d
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962f1:       89 55 c0                mov    %edx,-0x40(%rbp)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962f4:       0f 8f 9b fe ff ff       jg     496195 <heapgettup_pagemode+0xa5>
    0.00 :	  4962fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /*
         :	                 * if we get here, it means we've exhausted the items on this page and
         :	                 * it's time to move to the next.
         :	                 */
         :	                if (backward)
    0.00 :	  496300:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  496304:       0f 84 86 02 00 00       je     496590 <heapgettup_pagemode+0x4a0>
         :	                {
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  49630a:       45 39 7d 2c             cmp    %r15d,0x2c(%r13)
    0.00 :	  49630e:       74 1c                   je     49632c <heapgettup_pagemode+0x23c>
    0.00 :	  496310:       41 8b 45 34             mov    0x34(%r13),%eax
    0.00 :	  496314:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  496317:       0f 84 15 02 00 00       je     496532 <heapgettup_pagemode+0x442>
    0.00 :	  49631d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496320:       85 c0                   test   %eax,%eax
    0.00 :	  496322:       41 89 45 34             mov    %eax,0x34(%r13)
    0.00 :	  496326:       0f 85 06 02 00 00       jne    496532 <heapgettup_pagemode+0x442>
    0.00 :	  49632c:       bb 01 00 00 00          mov    $0x1,%ebx
         :	                                (scan->rs_numblocks != InvalidBlockNumber ? --scan->rs_numblocks <= 0 : false);
         :	                        if (page == 0)
    0.00 :	  496331:       45 85 ff                test   %r15d,%r15d
    0.00 :	  496334:       75 04                   jne    49633a <heapgettup_pagemode+0x24a>
         :	                                page = scan->rs_nblocks;
    0.00 :	  496336:       45 8b 7d 28             mov    0x28(%r13),%r15d
         :	                        page--;
    0.00 :	  49633a:       41 83 ef 01             sub    $0x1,%r15d
         :	                }
         :
         :	                /*
         :	                 * return NULL if we've exhausted all the pages
         :	                 */
         :	                if (finished)
    0.00 :	  49633e:       84 db                   test   %bl,%bl
    0.00 :	  496340:       0f 85 f6 02 00 00       jne    49663c <heapgettup_pagemode+0x54c>
         :	                        tuple->t_data = NULL;
         :	                        scan->rs_inited = false;
         :	                        return;
         :	                }
         :
         :	                heapgetpage(scan, page);
    0.00 :	  496346:       44 89 fe                mov    %r15d,%esi
    0.00 :	  496349:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  49634c:       e8 0f fb ff ff          callq  495e60 <heapgetpage>
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496351:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  496355:       85 c0                   test   %eax,%eax
    0.00 :	  496357:       0f 88 bb 02 00 00       js     496618 <heapgettup_pagemode+0x528>
    0.00 :	  49635d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496360:       4c 63 f0                movslq %eax,%r14
    0.00 :	  496363:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  496367:       4c 03 35 8a 97 72 00    add    0x72978a(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :	                linesleft = lines;
         :	                if (backward)
    0.00 :	  49636e:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
         :	                }
         :
         :	                heapgetpage(scan, page);
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lines = scan->rs_ntuples;
    0.00 :	  496372:       41 8b 45 78             mov    0x78(%r13),%eax
         :	                linesleft = lines;
         :	                if (backward)
    0.00 :	  496376:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
    0.00 :	  49637d:       89 45 c4                mov    %eax,-0x3c(%rbp)
    0.00 :	  496380:       0f 84 02 fe ff ff       je     496188 <heapgettup_pagemode+0x98>
         :	                        lineindex = lines - 1;
    0.00 :	  496386:       8d 50 ff                lea    -0x1(%rax),%edx
    0.00 :	  496389:       89 45 c4                mov    %eax,-0x3c(%rbp)
    0.00 :	  49638c:       89 55 c0                mov    %edx,-0x40(%rbp)
    0.00 :	  49638f:       e9 f4 fd ff ff          jmpq   496188 <heapgettup_pagemode+0x98>
         :	        else
         :	        {
         :	                /*
         :	                 * ``no movement'' scan direction: refetch prior tuple
         :	                 */
         :	                if (!scan->rs_inited)
    0.00 :	  496394:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
    0.00 :	  496398:       74 6e                   je     496408 <heapgettup_pagemode+0x318>
         :	                        Assert(!BufferIsValid(scan->rs_cbuf));
         :	                        tuple->t_data = NULL;
         :	                        return;
         :	                }
         :
         :	                page = ItemPointerGetBlockNumber(&(tuple->t_self));
    0.00 :	  49639a:       0f b7 77 4c             movzwl 0x4c(%rdi),%esi
    0.00 :	  49639e:       0f b7 47 4e             movzwl 0x4e(%rdi),%eax
    0.00 :	  4963a2:       c1 e6 10                shl    $0x10,%esi
    0.00 :	  4963a5:       09 c6                   or     %eax,%esi
         :	                if (page != scan->rs_cblock)
    0.00 :	  4963a7:       39 77 60                cmp    %esi,0x60(%rdi)
    0.00 :	  4963aa:       74 05                   je     4963b1 <heapgettup_pagemode+0x2c1>
         :	                        heapgetpage(scan, page);
    0.00 :	  4963ac:       e8 af fa ff ff          callq  495e60 <heapgetpage>
         :
         :	                /* Since the tuple was previously fetched, needn't lock page here */
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  4963b1:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  4963b5:       85 c0                   test   %eax,%eax
    0.00 :	  4963b7:       0f 88 d8 02 00 00       js     496695 <heapgettup_pagemode+0x5a5>
    0.00 :	  4963bd:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4963c0:       48 63 c8                movslq %eax,%rcx
    0.00 :	  4963c3:       48 c1 e1 0d             shl    $0xd,%rcx
    0.00 :	  4963c7:       48 03 0d 2a 97 72 00    add    0x72972a(%rip),%rcx        # bbfaf8 <BufferBlocks>
         :	                lineoff = ItemPointerGetOffsetNumber(&(tuple->t_self));
         :	                lpp = PageGetItemId(dp, lineoff);
    0.00 :	  4963ce:       41 0f b7 45 50          movzwl 0x50(%r13),%eax
         :	                Assert(ItemIdIsNormal(lpp));
         :
         :	                tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
    0.00 :	  4963d3:       48 83 c0 03             add    $0x3,%rax
    0.00 :	  4963d7:       0f b7 54 81 08          movzwl 0x8(%rcx,%rax,4),%edx
    0.00 :	  4963dc:       81 e2 ff 7f 00 00       and    $0x7fff,%edx
    0.00 :	  4963e2:       48 8d 14 11             lea    (%rcx,%rdx,1),%rdx
    0.00 :	  4963e6:       49 89 55 58             mov    %rdx,0x58(%r13)
         :	                tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4963ea:       0f b7 44 81 0a          movzwl 0xa(%rcx,%rax,4),%eax
    0.00 :	  4963ef:       66 d1 e8                shr    %ax
    0.00 :	  4963f2:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4963f5:       41 89 45 48             mov    %eax,0x48(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  4963f9:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  4963fd:       5b                      pop    %rbx
    0.00 :	  4963fe:       41 5c                   pop    %r12
    0.00 :	  496400:       41 5d                   pop    %r13
    0.00 :	  496402:       41 5e                   pop    %r14
    0.00 :	  496404:       41 5f                   pop    %r15
    0.00 :	  496406:       c9                      leaveq 
    0.00 :	  496407:       c3                      retq   
         :	                 * ``no movement'' scan direction: refetch prior tuple
         :	                 */
         :	                if (!scan->rs_inited)
         :	                {
         :	                        Assert(!BufferIsValid(scan->rs_cbuf));
         :	                        tuple->t_data = NULL;
    0.00 :	  496408:       49 c7 45 58 00 00 00    movq   $0x0,0x58(%r13)
    0.00 :	  49640f:       00 
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496410:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  496414:       5b                      pop    %rbx
    0.00 :	  496415:       41 5c                   pop    %r12
    0.00 :	  496417:       41 5d                   pop    %r13
    0.00 :	  496419:       41 5e                   pop    %r14
    0.00 :	  49641b:       41 5f                   pop    %r15
    0.00 :	  49641d:       c9                      leaveq 
    0.00 :	  49641e:       c3                      retq   
    0.00 :	  49641f:       90                      nop
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                if (!scan->rs_inited)
    0.00 :	  496420:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
    0.00 :	  496424:       74 66                   je     49648c <heapgettup_pagemode+0x39c>
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                        lineindex = scan->rs_cindex + 1;
    0.00 :	  496426:       8b 47 70                mov    0x70(%rdi),%eax
         :	                        scan->rs_inited = true;
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:766
    7.69 :	  496429:       44 8b 7f 60             mov    0x60(%rdi),%r15d
         :	                        lineindex = scan->rs_cindex + 1;
    0.00 :	  49642d:       83 c0 01                add    $0x1,%eax
    0.00 :	  496430:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496433:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  496437:       85 c0                   test   %eax,%eax
    0.00 :	  496439:       0f 88 41 02 00 00       js     496680 <heapgettup_pagemode+0x590>
    0.00 :	  49643f:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496442:       4c 63 f0                movslq %eax,%r14
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
    7.69 :	  496445:       49 c1 e6 0d             shl    $0xd,%r14
    7.69 :	  496449:       4c 03 35 a8 96 72 00    add    0x7296a8(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :	                /* page and lineindex now reference the next visible tid */
         :
         :	                linesleft = lines - lineindex;
    0.00 :	  496450:       41 8b 55 78             mov    0x78(%r13),%edx
    0.00 :	  496454:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  496457:       29 c2                   sub    %eax,%edx
    0.00 :	  496459:       89 55 c4                mov    %edx,-0x3c(%rbp)
    0.00 :	  49645c:       e9 1a fd ff ff          jmpq   49617b <heapgettup_pagemode+0x8b>
         :	                if (!scan->rs_inited)
         :	                {
         :	                        /*
         :	                         * return null immediately if relation is empty
         :	                         */
         :	                        if (scan->rs_nblocks == 0)
    0.00 :	  496461:       44 8b 57 28             mov    0x28(%rdi),%r10d
    0.00 :	  496465:       45 85 d2                test   %r10d,%r10d
    0.00 :	  496468:       74 9e                   je     496408 <heapgettup_pagemode+0x318>
         :	                         * time, and much more likely that we'll just bollix things for
         :	                         * forward scanners.
         :	                         */
         :	                        scan->rs_syncscan = false;
         :	                        /* start from last page of the scan */
         :	                        if (scan->rs_startblock > 0)
    0.00 :	  49646a:       8b 47 2c                mov    0x2c(%rdi),%eax
         :	                         * Disable reporting to syncscan logic in a backwards scan; it's
         :	                         * not very likely anyone else is doing the same thing at the same
         :	                         * time, and much more likely that we'll just bollix things for
         :	                         * forward scanners.
         :	                         */
         :	                        scan->rs_syncscan = false;
    0.00 :	  49646d:       c6 47 40 00             movb   $0x0,0x40(%rdi)
         :	                        /* start from last page of the scan */
         :	                        if (scan->rs_startblock > 0)
    0.00 :	  496471:       85 c0                   test   %eax,%eax
    0.00 :	  496473:       75 03                   jne    496478 <heapgettup_pagemode+0x388>
         :	                                page = scan->rs_startblock - 1;
         :	                        else
         :	                                page = scan->rs_nblocks - 1;
    0.00 :	  496475:       8b 47 28                mov    0x28(%rdi),%eax
    0.00 :	  496478:       44 8d 78 ff             lea    -0x1(%rax),%r15d
         :	                        heapgetpage(scan, page);
    0.00 :	  49647c:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  49647f:       44 89 fe                mov    %r15d,%esi
    0.00 :	  496482:       e8 d9 f9 ff ff          callq  495e60 <heapgetpage>
    0.00 :	  496487:       e9 af fc ff ff          jmpq   49613b <heapgettup_pagemode+0x4b>
         :	                if (!scan->rs_inited)
         :	                {
         :	                        /*
         :	                         * return null immediately if relation is empty
         :	                         */
         :	                        if (scan->rs_nblocks == 0)
    0.00 :	  49648c:       44 8b 5f 28             mov    0x28(%rdi),%r11d
    0.00 :	  496490:       45 85 db                test   %r11d,%r11d
    0.00 :	  496493:       0f 84 6f ff ff ff       je     496408 <heapgettup_pagemode+0x318>
         :	                        {
         :	                                Assert(!BufferIsValid(scan->rs_cbuf));
         :	                                tuple->t_data = NULL;
         :	                                return;
         :	                        }
         :	                        page = scan->rs_startblock; /* first page */
    0.00 :	  496499:       44 8b 7f 2c             mov    0x2c(%rdi),%r15d
         :	                        heapgetpage(scan, page);
    0.00 :	  49649d:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4964a0:       e8 bb f9 ff ff          callq  495e60 <heapgetpage>
         :	                        lineindex = 0;
         :	                        scan->rs_inited = true;
    0.00 :	  4964a5:       41 c6 45 41 01          movb   $0x1,0x41(%r13)
    0.00 :	  4964aa:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
    0.00 :	  4964b1:       eb 80                   jmp    496433 <heapgettup_pagemode+0x343>
    0.00 :	  4964b3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4964b8:       0f bf 73 04             movswl 0x4(%rbx),%esi
    0.00 :	  4964bc:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  4964bf:       89 c8                   mov    %ecx,%eax
    0.00 :	  4964c1:       83 e1 07                and    $0x7,%ecx
    0.00 :	  4964c4:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4964c7:       48 98                   cltq   
    0.00 :	  4964c9:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  4964ce:       d3 f8                   sar    %cl,%eax
    0.00 :	  4964d0:       a8 01                   test   $0x1,%al
    0.00 :	  4964d2:       0f 84 f7 fd ff ff       je     4962cf <heapgettup_pagemode+0x1df>
    0.00 :	  4964d8:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  4964dc:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  4964e0:       48 8b 50 38             mov    0x38(%rax),%rdx
    0.00 :	  4964e4:       e8 a7 94 fd ff          callq  46f990 <nocachegetattr>
    0.00 :	  4964e9:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4964ec:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  4964f0:       0f 84 8a fd ff ff       je     496280 <heapgettup_pagemode+0x190>
    0.00 :	  4964f6:       e9 d8 fd ff ff          jmpq   4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  4964fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  496500:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  496504:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  496508:       0f bf f1                movswl %cx,%esi
    0.00 :	  49650b:       48 8d 4d d7             lea    -0x29(%rbp),%rcx
    0.00 :	  49650f:       48 8b 50 38             mov    0x38(%rax),%rdx
    0.00 :	  496513:       e8 b8 87 fd ff          callq  46ecd0 <heap_getsysattr>
    0.00 :	  496518:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49651b:       eb cf                   jmp    4964ec <heapgettup_pagemode+0x3fc>
    0.00 :	  49651d:       0f 1f 00                nopl   (%rax)
    0.00 :	  496520:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  496524:       48 98                   cltq   
    0.00 :	  496526:       48 01 d0                add    %rdx,%rax
    0.00 :	  496529:       48 8d 14 07             lea    (%rdi,%rax,1),%rdx
    0.00 :	  49652d:       e9 4e fd ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
         :	                 * if we get here, it means we've exhausted the items on this page and
         :	                 * it's time to move to the next.
         :	                 */
         :	                if (backward)
         :	                {
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  496532:       31 db                   xor    %ebx,%ebx
    0.00 :	  496534:       e9 f8 fd ff ff          jmpq   496331 <heapgettup_pagemode+0x241>
    0.00 :	  496539:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  496540:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  496544:       4c 89 c2                mov    %r8,%rdx
    0.00 :	  496547:       e8 44 94 fd ff          callq  46f990 <nocachegetattr>
    0.00 :	  49654c:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49654f:       eb 9b                   jmp    4964ec <heapgettup_pagemode+0x3fc>
    0.00 :	  496551:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  496558:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  49655c:       48 98                   cltq   
    0.00 :	  49655e:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  496562:       48 8b 14 10             mov    (%rax,%rdx,1),%rdx
    0.00 :	  496566:       e9 15 fd ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  49656b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                                        nkeys, key, valid);
         :	                                if (valid)
         :	                                {
         :	                                        scan->rs_cindex = lineindex;
    0.00 :	  496570:       8b 45 c0                mov    -0x40(%rbp),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:885
   15.38 :	  496573:       41 89 45 70             mov    %eax,0x70(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496577:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  49657b:       5b                      pop    %rbx
    0.00 :	  49657c:       41 5c                   pop    %r12
    0.00 :	  49657e:       41 5d                   pop    %r13
    0.00 :	  496580:       41 5e                   pop    %r14
    0.00 :	  496582:       41 5f                   pop    %r15
    0.00 :	  496584:       c9                      leaveq 
    0.00 :	  496585:       c3                      retq   
    0.00 :	  496586:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  49658d:       00 00 00 
         :	                                page = scan->rs_nblocks;
         :	                        page--;
         :	                }
         :	                else
         :	                {
         :	                        page++;
    0.00 :	  496590:       41 83 c7 01             add    $0x1,%r15d
         :	                        if (page >= scan->rs_nblocks)
    0.00 :	  496594:       45 3b 7d 28             cmp    0x28(%r13),%r15d
    0.00 :	  496598:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  49659d:       44 0f 43 f8             cmovae %eax,%r15d
         :	                                page = 0;
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  4965a1:       45 39 7d 2c             cmp    %r15d,0x2c(%r13)
    0.00 :	  4965a5:       74 14                   je     4965bb <heapgettup_pagemode+0x4cb>
    0.00 :	  4965a7:       41 8b 45 34             mov    0x34(%r13),%eax
    0.00 :	  4965ab:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  4965ae:       74 2c                   je     4965dc <heapgettup_pagemode+0x4ec>
    0.00 :	  4965b0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4965b3:       85 c0                   test   %eax,%eax
    0.00 :	  4965b5:       41 89 45 34             mov    %eax,0x34(%r13)
    0.00 :	  4965b9:       75 21                   jne    4965dc <heapgettup_pagemode+0x4ec>
    0.00 :	  4965bb:       bb 01 00 00 00          mov    $0x1,%ebx
         :	                         * rel.  That's not strictly necessary, but otherwise when you run
         :	                         * the same query multiple times the starting position would shift
         :	                         * a little bit backwards on every invocation, which is confusing.
         :	                         * We don't guarantee any specific ordering in general, though.
         :	                         */
         :	                        if (scan->rs_syncscan)
    0.00 :	  4965c0:       41 80 7d 40 00          cmpb   $0x0,0x40(%r13)
    0.00 :	  4965c5:       0f 84 73 fd ff ff       je     49633e <heapgettup_pagemode+0x24e>
         :	                                ss_report_location(scan->rs_rd, page);
    0.00 :	  4965cb:       49 8b 7d 00             mov    0x0(%r13),%rdi
    0.00 :	  4965cf:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4965d2:       e8 49 a8 00 00          callq  4a0e20 <ss_report_location>
    0.00 :	  4965d7:       e9 62 fd ff ff          jmpq   49633e <heapgettup_pagemode+0x24e>
         :	                else
         :	                {
         :	                        page++;
         :	                        if (page >= scan->rs_nblocks)
         :	                                page = 0;
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  4965dc:       31 db                   xor    %ebx,%ebx
    0.00 :	  4965de:       66 90                   xchg   %ax,%ax
    0.00 :	  4965e0:       eb de                   jmp    4965c0 <heapgettup_pagemode+0x4d0>
    0.00 :	  4965e2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4965e8:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  4965ec:       48 98                   cltq   
    0.00 :	  4965ee:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  4965f2:       8b 14 10                mov    (%rax,%rdx,1),%edx
    0.00 :	  4965f5:       e9 86 fc ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  4965fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  496600:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  496604:       48 98                   cltq   
    0.00 :	  496606:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  49660a:       0f b7 14 10             movzwl (%rax,%rdx,1),%edx
    0.00 :	  49660e:       e9 6d fc ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  496613:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        return;
         :	                }
         :
         :	                heapgetpage(scan, page);
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496618:       f7 d0                   not    %eax
    0.00 :	  49661a:       48 63 d0                movslq %eax,%rdx
    0.00 :	  49661d:       48 8b 05 f4 6a 6e 00    mov    0x6e6af4(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  496624:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  496628:       e9 41 fd ff ff          jmpq   49636e <heapgettup_pagemode+0x27e>
         :	                        lineindex = lines - 1;
         :	                        scan->rs_inited = true;
         :	                }
         :	                else
         :	                {
         :	                        lineindex = scan->rs_cindex - 1;
    0.00 :	  49662d:       41 8b 45 70             mov    0x70(%r13),%eax
    0.00 :	  496631:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496634:       89 45 c0                mov    %eax,-0x40(%rbp)
    0.00 :	  496637:       e9 36 fb ff ff          jmpq   496172 <heapgettup_pagemode+0x82>
         :	                /*
         :	                 * return NULL if we've exhausted all the pages
         :	                 */
         :	                if (finished)
         :	                {
         :	                        if (BufferIsValid(scan->rs_cbuf))
    0.00 :	  49663c:       41 8b 7d 64             mov    0x64(%r13),%edi
    0.00 :	  496640:       85 ff                   test   %edi,%edi
    0.00 :	  496642:       74 05                   je     496649 <heapgettup_pagemode+0x559>
         :	                                ReleaseBuffer(scan->rs_cbuf);
    0.00 :	  496644:       e8 17 e8 1d 00          callq  674e60 <ReleaseBuffer>
         :	                        scan->rs_cbuf = InvalidBuffer;
    0.00 :	  496649:       41 c7 45 64 00 00 00    movl   $0x0,0x64(%r13)
    0.00 :	  496650:       00 
         :	                        scan->rs_cblock = InvalidBlockNumber;
    0.00 :	  496651:       41 c7 45 60 ff ff ff    movl   $0xffffffff,0x60(%r13)
    0.00 :	  496658:       ff 
         :	                        tuple->t_data = NULL;
    0.00 :	  496659:       49 c7 45 58 00 00 00    movq   $0x0,0x58(%r13)
    0.00 :	  496660:       00 
         :	                        scan->rs_inited = false;
    0.00 :	  496661:       41 c6 45 41 00          movb   $0x0,0x41(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496666:       e9 a5 fd ff ff          jmpq   496410 <heapgettup_pagemode+0x320>
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  49666b:       f7 d0                   not    %eax
    0.00 :	  49666d:       48 63 d0                movslq %eax,%rdx
    0.00 :	  496670:       48 8b 05 a1 6a 6e 00    mov    0x6e6aa1(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  496677:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  49667b:       e9 d8 fa ff ff          jmpq   496158 <heapgettup_pagemode+0x68>
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                        lineindex = scan->rs_cindex + 1;
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496680:       f7 d0                   not    %eax
    0.00 :	  496682:       48 63 d0                movslq %eax,%rdx
    0.00 :	  496685:       48 8b 05 8c 6a 6e 00    mov    0x6e6a8c(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49668c:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  496690:       e9 bb fd ff ff          jmpq   496450 <heapgettup_pagemode+0x360>
         :	                page = ItemPointerGetBlockNumber(&(tuple->t_self));
         :	                if (page != scan->rs_cblock)
         :	                        heapgetpage(scan, page);
         :
         :	                /* Since the tuple was previously fetched, needn't lock page here */
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496695:       f7 d0                   not    %eax
    0.00 :	  496697:       48 63 d0                movslq %eax,%rdx
    0.00 :	  49669a:       48 8b 05 77 6a 6e 00    mov    0x6e6a77(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4966a1:       48 8b 0c d0             mov    (%rax,%rdx,8),%rcx
    0.00 :	  4966a5:       e9 24 fd ff ff          jmpq   4963ce <heapgettup_pagemode+0x2de>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   15.38 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:264
   15.38 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:398
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:214
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:260
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:266
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:269
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:269
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:284
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:287
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:224
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:389
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005baf80 <BitmapHeapNext>:
         :	 *              Retrieve next tuple from the BitmapHeapScan node's currentRelation
         :	 * ----------------------------------------------------------------
         :	 */
         :	static TupleTableSlot *
         :	BitmapHeapNext(BitmapHeapScanState *node)
         :	{
    0.00 :	  5baf80:       55                      push   %rbp
    0.00 :	  5baf81:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5baf84:       41 57                   push   %r15
    0.00 :	  5baf86:       41 56                   push   %r14
    0.00 :	  5baf88:       41 55                   push   %r13
    0.00 :	  5baf8a:       41 54                   push   %r12
    0.00 :	  5baf8c:       53                      push   %rbx
    0.00 :	  5baf8d:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5baf90:       48 81 ec d8 00 00 00    sub    $0xd8,%rsp
         :	        TupleTableSlot *slot;
         :
         :	        /*
         :	         * extract necessary information from index scan node
         :	         */
         :	        econtext = node->ss.ps.ps_ExprContext;
    0.00 :	  5baf97:       48 8b 47 60             mov    0x60(%rdi),%rax
    0.00 :	  5baf9b:       48 89 85 28 ff ff ff    mov    %rax,-0xd8(%rbp)
         :	        slot = node->ss.ss_ScanTupleSlot;
    0.00 :	  5bafa2:       48 8b 97 88 00 00 00    mov    0x88(%rdi),%rdx
    0.00 :	  5bafa9:       48 89 95 38 ff ff ff    mov    %rdx,-0xc8(%rbp)
         :	        scan = node->ss.ss_currentScanDesc;
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
    0.00 :	  5bafb0:       48 8b 8f a0 00 00 00    mov    0xa0(%rdi),%rcx
         :	        /*
         :	         * extract necessary information from index scan node
         :	         */
         :	        econtext = node->ss.ps.ps_ExprContext;
         :	        slot = node->ss.ss_ScanTupleSlot;
         :	        scan = node->ss.ss_currentScanDesc;
    0.00 :	  5bafb7:       4c 8b a7 80 00 00 00    mov    0x80(%rdi),%r12
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
    0.00 :	  5bafbe:       48 89 8d 30 ff ff ff    mov    %rcx,-0xd0(%rbp)
         :	         * desired prefetch distance, which starts small and increases up to the
         :	         * GUC-controlled maximum, target_prefetch_pages.  This is to avoid doing
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
    0.00 :	  5bafc5:       48 83 bf 98 00 00 00    cmpq   $0x0,0x98(%rdi)
    0.00 :	  5bafcc:       00 
         :	        econtext = node->ss.ps.ps_ExprContext;
         :	        slot = node->ss.ss_ScanTupleSlot;
         :	        scan = node->ss.ss_currentScanDesc;
         :	        tbm = node->tbm;
         :	        tbmiterator = node->tbmiterator;
         :	        tbmres = node->tbmres;
    0.00 :	  5bafcd:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
         :	#ifdef USE_PREFETCH
         :	        prefetch_iterator = node->prefetch_iterator;
    0.00 :	  5bafd4:       4c 8b bf c0 00 00 00    mov    0xc0(%rdi),%r15
         :	         * desired prefetch distance, which starts small and increases up to the
         :	         * GUC-controlled maximum, target_prefetch_pages.  This is to avoid doing
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
    0.00 :	  5bafdb:       0f 84 11 06 00 00       je     5bb5f2 <BitmapHeapNext+0x672>
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bafe1:       49 8d 44 24 48          lea    0x48(%r12),%rax
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5bafe6:       48 85 d2                test   %rdx,%rdx
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bafe9:       48 89 85 20 ff ff ff    mov    %rax,-0xe0(%rbp)
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5baff0:       0f 84 c4 01 00 00       je     5bb1ba <BitmapHeapNext+0x23a>
    0.00 :	  5baff6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5baffd:       00 00 00 
         :	                else
         :	                {
         :	                        /*
         :	                         * Continuing in previously obtained page; advance rs_cindex
         :	                         */
         :	                        scan->rs_cindex++;
    0.00 :	  5bb000:       41 83 44 24 70 01       addl   $0x1,0x70(%r12)
         :
         :	                        /*
         :	                         * Try to prefetch at least a few pages even before we get to the
         :	                         * second page if we don't stop reading after the first tuple.
         :	                         */
         :	                        if (node->prefetch_target < target_prefetch_pages)
    0.00 :	  5bb006:       49 89 d5                mov    %rdx,%r13
    0.00 :	  5bb009:       8b 83 cc 00 00 00       mov    0xcc(%rbx),%eax
    0.00 :	  5bb00f:       3b 05 4f 20 5c 00       cmp    0x5c204f(%rip),%eax        # b7d064 <target_prefetch_pages>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:214
    7.69 :	  5bb015:       7d 0c                   jge    5bb023 <BitmapHeapNext+0xa3>
         :	                                node->prefetch_target++;
    0.00 :	  5bb017:       83 c0 01                add    $0x1,%eax
    0.00 :	  5bb01a:       49 89 d5                mov    %rdx,%r13
    0.00 :	  5bb01d:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
         :	                }
         :
         :	                /*
         :	                 * Out of range?  If so, nothing more to look at on this page
         :	                 */
         :	                if (scan->rs_cindex < 0 || scan->rs_cindex >= scan->rs_ntuples)
    0.00 :	  5bb023:       41 8b 44 24 70          mov    0x70(%r12),%eax
    0.00 :	  5bb028:       85 c0                   test   %eax,%eax
    0.00 :	  5bb02a:       0f 88 e0 01 00 00       js     5bb210 <BitmapHeapNext+0x290>
    0.00 :	  5bb030:       41 3b 44 24 78          cmp    0x78(%r12),%eax
    0.00 :	  5bb035:       0f 8d d5 01 00 00       jge    5bb210 <BitmapHeapNext+0x290>
         :	                 * to avoid having prefetching interfere with the main I/O. Also, this
         :	                 * should happen only when we have determined there is still something
         :	                 * to do on the current page, else we may uselessly prefetch the same
         :	                 * page we are just about to request for real.
         :	                 */
         :	                if (prefetch_iterator)
    0.00 :	  5bb03b:       4d 85 ff                test   %r15,%r15
    0.00 :	  5bb03e:       74 55                   je     5bb095 <BitmapHeapNext+0x115>
         :	                {
         :	                        while (node->prefetch_pages < node->prefetch_target)
    0.00 :	  5bb040:       8b 83 cc 00 00 00       mov    0xcc(%rbx),%eax
    0.00 :	  5bb046:       3b 83 c8 00 00 00       cmp    0xc8(%rbx),%eax
    0.00 :	  5bb04c:       7f 24                   jg     5bb072 <BitmapHeapNext+0xf2>
    0.00 :	  5bb04e:       eb 45                   jmp    5bb095 <BitmapHeapNext+0x115>
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
         :	                                        break;
         :	                                }
         :	                                node->prefetch_pages++;
    0.00 :	  5bb050:       83 83 c8 00 00 00 01    addl   $0x1,0xc8(%rbx)
         :	                                PrefetchBuffer(scan->rs_rd, MAIN_FORKNUM, tbmpre->blockno);
    0.00 :	  5bb057:       31 f6                   xor    %esi,%esi
    0.00 :	  5bb059:       8b 10                   mov    (%rax),%edx
    0.00 :	  5bb05b:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb05f:       e8 6c b7 0b 00          callq  6767d0 <PrefetchBuffer>
         :	                 * to do on the current page, else we may uselessly prefetch the same
         :	                 * page we are just about to request for real.
         :	                 */
         :	                if (prefetch_iterator)
         :	                {
         :	                        while (node->prefetch_pages < node->prefetch_target)
    0.00 :	  5bb064:       8b 83 c8 00 00 00       mov    0xc8(%rbx),%eax
    0.00 :	  5bb06a:       3b 83 cc 00 00 00       cmp    0xcc(%rbx),%eax
    0.00 :	  5bb070:       7d 23                   jge    5bb095 <BitmapHeapNext+0x115>
         :	                        {
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
    0.00 :	  5bb072:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bb075:       e8 d6 82 02 00          callq  5e3350 <tbm_iterate>
         :
         :	                                if (tbmpre == NULL)
    0.00 :	  5bb07a:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb07d:       75 d1                   jne    5bb050 <BitmapHeapNext+0xd0>
         :	                                {
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
    0.00 :	  5bb07f:       4c 89 ff                mov    %r15,%rdi
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
    0.00 :	  5bb082:       45 31 ff                xor    %r15d,%r15d
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
         :
         :	                                if (tbmpre == NULL)
         :	                                {
         :	                                        /* No more pages to prefetch */
         :	                                        tbm_end_iterate(prefetch_iterator);
    0.00 :	  5bb085:       e8 86 84 02 00          callq  5e3510 <tbm_end_iterate>
         :	                                        node->prefetch_iterator = prefetch_iterator = NULL;
    0.00 :	  5bb08a:       48 c7 83 c0 00 00 00    movq   $0x0,0xc0(%rbx)
    0.00 :	  5bb091:       00 00 00 00 
         :	#endif   /* USE_PREFETCH */
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
    0.00 :	  5bb095:       49 63 44 24 70          movslq 0x70(%r12),%rax
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb09a:       41 8b 74 24 64          mov    0x64(%r12),%esi
    0.00 :	  5bb09f:       85 f6                   test   %esi,%esi
         :	#endif   /* USE_PREFETCH */
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
    0.00 :	  5bb0a1:       41 0f b7 7c 44 7c       movzwl 0x7c(%r12,%rax,2),%edi
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb0a7:       0f 88 73 01 00 00       js     5bb220 <BitmapHeapNext+0x2a0>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:260
    7.69 :	  5bb0ad:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  5bb0b0:       48 63 c8                movslq %eax,%rcx
    0.00 :	  5bb0b3:       48 c1 e1 0d             shl    $0xd,%rcx
    0.00 :	  5bb0b7:       48 03 0d 3a 4a 60 00    add    0x604a3a(%rip),%rcx        # bbfaf8 <BufferBlocks>
         :	                lp = PageGetItemId(dp, targoffset);
    0.00 :	  5bb0be:       0f b7 d7                movzwl %di,%edx
         :	                Assert(ItemIdIsNormal(lp));
         :
         :	                scan->rs_ctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb0c1:       48 83 c2 03             add    $0x3,%rdx
    0.00 :	  5bb0c5:       0f b7 44 91 08          movzwl 0x8(%rcx,%rdx,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:264
   15.38 :	  5bb0ca:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  5bb0cf:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	  5bb0d3:       49 89 44 24 58          mov    %rax,0x58(%r12)
         :	                scan->rs_ctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb0d8:       0f b7 44 91 0a          movzwl 0xa(%rcx,%rdx,4),%eax
         :	                scan->rs_ctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb0dd:       49 8b 14 24             mov    (%r12),%rdx
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lp = PageGetItemId(dp, targoffset);
         :	                Assert(ItemIdIsNormal(lp));
         :
         :	                scan->rs_ctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                scan->rs_ctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb0e1:       66 d1 e8                shr    %ax
    0.00 :	  5bb0e4:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb0e7:       41 89 44 24 48          mov    %eax,0x48(%r12)
         :	                scan->rs_ctup.t_tableOid = scan->rs_rd->rd_id;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:266
    7.69 :	  5bb0ec:       8b 42 40                mov    0x40(%rdx),%eax
    0.00 :	  5bb0ef:       41 89 44 24 54          mov    %eax,0x54(%r12)
         :	                ItemPointerSet(&scan->rs_ctup.t_self, tbmres->blockno, targoffset);
    0.00 :	  5bb0f4:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  5bb0f8:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  5bb0fb:       66 41 89 44 24 4c       mov    %ax,0x4c(%r12)
    0.00 :	  5bb101:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  5bb105:       66 41 89 7c 24 50       mov    %di,0x50(%r12)
    0.00 :	  5bb10b:       66 41 89 44 24 4e       mov    %ax,0x4e(%r12)
         :
         :	                pgstat_count_heap_fetch(scan->rs_rd);
    0.00 :	  5bb111:       48 8b 82 38 01 00 00    mov    0x138(%rdx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:269
    7.69 :	  5bb118:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb11b:       74 0a                   je     5bb127 <BitmapHeapNext+0x1a7>
    0.00 :	  5bb11d:       48 83 40 20 01          addq   $0x1,0x20(%rax)
    7.69 :	  5bb122:       41 8b 74 24 64          mov    0x64(%r12),%esi
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bb127:       89 f2                   mov    %esi,%edx
    0.00 :	  5bb129:       48 8b bd 20 ff ff ff    mov    -0xe0(%rbp),%rdi
    0.00 :	  5bb130:       48 8b b5 38 ff ff ff    mov    -0xc8(%rbp),%rsi
    0.00 :	  5bb137:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5bb139:       e8 42 93 ff ff          callq  5b4480 <ExecStoreTuple>
         :
         :	                /*
         :	                 * If we are using lossy info, we have to recheck the qual conditions
         :	                 * at every tuple.
         :	                 */
         :	                if (tbmres->recheck)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:284
    7.69 :	  5bb13e:       41 80 7d 08 00          cmpb   $0x0,0x8(%r13)
    0.00 :	  5bb143:       0f 84 b1 02 00 00       je     5bb3fa <BitmapHeapNext+0x47a>
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
    0.00 :	  5bb149:       48 8b 95 28 ff ff ff    mov    -0xd8(%rbp),%rdx
    0.00 :	  5bb150:       48 8b 8d 38 ff ff ff    mov    -0xc8(%rbp),%rcx
         :	                        ResetExprContext(econtext);
    0.00 :	  5bb157:       48 8b 7a 28             mov    0x28(%rdx),%rdi
         :	                 * If we are using lossy info, we have to recheck the qual conditions
         :	                 * at every tuple.
         :	                 */
         :	                if (tbmres->recheck)
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
    0.00 :	  5bb15b:       48 89 4a 08             mov    %rcx,0x8(%rdx)
         :	                        ResetExprContext(econtext);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:287
    7.69 :	  5bb15f:       e8 4c d8 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                        if (!ExecQual(node->bitmapqualorig, econtext, false))
    0.00 :	  5bb164:       48 8b bb 90 00 00 00    mov    0x90(%rbx),%rdi
    0.00 :	  5bb16b:       48 8b b5 28 ff ff ff    mov    -0xd8(%rbp),%rsi
    0.00 :	  5bb172:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb174:       e8 97 1d ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5bb179:       84 c0                   test   %al,%al
    0.00 :	  5bb17b:       0f 85 79 02 00 00       jne    5bb3fa <BitmapHeapNext+0x47a>
         :	                        {
         :	                                /* Fails recheck, so drop it and loop back for another */
         :	                                InstrCountFiltered2(node, 1);
    0.00 :	  5bb181:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  5bb185:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb188:       74 18                   je     5bb1a2 <BitmapHeapNext+0x222>
    0.00 :	  5bb18a:       f2 0f 10 05 c6 3f 1f    movsd  0x1f3fc6(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bb191:       00 
    0.00 :	  5bb192:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5bb199:       00 
    0.00 :	  5bb19a:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5bb1a1:       00 
         :	                                ExecClearTuple(slot);
    0.00 :	  5bb1a2:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  5bb1a9:       e8 62 8f ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	                /*
         :	                 * Set up the result slot to point to this tuple. Note that the slot
         :	                 * acquires a pin on the buffer.
         :	                 */
         :	                ExecStoreTuple(&scan->rs_ctup,
    0.00 :	  5bb1ae:       4c 89 ea                mov    %r13,%rdx
         :	                ItemId          lp;
         :
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
    0.00 :	  5bb1b1:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5bb1b4:       0f 85 46 fe ff ff       jne    5bb000 <BitmapHeapNext+0x80>
         :	                {
         :	                        node->tbmres = tbmres = tbm_iterate(tbmiterator);
    0.00 :	  5bb1ba:       48 8b bd 30 ff ff ff    mov    -0xd0(%rbp),%rdi
    0.00 :	  5bb1c1:       e8 8a 81 02 00          callq  5e3350 <tbm_iterate>
         :	                        if (tbmres == NULL)
    0.00 :	  5bb1c6:       48 85 c0                test   %rax,%rax
         :	                /*
         :	                 * Get next page of results if needed
         :	                 */
         :	                if (tbmres == NULL)
         :	                {
         :	                        node->tbmres = tbmres = tbm_iterate(tbmiterator);
    0.00 :	  5bb1c9:       49 89 c5                mov    %rax,%r13
    0.00 :	  5bb1cc:       48 89 83 a8 00 00 00    mov    %rax,0xa8(%rbx)
         :	                        if (tbmres == NULL)
    0.00 :	  5bb1d3:       0f 84 0e 02 00 00       je     5bb3e7 <BitmapHeapNext+0x467>
         :	                                /* no more entries in the bitmap */
         :	                                break;
         :	                        }
         :
         :	#ifdef USE_PREFETCH
         :	                        if (node->prefetch_pages > 0)
    0.00 :	  5bb1d9:       8b 83 c8 00 00 00       mov    0xc8(%rbx),%eax
    0.00 :	  5bb1df:       85 c0                   test   %eax,%eax
    0.00 :	  5bb1e1:       0f 8e ae 01 00 00       jle    5bb395 <BitmapHeapNext+0x415>
         :	                        {
         :	                                /* The main iterator has closed the distance by one page */
         :	                                node->prefetch_pages--;
    0.00 :	  5bb1e7:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bb1ea:       89 83 c8 00 00 00       mov    %eax,0xc8(%rbx)
    0.00 :	  5bb1f0:       41 8b 55 00             mov    0x0(%r13),%edx
    0.00 :	  5bb1f4:       89 95 7c ff ff ff       mov    %edx,-0x84(%rbp)
         :	                         * Ignore any claimed entries past what we think is the end of the
         :	                         * relation.  (This is probably not necessary given that we got at
         :	                         * least AccessShareLock on the table before performing any of the
         :	                         * indexscans, but let's be safe.)
         :	                         */
         :	                        if (tbmres->blockno >= scan->rs_nblocks)
    0.00 :	  5bb1fa:       8b 85 7c ff ff ff       mov    -0x84(%rbp),%eax
    0.00 :	  5bb200:       41 39 44 24 28          cmp    %eax,0x28(%r12)
    0.00 :	  5bb205:       77 2f                   ja     5bb236 <BitmapHeapNext+0x2b6>
    0.00 :	  5bb207:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bb20e:       00 00 
         :	                /*
         :	                 * Out of range?  If so, nothing more to look at on this page
         :	                 */
         :	                if (scan->rs_cindex < 0 || scan->rs_cindex >= scan->rs_ntuples)
         :	                {
         :	                        node->tbmres = tbmres = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:224
    7.69 :	  5bb210:       48 c7 83 a8 00 00 00    movq   $0x0,0xa8(%rbx)
    0.00 :	  5bb217:       00 00 00 00 
    0.00 :	  5bb21b:       45 31 ed                xor    %r13d,%r13d
         :	                        continue;
    0.00 :	  5bb21e:       eb 8e                   jmp    5bb1ae <BitmapHeapNext+0x22e>
         :
         :	                /*
         :	                 * Okay to fetch the tuple
         :	                 */
         :	                targoffset = scan->rs_vistuples[scan->rs_cindex];
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  5bb220:       89 f0                   mov    %esi,%eax
    0.00 :	  5bb222:       48 8b 15 ef 1e 5c 00    mov    0x5c1eef(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  5bb229:       f7 d0                   not    %eax
    0.00 :	  5bb22b:       48 98                   cltq   
    0.00 :	  5bb22d:       48 8b 0c c2             mov    (%rdx,%rax,8),%rcx
    0.00 :	  5bb231:       e9 88 fe ff ff          jmpq   5bb0be <BitmapHeapNext+0x13e>
         :	        /*
         :	         * Acquire pin on the target heap page, trading in any pin we held before.
         :	         */
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        scan->rs_cbuf = ReleaseAndReadBuffer(scan->rs_cbuf,
    0.00 :	  5bb236:       41 8b 7c 24 64          mov    0x64(%r12),%edi
    0.00 :	  5bb23b:       8b 95 7c ff ff ff       mov    -0x84(%rbp),%edx
    0.00 :	  5bb241:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb245:       e8 76 b4 0b 00          callq  6766c0 <ReleaseAndReadBuffer>
    0.00 :	  5bb24a:       89 85 78 ff ff ff       mov    %eax,-0x88(%rbp)
         :	                                                                                 scan->rs_rd,
         :	                                                                                 page);
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  5bb250:       49 8b 54 24 08          mov    0x8(%r12),%rdx
         :	        ntup = 0;
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  5bb255:       89 c6                   mov    %eax,%esi
         :	        /*
         :	         * Acquire pin on the target heap page, trading in any pin we held before.
         :	         */
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        scan->rs_cbuf = ReleaseAndReadBuffer(scan->rs_cbuf,
    0.00 :	  5bb257:       41 89 44 24 64          mov    %eax,0x64(%r12)
         :	                                                                                 scan->rs_rd,
         :	                                                                                 page);
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  5bb25c:       48 89 95 58 ff ff ff    mov    %rdx,-0xa8(%rbp)
         :	        ntup = 0;
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  5bb263:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb267:       e8 e4 43 ee ff          callq  49f650 <heap_page_prune_opt>
         :	        /*
         :	         * We must hold share lock on the buffer content while examining tuple
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
    0.00 :	  5bb26c:       8b bd 78 ff ff ff       mov    -0x88(%rbp),%edi
    0.00 :	  5bb272:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5bb277:       e8 94 94 0b 00          callq  674710 <LockBuffer>
         :
         :	        /*
         :	         * We need two separate strategies for lossy and non-lossy cases.
         :	         */
         :	        if (tbmres->ntuples >= 0)
    0.00 :	  5bb27c:       41 83 7d 04 00          cmpl   $0x0,0x4(%r13)
    0.00 :	  5bb281:       0f 8c 97 01 00 00       jl     5bb41e <BitmapHeapNext+0x49e>
         :	                 * tbmres; but we have to follow any HOT chain starting at each such
         :	                 * offset.
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
    0.00 :	  5bb287:       0f 84 c1 01 00 00       je     5bb44e <BitmapHeapNext+0x4ce>
    0.00 :	  5bb28d:       8b 8d 7c ff ff ff       mov    -0x84(%rbp),%ecx
    0.00 :	  5bb293:       0f b7 85 7c ff ff ff    movzwl -0x84(%rbp),%eax
    0.00 :	  5bb29a:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5bb29d:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb2a4:       00 00 00 
    0.00 :	  5bb2a7:       c1 e9 10                shr    $0x10,%ecx
    0.00 :	  5bb2aa:       66 89 4d 80             mov    %cx,-0x80(%rbp)
    0.00 :	  5bb2ae:       66 89 45 9e             mov    %ax,-0x62(%rbp)
    0.00 :	  5bb2b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
    0.00 :	  5bb2b8:       49 63 c6                movslq %r14d,%rax
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
    0.00 :	  5bb2bb:       0f b7 55 80             movzwl -0x80(%rbp),%edx
    0.00 :	  5bb2bf:       0f b7 4d 9e             movzwl -0x62(%rbp),%ecx
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
    0.00 :	  5bb2c3:       41 0f b7 44 45 0a       movzwl 0xa(%r13,%rax,2),%eax
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
         :	                        if (heap_hot_search_buffer(&tid, scan->rs_rd, buffer, snapshot,
    0.00 :	  5bb2c9:       c7 04 24 01 00 00 00    movl   $0x1,(%rsp)
    0.00 :	  5bb2d0:       4c 8d 45 a0             lea    -0x60(%rbp),%r8
    0.00 :	  5bb2d4:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
    0.00 :	  5bb2d8:       45 31 c9                xor    %r9d,%r9d
         :	                {
         :	                        OffsetNumber offnum = tbmres->offsets[curslot];
         :	                        ItemPointerData tid;
         :	                        HeapTupleData heapTuple;
         :
         :	                        ItemPointerSet(&tid, page, offnum);
    0.00 :	  5bb2db:       66 89 55 c0             mov    %dx,-0x40(%rbp)
    0.00 :	  5bb2df:       66 89 4d c2             mov    %cx,-0x3e(%rbp)
    0.00 :	  5bb2e3:       66 89 45 c4             mov    %ax,-0x3c(%rbp)
         :	                        if (heap_hot_search_buffer(&tid, scan->rs_rd, buffer, snapshot,
    0.00 :	  5bb2e7:       48 8b 8d 58 ff ff ff    mov    -0xa8(%rbp),%rcx
    0.00 :	  5bb2ee:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
    0.00 :	  5bb2f4:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb2f8:       e8 23 1f ee ff          callq  49d220 <heap_hot_search_buffer>
    0.00 :	  5bb2fd:       84 c0                   test   %al,%al
    0.00 :	  5bb2ff:       74 18                   je     5bb319 <BitmapHeapNext+0x399>
         :	                                                                           &heapTuple, NULL, true))
         :	                                scan->rs_vistuples[ntup++] = ItemPointerGetOffsetNumber(&tid);
    0.00 :	  5bb301:       48 63 95 54 ff ff ff    movslq -0xac(%rbp),%rdx
    0.00 :	  5bb308:       0f b7 45 c4             movzwl -0x3c(%rbp),%eax
    0.00 :	  5bb30c:       66 41 89 44 54 7c       mov    %ax,0x7c(%r12,%rdx,2)
    0.00 :	  5bb312:       83 85 54 ff ff ff 01    addl   $0x1,-0xac(%rbp)
         :	                 * tbmres; but we have to follow any HOT chain starting at each such
         :	                 * offset.
         :	                 */
         :	                int                     curslot;
         :
         :	                for (curslot = 0; curslot < tbmres->ntuples; curslot++)
    0.00 :	  5bb319:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5bb31d:       45 3b 75 04             cmp    0x4(%r13),%r14d
    0.00 :	  5bb321:       7c 95                   jl     5bb2b8 <BitmapHeapNext+0x338>
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
         :	                                                                                        buffer, snapshot);
         :	                }
         :	        }
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  5bb323:       8b bd 78 ff ff ff       mov    -0x88(%rbp),%edi
    0.00 :	  5bb329:       31 f6                   xor    %esi,%esi
    0.00 :	  5bb32b:       e8 e0 93 0b 00          callq  674710 <LockBuffer>
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
    0.00 :	  5bb330:       8b 85 54 ff ff ff       mov    -0xac(%rbp),%eax
    0.00 :	  5bb336:       41 89 44 24 78          mov    %eax,0x78(%r12)
         :	                        /*
         :	                         * Fetch the current heap page and identify candidate tuples.
         :	                         */
         :	                        bitgetpage(scan, tbmres);
         :
         :	                        if (tbmres->ntuples >= 0)
    0.00 :	  5bb33b:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  5bb33f:       85 c0                   test   %eax,%eax
    0.00 :	  5bb341:       0f 88 16 01 00 00       js     5bb45d <BitmapHeapNext+0x4dd>
         :	                                node->exact_pages++;
    0.00 :	  5bb347:       48 83 83 b0 00 00 00    addq   $0x1,0xb0(%rbx)
    0.00 :	  5bb34e:       01 
         :	                                node->lossy_pages++;
         :
         :	                        /*
         :	                         * Set rs_cindex to first slot to examine
         :	                         */
         :	                        scan->rs_cindex = 0;
    0.00 :	  5bb34f:       41 c7 44 24 70 00 00    movl   $0x0,0x70(%r12)
    0.00 :	  5bb356:       00 00 
         :	                         * Increase prefetch target if it's not yet at the max.  Note that
         :	                         * we will increase it to zero after fetching the very first
         :	                         * page/tuple, then to one after the second tuple is fetched, then
         :	                         * it doubles as later pages are fetched.
         :	                         */
         :	                        if (node->prefetch_target >= target_prefetch_pages)
    0.00 :	  5bb358:       8b 8b cc 00 00 00       mov    0xcc(%rbx),%ecx
    0.00 :	  5bb35e:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb360:       8b 15 fe 1c 5c 00       mov    0x5c1cfe(%rip),%edx        # b7d064 <target_prefetch_pages>
    0.00 :	  5bb366:       39 d1                   cmp    %edx,%ecx
    0.00 :	  5bb368:       0f 8d c2 fc ff ff       jge    5bb030 <BitmapHeapNext+0xb0>
         :	                                 /* don't increase any further */ ;
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
    0.00 :	  5bb36e:       89 d0                   mov    %edx,%eax
    0.00 :	  5bb370:       c1 e8 1f                shr    $0x1f,%eax
    0.00 :	  5bb373:       01 d0                   add    %edx,%eax
    0.00 :	  5bb375:       d1 f8                   sar    %eax
    0.00 :	  5bb377:       39 c1                   cmp    %eax,%ecx
    0.00 :	  5bb379:       0f 8d 94 00 00 00       jge    5bb413 <BitmapHeapNext+0x493>
         :	                                node->prefetch_target = target_prefetch_pages;
         :	                        else if (node->prefetch_target > 0)
    0.00 :	  5bb37f:       85 c9                   test   %ecx,%ecx
    0.00 :	  5bb381:       0f 8e 5d 02 00 00       jle    5bb5e4 <BitmapHeapNext+0x664>
         :	                                node->prefetch_target *= 2;
    0.00 :	  5bb387:       8d 04 09                lea    (%rcx,%rcx,1),%eax
    0.00 :	  5bb38a:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
    0.00 :	  5bb390:       e9 8e fc ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	                        if (node->prefetch_pages > 0)
         :	                        {
         :	                                /* The main iterator has closed the distance by one page */
         :	                                node->prefetch_pages--;
         :	                        }
         :	                        else if (prefetch_iterator)
    0.00 :	  5bb395:       4d 85 ff                test   %r15,%r15
    0.00 :	  5bb398:       0f 84 cc 00 00 00       je     5bb46a <BitmapHeapNext+0x4ea>
         :	                        {
         :	                                /* Do not let the prefetch iterator get behind the main one */
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
    0.00 :	  5bb39e:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bb3a1:       e8 aa 7f 02 00          callq  5e3350 <tbm_iterate>
         :
         :	                                if (tbmpre == NULL || tbmpre->blockno != tbmres->blockno)
    0.00 :	  5bb3a6:       48 85 c0                test   %rax,%rax
    0.00 :	  5bb3a9:       74 12                   je     5bb3bd <BitmapHeapNext+0x43d>
    0.00 :	  5bb3ab:       8b 00                   mov    (%rax),%eax
    0.00 :	  5bb3ad:       89 85 7c ff ff ff       mov    %eax,-0x84(%rbp)
    0.00 :	  5bb3b3:       41 3b 45 00             cmp    0x0(%r13),%eax
    0.00 :	  5bb3b7:       0f 84 3d fe ff ff       je     5bb1fa <BitmapHeapNext+0x27a>
         :	                                        elog(ERROR, "prefetch and main iterators are out of sync");
    0.00 :	  5bb3bd:       ba b4 b8 88 00          mov    $0x88b8b4,%edx
    0.00 :	  5bb3c2:       be 98 00 00 00          mov    $0x98,%esi
    0.00 :	  5bb3c7:       bf 72 b8 88 00          mov    $0x88b872,%edi
    0.00 :	  5bb3cc:       e8 4f 00 1c 00          callq  77b420 <elog_start>
    0.00 :	  5bb3d1:       be 88 b8 88 00          mov    $0x88b888,%esi
    0.00 :	  5bb3d6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bb3db:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb3dd:       e8 4e fe 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bb3e2:       e8 e9 e0 ea ff          callq  4694d0 <abort@plt>
         :	        }
         :
         :	        /*
         :	         * if we get here it means we are at the end of the scan..
         :	         */
         :	        return ExecClearTuple(slot);
    0.00 :	  5bb3e7:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  5bb3ee:       e8 1d 8d ff ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5bb3f3:       48 89 85 38 ff ff ff    mov    %rax,-0xc8(%rbp)
         :	}
    0.00 :	  5bb3fa:       48 8b 85 38 ff ff ff    mov    -0xc8(%rbp),%rax
    0.00 :	  5bb401:       48 81 c4 d8 00 00 00    add    $0xd8,%rsp
    0.00 :	  5bb408:       5b                      pop    %rbx
    0.00 :	  5bb409:       41 5c                   pop    %r12
    0.00 :	  5bb40b:       41 5d                   pop    %r13
    0.00 :	  5bb40d:       41 5e                   pop    %r14
    0.00 :	  5bb40f:       41 5f                   pop    %r15
    0.00 :	  5bb411:       c9                      leaveq 
    0.00 :	  5bb412:       c3                      retq   
         :	                         * it doubles as later pages are fetched.
         :	                         */
         :	                        if (node->prefetch_target >= target_prefetch_pages)
         :	                                 /* don't increase any further */ ;
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
         :	                                node->prefetch_target = target_prefetch_pages;
    0.00 :	  5bb413:       89 93 cc 00 00 00       mov    %edx,0xcc(%rbx)
    0.00 :	  5bb419:       e9 05 fc ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	        {
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  5bb41e:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
    0.00 :	  5bb424:       85 d2                   test   %edx,%edx
    0.00 :	  5bb426:       0f 88 9e 01 00 00       js     5bb5ca <BitmapHeapNext+0x64a>
    0.00 :	  5bb42c:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
    0.00 :	  5bb432:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bb435:       4c 63 c8                movslq %eax,%r9
    0.00 :	  5bb438:       49 c1 e1 0d             shl    $0xd,%r9
    0.00 :	  5bb43c:       4c 03 0d b5 46 60 00    add    0x6046b5(%rip),%r9        # bbfaf8 <BufferBlocks>
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb443:       41 0f b7 41 0c          movzwl 0xc(%r9),%eax
    0.00 :	  5bb448:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  5bb44c:       77 2b                   ja     5bb479 <BitmapHeapNext+0x4f9>
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb44e:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb455:       00 00 00 
    0.00 :	  5bb458:       e9 c6 fe ff ff          jmpq   5bb323 <BitmapHeapNext+0x3a3>
         :	                        bitgetpage(scan, tbmres);
         :
         :	                        if (tbmres->ntuples >= 0)
         :	                                node->exact_pages++;
         :	                        else
         :	                                node->lossy_pages++;
    0.00 :	  5bb45d:       48 83 83 b8 00 00 00    addq   $0x1,0xb8(%rbx)
    0.00 :	  5bb464:       01 
    0.00 :	  5bb465:       e9 e5 fe ff ff          jmpq   5bb34f <BitmapHeapNext+0x3cf>
         :	                        {
         :	                                /* Do not let the prefetch iterator get behind the main one */
         :	                                TBMIterateResult *tbmpre = tbm_iterate(prefetch_iterator);
         :
         :	                                if (tbmpre == NULL || tbmpre->blockno != tbmres->blockno)
         :	                                        elog(ERROR, "prefetch and main iterators are out of sync");
    0.00 :	  5bb46a:       41 8b 4d 00             mov    0x0(%r13),%ecx
    0.00 :	  5bb46e:       89 8d 7c ff ff ff       mov    %ecx,-0x84(%rbp)
    0.00 :	  5bb474:       e9 81 fd ff ff          jmpq   5bb1fa <BitmapHeapNext+0x27a>
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb479:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb47c:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  5bb480:       48 c1 e8 02             shr    $0x2,%rax
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb484:       66 85 c0                test   %ax,%ax
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
    0.00 :	  5bb487:       66 89 85 40 ff ff ff    mov    %ax,-0xc0(%rbp)
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb48e:       74 be                   je     5bb44e <BitmapHeapNext+0x4ce>
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb490:       8b 85 7c ff ff ff       mov    -0x84(%rbp),%eax
    0.00 :	  5bb496:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  5bb49c:       c7 85 54 ff ff ff 00    movl   $0x0,-0xac(%rbp)
    0.00 :	  5bb4a3:       00 00 00 
    0.00 :	  5bb4a6:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  5bb4a9:       66 89 85 60 ff ff ff    mov    %ax,-0xa0(%rbp)
    0.00 :	  5bb4b0:       eb 18                   jmp    5bb4ca <BitmapHeapNext+0x54a>
    0.00 :	  5bb4b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
         :	                        }
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  5bb4b8:       41 83 c6 01             add    $0x1,%r14d
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
         :	                OffsetNumber maxoff = PageGetMaxOffsetNumber(dp);
         :	                OffsetNumber offnum;
         :
         :	                for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum))
    0.00 :	  5bb4bc:       66 44 3b b5 40 ff ff    cmp    -0xc0(%rbp),%r14w
    0.00 :	  5bb4c3:       ff 
    0.00 :	  5bb4c4:       0f 87 59 fe ff ff       ja     5bb323 <BitmapHeapNext+0x3a3>
         :	                {
         :	                        ItemId          lp;
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        lp = PageGetItemId(dp, offnum);
    0.00 :	  5bb4ca:       41 0f b7 c6             movzwl %r14w,%eax
         :	                        if (!ItemIdIsNormal(lp))
    0.00 :	  5bb4ce:       48 8d 50 03             lea    0x3(%rax),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:389
    7.69 :	  5bb4d2:       41 8b 44 91 08          mov    0x8(%r9,%rdx,4),%eax
    0.00 :	  5bb4d7:       25 00 80 01 00          and    $0x18000,%eax
    0.00 :	  5bb4dc:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  5bb4e1:       75 d5                   jne    5bb4b8 <BitmapHeapNext+0x538>
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb4e3:       41 0f b7 44 91 08       movzwl 0x8(%r9,%rdx,4),%eax
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb4e9:       0f b7 8d 7c ff ff ff    movzwl -0x84(%rbp),%ecx
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb4f0:       48 8d 7d a0             lea    -0x60(%rbp),%rdi
    0.00 :	  5bb4f4:       48 8b b5 58 ff ff ff    mov    -0xa8(%rbp),%rsi
         :	                        bool            valid;
         :
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
    0.00 :	  5bb4fb:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  5bb500:       49 8d 04 01             lea    (%r9,%rax,1),%rax
    0.00 :	  5bb504:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	                        loctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb508:       41 0f b7 44 91 0a       movzwl 0xa(%r9,%rdx,4),%eax
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb50e:       0f b7 95 60 ff ff ff    movzwl -0xa0(%rbp),%edx
         :
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
    0.00 :	  5bb515:       66 d1 e8                shr    %ax
    0.00 :	  5bb518:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  5bb51b:       89 45 a0                mov    %eax,-0x60(%rbp)
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb51e:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  5bb522:       8b 40 40                mov    0x40(%rax),%eax
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb525:       66 89 55 a4             mov    %dx,-0x5c(%rbp)
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb529:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
    0.00 :	  5bb530:       66 89 4d a6             mov    %cx,-0x5a(%rbp)
    0.00 :	  5bb534:       66 44 89 75 a8          mov    %r14w,-0x58(%rbp)
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb539:       8b 95 78 ff ff ff       mov    -0x88(%rbp),%edx
         :	                        lp = PageGetItemId(dp, offnum);
         :	                        if (!ItemIdIsNormal(lp))
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
    0.00 :	  5bb53f:       89 45 ac                mov    %eax,-0x54(%rbp)
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb542:       ff 16                   callq  *(%rsi)
         :	                        if (valid)
    0.00 :	  5bb544:       84 c0                   test   %al,%al
         :	                                continue;
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lp);
         :	                        loctup.t_len = ItemIdGetLength(lp);
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  5bb546:       41 89 c0                mov    %eax,%r8d
         :	                        if (valid)
    0.00 :	  5bb549:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb550:       75 31                   jne    5bb583 <BitmapHeapNext+0x603>
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
         :	                        }
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  5bb552:       41 0f be f8             movsbl %r8b,%edi
    0.00 :	  5bb556:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  5bb55a:       4c 8b 85 58 ff ff ff    mov    -0xa8(%rbp),%r8
    0.00 :	  5bb561:       8b 8d 78 ff ff ff       mov    -0x88(%rbp),%ecx
    0.00 :	  5bb567:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
    0.00 :	  5bb56b:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
    0.00 :	  5bb572:       e8 e9 90 0d 00          callq  694660 <CheckForSerializableConflictOut>
    0.00 :	  5bb577:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb57e:       e9 35 ff ff ff          jmpq   5bb4b8 <BitmapHeapNext+0x538>
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
    0.00 :	  5bb583:       48 63 85 54 ff ff ff    movslq -0xac(%rbp),%rax
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
    0.00 :	  5bb58a:       48 8d 75 a0             lea    -0x60(%rbp),%rsi
         :	                        loctup.t_tableOid = scan->rs_rd->rd_id;
         :	                        ItemPointerSet(&loctup.t_self, page, offnum);
         :	                        valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :	                        if (valid)
         :	                        {
         :	                                scan->rs_vistuples[ntup++] = offnum;
    0.00 :	  5bb58e:       66 45 89 74 44 7c       mov    %r14w,0x7c(%r12,%rax,2)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeBitmapHeapscan.c:398
   15.38 :	  5bb594:       83 85 54 ff ff ff 01    addl   $0x1,-0xac(%rbp)
         :	                                PredicateLockTuple(scan->rs_rd, &loctup, snapshot);
    0.00 :	  5bb59b:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5bb59f:       48 8b 95 58 ff ff ff    mov    -0xa8(%rbp),%rdx
    0.00 :	  5bb5a6:       44 88 85 18 ff ff ff    mov    %r8b,-0xe8(%rbp)
    0.00 :	  5bb5ad:       4c 89 8d 10 ff ff ff    mov    %r9,-0xf0(%rbp)
    0.00 :	  5bb5b4:       e8 e7 95 0d 00          callq  694ba0 <PredicateLockTuple>
    0.00 :	  5bb5b9:       4c 8b 8d 10 ff ff ff    mov    -0xf0(%rbp),%r9
    0.00 :	  5bb5c0:       44 0f b6 85 18 ff ff    movzbl -0xe8(%rbp),%r8d
    0.00 :	  5bb5c7:       ff 
    0.00 :	  5bb5c8:       eb 88                   jmp    5bb552 <BitmapHeapNext+0x5d2>
         :	        {
         :	                /*
         :	                 * Bitmap is lossy, so we must examine each item pointer on the page.
         :	                 * But we can ignore HOT chains, since we'll check each tuple anyway.
         :	                 */
         :	                Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  5bb5ca:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
    0.00 :	  5bb5d0:       48 8b 15 41 1b 5c 00    mov    0x5c1b41(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  5bb5d7:       f7 d0                   not    %eax
    0.00 :	  5bb5d9:       48 98                   cltq   
    0.00 :	  5bb5db:       4c 8b 0c c2             mov    (%rdx,%rax,8),%r9
    0.00 :	  5bb5df:       e9 5f fe ff ff          jmpq   5bb443 <BitmapHeapNext+0x4c3>
         :	                        else if (node->prefetch_target >= target_prefetch_pages / 2)
         :	                                node->prefetch_target = target_prefetch_pages;
         :	                        else if (node->prefetch_target > 0)
         :	                                node->prefetch_target *= 2;
         :	                        else
         :	                                node->prefetch_target++;
    0.00 :	  5bb5e4:       8d 41 01                lea    0x1(%rcx),%eax
    0.00 :	  5bb5e7:       89 83 cc 00 00 00       mov    %eax,0xcc(%rbx)
    0.00 :	  5bb5ed:       e9 31 fa ff ff          jmpq   5bb023 <BitmapHeapNext+0xa3>
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
         :	        {
         :	                tbm = (TIDBitmap *) MultiExecProcNode(outerPlanState(node));
    0.00 :	  5bb5f2:       48 8b 7f 30             mov    0x30(%rdi),%rdi
    0.00 :	  5bb5f6:       e8 d5 0d ff ff          callq  5ac3d0 <MultiExecProcNode>
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
    0.00 :	  5bb5fb:       48 85 c0                test   %rax,%rax
         :	         * a lot of prefetching in a scan that stops after a few tuples because of
         :	         * a LIMIT.
         :	         */
         :	        if (tbm == NULL)
         :	        {
         :	                tbm = (TIDBitmap *) MultiExecProcNode(outerPlanState(node));
    0.00 :	  5bb5fe:       49 89 c5                mov    %rax,%r13
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
    0.00 :	  5bb601:       74 08                   je     5bb60b <BitmapHeapNext+0x68b>
    0.00 :	  5bb603:       81 38 ba 03 00 00       cmpl   $0x3ba,(%rax)
    0.00 :	  5bb609:       74 2a                   je     5bb635 <BitmapHeapNext+0x6b5>
         :	                        elog(ERROR, "unrecognized result from subplan");
    0.00 :	  5bb60b:       ba b4 b8 88 00          mov    $0x88b8b4,%edx
    0.00 :	  5bb610:       be 6b 00 00 00          mov    $0x6b,%esi
    0.00 :	  5bb615:       bf 72 b8 88 00          mov    $0x88b872,%edi
    0.00 :	  5bb61a:       e8 01 fe 1b 00          callq  77b420 <elog_start>
    0.00 :	  5bb61f:       be c0 b7 88 00          mov    $0x88b7c0,%esi
    0.00 :	  5bb624:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bb629:       31 c0                   xor    %eax,%eax
    0.00 :	  5bb62b:       e8 00 fc 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bb630:       e8 9b de ea ff          callq  4694d0 <abort@plt>
         :
         :	                node->tbm = tbm;
    0.00 :	  5bb635:       48 89 83 98 00 00 00    mov    %rax,0x98(%rbx)
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb63c:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5bb63f:       e8 dc 7e 02 00          callq  5e3520 <tbm_begin_iterate>
         :	                node->tbmres = tbmres = NULL;
    0.00 :	  5bb644:       48 c7 83 a8 00 00 00    movq   $0x0,0xa8(%rbx)
    0.00 :	  5bb64b:       00 00 00 00 
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
         :	                        elog(ERROR, "unrecognized result from subplan");
         :
         :	                node->tbm = tbm;
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb64f:       48 89 83 a0 00 00 00    mov    %rax,0xa0(%rbx)
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
    0.00 :	  5bb656:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb658:       8b 0d 06 1a 5c 00       mov    0x5c1a06(%rip),%ecx        # b7d064 <target_prefetch_pages>
         :
         :	                if (!tbm || !IsA(tbm, TIDBitmap))
         :	                        elog(ERROR, "unrecognized result from subplan");
         :
         :	                node->tbm = tbm;
         :	                node->tbmiterator = tbmiterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb65e:       48 89 85 30 ff ff ff    mov    %rax,-0xd0(%rbp)
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
    0.00 :	  5bb665:       85 c9                   test   %ecx,%ecx
    0.00 :	  5bb667:       0f 8e 74 f9 ff ff       jle    5bafe1 <BitmapHeapNext+0x61>
         :	                {
         :	                        node->prefetch_iterator = prefetch_iterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb66d:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5bb670:       e8 ab 7e 02 00          callq  5e3520 <tbm_begin_iterate>
         :	                        node->prefetch_pages = 0;
    0.00 :	  5bb675:       c7 83 c8 00 00 00 00    movl   $0x0,0xc8(%rbx)
    0.00 :	  5bb67c:       00 00 00 
         :	                node->tbmres = tbmres = NULL;
         :
         :	#ifdef USE_PREFETCH
         :	                if (target_prefetch_pages > 0)
         :	                {
         :	                        node->prefetch_iterator = prefetch_iterator = tbm_begin_iterate(tbm);
    0.00 :	  5bb67f:       49 89 c7                mov    %rax,%r15
    0.00 :	  5bb682:       48 89 83 c0 00 00 00    mov    %rax,0xc0(%rbx)
         :	                        node->prefetch_pages = 0;
         :	                        node->prefetch_target = -1;
    0.00 :	  5bb689:       c7 83 cc 00 00 00 ff    movl   $0xffffffff,0xcc(%rbx)
    0.00 :	  5bb690:       ff ff ff 
    0.00 :	  5bb693:       31 d2                   xor    %edx,%edx
    0.00 :	  5bb695:       e9 47 f9 ff ff          jmpq   5bafe1 <BitmapHeapNext+0x61>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:56
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:53
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:53
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:53
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:56
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:63
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b7f00 <InstrStartNode>:
         :	}
         :
         :	/* Entry to a plan node */
         :	void
         :	InstrStartNode(Instrumentation *instr)
         :	{
    0.00 :	  5b7f00:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:53
    8.33 :	  5b7f01:       48 89 e5                mov    %rsp,%rbp
    8.33 :	  5b7f04:       53                      push   %rbx
    0.00 :	  5b7f05:       48 89 fb                mov    %rdi,%rbx
    8.33 :	  5b7f08:       48 83 ec 08             sub    $0x8,%rsp
         :	        if (instr->need_timer)
    0.00 :	  5b7f0c:       80 3f 00                cmpb   $0x0,(%rdi)
    0.00 :	  5b7f0f:       74 4a                   je     5b7f5b <InstrStartNode+0x5b>
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:56
    8.33 :	  5b7f11:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
   16.67 :	  5b7f16:       75 07                   jne    5b7f1f <InstrStartNode+0x1f>
    0.00 :	  5b7f18:       48 83 7f 08 00          cmpq   $0x0,0x8(%rdi)
    0.00 :	  5b7f1d:       74 31                   je     5b7f50 <InstrStartNode+0x50>
         :	                        INSTR_TIME_SET_CURRENT(instr->starttime);
         :	                else
         :	                        elog(ERROR, "InstrStartNode called twice in a row");
    0.00 :	  5b7f1f:       ba 98 b6 88 00          mov    $0x88b698,%edx
    0.00 :	  5b7f24:       be 3b 00 00 00          mov    $0x3b,%esi
    0.00 :	  5b7f29:       bf fa b5 88 00          mov    $0x88b5fa,%edi
    0.00 :	  5b7f2e:       e8 ed 34 1c 00          callq  77b420 <elog_start>
    0.00 :	  5b7f33:       be 58 b6 88 00          mov    $0x88b658,%esi
    0.00 :	  5b7f38:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b7f3d:       31 c0                   xor    %eax,%eax
    0.00 :	  5b7f3f:       e8 ec 32 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5b7f44:       e8 87 15 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5b7f49:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	InstrStartNode(Instrumentation *instr)
         :	{
         :	        if (instr->need_timer)
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
         :	                        INSTR_TIME_SET_CURRENT(instr->starttime);
    0.00 :	  5b7f50:       48 8d 7f 08             lea    0x8(%rdi),%rdi
    0.00 :	  5b7f54:       31 f6                   xor    %esi,%esi
    0.00 :	  5b7f56:       e8 65 16 eb ff          callq  4695c0 <gettimeofday@plt>
         :	                else
         :	                        elog(ERROR, "InstrStartNode called twice in a row");
         :	        }
         :
         :	        /* save buffer usage totals at node entry, if needed */
         :	        if (instr->need_bufusage)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:63
    8.33 :	  5b7f5b:       80 7b 01 00             cmpb   $0x0,0x1(%rbx)
    0.00 :	  5b7f5f:       0f 84 a9 00 00 00       je     5b800e <InstrStartNode+0x10e>
         :	                instr->bufusage_start = pgBufferUsage;
    0.00 :	  5b7f65:       48 8b 05 f4 77 60 00    mov    0x6077f4(%rip),%rax        # bbf760 <pgBufferUsage>
    0.00 :	  5b7f6c:       48 89 43 38             mov    %rax,0x38(%rbx)
    0.00 :	  5b7f70:       48 8b 05 f1 77 60 00    mov    0x6077f1(%rip),%rax        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  5b7f77:       48 89 43 40             mov    %rax,0x40(%rbx)
    0.00 :	  5b7f7b:       48 8b 05 ee 77 60 00    mov    0x6077ee(%rip),%rax        # bbf770 <pgBufferUsage+0x10>
    0.00 :	  5b7f82:       48 89 43 48             mov    %rax,0x48(%rbx)
    0.00 :	  5b7f86:       48 8b 05 eb 77 60 00    mov    0x6077eb(%rip),%rax        # bbf778 <pgBufferUsage+0x18>
    0.00 :	  5b7f8d:       48 89 43 50             mov    %rax,0x50(%rbx)
    0.00 :	  5b7f91:       48 8b 05 e8 77 60 00    mov    0x6077e8(%rip),%rax        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  5b7f98:       48 89 43 58             mov    %rax,0x58(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
    8.33 :	  5b7f9c:       48 8b 05 e5 77 60 00    mov    0x6077e5(%rip),%rax        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  5b7fa3:       48 89 43 60             mov    %rax,0x60(%rbx)
    0.00 :	  5b7fa7:       48 8b 05 e2 77 60 00    mov    0x6077e2(%rip),%rax        # bbf790 <pgBufferUsage+0x30>
    0.00 :	  5b7fae:       48 89 43 68             mov    %rax,0x68(%rbx)
    0.00 :	  5b7fb2:       48 8b 05 df 77 60 00    mov    0x6077df(%rip),%rax        # bbf798 <pgBufferUsage+0x38>
    0.00 :	  5b7fb9:       48 89 43 70             mov    %rax,0x70(%rbx)
    0.00 :	  5b7fbd:       48 8b 05 dc 77 60 00    mov    0x6077dc(%rip),%rax        # bbf7a0 <pgBufferUsage+0x40>
    0.00 :	  5b7fc4:       48 89 43 78             mov    %rax,0x78(%rbx)
    0.00 :	  5b7fc8:       48 8b 05 d9 77 60 00    mov    0x6077d9(%rip),%rax        # bbf7a8 <pgBufferUsage+0x48>
    0.00 :	  5b7fcf:       48 89 83 80 00 00 00    mov    %rax,0x80(%rbx)
    0.00 :	  5b7fd6:       48 8b 05 d3 77 60 00    mov    0x6077d3(%rip),%rax        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  5b7fdd:       48 89 83 88 00 00 00    mov    %rax,0x88(%rbx)
    8.33 :	  5b7fe4:       48 8b 05 cd 77 60 00    mov    0x6077cd(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    8.33 :	  5b7feb:       48 89 83 90 00 00 00    mov    %rax,0x90(%rbx)
    0.00 :	  5b7ff2:       48 8b 05 c7 77 60 00    mov    0x6077c7(%rip),%rax        # bbf7c0 <pgBufferUsage+0x60>
    0.00 :	  5b7ff9:       48 89 83 98 00 00 00    mov    %rax,0x98(%rbx)
   16.67 :	  5b8000:       48 8b 05 c1 77 60 00    mov    0x6077c1(%rip),%rax        # bbf7c8 <pgBufferUsage+0x68>
    0.00 :	  5b8007:       48 89 83 a0 00 00 00    mov    %rax,0xa0(%rbx)
         :	}
    0.00 :	  5b800e:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5b8012:       5b                      pop    %rbx
    0.00 :	  5b8013:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   18.18 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2610
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2542
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2617
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2617
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2618
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2619
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2633
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2639
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2619
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2617
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b0d90 <ExecEvalScalarArrayOp>:
         :	 */
         :	static Datum
         :	ExecEvalScalarArrayOp(ScalarArrayOpExprState *sstate,
         :	                                          ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5b0d90:       55                      push   %rbp
    0.00 :	  5b0d91:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b0d94:       41 57                   push   %r15
    0.00 :	  5b0d96:       41 56                   push   %r14
    0.00 :	  5b0d98:       41 55                   push   %r13
    0.00 :	  5b0d9a:       41 54                   push   %r12
    0.00 :	  5b0d9c:       49 89 f4                mov    %rsi,%r12
    0.00 :	  5b0d9f:       53                      push   %rbx
    0.00 :	  5b0da0:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b0da3:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  5b0da7:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        ScalarArrayOpExpr *opexpr = (ScalarArrayOpExpr *) sstate->fxprstate.xprstate.expr;
    0.00 :	  5b0dab:       48 8b 47 08             mov    0x8(%rdi),%rax
         :	        bits8      *bitmap;
         :	        int                     bitmask;
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
         :	        if (isDone)
    0.00 :	  5b0daf:       48 85 c9                test   %rcx,%rcx
         :	ExecEvalScalarArrayOp(ScalarArrayOpExprState *sstate,
         :	                                          ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        ScalarArrayOpExpr *opexpr = (ScalarArrayOpExpr *) sstate->fxprstate.xprstate.expr;
         :	        bool            useOr = opexpr->useOr;
    0.00 :	  5b0db2:       0f b6 50 0c             movzbl 0xc(%rax),%edx
    0.00 :	  5b0db6:       88 55 bf                mov    %dl,-0x41(%rbp)
         :	        char       *s;
         :	        bits8      *bitmap;
         :	        int                     bitmask;
         :
         :	        /* Set default values for result flags: non-null, not a set result */
         :	        *isNull = false;
    0.00 :	  5b0db9:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b0dbd:       c6 02 00                movb   $0x0,(%rdx)
         :	        if (isDone)
    0.00 :	  5b0dc0:       74 06                   je     5b0dc8 <ExecEvalScalarArrayOp+0x38>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b0dc2:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /*
         :	         * Initialize function cache if first time through
         :	         */
         :	        if (sstate->fxprstate.func.fn_oid == InvalidOid)
    0.00 :	  5b0dc8:       44 8b 43 28             mov    0x28(%rbx),%r8d
    0.00 :	  5b0dcc:       45 85 c0                test   %r8d,%r8d
    0.00 :	  5b0dcf:       0f 84 43 02 00 00       je     5b1018 <ExecEvalScalarArrayOp+0x288>
         :	        }
         :
         :	        /*
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
    0.00 :	  5b0dd5:       48 8d 4b 70             lea    0x70(%rbx),%rcx
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
    0.00 :	  5b0dd9:       4c 89 e2                mov    %r12,%rdx
         :	        }
         :
         :	        /*
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
    0.00 :	  5b0ddc:       48 89 4d c8             mov    %rcx,-0x38(%rbp)
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
    0.00 :	  5b0de0:       48 8b 73 18             mov    0x18(%rbx),%rsi
    0.00 :	  5b0de4:       48 89 cf                mov    %rcx,%rdi
    0.00 :	  5b0de7:       e8 44 c6 ff ff          callq  5ad430 <ExecEvalFuncArgs>
         :	        if (argDone != ExprSingleResult)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2542
    9.09 :	  5b0dec:       85 c0                   test   %eax,%eax
    0.00 :	  5b0dee:       0f 85 a0 03 00 00       jne    5b1194 <ExecEvalScalarArrayOp+0x404>
         :
         :	        /*
         :	         * If the array is NULL then we return NULL --- it's not very meaningful
         :	         * to do anything else, even if the operator isn't strict.
         :	         */
         :	        if (fcinfo->argnull[1])
    0.00 :	  5b0df4:       80 bb b1 03 00 00 00    cmpb   $0x0,0x3b1(%rbx)
    0.00 :	  5b0dfb:       74 1b                   je     5b0e18 <ExecEvalScalarArrayOp+0x88>
         :	        {
         :	                *isNull = true;
    0.00 :	  5b0dfd:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5b0e01:       c6 00 01                movb   $0x1,(%rax)
    0.00 :	  5b0e04:       31 c0                   xor    %eax,%eax
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b0e06:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5b0e0a:       5b                      pop    %rbx
    0.00 :	  5b0e0b:       41 5c                   pop    %r12
    0.00 :	  5b0e0d:       41 5d                   pop    %r13
    0.00 :	  5b0e0f:       41 5e                   pop    %r14
    0.00 :	  5b0e11:       41 5f                   pop    %r15
    0.00 :	  5b0e13:       c9                      leaveq 
    0.00 :	  5b0e14:       c3                      retq   
    0.00 :	  5b0e15:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                *isNull = true;
         :	                return (Datum) 0;
         :	        }
         :	        /* Else okay to fetch and detoast the array */
         :	        arr = DatumGetArrayTypeP(fcinfo->arg[1]);
    0.00 :	  5b0e18:       48 8b bb 98 00 00 00    mov    0x98(%rbx),%rdi
    0.00 :	  5b0e1f:       e8 ec de 1c 00          callq  77ed10 <pg_detoast_datum>
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e24:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  5b0e27:       48 8d 70 10             lea    0x10(%rax),%rsi
         :	        {
         :	                *isNull = true;
         :	                return (Datum) 0;
         :	        }
         :	        /* Else okay to fetch and detoast the array */
         :	        arr = DatumGetArrayTypeP(fcinfo->arg[1]);
    0.00 :	  5b0e2b:       49 89 c5                mov    %rax,%r13
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e2e:       e8 1d 35 11 00          callq  6c4350 <ArrayGetNItems>
         :	        if (nitems <= 0)
    0.00 :	  5b0e33:       85 c0                   test   %eax,%eax
         :	         * If the array is empty, we return either FALSE or TRUE per the useOr
         :	         * flag.  This is correct even if the scalar is NULL; since we would
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
    0.00 :	  5b0e35:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	        if (nitems <= 0)
    0.00 :	  5b0e38:       0f 8e 3a 03 00 00       jle    5b1178 <ExecEvalScalarArrayOp+0x3e8>
         :
         :	        /*
         :	         * If the scalar is NULL, and the function is strict, return NULL; no
         :	         * point in iterating the loop.
         :	         */
         :	        if (fcinfo->argnull[0] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0e3e:       80 bb b0 03 00 00 00    cmpb   $0x0,0x3b0(%rbx)
    0.00 :	  5b0e45:       0f 85 f5 01 00 00       jne    5b1040 <ExecEvalScalarArrayOp+0x2b0>
         :
         :	        /*
         :	         * We arrange to look up info about the element type only once per series
         :	         * of calls, assuming the element type doesn't change underneath us.
         :	         */
         :	        if (sstate->element_type != ARR_ELEMTYPE(arr))
    0.00 :	  5b0e4b:       41 8b 7d 0c             mov    0xc(%r13),%edi
    0.00 :	  5b0e4f:       39 bb 18 04 00 00       cmp    %edi,0x418(%rbx)
    0.00 :	  5b0e55:       74 24                   je     5b0e7b <ExecEvalScalarArrayOp+0xeb>
         :	        {
         :	                get_typlenbyvalalign(ARR_ELEMTYPE(arr),
    0.00 :	  5b0e57:       48 8d 8b 1f 04 00 00    lea    0x41f(%rbx),%rcx
    0.00 :	  5b0e5e:       48 8d 93 1e 04 00 00    lea    0x41e(%rbx),%rdx
    0.00 :	  5b0e65:       48 8d b3 1c 04 00 00    lea    0x41c(%rbx),%rsi
    0.00 :	  5b0e6c:       e8 ff 1f 1c 00          callq  772e70 <get_typlenbyvalalign>
         :	                                                         &sstate->typlen,
         :	                                                         &sstate->typbyval,
         :	                                                         &sstate->typalign);
         :	                sstate->element_type = ARR_ELEMTYPE(arr);
    0.00 :	  5b0e71:       41 8b 45 0c             mov    0xc(%r13),%eax
    0.00 :	  5b0e75:       89 83 18 04 00 00       mov    %eax,0x418(%rbx)
         :	        }
         :	        typlen = sstate->typlen;
    0.00 :	  5b0e7b:       0f b7 8b 1c 04 00 00    movzwl 0x41c(%rbx),%ecx
    0.00 :	  5b0e82:       66 89 4d d4             mov    %cx,-0x2c(%rbp)
         :	        typbyval = sstate->typbyval;
    0.00 :	  5b0e86:       0f b6 83 1e 04 00 00    movzbl 0x41e(%rbx),%eax
    0.00 :	  5b0e8d:       88 45 d6                mov    %al,-0x2a(%rbp)
         :	        typalign = sstate->typalign;
    0.00 :	  5b0e90:       0f b6 93 1f 04 00 00    movzbl 0x41f(%rbx),%edx
    0.00 :	  5b0e97:       88 55 d7                mov    %dl,-0x29(%rbp)
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b0e9a:       41 8b 45 08             mov    0x8(%r13),%eax
    0.00 :	  5b0e9e:       85 c0                   test   %eax,%eax
    0.00 :	  5b0ea0:       0f 84 ba 02 00 00       je     5b1160 <ExecEvalScalarArrayOp+0x3d0>
    0.00 :	  5b0ea6:       48 98                   cltq   
    0.00 :	  5b0ea8:       4d 8d 64 05 00          lea    0x0(%r13,%rax,1),%r12
         :	        bitmap = ARR_NULLBITMAP(arr);
    0.00 :	  5b0ead:       49 63 45 04             movslq 0x4(%r13),%rax
    0.00 :	  5b0eb1:       4d 8d 7c c5 10          lea    0x10(%r13,%rax,8),%r15
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0eb6:       48 0f bf 4d d4          movswq -0x2c(%rbp),%rcx
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b0ebb:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b0ebf:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5b0ec2:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0ec8:       48 89 4d a8             mov    %rcx,-0x58(%rbp)
    0.00 :	  5b0ecc:       eb 47                   jmp    5b0f15 <ExecEvalScalarArrayOp+0x185>
    0.00 :	  5b0ece:       66 90                   xchg   %ax,%ax
         :	                        fcinfo->arg[1] = elt;
         :	                        fcinfo->argnull[1] = false;
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0ed0:       80 7b 2e 00             cmpb   $0x0,0x2e(%rbx)
         :	                Datum           thisresult;
         :
         :	                /* Get array element, checking for NULL */
         :	                if (bitmap && (*bitmap & bitmask) == 0)
         :	                {
         :	                        fcinfo->arg[1] = (Datum) 0;
    0.00 :	  5b0ed4:       48 c7 83 98 00 00 00    movq   $0x0,0x98(%rbx)
    0.00 :	  5b0edb:       00 00 00 00 
         :	                        fcinfo->argnull[1] = true;
    0.00 :	  5b0edf:       c6 83 b1 03 00 00 01    movb   $0x1,0x3b1(%rbx)
         :	                        fcinfo->arg[1] = elt;
         :	                        fcinfo->argnull[1] = false;
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b0ee6:       0f 84 a5 00 00 00       je     5b0f91 <ExecEvalScalarArrayOp+0x201>
         :	                }
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
    0.00 :	  5b0eec:       45 01 ed                add    %r13d,%r13d
         :	                }
         :
         :	                /* Call comparison function */
         :	                if (fcinfo->argnull[1] && sstate->fxprstate.func.fn_strict)
         :	                {
         :	                        fcinfo->isnull = true;
    0.00 :	  5b0eef:       c6 83 8c 00 00 00 01    movb   $0x1,0x8c(%rbx)
    0.00 :	  5b0ef6:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
         :	                        if (bitmask == 0x100)
    0.00 :	  5b0efa:       41 81 fd 00 01 00 00    cmp    $0x100,%r13d
    0.00 :	  5b0f01:       0f 84 d3 00 00 00       je     5b0fda <ExecEvalScalarArrayOp+0x24a>
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0f07:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5b0f0b:       44 39 75 c0             cmp    %r14d,-0x40(%rbp)
    0.00 :	  5b0f0f:       0f 8e dc 00 00 00       jle    5b0ff1 <ExecEvalScalarArrayOp+0x261>
         :	        {
         :	                Datum           elt;
         :	                Datum           thisresult;
         :
         :	                /* Get array element, checking for NULL */
         :	                if (bitmap && (*bitmap & bitmask) == 0)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2610
   18.18 :	  5b0f15:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b0f18:       74 09                   je     5b0f23 <ExecEvalScalarArrayOp+0x193>
    0.00 :	  5b0f1a:       41 0f b6 07             movzbl (%r15),%eax
    0.00 :	  5b0f1e:       44 85 e8                test   %r13d,%eax
    0.00 :	  5b0f21:       74 ad                   je     5b0ed0 <ExecEvalScalarArrayOp+0x140>
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2617
    9.09 :	  5b0f23:       80 7d d6 00             cmpb   $0x0,-0x2a(%rbp)
    9.09 :	  5b0f27:       4d 89 e0                mov    %r12,%r8
    0.00 :	  5b0f2a:       74 26                   je     5b0f52 <ExecEvalScalarArrayOp+0x1c2>
    0.00 :	  5b0f2c:       66 83 7d d4 08          cmpw   $0x8,-0x2c(%rbp)
    0.00 :	  5b0f31:       0f 84 89 01 00 00       je     5b10c0 <ExecEvalScalarArrayOp+0x330>
    0.00 :	  5b0f37:       66 83 7d d4 04          cmpw   $0x4,-0x2c(%rbp)
    0.00 :	  5b0f3c:       0f 84 be 01 00 00       je     5b1100 <ExecEvalScalarArrayOp+0x370>
    0.00 :	  5b0f42:       66 83 7d d4 02          cmpw   $0x2,-0x2c(%rbp)
    0.00 :	  5b0f47:       0f 84 c3 01 00 00       je     5b1110 <ExecEvalScalarArrayOp+0x380>
    0.00 :	  5b0f4d:       45 0f b6 04 24          movzbl (%r12),%r8d
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b0f52:       66 83 7d d4 00          cmpw   $0x0,-0x2c(%rbp)
    0.00 :	  5b0f57:       0f 8e 23 01 00 00       jle    5b1080 <ExecEvalScalarArrayOp+0x2f0>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2618
    9.09 :	  5b0f5d:       4c 03 65 a8             add    -0x58(%rbp),%r12
         :	                        s = (char *) att_align_nominal(s, typalign);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2619
    9.09 :	  5b0f61:       80 7d d7 69             cmpb   $0x69,-0x29(%rbp)
    0.00 :	  5b0f65:       0f 84 05 01 00 00       je     5b1070 <ExecEvalScalarArrayOp+0x2e0>
    0.00 :	  5b0f6b:       80 7d d7 63             cmpb   $0x63,-0x29(%rbp)
    0.00 :	  5b0f6f:       74 12                   je     5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b0f71:       80 7d d7 64             cmpb   $0x64,-0x29(%rbp)
    0.00 :	  5b0f75:       0f 84 75 01 00 00       je     5b10f0 <ExecEvalScalarArrayOp+0x360>
    0.00 :	  5b0f7b:       49 83 c4 01             add    $0x1,%r12
    0.00 :	  5b0f7f:       49 83 e4 fe             and    $0xfffffffffffffffe,%r12
         :	                        fcinfo->arg[1] = elt;
    0.00 :	  5b0f83:       4c 89 83 98 00 00 00    mov    %r8,0x98(%rbx)
         :	                        fcinfo->argnull[1] = false;
    0.00 :	  5b0f8a:       c6 83 b1 03 00 00 00    movb   $0x0,0x3b1(%rbx)
         :	                        thisresult = (Datum) 0;
         :	                }
         :	                else
         :	                {
         :	                        fcinfo->isnull = false;
         :	                        thisresult = FunctionCallInvoke(fcinfo);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2633
    9.09 :	  5b0f91:       48 8b 43 70             mov    0x70(%rbx),%rax
         :	                        fcinfo->isnull = true;
         :	                        thisresult = (Datum) 0;
         :	                }
         :	                else
         :	                {
         :	                        fcinfo->isnull = false;
    0.00 :	  5b0f95:       c6 83 8c 00 00 00 00    movb   $0x0,0x8c(%rbx)
         :	                        thisresult = FunctionCallInvoke(fcinfo);
    0.00 :	  5b0f9c:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  5b0fa0:       ff 10                   callq  *(%rax)
         :	                }
         :
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
    0.00 :	  5b0fa2:       80 bb 8c 00 00 00 00    cmpb   $0x0,0x8c(%rbx)
    0.00 :	  5b0fa9:       0f 85 01 01 00 00       jne    5b10b0 <ExecEvalScalarArrayOp+0x320>
         :	                        resultnull = true;
         :	                else if (useOr)
    0.00 :	  5b0faf:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2639
    9.09 :	  5b0fb3:       0f 84 a7 00 00 00       je     5b1060 <ExecEvalScalarArrayOp+0x2d0>
         :	                {
         :	                        if (DatumGetBool(thisresult))
    0.00 :	  5b0fb9:       84 c0                   test   %al,%al
    0.00 :	  5b0fbb:       0f 85 c5 01 00 00       jne    5b1186 <ExecEvalScalarArrayOp+0x3f6>
         :	                                break;                  /* needn't look at any more elements */
         :	                        }
         :	                }
         :
         :	                /* advance bitmap pointer if any */
         :	                if (bitmap)
    0.00 :	  5b0fc1:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b0fc4:       0f 84 3d ff ff ff       je     5b0f07 <ExecEvalScalarArrayOp+0x177>
         :	                {
         :	                        bitmask <<= 1;
    0.00 :	  5b0fca:       45 01 ed                add    %r13d,%r13d
         :	                        if (bitmask == 0x100)
    0.00 :	  5b0fcd:       41 81 fd 00 01 00 00    cmp    $0x100,%r13d
    0.00 :	  5b0fd4:       0f 85 2d ff ff ff       jne    5b0f07 <ExecEvalScalarArrayOp+0x177>
         :	                        {
         :	                                bitmap++;
    0.00 :	  5b0fda:       49 83 c7 01             add    $0x1,%r15
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0fde:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5b0fe2:       44 39 75 c0             cmp    %r14d,-0x40(%rbp)
         :	                if (bitmap)
         :	                {
         :	                        bitmask <<= 1;
         :	                        if (bitmask == 0x100)
         :	                        {
         :	                                bitmap++;
    0.00 :	  5b0fe6:       66 41 bd 01 00          mov    $0x1,%r13w
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
         :	        bitmap = ARR_NULLBITMAP(arr);
         :	        bitmask = 1;
         :
         :	        for (i = 0; i < nitems; i++)
    0.00 :	  5b0feb:       0f 8f 24 ff ff ff       jg     5b0f15 <ExecEvalScalarArrayOp+0x185>
         :	        }
         :	        typlen = sstate->typlen;
         :	        typbyval = sstate->typbyval;
         :	        typalign = sstate->typalign;
         :
         :	        result = BoolGetDatum(!useOr);
    0.00 :	  5b0ff1:       31 c0                   xor    %eax,%eax
    0.00 :	  5b0ff3:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  5b0ff7:       0f 94 c0                sete   %al
         :	                                bitmask = 1;
         :	                        }
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
    0.00 :	  5b0ffa:       0f b6 4d c7             movzbl -0x39(%rbp),%ecx
    0.00 :	  5b0ffe:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b1002:       88 0a                   mov    %cl,(%rdx)
         :	        return result;
         :	}
    0.00 :	  5b1004:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5b1008:       5b                      pop    %rbx
    0.00 :	  5b1009:       41 5c                   pop    %r12
    0.00 :	  5b100b:       41 5d                   pop    %r13
    0.00 :	  5b100d:       41 5e                   pop    %r14
    0.00 :	  5b100f:       41 5f                   pop    %r15
    0.00 :	  5b1011:       c9                      leaveq 
    0.00 :	  5b1012:       c3                      retq   
    0.00 :	  5b1013:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /*
         :	         * Initialize function cache if first time through
         :	         */
         :	        if (sstate->fxprstate.func.fn_oid == InvalidOid)
         :	        {
         :	                init_fcache(opexpr->opfuncid, opexpr->inputcollid, &sstate->fxprstate,
    0.00 :	  5b1018:       49 8b 4c 24 20          mov    0x20(%r12),%rcx
    0.00 :	  5b101d:       8b 70 10                mov    0x10(%rax),%esi
    0.00 :	  5b1020:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  5b1026:       8b 78 08                mov    0x8(%rax),%edi
    0.00 :	  5b1029:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5b102c:       e8 ff fa ff ff          callq  5b0b30 <init_fcache>
    0.00 :	  5b1031:       e9 9f fd ff ff          jmpq   5b0dd5 <ExecEvalScalarArrayOp+0x45>
    0.00 :	  5b1036:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b103d:       00 00 00 
         :
         :	        /*
         :	         * If the scalar is NULL, and the function is strict, return NULL; no
         :	         * point in iterating the loop.
         :	         */
         :	        if (fcinfo->argnull[0] && sstate->fxprstate.func.fn_strict)
    0.00 :	  5b1040:       80 7b 2e 00             cmpb   $0x0,0x2e(%rbx)
    0.00 :	  5b1044:       0f 84 01 fe ff ff       je     5b0e4b <ExecEvalScalarArrayOp+0xbb>
         :	        {
         :	                *isNull = true;
    0.00 :	  5b104a:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5b104e:       31 c0                   xor    %eax,%eax
    0.00 :	  5b1050:       c6 02 01                movb   $0x1,(%rdx)
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b1053:       e9 ae fd ff ff          jmpq   5b0e06 <ExecEvalScalarArrayOp+0x76>
    0.00 :	  5b1058:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b105f:       00 
         :	                                break;                  /* needn't look at any more elements */
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        if (!DatumGetBool(thisresult))
    0.00 :	  5b1060:       84 c0                   test   %al,%al
    0.00 :	  5b1062:       0f 85 59 ff ff ff       jne    5b0fc1 <ExecEvalScalarArrayOp+0x231>
    0.00 :	  5b1068:       31 c0                   xor    %eax,%eax
    0.00 :	  5b106a:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b106e:       eb 8a                   jmp    5b0ffa <ExecEvalScalarArrayOp+0x26a>
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
         :	                        s = (char *) att_align_nominal(s, typalign);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2619
    9.09 :	  5b1070:       49 83 c4 03             add    $0x3,%r12
    0.00 :	  5b1074:       49 83 e4 fc             and    $0xfffffffffffffffc,%r12
    0.00 :	  5b1078:       e9 06 ff ff ff          jmpq   5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b107d:       0f 1f 00                nopl   (%rax)
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b1080:       66 83 7d d4 ff          cmpw   $0xffff,-0x2c(%rbp)
    0.00 :	  5b1085:       75 49                   jne    5b10d0 <ExecEvalScalarArrayOp+0x340>
    0.00 :	  5b1087:       41 0f b6 04 24          movzbl (%r12),%eax
    0.00 :	  5b108c:       3c 01                   cmp    $0x1,%al
    0.00 :	  5b108e:       0f 84 9c 00 00 00       je     5b1130 <ExecEvalScalarArrayOp+0x3a0>
    0.00 :	  5b1094:       a8 01                   test   $0x1,%al
    0.00 :	  5b1096:       0f 84 84 00 00 00       je     5b1120 <ExecEvalScalarArrayOp+0x390>
    0.00 :	  5b109c:       d0 e8                   shr    %al
    0.00 :	  5b109e:       0f b6 c0                movzbl %al,%eax
    0.00 :	  5b10a1:       49 01 c4                add    %rax,%r12
    0.00 :	  5b10a4:       e9 b8 fe ff ff          jmpq   5b0f61 <ExecEvalScalarArrayOp+0x1d1>
    0.00 :	  5b10a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        fcinfo->isnull = false;
         :	                        thisresult = FunctionCallInvoke(fcinfo);
         :	                }
         :
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
    0.00 :	  5b10b0:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
    0.00 :	  5b10b4:       e9 08 ff ff ff          jmpq   5b0fc1 <ExecEvalScalarArrayOp+0x231>
    0.00 :	  5b10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
    0.00 :	  5b10c0:       4d 8b 04 24             mov    (%r12),%r8
    0.00 :	  5b10c4:       e9 94 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b10c9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b10d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b10d3:       4c 89 45 a0             mov    %r8,-0x60(%rbp)
    0.00 :	  5b10d7:       e8 74 87 eb ff          callq  469850 <strlen@plt>
    0.00 :	  5b10dc:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  5b10e0:       4d 8d 64 04 01          lea    0x1(%r12,%rax,1),%r12
    0.00 :	  5b10e5:       e9 77 fe ff ff          jmpq   5b0f61 <ExecEvalScalarArrayOp+0x1d1>
    0.00 :	  5b10ea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        s = (char *) att_align_nominal(s, typalign);
    0.00 :	  5b10f0:       49 83 c4 07             add    $0x7,%r12
    0.00 :	  5b10f4:       49 83 e4 f8             and    $0xfffffffffffffff8,%r12
    0.00 :	  5b10f8:       e9 86 fe ff ff          jmpq   5b0f83 <ExecEvalScalarArrayOp+0x1f3>
    0.00 :	  5b10fd:       0f 1f 00                nopl   (%rax)
         :	                        fcinfo->arg[1] = (Datum) 0;
         :	                        fcinfo->argnull[1] = true;
         :	                }
         :	                else
         :	                {
         :	                        elt = fetch_att(s, typbyval, typlen);
    0.00 :	  5b1100:       45 8b 04 24             mov    (%r12),%r8d
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2617
    9.09 :	  5b1104:       e9 54 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b1109:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5b1110:       45 0f b7 04 24          movzwl (%r12),%r8d
    0.00 :	  5b1115:       e9 43 fe ff ff          jmpq   5b0f5d <ExecEvalScalarArrayOp+0x1cd>
    0.00 :	  5b111a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        s = att_addlength_pointer(s, typlen, s);
    0.00 :	  5b1120:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  5b1124:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  5b1127:       89 c0                   mov    %eax,%eax
    0.00 :	  5b1129:       e9 73 ff ff ff          jmpq   5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b112e:       66 90                   xchg   %ax,%ax
    0.00 :	  5b1130:       41 0f b6 54 24 01       movzbl 0x1(%r12),%edx
    0.00 :	  5b1136:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  5b113b:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  5b113e:       0f 84 5d ff ff ff       je     5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b1144:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  5b1147:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  5b114c:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  5b1151:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  5b1155:       e9 47 ff ff ff          jmpq   5b10a1 <ExecEvalScalarArrayOp+0x311>
    0.00 :	  5b115a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        result = BoolGetDatum(!useOr);
         :	        resultnull = false;
         :
         :	        /* Loop over the array elements */
         :	        s = (char *) ARR_DATA_PTR(arr);
    0.00 :	  5b1160:       49 63 45 04             movslq 0x4(%r13),%rax
    0.00 :	  5b1164:       45 31 ff                xor    %r15d,%r15d
    0.00 :	  5b1167:       4d 8d 64 c5 10          lea    0x10(%r13,%rax,8),%r12
    0.00 :	  5b116c:       e9 45 fd ff ff          jmpq   5b0eb6 <ExecEvalScalarArrayOp+0x126>
    0.00 :	  5b1171:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * evaluate the operator zero times, it matters not whether it would want
         :	         * to return NULL.
         :	         */
         :	        nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));
         :	        if (nitems <= 0)
         :	                return BoolGetDatum(!useOr);
    0.00 :	  5b1178:       31 c0                   xor    %eax,%eax
    0.00 :	  5b117a:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  5b117e:       0f 94 c0                sete   %al
         :	                }
         :	        }
         :
         :	        *isNull = resultnull;
         :	        return result;
         :	}
    0.00 :	  5b1181:       e9 80 fc ff ff          jmpq   5b0e06 <ExecEvalScalarArrayOp+0x76>
         :	                /* Combine results per OR or AND semantics */
         :	                if (fcinfo->isnull)
         :	                        resultnull = true;
         :	                else if (useOr)
         :	                {
         :	                        if (DatumGetBool(thisresult))
    0.00 :	  5b1186:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5b118b:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5b118f:       e9 66 fe ff ff          jmpq   5b0ffa <ExecEvalScalarArrayOp+0x26a>
         :	         * Evaluate arguments
         :	         */
         :	        fcinfo = &sstate->fxprstate.fcinfo_data;
         :	        argDone = ExecEvalFuncArgs(fcinfo, sstate->fxprstate.args, econtext);
         :	        if (argDone != ExprSingleResult)
         :	                ereport(ERROR,
    0.00 :	  5b1194:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5b1197:       b9 e0 ae 88 00          mov    $0x88aee0,%ecx
    0.00 :	  5b119c:       ba f1 09 00 00          mov    $0x9f1,%edx
    0.00 :	  5b11a1:       be fc a3 88 00          mov    $0x88a3fc,%esi
    0.00 :	  5b11a6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b11ab:       e8 10 99 1c 00          callq  77aac0 <errstart>
    0.00 :	  5b11b0:       84 c0                   test   %al,%al
    0.00 :	  5b11b2:       75 05                   jne    5b11b9 <ExecEvalScalarArrayOp+0x429>
    0.00 :	  5b11b4:       e8 17 83 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5b11b9:       bf 10 a9 88 00          mov    $0x88a910,%edi
    0.00 :	  5b11be:       31 c0                   xor    %eax,%eax
    0.00 :	  5b11c0:       e8 db b6 1c 00          callq  77c8a0 <errmsg>
    0.00 :	  5b11c5:       bf 84 80 00 04          mov    $0x4008084,%edi
    0.00 :	  5b11ca:       89 c3                   mov    %eax,%ebx
    0.00 :	  5b11cc:       e8 7f bb 1c 00          callq  77cd50 <errcode>
    0.00 :	  5b11d1:       89 de                   mov    %ebx,%esi
    0.00 :	  5b11d3:       89 c7                   mov    %eax,%edi
    0.00 :	  5b11d5:       31 c0                   xor    %eax,%eax
    0.00 :	  5b11d7:       e8 04 94 1c 00          callq  77a5e0 <errfinish>
    0.00 :	  5b11dc:       eb d6                   jmp    5b11b4 <ExecEvalScalarArrayOp+0x424>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   45.45 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:54
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:48
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:44
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:54
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:61
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:61
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079c830 <comparison_shim>:
         :	 * we assume that the FunctionCallInfoData was already mostly set up by
         :	 * PrepareSortSupportComparisonShim.
         :	 */
         :	static int
         :	comparison_shim(Datum x, Datum y, SortSupport ssup)
         :	{
    0.00 :	  79c830:       55                      push   %rbp
    0.00 :	  79c831:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79c834:       53                      push   %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:44
    9.09 :	  79c835:       48 83 ec 08             sub    $0x8,%rsp
         :	        SortShimExtra *extra = (SortShimExtra *) ssup->ssup_extra;
    0.00 :	  79c839:       48 8b 5a 10             mov    0x10(%rdx),%rbx
         :	        extra->fcinfo.arg[1] = y;
         :
         :	        /* just for paranoia's sake, we reset isnull each time */
         :	        extra->fcinfo.isnull = false;
         :
         :	        result = FunctionCallInvoke(&extra->fcinfo);
    0.00 :	  79c83d:       48 8b 03                mov    (%rbx),%rax
         :	comparison_shim(Datum x, Datum y, SortSupport ssup)
         :	{
         :	        SortShimExtra *extra = (SortShimExtra *) ssup->ssup_extra;
         :	        Datum           result;
         :
         :	        extra->fcinfo.arg[0] = x;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:48
   18.18 :	  79c840:       48 89 7b 20             mov    %rdi,0x20(%rbx)
         :	        extra->fcinfo.arg[1] = y;
         :
         :	        /* just for paranoia's sake, we reset isnull each time */
         :	        extra->fcinfo.isnull = false;
         :
         :	        result = FunctionCallInvoke(&extra->fcinfo);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:54
   45.45 :	  79c844:       48 89 df                mov    %rbx,%rdi
         :	{
         :	        SortShimExtra *extra = (SortShimExtra *) ssup->ssup_extra;
         :	        Datum           result;
         :
         :	        extra->fcinfo.arg[0] = x;
         :	        extra->fcinfo.arg[1] = y;
    0.00 :	  79c847:       48 89 73 28             mov    %rsi,0x28(%rbx)
         :
         :	        /* just for paranoia's sake, we reset isnull each time */
         :	        extra->fcinfo.isnull = false;
    0.00 :	  79c84b:       c6 43 1c 00             movb   $0x0,0x1c(%rbx)
         :
         :	        result = FunctionCallInvoke(&extra->fcinfo);
    9.09 :	  79c84f:       ff 10                   callq  *(%rax)
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (extra->fcinfo.isnull)
    0.00 :	  79c851:       80 7b 1c 00             cmpb   $0x0,0x1c(%rbx)
    0.00 :	  79c855:       75 07                   jne    79c85e <comparison_shim+0x2e>
         :	                elog(ERROR, "function %u returned NULL", extra->flinfo.fn_oid);
         :
         :	        return result;
         :	}
    0.00 :	  79c857:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  79c85b:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/sortsupport.c:61
    9.09 :	  79c85c:       c9                      leaveq 
    9.09 :	  79c85d:       c3                      retq   
         :
         :	        result = FunctionCallInvoke(&extra->fcinfo);
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (extra->fcinfo.isnull)
         :	                elog(ERROR, "function %u returned NULL", extra->flinfo.fn_oid);
    0.00 :	  79c85e:       ba 70 29 8e 00          mov    $0x8e2970,%edx
    0.00 :	  79c863:       be 3a 00 00 00          mov    $0x3a,%esi
    0.00 :	  79c868:       bf 21 29 8e 00          mov    $0x8e2921,%edi
    0.00 :	  79c86d:       e8 ae eb fd ff          callq  77b420 <elog_start>
    0.00 :	  79c872:       8b 93 b0 03 00 00       mov    0x3b0(%rbx),%edx
    0.00 :	  79c878:       be 97 4c 8d 00          mov    $0x8d4c97,%esi
    0.00 :	  79c87d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79c882:       31 c0                   xor    %eax,%eax
    0.00 :	  79c884:       e8 a7 e9 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79c889:       e8 42 cc cc ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   44.44 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:923
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/nodes/pg_list.h:87
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:970
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbe90 <ExecHashGetHashValue>:
         :	                                         ExprContext *econtext,
         :	                                         List *hashkeys,
         :	                                         bool outer_tuple,
         :	                                         bool keep_nulls,
         :	                                         uint32 *hashvalue)
         :	{
    0.00 :	  5bbe90:       55                      push   %rbp
    0.00 :	  5bbe91:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bbe94:       41 57                   push   %r15
    0.00 :	  5bbe96:       49 89 ff                mov    %rdi,%r15
    0.00 :	  5bbe99:       41 56                   push   %r14
    0.00 :	  5bbe9b:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5bbe9e:       41 55                   push   %r13
    0.00 :	  5bbea0:       41 54                   push   %r12
    0.00 :	  5bbea2:       49 89 d4                mov    %rdx,%r12
    0.00 :	  5bbea5:       53                      push   %rbx
    0.00 :	  5bbea6:       89 cb                   mov    %ecx,%ebx
    0.00 :	  5bbea8:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  5bbeac:       4c 89 4d a8             mov    %r9,-0x58(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:923
   11.11 :	  5bbeb0:       44 88 45 b7             mov    %r8b,-0x49(%rbp)
         :
         :	        /*
         :	         * We reset the eval context each time to reclaim any memory leaked in the
         :	         * hashkey expressions.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5bbeb4:       48 8b 7e 28             mov    0x28(%rsi),%rdi
    0.00 :	  5bbeb8:       e8 f3 ca 1d 00          callq  7989b0 <MemoryContextReset>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5bbebd:       48 8b 05 9c e9 5f 00    mov    0x5fe99c(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        if (outer_tuple)
    0.00 :	  5bbec4:       84 db                   test   %bl,%bl
    0.00 :	  5bbec6:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5bbeca:       49 8b 46 28             mov    0x28(%r14),%rax
    0.00 :	  5bbece:       48 89 05 8b e9 5f 00    mov    %rax,0x5fe98b(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5bbed5:       0f 84 d5 00 00 00       je     5bbfb0 <ExecHashGetHashValue+0x120>
         :	                hashfunctions = hashtable->outer_hashfunctions;
    0.00 :	  5bbedb:       49 8b 47 78             mov    0x78(%r15),%rax
    0.00 :	  5bbedf:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/nodes/pg_list.h:87
   11.11 :	  5bbee3:       4d 85 e4                test   %r12,%r12
    0.00 :	  5bbee6:       0f 84 94 00 00 00       je     5bbf80 <ExecHashGetHashValue+0xf0>
    0.00 :	  5bbeec:       49 8b 5c 24 08          mov    0x8(%r12),%rbx
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
         :
         :	        foreach(hk, hashkeys)
    0.00 :	  5bbef1:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbef4:       0f 84 86 00 00 00       je     5bbf80 <ExecHashGetHashValue+0xf0>
    0.00 :	  5bbefa:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5bbefd:       45 31 e4                xor    %r12d,%r12d
         :	        {
         :	                ExprState  *keyexpr = (ExprState *) lfirst(hk);
    0.00 :	  5bbf00:       48 8b 03                mov    (%rbx),%rax
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
         :
         :	                /*
         :	                 * Get the join attribute value of the tuple
         :	                 */
         :	                keyval = ExecEvalExpr(keyexpr, econtext, &isNull, NULL);
    0.00 :	  5bbf03:       31 c9                   xor    %ecx,%ecx
         :	                ExprState  *keyexpr = (ExprState *) lfirst(hk);
         :	                Datum           keyval;
         :	                bool            isNull;
         :
         :	                /* rotate hashkey left 1 bit at each step */
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
    0.00 :	  5bbf05:       41 d1 c5                rol    %r13d
         :
         :	                /*
         :	                 * Get the join attribute value of the tuple
         :	                 */
         :	                keyval = ExecEvalExpr(keyexpr, econtext, &isNull, NULL);
    0.00 :	  5bbf08:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5bbf0c:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5bbf0f:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5bbf12:       ff 50 10                callq  *0x10(%rax)
         :	                 *
         :	                 * Note: currently, all hashjoinable operators must be strict since
         :	                 * the hash index AM assumes that.  However, it takes so little extra
         :	                 * code here to allow non-strict that we may as well do it.
         :	                 */
         :	                if (isNull)
    0.00 :	  5bbf15:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:970
   11.11 :	  5bbf19:       74 35                   je     5bbf50 <ExecHashGetHashValue+0xc0>
         :	                {
         :	                        if (hashtable->hashStrict[i] && !keep_nulls)
    0.00 :	  5bbf1b:       49 8b 87 88 00 00 00    mov    0x88(%r15),%rax
    0.00 :	  5bbf22:       49 63 d4                movslq %r12d,%rdx
    0.00 :	  5bbf25:       80 3c 10 00             cmpb   $0x0,(%rax,%rdx,1)
    0.00 :	  5bbf29:       74 41                   je     5bbf6c <ExecHashGetHashValue+0xdc>
    0.00 :	  5bbf2b:       80 7d b7 00             cmpb   $0x0,-0x49(%rbp)
    0.00 :	  5bbf2f:       75 3b                   jne    5bbf6c <ExecHashGetHashValue+0xdc>
    0.00 :	  5bbf31:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bbf35:       48 89 05 24 e9 5f 00    mov    %rax,0x5fe924(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
         :	        return true;
         :	}
    0.00 :	  5bbf3c:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5bbf40:       31 c0                   xor    %eax,%eax
    0.00 :	  5bbf42:       5b                      pop    %rbx
    0.00 :	  5bbf43:       41 5c                   pop    %r12
    0.00 :	  5bbf45:       41 5d                   pop    %r13
    0.00 :	  5bbf47:       41 5e                   pop    %r14
    0.00 :	  5bbf49:       41 5f                   pop    %r15
    0.00 :	  5bbf4b:       c9                      leaveq 
    0.00 :	  5bbf4c:       c3                      retq   
    0.00 :	  5bbf4d:       0f 1f 00                nopl   (%rax)
         :	                else
         :	                {
         :	                        /* Compute the hash function */
         :	                        uint32          hkey;
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i], keyval));
    0.00 :	  5bbf50:       49 63 fc                movslq %r12d,%rdi
    0.00 :	  5bbf53:       48 89 c2                mov    %rax,%rdx
    0.00 :	  5bbf56:       31 f6                   xor    %esi,%esi
    0.00 :	  5bbf58:       48 8d 3c 7f             lea    (%rdi,%rdi,2),%rdi
    0.00 :	  5bbf5c:       48 c1 e7 04             shl    $0x4,%rdi
    0.00 :	  5bbf60:       48 03 7d b8             add    -0x48(%rbp),%rdi
    0.00 :	  5bbf64:       e8 67 21 1c 00          callq  77e0d0 <FunctionCall1Coll>
         :	                        hashkey ^= hkey;
    0.00 :	  5bbf69:       41 31 c5                xor    %eax,%r13d
         :	        if (outer_tuple)
         :	                hashfunctions = hashtable->outer_hashfunctions;
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
         :
         :	        foreach(hk, hashkeys)
    0.00 :	  5bbf6c:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5bbf70:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbf73:       74 13                   je     5bbf88 <ExecHashGetHashValue+0xf8>
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i], keyval));
         :	                        hashkey ^= hkey;
         :	                }
         :
         :	                i++;
    0.00 :	  5bbf75:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  5bbf79:       eb 85                   jmp    5bbf00 <ExecHashGetHashValue+0x70>
    0.00 :	  5bbf7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbf80:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5bbf83:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbf88:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bbf8c:       48 89 05 cd e8 5f 00    mov    %rax,0x5fe8cd(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
    0.00 :	  5bbf93:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  5bbf97:       44 89 28                mov    %r13d,(%rax)
         :	        return true;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
   44.44 :	  5bbf9a:       48 83 c4 38             add    $0x38,%rsp
         :	                i++;
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
    0.00 :	  5bbf9e:       b8 01 00 00 00          mov    $0x1,%eax
         :	        return true;
         :	}
    0.00 :	  5bbfa3:       5b                      pop    %rbx
   11.11 :	  5bbfa4:       41 5c                   pop    %r12
    0.00 :	  5bbfa6:       41 5d                   pop    %r13
    0.00 :	  5bbfa8:       41 5e                   pop    %r14
    0.00 :	  5bbfaa:       41 5f                   pop    %r15
   11.11 :	  5bbfac:       c9                      leaveq 
    0.00 :	  5bbfad:       c3                      retq   
    0.00 :	  5bbfae:       66 90                   xchg   %ax,%ax
         :	        oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        if (outer_tuple)
         :	                hashfunctions = hashtable->outer_hashfunctions;
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
    0.00 :	  5bbfb0:       49 8b 87 80 00 00 00    mov    0x80(%r15),%rax
    0.00 :	  5bbfb7:       48 89 45 b8             mov    %rax,-0x48(%rbp)
    0.00 :	  5bbfbb:       e9 23 ff ff ff          jmpq   5bbee3 <ExecHashGetHashValue+0x53>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:147
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:151
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007989b0 <MemoryContextReset>:
         :	 * The type-specific reset routine handles the context itself, but we
         :	 * have to do the recursion for the children.
         :	 */
         :	void
         :	MemoryContextReset(MemoryContext context)
         :	{
   33.33 :	  7989b0:       55                      push   %rbp
   11.11 :	  7989b1:       48 89 e5                mov    %rsp,%rbp
   11.11 :	  7989b4:       53                      push   %rbx
    0.00 :	  7989b5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7989b8:       48 83 ec 08             sub    $0x8,%rsp
         :	        AssertArg(MemoryContextIsValid(context));
         :
         :	        /* save a function call in common case where there are no children */
         :	        if (context->firstchild != NULL)
    0.00 :	  7989bc:       48 83 7f 18 00          cmpq   $0x0,0x18(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:147
   11.11 :	  7989c1:       74 05                   je     7989c8 <MemoryContextReset+0x18>
         :	                MemoryContextResetChildren(context);
    0.00 :	  7989c3:       e8 b8 ff ff ff          callq  798980 <MemoryContextResetChildren>
         :
         :	        /* Nothing to do if no pallocs since startup or last reset */
         :	        if (!context->isReset)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:151
   11.11 :	  7989c8:       80 7b 30 00             cmpb   $0x0,0x30(%rbx)
    0.00 :	  7989cc:       75 0e                   jne    7989dc <MemoryContextReset+0x2c>
         :	        {
         :	                (*context->methods->reset) (context);
    0.00 :	  7989ce:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7989d2:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7989d5:       ff 50 20                callq  *0x20(%rax)
         :	                context->isReset = true;
    0.00 :	  7989d8:       c6 43 30 01             movb   $0x1,0x30(%rbx)
         :	                VALGRIND_DESTROY_MEMPOOL(context);
         :	                VALGRIND_CREATE_MEMPOOL(context, 0, false);
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
   11.11 :	  7989dc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  7989e0:       5b                      pop    %rbx
   11.11 :	  7989e1:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1334
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1296
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1305
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1305
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1313
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1319
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1320
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f260 <slot_getsomeattrs>:
         :	 *              This function forces the entries of the slot's Datum/isnull
         :	 *              arrays to be valid at least up through the attnum'th entry.
         :	 */
         :	void
         :	slot_getsomeattrs(TupleTableSlot *slot, int attnum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1296
   12.50 :	  46f260:       55                      push   %rbp
    0.00 :	  46f261:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46f264:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  46f268:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  46f26c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  46f26f:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  46f273:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTuple       tuple;
         :	        int                     attno;
         :
         :	        /* Quick out if we have 'em all already */
         :	        if (slot->tts_nvalid >= attnum)
    0.00 :	  46f277:       39 77 24                cmp    %esi,0x24(%rdi)
         :	 *              This function forces the entries of the slot's Datum/isnull
         :	 *              arrays to be valid at least up through the attnum'th entry.
         :	 */
         :	void
         :	slot_getsomeattrs(TupleTableSlot *slot, int attnum)
         :	{
    0.00 :	  46f27a:       41 89 f5                mov    %esi,%r13d
         :	        HeapTuple       tuple;
         :	        int                     attno;
         :
         :	        /* Quick out if we have 'em all already */
         :	        if (slot->tts_nvalid >= attnum)
    0.00 :	  46f27d:       7d 67                   jge    46f2e6 <slot_getsomeattrs+0x86>
         :	                return;
         :
         :	        /* Check for caller error */
         :	        if (attnum <= 0 || attnum > slot->tts_tupleDescriptor->natts)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1305
   12.50 :	  46f27f:       85 f6                   test   %esi,%esi
    0.00 :	  46f281:       7e 75                   jle    46f2f8 <slot_getsomeattrs+0x98>
    0.00 :	  46f283:       48 8b 47 10             mov    0x10(%rdi),%rax
   12.50 :	  46f287:       3b 30                   cmp    (%rax),%esi
    0.00 :	  46f289:       7f 6d                   jg     46f2f8 <slot_getsomeattrs+0x98>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        tuple = slot->tts_tuple;
    0.00 :	  46f28b:       48 8b 47 08             mov    0x8(%rdi),%rax
         :	        if (tuple == NULL)                      /* internal error */
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1313
   12.50 :	  46f28f:       48 85 c0                test   %rax,%rax
    0.00 :	  46f292:       0f 84 8d 00 00 00       je     46f325 <slot_getsomeattrs+0xc5>
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
         :
         :	        /*
         :	         * load up any slots available from physical tuple
         :	         */
         :	        attno = HeapTupleHeaderGetNatts(tuple->t_data);
    0.00 :	  46f298:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  46f29c:       0f b7 40 12             movzwl 0x12(%rax),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1319
   12.50 :	  46f2a0:       25 ff 07 00 00          and    $0x7ff,%eax
         :	        attno = Min(attno, attnum);
    0.00 :	  46f2a5:       39 c6                   cmp    %eax,%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1320
   12.50 :	  46f2a7:       89 c3                   mov    %eax,%ebx
    0.00 :	  46f2a9:       0f 4e de                cmovle %esi,%ebx
         :
         :	        slot_deform_tuple(slot, attno);
    0.00 :	  46f2ac:       89 de                   mov    %ebx,%esi
    0.00 :	  46f2ae:       e8 5d fc ff ff          callq  46ef10 <slot_deform_tuple>
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2b3:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  46f2b6:       7e 29                   jle    46f2e1 <slot_getsomeattrs+0x81>
    0.00 :	  46f2b8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46f2bf:       00 
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
    0.00 :	  46f2c0:       49 8b 54 24 28          mov    0x28(%r12),%rdx
    0.00 :	  46f2c5:       48 63 c3                movslq %ebx,%rax
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2c8:       83 c3 01                add    $0x1,%ebx
    0.00 :	  46f2cb:       41 39 dd                cmp    %ebx,%r13d
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
    0.00 :	  46f2ce:       48 c7 04 c2 00 00 00    movq   $0x0,(%rdx,%rax,8)
    0.00 :	  46f2d5:       00 
         :	                slot->tts_isnull[attno] = true;
    0.00 :	  46f2d6:       49 8b 54 24 30          mov    0x30(%r12),%rdx
    0.00 :	  46f2db:       c6 04 02 01             movb   $0x1,(%rdx,%rax,1)
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2df:       7f df                   jg     46f2c0 <slot_getsomeattrs+0x60>
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
         :	                slot->tts_isnull[attno] = true;
         :	        }
         :	        slot->tts_nvalid = attnum;
    0.00 :	  46f2e1:       45 89 6c 24 24          mov    %r13d,0x24(%r12)
         :	}
    0.00 :	  46f2e6:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  46f2ea:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  46f2ee:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1334
   25.00 :	  46f2f2:       c9                      leaveq 
    0.00 :	  46f2f3:       c3                      retq   
    0.00 :	  46f2f4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        if (slot->tts_nvalid >= attnum)
         :	                return;
         :
         :	        /* Check for caller error */
         :	        if (attnum <= 0 || attnum > slot->tts_tupleDescriptor->natts)
         :	                elog(ERROR, "invalid attribute number %d", attnum);
    0.00 :	  46f2f8:       ba c0 f6 7a 00          mov    $0x7af6c0,%edx
    0.00 :	  46f2fd:       be 1a 05 00 00          mov    $0x51a,%esi
    0.00 :	  46f302:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f307:       e8 14 c1 30 00          callq  77b420 <elog_start>
    0.00 :	  46f30c:       44 89 ea                mov    %r13d,%edx
    0.00 :	  46f30f:       be 13 f6 7a 00          mov    $0x7af613,%esi
    0.00 :	  46f314:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f319:       31 c0                   xor    %eax,%eax
    0.00 :	  46f31b:       e8 10 bf 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f320:       e8 ab a1 ff ff          callq  4694d0 <abort@plt>
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        tuple = slot->tts_tuple;
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46f325:       ba c0 f6 7a 00          mov    $0x7af6c0,%edx
    0.00 :	  46f32a:       be 22 05 00 00          mov    $0x522,%esi
    0.00 :	  46f32f:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f334:       e8 e7 c0 30 00          callq  77b420 <elog_start>
    0.00 :	  46f339:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46f33e:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f343:       31 c0                   xor    %eax,%eax
    0.00 :	  46f345:       e8 e6 be 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f34a:       e8 81 a1 ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:394
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:344
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:396
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:404
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:393
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:411
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:367
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000495e60 <heapgetpage>:
         :	 * In page-at-a-time mode it performs additional work, namely determining
         :	 * which tuples on the page are visible.
         :	 */
         :	static void
         :	heapgetpage(HeapScanDesc scan, BlockNumber page)
         :	{
    0.00 :	  495e60:       55                      push   %rbp
    0.00 :	  495e61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  495e64:       41 57                   push   %r15
    0.00 :	  495e66:       41 56                   push   %r14
    0.00 :	  495e68:       49 89 fe                mov    %rdi,%r14
    0.00 :	  495e6b:       41 55                   push   %r13
    0.00 :	  495e6d:       41 54                   push   %r12
    0.00 :	  495e6f:       53                      push   %rbx
    0.00 :	  495e70:       48 83 ec 78             sub    $0x78,%rsp
    0.00 :	  495e74:       89 b5 6c ff ff ff       mov    %esi,-0x94(%rbp)
         :	        bool            all_visible;
         :
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        /* release previous scan buffer, if any */
         :	        if (BufferIsValid(scan->rs_cbuf))
    0.00 :	  495e7a:       8b 7f 64                mov    0x64(%rdi),%edi
    0.00 :	  495e7d:       85 ff                   test   %edi,%edi
    0.00 :	  495e7f:       0f 85 fb 01 00 00       jne    496080 <heapgetpage+0x220>
         :	        /*
         :	         * Be sure to check for interrupts at least once per page.  Checks at
         :	         * higher code levels won't be able to stop a seqscan that encounters many
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  495e85:       0f b6 05 04 42 72 00    movzbl 0x724204(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  495e8c:       84 c0                   test   %al,%al
    0.00 :	  495e8e:       0f 85 d4 01 00 00       jne    496068 <heapgetpage+0x208>
         :
         :	        /* read page using selected strategy */
         :	        scan->rs_cbuf = ReadBufferExtended(scan->rs_rd, MAIN_FORKNUM, page,
    0.00 :	  495e94:       4d 8b 46 38             mov    0x38(%r14),%r8
    0.00 :	  495e98:       8b 95 6c ff ff ff       mov    -0x94(%rbp),%edx
    0.00 :	  495e9e:       31 c9                   xor    %ecx,%ecx
    0.00 :	  495ea0:       49 8b 3e                mov    (%r14),%rdi
    0.00 :	  495ea3:       31 f6                   xor    %esi,%esi
    0.00 :	  495ea5:       e8 c6 06 1e 00          callq  676570 <ReadBufferExtended>
         :	                                                                           RBM_NORMAL, scan->rs_strategy);
         :	        scan->rs_cblock = page;
         :
         :	        if (!scan->rs_pageatatime)
    0.00 :	  495eaa:       41 80 7e 21 00          cmpb   $0x0,0x21(%r14)
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
         :
         :	        /* read page using selected strategy */
         :	        scan->rs_cbuf = ReadBufferExtended(scan->rs_rd, MAIN_FORKNUM, page,
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:344
   12.50 :	  495eaf:       41 89 c7                mov    %eax,%r15d
    0.00 :	  495eb2:       41 89 46 64             mov    %eax,0x64(%r14)
         :	                                                                           RBM_NORMAL, scan->rs_strategy);
         :	        scan->rs_cblock = page;
    0.00 :	  495eb6:       8b 85 6c ff ff ff       mov    -0x94(%rbp),%eax
    0.00 :	  495ebc:       41 89 46 60             mov    %eax,0x60(%r14)
         :
         :	        if (!scan->rs_pageatatime)
    0.00 :	  495ec0:       75 16                   jne    495ed8 <heapgetpage+0x78>
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
         :	}
    0.00 :	  495ec2:       48 83 c4 78             add    $0x78,%rsp
    0.00 :	  495ec6:       5b                      pop    %rbx
    0.00 :	  495ec7:       41 5c                   pop    %r12
    0.00 :	  495ec9:       41 5d                   pop    %r13
    0.00 :	  495ecb:       41 5e                   pop    %r14
    0.00 :	  495ecd:       41 5f                   pop    %r15
    0.00 :	  495ecf:       c9                      leaveq 
    0.00 :	  495ed0:       c3                      retq   
    0.00 :	  495ed1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        if (!scan->rs_pageatatime)
         :	                return;
         :
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  495ed8:       49 8b 4e 08             mov    0x8(%r14),%rcx
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  495edc:       44 89 fe                mov    %r15d,%esi
         :
         :	        if (!scan->rs_pageatatime)
         :	                return;
         :
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  495edf:       48 89 4d 88             mov    %rcx,-0x78(%rbp)
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  495ee3:       49 8b 3e                mov    (%r14),%rdi
    0.00 :	  495ee6:       e8 65 97 00 00          callq  49f650 <heap_page_prune_opt>
         :	        /*
         :	         * We must hold share lock on the buffer content while examining tuple
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
    0.00 :	  495eeb:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  495ef0:       44 89 ff                mov    %r15d,%edi
    0.00 :	  495ef3:       e8 18 e8 1d 00          callq  674710 <LockBuffer>
         :
         :	        dp = (Page) BufferGetPage(buffer);
    0.00 :	  495ef8:       45 85 ff                test   %r15d,%r15d
    0.00 :	  495efb:       0f 88 cf 01 00 00       js     4960d0 <heapgetpage+0x270>
    0.00 :	  495f01:       41 8d 47 ff             lea    -0x1(%r15),%eax
    0.00 :	  495f05:       48 63 d8                movslq %eax,%rbx
    0.00 :	  495f08:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  495f0c:       48 03 1d e5 9b 72 00    add    0x729be5(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        lines = PageGetMaxOffsetNumber(dp);
    0.00 :	  495f13:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  495f17:       c7 45 90 00 00 00 00    movl   $0x0,-0x70(%rbp)
    0.00 :	  495f1e:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  495f22:       0f 87 88 01 00 00       ja     4960b0 <heapgetpage+0x250>
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  495f28:       c6 45 af 00             movb   $0x0,-0x51(%rbp)
    0.00 :	  495f2c:       f6 43 0a 04             testb  $0x4,0xa(%rbx)
    0.00 :	  495f30:       0f 85 62 01 00 00       jne    496098 <heapgetpage+0x238>
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f36:       8b 7d 90                mov    -0x70(%rbp),%edi
         :	                 lineoff++, lpp++)
    0.00 :	  495f39:       c7 45 a8 00 00 00 00    movl   $0x0,-0x58(%rbp)
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f40:       85 ff                   test   %edi,%edi
    0.00 :	  495f42:       0f 8e c8 00 00 00       jle    496010 <heapgetpage+0x1b0>
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f48:       8b 8d 6c ff ff ff       mov    -0x94(%rbp),%ecx
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
    0.00 :	  495f4e:       4c 8d 6b 18             lea    0x18(%rbx),%r13
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f52:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  495f58:       c1 e9 10                shr    $0x10,%ecx
    0.00 :	  495f5b:       66 89 8d 70 ff ff ff    mov    %cx,-0x90(%rbp)
    0.00 :	  495f62:       eb 19                   jmp    495f7d <heapgetpage+0x11d>
    0.00 :	  495f64:       0f 1f 40 00             nopl   0x0(%rax)
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
         :	                 lineoff++, lpp++)
    0.00 :	  495f68:       41 83 c4 01             add    $0x1,%r12d
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f6c:       41 0f b7 c4             movzwl %r12w,%eax
    0.00 :	  495f70:       39 45 90                cmp    %eax,-0x70(%rbp)
    0.00 :	  495f73:       0f 8c 97 00 00 00       jl     496010 <heapgetpage+0x1b0>
         :	                 lineoff++, lpp++)
    0.00 :	  495f79:       49 83 c5 04             add    $0x4,%r13
         :	        {
         :	                if (ItemIdIsNormal(lpp))
    0.00 :	  495f7d:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  495f81:       25 00 80 01 00          and    $0x18000,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:396
   12.50 :	  495f86:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  495f8b:       75 db                   jne    495f68 <heapgetpage+0x108>
         :	                {
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
    0.00 :	  495f8d:       49 8b 36                mov    (%r14),%rsi
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f90:       0f b7 8d 6c ff ff ff    movzwl -0x94(%rbp),%ecx
         :	                if (ItemIdIsNormal(lpp))
         :	                {
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
    0.00 :	  495f97:       8b 46 40                mov    0x40(%rsi),%eax
    0.00 :	  495f9a:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
    0.00 :	  495f9d:       41 0f b7 45 00          movzwl 0x0(%r13),%eax
    0.00 :	  495fa2:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  495fa7:       48 8d 04 03             lea    (%rbx,%rax,1),%rax
    0.00 :	  495fab:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495faf:       41 0f b7 45 02          movzwl 0x2(%r13),%eax
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495fb4:       66 89 4d b6             mov    %cx,-0x4a(%rbp)
    0.00 :	  495fb8:       66 44 89 65 b8          mov    %r12w,-0x48(%rbp)
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495fbd:       66 d1 e8                shr    %ax
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
    0.00 :	  495fc0:       80 7d af 00             cmpb   $0x0,-0x51(%rbp)
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495fc4:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  495fc7:       89 45 b0                mov    %eax,-0x50(%rbp)
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:404
   12.50 :	  495fca:       0f b7 85 70 ff ff ff    movzwl -0x90(%rbp),%eax
    0.00 :	  495fd1:       66 89 45 b4             mov    %ax,-0x4c(%rbp)
         :
         :	                        if (all_visible)
    0.00 :	  495fd5:       74 59                   je     496030 <heapgetpage+0x1d0>
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  495fd7:       4c 8b 45 88             mov    -0x78(%rbp),%r8
    0.00 :	  495fdb:       48 8d 55 b0             lea    -0x50(%rbp),%rdx
    0.00 :	  495fdf:       44 89 f9                mov    %r15d,%ecx
    0.00 :	  495fe2:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  495fe7:       e8 74 e6 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
    0.00 :	  495fec:       48 63 45 a8             movslq -0x58(%rbp),%rax
    0.00 :	  495ff0:       66 45 89 64 46 7c       mov    %r12w,0x7c(%r14,%rax,2)
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
         :	                 lineoff++, lpp++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:394
   25.00 :	  495ff6:       41 83 c4 01             add    $0x1,%r12d
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
    0.00 :	  495ffa:       83 45 a8 01             addl   $0x1,-0x58(%rbp)
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495ffe:       41 0f b7 c4             movzwl %r12w,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:393
   12.50 :	  496002:       39 45 90                cmp    %eax,-0x70(%rbp)
    0.00 :	  496005:       0f 8d 6e ff ff ff       jge    495f79 <heapgetpage+0x119>
    0.00 :	  49600b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
         :	                }
         :	        }
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  496010:       44 89 ff                mov    %r15d,%edi
    0.00 :	  496013:       31 f6                   xor    %esi,%esi
    0.00 :	  496015:       e8 f6 e6 1d 00          callq  674710 <LockBuffer>
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
    0.00 :	  49601a:       8b 45 a8                mov    -0x58(%rbp),%eax
    0.00 :	  49601d:       41 89 46 78             mov    %eax,0x78(%r14)
         :	}
    0.00 :	  496021:       48 83 c4 78             add    $0x78,%rsp
    0.00 :	  496025:       5b                      pop    %rbx
    0.00 :	  496026:       41 5c                   pop    %r12
    0.00 :	  496028:       41 5d                   pop    %r13
    0.00 :	  49602a:       41 5e                   pop    %r14
    0.00 :	  49602c:       41 5f                   pop    %r15
    0.00 :	  49602e:       c9                      leaveq 
    0.00 :	  49602f:       c3                      retq   
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  496030:       48 8b 75 88             mov    -0x78(%rbp),%rsi
    0.00 :	  496034:       44 89 fa                mov    %r15d,%edx
    0.00 :	  496037:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  49603b:       ff 16                   callq  *(%rsi)
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  49603d:       4c 8b 45 88             mov    -0x78(%rbp),%r8
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
    0.00 :	  496041:       88 45 ae                mov    %al,-0x52(%rbp)
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:411
   12.50 :	  496044:       48 8d 55 b0             lea    -0x50(%rbp),%rdx
    0.00 :	  496048:       49 8b 36                mov    (%r14),%rsi
    0.00 :	  49604b:       0f be f8                movsbl %al,%edi
    0.00 :	  49604e:       44 89 f9                mov    %r15d,%ecx
    0.00 :	  496051:       e8 0a e6 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
    0.00 :	  496056:       80 7d ae 00             cmpb   $0x0,-0x52(%rbp)
    0.00 :	  49605a:       0f 84 08 ff ff ff       je     495f68 <heapgetpage+0x108>
    0.00 :	  496060:       eb 8a                   jmp    495fec <heapgetpage+0x18c>
    0.00 :	  496062:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  496068:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49606f:       00 
         :	        /*
         :	         * Be sure to check for interrupts at least once per page.  Checks at
         :	         * higher code levels won't be able to stop a seqscan that encounters many
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  496070:       e8 2b 62 20 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  496075:       0f 1f 00                nopl   (%rax)
    0.00 :	  496078:       e9 17 fe ff ff          jmpq   495e94 <heapgetpage+0x34>
    0.00 :	  49607d:       0f 1f 00                nopl   (%rax)
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        /* release previous scan buffer, if any */
         :	        if (BufferIsValid(scan->rs_cbuf))
         :	        {
         :	                ReleaseBuffer(scan->rs_cbuf);
    0.00 :	  496080:       e8 db ed 1d 00          callq  674e60 <ReleaseBuffer>
         :	                scan->rs_cbuf = InvalidBuffer;
    0.00 :	  496085:       41 c7 46 64 00 00 00    movl   $0x0,0x64(%r14)
    0.00 :	  49608c:       00 
    0.00 :	  49608d:       0f 1f 00                nopl   (%rax)
    0.00 :	  496090:       e9 f0 fd ff ff          jmpq   495e85 <heapgetpage+0x25>
    0.00 :	  496095:       0f 1f 00                nopl   (%rax)
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  496098:       48 8b 45 88             mov    -0x78(%rbp),%rax
    0.00 :	  49609c:       80 78 29 00             cmpb   $0x0,0x29(%rax)
    0.00 :	  4960a0:       0f 94 45 af             sete   -0x51(%rbp)
    0.00 :	  4960a4:       e9 8d fe ff ff          jmpq   495f36 <heapgetpage+0xd6>
    0.00 :	  4960a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
         :	        lines = PageGetMaxOffsetNumber(dp);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:367
   12.50 :	  4960b0:       0f b7 c0                movzwl %ax,%eax
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  4960b3:       c6 45 af 00             movb   $0x0,-0x51(%rbp)
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
         :	        lines = PageGetMaxOffsetNumber(dp);
    0.00 :	  4960b7:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4960bb:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4960bf:       89 45 90                mov    %eax,-0x70(%rbp)
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  4960c2:       f6 43 0a 04             testb  $0x4,0xa(%rbx)
    0.00 :	  4960c6:       0f 84 6a fe ff ff       je     495f36 <heapgetpage+0xd6>
    0.00 :	  4960cc:       eb ca                   jmp    496098 <heapgetpage+0x238>
    0.00 :	  4960ce:       66 90                   xchg   %ax,%ax
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
    0.00 :	  4960d0:       44 89 f8                mov    %r15d,%eax
    0.00 :	  4960d3:       48 8b 15 3e 70 6e 00    mov    0x6e703e(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4960da:       f7 d0                   not    %eax
    0.00 :	  4960dc:       48 98                   cltq   
    0.00 :	  4960de:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  4960e2:       e9 2c fe ff ff          jmpq   495f13 <heapgetpage+0xb3>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   37.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b16a0 <ExecEvalScalarVarFast>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
   37.50 :	  5b16a0:       55                      push   %rbp
         :	        Var                *variable = (Var *) exprstate->expr;
         :	        TupleTableSlot *slot;
         :	        AttrNumber      attnum;
         :
         :	        if (isDone)
    0.00 :	  5b16a1:       48 85 c9                test   %rcx,%rcx
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        Var                *variable = (Var *) exprstate->expr;
    0.00 :	  5b16a4:       4c 8b 47 08             mov    0x8(%rdi),%r8
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
   12.50 :	  5b16a8:       48 89 e5                mov    %rsp,%rbp
         :	        Var                *variable = (Var *) exprstate->expr;
         :	        TupleTableSlot *slot;
         :	        AttrNumber      attnum;
         :
         :	        if (isDone)
    0.00 :	  5b16ab:       74 06                   je     5b16b3 <ExecEvalScalarVarFast+0x13>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b16ad:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /* Get the input slot and attribute number we want */
         :	        switch (variable->varno)
    0.00 :	  5b16b3:       41 8b 40 04             mov    0x4(%r8),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
   25.00 :	  5b16b7:       3d e8 fd 00 00          cmp    $0xfde8,%eax
    0.00 :	  5b16bc:       74 1a                   je     5b16d8 <ExecEvalScalarVarFast+0x38>
   25.00 :	  5b16be:       3d e9 fd 00 00          cmp    $0xfde9,%eax
    0.00 :	  5b16c3:       74 2b                   je     5b16f0 <ExecEvalScalarVarFast+0x50>
         :
         :	                        /* INDEX_VAR is handled by default case */
         :
         :	                default:                                /* get the tuple from the relation being
         :	                                                                 * scanned */
         :	                        slot = econtext->ecxt_scantuple;
    0.00 :	  5b16c5:       48 8b 7e 08             mov    0x8(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16c9:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16ce:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16cf:       e9 2c dd eb ff          jmpq   46f400 <slot_getattr>
    0.00 :	  5b16d4:       0f 1f 40 00             nopl   0x0(%rax)
         :
         :	        /* Get the input slot and attribute number we want */
         :	        switch (variable->varno)
         :	        {
         :	                case INNER_VAR: /* get the tuple from the inner node */
         :	                        slot = econtext->ecxt_innertuple;
    0.00 :	  5b16d8:       48 8b 7e 10             mov    0x10(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16dc:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16e1:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16e2:       e9 19 dd eb ff          jmpq   46f400 <slot_getattr>
    0.00 :	  5b16e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5b16ee:       00 00 
         :	                case INNER_VAR: /* get the tuple from the inner node */
         :	                        slot = econtext->ecxt_innertuple;
         :	                        break;
         :
         :	                case OUTER_VAR: /* get the tuple from the outer node */
         :	                        slot = econtext->ecxt_outertuple;
    0.00 :	  5b16f0:       48 8b 7e 18             mov    0x18(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16f4:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16f9:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16fa:       e9 01 dd eb ff          jmpq   46f400 <slot_getattr>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:466
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:450
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:472
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:465
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:472
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:484
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:484
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b4110 <ExecClearTuple>:
         :	 *              NB: only the tuple is cleared, not the tuple descriptor (if any).
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *                                /* return: slot passed */
         :	ExecClearTuple(TupleTableSlot *slot)    /* slot in which to store tuple */
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:450
   12.50 :	  5b4110:       55                      push   %rbp
    0.00 :	  5b4111:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b4114:       53                      push   %rbx
    0.00 :	  5b4115:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b4118:       48 83 ec 08             sub    $0x8,%rsp
         :	        Assert(slot != NULL);
         :
         :	        /*
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b411c:       80 7f 05 00             cmpb   $0x0,0x5(%rdi)
    0.00 :	  5b4120:       75 5e                   jne    5b4180 <ExecClearTuple+0x70>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b4122:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
    0.00 :	  5b4126:       75 48                   jne    5b4170 <ExecClearTuple+0x60>
         :	        slot->tts_shouldFreeMin = false;
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:472
   12.50 :	  5b4128:       8b 7b 20                mov    0x20(%rbx),%edi
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        slot->tts_tuple = NULL;
    0.00 :	  5b412b:       48 c7 43 08 00 00 00    movq   $0x0,0x8(%rbx)
    0.00 :	  5b4132:       00 
         :	        slot->tts_mintuple = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:465
   12.50 :	  5b4133:       48 c7 43 38 00 00 00    movq   $0x0,0x38(%rbx)
    0.00 :	  5b413a:       00 
         :	        slot->tts_shouldFree = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:466
   25.00 :	  5b413b:       c6 43 05 00             movb   $0x0,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = false;
    0.00 :	  5b413f:       c6 43 06 00             movb   $0x0,0x6(%rbx)
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:472
   12.50 :	  5b4143:       85 ff                   test   %edi,%edi
    0.00 :	  5b4145:       74 05                   je     5b414c <ExecClearTuple+0x3c>
         :	                ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4147:       e8 14 0d 0c 00          callq  674e60 <ReleaseBuffer>
         :
         :	        slot->tts_buffer = InvalidBuffer;
    0.00 :	  5b414c:       c7 43 20 00 00 00 00    movl   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Mark it empty.
         :	         */
         :	        slot->tts_isempty = true;
    0.00 :	  5b4153:       c6 43 04 01             movb   $0x1,0x4(%rbx)
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
    0.00 :	  5b4157:       48 89 d8                mov    %rbx,%rax
         :
         :	        /*
         :	         * Mark it empty.
         :	         */
         :	        slot->tts_isempty = true;
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b415a:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :
         :	        return slot;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:484
   12.50 :	  5b4161:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5b4165:       5b                      pop    %rbx
    0.00 :	  5b4166:       c9                      leaveq 
   12.50 :	  5b4167:       c3                      retq   
    0.00 :	  5b4168:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b416f:       00 
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4170:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b4174:       e8 37 ab eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4179:       eb ad                   jmp    5b4128 <ExecClearTuple+0x18>
    0.00 :	  5b417b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4180:       48 8b 7f 08             mov    0x8(%rdi),%rdi
    0.00 :	  5b4184:       e8 37 ab eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4189:       eb 97                   jmp    5b4122 <ExecClearTuple+0x12>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:347
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b4480 <ExecStoreTuple>:
         :	TupleTableSlot *
         :	ExecStoreTuple(HeapTuple tuple,
         :	                           TupleTableSlot *slot,
         :	                           Buffer buffer,
         :	                           bool shouldFree)
         :	{
    0.00 :	  5b4480:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
   12.50 :	  5b4481:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b4484:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  5b4488:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  5b448c:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  5b448f:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  5b4493:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  5b4497:       48 83 ec 20             sub    $0x20,%rsp
         :	        Assert(BufferIsValid(buffer) ? (!shouldFree) : true);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b449b:       80 7e 05 00             cmpb   $0x0,0x5(%rsi)
         :	TupleTableSlot *
         :	ExecStoreTuple(HeapTuple tuple,
         :	                           TupleTableSlot *slot,
         :	                           Buffer buffer,
         :	                           bool shouldFree)
         :	{
    0.00 :	  5b449f:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5b44a2:       41 89 d4                mov    %edx,%r12d
    0.00 :	  5b44a5:       41 89 cd                mov    %ecx,%r13d
         :	        Assert(BufferIsValid(buffer) ? (!shouldFree) : true);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:347
   25.00 :	  5b44a8:       0f 85 92 00 00 00       jne    5b4540 <ExecStoreTuple+0xc0>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b44ae:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
    0.00 :	  5b44b2:       75 74                   jne    5b4528 <ExecStoreTuple+0xa8>
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
    0.00 :	  5b44b4:       8b 7b 20                mov    0x20(%rbx),%edi
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
    0.00 :	  5b44b7:       c6 43 04 00             movb   $0x0,0x4(%rbx)
         :	        slot->tts_shouldFree = shouldFree;
    0.00 :	  5b44bb:       44 88 6b 05             mov    %r13b,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = false;
    0.00 :	  5b44bf:       c6 43 06 00             movb   $0x0,0x6(%rbx)
         :	        slot->tts_tuple = tuple;
    0.00 :	  5b44c3:       4c 89 73 08             mov    %r14,0x8(%rbx)
         :	        slot->tts_mintuple = NULL;
    0.00 :	  5b44c7:       48 c7 43 38 00 00 00    movq   $0x0,0x38(%rbx)
    0.00 :	  5b44ce:       00 
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
    0.00 :	  5b44cf:       44 39 e7                cmp    %r12d,%edi
         :	        slot->tts_shouldFreeMin = false;
         :	        slot->tts_tuple = tuple;
         :	        slot->tts_mintuple = NULL;
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b44d2:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
    0.00 :	  5b44d9:       74 0d                   je     5b44e8 <ExecStoreTuple+0x68>
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b44db:       85 ff                   test   %edi,%edi
    0.00 :	  5b44dd:       75 31                   jne    5b4510 <ExecStoreTuple+0x90>
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b44df:       45 85 e4                test   %r12d,%r12d
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
    0.00 :	  5b44e2:       44 89 63 20             mov    %r12d,0x20(%rbx)
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b44e6:       75 18                   jne    5b4500 <ExecStoreTuple+0x80>
         :	                        IncrBufferRefCount(buffer);
         :	        }
         :
         :	        return slot;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
   12.50 :	  5b44e8:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b44eb:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  5b44f0:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5b44f4:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
   25.00 :	  5b44f9:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  5b44fe:       c9                      leaveq 
   25.00 :	  5b44ff:       c3                      retq   
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
         :	                        IncrBufferRefCount(buffer);
    0.00 :	  5b4500:       44 89 e7                mov    %r12d,%edi
    0.00 :	  5b4503:       e8 58 06 0c 00          callq  674b60 <IncrBufferRefCount>
    0.00 :	  5b4508:       eb de                   jmp    5b44e8 <ExecStoreTuple+0x68>
    0.00 :	  5b450a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4510:       e8 4b 09 0c 00          callq  674e60 <ReleaseBuffer>
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b4515:       45 85 e4                test   %r12d,%r12d
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
    0.00 :	  5b4518:       44 89 63 20             mov    %r12d,0x20(%rbx)
    0.00 :	  5b451c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b4520:       74 c6                   je     5b44e8 <ExecStoreTuple+0x68>
    0.00 :	  5b4522:       eb dc                   jmp    5b4500 <ExecStoreTuple+0x80>
    0.00 :	  5b4524:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4528:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b452c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5b4530:       e8 7b a7 eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4535:       e9 7a ff ff ff          jmpq   5b44b4 <ExecStoreTuple+0x34>
    0.00 :	  5b453a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4540:       48 8b 7e 08             mov    0x8(%rsi),%rdi
    0.00 :	  5b4544:       e8 77 a7 eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4549:       e9 60 ff ff ff          jmpq   5b44ae <ExecStoreTuple+0x2e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:842
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:842
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:843
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:852
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:855
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:852
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:859
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007584b0 <bpcharcmp>:
         :	        PG_RETURN_BOOL(cmp >= 0);
         :	}
         :
         :	Datum
         :	bpcharcmp(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:842
   12.50 :	  7584b0:       55                      push   %rbp
    0.00 :	  7584b1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7584b4:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  7584b8:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
   25.00 :	  7584bc:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7584c0:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7584c4:       48 83 ec 20             sub    $0x20,%rsp
    0.00 :	  7584c8:       49 89 fe                mov    %rdi,%r14
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:843
   12.50 :	  7584cb:       48 8b 7f 20             mov    0x20(%rdi),%rdi
    0.00 :	  7584cf:       e8 0c 68 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  7584d4:       49 8b 7e 28             mov    0x28(%r14),%rdi
         :	}
         :
         :	Datum
         :	bpcharcmp(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  7584d8:       49 89 c5                mov    %rax,%r13
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  7584db:       e8 00 68 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        int                     len1,
         :	                                len2;
         :	        int                     cmp;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  7584e0:       4c 89 ef                mov    %r13,%rdi
         :
         :	Datum
         :	bpcharcmp(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  7584e3:       49 89 c4                mov    %rax,%r12
         :	        int                     len1,
         :	                                len2;
         :	        int                     cmp;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  7584e6:       e8 a5 f8 ff ff          callq  757d90 <bcTruelen>
         :	        len2 = bcTruelen(arg2);
    0.00 :	  7584eb:       4c 89 e7                mov    %r12,%rdi
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
         :	        int                     len1,
         :	                                len2;
         :	        int                     cmp;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  7584ee:       89 c3                   mov    %eax,%ebx
         :	        len2 = bcTruelen(arg2);
    0.00 :	  7584f0:       e8 9b f8 ff ff          callq  757d90 <bcTruelen>
         :
         :	        cmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,
    0.00 :	  7584f5:       41 f6 04 24 01          testb  $0x1,(%r12)
         :	        int                     len1,
         :	                                len2;
         :	        int                     cmp;
         :
         :	        len1 = bcTruelen(arg1);
         :	        len2 = bcTruelen(arg2);
    0.00 :	  7584fa:       89 c1                   mov    %eax,%ecx
         :
         :	        cmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,
    0.00 :	  7584fc:       49 8d 54 24 01          lea    0x1(%r12),%rdx
    0.00 :	  758501:       49 8d 44 24 04          lea    0x4(%r12),%rax
    0.00 :	  758506:       49 8d 7d 01             lea    0x1(%r13),%rdi
    0.00 :	  75850a:       45 8b 46 18             mov    0x18(%r14),%r8d
    0.00 :	  75850e:       89 de                   mov    %ebx,%esi
    0.00 :	  758510:       48 0f 44 d0             cmove  %rax,%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:852
   12.50 :	  758514:       41 f6 45 00 01          testb  $0x1,0x0(%r13)
    0.00 :	  758519:       49 8d 45 04             lea    0x4(%r13),%rax
    0.00 :	  75851d:       48 0f 44 f8             cmove  %rax,%rdi
    0.00 :	  758521:       e8 8a 71 00 00          callq  75f6b0 <varstr_cmp>
         :	                                         PG_GET_COLLATION());
         :
         :	        PG_FREE_IF_COPY(arg1, 0);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:855
   12.50 :	  758526:       4d 3b 6e 20             cmp    0x20(%r14),%r13
         :	        int                     cmp;
         :
         :	        len1 = bcTruelen(arg1);
         :	        len2 = bcTruelen(arg2);
         :
         :	        cmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:852
   12.50 :	  75852a:       89 c3                   mov    %eax,%ebx
         :	                                         PG_GET_COLLATION());
         :
         :	        PG_FREE_IF_COPY(arg1, 0);
    0.00 :	  75852c:       74 08                   je     758536 <bpcharcmp+0x86>
    0.00 :	  75852e:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  758531:       e8 4a 06 04 00          callq  798b80 <pfree>
         :	        PG_FREE_IF_COPY(arg2, 1);
    0.00 :	  758536:       4d 3b 66 28             cmp    0x28(%r14),%r12
    0.00 :	  75853a:       74 08                   je     758544 <bpcharcmp+0x94>
    0.00 :	  75853c:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75853f:       e8 3c 06 04 00          callq  798b80 <pfree>
    0.00 :	  758544:       89 d8                   mov    %ebx,%eax
         :
         :	        PG_RETURN_INT32(cmp);
         :	}
    0.00 :	  758546:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  75854b:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  75854f:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  758554:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:859
   12.50 :	  758559:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   37.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:993
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:936
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:888
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:504
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:516
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782f20 <CHashInsert>:
         :	 * degrading performance; or CHashAllocate may enter a tight loop until such
         :	 * time as an element is deleted).
         :	 */
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
    0.00 :	  782f20:       55                      push   %rbp
    0.00 :	  782f21:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782f24:       41 57                   push   %r15
    0.00 :	  782f26:       41 56                   push   %r14
    0.00 :	  782f28:       41 55                   push   %r13
    0.00 :	  782f2a:       41 54                   push   %r12
    0.00 :	  782f2c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  782f2f:       53                      push   %rbx
    0.00 :	  782f30:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  782f34:       48 89 75 a0             mov    %rsi,-0x60(%rbp)
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  782f38:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  782f3c:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  782f40:       e8 0b d4 d0 ff          callq  490350 <hash_any>
    0.00 :	  782f45:       89 45 a8                mov    %eax,-0x58(%rbp)
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782f48:       41 23 44 24 10          and    0x10(%r12),%eax
         :	{
         :	        uint32          f_current;
         :	        CHashPtr        new;
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  782f4d:       8b 35 b5 5b 3e 00       mov    0x3e5bb5(%rip),%esi        # b68b08 <MyBackendId>
    0.00 :	  782f53:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
         :	 */
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782f59:       89 45 ac                mov    %eax,-0x54(%rbp)
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782f5c:       89 c0                   mov    %eax,%eax
    0.00 :	  782f5e:       4c 8d 3c 85 00 00 00    lea    0x0(,%rax,4),%r15
    0.00 :	  782f65:       00 
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
    0.00 :	  782f66:       8b 05 78 cd 43 00       mov    0x43cd78(%rip),%eax        # bbfce4 <MyProcPid>
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782f6c:       4d 03 7c 24 20          add    0x20(%r12),%r15
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
    0.00 :	  782f71:       41 39 44 24 38          cmp    %eax,0x38(%r12)
    0.00 :	  782f76:       74 26                   je     782f9e <CHashInsert+0x7e>
         :	        {
         :	                table->gc_pid = MyProcPid;
         :	                table->gc_next = ((uint32) MyProcPid) % CHashTableNGarbage(table);
    0.00 :	  782f78:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
    0.00 :	  782f7e:       41 8b 54 24 10          mov    0x10(%r12),%edx
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
         :	        {
         :	                table->gc_pid = MyProcPid;
    0.00 :	  782f83:       41 89 44 24 38          mov    %eax,0x38(%r12)
         :	                table->gc_next = ((uint32) MyProcPid) % CHashTableNGarbage(table);
    0.00 :	  782f88:       8b 05 56 cd 43 00       mov    0x43cd56(%rip),%eax        # bbfce4 <MyProcPid>
    0.00 :	  782f8e:       83 c2 01                add    $0x1,%edx
    0.00 :	  782f91:       d3 ea                   shr    %cl,%edx
    0.00 :	  782f93:       89 d1                   mov    %edx,%ecx
    0.00 :	  782f95:       31 d2                   xor    %edx,%edx
    0.00 :	  782f97:       f7 f1                   div    %ecx
    0.00 :	  782f99:       41 89 54 24 3c          mov    %edx,0x3c(%r12)
         :	{
         :	        uint32          f_current;
         :	        CHashPtr        new;
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  782f9e:       0f b7 cf                movzwl %di,%ecx
    0.00 :	  782fa1:       89 f0                   mov    %esi,%eax
    0.00 :	  782fa3:       31 d2                   xor    %edx,%edx
    0.00 :	  782fa5:       f7 f1                   div    %ecx
    0.00 :	  782fa7:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  782fad:       49 8b 74 24 28          mov    0x28(%r12),%rsi
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
         :	                return InvalidCHashPtr;
         :
         :	        /* If we're unable to empty the list via compare-and-swap, fail. */
         :	        if (!__sync_bool_compare_and_swap(b, garbage, InvalidCHashPtr))
    0.00 :	  782fb2:       41 bb fe ff ff ff       mov    $0xfffffffe,%r11d
         :	                 * If we attempt to pop the free-list and fail, we retry immediately
         :	                 * with the same free-list.  This reduces the frequency with which
         :	                 * we're obliged to update our hazard pointers, which is a material
         :	                 * savings due to the associated memory barrier.
         :	                 */
         :	                b = CHashTableGetFreeList(table, f_current);
    0.00 :	  782fb8:       44 8d 42 01             lea    0x1(%rdx),%r8d
    0.00 :	  782fbc:       44 89 c0                mov    %r8d,%eax
    0.00 :	  782fbf:       d3 e0                   shl    %cl,%eax
    0.00 :	  782fc1:       01 d0                   add    %edx,%eax
    0.00 :	  782fc3:       48 8d 0c 86             lea    (%rsi,%rax,4),%rcx
         :	                MyProc->hazard[0] = b;
    0.00 :	  782fc7:       48 8b 05 7a a9 3f 00    mov    0x3fa97a(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  782fce:       48 89 88 e8 02 00 00    mov    %rcx,0x2e8(%rax)
         :	                pg_memory_barrier();
    0.00 :	  782fd5:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	                new = *b;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:888
   12.50 :	  782fda:       8b 19                   mov    (%rcx),%ebx
         :	                while (!CHashPtrIsInvalid(new))
    0.00 :	  782fdc:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  782fdf:       76 23                   jbe    783004 <CHashInsert+0xe4>
    0.00 :	  782fe1:       e9 52 01 00 00          jmpq   783138 <CHashInsert+0x218>
    0.00 :	  782fe6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  782fed:       00 00 00 
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
         :	                                return new;
         :	                        CHashTableIncrementStatistic(table, CHS_Allocate_Fail);
    0.00 :	  782ff0:       49 83 84 24 a0 00 00    addq   $0x1,0xa0(%r12)
    0.00 :	  782ff7:       00 01 
         :	                        new = *b;
    0.00 :	  782ff9:       8b 19                   mov    (%rcx),%ebx
         :	                 */
         :	                b = CHashTableGetFreeList(table, f_current);
         :	                MyProc->hazard[0] = b;
         :	                pg_memory_barrier();
         :	                new = *b;
         :	                while (!CHashPtrIsInvalid(new))
    0.00 :	  782ffb:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  782ffe:       0f 87 34 01 00 00       ja     783138 <CHashInsert+0x218>
         :	                {
         :	                        CHashNode  *n = CHashTableGetNode(table, new);
    0.00 :	  783004:       89 de                   mov    %ebx,%esi
         :	                         * n is computed from table->freelist[f_current], which could
         :	                         * be modified by concurrent activity, so we need a dependency
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
    0.00 :	  783006:       49 8b 44 24 30          mov    0x30(%r12),%rax
         :	                MyProc->hazard[0] = b;
         :	                pg_memory_barrier();
         :	                new = *b;
         :	                while (!CHashPtrIsInvalid(new))
         :	                {
         :	                        CHashNode  *n = CHashTableGetNode(table, new);
    0.00 :	  78300b:       d1 ee                   shr    %esi
         :	                         * n is computed from table->freelist[f_current], which could
         :	                         * be modified by concurrent activity, so we need a dependency
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
    0.00 :	  78300d:       89 f2                   mov    %esi,%edx
    0.00 :	  78300f:       41 0f af 54 24 1c       imul   0x1c(%r12),%edx
    0.00 :	  783015:       8b 54 10 04             mov    0x4(%rax,%rdx,1),%edx
    0.00 :	  783019:       89 d8                   mov    %ebx,%eax
    0.00 :	  78301b:       f0 0f b1 11             lock cmpxchg %edx,(%rcx)
    0.00 :	  78301f:       75 cf                   jne    782ff0 <CHashInsert+0xd0>
         :	         * Allocate and initialize a new entry, on the assumption that the insert
         :	         * will succeed.  If it ends up failing, we must be sure to put this back
         :	         * on some free list, lest it be permanently leaked.
         :	         */
         :	        new = CHashAllocate(table);
         :	        nnew = CHashTableGetNode(table, new);
    0.00 :	  783021:       41 89 f5                mov    %esi,%r13d
         :	        nnew->un.hashcode = hashcode;
    0.00 :	  783024:       8b 4d a8                mov    -0x58(%rbp),%ecx
         :	         * Allocate and initialize a new entry, on the assumption that the insert
         :	         * will succeed.  If it ends up failing, we must be sure to put this back
         :	         * on some free list, lest it be permanently leaked.
         :	         */
         :	        new = CHashAllocate(table);
         :	        nnew = CHashTableGetNode(table, new);
    0.00 :	  783027:       45 0f af 6c 24 1c       imul   0x1c(%r12),%r13d
    0.00 :	  78302d:       4d 03 6c 24 30          add    0x30(%r12),%r13
         :	        nnew->un.hashcode = hashcode;
    0.00 :	  783032:       41 89 4d 04             mov    %ecx,0x4(%r13)
         :	        memcpy(CHashNodeGetItem(nnew), entry, table->desc.element_size);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:504
   12.50 :	  783036:       41 0f b7 54 24 0c       movzwl 0xc(%r12),%edx
    0.00 :	  78303c:       49 8d 7d 08             lea    0x8(%r13),%rdi
    0.00 :	  783040:       48 8b 75 a0             mov    -0x60(%rbp),%rsi
    0.00 :	  783044:       e8 a7 6b ce ff          callq  469bf0 <memcpy@plt>
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783049:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
    0.00 :	  78304f:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  783052:       d3 ea                   shr    %cl,%edx
    0.00 :	  783054:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  78305a:       89 d0                   mov    %edx,%eax
    0.00 :	  78305c:       d3 e8                   shr    %cl,%eax
    0.00 :	  78305e:       01 d0                   add    %edx,%eax
    0.00 :	  783060:       48 8b 15 e1 a8 3f 00    mov    0x3fa8e1(%rip),%rdx        # b7d948 <MyProc>
    0.00 :	  783067:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  78306b:       49 03 44 24 28          add    0x28(%r12),%rax
    0.00 :	  783070:       48 89 82 e8 02 00 00    mov    %rax,0x2e8(%rdx)
         :	        pg_memory_barrier();
    0.00 :	  783077:       f0 83 04 24 00          lock addl $0x0,(%rsp)
    0.00 :	  78307c:       4c 8d 75 b0             lea    -0x50(%rbp),%r14
    0.00 :	  783080:       eb 20                   jmp    7830a2 <CHashInsert+0x182>
    0.00 :	  783082:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * where N is the number of buckets and M is the number of elements
         :	                 * in the table.  Even for a quite modestly size table this is likely
         :	                 * to exceed the number of CPU cores.
         :	                 */
         :	                Assert(!CHashPtrIsMarked(scan.target));
         :	                nnew->next = scan.target;
    0.00 :	  783088:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  78308b:       41 89 45 00             mov    %eax,0x0(%r13)
         :	                if (!__sync_bool_compare_and_swap(scan.pointer_to_target,
    0.00 :	  78308f:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  783093:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  783096:       f0 0f b1 1a             lock cmpxchg %ebx,(%rdx)
    0.00 :	  78309a:       74 49                   je     7830e5 <CHashInsert+0x1c5>
         :	                                                                                  scan.target, new))
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_Insert_Retry);
    0.00 :	  78309c:       49 83 44 24 60 01       addq   $0x1,0x60(%r12)
         :	         * Scan the bucket.  If we don't find a match, use compare-and-swap to
         :	         * insert the new node at the insert position.  If we do find a match,
         :	         * return the data to the caller.
         :	         */
         :	retry:
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
    0.00 :	  7830a2:       48 8b 4d a0             mov    -0x60(%rbp),%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:516
   12.50 :	  7830a6:       8b 55 a8                mov    -0x58(%rbp),%edx
    0.00 :	  7830a9:       4d 89 f0                mov    %r14,%r8
    0.00 :	  7830ac:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  7830af:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7830b2:       e8 e9 fb ff ff          callq  782ca0 <CHashBucketScan>
         :	        if (scan.found)
    0.00 :	  7830b7:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  7830bb:       74 cb                   je     783088 <CHashInsert+0x168>
         :	                memcpy(((char *) entry) + table->desc.key_size,
    0.00 :	  7830bd:       41 0f b7 44 24 0e       movzwl 0xe(%r12),%eax
    0.00 :	  7830c3:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  7830c7:       41 0f b7 54 24 0c       movzwl 0xc(%r12),%edx
    0.00 :	  7830cd:       0f b7 f0                movzwl %ax,%esi
    0.00 :	  7830d0:       48 01 f7                add    %rsi,%rdi
    0.00 :	  7830d3:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	  7830d7:       48 03 75 c0             add    -0x40(%rbp),%rsi
    0.00 :	  7830db:       29 c2                   sub    %eax,%edx
    0.00 :	  7830dd:       48 63 d2                movslq %edx,%rdx
    0.00 :	  7830e0:       e8 0b 6b ce ff          callq  469bf0 <memcpy@plt>
         :	                }
         :	        }
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  7830e5:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
    0.00 :	  7830ea:       48 8b 05 57 a8 3f 00    mov    0x3fa857(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  7830f1:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  7830f8:       00 00 00 00 
         :	         * guarantees that any allocation still in progress at the time this
         :	         * element makes it back to the freelist is trying to allocate some
         :	         * other node.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_Insert);
         :	        if (scan.found)
    0.00 :	  7830fc:       31 c0                   xor    %eax,%eax
         :	         * progress at the time we popped the freelist has completed.  This
         :	         * guarantees that any allocation still in progress at the time this
         :	         * element makes it back to the freelist is trying to allocate some
         :	         * other node.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_Insert);
    0.00 :	  7830fe:       49 83 44 24 50 01       addq   $0x1,0x50(%r12)
         :	        if (scan.found)
    0.00 :	  783104:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  783108:       74 17                   je     783121 <CHashInsert+0x201>
         :	        {
         :	                CHashTableIncrementStatistic(table, CHS_Insert_Failed);
    0.00 :	  78310a:       49 83 44 24 58 01       addq   $0x1,0x58(%r12)
         :	                CHashAddToGarbage(table, bucket, new);
    0.00 :	  783110:       8b 75 ac                mov    -0x54(%rbp),%esi
    0.00 :	  783113:       89 da                   mov    %ebx,%edx
    0.00 :	  783115:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  783118:       e8 33 fb ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  78311d:       0f b6 45 c8             movzbl -0x38(%rbp),%eax
    0.00 :	  783121:       84 c0                   test   %al,%al
    0.00 :	  783123:       0f 94 c0                sete   %al
         :	        }
         :
         :	        /* The insert succeeded if and only if no duplicate was found. */
         :	        return !scan.found;
         :	}
    0.00 :	  783126:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  78312a:       5b                      pop    %rbx
    0.00 :	  78312b:       41 5c                   pop    %r12
    0.00 :	  78312d:       41 5d                   pop    %r13
    0.00 :	  78312f:       41 5e                   pop    %r14
    0.00 :	  783131:       41 5f                   pop    %r15
    0.00 :	  783133:       c9                      leaveq 
    0.00 :	  783134:       c3                      retq   
    0.00 :	  783135:       0f 1f 00                nopl   (%rax)
         :	        CHashPtr        new;
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  783138:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
    0.00 :	  78313e:       8b 05 c4 59 3e 00       mov    0x3e59c4(%rip),%eax        # b68b08 <MyBackendId>
    0.00 :	  783144:       31 d2                   xor    %edx,%edx
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  783146:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  78314c:       4d 8b 4c 24 28          mov    0x28(%r12),%r9
         :	        CHashPtr        new;
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  783151:       f7 f7                   div    %edi
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  783153:       8d 42 01                lea    0x1(%rdx),%eax
    0.00 :	  783156:       d3 e0                   shl    %cl,%eax
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783158:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  78315e:       01 d0                   add    %edx,%eax
    0.00 :	  783160:       4c 8d 14 85 00 00 00    lea    0x0(,%rax,4),%r10
    0.00 :	  783167:       00 
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783168:       41 8b 44 24 3c          mov    0x3c(%r12),%eax
    0.00 :	  78316d:       8d 50 01                lea    0x1(%rax),%edx
    0.00 :	  783170:       41 8b 44 24 10          mov    0x10(%r12),%eax
    0.00 :	  783175:       8d 70 01                lea    0x1(%rax),%esi
    0.00 :	  783178:       89 d0                   mov    %edx,%eax
    0.00 :	  78317a:       31 d2                   xor    %edx,%edx
    0.00 :	  78317c:       d3 ee                   shr    %cl,%esi
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  78317e:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783184:       f7 f6                   div    %esi
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  783186:       4c 89 ce                mov    %r9,%rsi
    0.00 :	  783189:       89 d0                   mov    %edx,%eax
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  78318b:       41 89 54 24 3c          mov    %edx,0x3c(%r12)
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  783190:       d3 e8                   shr    %cl,%eax
    0.00 :	  783192:       01 d0                   add    %edx,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:936
   25.00 :	  783194:       49 8d 14 81             lea    (%r9,%rax,4),%rdx
         :	        garbage = *b;
    0.00 :	  783198:       8b 1a                   mov    (%rdx),%ebx
         :
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
    0.00 :	  78319a:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  78319d:       76 11                   jbe    7831b0 <CHashInsert+0x290>
         :	                new = CHashAllocateViaGC(table);
         :	                if (!CHashPtrIsInvalid(new))
         :	                        return new;
         :
         :	                /* Advance to next freelist. */
         :	                f_current = (f_current + 1) % CHashTableNFreeLists(table);
    0.00 :	  78319f:       44 89 c0                mov    %r8d,%eax
    0.00 :	  7831a2:       31 d2                   xor    %edx,%edx
    0.00 :	  7831a4:       f7 f7                   div    %edi
    0.00 :	  7831a6:       e9 0d fe ff ff          jmpq   782fb8 <CHashInsert+0x98>
    0.00 :	  7831ab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
         :	                return InvalidCHashPtr;
         :
         :	        /* If we're unable to empty the list via compare-and-swap, fail. */
         :	        if (!__sync_bool_compare_and_swap(b, garbage, InvalidCHashPtr))
    0.00 :	  7831b0:       89 d8                   mov    %ebx,%eax
    0.00 :	  7831b2:       f0 44 0f b1 1a          lock cmpxchg %r11d,(%rdx)
    0.00 :	  7831b7:       74 1c                   je     7831d5 <CHashInsert+0x2b5>
         :	        {
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Dequeue_Fail);
    0.00 :	  7831b9:       49 83 84 24 b0 00 00    addq   $0x1,0xb0(%r12)
    0.00 :	  7831c0:       00 01 
    0.00 :	  7831c2:       49 8b 74 24 28          mov    0x28(%r12),%rsi
    0.00 :	  7831c7:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  7831cd:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
    0.00 :	  7831d3:       eb ca                   jmp    78319f <CHashInsert+0x27f>
         :	         * requeues the garbage if it's not immediately recycleable, but
         :	         * it's not clear that we need such a thing.  On the flip side we
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
    0.00 :	  7831d5:       49 83 84 24 b8 00 00    addq   $0x1,0xb8(%r12)
    0.00 :	  7831dc:       00 01 
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  7831de:       4f 8d 04 11             lea    (%r9,%r10,1),%r8
         :	         * it's not clear that we need such a thing.  On the flip side we
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
    0.00 :	  7831e2:       48 8b 05 5f a7 3f 00    mov    0x3fa75f(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  7831e9:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  7831f0:       00 00 00 00 
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
    0.00 :	  7831f4:       48 8b 35 5d a7 3f 00    mov    0x3fa75d(%rip),%rsi        # b7d958 <ProcGlobal>
    0.00 :	  7831fb:       8b 46 10                mov    0x10(%rsi),%eax
    0.00 :	  7831fe:       85 c0                   test   %eax,%eax
    0.00 :	  783200:       74 5f                   je     783261 <CHashInsert+0x341>
    0.00 :	  783202:       31 ff                   xor    %edi,%edi
    0.00 :	  783204:       eb 1a                   jmp    783220 <CHashInsert+0x300>
    0.00 :	  783206:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  78320d:       00 00 00 
         :	        {
         :	                volatile PGPROC *proc = &ProcGlobal->allProcs[i];
         :	                void       *hazard;
         :
         :	                hazard = proc->hazard[0];
         :	                if (hazard == b || hazard == fh)
    0.00 :	  783210:       49 39 c8                cmp    %rcx,%r8
    0.00 :	  783213:       74 23                   je     783238 <CHashInsert+0x318>
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
    0.00 :	  783215:       83 c7 01                add    $0x1,%edi
    0.00 :	  783218:       3b 7e 10                cmp    0x10(%rsi),%edi
    0.00 :	  78321b:       73 44                   jae    783261 <CHashInsert+0x341>
    0.00 :	  78321d:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                volatile PGPROC *proc = &ProcGlobal->allProcs[i];
    0.00 :	  783220:       89 f8                   mov    %edi,%eax
    0.00 :	  783222:       48 69 c0 f0 02 00 00    imul   $0x2f0,%rax,%rax
    0.00 :	  783229:       48 03 06                add    (%rsi),%rax
         :	                void       *hazard;
         :
         :	                hazard = proc->hazard[0];
    0.00 :	  78322c:       48 8b 88 e8 02 00 00    mov    0x2e8(%rax),%rcx
         :	                if (hazard == b || hazard == fh)
    0.00 :	  783233:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  783236:       75 d8                   jne    783210 <CHashInsert+0x2f0>
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_GC_Spin);
    0.00 :	  783238:       49 83 84 24 c0 00 00    addq   $0x1,0xc0(%r12)
    0.00 :	  78323f:       00 01 
         :	                        do
         :	                        {
         :	                                hazard = proc->hazard[0];
    0.00 :	  783241:       48 8b 88 e8 02 00 00    mov    0x2e8(%rax),%rcx
         :	                        } while (hazard == b || hazard == fh);
    0.00 :	  783248:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  78324b:       74 f4                   je     783241 <CHashInsert+0x321>
    0.00 :	  78324d:       49 39 c8                cmp    %rcx,%r8
    0.00 :	  783250:       74 ef                   je     783241 <CHashInsert+0x321>
    0.00 :	  783252:       48 8b 35 ff a6 3f 00    mov    0x3fa6ff(%rip),%rsi        # b7d958 <ProcGlobal>
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
    0.00 :	  783259:       83 c7 01                add    $0x1,%edi
    0.00 :	  78325c:       3b 7e 10                cmp    0x10(%rsi),%edi
    0.00 :	  78325f:       72 bf                   jb     783220 <CHashInsert+0x300>
         :	                }
         :	        }
         :
         :	        /* Remove one item from list to satisfy current allocation. */
         :	        new = garbage;
         :	        n = CHashTableGetNode(table, new);
    0.00 :	  783261:       89 de                   mov    %ebx,%esi
         :	        pg_read_barrier_depends();
         :	        fhead = n->un.gcnext;
    0.00 :	  783263:       49 8b 44 24 30          mov    0x30(%r12),%rax
         :	                }
         :	        }
         :
         :	        /* Remove one item from list to satisfy current allocation. */
         :	        new = garbage;
         :	        n = CHashTableGetNode(table, new);
    0.00 :	  783268:       d1 ee                   shr    %esi
         :	        pg_read_barrier_depends();
         :	        fhead = n->un.gcnext;
    0.00 :	  78326a:       89 f2                   mov    %esi,%edx
    0.00 :	  78326c:       41 0f af 54 24 1c       imul   0x1c(%r12),%edx
    0.00 :	  783272:       8b 54 10 04             mov    0x4(%rax,%rdx,1),%edx
         :
         :	        if (CHashPtrIsInvalid(fhead))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:993
   37.50 :	  783276:       83 fa fd                cmp    $0xfffffffd,%edx
    0.00 :	  783279:       76 13                   jbe    78328e <CHashInsert+0x36e>
         :	                 * before we overwrite n->un.gcnext with a new hashcode.
         :	                 * (This is only needed when we reclaim exactly one node,
         :	                 * because in any other case we'll do a compare-and-swap
         :	                 * before returning, which implies a full barrier.)
         :	                 */
         :	                pg_memory_barrier();
    0.00 :	  78327b:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Skipped);
    0.00 :	  783280:       49 83 84 24 c8 00 00    addq   $0x1,0xc8(%r12)
    0.00 :	  783287:       00 01 
    0.00 :	  783289:       e9 93 fd ff ff          jmpq   783021 <CHashInsert+0x101>
         :	        }
         :	        else if (__sync_bool_compare_and_swap(fh, InvalidCHashPtr, fhead))
    0.00 :	  78328e:       b8 fe ff ff ff          mov    $0xfffffffe,%eax
    0.00 :	  783293:       f0 41 0f b1 10          lock cmpxchg %edx,(%r8)
    0.00 :	  783298:       74 41                   je     7832db <CHashInsert+0x3bb>
         :	        {
         :	                /*
         :	                 * Our free list is empty, and we've succesfully pushed the
         :	                 * reclaimed nodes onto it.  So we're done.
         :	                 */
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Fast);
    0.00 :	  78329a:       4d 8b 4c 24 30          mov    0x30(%r12),%r9
    0.00 :	  78329f:       41 8b 7c 24 1c          mov    0x1c(%r12),%edi
    0.00 :	  7832a4:       89 d0                   mov    %edx,%eax
         :
         :	                /* Walk list of reclaimed elements to end. */
         :	                fcurrent = fhead;
         :	                for (;;)
         :	                {
         :	                        n = CHashTableGetNode(table, fcurrent);
    0.00 :	  7832a6:       d1 e8                   shr    %eax
    0.00 :	  7832a8:       0f af c7                imul   %edi,%eax
    0.00 :	  7832ab:       49 8d 0c 01             lea    (%r9,%rax,1),%rcx
         :	                        fnext = n->un.gcnext;
    0.00 :	  7832af:       8b 41 04                mov    0x4(%rcx),%eax
         :	                        if (CHashPtrIsInvalid(fnext))
    0.00 :	  7832b2:       83 f8 fd                cmp    $0xfffffffd,%eax
    0.00 :	  7832b5:       76 ef                   jbe    7832a6 <CHashInsert+0x386>
    0.00 :	  7832b7:       eb 10                   jmp    7832c9 <CHashInsert+0x3a9>
    0.00 :	  7832b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                {
         :	                        oldhead = *fh;
         :	                        n->un.gcnext = oldhead;
         :	                        if (__sync_bool_compare_and_swap(fh, oldhead, fhead))
         :	                                break;
         :	                        CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Retry);
    0.00 :	  7832c0:       49 83 84 24 d8 00 00    addq   $0x1,0xd8(%r12)
    0.00 :	  7832c7:       00 01 
         :	                }
         :
         :	                /* Push reclaimed elements onto home free list. */
         :	                for (;;)
         :	                {
         :	                        oldhead = *fh;
    0.00 :	  7832c9:       41 8b 00                mov    (%r8),%eax
         :	                        n->un.gcnext = oldhead;
    0.00 :	  7832cc:       89 41 04                mov    %eax,0x4(%rcx)
         :	                        if (__sync_bool_compare_and_swap(fh, oldhead, fhead))
    0.00 :	  7832cf:       f0 41 0f b1 10          lock cmpxchg %edx,(%r8)
    0.00 :	  7832d4:       75 ea                   jne    7832c0 <CHashInsert+0x3a0>
    0.00 :	  7832d6:       e9 46 fd ff ff          jmpq   783021 <CHashInsert+0x101>
         :	        {
         :	                /*
         :	                 * Our free list is empty, and we've succesfully pushed the
         :	                 * reclaimed nodes onto it.  So we're done.
         :	                 */
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Fast);
    0.00 :	  7832db:       49 83 84 24 d0 00 00    addq   $0x1,0xd0(%r12)
    0.00 :	  7832e2:       00 01 
    0.00 :	  7832e4:       e9 38 fd ff ff          jmpq   783021 <CHashInsert+0x101>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:138
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:141
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:146
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:138
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:150
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:130
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:133
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079d300 <qsort_tuple>:
         :	                        (cmp_tuple(a, c, state) < 0 ? a : c));
         :	}
         :
         :	static void
         :	qsort_tuple(SortTuple *a, size_t n, SortTupleComparator cmp_tuple, Tuplesortstate *state)
         :	{
    0.00 :	  79d300:       55                      push   %rbp
    0.00 :	  79d301:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79d304:       41 57                   push   %r15
    0.00 :	  79d306:       41 56                   push   %r14
    0.00 :	  79d308:       41 55                   push   %r13
    0.00 :	  79d30a:       41 54                   push   %r12
    0.00 :	  79d30c:       49 89 f4                mov    %rsi,%r12
    0.00 :	  79d30f:       53                      push   %rbx
    0.00 :	  79d310:       48 83 ec 38             sub    $0x38,%rsp
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d314:       0f b6 05 75 cd 41 00    movzbl 0x41cd75(%rip),%eax        # bba090 <InterruptPending>
         :	                        (cmp_tuple(a, c, state) < 0 ? a : c));
         :	}
         :
         :	static void
         :	qsort_tuple(SortTuple *a, size_t n, SortTupleComparator cmp_tuple, Tuplesortstate *state)
         :	{
    0.00 :	  79d31b:       48 89 7d b0             mov    %rdi,-0x50(%rbp)
    0.00 :	  79d31f:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
    0.00 :	  79d323:       48 89 4d a0             mov    %rcx,-0x60(%rbp)
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d327:       84 c0                   test   %al,%al
    0.00 :	  79d329:       0f 85 86 02 00 00       jne    79d5b5 <qsort_tuple+0x2b5>
         :	        if (n < 7)
    0.00 :	  79d32f:       49 83 fc 06             cmp    $0x6,%r12
    0.00 :	  79d333:       0f 86 8b 02 00 00       jbe    79d5c4 <qsort_tuple+0x2c4>
         :	                        for (pl = pm; pl > a && cmp_tuple(pl - 1, pl, state) > 0; pl--)
         :	                                swap(pl, pl - 1);
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  79d339:       48 8b 5d b0             mov    -0x50(%rbp),%rbx
    0.00 :	  79d33d:       4c 8b 75 b0             mov    -0x50(%rbp),%r14
    0.00 :	  79d341:       4b 8d 04 64             lea    (%r12,%r12,2),%rax
    0.00 :	  79d345:       48 8d 04 c3             lea    (%rbx,%rax,8),%rax
    0.00 :	  79d349:       49 83 c6 18             add    $0x18,%r14
    0.00 :	  79d34d:       49 39 c6                cmp    %rax,%r14
    0.00 :	  79d350:       48 89 45 c8             mov    %rax,-0x38(%rbp)
    0.00 :	  79d354:       0f 83 fe 02 00 00       jae    79d658 <qsort_tuple+0x358>
    0.00 :	  79d35a:       4c 89 f3                mov    %r14,%rbx
    0.00 :	  79d35d:       eb 21                   jmp    79d380 <qsort_tuple+0x80>
    0.00 :	  79d35f:       90                      nop
         :	        {
         :	                CHECK_FOR_INTERRUPTS();
         :	                if (cmp_tuple(pm - 1, pm, state) > 0)
    0.00 :	  79d360:       48 8d 7b e8             lea    -0x18(%rbx),%rdi
    0.00 :	  79d364:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  79d368:       48 89 de                mov    %rbx,%rsi
    0.00 :	  79d36b:       ff 55 a8                callq  *-0x58(%rbp)
    0.00 :	  79d36e:       85 c0                   test   %eax,%eax
    0.00 :	  79d370:       7f 20                   jg     79d392 <qsort_tuple+0x92>
         :	                        for (pl = pm; pl > a && cmp_tuple(pl - 1, pl, state) > 0; pl--)
         :	                                swap(pl, pl - 1);
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  79d372:       48 83 c3 18             add    $0x18,%rbx
    0.00 :	  79d376:       48 3b 5d c8             cmp    -0x38(%rbp),%rbx
    0.00 :	  79d37a:       0f 83 d8 02 00 00       jae    79d658 <qsort_tuple+0x358>
         :	        {
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  79d380:       0f b6 05 09 cd 41 00    movzbl 0x41cd09(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  79d387:       84 c0                   test   %al,%al
    0.00 :	  79d389:       74 d5                   je     79d360 <qsort_tuple+0x60>
    0.00 :	  79d38b:       e8 10 ef ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  79d390:       eb ce                   jmp    79d360 <qsort_tuple+0x60>
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = a + (n / 2);
    0.00 :	  79d392:       4c 89 e0                mov    %r12,%rax
    0.00 :	  79d395:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  79d399:       48 d1 e8                shr    %rax
         :	        if (n > 7)
    0.00 :	  79d39c:       49 83 fc 07             cmp    $0x7,%r12
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = a + (n / 2);
    0.00 :	  79d3a0:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79d3a4:       4c 8d 2c c2             lea    (%rdx,%rax,8),%r13
         :	        if (n > 7)
    0.00 :	  79d3a8:       0f 85 07 04 00 00       jne    79d7b5 <qsort_tuple+0x4b5>
    0.00 :	  79d3ae:       48 81 c2 90 00 00 00    add    $0x90,%rdx
    0.00 :	  79d3b5:       48 89 55 c0             mov    %rdx,-0x40(%rbp)
         :	                        pm = med3_tuple(pm - d, pm, pm + d, cmp_tuple, state);
         :	                        pn = med3_tuple(pn - 2 * d, pn - d, pn, cmp_tuple, state);
         :	                }
         :	                pm = med3_tuple(pl, pm, pn, cmp_tuple, state);
         :	        }
         :	        swap(a, pm);
    0.00 :	  79d3b9:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  79d3bd:       48 8b 5d b0             mov    -0x50(%rbp),%rbx
    0.00 :	  79d3c1:       8b 50 14                mov    0x14(%rax),%edx
    0.00 :	  79d3c4:       0f b6 48 10             movzbl 0x10(%rax),%ecx
    0.00 :	  79d3c8:       49 89 df                mov    %rbx,%r15
    0.00 :	  79d3cb:       48 8b 70 08             mov    0x8(%rax),%rsi
    0.00 :	  79d3cf:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  79d3d2:       49 83 c7 30             add    $0x30,%r15
    0.00 :	  79d3d6:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  79d3da:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  79d3dd:       49 8b 45 08             mov    0x8(%r13),%rax
    0.00 :	  79d3e1:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  79d3e5:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  79d3e9:       48 89 43 10             mov    %rax,0x10(%rbx)
    0.00 :	  79d3ed:       41 89 55 14             mov    %edx,0x14(%r13)
    0.00 :	  79d3f1:       41 88 4d 10             mov    %cl,0x10(%r13)
    0.00 :	  79d3f5:       49 89 75 08             mov    %rsi,0x8(%r13)
    0.00 :	  79d3f9:       49 89 7d 00             mov    %rdi,0x0(%r13)
    0.00 :	  79d3fd:       4c 8b 65 c0             mov    -0x40(%rbp),%r12
    0.00 :	  79d401:       4c 89 75 b8             mov    %r14,-0x48(%rbp)
    0.00 :	  79d405:       4d 89 e5                mov    %r12,%r13
    0.00 :	  79d408:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  79d40f:       00 
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
         :	                                pa++;
    0.00 :	  79d410:       4d 8d 77 e8             lea    -0x18(%r15),%r14
         :	        swap(a, pm);
         :	        pa = pb = a + 1;
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_tuple(pb, a, state)) <= 0)
    0.00 :	  79d414:       4d 39 f4                cmp    %r14,%r12
    0.00 :	  79d417:       0f 83 53 02 00 00       jae    79d670 <qsort_tuple+0x370>
         :	                swap(pb, pc);
         :	                pb++;
         :	                pc--;
         :	        }
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
    0.00 :	  79d41d:       4d 89 f2                mov    %r14,%r10
    0.00 :	  79d420:       4c 2b 55 b8             sub    -0x48(%rbp),%r10
    0.00 :	  79d424:       48 b8 ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rax
    0.00 :	  79d42b:       aa aa aa 
    0.00 :	  79d42e:       48 ba ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rdx
    0.00 :	  79d435:       aa aa aa 
    0.00 :	  79d438:       49 c1 fa 03             sar    $0x3,%r10
    0.00 :	  79d43c:       4c 0f af d0             imul   %rax,%r10
    0.00 :	  79d440:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  79d444:       48 2b 45 b0             sub    -0x50(%rbp),%rax
    0.00 :	  79d448:       48 c1 f8 03             sar    $0x3,%rax
    0.00 :	  79d44c:       48 0f af c2             imul   %rdx,%rax
    0.00 :	  79d450:       4c 39 d0                cmp    %r10,%rax
    0.00 :	  79d453:       49 0f 4f c2             cmovg  %r10,%rax
         :	        vecswap(a, pb - r, r);
    0.00 :	  79d457:       85 c0                   test   %eax,%eax
    0.00 :	  79d459:       7e 66                   jle    79d4c1 <qsort_tuple+0x1c1>
    0.00 :	  79d45b:       4c 63 d8                movslq %eax,%r11
    0.00 :	  79d45e:       4d 89 f1                mov    %r14,%r9
    0.00 :	  79d461:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  79d464:       4b 8d 04 5b             lea    (%r11,%r11,2),%rax
    0.00 :	  79d468:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  79d46c:       49 29 c1                sub    %rax,%r9
    0.00 :	  79d46f:       90                      nop
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  79d470:       48 8b 5d b0             mov    -0x50(%rbp),%rbx
         :	                *a++ = *b;
    0.00 :	  79d474:       4b 8b 04 01             mov    (%r9,%r8,1),%rax
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  79d478:       4a 8b 3c 03             mov    (%rbx,%r8,1),%rdi
         :	                *a++ = *b;
    0.00 :	  79d47c:       4a 89 04 03             mov    %rax,(%rbx,%r8,1)
    0.00 :	  79d480:       4b 8b 44 01 08          mov    0x8(%r9,%r8,1),%rax
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  79d485:       42 0f b6 4c 03 10       movzbl 0x10(%rbx,%r8,1),%ecx
    0.00 :	  79d48b:       42 8b 54 03 14          mov    0x14(%rbx,%r8,1),%edx
    0.00 :	  79d490:       4a 8b 74 03 08          mov    0x8(%rbx,%r8,1),%rsi
         :	                *a++ = *b;
    0.00 :	  79d495:       4a 89 44 03 08          mov    %rax,0x8(%rbx,%r8,1)
    0.00 :	  79d49a:       4b 8b 44 01 10          mov    0x10(%r9,%r8,1),%rax
    0.00 :	  79d49f:       4a 89 44 03 10          mov    %rax,0x10(%rbx,%r8,1)
         :	                *b++ = t;
    0.00 :	  79d4a4:       43 89 54 01 14          mov    %edx,0x14(%r9,%r8,1)
    0.00 :	  79d4a9:       43 88 4c 01 10          mov    %cl,0x10(%r9,%r8,1)
    0.00 :	  79d4ae:       4b 89 74 01 08          mov    %rsi,0x8(%r9,%r8,1)
    0.00 :	  79d4b3:       4b 89 3c 01             mov    %rdi,(%r9,%r8,1)
         :	        } while (--n > 0);
    0.00 :	  79d4b7:       49 83 c0 18             add    $0x18,%r8
    0.00 :	  79d4bb:       49 83 eb 01             sub    $0x1,%r11
    0.00 :	  79d4bf:       75 af                   jne    79d470 <qsort_tuple+0x170>
         :	                pc--;
         :	        }
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
         :	        vecswap(a, pb - r, r);
         :	        r = Min(pd - pc, pn - pd - 1);
    0.00 :	  79d4c1:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  79d4c4:       48 b8 ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rax
    0.00 :	  79d4cb:       aa aa aa 
    0.00 :	  79d4ce:       48 ba ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rdx
    0.00 :	  79d4d5:       aa aa aa 
    0.00 :	  79d4d8:       4c 29 e3                sub    %r12,%rbx
    0.00 :	  79d4db:       48 c1 fb 03             sar    $0x3,%rbx
    0.00 :	  79d4df:       48 0f af d8             imul   %rax,%rbx
    0.00 :	  79d4e3:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  79d4e7:       4c 29 e8                sub    %r13,%rax
    0.00 :	  79d4ea:       48 c1 f8 03             sar    $0x3,%rax
    0.00 :	  79d4ee:       48 0f af c2             imul   %rdx,%rax
    0.00 :	  79d4f2:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  79d4f6:       48 39 d8                cmp    %rbx,%rax
    0.00 :	  79d4f9:       48 0f 4f c3             cmovg  %rbx,%rax
         :	        vecswap(pb, pn - r, r);
    0.00 :	  79d4fd:       85 c0                   test   %eax,%eax
    0.00 :	  79d4ff:       7e 6c                   jle    79d56d <qsort_tuple+0x26d>
    0.00 :	  79d501:       4c 63 d8                movslq %eax,%r11
    0.00 :	  79d504:       4c 8b 4d c8             mov    -0x38(%rbp),%r9
    0.00 :	  79d508:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  79d50b:       4b 8d 04 5b             lea    (%r11,%r11,2),%rax
    0.00 :	  79d50f:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  79d513:       49 29 c1                sub    %rax,%r9
    0.00 :	  79d516:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  79d51d:       00 00 00 
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
         :	                *a++ = *b;
    0.00 :	  79d520:       4b 8b 04 01             mov    (%r9,%r8,1),%rax
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  79d524:       4b 8b 3c 06             mov    (%r14,%r8,1),%rdi
    0.00 :	  79d528:       43 0f b6 4c 06 10       movzbl 0x10(%r14,%r8,1),%ecx
    0.00 :	  79d52e:       43 8b 54 06 14          mov    0x14(%r14,%r8,1),%edx
    0.00 :	  79d533:       4b 8b 74 06 08          mov    0x8(%r14,%r8,1),%rsi
         :	                *a++ = *b;
    0.00 :	  79d538:       4b 89 04 06             mov    %rax,(%r14,%r8,1)
    0.00 :	  79d53c:       4b 8b 44 01 08          mov    0x8(%r9,%r8,1),%rax
    0.00 :	  79d541:       4b 89 44 06 08          mov    %rax,0x8(%r14,%r8,1)
    0.00 :	  79d546:       4b 8b 44 01 10          mov    0x10(%r9,%r8,1),%rax
    0.00 :	  79d54b:       4b 89 44 06 10          mov    %rax,0x10(%r14,%r8,1)
         :	                *b++ = t;
    0.00 :	  79d550:       43 89 54 01 14          mov    %edx,0x14(%r9,%r8,1)
    0.00 :	  79d555:       43 88 4c 01 10          mov    %cl,0x10(%r9,%r8,1)
    0.00 :	  79d55a:       4b 89 74 01 08          mov    %rsi,0x8(%r9,%r8,1)
    0.00 :	  79d55f:       4b 89 3c 01             mov    %rdi,(%r9,%r8,1)
         :	        } while (--n > 0);
    0.00 :	  79d563:       49 83 c0 18             add    $0x18,%r8
    0.00 :	  79d567:       49 83 eb 01             sub    $0x1,%r11
    0.00 :	  79d56b:       75 b3                   jne    79d520 <qsort_tuple+0x220>
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
         :	        vecswap(a, pb - r, r);
         :	        r = Min(pd - pc, pn - pd - 1);
         :	        vecswap(pb, pn - r, r);
         :	        if ((r = pb - pa) > 1)
    0.00 :	  79d56d:       41 83 fa 01             cmp    $0x1,%r10d
    0.00 :	  79d571:       7e 14                   jle    79d587 <qsort_tuple+0x287>
         :	                qsort_tuple(a, r, cmp_tuple, state);
    0.00 :	  79d573:       48 8b 4d a0             mov    -0x60(%rbp),%rcx
    0.00 :	  79d577:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  79d57b:       49 63 f2                movslq %r10d,%rsi
    0.00 :	  79d57e:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  79d582:       e8 79 fd ff ff          callq  79d300 <qsort_tuple>
         :	        if ((r = pd - pc) > 1)
    0.00 :	  79d587:       83 fb 01                cmp    $0x1,%ebx
    0.00 :	  79d58a:       0f 8e c8 00 00 00       jle    79d658 <qsort_tuple+0x358>
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
    0.00 :	  79d590:       4c 63 e3                movslq %ebx,%r12
    0.00 :	  79d593:       48 8b 5d c8             mov    -0x38(%rbp),%rbx
    0.00 :	  79d597:       4b 8d 04 64             lea    (%r12,%r12,2),%rax
    0.00 :	  79d59b:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  79d59f:       48 29 c3                sub    %rax,%rbx
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d5a2:       0f b6 05 e7 ca 41 00    movzbl 0x41cae7(%rip),%eax        # bba090 <InterruptPending>
         :	        if ((r = pb - pa) > 1)
         :	                qsort_tuple(a, r, cmp_tuple, state);
         :	        if ((r = pd - pc) > 1)
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
    0.00 :	  79d5a9:       48 89 5d b0             mov    %rbx,-0x50(%rbp)
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d5ad:       84 c0                   test   %al,%al
    0.00 :	  79d5af:       0f 84 7a fd ff ff       je     79d32f <qsort_tuple+0x2f>
    0.00 :	  79d5b5:       e8 e6 ec ef ff          callq  69c2a0 <ProcessInterrupts>
         :	        if (n < 7)
    0.00 :	  79d5ba:       49 83 fc 06             cmp    $0x6,%r12
    0.00 :	  79d5be:       0f 87 75 fd ff ff       ja     79d339 <qsort_tuple+0x39>
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  79d5c4:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  79d5c8:       4c 8b 6d b0             mov    -0x50(%rbp),%r13
    0.00 :	  79d5cc:       4b 8d 04 64             lea    (%r12,%r12,2),%rax
    0.00 :	  79d5d0:       4c 8d 34 c2             lea    (%rdx,%rax,8),%r14
    0.00 :	  79d5d4:       49 83 c5 18             add    $0x18,%r13
    0.00 :	  79d5d8:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  79d5db:       4d 39 f5                cmp    %r14,%r13
    0.00 :	  79d5de:       73 78                   jae    79d658 <qsort_tuple+0x358>
         :	                        for (pl = pm; pl > a && cmp_tuple(pl - 1, pl, state) > 0; pl--)
    0.00 :	  79d5e0:       4c 3b 6d b0             cmp    -0x50(%rbp),%r13
    0.00 :	  79d5e4:       77 51                   ja     79d637 <qsort_tuple+0x337>
    0.00 :	  79d5e6:       eb 64                   jmp    79d64c <qsort_tuple+0x34c>
    0.00 :	  79d5e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  79d5ef:       00 
         :	                                swap(pl, pl - 1);
    0.00 :	  79d5f0:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  79d5f4:       8b 53 14                mov    0x14(%rbx),%edx
    0.00 :	  79d5f7:       0f b6 4b 10             movzbl 0x10(%rbx),%ecx
    0.00 :	  79d5fb:       48 8b 73 08             mov    0x8(%rbx),%rsi
    0.00 :	  79d5ff:       48 8b 3b                mov    (%rbx),%rdi
    0.00 :	  79d602:       4c 89 e3                mov    %r12,%rbx
    0.00 :	  79d605:       49 89 44 24 18          mov    %rax,0x18(%r12)
    0.00 :	  79d60a:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  79d60f:       49 89 74 24 08          mov    %rsi,0x8(%r12)
    0.00 :	  79d614:       49 89 3c 24             mov    %rdi,(%r12)
    0.00 :	  79d618:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  79d61d:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  79d622:       41 89 54 24 14          mov    %edx,0x14(%r12)
    0.00 :	  79d627:       41 88 4c 24 10          mov    %cl,0x10(%r12)
    0.00 :	  79d62c:       49 89 44 24 28          mov    %rax,0x28(%r12)
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
         :	                        for (pl = pm; pl > a && cmp_tuple(pl - 1, pl, state) > 0; pl--)
    0.00 :	  79d631:       4c 3b 65 b0             cmp    -0x50(%rbp),%r12
    0.00 :	  79d635:       76 15                   jbe    79d64c <qsort_tuple+0x34c>
    0.00 :	  79d637:       4c 8d 63 e8             lea    -0x18(%rbx),%r12
    0.00 :	  79d63b:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  79d63f:       48 89 de                mov    %rbx,%rsi
    0.00 :	  79d642:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79d645:       ff 55 a8                callq  *-0x58(%rbp)
    0.00 :	  79d648:       85 c0                   test   %eax,%eax
    0.00 :	  79d64a:       7f a4                   jg     79d5f0 <qsort_tuple+0x2f0>
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  79d64c:       49 83 c5 18             add    $0x18,%r13
    0.00 :	  79d650:       4d 39 f5                cmp    %r14,%r13
    0.00 :	  79d653:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  79d656:       72 88                   jb     79d5e0 <qsort_tuple+0x2e0>
         :	                a = pn - r;
         :	                n = r;
         :	                goto loop;
         :	        }
         :	/*              qsort_tuple(pn - r, r, cmp_tuple, state);*/
         :	}
    0.00 :	  79d658:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  79d65c:       5b                      pop    %rbx
    0.00 :	  79d65d:       41 5c                   pop    %r12
    0.00 :	  79d65f:       41 5d                   pop    %r13
    0.00 :	  79d661:       41 5e                   pop    %r14
    0.00 :	  79d663:       41 5f                   pop    %r15
    0.00 :	  79d665:       c9                      leaveq 
    0.00 :	  79d666:       c3                      retq   
    0.00 :	  79d667:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  79d66e:       00 00 
         :	        swap(a, pm);
         :	        pa = pb = a + 1;
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_tuple(pb, a, state)) <= 0)
    0.00 :	  79d670:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  79d674:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  79d678:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  79d67b:       ff 55 a8                callq  *-0x58(%rbp)
    0.00 :	  79d67e:       85 c0                   test   %eax,%eax
    0.00 :	  79d680:       89 c3                   mov    %eax,%ebx
    0.00 :	  79d682:       7f 5f                   jg     79d6e3 <qsort_tuple+0x3e3>
    0.00 :	  79d684:       e9 d2 00 00 00          jmpq   79d75b <qsort_tuple+0x45b>
    0.00 :	  79d689:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_tuple(pc, a, state)) >= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:141
   12.50 :	  79d690:       85 db                   test   %ebx,%ebx
    0.00 :	  79d692:       75 42                   jne    79d6d6 <qsort_tuple+0x3d6>
         :	                        {
         :	                                swap(pc, pd);
    0.00 :	  79d694:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  79d698:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  79d69c:       41 0f b6 4c 24 10       movzbl 0x10(%r12),%ecx
    0.00 :	  79d6a2:       41 8b 54 24 14          mov    0x14(%r12),%edx
    0.00 :	  79d6a7:       49 8b 74 24 08          mov    0x8(%r12),%rsi
    0.00 :	  79d6ac:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	  79d6b0:       49 8b 45 08             mov    0x8(%r13),%rax
    0.00 :	  79d6b4:       49 89 44 24 08          mov    %rax,0x8(%r12)
    0.00 :	  79d6b9:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  79d6bd:       49 89 44 24 10          mov    %rax,0x10(%r12)
    0.00 :	  79d6c2:       41 89 55 14             mov    %edx,0x14(%r13)
    0.00 :	  79d6c6:       41 88 4d 10             mov    %cl,0x10(%r13)
    0.00 :	  79d6ca:       49 89 75 08             mov    %rsi,0x8(%r13)
    0.00 :	  79d6ce:       49 89 7d 00             mov    %rdi,0x0(%r13)
         :	                                pd--;
    0.00 :	  79d6d2:       49 83 ed 18             sub    $0x18,%r13
         :	                        }
         :	                        pc--;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:146
   12.50 :	  79d6d6:       49 83 ec 18             sub    $0x18,%r12
         :	                                swap(pa, pb);
         :	                                pa++;
         :	                        }
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_tuple(pc, a, state)) >= 0)
    0.00 :	  79d6da:       4d 39 f4                cmp    %r14,%r12
    0.00 :	  79d6dd:       0f 82 3a fd ff ff       jb     79d41d <qsort_tuple+0x11d>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:138
   12.50 :	  79d6e3:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
   25.00 :	  79d6e7:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  79d6eb:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79d6ee:       ff 55 a8                callq  *-0x58(%rbp)
    0.00 :	  79d6f1:       85 c0                   test   %eax,%eax
    0.00 :	  79d6f3:       89 c3                   mov    %eax,%ebx
    0.00 :	  79d6f5:       78 19                   js     79d710 <qsort_tuple+0x410>
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d6f7:       0f b6 05 92 c9 41 00    movzbl 0x41c992(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  79d6fe:       84 c0                   test   %al,%al
    0.00 :	  79d700:       74 8e                   je     79d690 <qsort_tuple+0x390>
    0.00 :	  79d702:       e8 99 eb ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  79d707:       eb 87                   jmp    79d690 <qsort_tuple+0x390>
    0.00 :	  79d709:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        }
         :	                        pc--;
         :	                }
         :	                if (pb > pc)
         :	                        break;
         :	                swap(pb, pc);
    0.00 :	  79d710:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  79d714:       49 8b 7f e8             mov    -0x18(%r15),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:150
   12.50 :	  79d718:       41 0f b6 4f f8          movzbl -0x8(%r15),%ecx
    0.00 :	  79d71d:       41 8b 57 fc             mov    -0x4(%r15),%edx
    0.00 :	  79d721:       49 8b 77 f0             mov    -0x10(%r15),%rsi
    0.00 :	  79d725:       49 89 47 e8             mov    %rax,-0x18(%r15)
    0.00 :	  79d729:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  79d72e:       49 89 47 f0             mov    %rax,-0x10(%r15)
    0.00 :	  79d732:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  79d737:       49 89 47 f8             mov    %rax,-0x8(%r15)
    0.00 :	  79d73b:       41 89 54 24 14          mov    %edx,0x14(%r12)
    0.00 :	  79d740:       41 88 4c 24 10          mov    %cl,0x10(%r12)
    0.00 :	  79d745:       49 89 74 24 08          mov    %rsi,0x8(%r12)
    0.00 :	  79d74a:       49 89 3c 24             mov    %rdi,(%r12)
         :	                pb++;
         :	                pc--;
    0.00 :	  79d74e:       49 83 ec 18             sub    $0x18,%r12
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
         :	                                pa++;
    0.00 :	  79d752:       49 83 c7 18             add    $0x18,%r15
    0.00 :	  79d756:       e9 b5 fc ff ff          jmpq   79d410 <qsort_tuple+0x110>
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_tuple(pb, a, state)) <= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:130
   12.50 :	  79d75b:       0f b6 05 2e c9 41 00    movzbl 0x41c92e(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  79d762:       84 c0                   test   %al,%al
    0.00 :	  79d764:       0f 85 83 00 00 00       jne    79d7ed <qsort_tuple+0x4ed>
         :	                        if (r == 0)
    0.00 :	  79d76a:       85 db                   test   %ebx,%ebx
    0.00 :	  79d76c:       75 e4                   jne    79d752 <qsort_tuple+0x452>
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  79d76e:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  79d772:       48 8b 5d b8             mov    -0x48(%rbp),%rbx
    0.00 :	  79d776:       8b 50 14                mov    0x14(%rax),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/qsort_tuple.c:133
   12.50 :	  79d779:       0f b6 48 10             movzbl 0x10(%rax),%ecx
    0.00 :	  79d77d:       48 8b 70 08             mov    0x8(%rax),%rsi
    0.00 :	  79d781:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  79d784:       49 8b 47 e8             mov    -0x18(%r15),%rax
    0.00 :	  79d788:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  79d78b:       49 8b 47 f0             mov    -0x10(%r15),%rax
    0.00 :	  79d78f:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  79d793:       49 8b 47 f8             mov    -0x8(%r15),%rax
    0.00 :	  79d797:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	                                pa++;
    0.00 :	  79d79b:       48 83 c3 18             add    $0x18,%rbx
         :	                while (pb <= pc && (r = cmp_tuple(pb, a, state)) <= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  79d79f:       41 89 57 fc             mov    %edx,-0x4(%r15)
    0.00 :	  79d7a3:       41 88 4f f8             mov    %cl,-0x8(%r15)
    0.00 :	  79d7a7:       49 89 77 f0             mov    %rsi,-0x10(%r15)
    0.00 :	  79d7ab:       49 89 7f e8             mov    %rdi,-0x18(%r15)
         :	                                pa++;
    0.00 :	  79d7af:       48 89 5d b8             mov    %rbx,-0x48(%rbp)
    0.00 :	  79d7b3:       eb 9d                   jmp    79d752 <qsort_tuple+0x452>
         :	                return;
         :	        pm = a + (n / 2);
         :	        if (n > 7)
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
    0.00 :	  79d7b5:       48 8b 5d b0             mov    -0x50(%rbp),%rbx
    0.00 :	  79d7b9:       4b 8d 44 64 fd          lea    -0x3(%r12,%r12,2),%rax
         :	                if (n > 40)
    0.00 :	  79d7be:       49 83 fc 28             cmp    $0x28,%r12
         :	                return;
         :	        pm = a + (n / 2);
         :	        if (n > 7)
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
    0.00 :	  79d7c2:       48 8d 04 c3             lea    (%rbx,%rax,8),%rax
         :	                if (n > 40)
    0.00 :	  79d7c6:       49 89 df                mov    %rbx,%r15
         :	                return;
         :	        pm = a + (n / 2);
         :	        if (n > 7)
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
    0.00 :	  79d7c9:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	                if (n > 40)
    0.00 :	  79d7cd:       48 89 c2                mov    %rax,%rdx
    0.00 :	  79d7d0:       77 25                   ja     79d7f7 <qsort_tuple+0x4f7>
         :	                        d = (n / 8);
         :	                        pl = med3_tuple(pl, pl + d, pl + 2 * d, cmp_tuple, state);
         :	                        pm = med3_tuple(pm - d, pm, pm + d, cmp_tuple, state);
         :	                        pn = med3_tuple(pn - 2 * d, pn - d, pn, cmp_tuple, state);
         :	                }
         :	                pm = med3_tuple(pl, pm, pn, cmp_tuple, state);
    0.00 :	  79d7d2:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  79d7d6:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  79d7da:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  79d7dd:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  79d7e0:       e8 4b f2 ff ff          callq  79ca30 <med3_tuple>
    0.00 :	  79d7e5:       49 89 c5                mov    %rax,%r13
    0.00 :	  79d7e8:       e9 cc fb ff ff          jmpq   79d3b9 <qsort_tuple+0xb9>
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_tuple(pb, a, state)) <= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  79d7ed:       e8 ae ea ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  79d7f2:       e9 73 ff ff ff          jmpq   79d76a <qsort_tuple+0x46a>
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
    0.00 :	  79d7f7:       4c 89 e0                mov    %r12,%rax
         :	                        pl = med3_tuple(pl, pl + d, pl + 2 * d, cmp_tuple, state);
    0.00 :	  79d7fa:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  79d7fe:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
    0.00 :	  79d802:       48 c1 e8 03             shr    $0x3,%rax
         :	                        pl = med3_tuple(pl, pl + d, pl + 2 * d, cmp_tuple, state);
    0.00 :	  79d806:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  79d80a:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  79d80e:       8d 1c 00                lea    (%rax,%rax,1),%ebx
    0.00 :	  79d811:       48 98                   cltq   
    0.00 :	  79d813:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  79d817:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79d81b:       48 63 db                movslq %ebx,%rbx
    0.00 :	  79d81e:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  79d822:       4c 8d 24 c5 00 00 00    lea    0x0(,%rax,8),%r12
    0.00 :	  79d829:       00 
    0.00 :	  79d82a:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  79d82e:       4c 01 e6                add    %r12,%rsi
    0.00 :	  79d831:       48 01 da                add    %rbx,%rdx
    0.00 :	  79d834:       e8 f7 f1 ff ff          callq  79ca30 <med3_tuple>
         :	                        pm = med3_tuple(pm - d, pm, pm + d, cmp_tuple, state);
    0.00 :	  79d839:       4b 8d 54 25 00          lea    0x0(%r13,%r12,1),%rdx
    0.00 :	  79d83e:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  79d842:       49 f7 dc                neg    %r12
    0.00 :	  79d845:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  79d849:       4b 8d 7c 25 00          lea    0x0(%r13,%r12,1),%rdi
    0.00 :	  79d84e:       4c 89 ee                mov    %r13,%rsi
         :	                pl = a;
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
         :	                        pl = med3_tuple(pl, pl + d, pl + 2 * d, cmp_tuple, state);
    0.00 :	  79d851:       49 89 c7                mov    %rax,%r15
         :	                        pm = med3_tuple(pm - d, pm, pm + d, cmp_tuple, state);
    0.00 :	  79d854:       e8 d7 f1 ff ff          callq  79ca30 <med3_tuple>
         :	                        pn = med3_tuple(pn - 2 * d, pn - d, pn, cmp_tuple, state);
    0.00 :	  79d859:       48 8b 75 c0             mov    -0x40(%rbp),%rsi
    0.00 :	  79d85d:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
         :	                        pl = med3_tuple(pl, pl + d, pl + 2 * d, cmp_tuple, state);
         :	                        pm = med3_tuple(pm - d, pm, pm + d, cmp_tuple, state);
    0.00 :	  79d861:       49 89 c5                mov    %rax,%r13
         :	                        pn = med3_tuple(pn - 2 * d, pn - d, pn, cmp_tuple, state);
    0.00 :	  79d864:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  79d868:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  79d86c:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  79d870:       4c 01 e6                add    %r12,%rsi
    0.00 :	  79d873:       48 29 df                sub    %rbx,%rdi
    0.00 :	  79d876:       e8 b5 f1 ff ff          callq  79ca30 <med3_tuple>
    0.00 :	  79d87b:       48 89 c2                mov    %rax,%rdx
    0.00 :	  79d87e:       e9 4f ff ff ff          jmpq   79d7d2 <qsort_tuple+0x4d2>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:359
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:356
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:509
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005ac4a0 <ExecProcNode>:
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac4a0:       0f b6 05 e9 db 60 00    movzbl 0x60dbe9(%rip),%eax        # bba090 <InterruptPending>
         :	 *              Execute the given node to return a(nother) tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
    0.00 :	  5ac4a7:       55                      push   %rbp
    0.00 :	  5ac4a8:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5ac4ab:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:356
   14.29 :	  5ac4ad:       49 89 fc                mov    %rdi,%r12
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac4b0:       84 c0                   test   %al,%al
         :	 *              Execute the given node to return a(nother) tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
    0.00 :	  5ac4b2:       53                      push   %rbx
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:359
   28.57 :	  5ac4b3:       75 6b                   jne    5ac520 <ExecProcNode+0x80>
         :
         :	        if (node->chgParam != NULL) /* something changed */
    0.00 :	  5ac4b5:       49 83 7c 24 50 00       cmpq   $0x0,0x50(%r12)
    0.00 :	  5ac4bb:       74 08                   je     5ac4c5 <ExecProcNode+0x25>
         :	                ExecReScan(node);               /* let ReScan handle this */
    0.00 :	  5ac4bd:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac4c0:       e8 db bf ff ff          callq  5a84a0 <ExecReScan>
         :
         :	        if (node->instrument)
    0.00 :	  5ac4c5:       49 8b 7c 24 18          mov    0x18(%r12),%rdi
    0.00 :	  5ac4ca:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ac4cd:       74 05                   je     5ac4d4 <ExecProcNode+0x34>
         :	                InstrStartNode(node->instrument);
    0.00 :	  5ac4cf:       e8 2c ba 00 00          callq  5b7f00 <InstrStartNode>
         :
         :	        switch (nodeTag(node))
    0.00 :	  5ac4d4:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  5ac4d8:       2d c9 00 00 00          sub    $0xc9,%eax
    0.00 :	  5ac4dd:       83 f8 21                cmp    $0x21,%eax
    0.00 :	  5ac4e0:       76 2e                   jbe    5ac510 <ExecProcNode+0x70>
         :	                case T_LimitState:
         :	                        result = ExecLimit((LimitState *) node);
         :	                        break;
         :
         :	                default:
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
    0.00 :	  5ac4e2:       ba e2 a3 88 00          mov    $0x88a3e2,%edx
    0.00 :	  5ac4e7:       be f8 01 00 00          mov    $0x1f8,%esi
    0.00 :	  5ac4ec:       bf 75 a0 88 00          mov    $0x88a075,%edi
    0.00 :	  5ac4f1:       e8 2a ef 1c 00          callq  77b420 <elog_start>
    0.00 :	  5ac4f6:       41 8b 14 24             mov    (%r12),%edx
    0.00 :	  5ac4fa:       be 5c 17 87 00          mov    $0x87175c,%esi
    0.00 :	  5ac4ff:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5ac504:       31 c0                   xor    %eax,%eax
    0.00 :	  5ac506:       e8 25 ed 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5ac50b:       e8 c0 cf eb ff          callq  4694d0 <abort@plt>
         :	                ExecReScan(node);               /* let ReScan handle this */
         :
         :	        if (node->instrument)
         :	                InstrStartNode(node->instrument);
         :
         :	        switch (nodeTag(node))
    0.00 :	  5ac510:       89 c0                   mov    %eax,%eax
    0.00 :	  5ac512:       ff 24 c5 a0 a1 88 00    jmpq   *0x88a1a0(,%rax,8)
    0.00 :	  5ac519:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac520:       e8 7b fd 0e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5ac525:       eb 8e                   jmp    5ac4b5 <ExecProcNode+0x15>
    0.00 :	  5ac527:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5ac52e:       00 00 
         :	                case T_LockRowsState:
         :	                        result = ExecLockRows((LockRowsState *) node);
         :	                        break;
         :
         :	                case T_LimitState:
         :	                        result = ExecLimit((LimitState *) node);
    0.00 :	  5ac530:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac533:       e8 a8 3c 01 00          callq  5c01e0 <ExecLimit>
    0.00 :	  5ac538:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5ac53b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
         :	                        result = NULL;
         :	                        break;
         :	        }
         :
         :	        if (node->instrument)
    0.00 :	  5ac540:       49 8b 7c 24 18          mov    0x18(%r12),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:509
   14.29 :	  5ac545:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ac548:       74 20                   je     5ac56a <ExecProcNode+0xca>
         :	                InstrStopNode(node->instrument, TupIsNull(result) ? 0.0 : 1.0);
    0.00 :	  5ac54a:       48 85 db                test   %rbx,%rbx
    0.00 :	  5ac54d:       0f 84 ed 01 00 00       je     5ac740 <ExecProcNode+0x2a0>
    0.00 :	  5ac553:       80 7b 04 00             cmpb   $0x0,0x4(%rbx)
    0.00 :	  5ac557:       0f 85 e3 01 00 00       jne    5ac740 <ExecProcNode+0x2a0>
    0.00 :	  5ac55d:       f2 0f 10 05 f3 2b 20    movsd  0x202bf3(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5ac564:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
   14.29 :	  5ac565:       e8 66 b6 00 00          callq  5b7bd0 <InstrStopNode>
         :
         :	        return result;
         :	}
    0.00 :	  5ac56a:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5ac56d:       5b                      pop    %rbx
    0.00 :	  5ac56e:       41 5c                   pop    %r12
    0.00 :	  5ac570:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
   28.57 :	  5ac571:       c3                      retq   
    0.00 :	  5ac572:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                case T_SetOpState:
         :	                        result = ExecSetOp((SetOpState *) node);
         :	                        break;
         :
         :	                case T_LockRowsState:
         :	                        result = ExecLockRows((LockRowsState *) node);
    0.00 :	  5ac578:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac57b:       e8 a0 40 01 00          callq  5c0620 <ExecLockRows>
    0.00 :	  5ac580:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac583:       eb bb                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac585:       0f 1f 00                nopl   (%rax)
         :	                case T_HashState:
         :	                        result = ExecHash((HashState *) node);
         :	                        break;
         :
         :	                case T_SetOpState:
         :	                        result = ExecSetOp((SetOpState *) node);
    0.00 :	  5ac588:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac58b:       e8 60 98 01 00          callq  5c5df0 <ExecSetOp>
    0.00 :	  5ac590:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac593:       eb ab                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac595:       0f 1f 00                nopl   (%rax)
         :	                case T_UniqueState:
         :	                        result = ExecUnique((UniqueState *) node);
         :	                        break;
         :
         :	                case T_HashState:
         :	                        result = ExecHash((HashState *) node);
    0.00 :	  5ac598:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac59b:       e8 d0 02 01 00          callq  5bc870 <ExecHash>
    0.00 :	  5ac5a0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5a3:       eb 9b                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5a5:       0f 1f 00                nopl   (%rax)
         :	                case T_WindowAggState:
         :	                        result = ExecWindowAgg((WindowAggState *) node);
         :	                        break;
         :
         :	                case T_UniqueState:
         :	                        result = ExecUnique((UniqueState *) node);
    0.00 :	  5ac5a8:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5ab:       e8 20 a0 01 00          callq  5c65d0 <ExecUnique>
    0.00 :	  5ac5b0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5b3:       eb 8b                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5b5:       0f 1f 00                nopl   (%rax)
         :	                case T_AggState:
         :	                        result = ExecAgg((AggState *) node);
         :	                        break;
         :
         :	                case T_WindowAggState:
         :	                        result = ExecWindowAgg((WindowAggState *) node);
    0.00 :	  5ac5b8:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5bb:       e8 90 00 02 00          callq  5cc650 <ExecWindowAgg>
    0.00 :	  5ac5c0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5c3:       e9 78 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5c8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ac5cf:       00 
         :	                case T_GroupState:
         :	                        result = ExecGroup((GroupState *) node);
         :	                        break;
         :
         :	                case T_AggState:
         :	                        result = ExecAgg((AggState *) node);
    0.00 :	  5ac5d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5d3:       e8 a8 d7 00 00          callq  5b9d80 <ExecAgg>
    0.00 :	  5ac5d8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5db:       e9 60 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SortState:
         :	                        result = ExecSort((SortState *) node);
         :	                        break;
         :
         :	                case T_GroupState:
         :	                        result = ExecGroup((GroupState *) node);
    0.00 :	  5ac5e0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5e3:       e8 88 ab 01 00          callq  5c7170 <ExecGroup>
    0.00 :	  5ac5e8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5eb:       e9 50 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MaterialState:
         :	                        result = ExecMaterial((MaterialState *) node);
         :	                        break;
         :
         :	                case T_SortState:
         :	                        result = ExecSort((SortState *) node);
    0.00 :	  5ac5f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5f3:       e8 48 9d 01 00          callq  5c6340 <ExecSort>
    0.00 :	  5ac5f8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5fb:       e9 40 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * materialization nodes
         :	                         */
         :	                case T_MaterialState:
         :	                        result = ExecMaterial((MaterialState *) node);
    0.00 :	  5ac600:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac603:       e8 38 47 01 00          callq  5c0d40 <ExecMaterial>
    0.00 :	  5ac608:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac60b:       e9 30 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MergeJoinState:
         :	                        result = ExecMergeJoin((MergeJoinState *) node);
         :	                        break;
         :
         :	                case T_HashJoinState:
         :	                        result = ExecHashJoin((HashJoinState *) node);
    0.00 :	  5ac610:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac613:       e8 88 14 01 00          callq  5bdaa0 <ExecHashJoin>
    0.00 :	  5ac618:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac61b:       e9 20 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_NestLoopState:
         :	                        result = ExecNestLoop((NestLoopState *) node);
         :	                        break;
         :
         :	                case T_MergeJoinState:
         :	                        result = ExecMergeJoin((MergeJoinState *) node);
    0.00 :	  5ac620:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac623:       e8 08 5a 01 00          callq  5c2030 <ExecMergeJoin>
    0.00 :	  5ac628:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac62b:       e9 10 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * join nodes
         :	                         */
         :	                case T_NestLoopState:
         :	                        result = ExecNestLoop((NestLoopState *) node);
    0.00 :	  5ac630:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac633:       e8 08 7c 01 00          callq  5c4240 <ExecNestLoop>
    0.00 :	  5ac638:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac63b:       e9 00 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_WorkTableScanState:
         :	                        result = ExecWorkTableScan((WorkTableScanState *) node);
         :	                        break;
         :
         :	                case T_ForeignScanState:
         :	                        result = ExecForeignScan((ForeignScanState *) node);
    0.00 :	  5ac640:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac643:       e8 f8 d2 01 00          callq  5c9940 <ExecForeignScan>
    0.00 :	  5ac648:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac64b:       e9 f0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_CteScanState:
         :	                        result = ExecCteScan((CteScanState *) node);
         :	                        break;
         :
         :	                case T_WorkTableScanState:
         :	                        result = ExecWorkTableScan((WorkTableScanState *) node);
    0.00 :	  5ac650:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac653:       e8 f8 a8 01 00          callq  5c6f50 <ExecWorkTableScan>
    0.00 :	  5ac658:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac65b:       e9 e0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ValuesScanState:
         :	                        result = ExecValuesScan((ValuesScanState *) node);
         :	                        break;
         :
         :	                case T_CteScanState:
         :	                        result = ExecCteScan((CteScanState *) node);
    0.00 :	  5ac660:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac663:       e8 28 a6 01 00          callq  5c6c90 <ExecCteScan>
    0.00 :	  5ac668:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac66b:       e9 d0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_FunctionScanState:
         :	                        result = ExecFunctionScan((FunctionScanState *) node);
         :	                        break;
         :
         :	                case T_ValuesScanState:
         :	                        result = ExecValuesScan((ValuesScanState *) node);
    0.00 :	  5ac670:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac673:       e8 18 a2 01 00          callq  5c6890 <ExecValuesScan>
    0.00 :	  5ac678:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac67b:       e9 c0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SubqueryScanState:
         :	                        result = ExecSubqueryScan((SubqueryScanState *) node);
         :	                        break;
         :
         :	                case T_FunctionScanState:
         :	                        result = ExecFunctionScan((FunctionScanState *) node);
    0.00 :	  5ac680:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac683:       e8 28 86 01 00          callq  5c4cb0 <ExecFunctionScan>
    0.00 :	  5ac688:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac68b:       e9 b0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_TidScanState:
         :	                        result = ExecTidScan((TidScanState *) node);
         :	                        break;
         :
         :	                case T_SubqueryScanState:
         :	                        result = ExecSubqueryScan((SubqueryScanState *) node);
    0.00 :	  5ac690:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac693:       e8 d8 c7 01 00          callq  5c8e70 <ExecSubqueryScan>
    0.00 :	  5ac698:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac69b:       e9 a0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_BitmapHeapScanState:
         :	                        result = ExecBitmapHeapScan((BitmapHeapScanState *) node);
         :	                        break;
         :
         :	                case T_TidScanState:
         :	                        result = ExecTidScan((TidScanState *) node);
    0.00 :	  5ac6a0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6a3:       e8 58 ca 01 00          callq  5c9100 <ExecTidScan>
    0.00 :	  5ac6a8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6ab:       e9 90 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                        break;
         :
         :	                        /* BitmapIndexScanState does not yield tuples */
         :
         :	                case T_BitmapHeapScanState:
         :	                        result = ExecBitmapHeapScan((BitmapHeapScanState *) node);
    0.00 :	  5ac6b0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6b3:       e8 68 e8 00 00          callq  5baf20 <ExecBitmapHeapScan>
    0.00 :	  5ac6b8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6bb:       e9 80 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_IndexScanState:
         :	                        result = ExecIndexScan((IndexScanState *) node);
         :	                        break;
         :
         :	                case T_IndexOnlyScanState:
         :	                        result = ExecIndexOnlyScan((IndexOnlyScanState *) node);
    0.00 :	  5ac6c0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6c3:       e8 b8 33 01 00          callq  5bfa80 <ExecIndexOnlyScan>
    0.00 :	  5ac6c8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6cb:       e9 70 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SeqScanState:
         :	                        result = ExecSeqScan((SeqScanState *) node);
         :	                        break;
         :
         :	                case T_IndexScanState:
         :	                        result = ExecIndexScan((IndexScanState *) node);
    0.00 :	  5ac6d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6d3:       e8 08 2e 01 00          callq  5bf4e0 <ExecIndexScan>
    0.00 :	  5ac6d8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6db:       e9 60 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * scan nodes
         :	                         */
         :	                case T_SeqScanState:
         :	                        result = ExecSeqScan((SeqScanState *) node);
    0.00 :	  5ac6e0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6e3:       e8 28 92 01 00          callq  5c5910 <ExecSeqScan>
    0.00 :	  5ac6e8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6eb:       e9 50 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MergeAppendState:
         :	                        result = ExecMergeAppend((MergeAppendState *) node);
         :	                        break;
         :
         :	                case T_RecursiveUnionState:
         :	                        result = ExecRecursiveUnion((RecursiveUnionState *) node);
    0.00 :	  5ac6f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6f3:       e8 d8 8b 01 00          callq  5c52d0 <ExecRecursiveUnion>
    0.00 :	  5ac6f8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6fb:       e9 40 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_AppendState:
         :	                        result = ExecAppend((AppendState *) node);
         :	                        break;
         :
         :	                case T_MergeAppendState:
         :	                        result = ExecMergeAppend((MergeAppendState *) node);
    0.00 :	  5ac700:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac703:       e8 c8 48 01 00          callq  5c0fd0 <ExecMergeAppend>
    0.00 :	  5ac708:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac70b:       e9 30 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ModifyTableState:
         :	                        result = ExecModifyTable((ModifyTableState *) node);
         :	                        break;
         :
         :	                case T_AppendState:
         :	                        result = ExecAppend((AppendState *) node);
    0.00 :	  5ac710:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac713:       e8 68 ba 00 00          callq  5b8180 <ExecAppend>
    0.00 :	  5ac718:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac71b:       e9 20 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ResultState:
         :	                        result = ExecResult((ResultState *) node);
         :	                        break;
         :
         :	                case T_ModifyTableState:
         :	                        result = ExecModifyTable((ModifyTableState *) node);
    0.00 :	  5ac720:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac723:       e8 d8 6a 01 00          callq  5c3200 <ExecModifyTable>
    0.00 :	  5ac728:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac72b:       e9 10 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	        {
         :	                        /*
         :	                         * control nodes
         :	                         */
         :	                case T_ResultState:
         :	                        result = ExecResult((ResultState *) node);
    0.00 :	  5ac730:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac733:       e8 08 8f 01 00          callq  5c5640 <ExecResult>
    0.00 :	  5ac738:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac73b:       e9 00 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                        result = NULL;
         :	                        break;
         :	        }
         :
         :	        if (node->instrument)
         :	                InstrStopNode(node->instrument, TupIsNull(result) ? 0.0 : 1.0);
    0.00 :	  5ac740:       66 0f 57 c0             xorpd  %xmm0,%xmm0
    0.00 :	  5ac744:       e9 1c fe ff ff          jmpq   5ac565 <ExecProcNode+0xc5>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   42.86 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2692
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2696
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2699
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2712
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005aca40 <ExecEvalNot>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalNot(BoolExprState *notclause, ExprContext *econtext,
         :	                        bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2692
   42.86 :	  5aca40:       55                      push   %rbp
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5aca41:       31 c0                   xor    %eax,%eax
    0.00 :	  5aca43:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5aca46:       53                      push   %rbx
    0.00 :	  5aca47:       48 89 d3                mov    %rdx,%rbx
    0.00 :	  5aca4a:       48 83 ec 08             sub    $0x8,%rsp
         :	        ExprState  *clause = linitial(notclause->args);
    0.00 :	  5aca4e:       48 8b 57 18             mov    0x18(%rdi),%rdx
    0.00 :	  5aca52:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5aca55:       74 04                   je     5aca5b <ExecEvalNot+0x1b>
    0.00 :	  5aca57:       48 8b 42 08             mov    0x8(%rdx),%rax
         :	        Datum           expr_value;
         :
         :	        if (isDone)
    0.00 :	  5aca5b:       48 85 c9                test   %rcx,%rcx
         :	 */
         :	static Datum
         :	ExecEvalNot(BoolExprState *notclause, ExprContext *econtext,
         :	                        bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        ExprState  *clause = linitial(notclause->args);
    0.00 :	  5aca5e:       48 8b 00                mov    (%rax),%rax
         :	        Datum           expr_value;
         :
         :	        if (isDone)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2696
   28.57 :	  5aca61:       74 06                   je     5aca69 <ExecEvalNot+0x29>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5aca63:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        expr_value = ExecEvalExpr(clause, econtext, isNull, NULL);
    0.00 :	  5aca69:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5aca6b:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5aca6e:       48 89 c7                mov    %rax,%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2699
   14.29 :	  5aca71:       ff 50 10                callq  *0x10(%rax)
         :
         :	        /*
         :	         * if the expression evaluates to null, then we just cascade the null back
         :	         * to whoever called us.
         :	         */
         :	        if (*isNull)
    0.00 :	  5aca74:       80 3b 00                cmpb   $0x0,(%rbx)
    0.00 :	  5aca77:       75 08                   jne    5aca81 <ExecEvalNot+0x41>
         :
         :	        /*
         :	         * evaluation of 'not' is simple.. expr is false, then return 'true' and
         :	         * vice versa.
         :	         */
         :	        return BoolGetDatum(!DatumGetBool(expr_value));
    0.00 :	  5aca79:       84 c0                   test   %al,%al
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2712
   14.29 :	  5aca7b:       0f 94 c0                sete   %al
    0.00 :	  5aca7e:       0f b6 c0                movzbl %al,%eax
         :	}
    0.00 :	  5aca81:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5aca85:       5b                      pop    %rbx
    0.00 :	  5aca86:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006ea7a0 <int4eq>:
         :	 *              intge                   - returns 1 iff arg1 >= arg2
         :	 */
         :
         :	Datum
         :	int4eq(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   14.29 :	  6ea7a0:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  6ea7a4:       39 47 20                cmp    %eax,0x20(%rdi)
   28.57 :	  6ea7a7:       55                      push   %rbp
   28.57 :	  6ea7a8:       48 89 e5                mov    %rsp,%rbp
         :	        int32           arg1 = PG_GETARG_INT32(0);
         :	        int32           arg2 = PG_GETARG_INT32(1);
         :
         :	        PG_RETURN_BOOL(arg1 == arg2);
         :	}
    0.00 :	  6ea7ab:       c9                      leaveq 
         :	 *              intge                   - returns 1 iff arg1 >= arg2
         :	 */
         :
         :	Datum
         :	int4eq(PG_FUNCTION_ARGS)
         :	{
   28.57 :	  6ea7ac:       0f 94 c0                sete   %al
    0.00 :	  6ea7af:       0f b6 c0                movzbl %al,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   42.86 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:811
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:811
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:811
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:816
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007846a0 <hash_search>:
         :	void *
         :	hash_search(HTAB *hashp,
         :	                        const void *keyPtr,
         :	                        HASHACTION action,
         :	                        bool *foundPtr)
         :	{
    0.00 :	  7846a0:       55                      push   %rbp
    0.00 :	  7846a1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7846a4:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  7846a8:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  7846ac:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7846af:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7846b3:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7846b7:       49 89 f5                mov    %rsi,%r13
    0.00 :	  7846ba:       48 83 ec 20             sub    $0x20,%rsp
    0.00 :	  7846be:       41 89 d6                mov    %edx,%r14d
    0.00 :	  7846c1:       49 89 cc                mov    %rcx,%r12
         :	        return hash_search_with_hash_value(hashp,
    0.00 :	  7846c4:       48 8b 77 48             mov    0x48(%rdi),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:811
   28.57 :	  7846c8:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7846cb:       ff 53 10                callq  *0x10(%rbx)
   14.29 :	  7846ce:       4d 89 e0                mov    %r12,%r8
    0.00 :	  7846d1:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  7846d4:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7846d7:       48 89 df                mov    %rbx,%rdi
         :	                                                                           keyPtr,
         :	                                                                           hashp->hash(keyPtr, hashp->keysize),
         :	                                                                           action,
         :	                                                                           foundPtr);
         :	}
    0.00 :	  7846da:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  7846df:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  7846e3:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:816
   14.29 :	  7846e8:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
         :	hash_search(HTAB *hashp,
         :	                        const void *keyPtr,
         :	                        HASHACTION action,
         :	                        bool *foundPtr)
         :	{
         :	        return hash_search_with_hash_value(hashp,
    0.00 :	  7846ed:       89 c2                   mov    %eax,%edx
         :	                                                                           keyPtr,
         :	                                                                           hashp->hash(keyPtr, hashp->keysize),
         :	                                                                           action,
         :	                                                                           foundPtr);
         :	}
    0.00 :	  7846ef:       c9                      leaveq 
         :	hash_search(HTAB *hashp,
         :	                        const void *keyPtr,
         :	                        HASHACTION action,
         :	                        bool *foundPtr)
         :	{
         :	        return hash_search_with_hash_value(hashp,
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:811
   42.86 :	  7846f0:       e9 5b f9 ff ff          jmpq   784050 <hash_search_with_hash_value>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1103
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1099
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5750 <HeapTupleSatisfiesMVCC>:
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
    0.00 :	  7a5750:       55                      push   %rbp
    0.00 :	  7a5751:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
   14.29 :	  7a5754:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7a5758:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7a575c:       41 89 d6                mov    %edx,%r14d
    0.00 :	  7a575f:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  7a5763:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  7a5767:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tuple = htup->t_data;
    0.00 :	  7a576b:       48 8b 5f 10             mov    0x10(%rdi),%rbx
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
    0.00 :	  7a576f:       49 89 f5                mov    %rsi,%r13
         :	        HeapTupleHeader tuple = htup->t_data;
         :
         :	        Assert(ItemPointerIsValid(&htup->t_self));
         :	        Assert(htup->t_tableOid != InvalidOid);
         :
         :	        if (!HeapTupleHeaderXminCommitted(tuple))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
   14.29 :	  7a5772:       0f b7 4b 14             movzwl 0x14(%rbx),%ecx
   14.29 :	  7a5776:       0f b7 d1                movzwl %cx,%edx
    0.00 :	  7a5779:       f6 c6 01                test   $0x1,%dh
    0.00 :	  7a577c:       75 72                   jne    7a57f0 <HeapTupleSatisfiesMVCC+0xa0>
         :	        {
         :	                if (HeapTupleHeaderXminInvalid(tuple))
    0.00 :	  7a577e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5780:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a5785:       3d 00 02 00 00          cmp    $0x200,%eax
    0.00 :	  7a578a:       0f 84 06 01 00 00       je     7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :
         :	                /* Used by pre-9.0 binary upgrades */
         :	                if (tuple->t_infomask & HEAP_MOVED_OFF)
    0.00 :	  7a5790:       f6 c6 40                test   $0x40,%dh
    0.00 :	  7a5793:       0f 84 27 01 00 00       je     7a58c0 <HeapTupleSatisfiesMVCC+0x170>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a5799:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a579c:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a57a1:       74 04                   je     7a57a7 <HeapTupleSatisfiesMVCC+0x57>
    0.00 :	  7a57a3:       44 8b 63 08             mov    0x8(%rbx),%r12d
         :
         :	                        if (TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a57a7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57aa:       e8 f1 ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a57af:       84 c0                   test   %al,%al
    0.00 :	  7a57b1:       0f 85 df 00 00 00       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;
         :	                        if (!TransactionIdIsInProgress(xvac))
    0.00 :	  7a57b7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ba:       e8 f1 c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a57bf:       84 c0                   test   %al,%al
    0.00 :	  7a57c1:       0f 85 1f 01 00 00       jne    7a58e6 <HeapTupleSatisfiesMVCC+0x196>
         :	                        {
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a57c7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ca:       e8 11 ab d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a57cf:       84 c0                   test   %al,%al
    0.00 :	  7a57d1:       0f 85 79 02 00 00       jne    7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
         :	                                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a57d7:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a57dc:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a57de:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a57e1:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a57e4:       e8 b7 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a57e9:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a57ed:       0f 1f 00                nopl   (%rax)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a57f0:       89 d0                   mov    %edx,%eax
    0.00 :	  7a57f2:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a57f7:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a57fc:       0f 85 86 00 00 00       jne    7a5888 <HeapTupleSatisfiesMVCC+0x138>
         :	                return false;                   /* treat as still in progress */
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid or aborted */
         :	                return true;
         :
         :	        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))
    0.00 :	  7a5802:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5808:       0f 85 a2 00 00 00       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a580e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5810:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a5815:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5818:       0f 84 92 00 00 00       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                return true;
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a581e:       f6 c6 10                test   $0x10,%dh
    0.00 :	  7a5821:       0f 85 b9 01 00 00       jne    7a59e0 <HeapTupleSatisfiesMVCC+0x290>
         :	                }
         :	                /* it must have aborted or crashed */
         :	                return true;
         :	        }
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
    0.00 :	  7a5827:       80 e6 04                and    $0x4,%dh
    0.00 :	  7a582a:       75 44                   jne    7a5870 <HeapTupleSatisfiesMVCC+0x120>
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a582c:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a582f:       90                      nop
    0.00 :	  7a5830:       e8 6b ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5835:       84 c0                   test   %al,%al
    0.00 :	  7a5837:       0f 85 43 01 00 00       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :
         :	                if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a583d:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5840:       e8 6b c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5845:       84 c0                   test   %al,%al
    0.00 :	  7a5847:       75 67                   jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5849:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a584c:       e8 8f aa d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5851:       84 c0                   test   %al,%al
    0.00 :	  7a5853:       0f 84 20 02 00 00       je     7a5a79 <HeapTupleSatisfiesMVCC+0x329>
         :	                                                InvalidTransactionId);
         :	                        return true;
         :	                }
         :
         :	                /* xmax transaction committed */
         :	                SetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,
    0.00 :	  7a5859:       8b 4b 04                mov    0x4(%rbx),%ecx
    0.00 :	  7a585c:       ba 00 04 00 00          mov    $0x400,%edx
    0.00 :	  7a5861:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5864:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5867:       e8 34 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a586c:       0f 1f 40 00             nopl   0x0(%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5870:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5873:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5876:       e8 85 fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a587b:       84 c0                   test   %al,%al
    0.00 :	  7a587d:       0f 95 c0                setne  %al
    0.00 :	  7a5880:       eb 16                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5882:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a5888:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a588a:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a588d:       e8 6e fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
   28.57 :	  7a5892:       84 c0                   test   %al,%al
    0.00 :	  7a5894:       74 6a                   je     7a5900 <HeapTupleSatisfiesMVCC+0x1b0>
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5896:       31 c0                   xor    %eax,%eax
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5898:       48 8b 1c 24             mov    (%rsp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1103
   14.29 :	  7a589c:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  7a58a1:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  7a58a6:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  7a58ab:       c9                      leaveq 
    0.00 :	  7a58ac:       c3                      retq   
    0.00 :	  7a58ad:       0f 1f 00                nopl   (%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1099
   14.29 :	  7a58b0:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  7a58b5:       eb e1                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a58b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7a58be:       00 00 
         :	                                SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                        InvalidTransactionId);
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
    0.00 :	  7a58c0:       66 85 c9                test   %cx,%cx
    0.00 :	  7a58c3:       79 4b                   jns    7a5910 <HeapTupleSatisfiesMVCC+0x1c0>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a58c5:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a58c8:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a58cd:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a58d0:       0f 85 fa 00 00 00       jne    7a59d0 <HeapTupleSatisfiesMVCC+0x280>
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a58d6:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a58d9:       e8 c2 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a58de:       84 c0                   test   %al,%al
    0.00 :	  7a58e0:       0f 84 4a 01 00 00       je     7a5a30 <HeapTupleSatisfiesMVCC+0x2e0>
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a58e6:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a58ea:       89 d0                   mov    %edx,%eax
    0.00 :	  7a58ec:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a58f1:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a58f6:       0f 84 06 ff ff ff       je     7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a58fc:       eb 8a                   jmp    7a5888 <HeapTupleSatisfiesMVCC+0x138>
    0.00 :	  7a58fe:       66 90                   xchg   %ax,%ax
    0.00 :	  7a5900:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a5904:       e9 f9 fe ff ff          jmpq   7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a5909:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                InvalidTransactionId);
         :	                                        return false;
         :	                                }
         :	                        }
         :	                }
         :	                else if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5910:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a5912:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5918:       e8 83 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a591d:       84 c0                   test   %al,%al
    0.00 :	  7a591f:       90                      nop
    0.00 :	  7a5920:       74 76                   je     7a5998 <HeapTupleSatisfiesMVCC+0x248>
         :	                {
         :	                        if (HeapTupleHeaderGetCmin(tuple) >= snapshot->curcid)
    0.00 :	  7a5922:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5925:       e8 96 eb ff ff          callq  7a44c0 <HeapTupleHeaderGetCmin>
    0.00 :	  7a592a:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a592e:       66 90                   xchg   %ax,%ax
    0.00 :	  7a5930:       0f 83 60 ff ff ff       jae    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;   /* inserted after scan started */
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid */
    0.00 :	  7a5936:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :	                                return true;
         :
         :	                        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))        /* not deleter */
    0.00 :	  7a593a:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5940:       0f 85 6a ff ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5946:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5948:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a594d:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5950:       0f 84 5a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                                return true;
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a5956:       80 e6 10                and    $0x10,%dh
    0.00 :	  7a5959:       0f 84 0a 01 00 00       je     7a5a69 <HeapTupleSatisfiesMVCC+0x319>
         :	                        {
         :	                                TransactionId xmax;
         :
         :	                                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a595f:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5962:       e8 b9 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  7a5967:       89 c7                   mov    %eax,%edi
         :
         :	                                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                                Assert(TransactionIdIsValid(xmax));
         :
         :	                                /* updating subtransaction must have aborted */
         :	                                if (!TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a5969:       e8 32 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a596e:       84 c0                   test   %al,%al
    0.00 :	  7a5970:       0f 84 3a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5976:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a597d:       00 00 00 
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
    0.00 :	  7a5980:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5983:       e8 58 eb ff ff          callq  7a44e0 <HeapTupleHeaderGetCmax>
    0.00 :	  7a5988:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a598c:       0f 93 c0                setae  %al
    0.00 :	  7a598f:       e9 04 ff ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5994:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5998:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a599a:       e8 11 c3 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a599f:       84 c0                   test   %al,%al
    0.00 :	  7a59a1:       0f 85 ef fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a59a7:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a59a9:       e8 32 a9 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a59ae:       84 c0                   test   %al,%al
    0.00 :	  7a59b0:       0f 84 9a 00 00 00       je     7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a59b6:       8b 0b                   mov    (%rbx),%ecx
    0.00 :	  7a59b8:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a59bd:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a59c0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59c3:       e8 d8 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a59c8:       e9 19 ff ff ff          jmpq   7a58e6 <HeapTupleSatisfiesMVCC+0x196>
    0.00 :	  7a59cd:       0f 1f 00                nopl   (%rax)
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a59d0:       44 8b 63 08             mov    0x8(%rbx),%r12d
    0.00 :	  7a59d4:       e9 fd fe ff ff          jmpq   7a58d6 <HeapTupleSatisfiesMVCC+0x186>
    0.00 :	  7a59d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59e0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59e3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a59e8:       e8 33 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59ed:       89 c7                   mov    %eax,%edi
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59ef:       41 89 c4                mov    %eax,%r12d
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59f2:       e8 a9 ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a59f7:       84 c0                   test   %al,%al
    0.00 :	  7a59f9:       75 85                   jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                if (TransactionIdIsInProgress(xmax))
    0.00 :	  7a59fb:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a59fe:       e8 ad c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a03:       84 c0                   test   %al,%al
    0.00 :	  7a5a05:       0f 85 a5 fe ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :	                if (TransactionIdDidCommit(xmax))
    0.00 :	  7a5a0b:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a0e:       e8 cd a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a13:       84 c0                   test   %al,%al
    0.00 :	  7a5a15:       0f 84 95 fe ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                {
         :	                        /* updating transaction committed, but when? */
         :	                        if (XidInMVCCSnapshot(xmax, snapshot))
    0.00 :	  7a5a1b:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5a1e:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a21:       e8 da fb ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a5a26:       84 c0                   test   %al,%al
    0.00 :	  7a5a28:       0f 95 c0                setne  %al
    0.00 :	  7a5a2b:       e9 68 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
    0.00 :	  7a5a30:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a33:       e8 78 c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a38:       84 c0                   test   %al,%al
    0.00 :	  7a5a3a:       0f 85 56 fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a5a40:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a43:       e8 98 a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a48:       84 c0                   test   %al,%al
    0.00 :	  7a5a4a:       0f 85 87 fd ff ff       jne    7a57d7 <HeapTupleSatisfiesMVCC+0x87>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                HeapTupleHeaderGetRawXmin(tuple));
         :	                else
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_INVALID,
    0.00 :	  7a5a50:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a52:       ba 00 02 00 00          mov    $0x200,%edx
    0.00 :	  7a5a57:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a5a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a5d:       e8 3e f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a62:       31 c0                   xor    %eax,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a64:       e9 2f fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                                        return true;    /* updated after scan started */
         :	                                else
         :	                                        return false;           /* updated before scan started */
         :	                        }
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5a69:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5a6c:       e8 2f ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5a71:       84 c0                   test   %al,%al
    0.00 :	  7a5a73:       0f 85 07 ff ff ff       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,
    0.00 :	  7a5a79:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a7b:       ba 00 08 00 00          mov    $0x800,%edx
    0.00 :	  7a5a80:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a83:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a86:       e8 15 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a8b:       b8 01 00 00 00          mov    $0x1,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a90:       e9 03 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:148
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:166
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:211
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:231
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:231
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:195
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046ff60 <heap_fill_tuple>:
         :	void
         :	heap_fill_tuple(TupleDesc tupleDesc,
         :	                                Datum *values, bool *isnull,
         :	                                char *data, Size data_size,
         :	                                uint16 *infomask, bits8 *bit)
         :	{
    0.00 :	  46ff60:       55                      push   %rbp
         :
         :	#ifdef USE_ASSERT_CHECKING
         :	        char       *start = data;
         :	#endif
         :
         :	        if (bit != NULL)
    0.00 :	  46ff61:       45 31 d2                xor    %r10d,%r10d
         :	void
         :	heap_fill_tuple(TupleDesc tupleDesc,
         :	                                Datum *values, bool *isnull,
         :	                                char *data, Size data_size,
         :	                                uint16 *infomask, bits8 *bit)
         :	{
    0.00 :	  46ff64:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46ff67:       41 57                   push   %r15
         :
         :	#ifdef USE_ASSERT_CHECKING
         :	        char       *start = data;
         :	#endif
         :
         :	        if (bit != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:148
   16.67 :	  46ff69:       45 31 ff                xor    %r15d,%r15d
         :	void
         :	heap_fill_tuple(TupleDesc tupleDesc,
         :	                                Datum *values, bool *isnull,
         :	                                char *data, Size data_size,
         :	                                uint16 *infomask, bits8 *bit)
         :	{
    0.00 :	  46ff6c:       41 56                   push   %r14
    0.00 :	  46ff6e:       41 55                   push   %r13
    0.00 :	  46ff70:       49 89 cd                mov    %rcx,%r13
    0.00 :	  46ff73:       41 54                   push   %r12
    0.00 :	  46ff75:       53                      push   %rbx
    0.00 :	  46ff76:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  46ff7a:       4c 8b 5d 10             mov    0x10(%rbp),%r11
    0.00 :	  46ff7e:       48 89 75 c8             mov    %rsi,-0x38(%rbp)
    0.00 :	  46ff82:       48 89 55 c0             mov    %rdx,-0x40(%rbp)
         :	        bits8      *bitP;
         :	        int                     bitmask;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
    0.00 :	  46ff86:       8b 07                   mov    (%rdi),%eax
         :
         :	#ifdef USE_ASSERT_CHECKING
         :	        char       *start = data;
         :	#endif
         :
         :	        if (bit != NULL)
    0.00 :	  46ff88:       4d 85 db                test   %r11,%r11
         :	                                uint16 *infomask, bits8 *bit)
         :	{
         :	        bits8      *bitP;
         :	        int                     bitmask;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
    0.00 :	  46ff8b:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ff8e:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	#ifdef USE_ASSERT_CHECKING
         :	        char       *start = data;
         :	#endif
         :
         :	        if (bit != NULL)
    0.00 :	  46ff92:       74 0a                   je     46ff9e <heap_fill_tuple+0x3e>
         :	        {
         :	                bitP = &bit[-1];
    0.00 :	  46ff94:       4d 8d 53 ff             lea    -0x1(%r11),%r10
    0.00 :	  46ff98:       41 bf 80 00 00 00       mov    $0x80,%r15d
         :	                /* just to keep compiler quiet */
         :	                bitP = NULL;
         :	                bitmask = 0;
         :	        }
         :
         :	        *infomask &= ~(HEAP_HASNULL | HEAP_HASVARWIDTH | HEAP_HASEXTERNAL);
    0.00 :	  46ff9e:       66 41 83 21 f8          andw   $0xfff8,(%r9)
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  46ffa3:       8b 4d d4                mov    -0x2c(%rbp),%ecx
    0.00 :	  46ffa6:       85 c9                   test   %ecx,%ecx
    0.00 :	  46ffa8:       0f 8e 5c 01 00 00       jle    47010a <heap_fill_tuple+0x1aa>
    0.00 :	  46ffae:       49 89 c0                mov    %rax,%r8
    0.00 :	  46ffb1:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  46ffb4:       eb 21                   jmp    46ffd7 <heap_fill_tuple+0x77>
    0.00 :	  46ffb6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46ffbd:       00 00 00 
         :	                                bitmask = 1;
         :	                        }
         :
         :	                        if (isnull[i])
         :	                        {
         :	                                *infomask |= HEAP_HASNULL;
    0.00 :	  46ffc0:       66 41 83 09 01          orw    $0x1,(%r9)
         :	                        Assert(att[i]->attlen > 0);
         :	                        data_length = att[i]->attlen;
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
         :	                }
         :
         :	                data += data_length;
    0.00 :	  46ffc5:       49 83 c6 01             add    $0x1,%r14
    0.00 :	  46ffc9:       49 83 c0 08             add    $0x8,%r8
         :	                bitmask = 0;
         :	        }
         :
         :	        *infomask &= ~(HEAP_HASNULL | HEAP_HASVARWIDTH | HEAP_HASEXTERNAL);
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  46ffcd:       44 39 75 d4             cmp    %r14d,-0x2c(%rbp)
    0.00 :	  46ffd1:       0f 8e 33 01 00 00       jle    47010a <heap_fill_tuple+0x1aa>
         :	        {
         :	                Size            data_length;
         :
         :	                if (bit != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:166
   16.67 :	  46ffd7:       4d 85 db                test   %r11,%r11
    0.00 :	  46ffda:       74 1e                   je     46fffa <heap_fill_tuple+0x9a>
         :	                {
         :	                        if (bitmask != HIGHBIT)
    0.00 :	  46ffdc:       41 81 ff 80 00 00 00    cmp    $0x80,%r15d
    0.00 :	  46ffe3:       0f 84 37 01 00 00       je     470120 <heap_fill_tuple+0x1c0>
         :	                                bitmask <<= 1;
    0.00 :	  46ffe9:       45 01 ff                add    %r15d,%r15d
         :	                                bitP += 1;
         :	                                *bitP = 0x0;
         :	                                bitmask = 1;
         :	                        }
         :
         :	                        if (isnull[i])
    0.00 :	  46ffec:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  46fff0:       42 80 3c 32 00          cmpb   $0x0,(%rdx,%r14,1)
    0.00 :	  46fff5:       75 c9                   jne    46ffc0 <heap_fill_tuple+0x60>
         :	                        {
         :	                                *infomask |= HEAP_HASNULL;
         :	                                continue;
         :	                        }
         :
         :	                        *bitP |= bitmask;
    0.00 :	  46fff7:       45 08 3a                or     %r15b,(%r10)
         :	                /*
         :	                 * XXX we use the att_align macros on the pointer value itself, not on
         :	                 * an offset.  This is a bit of a hack.
         :	                 */
         :
         :	                if (att[i]->attbyval)
    0.00 :	  46fffa:       49 8b 08                mov    (%r8),%rcx
    0.00 :	  46fffd:       80 79 5c 00             cmpb   $0x0,0x5c(%rcx)
    0.00 :	  470001:       74 7d                   je     470080 <heap_fill_tuple+0x120>
         :	                {
         :	                        /* pass-by-value */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  470003:       0f b6 41 5e             movzbl 0x5e(%rcx),%eax
    0.00 :	  470007:       3c 69                   cmp    $0x69,%al
    0.00 :	  470009:       0f 84 f1 01 00 00       je     470200 <heap_fill_tuple+0x2a0>
    0.00 :	  47000f:       3c 63                   cmp    $0x63,%al
    0.00 :	  470011:       74 10                   je     470023 <heap_fill_tuple+0xc3>
    0.00 :	  470013:       3c 64                   cmp    $0x64,%al
    0.00 :	  470015:       0f 84 55 02 00 00       je     470270 <heap_fill_tuple+0x310>
    0.00 :	  47001b:       49 83 c5 01             add    $0x1,%r13
    0.00 :	  47001f:       49 83 e5 fe             and    $0xfffffffffffffffe,%r13
         :	                        store_att_byval(data, values[i], att[i]->attlen);
    0.00 :	  470023:       0f b7 41 4c             movzwl 0x4c(%rcx),%eax
    0.00 :	  470027:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  47002b:       0f 84 e5 01 00 00       je     470216 <heap_fill_tuple+0x2b6>
    0.00 :	  470031:       0f 8f 01 01 00 00       jg     470138 <heap_fill_tuple+0x1d8>
    0.00 :	  470037:       66 83 e8 01             sub    $0x1,%ax
    0.00 :	  47003b:       0f 84 07 02 00 00       je     470248 <heap_fill_tuple+0x2e8>
    0.00 :	  470041:       ba 30 f7 7a 00          mov    $0x7af730,%edx
    0.00 :	  470046:       be c3 00 00 00          mov    $0xc3,%esi
    0.00 :	  47004b:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  470050:       4c 89 45 b8             mov    %r8,-0x48(%rbp)
    0.00 :	  470054:       e8 c7 b3 30 00          callq  77b420 <elog_start>
    0.00 :	  470059:       4c 8b 45 b8             mov    -0x48(%rbp),%r8
    0.00 :	  47005d:       be 2f f6 7a 00          mov    $0x7af62f,%esi
    0.00 :	  470062:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  470067:       49 8b 00                mov    (%r8),%rax
    0.00 :	  47006a:       0f bf 50 4c             movswl 0x4c(%rax),%edx
    0.00 :	  47006e:       31 c0                   xor    %eax,%eax
    0.00 :	  470070:       e8 bb b1 30 00          callq  77b230 <elog_finish>
    0.00 :	  470075:       e8 56 94 ff ff          callq  4694d0 <abort@plt>
    0.00 :	  47007a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        data_length = att[i]->attlen;
         :	                }
         :	                else if (att[i]->attlen == -1)
    0.00 :	  470080:       0f b7 41 4c             movzwl 0x4c(%rcx),%eax
    0.00 :	  470084:       66 83 f8 ff             cmp    $0xffff,%ax
    0.00 :	  470088:       0f 84 da 00 00 00       je     470168 <heap_fill_tuple+0x208>
         :	                                                                                                  att[i]->attalign);
         :	                                data_length = VARSIZE(val);
         :	                                memcpy(data, val, data_length);
         :	                        }
         :	                }
         :	                else if (att[i]->attlen == -2)
    0.00 :	  47008e:       66 83 f8 fe             cmp    $0xfffe,%ax
    0.00 :	  470092:       0f 84 e8 01 00 00       je     470280 <heap_fill_tuple+0x320>
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
         :	                }
         :	                else
         :	                {
         :	                        /* fixed-length pass-by-reference */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  470098:       0f b6 49 5e             movzbl 0x5e(%rcx),%ecx
    0.00 :	  47009c:       80 f9 69                cmp    $0x69,%cl
    0.00 :	  47009f:       0f 84 bb 01 00 00       je     470260 <heap_fill_tuple+0x300>
    0.00 :	  4700a5:       80 f9 63                cmp    $0x63,%cl
    0.00 :	  4700a8:       74 14                   je     4700be <heap_fill_tuple+0x15e>
    0.00 :	  4700aa:       80 f9 64                cmp    $0x64,%cl
    0.00 :	  4700ad:       0f 1f 00                nopl   (%rax)
    0.00 :	  4700b0:       0f 84 3a 02 00 00       je     4702f0 <heap_fill_tuple+0x390>
    0.00 :	  4700b6:       49 83 c5 01             add    $0x1,%r13
    0.00 :	  4700ba:       49 83 e5 fe             and    $0xfffffffffffffffe,%r13
         :	                        Assert(att[i]->attlen > 0);
         :	                        data_length = att[i]->attlen;
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
    0.00 :	  4700be:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
         :	                else
         :	                {
         :	                        /* fixed-length pass-by-reference */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
         :	                        Assert(att[i]->attlen > 0);
         :	                        data_length = att[i]->attlen;
    0.00 :	  4700c2:       4c 0f bf e0             movswq %ax,%r12
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
    0.00 :	  4700c6:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4700c9:       4a 8b 34 f2             mov    (%rdx,%r14,8),%rsi
    0.00 :	  4700cd:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  4700d0:       4c 89 45 b8             mov    %r8,-0x48(%rbp)
    0.00 :	  4700d4:       4c 89 4d b0             mov    %r9,-0x50(%rbp)
    0.00 :	  4700d8:       4c 89 55 a8             mov    %r10,-0x58(%rbp)
    0.00 :	  4700dc:       4c 89 5d a0             mov    %r11,-0x60(%rbp)
    0.00 :	  4700e0:       e8 0b 9b ff ff          callq  469bf0 <memcpy@plt>
    0.00 :	  4700e5:       4c 8b 5d a0             mov    -0x60(%rbp),%r11
    0.00 :	  4700e9:       4c 8b 55 a8             mov    -0x58(%rbp),%r10
    0.00 :	  4700ed:       4c 8b 4d b0             mov    -0x50(%rbp),%r9
    0.00 :	  4700f1:       4c 8b 45 b8             mov    -0x48(%rbp),%r8
         :	                }
         :
         :	                data += data_length;
    0.00 :	  4700f5:       4d 01 e5                add    %r12,%r13
    0.00 :	  4700f8:       49 83 c6 01             add    $0x1,%r14
    0.00 :	  4700fc:       49 83 c0 08             add    $0x8,%r8
         :	                bitmask = 0;
         :	        }
         :
         :	        *infomask &= ~(HEAP_HASNULL | HEAP_HASVARWIDTH | HEAP_HASEXTERNAL);
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470100:       44 39 75 d4             cmp    %r14d,-0x2c(%rbp)
    0.00 :	  470104:       0f 8f cd fe ff ff       jg     46ffd7 <heap_fill_tuple+0x77>
         :
         :	                data += data_length;
         :	        }
         :
         :	        Assert((data - start) == data_size);
         :	}
    0.00 :	  47010a:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  47010e:       5b                      pop    %rbx
    0.00 :	  47010f:       41 5c                   pop    %r12
    0.00 :	  470111:       41 5d                   pop    %r13
    0.00 :	  470113:       41 5e                   pop    %r14
    0.00 :	  470115:       41 5f                   pop    %r15
    0.00 :	  470117:       c9                      leaveq 
    0.00 :	  470118:       c3                      retq   
    0.00 :	  470119:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                {
         :	                        if (bitmask != HIGHBIT)
         :	                                bitmask <<= 1;
         :	                        else
         :	                        {
         :	                                bitP += 1;
    0.00 :	  470120:       49 83 c2 01             add    $0x1,%r10
         :	                                *bitP = 0x0;
    0.00 :	  470124:       41 bf 01 00 00 00       mov    $0x1,%r15d
    0.00 :	  47012a:       41 c6 02 00             movb   $0x0,(%r10)
    0.00 :	  47012e:       e9 b9 fe ff ff          jmpq   46ffec <heap_fill_tuple+0x8c>
    0.00 :	  470133:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	                if (att[i]->attbyval)
         :	                {
         :	                        /* pass-by-value */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
         :	                        store_att_byval(data, values[i], att[i]->attlen);
    0.00 :	  470138:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  47013c:       0f 84 ee 00 00 00       je     470230 <heap_fill_tuple+0x2d0>
    0.00 :	  470142:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  470146:       0f 85 f5 fe ff ff       jne    470041 <heap_fill_tuple+0xe1>
    0.00 :	  47014c:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  470150:       4a 8b 04 f2             mov    (%rdx,%r14,8),%rax
    0.00 :	  470154:       49 89 45 00             mov    %rax,0x0(%r13)
         :	                        data_length = att[i]->attlen;
    0.00 :	  470158:       49 8b 00                mov    (%r8),%rax
    0.00 :	  47015b:       4c 0f bf 60 4c          movswq 0x4c(%rax),%r12
    0.00 :	  470160:       eb 93                   jmp    4700f5 <heap_fill_tuple+0x195>
    0.00 :	  470162:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                }
         :	                else if (att[i]->attlen == -1)
         :	                {
         :	                        /* varlena */
         :	                        Pointer         val = DatumGetPointer(values[i]);
    0.00 :	  470168:       48 8b 45 c8             mov    -0x38(%rbp),%rax
         :
         :	                        *infomask |= HEAP_HASVARWIDTH;
    0.00 :	  47016c:       41 0f b7 11             movzwl (%r9),%edx
         :	                        data_length = att[i]->attlen;
         :	                }
         :	                else if (att[i]->attlen == -1)
         :	                {
         :	                        /* varlena */
         :	                        Pointer         val = DatumGetPointer(values[i]);
    0.00 :	  470170:       4a 8b 34 f0             mov    (%rax,%r14,8),%rsi
         :
         :	                        *infomask |= HEAP_HASVARWIDTH;
    0.00 :	  470174:       89 d0                   mov    %edx,%eax
    0.00 :	  470176:       83 c8 02                or     $0x2,%eax
    0.00 :	  470179:       66 41 89 01             mov    %ax,(%r9)
         :	                        if (VARATT_IS_EXTERNAL(val))
    0.00 :	  47017d:       0f b6 06                movzbl (%rsi),%eax
    0.00 :	  470180:       3c 01                   cmp    $0x1,%al
    0.00 :	  470182:       0f 84 38 01 00 00       je     4702c0 <heap_fill_tuple+0x360>
         :	                                *infomask |= HEAP_HASEXTERNAL;
         :	                                /* no alignment, since it's short by definition */
         :	                                data_length = VARSIZE_EXTERNAL(val);
         :	                                memcpy(data, val, data_length);
         :	                        }
         :	                        else if (VARATT_IS_SHORT(val))
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:211
   16.67 :	  470188:       0f b6 d0                movzbl %al,%edx
    0.00 :	  47018b:       f6 c2 01                test   $0x1,%dl
    0.00 :	  47018e:       0f 85 6c 01 00 00       jne    470300 <heap_fill_tuple+0x3a0>
         :	                        {
         :	                                /* no alignment for short varlenas */
         :	                                data_length = VARSIZE_SHORT(val);
         :	                                memcpy(data, val, data_length);
         :	                        }
         :	                        else if (VARLENA_ATT_IS_PACKABLE(att[i]) &&
    0.00 :	  470194:       49 8b 00                mov    (%r8),%rax
    0.00 :	  470197:       80 78 5d 70             cmpb   $0x70,0x5d(%rax)
    0.00 :	  47019b:       74 09                   je     4701a6 <heap_fill_tuple+0x246>
    0.00 :	  47019d:       83 e2 03                and    $0x3,%edx
    0.00 :	  4701a0:       0f 84 6a 01 00 00       je     470310 <heap_fill_tuple+0x3b0>
    0.00 :	  4701a6:       8b 0e                   mov    (%rsi),%ecx
    0.00 :	  4701a8:       c1 e9 02                shr    $0x2,%ecx
         :	                                memcpy(data + 1, VARDATA(val), data_length - 1);
         :	                        }
         :	                        else
         :	                        {
         :	                                /* full 4-byte header varlena */
         :	                                data = (char *) att_align_nominal(data,
    0.00 :	  4701ab:       0f b6 40 5e             movzbl 0x5e(%rax),%eax
    0.00 :	  4701af:       3c 69                   cmp    $0x69,%al
    0.00 :	  4701b1:       0f 84 99 01 00 00       je     470350 <heap_fill_tuple+0x3f0>
    0.00 :	  4701b7:       3c 63                   cmp    $0x63,%al
    0.00 :	  4701b9:       74 10                   je     4701cb <heap_fill_tuple+0x26b>
    0.00 :	  4701bb:       3c 64                   cmp    $0x64,%al
    0.00 :	  4701bd:       0f 84 9a 01 00 00       je     47035d <heap_fill_tuple+0x3fd>
    0.00 :	  4701c3:       49 83 c5 01             add    $0x1,%r13
    0.00 :	  4701c7:       49 83 e5 fe             and    $0xfffffffffffffffe,%r13
         :	                                                                                                  att[i]->attalign);
         :	                                data_length = VARSIZE(val);
    0.00 :	  4701cb:       41 89 cc                mov    %ecx,%r12d
         :	                                memcpy(data, val, data_length);
    0.00 :	  4701ce:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  4701d1:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4701d4:       4c 89 45 b8             mov    %r8,-0x48(%rbp)
    0.00 :	  4701d8:       4c 89 4d b0             mov    %r9,-0x50(%rbp)
    0.00 :	  4701dc:       4c 89 55 a8             mov    %r10,-0x58(%rbp)
    0.00 :	  4701e0:       4c 89 5d a0             mov    %r11,-0x60(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:231
   16.67 :	  4701e4:       e8 07 9a ff ff          callq  469bf0 <memcpy@plt>
    0.00 :	  4701e9:       4c 8b 45 b8             mov    -0x48(%rbp),%r8
    0.00 :	  4701ed:       4c 8b 4d b0             mov    -0x50(%rbp),%r9
   16.67 :	  4701f1:       4c 8b 55 a8             mov    -0x58(%rbp),%r10
    0.00 :	  4701f5:       4c 8b 5d a0             mov    -0x60(%rbp),%r11
    0.00 :	  4701f9:       e9 f7 fe ff ff          jmpq   4700f5 <heap_fill_tuple+0x195>
    0.00 :	  4701fe:       66 90                   xchg   %ax,%ax
         :
         :	                if (att[i]->attbyval)
         :	                {
         :	                        /* pass-by-value */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
         :	                        store_att_byval(data, values[i], att[i]->attlen);
    0.00 :	  470200:       0f b7 41 4c             movzwl 0x4c(%rcx),%eax
         :	                 */
         :
         :	                if (att[i]->attbyval)
         :	                {
         :	                        /* pass-by-value */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  470204:       49 83 c5 03             add    $0x3,%r13
    0.00 :	  470208:       49 83 e5 fc             and    $0xfffffffffffffffc,%r13
         :	                        store_att_byval(data, values[i], att[i]->attlen);
    0.00 :	  47020c:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  470210:       0f 85 1b fe ff ff       jne    470031 <heap_fill_tuple+0xd1>
    0.00 :	  470216:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  47021a:       4a 8b 04 f2             mov    (%rdx,%r14,8),%rax
    0.00 :	  47021e:       66 41 89 45 00          mov    %ax,0x0(%r13)
    0.00 :	  470223:       e9 30 ff ff ff          jmpq   470158 <heap_fill_tuple+0x1f8>
    0.00 :	  470228:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  47022f:       00 
    0.00 :	  470230:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  470234:       4a 8b 04 f2             mov    (%rdx,%r14,8),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:195
   16.67 :	  470238:       41 89 45 00             mov    %eax,0x0(%r13)
    0.00 :	  47023c:       e9 17 ff ff ff          jmpq   470158 <heap_fill_tuple+0x1f8>
    0.00 :	  470241:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  470248:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  47024c:       4a 8b 04 f2             mov    (%rdx,%r14,8),%rax
    0.00 :	  470250:       41 88 45 00             mov    %al,0x0(%r13)
    0.00 :	  470254:       e9 ff fe ff ff          jmpq   470158 <heap_fill_tuple+0x1f8>
    0.00 :	  470259:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
         :	                }
         :	                else
         :	                {
         :	                        /* fixed-length pass-by-reference */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  470260:       49 83 c5 03             add    $0x3,%r13
    0.00 :	  470264:       49 83 e5 fc             and    $0xfffffffffffffffc,%r13
    0.00 :	  470268:       e9 51 fe ff ff          jmpq   4700be <heap_fill_tuple+0x15e>
    0.00 :	  47026d:       0f 1f 00                nopl   (%rax)
         :	                 */
         :
         :	                if (att[i]->attbyval)
         :	                {
         :	                        /* pass-by-value */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  470270:       49 83 c5 07             add    $0x7,%r13
    0.00 :	  470274:       49 83 e5 f8             and    $0xfffffffffffffff8,%r13
    0.00 :	  470278:       e9 a6 fd ff ff          jmpq   470023 <heap_fill_tuple+0xc3>
    0.00 :	  47027d:       0f 1f 00                nopl   (%rax)
         :	                        }
         :	                }
         :	                else if (att[i]->attlen == -2)
         :	                {
         :	                        /* cstring ... never needs alignment */
         :	                        *infomask |= HEAP_HASVARWIDTH;
    0.00 :	  470280:       66 41 83 09 02          orw    $0x2,(%r9)
         :	                        Assert(att[i]->attalign == 'c');
         :	                        data_length = strlen(DatumGetCString(values[i])) + 1;
    0.00 :	  470285:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  470289:       4a 8b 1c f0             mov    (%rax,%r14,8),%rbx
    0.00 :	  47028d:       4c 89 45 b8             mov    %r8,-0x48(%rbp)
    0.00 :	  470291:       4c 89 4d b0             mov    %r9,-0x50(%rbp)
    0.00 :	  470295:       4c 89 55 a8             mov    %r10,-0x58(%rbp)
    0.00 :	  470299:       4c 89 5d a0             mov    %r11,-0x60(%rbp)
    0.00 :	  47029d:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4702a0:       e8 ab 95 ff ff          callq  469850 <strlen@plt>
    0.00 :	  4702a5:       4c 8d 60 01             lea    0x1(%rax),%r12
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
    0.00 :	  4702a9:       48 89 de                mov    %rbx,%rsi
    0.00 :	  4702ac:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4702af:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  4702b2:       e9 2d ff ff ff          jmpq   4701e4 <heap_fill_tuple+0x284>
    0.00 :	  4702b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4702be:       00 00 
         :	                        Pointer         val = DatumGetPointer(values[i]);
         :
         :	                        *infomask |= HEAP_HASVARWIDTH;
         :	                        if (VARATT_IS_EXTERNAL(val))
         :	                        {
         :	                                *infomask |= HEAP_HASEXTERNAL;
    0.00 :	  4702c0:       83 ca 06                or     $0x6,%edx
         :	                                /* no alignment, since it's short by definition */
         :	                                data_length = VARSIZE_EXTERNAL(val);
    0.00 :	  4702c3:       41 bc 0a 00 00 00       mov    $0xa,%r12d
         :	                        Pointer         val = DatumGetPointer(values[i]);
         :
         :	                        *infomask |= HEAP_HASVARWIDTH;
         :	                        if (VARATT_IS_EXTERNAL(val))
         :	                        {
         :	                                *infomask |= HEAP_HASEXTERNAL;
    0.00 :	  4702c9:       66 41 89 11             mov    %dx,(%r9)
         :	                                /* no alignment, since it's short by definition */
         :	                                data_length = VARSIZE_EXTERNAL(val);
    0.00 :	  4702cd:       0f b6 46 01             movzbl 0x1(%rsi),%eax
    0.00 :	  4702d1:       3c 01                   cmp    $0x1,%al
    0.00 :	  4702d3:       0f 84 f5 fe ff ff       je     4701ce <heap_fill_tuple+0x26e>
    0.00 :	  4702d9:       3c 12                   cmp    $0x12,%al
    0.00 :	  4702db:       41 bc 03 00 00 00       mov    $0x3,%r12d
    0.00 :	  4702e1:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  4702e6:       4c 0f 44 e2             cmove  %rdx,%r12
    0.00 :	  4702ea:       e9 df fe ff ff          jmpq   4701ce <heap_fill_tuple+0x26e>
    0.00 :	  4702ef:       90                      nop
         :	                        memcpy(data, DatumGetPointer(values[i]), data_length);
         :	                }
         :	                else
         :	                {
         :	                        /* fixed-length pass-by-reference */
         :	                        data = (char *) att_align_nominal(data, att[i]->attalign);
    0.00 :	  4702f0:       49 83 c5 07             add    $0x7,%r13
    0.00 :	  4702f4:       49 83 e5 f8             and    $0xfffffffffffffff8,%r13
    0.00 :	  4702f8:       e9 c1 fd ff ff          jmpq   4700be <heap_fill_tuple+0x15e>
    0.00 :	  4702fd:       0f 1f 00                nopl   (%rax)
         :	                                memcpy(data, val, data_length);
         :	                        }
         :	                        else if (VARATT_IS_SHORT(val))
         :	                        {
         :	                                /* no alignment for short varlenas */
         :	                                data_length = VARSIZE_SHORT(val);
    0.00 :	  470300:       d0 e8                   shr    %al
    0.00 :	  470302:       44 0f b6 e0             movzbl %al,%r12d
    0.00 :	  470306:       e9 c3 fe ff ff          jmpq   4701ce <heap_fill_tuple+0x26e>
    0.00 :	  47030b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                memcpy(data, val, data_length);
         :	                        }
         :	                        else if (VARLENA_ATT_IS_PACKABLE(att[i]) &&
    0.00 :	  470310:       8b 0e                   mov    (%rsi),%ecx
    0.00 :	  470312:       c1 e9 02                shr    $0x2,%ecx
    0.00 :	  470315:       8d 51 fc                lea    -0x4(%rcx),%edx
    0.00 :	  470318:       4c 8d 62 01             lea    0x1(%rdx),%r12
    0.00 :	  47031c:       49 83 fc 7f             cmp    $0x7f,%r12
    0.00 :	  470320:       0f 87 85 fe ff ff       ja     4701ab <heap_fill_tuple+0x24b>
         :	                                         VARATT_CAN_MAKE_SHORT(val))
         :	                        {
         :	                                /* convert to short varlena -- no alignment */
         :	                                data_length = VARATT_CONVERTED_SHORT_SIZE(val);
         :	                                SET_VARSIZE_SHORT(data, data_length);
    0.00 :	  470326:       43 8d 04 24             lea    (%r12,%r12,1),%eax
         :	                                memcpy(data + 1, VARDATA(val), data_length - 1);
    0.00 :	  47032a:       49 8d 7d 01             lea    0x1(%r13),%rdi
    0.00 :	  47032e:       48 83 c6 04             add    $0x4,%rsi
    0.00 :	  470332:       4c 89 45 b8             mov    %r8,-0x48(%rbp)
    0.00 :	  470336:       4c 89 4d b0             mov    %r9,-0x50(%rbp)
         :	                        else if (VARLENA_ATT_IS_PACKABLE(att[i]) &&
         :	                                         VARATT_CAN_MAKE_SHORT(val))
         :	                        {
         :	                                /* convert to short varlena -- no alignment */
         :	                                data_length = VARATT_CONVERTED_SHORT_SIZE(val);
         :	                                SET_VARSIZE_SHORT(data, data_length);
    0.00 :	  47033a:       83 c8 01                or     $0x1,%eax
         :	                                memcpy(data + 1, VARDATA(val), data_length - 1);
    0.00 :	  47033d:       4c 89 55 a8             mov    %r10,-0x58(%rbp)
    0.00 :	  470341:       4c 89 5d a0             mov    %r11,-0x60(%rbp)
         :	                        else if (VARLENA_ATT_IS_PACKABLE(att[i]) &&
         :	                                         VARATT_CAN_MAKE_SHORT(val))
         :	                        {
         :	                                /* convert to short varlena -- no alignment */
         :	                                data_length = VARATT_CONVERTED_SHORT_SIZE(val);
         :	                                SET_VARSIZE_SHORT(data, data_length);
    0.00 :	  470345:       41 88 45 00             mov    %al,0x0(%r13)
    0.00 :	  470349:       e9 96 fe ff ff          jmpq   4701e4 <heap_fill_tuple+0x284>
    0.00 :	  47034e:       66 90                   xchg   %ax,%ax
         :	                                memcpy(data + 1, VARDATA(val), data_length - 1);
         :	                        }
         :	                        else
         :	                        {
         :	                                /* full 4-byte header varlena */
         :	                                data = (char *) att_align_nominal(data,
    0.00 :	  470350:       49 83 c5 03             add    $0x3,%r13
    0.00 :	  470354:       49 83 e5 fc             and    $0xfffffffffffffffc,%r13
    0.00 :	  470358:       e9 6e fe ff ff          jmpq   4701cb <heap_fill_tuple+0x26b>
    0.00 :	  47035d:       49 83 c5 07             add    $0x7,%r13
    0.00 :	  470361:       49 83 e5 f8             and    $0xfffffffffffffff8,%r13
    0.00 :	  470365:       e9 61 fe ff ff          jmpq   4701cb <heap_fill_tuple+0x26b>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:117
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:111
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:111
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:111
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5c70 <btint4fastcmp>:
         :	                PG_RETURN_INT32(-1);
         :	}
         :
         :	static int
         :	btint4fastcmp(Datum x, Datum y, SortSupport ssup)
         :	{
    0.00 :	  4a5c70:       55                      push   %rbp
         :	        int32           a = DatumGetInt32(x);
         :	        int32           b = DatumGetInt32(y);
         :
         :	        if (a > b)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:111
   16.67 :	  4a5c71:       39 f7                   cmp    %esi,%edi
   16.67 :	  4a5c73:       b8 01 00 00 00          mov    $0x1,%eax
         :	                PG_RETURN_INT32(-1);
         :	}
         :
         :	static int
         :	btint4fastcmp(Datum x, Datum y, SortSupport ssup)
         :	{
    0.00 :	  4a5c78:       48 89 e5                mov    %rsp,%rbp
         :	        int32           a = DatumGetInt32(x);
         :	        int32           b = DatumGetInt32(y);
         :
         :	        if (a > b)
   16.67 :	  4a5c7b:       7f 09                   jg     4a5c86 <btint4fastcmp+0x16>
         :	                return 1;
         :	        else if (a == b)
    0.00 :	  4a5c7d:       0f 94 c0                sete   %al
    0.00 :	  4a5c80:       0f b6 c0                movzbl %al,%eax
    0.00 :	  4a5c83:       83 e8 01                sub    $0x1,%eax
         :	                return 0;
         :	        else
         :	                return -1;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:117
   50.00 :	  4a5c86:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:666
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:625
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/arch-x86.h:187
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/arch-x86.h:202
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068eec0 <LWLockAttemptLock>:
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
    0.00 :	  68eec0:       55                      push   %rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec1:       48 85 d2                test   %rdx,%rdx
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
    0.00 :	  68eec4:       48 89 e5                mov    %rsp,%rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec7:       74 03                   je     68eecc <LWLockAttemptLock+0xc>
         :	                *potentially_spurious = false;
    0.00 :	  68eec9:       c6 02 00                movb   $0x0,(%rdx)
         :
         :	        if (mode == LW_EXCLUSIVE)
    0.00 :	  68eecc:       85 f6                   test   %esi,%esi
    0.00 :	  68eece:       75 28                   jne    68eef8 <LWLockAttemptLock+0x38>
         :	#ifndef PG_HAVE_ATOMIC_READ_U32
         :	#define PG_HAVE_ATOMIC_READ_U32
         :	static inline uint32
         :	pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
         :	{
         :	        return *(&ptr->value);
    0.00 :	  68eed0:       8b 47 04                mov    0x4(%rdi),%eax
         :	                 * First check whether the variable is free without a atomic
         :	                 * operation; it's often quite a bit cheaper for contended
         :	                 * locks. Doing so can cause a superflous shared-exclusive cacheline
         :	                 * transition, but benchmarks show that it's still worth doing so.
         :	                 */
         :	                expected = pg_atomic_read_u32(&lock->lockcount);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:625
   16.67 :	  68eed3:       48 8d 57 04             lea    0x4(%rdi),%rdx
         :
         :	                if (expected != 0)
    0.00 :	  68eed7:       85 c0                   test   %eax,%eax
    0.00 :	  68eed9:       75 65                   jne    68ef40 <LWLockAttemptLock+0x80>
         :
         :	        /*
         :	         * Perform cmpxchg and use the zero flag which it implicitly sets when
         :	         * equal to measure the success.
         :	         */
         :	        __asm__ __volatile__(
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/arch-x86.h:187
   16.67 :	  68eedb:       b9 00 00 00 40          mov    $0x40000000,%ecx
    0.00 :	  68eee0:       89 f0                   mov    %esi,%eax
    0.00 :	  68eee2:       f0 0f b1 0a             lock cmpxchg %ecx,(%rdx)
    0.00 :	  68eee6:       40 0f 94 c6             sete   %sil
    0.00 :	  68eeea:       40 84 f6                test   %sil,%sil
    0.00 :	  68eeed:       0f 94 c1                sete   %cl
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68eef0:       89 c8                   mov    %ecx,%eax
    0.00 :	  68eef2:       c9                      leaveq 
    0.00 :	  68eef3:       c3                      retq   
    0.00 :	  68eef4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                /*
         :	                 * If the caller is interested in spurious locks, do an unlocked check
         :	                 * first.  This is useful if potentially spurious results have a
         :	                 * noticeable cost.
         :	                 */
         :	                if (potentially_spurious != NULL &&
    0.00 :	  68eef8:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68eefb:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68eeff:       74 0e                   je     68ef0f <LWLockAttemptLock+0x4f>
    0.00 :	  68ef01:       8b 47 04                mov    0x4(%rdi),%eax
    0.00 :	  68ef04:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68ef08:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef0d:       77 31                   ja     68ef40 <LWLockAttemptLock+0x80>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68ef0f:       b8 01 00 00 00          mov    $0x1,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/arch-x86.h:202
   16.67 :	  68ef14:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                 * might have to back out again if it turns out somebody else has an
         :	                 * exclusive lock.
         :	                 */
         :	                oldstate = pg_atomic_fetch_add_u32(&lock->lockcount, 1);
         :
         :	                if (oldstate >= EXCLUSIVE_LOCK)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:666
   50.00 :	  68ef18:       31 c9                   xor    %ecx,%ecx
    0.00 :	  68ef1a:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef1f:       76 cf                   jbe    68eef0 <LWLockAttemptLock+0x30>
    0.00 :	  68ef21:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68ef26:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                         * problems exist.
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
    0.00 :	  68ef2a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68ef2d:       74 11                   je     68ef40 <LWLockAttemptLock+0x80>
         :	                                *potentially_spurious = true;
    0.00 :	  68ef2f:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  68ef34:       c6 02 01                movb   $0x1,(%rdx)
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef37:       89 c8                   mov    %ecx,%eax
    0.00 :	  68ef39:       c9                      leaveq 
    0.00 :	  68ef3a:       c3                      retq   
    0.00 :	  68ef3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
         :	                                *potentially_spurious = true;
    0.00 :	  68ef40:       b9 01 00 00 00          mov    $0x1,%ecx
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef45:       c9                      leaveq 
    0.00 :	  68ef46:       89 c8                   mov    %ecx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1289
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1289
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1293
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1293
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1295
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1296
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077e0d0 <FunctionCall1Coll>:
         :	 * directly-computed parameter list.  Note that neither arguments nor result
         :	 * are allowed to be NULL.
         :	 */
         :	Datum
         :	FunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1289
   16.67 :	  77e0d0:       55                      push   %rbp
    0.00 :	  77e0d1:       48 89 f8                mov    %rdi,%rax
   16.67 :	  77e0d4:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  77e0d7:       48 81 ec b0 03 00 00    sub    $0x3b0,%rsp
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);
    0.00 :	  77e0de:       48 89 bd 50 fc ff ff    mov    %rdi,-0x3b0(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1293
   16.67 :	  77e0e5:       48 c7 85 58 fc ff ff    movq   $0x0,-0x3a8(%rbp)
    0.00 :	  77e0ec:       00 00 00 00 
         :
         :	        fcinfo.arg[0] = arg1;
         :	        fcinfo.argnull[0] = false;
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77e0f0:       48 8d bd 50 fc ff ff    lea    -0x3b0(%rbp),%rdi
         :	FunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)
         :	{
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);
    0.00 :	  77e0f7:       48 c7 85 60 fc ff ff    movq   $0x0,-0x3a0(%rbp)
    0.00 :	  77e0fe:       00 00 00 00 
   16.67 :	  77e102:       89 b5 68 fc ff ff       mov    %esi,-0x398(%rbp)
    0.00 :	  77e108:       c6 85 6c fc ff ff 00    movb   $0x0,-0x394(%rbp)
    0.00 :	  77e10f:       66 c7 85 6e fc ff ff    movw   $0x1,-0x392(%rbp)
    0.00 :	  77e116:       01 00 
         :
         :	        fcinfo.arg[0] = arg1;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1295
   16.67 :	  77e118:       48 89 95 70 fc ff ff    mov    %rdx,-0x390(%rbp)
         :	        fcinfo.argnull[0] = false;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1296
   16.67 :	  77e11f:       c6 45 90 00             movb   $0x0,-0x70(%rbp)
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77e123:       ff 10                   callq  *(%rax)
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
    0.00 :	  77e125:       80 bd 6c fc ff ff 00    cmpb   $0x0,-0x394(%rbp)
    0.00 :	  77e12c:       75 02                   jne    77e130 <FunctionCall1Coll+0x60>
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
         :
         :	        return result;
         :	}
    0.00 :	  77e12e:       c9                      leaveq 
    0.00 :	  77e12f:       c3                      retq   
         :
         :	        result = FunctionCallInvoke(&fcinfo);
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
    0.00 :	  77e130:       ba 60 52 8d 00          mov    $0x8d5260,%edx
    0.00 :	  77e135:       be 16 05 00 00          mov    $0x516,%esi
    0.00 :	  77e13a:       bf b3 47 8d 00          mov    $0x8d47b3,%edi
    0.00 :	  77e13f:       e8 dc d2 ff ff          callq  77b420 <elog_start>
    0.00 :	  77e144:       48 8b 85 50 fc ff ff    mov    -0x3b0(%rbp),%rax
    0.00 :	  77e14b:       be 97 4c 8d 00          mov    $0x8d4c97,%esi
    0.00 :	  77e150:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  77e155:       8b 50 08                mov    0x8(%rax),%edx
    0.00 :	  77e158:       31 c0                   xor    %eax,%eax
    0.00 :	  77e15a:       e8 d1 d0 ff ff          callq  77b230 <elog_finish>
    0.00 :	  77e15f:       e8 6c b3 ce ff          callq  4694d0 <abort@plt>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1506
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1483
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1494
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1508
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000496e90 <heap_getnext>:
         :	#endif   /* !defined(HEAPDEBUGALL) */
         :
         :
         :	HeapTuple
         :	heap_getnext(HeapScanDesc scan, ScanDirection direction)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1483
   20.00 :	  496e90:       55                      push   %rbp
    0.00 :	  496e91:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  496e94:       53                      push   %rbx
    0.00 :	  496e95:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  496e98:       48 83 ec 08             sub    $0x8,%rsp
         :	        /* Note: no locking manipulations needed */
         :
         :	        HEAPDEBUG_1;                            /* heap_getnext( info ) */
         :
         :	        if (scan->rs_pageatatime)
    0.00 :	  496e9c:       80 7f 21 00             cmpb   $0x0,0x21(%rdi)
    0.00 :	  496ea0:       74 3e                   je     496ee0 <heap_getnext+0x50>
         :	                heapgettup_pagemode(scan, direction,
    0.00 :	  496ea2:       48 8b 4f 18             mov    0x18(%rdi),%rcx
    0.00 :	  496ea6:       8b 57 10                mov    0x10(%rdi),%edx
    0.00 :	  496ea9:       e8 42 f2 ff ff          callq  4960f0 <heapgettup_pagemode>
         :	                                                        scan->rs_nkeys, scan->rs_key);
         :	        else
         :	                heapgettup(scan, direction, scan->rs_nkeys, scan->rs_key);
         :
         :	        if (scan->rs_ctup.t_data == NULL)
    0.00 :	  496eae:       31 c0                   xor    %eax,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1494
   20.00 :	  496eb0:       48 83 7b 58 00          cmpq   $0x0,0x58(%rbx)
    0.00 :	  496eb5:       74 18                   je     496ecf <heap_getnext+0x3f>
         :	         * if we get here it means we have a new current scan tuple, so point to
         :	         * the proper return buffer and return the tuple.
         :	         */
         :	        HEAPDEBUG_3;                            /* heap_getnext returning tuple */
         :
         :	        pgstat_count_heap_getnext(scan->rs_rd);
    0.00 :	  496eb7:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  496eba:       48 8b 80 38 01 00 00    mov    0x138(%rax),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1506
   40.00 :	  496ec1:       48 85 c0                test   %rax,%rax
    0.00 :	  496ec4:       74 05                   je     496ecb <heap_getnext+0x3b>
    0.00 :	  496ec6:       48 83 40 18 01          addq   $0x1,0x18(%rax)
         :
         :	        return &(scan->rs_ctup);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1508
   20.00 :	  496ecb:       48 8d 43 48             lea    0x48(%rbx),%rax
         :	}
    0.00 :	  496ecf:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  496ed3:       5b                      pop    %rbx
    0.00 :	  496ed4:       c9                      leaveq 
    0.00 :	  496ed5:       c3                      retq   
    0.00 :	  496ed6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  496edd:       00 00 00 
         :
         :	        if (scan->rs_pageatatime)
         :	                heapgettup_pagemode(scan, direction,
         :	                                                        scan->rs_nkeys, scan->rs_key);
         :	        else
         :	                heapgettup(scan, direction, scan->rs_nkeys, scan->rs_key);
    0.00 :	  496ee0:       48 8b 4f 18             mov    0x18(%rdi),%rcx
    0.00 :	  496ee4:       8b 57 10                mov    0x10(%rdi),%edx
    0.00 :	  496ee7:       e8 c4 f7 ff ff          callq  4966b0 <heapgettup>
    0.00 :	  496eec:       eb c0                   jmp    496eae <heap_getnext+0x1e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:129
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:129
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:155
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:41
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b3750 <ExecScan>:
         :	 */
         :	TupleTableSlot *
         :	ExecScan(ScanState *node,
         :	                 ExecScanAccessMtd accessMtd,   /* function returning a tuple */
         :	                 ExecScanRecheckMtd recheckMtd)
         :	{
    0.00 :	  5b3750:       55                      push   %rbp
    0.00 :	  5b3751:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b3754:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
   20.00 :	  5b3756:       41 56                   push   %r14
    0.00 :	  5b3758:       41 55                   push   %r13
    0.00 :	  5b375a:       41 54                   push   %r12
    0.00 :	  5b375c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5b375f:       53                      push   %rbx
    0.00 :	  5b3760:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	  5b3764:       48 89 75 b8             mov    %rsi,-0x48(%rbp)
    0.00 :	  5b3768:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        TupleTableSlot *resultSlot;
         :
         :	        /*
         :	         * Fetch data from node
         :	         */
         :	        qual = node->ps.qual;
    0.00 :	  5b376c:       48 8b 47 28             mov    0x28(%rdi),%rax
         :
         :	        /*
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
    0.00 :	  5b3770:       48 85 c0                test   %rax,%rax
         :	        TupleTableSlot *resultSlot;
         :
         :	        /*
         :	         * Fetch data from node
         :	         */
         :	        qual = node->ps.qual;
    0.00 :	  5b3773:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        projInfo = node->ps.ps_ProjInfo;
    0.00 :	  5b3777:       4c 8b 77 68             mov    0x68(%rdi),%r14
         :	        econtext = node->ps.ps_ExprContext;
    0.00 :	  5b377b:       4c 8b 6f 60             mov    0x60(%rdi),%r13
         :
         :	        /*
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:129
   20.00 :	  5b377f:       41 0f 94 c7             sete   %r15b
   20.00 :	  5b3783:       75 09                   jne    5b378e <ExecScan+0x3e>
    0.00 :	  5b3785:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b3788:       0f 84 d6 01 00 00       je     5b3964 <ExecScan+0x214>
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous scan
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
    0.00 :	  5b378e:       41 80 7c 24 70 00       cmpb   $0x0,0x70(%r12)
    0.00 :	  5b3794:       0f 85 a6 01 00 00       jne    5b3940 <ExecScan+0x1f0>
    0.00 :	  5b379a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a scan tuple.
         :	         */
         :	        ResetExprContext(econtext);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:155
   20.00 :	  5b37a0:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b37a4:       e8 07 52 1e 00          callq  7989b0 <MemoryContextReset>
         :	         */
         :	        for (;;)
         :	        {
         :	                TupleTableSlot *slot;
         :
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  5b37a9:       0f b6 05 e0 68 60 00    movzbl 0x6068e0(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  5b37b0:       84 c0                   test   %al,%al
    0.00 :	  5b37b2:       0f 85 50 01 00 00       jne    5b3908 <ExecScan+0x1b8>
         :	static inline TupleTableSlot *
         :	ExecScanFetch(ScanState *node,
         :	                          ExecScanAccessMtd accessMtd,
         :	                          ExecScanRecheckMtd recheckMtd)
         :	{
         :	        EState     *estate = node->ps.state;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:41
   20.00 :	  5b37b8:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :
         :	        if (estate->es_epqTuple != NULL)
    0.00 :	  5b37bd:       48 83 ba d0 00 00 00    cmpq   $0x0,0xd0(%rdx)
    0.00 :	  5b37c4:       00 
    0.00 :	  5b37c5:       0f 84 0d 01 00 00       je     5b38d8 <ExecScan+0x188>
         :	                 * conditions.
         :	                 */
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
    0.00 :	  5b37cb:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  5b37d0:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5b37d3:       8d 48 ff                lea    -0x1(%rax),%ecx
    0.00 :	  5b37d6:       48 8b 82 d8 00 00 00    mov    0xd8(%rdx),%rax
    0.00 :	  5b37dd:       80 3c 08 00             cmpb   $0x0,(%rax,%rcx,1)
    0.00 :	  5b37e1:       0f 84 f1 00 00 00       je     5b38d8 <ExecScan+0x188>
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b37e7:       48 89 c8                mov    %rcx,%rax
    0.00 :	  5b37ea:       48 03 82 e0 00 00 00    add    0xe0(%rdx),%rax
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
    0.00 :	  5b37f1:       49 8b 9c 24 88 00 00    mov    0x88(%r12),%rbx
    0.00 :	  5b37f8:       00 
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b37f9:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  5b37fc:       0f 85 16 01 00 00       jne    5b3918 <ExecScan+0x1c8>
         :	                                return ExecClearTuple(slot);
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
    0.00 :	  5b3802:       c6 00 01                movb   $0x1,(%rax)
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
    0.00 :	  5b3805:       48 8b 82 d0 00 00 00    mov    0xd0(%rdx),%rax
    0.00 :	  5b380c:       48 8b 3c c8             mov    (%rax,%rcx,8),%rdi
    0.00 :	  5b3810:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b3813:       0f 84 ff 00 00 00       je     5b3918 <ExecScan+0x1c8>
         :	                                return ExecClearTuple(slot);
         :
         :	                        /* Store test tuple in the plan node's scan slot */
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
    0.00 :	  5b3819:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b381b:       31 d2                   xor    %edx,%edx
    0.00 :	  5b381d:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b3820:       e8 5b 0c 00 00          callq  5b4480 <ExecStoreTuple>
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
    0.00 :	  5b3825:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b3828:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b382b:       ff 55 b0                callq  *-0x50(%rbp)
    0.00 :	  5b382e:       84 c0                   test   %al,%al
    0.00 :	  5b3830:       0f 84 fa 00 00 00       je     5b3930 <ExecScan+0x1e0>
         :	                 * if the slot returned by the accessMtd contains NULL, then it means
         :	                 * there is nothing more to scan so we just return an empty slot,
         :	                 * being careful to use the projection result slot so it has correct
         :	                 * tupleDesc.
         :	                 */
         :	                if (TupIsNull(slot))
    0.00 :	  5b3836:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b3839:       0f 84 ab 00 00 00       je     5b38ea <ExecScan+0x19a>
    0.00 :	  5b383f:       80 7b 04 00             cmpb   $0x0,0x4(%rbx)
    0.00 :	  5b3843:       0f 85 a1 00 00 00       jne    5b38ea <ExecScan+0x19a>
         :	                 *
         :	                 * check for non-nil qual here to avoid a function call to ExecQual()
         :	                 * when the qual is nil ... saves only a few cycles, but they add up
         :	                 * ...
         :	                 */
         :	                if (!qual || ExecQual(qual, econtext, false))
    0.00 :	  5b3849:       45 84 ff                test   %r15b,%r15b
         :	                }
         :
         :	                /*
         :	                 * place the current tuple into the expr context
         :	                 */
         :	                econtext->ecxt_scantuple = slot;
    0.00 :	  5b384c:       49 89 5d 08             mov    %rbx,0x8(%r13)
         :	                 *
         :	                 * check for non-nil qual here to avoid a function call to ExecQual()
         :	                 * when the qual is nil ... saves only a few cycles, but they add up
         :	                 * ...
         :	                 */
         :	                if (!qual || ExecQual(qual, econtext, false))
    0.00 :	  5b3850:       75 3e                   jne    5b3890 <ExecScan+0x140>
    0.00 :	  5b3852:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5b3856:       31 d2                   xor    %edx,%edx
    0.00 :	  5b3858:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  5b385b:       e8 b0 96 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b3860:       84 c0                   test   %al,%al
    0.00 :	  5b3862:       75 2c                   jne    5b3890 <ExecScan+0x140>
         :	                                 */
         :	                                return slot;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(node, 1);
    0.00 :	  5b3864:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  5b3869:       48 85 c0                test   %rax,%rax
    0.00 :	  5b386c:       0f 84 2e ff ff ff       je     5b37a0 <ExecScan+0x50>
    0.00 :	  5b3872:       f2 0f 10 05 de b8 1f    movsd  0x1fb8de(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b3879:       00 
    0.00 :	  5b387a:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b3881:       00 
    0.00 :	  5b3882:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b3889:       00 
    0.00 :	  5b388a:       e9 11 ff ff ff          jmpq   5b37a0 <ExecScan+0x50>
    0.00 :	  5b388f:       90                      nop
         :	                if (!qual || ExecQual(qual, econtext, false))
         :	                {
         :	                        /*
         :	                         * Found a satisfactory scan tuple.
         :	                         */
         :	                        if (projInfo)
    0.00 :	  5b3890:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b3893:       74 2b                   je     5b38c0 <ExecScan+0x170>
         :	                                /*
         :	                                 * Form a projection tuple, store it in the result tuple slot
         :	                                 * and return it --- unless we find we can project no tuples
         :	                                 * from this scan tuple, in which case continue scan.
         :	                                 */
         :	                                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3895:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b3899:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b389c:       e8 5f 97 ff ff          callq  5ad000 <ExecProject>
    0.00 :	  5b38a1:       48 89 c3                mov    %rax,%rbx
         :	                                if (isDone != ExprEndResult)
    0.00 :	  5b38a4:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  5b38a7:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5b38aa:       0f 84 f0 fe ff ff       je     5b37a0 <ExecScan+0x50>
         :	                                {
         :	                                        node->ps.ps_TupFromTlist = (isDone == ExprMultipleResult);
    0.00 :	  5b38b0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5b38b3:       41 0f 94 44 24 70       sete   0x70(%r12)
    0.00 :	  5b38b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
         :	        }
         :	}
    0.00 :	  5b38c0:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  5b38c4:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b38c7:       5b                      pop    %rbx
    0.00 :	  5b38c8:       41 5c                   pop    %r12
    0.00 :	  5b38ca:       41 5d                   pop    %r13
    0.00 :	  5b38cc:       41 5e                   pop    %r14
    0.00 :	  5b38ce:       41 5f                   pop    %r15
    0.00 :	  5b38d0:       c9                      leaveq 
    0.00 :	  5b38d1:       c3                      retq   
    0.00 :	  5b38d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        }
         :
         :	        /*
         :	         * Run the node-type-specific access method function to get the next tuple
         :	         */
         :	        return (*accessMtd) (node);
    0.00 :	  5b38d8:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b38db:       ff 55 b8                callq  *-0x48(%rbp)
    0.00 :	  5b38de:       48 89 c3                mov    %rax,%rbx
         :	                 * if the slot returned by the accessMtd contains NULL, then it means
         :	                 * there is nothing more to scan so we just return an empty slot,
         :	                 * being careful to use the projection result slot so it has correct
         :	                 * tupleDesc.
         :	                 */
         :	                if (TupIsNull(slot))
    0.00 :	  5b38e1:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b38e4:       0f 85 55 ff ff ff       jne    5b383f <ExecScan+0xef>
         :	                {
         :	                        if (projInfo)
    0.00 :	  5b38ea:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b38ed:       0f 1f 00                nopl   (%rax)
    0.00 :	  5b38f0:       74 ce                   je     5b38c0 <ExecScan+0x170>
         :	                                return ExecClearTuple(projInfo->pi_slot);
    0.00 :	  5b38f2:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	  5b38f6:       e8 15 08 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b38fb:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b38fe:       66 90                   xchg   %ax,%ax
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
         :	        }
         :	}
    0.00 :	  5b3900:       eb be                   jmp    5b38c0 <ExecScan+0x170>
    0.00 :	  5b3902:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         */
         :	        for (;;)
         :	        {
         :	                TupleTableSlot *slot;
         :
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  5b3908:       e8 93 89 0e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5b390d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5b3910:       e9 a3 fe ff ff          jmpq   5b37b8 <ExecScan+0x68>
    0.00 :	  5b3915:       0f 1f 00                nopl   (%rax)
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
         :	                                return ExecClearTuple(slot);
    0.00 :	  5b3918:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b391b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5b3920:       e8 eb 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3925:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b3928:       e9 09 ff ff ff          jmpq   5b3836 <ExecScan+0xe6>
    0.00 :	  5b392d:       0f 1f 00                nopl   (%rax)
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
         :	                                ExecClearTuple(slot);   /* would not be returned by scan */
    0.00 :	  5b3930:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b3933:       e8 d8 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3938:       e9 f9 fe ff ff          jmpq   5b3836 <ExecScan+0xe6>
    0.00 :	  5b393d:       0f 1f 00                nopl   (%rax)
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
         :	        {
         :	                Assert(projInfo);               /* can't get here if not projecting */
         :	                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3940:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b3944:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b3947:       e8 b4 96 ff ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b394c:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
         :	        {
         :	                Assert(projInfo);               /* can't get here if not projecting */
         :	                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3950:       48 89 c3                mov    %rax,%rbx
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b3953:       0f 84 67 ff ff ff       je     5b38c0 <ExecScan+0x170>
         :	                        return resultSlot;
         :	                /* Done with that source tuple... */
         :	                node->ps.ps_TupFromTlist = false;
    0.00 :	  5b3959:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  5b395f:       e9 3c fe ff ff          jmpq   5b37a0 <ExecScan+0x50>
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
         :	        {
         :	                ResetExprContext(econtext);
    0.00 :	  5b3964:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b3968:       e8 43 50 1e 00          callq  7989b0 <MemoryContextReset>
         :	static inline TupleTableSlot *
         :	ExecScanFetch(ScanState *node,
         :	                          ExecScanAccessMtd accessMtd,
         :	                          ExecScanRecheckMtd recheckMtd)
         :	{
         :	        EState     *estate = node->ps.state;
    0.00 :	  5b396d:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :
         :	        if (estate->es_epqTuple != NULL)
    0.00 :	  5b3972:       48 83 ba d0 00 00 00    cmpq   $0x0,0xd0(%rdx)
    0.00 :	  5b3979:       00 
    0.00 :	  5b397a:       74 74                   je     5b39f0 <ExecScan+0x2a0>
         :	                 * conditions.
         :	                 */
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
    0.00 :	  5b397c:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  5b3981:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5b3984:       8d 48 ff                lea    -0x1(%rax),%ecx
    0.00 :	  5b3987:       48 8b 82 d8 00 00 00    mov    0xd8(%rdx),%rax
    0.00 :	  5b398e:       80 3c 08 00             cmpb   $0x0,(%rax,%rcx,1)
    0.00 :	  5b3992:       74 5c                   je     5b39f0 <ExecScan+0x2a0>
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b3994:       48 89 c8                mov    %rcx,%rax
    0.00 :	  5b3997:       48 03 82 e0 00 00 00    add    0xe0(%rdx),%rax
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
    0.00 :	  5b399e:       49 8b 9c 24 88 00 00    mov    0x88(%r12),%rbx
    0.00 :	  5b39a5:       00 
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b39a6:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  5b39a9:       75 5a                   jne    5b3a05 <ExecScan+0x2b5>
         :	                                return ExecClearTuple(slot);
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
    0.00 :	  5b39ab:       c6 00 01                movb   $0x1,(%rax)
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
    0.00 :	  5b39ae:       48 8b 82 d0 00 00 00    mov    0xd0(%rdx),%rax
    0.00 :	  5b39b5:       48 8b 3c c8             mov    (%rax,%rcx,8),%rdi
    0.00 :	  5b39b9:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b39bc:       74 47                   je     5b3a05 <ExecScan+0x2b5>
         :	                                return ExecClearTuple(slot);
         :
         :	                        /* Store test tuple in the plan node's scan slot */
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
    0.00 :	  5b39be:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b39c0:       31 d2                   xor    %edx,%edx
    0.00 :	  5b39c2:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b39c5:       e8 b6 0a 00 00          callq  5b4480 <ExecStoreTuple>
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
    0.00 :	  5b39ca:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b39cd:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b39d0:       ff 55 b0                callq  *-0x50(%rbp)
    0.00 :	  5b39d3:       84 c0                   test   %al,%al
    0.00 :	  5b39d5:       0f 85 e5 fe ff ff       jne    5b38c0 <ExecScan+0x170>
         :	                                ExecClearTuple(slot);   /* would not be returned by scan */
    0.00 :	  5b39db:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b39de:       e8 2d 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b39e3:       e9 d8 fe ff ff          jmpq   5b38c0 <ExecScan+0x170>
    0.00 :	  5b39e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b39ef:       00 
         :	        }
         :
         :	        /*
         :	         * Run the node-type-specific access method function to get the next tuple
         :	         */
         :	        return (*accessMtd) (node);
    0.00 :	  5b39f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b39f3:       ff 55 b8                callq  *-0x48(%rbp)
    0.00 :	  5b39f6:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b39f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5b3a00:       e9 bb fe ff ff          jmpq   5b38c0 <ExecScan+0x170>
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
         :	                                return ExecClearTuple(slot);
    0.00 :	  5b3a05:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b3a08:       e8 03 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3a0d:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b3a10:       e9 ab fe ff ff          jmpq   5b38c0 <ExecScan+0x170>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   80.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:867
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:831
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bc410 <ExecHashTableInsert>:
         :	 */
         :	void
         :	ExecHashTableInsert(HashJoinTable hashtable,
         :	                                        TupleTableSlot *slot,
         :	                                        uint32 hashvalue)
         :	{
    0.00 :	  5bc410:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:831
   20.00 :	  5bc411:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bc414:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  5bc418:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  5bc41c:       49 89 fd                mov    %rdi,%r13
    0.00 :	  5bc41f:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  5bc423:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  5bc427:       48 89 f7                mov    %rsi,%rdi
    0.00 :	  5bc42a:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  5bc42e:       48 83 ec 40             sub    $0x40,%rsp
    0.00 :	  5bc432:       89 d3                   mov    %edx,%ebx
         :	        MinimalTuple tuple = ExecFetchSlotMinimalTuple(slot);
    0.00 :	  5bc434:       e8 17 7b ff ff          callq  5b3f50 <ExecFetchSlotMinimalTuple>
    0.00 :	  5bc439:       49 89 c7                mov    %rax,%r15
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
    0.00 :	  5bc43c:       41 8b 45 40             mov    0x40(%r13),%eax
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
    0.00 :	  5bc440:       41 8b 55 00             mov    0x0(%r13),%edx
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
    0.00 :	  5bc444:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  5bc447:       0f 86 0b 01 00 00       jbe    5bc558 <ExecHashTableInsert+0x148>
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc44d:       41 8b 4d 04             mov    0x4(%r13),%ecx
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc451:       44 8d 72 ff             lea    -0x1(%rdx),%r14d
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc455:       89 da                   mov    %ebx,%edx
    0.00 :	  5bc457:       83 e8 01                sub    $0x1,%eax
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc45a:       41 21 de                and    %ebx,%r14d
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc45d:       d3 ea                   shr    %cl,%edx
    0.00 :	  5bc45f:       21 c2                   and    %eax,%edx
         :	                                                          &bucketno, &batchno);
         :
         :	        /*
         :	         * decide whether to put the tuple in the hash table or a temp file
         :	         */
         :	        if (batchno == hashtable->curbatch)
    0.00 :	  5bc461:       41 39 55 44             cmp    %edx,0x44(%r13)
    0.00 :	  5bc465:       74 31                   je     5bc498 <ExecHashTableInsert+0x88>
         :	        {
         :	                /*
         :	                 * put the tuple into a temp file for later batches
         :	                 */
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
    0.00 :	  5bc467:       48 63 d2                movslq %edx,%rdx
    0.00 :	  5bc46a:       89 de                   mov    %ebx,%esi
    0.00 :	  5bc46c:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bc46f:       48 c1 e2 03             shl    $0x3,%rdx
    0.00 :	  5bc473:       49 03 55 68             add    0x68(%r13),%rdx
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc477:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc47b:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc47f:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc483:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc487:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc48b:       c9                      leaveq 
         :	        {
         :	                /*
         :	                 * put the tuple into a temp file for later batches
         :	                 */
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
    0.00 :	  5bc48c:       e9 cf 10 00 00          jmpq   5bd560 <ExecHashJoinSaveTuple>
    0.00 :	  5bc491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * put the tuple in hash table
         :	                 */
         :	                HashJoinTuple hashTuple;
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
    0.00 :	  5bc498:       f2 41 0f 10 45 58       movsd  0x58(%r13),%xmm0
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc49e:       4c 89 ef                mov    %r13,%rdi
         :	                /*
         :	                 * put the tuple in hash table
         :	                 */
         :	                HashJoinTuple hashTuple;
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
    0.00 :	  5bc4a1:       f2 0f 11 45 c0          movsd  %xmm0,-0x40(%rbp)
    0.00 :	  5bc4a6:       f2 41 0f 10 4d 60       movsd  0x60(%r13),%xmm1
    0.00 :	  5bc4ac:       f2 0f 11 4d c8          movsd  %xmm1,-0x38(%rbp)
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc4b1:       41 8b 07                mov    (%r15),%eax
    0.00 :	  5bc4b4:       83 c0 10                add    $0x10,%eax
    0.00 :	  5bc4b7:       48 98                   cltq   
    0.00 :	  5bc4b9:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5bc4bc:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5bc4c0:       e8 fb fa ff ff          callq  5bbfc0 <dense_alloc>
         :
         :	                hashTuple->hashvalue = hashvalue;
    0.00 :	  5bc4c5:       89 58 08                mov    %ebx,0x8(%rax)
         :	                memcpy(HJTUPLE_MINTUPLE(hashTuple), tuple, tuple->t_len);
    0.00 :	  5bc4c8:       41 8b 17                mov    (%r15),%edx
    0.00 :	  5bc4cb:       48 8d 58 10             lea    0x10(%rax),%rbx
    0.00 :	  5bc4cf:       4c 89 fe                mov    %r15,%rsi
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc4d2:       49 89 c4                mov    %rax,%r12
         :
         :	                hashTuple->hashvalue = hashvalue;
         :	                memcpy(HJTUPLE_MINTUPLE(hashTuple), tuple, tuple->t_len);
    0.00 :	  5bc4d5:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5bc4d8:       e8 13 d7 ea ff          callq  469bf0 <memcpy@plt>
         :	                 * We always reset the tuple-matched flag on insertion.  This is okay
         :	                 * even when reloading a tuple from a batch file, since the tuple
         :	                 * could not possibly have been matched to an outer tuple before it
         :	                 * went into the batch file.
         :	                 */
         :	                HeapTupleHeaderClearMatch(HJTUPLE_MINTUPLE(hashTuple));
    0.00 :	  5bc4dd:       66 81 63 0a ff 7f       andw   $0x7fff,0xa(%rbx)
         :
         :	                /* Push it onto the front of the bucket's list */
         :	                hashTuple->next = hashtable->buckets[bucketno];
    0.00 :	  5bc4e3:       49 63 d6                movslq %r14d,%rdx
    0.00 :	  5bc4e6:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  5bc4ea:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:867
   80.00 :	  5bc4ee:       49 89 04 24             mov    %rax,(%r12)
         :	                hashtable->buckets[bucketno] = hashTuple;
    0.00 :	  5bc4f2:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  5bc4f6:       4c 89 24 d0             mov    %r12,(%rax,%rdx,8)
         :
         :	                /*
         :	                 * Increase the (optimal) number of buckets if we just exceeded the
         :	                 * NTUP_PER_BUCKET threshold, but only when there's still a single batch.
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
    0.00 :	  5bc4fa:       41 83 7d 40 01          cmpl   $0x1,0x40(%r13)
    0.00 :	  5bc4ff:       74 7f                   je     5bc580 <ExecHashTableInsert+0x170>
    0.00 :	  5bc501:       41 8b 55 0c             mov    0xc(%r13),%edx
         :	                        hashtable->nbuckets_optimal *= 2;
         :	                        hashtable->log2_nbuckets_optimal += 1;
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
    0.00 :	  5bc505:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  5bc509:       49 03 85 90 00 00 00    add    0x90(%r13),%rax
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
    0.00 :	  5bc510:       49 3b 85 a0 00 00 00    cmp    0xa0(%r13),%rax
         :	                        hashtable->nbuckets_optimal *= 2;
         :	                        hashtable->log2_nbuckets_optimal += 1;
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
    0.00 :	  5bc517:       49 89 85 90 00 00 00    mov    %rax,0x90(%r13)
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
    0.00 :	  5bc51e:       77 50                   ja     5bc570 <ExecHashTableInsert+0x160>
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
    0.00 :	  5bc520:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bc523:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  5bc527:       49 03 85 90 00 00 00    add    0x90(%r13),%rax
    0.00 :	  5bc52e:       49 3b 85 98 00 00 00    cmp    0x98(%r13),%rax
    0.00 :	  5bc535:       0f 87 8d 00 00 00       ja     5bc5c8 <ExecHashTableInsert+0x1b8>
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc53b:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc53f:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc543:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc547:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc54b:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc54f:       c9                      leaveq 
    0.00 :	  5bc550:       c3                      retq   
    0.00 :	  5bc551:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
         :	        }
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc558:       44 8d 72 ff             lea    -0x1(%rdx),%r14d
    0.00 :	  5bc55c:       31 d2                   xor    %edx,%edx
    0.00 :	  5bc55e:       41 21 de                and    %ebx,%r14d
    0.00 :	  5bc561:       e9 fb fe ff ff          jmpq   5bc461 <ExecHashTableInsert+0x51>
    0.00 :	  5bc566:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bc56d:       00 00 00 
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
    0.00 :	  5bc570:       49 89 85 a0 00 00 00    mov    %rax,0xa0(%r13)
    0.00 :	  5bc577:       eb a7                   jmp    5bc520 <ExecHashTableInsert+0x110>
    0.00 :	  5bc579:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * Increase the (optimal) number of buckets if we just exceeded the
         :	                 * NTUP_PER_BUCKET threshold, but only when there's still a single batch.
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
    0.00 :	  5bc580:       41 8b 55 0c             mov    0xc(%r13),%edx
    0.00 :	  5bc584:       81 fa ff ff ff 3f       cmp    $0x3fffffff,%edx
    0.00 :	  5bc58a:       0f 8f 75 ff ff ff       jg     5bc505 <ExecHashTableInsert+0xf5>
    0.00 :	  5bc590:       f2 0f 10 45 c0          movsd  -0x40(%rbp),%xmm0
    0.00 :	  5bc595:       f2 0f 5c 45 c8          subsd  -0x38(%rbp),%xmm0
    0.00 :	  5bc59a:       f2 0f 11 45 c0          movsd  %xmm0,-0x40(%rbp)
    0.00 :	  5bc59f:       f2 0f 2a c2             cvtsi2sd %edx,%xmm0
    0.00 :	  5bc5a3:       f2 0f 10 4d c0          movsd  -0x40(%rbp),%xmm1
    0.00 :	  5bc5a8:       66 0f 2e c8             ucomisd %xmm0,%xmm1
    0.00 :	  5bc5ac:       0f 82 53 ff ff ff       jb     5bc505 <ExecHashTableInsert+0xf5>
         :	                        (hashtable->nbuckets_optimal <= INT_MAX/2) &&   /* overflow protection */
         :	                        (ntuples >= (hashtable->nbuckets_optimal * NTUP_PER_BUCKET)))
         :	                {
         :	                        hashtable->nbuckets_optimal *= 2;
    0.00 :	  5bc5b2:       8d 04 12                lea    (%rdx,%rdx,1),%eax
         :	                        hashtable->log2_nbuckets_optimal += 1;
    0.00 :	  5bc5b5:       41 83 45 10 01          addl   $0x1,0x10(%r13)
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
         :	                        (hashtable->nbuckets_optimal <= INT_MAX/2) &&   /* overflow protection */
         :	                        (ntuples >= (hashtable->nbuckets_optimal * NTUP_PER_BUCKET)))
         :	                {
         :	                        hashtable->nbuckets_optimal *= 2;
    0.00 :	  5bc5ba:       41 89 45 0c             mov    %eax,0xc(%r13)
    0.00 :	  5bc5be:       89 c2                   mov    %eax,%edx
    0.00 :	  5bc5c0:       e9 40 ff ff ff          jmpq   5bc505 <ExecHashTableInsert+0xf5>
    0.00 :	  5bc5c5:       0f 1f 00                nopl   (%rax)
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
         :	                        hashtable->nbuckets_optimal * sizeof(HashJoinTuple)
         :	                        > hashtable->spaceAllowed)
         :	                        ExecHashIncreaseNumBatches(hashtable);
    0.00 :	  5bc5c8:       4c 89 ef                mov    %r13,%rdi
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc5cb:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc5cf:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc5d3:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc5d7:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc5db:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc5df:       c9                      leaveq 
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
         :	                        hashtable->nbuckets_optimal * sizeof(HashJoinTuple)
         :	                        > hashtable->spaceAllowed)
         :	                        ExecHashIncreaseNumBatches(hashtable);
    0.00 :	  5bc5e0:       e9 fb fa ff ff          jmpq   5bc0e0 <ExecHashIncreaseNumBatches>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   60.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/pg_locale.c:972
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/pg_locale.c:934
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/pg_locale.c:934
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000712bd0 <lc_collate_is_c>:
         :	/*
         :	 * Detect whether collation's LC_COLLATE property is C
         :	 */
         :	bool
         :	lc_collate_is_c(Oid collation)
         :	{
    0.00 :	  712bd0:       55                      push   %rbp
         :	        /*
         :	         * If we're asked about "collation 0", return false, so that the code will
         :	         * go into the non-C path and report that the collation is bogus.
         :	         */
         :	        if (!OidIsValid(collation))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/pg_locale.c:934
   20.00 :	  712bd1:       31 d2                   xor    %edx,%edx
   20.00 :	  712bd3:       85 ff                   test   %edi,%edi
         :	/*
         :	 * Detect whether collation's LC_COLLATE property is C
         :	 */
         :	bool
         :	lc_collate_is_c(Oid collation)
         :	{
    0.00 :	  712bd5:       48 89 e5                mov    %rsp,%rbp
         :	        /*
         :	         * If we're asked about "collation 0", return false, so that the code will
         :	         * go into the non-C path and report that the collation is bogus.
         :	         */
         :	        if (!OidIsValid(collation))
    0.00 :	  712bd8:       74 23                   je     712bfd <lc_collate_is_c+0x2d>
         :
         :	        /*
         :	         * If we're asked about the default collation, we have to inquire of the C
         :	         * library.  Cache the result so we only have to compute it once.
         :	         */
         :	        if (collation == DEFAULT_COLLATION_OID)
    0.00 :	  712bda:       83 ff 64                cmp    $0x64,%edi
    0.00 :	  712bdd:       74 29                   je     712c08 <lc_collate_is_c+0x38>
         :	        }
         :
         :	        /*
         :	         * If we're asked about the built-in C/POSIX collations, we know that.
         :	         */
         :	        if (collation == C_COLLATION_OID ||
    0.00 :	  712bdf:       8d 87 4a fc ff ff       lea    -0x3b6(%rdi),%eax
    0.00 :	  712be5:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  712bea:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  712bed:       76 0e                   jbe    712bfd <lc_collate_is_c+0x2d>
         :	                return true;
         :
         :	        /*
         :	         * Otherwise, we have to consult pg_collation, but we cache that.
         :	         */
         :	        return (lookup_collation_cache(collation, true))->collate_is_c;
    0.00 :	  712bef:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  712bf4:       e8 87 fb ff ff          callq  712780 <lookup_collation_cache>
    0.00 :	  712bf9:       0f b6 50 04             movzbl 0x4(%rax),%edx
         :	}
    0.00 :	  712bfd:       89 d0                   mov    %edx,%eax
    0.00 :	  712bff:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/pg_locale.c:972
   60.00 :	  712c00:       c3                      retq   
    0.00 :	  712c01:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        if (collation == DEFAULT_COLLATION_OID)
         :	        {
         :	                static int      result = -1;
         :	                char       *localeptr;
         :
         :	                if (result >= 0)
    0.00 :	  712c08:       8b 05 26 5e 45 00       mov    0x455e26(%rip),%eax        # b68a34 <result.10492>
    0.00 :	  712c0e:       85 c0                   test   %eax,%eax
         :	                        return (bool) result;
    0.00 :	  712c10:       89 c2                   mov    %eax,%edx
         :	        if (collation == DEFAULT_COLLATION_OID)
         :	        {
         :	                static int      result = -1;
         :	                char       *localeptr;
         :
         :	                if (result >= 0)
    0.00 :	  712c12:       79 e9                   jns    712bfd <lc_collate_is_c+0x2d>
         :	                        return (bool) result;
         :	                localeptr = setlocale(LC_COLLATE, NULL);
    0.00 :	  712c14:       31 f6                   xor    %esi,%esi
    0.00 :	  712c16:       bf 03 00 00 00          mov    $0x3,%edi
    0.00 :	  712c1b:       e8 e0 73 d5 ff          callq  46a000 <setlocale@plt>
         :	                if (!localeptr)
    0.00 :	  712c20:       48 85 c0                test   %rax,%rax
    0.00 :	  712c23:       74 3d                   je     712c62 <lc_collate_is_c+0x92>
         :	                        elog(ERROR, "invalid LC_COLLATE setting");
         :
         :	                if (strcmp(localeptr, "C") == 0)
    0.00 :	  712c25:       80 38 43                cmpb   $0x43,(%rax)
    0.00 :	  712c28:       74 26                   je     712c50 <lc_collate_is_c+0x80>
         :	                        result = true;
         :	                else if (strcmp(localeptr, "POSIX") == 0)
    0.00 :	  712c2a:       48 89 c6                mov    %rax,%rsi
    0.00 :	  712c2d:       bf c8 48 8c 00          mov    $0x8c48c8,%edi
    0.00 :	  712c32:       b9 06 00 00 00          mov    $0x6,%ecx
         :	                        result = true;
    0.00 :	  712c37:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
    0.00 :	  712c39:       0f 94 c0                sete   %al
    0.00 :	  712c3c:       0f b6 c0                movzbl %al,%eax
    0.00 :	  712c3f:       89 05 ef 5d 45 00       mov    %eax,0x455def(%rip)        # b68a34 <result.10492>
         :	                else
         :	                        result = false;
         :	                return (bool) result;
    0.00 :	  712c45:       0f b6 15 e8 5d 45 00    movzbl 0x455de8(%rip),%edx        # b68a34 <result.10492>
         :
         :	        /*
         :	         * Otherwise, we have to consult pg_collation, but we cache that.
         :	         */
         :	        return (lookup_collation_cache(collation, true))->collate_is_c;
         :	}
    0.00 :	  712c4c:       eb af                   jmp    712bfd <lc_collate_is_c+0x2d>
    0.00 :	  712c4e:       66 90                   xchg   %ax,%ax
         :	                        return (bool) result;
         :	                localeptr = setlocale(LC_COLLATE, NULL);
         :	                if (!localeptr)
         :	                        elog(ERROR, "invalid LC_COLLATE setting");
         :
         :	                if (strcmp(localeptr, "C") == 0)
    0.00 :	  712c50:       80 78 01 00             cmpb   $0x0,0x1(%rax)
    0.00 :	  712c54:       75 d4                   jne    712c2a <lc_collate_is_c+0x5a>
         :	                        result = true;
    0.00 :	  712c56:       c7 05 d4 5d 45 00 01    movl   $0x1,0x455dd4(%rip)        # b68a34 <result.10492>
    0.00 :	  712c5d:       00 00 00 
    0.00 :	  712c60:       eb e3                   jmp    712c45 <lc_collate_is_c+0x75>
         :
         :	                if (result >= 0)
         :	                        return (bool) result;
         :	                localeptr = setlocale(LC_COLLATE, NULL);
         :	                if (!localeptr)
         :	                        elog(ERROR, "invalid LC_COLLATE setting");
    0.00 :	  712c62:       ba 90 4b 8c 00          mov    $0x8c4b90,%edx
    0.00 :	  712c67:       be b6 03 00 00          mov    $0x3b6,%esi
    0.00 :	  712c6c:       bf 75 2f 8a 00          mov    $0x8a2f75,%edi
    0.00 :	  712c71:       e8 aa 87 06 00          callq  77b420 <elog_start>
    0.00 :	  712c76:       be e7 48 8c 00          mov    $0x8c48e7,%esi
    0.00 :	  712c7b:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  712c80:       31 c0                   xor    %eax,%eax
    0.00 :	  712c82:       e8 a9 85 06 00          callq  77b230 <elog_finish>
    0.00 :	  712c87:       e8 44 68 d5 ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:97
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:100
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000470370 <heap_compute_data_size>:
         :	 */
         :	Size
         :	heap_compute_data_size(TupleDesc tupleDesc,
         :	                                           Datum *values,
         :	                                           bool *isnull)
         :	{
    0.00 :	  470370:       55                      push   %rbp
    0.00 :	  470371:       49 89 f0                mov    %rsi,%r8
    0.00 :	  470374:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  470377:       41 57                   push   %r15
    0.00 :	  470379:       41 56                   push   %r14
    0.00 :	  47037b:       49 89 d6                mov    %rdx,%r14
    0.00 :	  47037e:       41 55                   push   %r13
    0.00 :	  470380:       41 54                   push   %r12
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470382:       45 31 e4                xor    %r12d,%r12d
         :	 */
         :	Size
         :	heap_compute_data_size(TupleDesc tupleDesc,
         :	                                           Datum *values,
         :	                                           bool *isnull)
         :	{
    0.00 :	  470385:       53                      push   %rbx
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470386:       31 db                   xor    %ebx,%ebx
         :	 */
         :	Size
         :	heap_compute_data_size(TupleDesc tupleDesc,
         :	                                           Datum *values,
         :	                                           bool *isnull)
         :	{
    0.00 :	  470388:       48 83 ec 08             sub    $0x8,%rsp
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
    0.00 :	  47038c:       44 8b 2f                mov    (%rdi),%r13d
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  47038f:       4c 8b 7f 08             mov    0x8(%rdi),%r15
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470393:       45 85 ed                test   %r13d,%r13d
    0.00 :	  470396:       7f 43                   jg     4703db <heap_compute_data_size+0x6b>
    0.00 :	  470398:       e9 c3 00 00 00          jmpq   470460 <heap_compute_data_size+0xf0>
    0.00 :	  47039d:       0f 1f 00                nopl   (%rax)
         :	                         */
         :	                        data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));
         :	                }
         :	                else
         :	                {
         :	                        data_length = att_align_datum(data_length, att[i]->attalign,
    0.00 :	  4703a0:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  4703a4:       3c 69                   cmp    $0x69,%al
    0.00 :	  4703a6:       0f 84 cc 00 00 00       je     470478 <heap_compute_data_size+0x108>
    0.00 :	  4703ac:       3c 63                   cmp    $0x63,%al
    0.00 :	  4703ae:       66 90                   xchg   %ax,%ax
    0.00 :	  4703b0:       74 10                   je     4703c2 <heap_compute_data_size+0x52>
    0.00 :	  4703b2:       3c 64                   cmp    $0x64,%al
    0.00 :	  4703b4:       0f 84 ce 00 00 00       je     470488 <heap_compute_data_size+0x118>
    0.00 :	  4703ba:       49 83 c4 01             add    $0x1,%r12
    0.00 :	  4703be:       49 83 e4 fe             and    $0xfffffffffffffffe,%r12
         :	                                                                                  att[i]->attlen, val);
         :	                        data_length = att_addlength_datum(data_length, att[i]->attlen,
    0.00 :	  4703c2:       66 85 c9                test   %cx,%cx
    0.00 :	  4703c5:       7e 71                   jle    470438 <heap_compute_data_size+0xc8>
    0.00 :	  4703c7:       48 0f bf c1             movswq %cx,%rax
    0.00 :	  4703cb:       49 01 c4                add    %rax,%r12
    0.00 :	  4703ce:       48 83 c3 01             add    $0x1,%rbx
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  4703d2:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  4703d5:       0f 8e 85 00 00 00       jle    470460 <heap_compute_data_size+0xf0>
         :	        {
         :	                Datum           val;
         :
         :	                if (isnull[i])
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:97
   50.00 :	  4703db:       41 80 3c 1e 00          cmpb   $0x0,(%r14,%rbx,1)
    0.00 :	  4703e0:       75 ec                   jne    4703ce <heap_compute_data_size+0x5e>
         :	                        continue;
         :
         :	                val = values[i];
         :
         :	                if (ATT_IS_PACKABLE(att[i]) &&
    0.00 :	  4703e2:       49 8b 14 df             mov    (%r15,%rbx,8),%rdx
         :	                Datum           val;
         :
         :	                if (isnull[i])
         :	                        continue;
         :
         :	                val = values[i];
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:100
   50.00 :	  4703e6:       49 8b 3c d8             mov    (%r8,%rbx,8),%rdi
         :
         :	                if (ATT_IS_PACKABLE(att[i]) &&
    0.00 :	  4703ea:       0f b7 4a 4c             movzwl 0x4c(%rdx),%ecx
    0.00 :	  4703ee:       66 83 f9 ff             cmp    $0xffff,%cx
    0.00 :	  4703f2:       75 ac                   jne    4703a0 <heap_compute_data_size+0x30>
    0.00 :	  4703f4:       80 7a 5d 70             cmpb   $0x70,0x5d(%rdx)
    0.00 :	  4703f8:       0f 84 c2 00 00 00       je     4704c0 <heap_compute_data_size+0x150>
    0.00 :	  4703fe:       0f b6 37                movzbl (%rdi),%esi
    0.00 :	  470401:       40 f6 c6 03             test   $0x3,%sil
    0.00 :	  470405:       75 12                   jne    470419 <heap_compute_data_size+0xa9>
    0.00 :	  470407:       8b 07                   mov    (%rdi),%eax
    0.00 :	  470409:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  47040c:       83 e8 04                sub    $0x4,%eax
    0.00 :	  47040f:       48 83 c0 01             add    $0x1,%rax
    0.00 :	  470413:       48 83 f8 7f             cmp    $0x7f,%rax
    0.00 :	  470417:       76 b2                   jbe    4703cb <heap_compute_data_size+0x5b>
         :	                         */
         :	                        data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));
         :	                }
         :	                else
         :	                {
         :	                        data_length = att_align_datum(data_length, att[i]->attalign,
    0.00 :	  470419:       83 e6 01                and    $0x1,%esi
    0.00 :	  47041c:       74 82                   je     4703a0 <heap_compute_data_size+0x30>
         :	                                                                                  att[i]->attlen, val);
         :	                        data_length = att_addlength_datum(data_length, att[i]->attlen,
    0.00 :	  47041e:       0f b6 07                movzbl (%rdi),%eax
    0.00 :	  470421:       3c 01                   cmp    $0x1,%al
    0.00 :	  470423:       74 73                   je     470498 <heap_compute_data_size+0x128>
    0.00 :	  470425:       a8 01                   test   $0x1,%al
    0.00 :	  470427:       0f 84 a3 00 00 00       je     4704d0 <heap_compute_data_size+0x160>
    0.00 :	  47042d:       d0 e8                   shr    %al
    0.00 :	  47042f:       0f b6 c0                movzbl %al,%eax
    0.00 :	  470432:       eb 97                   jmp    4703cb <heap_compute_data_size+0x5b>
    0.00 :	  470434:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  470438:       66 83 c1 01             add    $0x1,%cx
    0.00 :	  47043c:       74 e0                   je     47041e <heap_compute_data_size+0xae>
    0.00 :	  47043e:       4c 89 45 d0             mov    %r8,-0x30(%rbp)
    0.00 :	  470442:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  470446:       e8 05 94 ff ff          callq  469850 <strlen@plt>
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  47044b:       41 39 dd                cmp    %ebx,%r13d
         :	                }
         :	                else
         :	                {
         :	                        data_length = att_align_datum(data_length, att[i]->attalign,
         :	                                                                                  att[i]->attlen, val);
         :	                        data_length = att_addlength_datum(data_length, att[i]->attlen,
    0.00 :	  47044e:       4d 8d 64 04 01          lea    0x1(%r12,%rax,1),%r12
    0.00 :	  470453:       4c 8b 45 d0             mov    -0x30(%rbp),%r8
         :	        Size            data_length = 0;
         :	        int                     i;
         :	        int                     numberOfAttributes = tupleDesc->natts;
         :	        Form_pg_attribute *att = tupleDesc->attrs;
         :
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470457:       7f 82                   jg     4703db <heap_compute_data_size+0x6b>
    0.00 :	  470459:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                                          val);
         :	                }
         :	        }
         :
         :	        return data_length;
         :	}
    0.00 :	  470460:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  470464:       4c 89 e0                mov    %r12,%rax
    0.00 :	  470467:       5b                      pop    %rbx
    0.00 :	  470468:       41 5c                   pop    %r12
    0.00 :	  47046a:       41 5d                   pop    %r13
    0.00 :	  47046c:       41 5e                   pop    %r14
    0.00 :	  47046e:       41 5f                   pop    %r15
    0.00 :	  470470:       c9                      leaveq 
    0.00 :	  470471:       c3                      retq   
    0.00 :	  470472:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         */
         :	                        data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));
         :	                }
         :	                else
         :	                {
         :	                        data_length = att_align_datum(data_length, att[i]->attalign,
    0.00 :	  470478:       49 83 c4 03             add    $0x3,%r12
    0.00 :	  47047c:       49 83 e4 fc             and    $0xfffffffffffffffc,%r12
    0.00 :	  470480:       e9 3d ff ff ff          jmpq   4703c2 <heap_compute_data_size+0x52>
    0.00 :	  470485:       0f 1f 00                nopl   (%rax)
    0.00 :	  470488:       49 83 c4 07             add    $0x7,%r12
    0.00 :	  47048c:       49 83 e4 f8             and    $0xfffffffffffffff8,%r12
    0.00 :	  470490:       e9 2d ff ff ff          jmpq   4703c2 <heap_compute_data_size+0x52>
    0.00 :	  470495:       0f 1f 00                nopl   (%rax)
         :	                                                                                  att[i]->attlen, val);
         :	                        data_length = att_addlength_datum(data_length, att[i]->attlen,
    0.00 :	  470498:       0f b6 57 01             movzbl 0x1(%rdi),%edx
    0.00 :	  47049c:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  4704a1:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  4704a4:       0f 84 21 ff ff ff       je     4703cb <heap_compute_data_size+0x5b>
    0.00 :	  4704aa:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  4704ad:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  4704b2:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  4704b7:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  4704bb:       e9 0b ff ff ff          jmpq   4703cb <heap_compute_data_size+0x5b>
         :	                if (isnull[i])
         :	                        continue;
         :
         :	                val = values[i];
         :
         :	                if (ATT_IS_PACKABLE(att[i]) &&
    0.00 :	  4704c0:       0f b6 37                movzbl (%rdi),%esi
    0.00 :	  4704c3:       e9 51 ff ff ff          jmpq   470419 <heap_compute_data_size+0xa9>
    0.00 :	  4704c8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4704cf:       00 
         :	                }
         :	                else
         :	                {
         :	                        data_length = att_align_datum(data_length, att[i]->attalign,
         :	                                                                                  att[i]->attlen, val);
         :	                        data_length = att_addlength_datum(data_length, att[i]->attlen,
    0.00 :	  4704d0:       8b 07                   mov    (%rdi),%eax
    0.00 :	  4704d2:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  4704d5:       89 c0                   mov    %eax,%eax
    0.00 :	  4704d7:       e9 ef fe ff ff          jmpq   4703cb <heap_compute_data_size+0x5b>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:479
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:504
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:513
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:515
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005a9120 <TupleHashTableHash>:
         :	 * Also, the caller must select an appropriate memory context for running
         :	 * the hash functions. (dynahash.c doesn't change CurrentMemoryContext.)
         :	 */
         :	static uint32
         :	TupleHashTableHash(const void *key, Size keysize)
         :	{
    0.00 :	  5a9120:       55                      push   %rbp
    0.00 :	  5a9121:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5a9124:       41 57                   push   %r15
    0.00 :	  5a9126:       41 56                   push   %r14
    0.00 :	  5a9128:       41 55                   push   %r13
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:479
   25.00 :	  5a912a:       41 54                   push   %r12
    0.00 :	  5a912c:       53                      push   %rbx
    0.00 :	  5a912d:       48 83 ec 18             sub    $0x18,%rsp
         :	        MinimalTuple tuple = ((const TupleHashEntryData *) key)->firstTuple;
         :	        TupleTableSlot *slot;
         :	        TupleHashTable hashtable = CurTupleHashTable;
    0.00 :	  5a9131:       48 8b 1d 88 07 5d 00    mov    0x5d0788(%rip),%rbx        # b798c0 <CurTupleHashTable>
         :	 * the hash functions. (dynahash.c doesn't change CurrentMemoryContext.)
         :	 */
         :	static uint32
         :	TupleHashTableHash(const void *key, Size keysize)
         :	{
         :	        MinimalTuple tuple = ((const TupleHashEntryData *) key)->firstTuple;
    0.00 :	  5a9138:       48 8b 3f                mov    (%rdi),%rdi
         :	        TupleTableSlot *slot;
         :	        TupleHashTable hashtable = CurTupleHashTable;
         :	        int                     numCols = hashtable->numCols;
    0.00 :	  5a913b:       8b 43 08                mov    0x8(%rbx),%eax
         :	        AttrNumber *keyColIdx = hashtable->keyColIdx;
         :	        FmgrInfo   *hashfunctions;
         :	        uint32          hashkey = 0;
         :	        int                     i;
         :
         :	        if (tuple == NULL)
    0.00 :	  5a913e:       48 85 ff                test   %rdi,%rdi
         :	TupleHashTableHash(const void *key, Size keysize)
         :	{
         :	        MinimalTuple tuple = ((const TupleHashEntryData *) key)->firstTuple;
         :	        TupleTableSlot *slot;
         :	        TupleHashTable hashtable = CurTupleHashTable;
         :	        int                     numCols = hashtable->numCols;
    0.00 :	  5a9141:       89 45 c4                mov    %eax,-0x3c(%rbp)
         :	        AttrNumber *keyColIdx = hashtable->keyColIdx;
    0.00 :	  5a9144:       4c 8b 63 10             mov    0x10(%rbx),%r12
         :	        FmgrInfo   *hashfunctions;
         :	        uint32          hashkey = 0;
         :	        int                     i;
         :
         :	        if (tuple == NULL)
    0.00 :	  5a9148:       0f 84 8a 00 00 00       je     5a91d8 <TupleHashTableHash+0xb8>
         :	        }
         :	        else
         :	        {
         :	                /* Process a tuple already stored in the table */
         :	                /* (this case never actually occurs in current dynahash.c code) */
         :	                slot = hashtable->tableslot;
    0.00 :	  5a914e:       4c 8b 7b 40             mov    0x40(%rbx),%r15
         :	                ExecStoreMinimalTuple(tuple, slot, false);
    0.00 :	  5a9152:       31 d2                   xor    %edx,%edx
    0.00 :	  5a9154:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5a9157:       e8 84 b2 00 00          callq  5b43e0 <ExecStoreMinimalTuple>
         :	                hashfunctions = hashtable->tab_hash_funcs;
    0.00 :	  5a915c:       48 8b 43 18             mov    0x18(%rbx),%rax
         :	        }
         :
         :	        for (i = 0; i < numCols; i++)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:504
   25.00 :	  5a9160:       8b 55 c4                mov    -0x3c(%rbp),%edx
    0.00 :	  5a9163:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5a9166:       85 d2                   test   %edx,%edx
    0.00 :	  5a9168:       7e 58                   jle    5a91c2 <TupleHashTableHash+0xa2>
    0.00 :	  5a916a:       49 89 c6                mov    %rax,%r14
    0.00 :	  5a916d:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5a9170:       31 db                   xor    %ebx,%ebx
    0.00 :	  5a9172:       eb 14                   jmp    5a9188 <TupleHashTableHash+0x68>
    0.00 :	  5a9174:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5a9178:       83 c3 01                add    $0x1,%ebx
    0.00 :	  5a917b:       49 83 c4 02             add    $0x2,%r12
    0.00 :	  5a917f:       49 83 c6 30             add    $0x30,%r14
    0.00 :	  5a9183:       39 5d c4                cmp    %ebx,-0x3c(%rbp)
    0.00 :	  5a9186:       7e 3a                   jle    5a91c2 <TupleHashTableHash+0xa2>
         :	                bool            isNull;
         :
         :	                /* rotate hashkey left 1 bit at each step */
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
         :
         :	                attr = slot_getattr(slot, att, &isNull);
    0.00 :	  5a9188:       41 0f bf 34 24          movswl (%r12),%esi
    0.00 :	  5a918d:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5a9191:       4c 89 ff                mov    %r15,%rdi
         :	                AttrNumber      att = keyColIdx[i];
         :	                Datum           attr;
         :	                bool            isNull;
         :
         :	                /* rotate hashkey left 1 bit at each step */
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
    0.00 :	  5a9194:       41 d1 c5                rol    %r13d
         :
         :	                attr = slot_getattr(slot, att, &isNull);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:513
   25.00 :	  5a9197:       e8 64 62 ec ff          callq  46f400 <slot_getattr>
         :
         :	                if (!isNull)                    /* treat nulls as having hash key 0 */
    0.00 :	  5a919c:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:515
   25.00 :	  5a91a0:       75 d6                   jne    5a9178 <TupleHashTableHash+0x58>
         :	                {
         :	                        uint32          hkey;
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i],
    0.00 :	  5a91a2:       31 f6                   xor    %esi,%esi
    0.00 :	  5a91a4:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a91a7:       48 89 c2                mov    %rax,%rdx
    0.00 :	  5a91aa:       e8 21 4f 1d 00          callq  77e0d0 <FunctionCall1Coll>
         :	                slot = hashtable->tableslot;
         :	                ExecStoreMinimalTuple(tuple, slot, false);
         :	                hashfunctions = hashtable->tab_hash_funcs;
         :	        }
         :
         :	        for (i = 0; i < numCols; i++)
    0.00 :	  5a91af:       83 c3 01                add    $0x1,%ebx
         :	                {
         :	                        uint32          hkey;
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i],
         :	                                                                                                attr));
         :	                        hashkey ^= hkey;
    0.00 :	  5a91b2:       41 31 c5                xor    %eax,%r13d
         :	                slot = hashtable->tableslot;
         :	                ExecStoreMinimalTuple(tuple, slot, false);
         :	                hashfunctions = hashtable->tab_hash_funcs;
         :	        }
         :
         :	        for (i = 0; i < numCols; i++)
    0.00 :	  5a91b5:       49 83 c4 02             add    $0x2,%r12
    0.00 :	  5a91b9:       49 83 c6 30             add    $0x30,%r14
    0.00 :	  5a91bd:       39 5d c4                cmp    %ebx,-0x3c(%rbp)
    0.00 :	  5a91c0:       7f c6                   jg     5a9188 <TupleHashTableHash+0x68>
         :	                        hashkey ^= hkey;
         :	                }
         :	        }
         :
         :	        return hashkey;
         :	}
    0.00 :	  5a91c2:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5a91c6:       44 89 e8                mov    %r13d,%eax
    0.00 :	  5a91c9:       5b                      pop    %rbx
    0.00 :	  5a91ca:       41 5c                   pop    %r12
    0.00 :	  5a91cc:       41 5d                   pop    %r13
    0.00 :	  5a91ce:       41 5e                   pop    %r14
    0.00 :	  5a91d0:       41 5f                   pop    %r15
    0.00 :	  5a91d2:       c9                      leaveq 
    0.00 :	  5a91d3:       c3                      retq   
    0.00 :	  5a91d4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        int                     i;
         :
         :	        if (tuple == NULL)
         :	        {
         :	                /* Process the current input tuple for the table */
         :	                slot = hashtable->inputslot;
    0.00 :	  5a91d8:       4c 8b 7b 48             mov    0x48(%rbx),%r15
         :	                hashfunctions = hashtable->in_hash_funcs;
    0.00 :	  5a91dc:       48 8b 43 50             mov    0x50(%rbx),%rax
    0.00 :	  5a91e0:       e9 7b ff ff ff          jmpq   5a9160 <TupleHashTableHash+0x40>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1438
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1472
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbbb0 <ExecHashGetSkewBucket>:
         :	 *              or INVALID_SKEW_BUCKET_NO if the hashvalue is not
         :	 *              associated with any active skew bucket.
         :	 */
         :	int
         :	ExecHashGetSkewBucket(HashJoinTable hashtable, uint32 hashvalue)
         :	{
    0.00 :	  5bbbb0:       55                      push   %rbp
         :
         :	        /*
         :	         * Always return INVALID_SKEW_BUCKET_NO if not doing skew optimization (in
         :	         * particular, this happens after the initial batch is done).
         :	         */
         :	        if (!hashtable->skewEnabled)
    0.00 :	  5bbbb1:       80 7f 21 00             cmpb   $0x0,0x21(%rdi)
         :	 *              or INVALID_SKEW_BUCKET_NO if the hashvalue is not
         :	 *              associated with any active skew bucket.
         :	 */
         :	int
         :	ExecHashGetSkewBucket(HashJoinTable hashtable, uint32 hashvalue)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1438
   50.00 :	  5bbbb5:       48 89 e5                mov    %rsp,%rbp
         :
         :	        /*
         :	         * Always return INVALID_SKEW_BUCKET_NO if not doing skew optimization (in
         :	         * particular, this happens after the initial batch is done).
         :	         */
         :	        if (!hashtable->skewEnabled)
    0.00 :	  5bbbb8:       74 46                   je     5bbc00 <ExecHashGetSkewBucket+0x50>
         :	                return INVALID_SKEW_BUCKET_NO;
         :
         :	        /*
         :	         * Since skewBucketLen is a power of 2, we can do a modulo by ANDing.
         :	         */
         :	        bucket = hashvalue & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbba:       8b 47 30                mov    0x30(%rdi),%eax
    0.00 :	  5bbbbd:       89 f2                   mov    %esi,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbbf:       48 8b 4f 28             mov    0x28(%rdi),%rcx
         :	                return INVALID_SKEW_BUCKET_NO;
         :
         :	        /*
         :	         * Since skewBucketLen is a power of 2, we can do a modulo by ANDing.
         :	         */
         :	        bucket = hashvalue & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbc3:       44 8d 40 ff             lea    -0x1(%rax),%r8d
    0.00 :	  5bbbc7:       44 21 c2                and    %r8d,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbca:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bbbcd:       48 8b 04 c1             mov    (%rcx,%rax,8),%rax
    0.00 :	  5bbbd1:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbbd4:       75 1c                   jne    5bbbf2 <ExecHashGetSkewBucket+0x42>
    0.00 :	  5bbbd6:       eb 28                   jmp    5bbc00 <ExecHashGetSkewBucket+0x50>
    0.00 :	  5bbbd8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbbdf:       00 
         :	                   hashtable->skewBucket[bucket]->hashvalue != hashvalue)
         :	                bucket = (bucket + 1) & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbe0:       83 c2 01                add    $0x1,%edx
    0.00 :	  5bbbe3:       44 21 c2                and    %r8d,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbe6:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bbbe9:       48 8b 04 c1             mov    (%rcx,%rax,8),%rax
    0.00 :	  5bbbed:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbbf0:       74 0e                   je     5bbc00 <ExecHashGetSkewBucket+0x50>
    0.00 :	  5bbbf2:       39 30                   cmp    %esi,(%rax)
    0.00 :	  5bbbf4:       75 ea                   jne    5bbbe0 <ExecHashGetSkewBucket+0x30>
         :
         :	        /*
         :	         * There must not be any hashtable entry for this hash value.
         :	         */
         :	        return INVALID_SKEW_BUCKET_NO;
         :	}
    0.00 :	  5bbbf6:       89 d0                   mov    %edx,%eax
    0.00 :	  5bbbf8:       c9                      leaveq 
    0.00 :	  5bbbf9:       c3                      retq   
    0.00 :	  5bbbfa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbc00:       ba ff ff ff ff          mov    $0xffffffff,%edx
         :
         :	        /*
         :	         * There must not be any hashtable entry for this hash value.
         :	         */
         :	        return INVALID_SKEW_BUCKET_NO;
         :	}
    0.00 :	  5bbc05:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1472
   50.00 :	  5bbc06:       89 d0                   mov    %edx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674520 <GetPrivateRefCountEntry>:
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  674520:       55                      push   %rbp
    0.00 :	  674521:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674524:       41 57                   push   %r15
    0.00 :	  674526:       41 89 f7                mov    %esi,%r15d
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  674529:       89 fe                   mov    %edi,%esi
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  67452b:       41 56                   push   %r14
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
   25.00 :	  67452d:       41 55                   push   %r13
    0.00 :	  67452f:       41 54                   push   %r12
    0.00 :	  674531:       41 89 d4                mov    %edx,%r12d
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  674534:       ba c0 d0 b7 00          mov    $0xb7d0c0,%edx
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  674539:       53                      push   %rbx
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  67453a:       31 db                   xor    %ebx,%ebx
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  67453c:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  674540:       89 7d c4                mov    %edi,-0x3c(%rbp)
         :	        PrivateRefCountEntry *res;
         :	        PrivateRefCountEntry *free = NULL;
         :	        bool            found = false;
    0.00 :	  674543:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
    0.00 :	  674547:       eb 14                   jmp    67455d <GetPrivateRefCountEntry+0x3d>
    0.00 :	  674549:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                if (res->buffer == buffer)
         :	                        return res;
         :
         :	                /* Remember where to put a new refcount, should it become necessary. */
         :	                if (free == NULL && res->buffer == InvalidBuffer)
    0.00 :	  674550:       48 83 c2 08             add    $0x8,%rdx
         :
         :	        /*
         :	         * First search for references in the array, that'll be sufficient in the
         :	         * majority of cases.
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
    0.00 :	  674554:       48 81 fa 00 d1 b7 00    cmp    $0xb7d100,%rdx
    0.00 :	  67455b:       74 2b                   je     674588 <GetPrivateRefCountEntry+0x68>
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  67455d:       8b 0a                   mov    (%rdx),%ecx
    0.00 :	  67455f:       48 89 d0                mov    %rdx,%rax
    0.00 :	  674562:       39 f1                   cmp    %esi,%ecx
    0.00 :	  674564:       0f 84 c8 00 00 00       je     674632 <GetPrivateRefCountEntry+0x112>
         :	                        return res;
         :
         :	                /* Remember where to put a new refcount, should it become necessary. */
         :	                if (free == NULL && res->buffer == InvalidBuffer)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
   25.00 :	  67456a:       48 85 db                test   %rbx,%rbx
    0.00 :	  67456d:       75 e1                   jne    674550 <GetPrivateRefCountEntry+0x30>
    0.00 :	  67456f:       85 c9                   test   %ecx,%ecx
    0.00 :	  674571:       48 0f 44 da             cmove  %rdx,%rbx
   25.00 :	  674575:       48 83 c2 08             add    $0x8,%rdx
         :
         :	        /*
         :	         * First search for references in the array, that'll be sufficient in the
         :	         * majority of cases.
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
    0.00 :	  674579:       48 81 fa 00 d1 b7 00    cmp    $0xb7d100,%rdx
    0.00 :	  674580:       75 db                   jne    67455d <GetPrivateRefCountEntry+0x3d>
    0.00 :	  674582:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
    0.00 :	  674588:       8b 05 e2 8a 50 00       mov    0x508ae2(%rip),%eax        # b7d070 <PrivateRefCountOverflowed>
         :	        /*
         :	         * By here we know that the buffer, if already pinned, isn't residing in
         :	         * the array.
         :	         */
         :	        res = NULL;
         :	        found = false;
    0.00 :	  67458e:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
         :
         :	        /*
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
    0.00 :	  674592:       85 c0                   test   %eax,%eax
    0.00 :	  674594:       0f 8e ee 00 00 00       jle    674688 <GetPrivateRefCountEntry+0x168>
         :	        {
         :	                res = hash_search(PrivateRefCountHash,
    0.00 :	  67459a:       4c 8d 75 d7             lea    -0x29(%rbp),%r14
    0.00 :	  67459e:       48 8b 3d d3 8a 50 00    mov    0x508ad3(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6745a5:       48 8d 75 c4             lea    -0x3c(%rbp),%rsi
    0.00 :	  6745a9:       31 d2                   xor    %edx,%edx
    0.00 :	  6745ab:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  6745ae:       e8 ed 00 11 00          callq  7846a0 <hash_search>
         :	                                                  (void *) &buffer,
         :	                                                  HASH_FIND,
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
    0.00 :	  6745b3:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
         :	        {
         :	                res = hash_search(PrivateRefCountHash,
    0.00 :	  6745b7:       49 89 c5                mov    %rax,%r13
         :	                                                  (void *) &buffer,
         :	                                                  HASH_FIND,
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
    0.00 :	  6745ba:       0f 84 c8 00 00 00       je     674688 <GetPrivateRefCountEntry+0x168>
         :
         :	                }
         :	        }
         :	        else
         :	        {
         :	                if (!do_move)
    0.00 :	  6745c0:       45 84 e4                test   %r12b,%r12b
    0.00 :	  6745c3:       74 6d                   je     674632 <GetPrivateRefCountEntry+0x112>
         :	                {
         :	                        return res;
         :	                }
         :	                else if (found && free != NULL)
    0.00 :	  6745c5:       48 85 db                test   %rbx,%rbx
    0.00 :	  6745c8:       75 7e                   jne    674648 <GetPrivateRefCountEntry+0x128>
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6745ca:       8b 05 b0 8a 50 00       mov    0x508ab0(%rip),%eax        # b7d080 <PrivateRefCountClock>
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim entry into the hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6745d0:       48 8b 3d a1 8a 50 00    mov    0x508aa1(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6745d7:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  6745da:       ba 01 00 00 00          mov    $0x1,%edx
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6745df:       49 89 c4                mov    %rax,%r12
    0.00 :	  6745e2:       83 c0 01                add    $0x1,%eax
    0.00 :	  6745e5:       41 83 e4 07             and    $0x7,%r12d
    0.00 :	  6745e9:       89 05 91 8a 50 00       mov    %eax,0x508a91(%rip)        # b7d080 <PrivateRefCountClock>
    0.00 :	  6745ef:       4a 8d 1c e5 c0 d0 b7    lea    0xb7d0c0(,%r12,8),%rbx
    0.00 :	  6745f6:       00 
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim entry into the hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6745f7:       48 89 de                mov    %rbx,%rsi
    0.00 :	  6745fa:       e8 a1 00 11 00          callq  7846a0 <hash_search>
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  6745ff:       8b 53 04                mov    0x4(%rbx),%edx
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
         :	                        arrayent->refcount = res->refcount;
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674602:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  674605:       48 89 de                mov    %rbx,%rsi
         :	                        hashent = hash_search(PrivateRefCountHash,
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  674608:       89 50 04                mov    %edx,0x4(%rax)
         :
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
    0.00 :	  67460b:       41 8b 45 00             mov    0x0(%r13),%eax
         :	                        arrayent->refcount = res->refcount;
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  67460f:       ba 02 00 00 00          mov    $0x2,%edx
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
         :
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
    0.00 :	  674614:       42 89 04 e5 c0 d0 b7    mov    %eax,0xb7d0c0(,%r12,8)
    0.00 :	  67461b:       00 
         :	                        arrayent->refcount = res->refcount;
    0.00 :	  67461c:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  674620:       89 43 04                mov    %eax,0x4(%rbx)
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674623:       48 8b 3d 4e 8a 50 00    mov    0x508a4e(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  67462a:       e8 71 00 11 00          callq  7846a0 <hash_search>
    0.00 :	  67462f:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  674632:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  674636:       5b                      pop    %rbx
    0.00 :	  674637:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
   25.00 :	  674639:       41 5d                   pop    %r13
    0.00 :	  67463b:       41 5e                   pop    %r14
    0.00 :	  67463d:       41 5f                   pop    %r15
    0.00 :	  67463f:       c9                      leaveq 
    0.00 :	  674640:       c3                      retq   
    0.00 :	  674641:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                else if (found && free != NULL)
         :	                {
         :	                        /* move buffer from hashtable into the free array slot */
         :
         :	                        /* fill array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674648:       8b 45 c4                mov    -0x3c(%rbp),%eax
         :	                        free->refcount = res->refcount;
         :
         :	                        /* delete from hashtable */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  67464b:       48 8d 75 c4             lea    -0x3c(%rbp),%rsi
    0.00 :	  67464f:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  674652:       ba 02 00 00 00          mov    $0x2,%edx
         :	                else if (found && free != NULL)
         :	                {
         :	                        /* move buffer from hashtable into the free array slot */
         :
         :	                        /* fill array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674657:       89 03                   mov    %eax,(%rbx)
         :	                        free->refcount = res->refcount;
    0.00 :	  674659:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  67465d:       89 43 04                mov    %eax,0x4(%rbx)
         :
         :	                        /* delete from hashtable */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674660:       48 8b 3d 11 8a 50 00    mov    0x508a11(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  674667:       e8 34 00 11 00          callq  7846a0 <hash_search>
         :	                                                (void *) &buffer,
         :	                                                HASH_REMOVE,
         :	                                                &found);
         :	                        Assert(found);
         :	                        Assert(PrivateRefCountOverflowed > 0);
         :	                        PrivateRefCountOverflowed--;
    0.00 :	  67466c:       83 2d fd 89 50 00 01    subl   $0x1,0x5089fd(%rip)        # b7d070 <PrivateRefCountOverflowed>
    0.00 :	  674673:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  674676:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  67467a:       5b                      pop    %rbx
    0.00 :	  67467b:       41 5c                   pop    %r12
    0.00 :	  67467d:       41 5d                   pop    %r13
    0.00 :	  67467f:       41 5e                   pop    %r14
    0.00 :	  674681:       41 5f                   pop    %r15
    0.00 :	  674683:       c9                      leaveq 
    0.00 :	  674684:       c3                      retq   
    0.00 :	  674685:       0f 1f 00                nopl   (%rax)
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
         :	        {
         :	                if (!create)
    0.00 :	  674688:       31 c0                   xor    %eax,%eax
    0.00 :	  67468a:       45 84 ff                test   %r15b,%r15b
    0.00 :	  67468d:       74 a3                   je     674632 <GetPrivateRefCountEntry+0x112>
         :	                {
         :	                        /* Neither array nor hash have an entry and no new entry is needed */
         :	                        return NULL;
         :	                }
         :	                else if (free != NULL)
    0.00 :	  67468f:       48 85 db                test   %rbx,%rbx
    0.00 :	  674692:       74 11                   je     6746a5 <GetPrivateRefCountEntry+0x185>
         :	                {
         :	                        /* add entry into the free array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674694:       8b 45 c4                mov    -0x3c(%rbp),%eax
         :	                        free->refcount = 0;
    0.00 :	  674697:       c7 43 04 00 00 00 00    movl   $0x0,0x4(%rbx)
         :	                        return NULL;
         :	                }
         :	                else if (free != NULL)
         :	                {
         :	                        /* add entry into the free array slot */
         :	                        free->buffer = buffer;
    0.00 :	  67469e:       89 03                   mov    %eax,(%rbx)
         :	                        free->refcount = 0;
    0.00 :	  6746a0:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  6746a3:       eb 8d                   jmp    674632 <GetPrivateRefCountEntry+0x112>
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6746a5:       8b 05 d5 89 50 00       mov    0x5089d5(%rip),%eax        # b7d080 <PrivateRefCountClock>
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim array entry into hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6746ab:       48 8b 3d c6 89 50 00    mov    0x5089c6(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6746b2:       48 8d 4d d7             lea    -0x29(%rbp),%rcx
    0.00 :	  6746b6:       ba 01 00 00 00          mov    $0x1,%edx
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6746bb:       49 89 c4                mov    %rax,%r12
    0.00 :	  6746be:       83 c0 01                add    $0x1,%eax
    0.00 :	  6746c1:       41 83 e4 07             and    $0x7,%r12d
    0.00 :	  6746c5:       89 05 b5 89 50 00       mov    %eax,0x5089b5(%rip)        # b7d080 <PrivateRefCountClock>
    0.00 :	  6746cb:       4a 8d 1c e5 c0 d0 b7    lea    0xb7d0c0(,%r12,8),%rbx
    0.00 :	  6746d2:       00 
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim array entry into hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6746d3:       48 89 de                mov    %rbx,%rsi
    0.00 :	  6746d6:       e8 c5 ff 10 00          callq  7846a0 <hash_search>
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  6746db:       8b 53 04                mov    0x4(%rbx),%edx
    0.00 :	  6746de:       89 50 04                mov    %edx,0x4(%rax)
         :
         :	                        /* fill the now free array slot */
         :	                        arrayent->buffer = buffer;
    0.00 :	  6746e1:       8b 45 c4                mov    -0x3c(%rbp),%eax
    0.00 :	  6746e4:       42 89 04 e5 c0 d0 b7    mov    %eax,0xb7d0c0(,%r12,8)
    0.00 :	  6746eb:       00 
         :	                        arrayent->refcount = 0;
    0.00 :	  6746ec:       c7 43 04 00 00 00 00    movl   $0x0,0x4(%rbx)
         :
         :	                        PrivateRefCountOverflowed++;
    0.00 :	  6746f3:       48 89 d8                mov    %rbx,%rax
    0.00 :	  6746f6:       83 05 73 89 50 00 01    addl   $0x1,0x508973(%rip)        # b7d070 <PrivateRefCountOverflowed>
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  6746fd:       e9 30 ff ff ff          jmpq   674632 <GetPrivateRefCountEntry+0x112>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:724
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:721
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000758230 <bpchareq>:
         :	 * need to be so careful.
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  758230:       55                      push   %rbp
    0.00 :	  758231:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  758234:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  758238:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  75823c:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  758240:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  758244:       49 89 fd                mov    %rdi,%r13
    0.00 :	  758247:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  75824b:       48 83 ec 30             sub    $0x30,%rsp
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  75824f:       48 8b 7f 20             mov    0x20(%rdi),%rdi
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  758253:       45 31 f6                xor    %r14d,%r14d
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  758256:       e8 85 6a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75825b:       49 8b 7d 28             mov    0x28(%r13),%rdi
         :	 *****************************************************************************/
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  75825f:       49 89 c4                mov    %rax,%r12
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  758262:       e8 79 6a 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  758267:       4c 89 e7                mov    %r12,%rdi
         :
         :	Datum
         :	bpchareq(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75826a:       48 89 c3                mov    %rax,%rbx
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  75826d:       e8 1e fb ff ff          callq  757d90 <bcTruelen>
         :	        len2 = bcTruelen(arg2);
    0.00 :	  758272:       48 89 df                mov    %rbx,%rdi
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  758275:       41 89 c7                mov    %eax,%r15d
         :	        len2 = bcTruelen(arg2);
    0.00 :	  758278:       e8 13 fb ff ff          callq  757d90 <bcTruelen>
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  75827d:       41 39 c7                cmp    %eax,%r15d
    0.00 :	  758280:       74 3e                   je     7582c0 <bpchareq+0x90>
         :	                result = false;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);
         :
         :	        PG_FREE_IF_COPY(arg1, 0);
    0.00 :	  758282:       4d 3b 65 20             cmp    0x20(%r13),%r12
    0.00 :	  758286:       74 0d                   je     758295 <bpchareq+0x65>
    0.00 :	  758288:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  75828b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  758290:       e8 eb 08 04 00          callq  798b80 <pfree>
         :	        PG_FREE_IF_COPY(arg2, 1);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:724
   50.00 :	  758295:       49 3b 5d 28             cmp    0x28(%r13),%rbx
    0.00 :	  758299:       74 08                   je     7582a3 <bpchareq+0x73>
    0.00 :	  75829b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  75829e:       e8 dd 08 04 00          callq  798b80 <pfree>
         :
         :	        PG_RETURN_BOOL(result);
         :	}
    0.00 :	  7582a3:       4c 89 f0                mov    %r14,%rax
    0.00 :	  7582a6:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  7582aa:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  7582ae:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  7582b2:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  7582b6:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  7582ba:       c9                      leaveq 
    0.00 :	  7582bb:       c3                      retq   
    0.00 :	  7582bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
         :	                result = false;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);
    0.00 :	  7582c0:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  7582c3:       48 8d 43 04             lea    0x4(%rbx),%rax
    0.00 :	  7582c7:       48 8d 7b 01             lea    0x1(%rbx),%rdi
    0.00 :	  7582cb:       49 8d 74 24 01          lea    0x1(%r12),%rsi
    0.00 :	  7582d0:       49 63 cf                movslq %r15d,%rcx
    0.00 :	  7582d3:       48 0f 44 f8             cmove  %rax,%rdi
    0.00 :	  7582d7:       41 f6 04 24 01          testb  $0x1,(%r12)
    0.00 :	  7582dc:       49 8d 44 24 04          lea    0x4(%r12),%rax
    0.00 :	  7582e1:       48 0f 44 f0             cmove  %rax,%rsi
    0.00 :	  7582e5:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  7582e8:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:721
   50.00 :	  7582ea:       0f 97 c2                seta   %dl
    0.00 :	  7582ed:       0f 92 c0                setb   %al
    0.00 :	  7582f0:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  7582f3:       38 c2                   cmp    %al,%dl
    0.00 :	  7582f5:       41 0f 94 c6             sete   %r14b
    0.00 :	  7582f9:       eb 87                   jmp    758282 <bpchareq+0x52>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:724
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:716
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:727
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798f70 <palloc0>:
         :	        return ret;
         :	}
         :
         :	void *
         :	palloc0(Size size)
         :	{
    0.00 :	  798f70:       55                      push   %rbp
         :	        void       *ret;
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:716
   25.00 :	  798f71:       48 81 ff ff ff ff 3f    cmp    $0x3fffffff,%rdi
         :	        return ret;
         :	}
         :
         :	void *
         :	palloc0(Size size)
         :	{
    0.00 :	  798f78:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  798f7b:       41 54                   push   %r12
    0.00 :	  798f7d:       53                      push   %rbx
    0.00 :	  798f7e:       48 89 fb                mov    %rdi,%rbx
         :	        void       *ret;
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
    0.00 :	  798f81:       77 6d                   ja     798ff0 <palloc0+0x80>
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798f83:       48 8b 05 d6 18 42 00    mov    0x4218d6(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798f8a:       48 89 de                mov    %rbx,%rsi
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798f8d:       c6 40 30 00             movb   $0x0,0x30(%rax)
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798f91:       48 8b 3d c8 18 42 00    mov    0x4218c8(%rip),%rdi        # bba860 <CurrentMemoryContext>
    0.00 :	  798f98:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  798f9c:       ff 10                   callq  *(%rax)
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798f9e:       f6 c3 07                test   $0x7,%bl
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798fa1:       49 89 c4                mov    %rax,%r12
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798fa4:       75 09                   jne    798faf <palloc0+0x3f>
    0.00 :	  798fa6:       48 81 fb 00 04 00 00    cmp    $0x400,%rbx
    0.00 :	  798fad:       76 19                   jbe    798fc8 <palloc0+0x58>
    0.00 :	  798faf:       48 89 da                mov    %rbx,%rdx
    0.00 :	  798fb2:       31 f6                   xor    %esi,%esi
    0.00 :	  798fb4:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  798fb7:       e8 64 04 cd ff          callq  469420 <memset@plt>
         :
         :	        return ret;
         :	}
    0.00 :	  798fbc:       5b                      pop    %rbx
    0.00 :	  798fbd:       4c 89 e0                mov    %r12,%rax
    0.00 :	  798fc0:       41 5c                   pop    %r12
    0.00 :	  798fc2:       c9                      leaveq 
    0.00 :	  798fc3:       c3                      retq   
    0.00 :	  798fc4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        CurrentMemoryContext->isReset = false;
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798fc8:       49 8d 14 1c             lea    (%r12,%rbx,1),%rdx
    0.00 :	  798fcc:       49 39 d4                cmp    %rdx,%r12
    0.00 :	  798fcf:       73 eb                   jae    798fbc <palloc0+0x4c>
    0.00 :	  798fd1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  798fd8:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:724
   50.00 :	  798fdf:       48 83 c0 08             add    $0x8,%rax
    0.00 :	  798fe3:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  798fe6:       77 f0                   ja     798fd8 <palloc0+0x68>
         :
         :	        return ret;
         :	}
    0.00 :	  798fe8:       5b                      pop    %rbx
    0.00 :	  798fe9:       4c 89 e0                mov    %r12,%rax
    0.00 :	  798fec:       41 5c                   pop    %r12
    0.00 :	  798fee:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:727
   25.00 :	  798fef:       c3                      retq   
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
    0.00 :	  798ff0:       ba 10 20 8e 00          mov    $0x8e2010,%edx
    0.00 :	  798ff5:       be cd 02 00 00          mov    $0x2cd,%esi
    0.00 :	  798ffa:       bf 8e 1f 8e 00          mov    $0x8e1f8e,%edi
    0.00 :	  798fff:       e8 1c 24 fe ff          callq  77b420 <elog_start>
    0.00 :	  799004:       48 89 da                mov    %rbx,%rdx
    0.00 :	  799007:       be b8 1f 8e 00          mov    $0x8e1fb8,%esi
    0.00 :	  79900c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  799011:       31 c0                   xor    %eax,%eax
    0.00 :	  799013:       e8 18 22 fe ff          callq  77b230 <elog_finish>
    0.00 :	  799018:       e8 b3 04 cd ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:134
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:143
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a18f0 <qsort_ssup>:
         :	                        (cmp_ssup(a, c, ssup) < 0 ? a : c));
         :	}
         :
         :	static void
         :	qsort_ssup(SortTuple *a, size_t n, SortSupport ssup)
         :	{
    0.00 :	  7a18f0:       55                      push   %rbp
    0.00 :	  7a18f1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7a18f4:       41 57                   push   %r15
    0.00 :	  7a18f6:       41 56                   push   %r14
    0.00 :	  7a18f8:       49 89 fe                mov    %rdi,%r14
    0.00 :	  7a18fb:       41 55                   push   %r13
    0.00 :	  7a18fd:       49 89 f5                mov    %rsi,%r13
    0.00 :	  7a1900:       41 54                   push   %r12
    0.00 :	  7a1902:       53                      push   %rbx
    0.00 :	  7a1903:       48 83 ec 38             sub    $0x38,%rsp
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1907:       0f b6 05 82 87 41 00    movzbl 0x418782(%rip),%eax        # bba090 <InterruptPending>
         :	                        (cmp_ssup(a, c, ssup) < 0 ? a : c));
         :	}
         :
         :	static void
         :	qsort_ssup(SortTuple *a, size_t n, SortSupport ssup)
         :	{
    0.00 :	  7a190e:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1912:       84 c0                   test   %al,%al
    0.00 :	  7a1914:       0f 85 7b 02 00 00       jne    7a1b95 <qsort_ssup+0x2a5>
         :	        if (n < 7)
    0.00 :	  7a191a:       49 83 fd 06             cmp    $0x6,%r13
    0.00 :	  7a191e:       0f 86 80 02 00 00       jbe    7a1ba4 <qsort_ssup+0x2b4>
         :	                        for (pl = pm; pl > a && cmp_ssup(pl - 1, pl, ssup) > 0; pl--)
         :	                                swap(pl, pl - 1);
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  7a1924:       4b 8d 44 6d 00          lea    0x0(%r13,%r13,2),%rax
    0.00 :	  7a1929:       49 8d 5e 18             lea    0x18(%r14),%rbx
    0.00 :	  7a192d:       49 8d 04 c6             lea    (%r14,%rax,8),%rax
    0.00 :	  7a1931:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
    0.00 :	  7a1935:       48 39 c3                cmp    %rax,%rbx
    0.00 :	  7a1938:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  7a193c:       72 20                   jb     7a195e <qsort_ssup+0x6e>
    0.00 :	  7a193e:       e9 04 03 00 00          jmpq   7a1c47 <qsort_ssup+0x357>
    0.00 :	  7a1943:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
    0.00 :	  7a1948:       84 c0                   test   %al,%al
    0.00 :	  7a194a:       0f 84 b2 05 00 00       je     7a1f02 <qsort_ssup+0x612>
    0.00 :	  7a1950:       48 83 c3 18             add    $0x18,%rbx
    0.00 :	  7a1954:       48 3b 5d b0             cmp    -0x50(%rbp),%rbx
    0.00 :	  7a1958:       0f 83 e9 02 00 00       jae    7a1c47 <qsort_ssup+0x357>
         :	        {
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  7a195e:       0f b6 05 2b 87 41 00    movzbl 0x41872b(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  7a1965:       84 c0                   test   %al,%al
    0.00 :	  7a1967:       0f 85 f3 02 00 00       jne    7a1c60 <qsort_ssup+0x370>
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a196d:       80 7b f8 00             cmpb   $0x0,-0x8(%rbx)
         :	                if (cmp_ssup(pm - 1, pm, ssup) > 0)
    0.00 :	  7a1971:       0f b6 43 10             movzbl 0x10(%rbx),%eax
    0.00 :	  7a1975:       48 8b 73 08             mov    0x8(%rbx),%rsi
    0.00 :	  7a1979:       48 8b 7b f0             mov    -0x10(%rbx),%rdi
    0.00 :	  7a197d:       75 c9                   jne    7a1948 <qsort_ssup+0x58>
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
    0.00 :	  7a197f:       84 c0                   test   %al,%al
    0.00 :	  7a1981:       0f 84 e9 02 00 00       je     7a1c70 <qsort_ssup+0x380>
         :	        {
         :	                if (ssup->ssup_nulls_first)
    0.00 :	  7a1987:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a198b:       80 7a 0d 00             cmpb   $0x0,0xd(%rdx)
    0.00 :	  7a198f:       74 bf                   je     7a1950 <qsort_ssup+0x60>
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = a + (n / 2);
    0.00 :	  7a1991:       4c 89 e8                mov    %r13,%rax
         :	        if (n > 7)
    0.00 :	  7a1994:       4d 8d be 90 00 00 00    lea    0x90(%r14),%r15
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = a + (n / 2);
    0.00 :	  7a199b:       48 d1 e8                shr    %rax
         :	        if (n > 7)
    0.00 :	  7a199e:       49 83 fd 07             cmp    $0x7,%r13
         :	                        break;
         :	                }
         :	        }
         :	        if (presorted)
         :	                return;
         :	        pm = a + (n / 2);
    0.00 :	  7a19a2:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  7a19a6:       4d 8d 24 c6             lea    (%r14,%rax,8),%r12
         :	        if (n > 7)
    0.00 :	  7a19aa:       0f 85 26 05 00 00       jne    7a1ed6 <qsort_ssup+0x5e6>
         :	                        pm = med3_ssup(pm - d, pm, pm + d, ssup);
         :	                        pn = med3_ssup(pn - 2 * d, pn - d, pn, ssup);
         :	                }
         :	                pm = med3_ssup(pl, pm, pn, ssup);
         :	        }
         :	        swap(a, pm);
    0.00 :	  7a19b0:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  7a19b4:       49 8b 3e                mov    (%r14),%rdi
    0.00 :	  7a19b7:       49 8d 5e 30             lea    0x30(%r14),%rbx
    0.00 :	  7a19bb:       41 0f b6 4e 10          movzbl 0x10(%r14),%ecx
    0.00 :	  7a19c0:       41 8b 56 14             mov    0x14(%r14),%edx
    0.00 :	  7a19c4:       4d 89 fd                mov    %r15,%r13
    0.00 :	  7a19c7:       49 8b 76 08             mov    0x8(%r14),%rsi
    0.00 :	  7a19cb:       49 89 06                mov    %rax,(%r14)
    0.00 :	  7a19ce:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  7a19d3:       49 89 46 08             mov    %rax,0x8(%r14)
    0.00 :	  7a19d7:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  7a19dc:       49 89 46 10             mov    %rax,0x10(%r14)
    0.00 :	  7a19e0:       41 89 54 24 14          mov    %edx,0x14(%r12)
    0.00 :	  7a19e5:       41 88 4c 24 10          mov    %cl,0x10(%r12)
    0.00 :	  7a19ea:       49 89 74 24 08          mov    %rsi,0x8(%r12)
    0.00 :	  7a19ef:       49 89 3c 24             mov    %rdi,(%r12)
    0.00 :	  7a19f3:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  7a19f7:       4d 89 fc                mov    %r15,%r12
    0.00 :	  7a19fa:       48 89 5d c0             mov    %rbx,-0x40(%rbp)
    0.00 :	  7a19fe:       48 89 45 b8             mov    %rax,-0x48(%rbp)
    0.00 :	  7a1a02:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
         :	                                pa++;
    0.00 :	  7a1a08:       4c 8b 7d c0             mov    -0x40(%rbp),%r15
    0.00 :	  7a1a0c:       49 83 ef 18             sub    $0x18,%r15
         :	        swap(a, pm);
         :	        pa = pb = a + 1;
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_ssup(pb, a, ssup)) <= 0)
    0.00 :	  7a1a10:       4d 39 fc                cmp    %r15,%r12
    0.00 :	  7a1a13:       0f 83 7f 02 00 00       jae    7a1c98 <qsort_ssup+0x3a8>
         :	                swap(pb, pc);
         :	                pb++;
         :	                pc--;
         :	        }
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
    0.00 :	  7a1a19:       4d 89 fa                mov    %r15,%r10
    0.00 :	  7a1a1c:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  7a1a20:       4c 2b 55 b8             sub    -0x48(%rbp),%r10
    0.00 :	  7a1a24:       48 b9 ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rcx
    0.00 :	  7a1a2b:       aa aa aa 
    0.00 :	  7a1a2e:       4c 29 f0                sub    %r14,%rax
    0.00 :	  7a1a31:       49 c1 fa 03             sar    $0x3,%r10
    0.00 :	  7a1a35:       48 c1 f8 03             sar    $0x3,%rax
    0.00 :	  7a1a39:       4c 0f af d1             imul   %rcx,%r10
    0.00 :	  7a1a3d:       48 0f af c1             imul   %rcx,%rax
    0.00 :	  7a1a41:       4c 39 d0                cmp    %r10,%rax
    0.00 :	  7a1a44:       49 0f 4f c2             cmovg  %r10,%rax
         :	        vecswap(a, pb - r, r);
    0.00 :	  7a1a48:       85 c0                   test   %eax,%eax
    0.00 :	  7a1a4a:       7e 61                   jle    7a1aad <qsort_ssup+0x1bd>
    0.00 :	  7a1a4c:       4c 63 d8                movslq %eax,%r11
    0.00 :	  7a1a4f:       4d 89 f9                mov    %r15,%r9
    0.00 :	  7a1a52:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7a1a55:       4b 8d 04 5b             lea    (%r11,%r11,2),%rax
    0.00 :	  7a1a59:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  7a1a5d:       49 29 c1                sub    %rax,%r9
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
         :	                *a++ = *b;
    0.00 :	  7a1a60:       4b 8b 04 01             mov    (%r9,%r8,1),%rax
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  7a1a64:       4b 8b 3c 06             mov    (%r14,%r8,1),%rdi
    0.00 :	  7a1a68:       43 0f b6 4c 06 10       movzbl 0x10(%r14,%r8,1),%ecx
    0.00 :	  7a1a6e:       43 8b 54 06 14          mov    0x14(%r14,%r8,1),%edx
    0.00 :	  7a1a73:       4b 8b 74 06 08          mov    0x8(%r14,%r8,1),%rsi
         :	                *a++ = *b;
    0.00 :	  7a1a78:       4b 89 04 06             mov    %rax,(%r14,%r8,1)
    0.00 :	  7a1a7c:       4b 8b 44 01 08          mov    0x8(%r9,%r8,1),%rax
    0.00 :	  7a1a81:       4b 89 44 06 08          mov    %rax,0x8(%r14,%r8,1)
    0.00 :	  7a1a86:       4b 8b 44 01 10          mov    0x10(%r9,%r8,1),%rax
    0.00 :	  7a1a8b:       4b 89 44 06 10          mov    %rax,0x10(%r14,%r8,1)
         :	                *b++ = t;
    0.00 :	  7a1a90:       43 89 54 01 14          mov    %edx,0x14(%r9,%r8,1)
    0.00 :	  7a1a95:       43 88 4c 01 10          mov    %cl,0x10(%r9,%r8,1)
    0.00 :	  7a1a9a:       4b 89 74 01 08          mov    %rsi,0x8(%r9,%r8,1)
    0.00 :	  7a1a9f:       4b 89 3c 01             mov    %rdi,(%r9,%r8,1)
         :	        } while (--n > 0);
    0.00 :	  7a1aa3:       49 83 c0 18             add    $0x18,%r8
    0.00 :	  7a1aa7:       49 83 eb 01             sub    $0x1,%r11
    0.00 :	  7a1aab:       75 b3                   jne    7a1a60 <qsort_ssup+0x170>
         :	                pc--;
         :	        }
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
         :	        vecswap(a, pb - r, r);
         :	        r = Min(pd - pc, pn - pd - 1);
    0.00 :	  7a1aad:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  7a1ab0:       48 b8 ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rax
    0.00 :	  7a1ab7:       aa aa aa 
    0.00 :	  7a1aba:       48 ba ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rdx
    0.00 :	  7a1ac1:       aa aa aa 
    0.00 :	  7a1ac4:       4c 29 e3                sub    %r12,%rbx
    0.00 :	  7a1ac7:       48 c1 fb 03             sar    $0x3,%rbx
    0.00 :	  7a1acb:       48 0f af d8             imul   %rax,%rbx
    0.00 :	  7a1acf:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  7a1ad3:       4c 29 e8                sub    %r13,%rax
    0.00 :	  7a1ad6:       48 c1 f8 03             sar    $0x3,%rax
    0.00 :	  7a1ada:       48 0f af c2             imul   %rdx,%rax
    0.00 :	  7a1ade:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  7a1ae2:       48 39 d8                cmp    %rbx,%rax
    0.00 :	  7a1ae5:       48 0f 4f c3             cmovg  %rbx,%rax
         :	        vecswap(pb, pn - r, r);
    0.00 :	  7a1ae9:       85 c0                   test   %eax,%eax
    0.00 :	  7a1aeb:       7e 68                   jle    7a1b55 <qsort_ssup+0x265>
    0.00 :	  7a1aed:       4c 63 d8                movslq %eax,%r11
    0.00 :	  7a1af0:       4c 8b 4d b0             mov    -0x50(%rbp),%r9
    0.00 :	  7a1af4:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7a1af7:       4b 8d 04 5b             lea    (%r11,%r11,2),%rax
    0.00 :	  7a1afb:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  7a1aff:       49 29 c1                sub    %rax,%r9
    0.00 :	  7a1b02:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
         :	                *a++ = *b;
    0.00 :	  7a1b08:       4b 8b 04 01             mov    (%r9,%r8,1),%rax
         :	static void
         :	swapfunc(SortTuple *a, SortTuple *b, size_t n)
         :	{
         :	        do
         :	        {
         :	                SortTuple       t = *a;
    0.00 :	  7a1b0c:       4b 8b 3c 07             mov    (%r15,%r8,1),%rdi
    0.00 :	  7a1b10:       43 0f b6 4c 07 10       movzbl 0x10(%r15,%r8,1),%ecx
    0.00 :	  7a1b16:       43 8b 54 07 14          mov    0x14(%r15,%r8,1),%edx
    0.00 :	  7a1b1b:       4b 8b 74 07 08          mov    0x8(%r15,%r8,1),%rsi
         :	                *a++ = *b;
    0.00 :	  7a1b20:       4b 89 04 07             mov    %rax,(%r15,%r8,1)
    0.00 :	  7a1b24:       4b 8b 44 01 08          mov    0x8(%r9,%r8,1),%rax
    0.00 :	  7a1b29:       4b 89 44 07 08          mov    %rax,0x8(%r15,%r8,1)
    0.00 :	  7a1b2e:       4b 8b 44 01 10          mov    0x10(%r9,%r8,1),%rax
    0.00 :	  7a1b33:       4b 89 44 07 10          mov    %rax,0x10(%r15,%r8,1)
         :	                *b++ = t;
    0.00 :	  7a1b38:       43 89 54 01 14          mov    %edx,0x14(%r9,%r8,1)
    0.00 :	  7a1b3d:       43 88 4c 01 10          mov    %cl,0x10(%r9,%r8,1)
    0.00 :	  7a1b42:       4b 89 74 01 08          mov    %rsi,0x8(%r9,%r8,1)
    0.00 :	  7a1b47:       4b 89 3c 01             mov    %rdi,(%r9,%r8,1)
         :	        } while (--n > 0);
    0.00 :	  7a1b4b:       49 83 c0 18             add    $0x18,%r8
    0.00 :	  7a1b4f:       49 83 eb 01             sub    $0x1,%r11
    0.00 :	  7a1b53:       75 b3                   jne    7a1b08 <qsort_ssup+0x218>
         :	        pn = a + n;
         :	        r = Min(pa - a, pb - pa);
         :	        vecswap(a, pb - r, r);
         :	        r = Min(pd - pc, pn - pd - 1);
         :	        vecswap(pb, pn - r, r);
         :	        if ((r = pb - pa) > 1)
    0.00 :	  7a1b55:       41 83 fa 01             cmp    $0x1,%r10d
    0.00 :	  7a1b59:       7e 0f                   jle    7a1b6a <qsort_ssup+0x27a>
         :	                qsort_ssup(a, r, ssup);
    0.00 :	  7a1b5b:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1b5f:       49 63 f2                movslq %r10d,%rsi
    0.00 :	  7a1b62:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7a1b65:       e8 86 fd ff ff          callq  7a18f0 <qsort_ssup>
         :	        if ((r = pd - pc) > 1)
    0.00 :	  7a1b6a:       83 fb 01                cmp    $0x1,%ebx
    0.00 :	  7a1b6d:       0f 8e d4 00 00 00       jle    7a1c47 <qsort_ssup+0x357>
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
    0.00 :	  7a1b73:       4c 63 eb                movslq %ebx,%r13
    0.00 :	  7a1b76:       4c 8b 75 b0             mov    -0x50(%rbp),%r14
    0.00 :	  7a1b7a:       4b 8d 44 6d 00          lea    0x0(%r13,%r13,2),%rax
    0.00 :	  7a1b7f:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  7a1b83:       49 29 c6                sub    %rax,%r14
         :	        int                     d,
         :	                                r,
         :	                                presorted;
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1b86:       0f b6 05 03 85 41 00    movzbl 0x418503(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  7a1b8d:       84 c0                   test   %al,%al
    0.00 :	  7a1b8f:       0f 84 85 fd ff ff       je     7a191a <qsort_ssup+0x2a>
    0.00 :	  7a1b95:       e8 06 a7 ef ff          callq  69c2a0 <ProcessInterrupts>
         :	        if (n < 7)
    0.00 :	  7a1b9a:       49 83 fd 06             cmp    $0x6,%r13
    0.00 :	  7a1b9e:       0f 87 80 fd ff ff       ja     7a1924 <qsort_ssup+0x34>
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  7a1ba4:       4b 8d 44 6d 00          lea    0x0(%r13,%r13,2),%rax
    0.00 :	  7a1ba9:       4d 8d 66 18             lea    0x18(%r14),%r12
    0.00 :	  7a1bad:       4d 8d 2c c6             lea    (%r14,%rax,8),%r13
    0.00 :	  7a1bb1:       4c 89 e3                mov    %r12,%rbx
    0.00 :	  7a1bb4:       4d 39 ec                cmp    %r13,%r12
    0.00 :	  7a1bb7:       72 1c                   jb     7a1bd5 <qsort_ssup+0x2e5>
    0.00 :	  7a1bb9:       e9 89 00 00 00          jmpq   7a1c47 <qsort_ssup+0x357>
    0.00 :	  7a1bbe:       66 90                   xchg   %ax,%ax
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
    0.00 :	  7a1bc0:       45 84 c0                test   %r8b,%r8b
    0.00 :	  7a1bc3:       0f 84 07 04 00 00       je     7a1fd0 <qsort_ssup+0x6e0>
    0.00 :	  7a1bc9:       49 83 c4 18             add    $0x18,%r12
    0.00 :	  7a1bcd:       4d 39 ec                cmp    %r13,%r12
    0.00 :	  7a1bd0:       4c 89 e3                mov    %r12,%rbx
    0.00 :	  7a1bd3:       73 72                   jae    7a1c47 <qsort_ssup+0x357>
         :	                        for (pl = pm; pl > a && cmp_ssup(pl - 1, pl, ssup) > 0; pl--)
    0.00 :	  7a1bd5:       4d 39 f4                cmp    %r14,%r12
    0.00 :	  7a1bd8:       76 ef                   jbe    7a1bc9 <qsort_ssup+0x2d9>
    0.00 :	  7a1bda:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a1be0:       44 0f b6 43 10          movzbl 0x10(%rbx),%r8d
    0.00 :	  7a1be5:       48 8b 73 08             mov    0x8(%rbx),%rsi
    0.00 :	  7a1be9:       48 83 eb 18             sub    $0x18,%rbx
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a1bed:       80 7b 10 00             cmpb   $0x0,0x10(%rbx)
    0.00 :	  7a1bf1:       48 8b 7b 08             mov    0x8(%rbx),%rdi
    0.00 :	  7a1bf5:       75 c9                   jne    7a1bc0 <qsort_ssup+0x2d0>
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
    0.00 :	  7a1bf7:       45 84 c0                test   %r8b,%r8b
    0.00 :	  7a1bfa:       0f 84 a4 03 00 00       je     7a1fa4 <qsort_ssup+0x6b4>
         :	        {
         :	                if (ssup->ssup_nulls_first)
    0.00 :	  7a1c00:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1c04:       80 7a 0d 00             cmpb   $0x0,0xd(%rdx)
    0.00 :	  7a1c08:       74 bf                   je     7a1bc9 <qsort_ssup+0x2d9>
         :	                                swap(pl, pl - 1);
    0.00 :	  7a1c0a:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  7a1c0d:       48 8b 4b 18             mov    0x18(%rbx),%rcx
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
         :	                        for (pl = pm; pl > a && cmp_ssup(pl - 1, pl, ssup) > 0; pl--)
    0.00 :	  7a1c11:       4c 39 f3                cmp    %r14,%rbx
         :	                                swap(pl, pl - 1);
    0.00 :	  7a1c14:       8b 53 2c                mov    0x2c(%rbx),%edx
    0.00 :	  7a1c17:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	  7a1c1b:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7a1c1f:       48 89 0b                mov    %rcx,(%rbx)
    0.00 :	  7a1c22:       48 89 73 08             mov    %rsi,0x8(%rbx)
    0.00 :	  7a1c26:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  7a1c2a:       48 8b 43 10             mov    0x10(%rbx),%rax
    0.00 :	  7a1c2e:       89 53 14                mov    %edx,0x14(%rbx)
    0.00 :	  7a1c31:       44 88 43 10             mov    %r8b,0x10(%rbx)
    0.00 :	  7a1c35:       48 89 43 28             mov    %rax,0x28(%rbx)
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
         :	                        for (pl = pm; pl > a && cmp_ssup(pl - 1, pl, ssup) > 0; pl--)
    0.00 :	  7a1c39:       77 a5                   ja     7a1be0 <qsort_ssup+0x2f0>
         :
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
    0.00 :	  7a1c3b:       49 83 c4 18             add    $0x18,%r12
    0.00 :	  7a1c3f:       4d 39 ec                cmp    %r13,%r12
    0.00 :	  7a1c42:       4c 89 e3                mov    %r12,%rbx
    0.00 :	  7a1c45:       72 8e                   jb     7a1bd5 <qsort_ssup+0x2e5>
         :	                a = pn - r;
         :	                n = r;
         :	                goto loop;
         :	        }
         :	/*              qsort_ssup(pn - r, r, ssup);*/
         :	}
    0.00 :	  7a1c47:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  7a1c4b:       5b                      pop    %rbx
    0.00 :	  7a1c4c:       41 5c                   pop    %r12
    0.00 :	  7a1c4e:       41 5d                   pop    %r13
    0.00 :	  7a1c50:       41 5e                   pop    %r14
    0.00 :	  7a1c52:       41 5f                   pop    %r15
    0.00 :	  7a1c54:       c9                      leaveq 
    0.00 :	  7a1c55:       c3                      retq   
    0.00 :	  7a1c56:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a1c5d:       00 00 00 
         :	                return;
         :	        }
         :	        presorted = 1;
         :	        for (pm = a + 1; pm < a + n; pm++)
         :	        {
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1c60:       e8 3b a6 ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  7a1c65:       e9 03 fd ff ff          jmpq   7a196d <qsort_ssup+0x7d>
    0.00 :	  7a1c6a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a1c70:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1c74:       ff 52 18                callq  *0x18(%rdx)
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1c77:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1c7b:       89 c2                   mov    %eax,%edx
    0.00 :	  7a1c7d:       f7 da                   neg    %edx
    0.00 :	  7a1c7f:       80 79 0c 00             cmpb   $0x0,0xc(%rcx)
    0.00 :	  7a1c83:       0f 45 c2                cmovne %edx,%eax
         :	                if (cmp_ssup(pm - 1, pm, ssup) > 0)
    0.00 :	  7a1c86:       85 c0                   test   %eax,%eax
    0.00 :	  7a1c88:       0f 8e c2 fc ff ff       jle    7a1950 <qsort_ssup+0x60>
    0.00 :	  7a1c8e:       e9 fe fc ff ff          jmpq   7a1991 <qsort_ssup+0xa1>
    0.00 :	  7a1c93:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        swap(a, pm);
         :	        pa = pb = a + 1;
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_ssup(pb, a, ssup)) <= 0)
    0.00 :	  7a1c98:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  7a1c9c:       41 0f b6 46 10          movzbl 0x10(%r14),%eax
    0.00 :	  7a1ca1:       49 8b 76 08             mov    0x8(%r14),%rsi
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a1ca5:       80 7a f8 00             cmpb   $0x0,-0x8(%rdx)
    0.00 :	  7a1ca9:       48 8b 7a f0             mov    -0x10(%rdx),%rdi
    0.00 :	  7a1cad:       0f 84 8d 00 00 00       je     7a1d40 <qsort_ssup+0x450>
         :	        {
         :	                if (isNull2)
    0.00 :	  7a1cb3:       31 db                   xor    %ebx,%ebx
    0.00 :	  7a1cb5:       84 c0                   test   %al,%al
    0.00 :	  7a1cb7:       0f 84 cf 02 00 00       je     7a1f8c <qsort_ssup+0x69c>
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1cbd:       0f b6 05 cc 83 41 00    movzbl 0x4183cc(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  7a1cc4:       84 c0                   test   %al,%al
    0.00 :	  7a1cc6:       0f 85 00 02 00 00       jne    7a1ecc <qsort_ssup+0x5dc>
         :	                        if (r == 0)
    0.00 :	  7a1ccc:       85 db                   test   %ebx,%ebx
    0.00 :	  7a1cce:       75 60                   jne    7a1d30 <qsort_ssup+0x440>
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  7a1cd0:       48 8b 4d b8             mov    -0x48(%rbp),%rcx
    0.00 :	  7a1cd4:       48 89 cb                mov    %rcx,%rbx
    0.00 :	  7a1cd7:       8b 51 14                mov    0x14(%rcx),%edx
    0.00 :	  7a1cda:       0f b6 49 10             movzbl 0x10(%rcx),%ecx
    0.00 :	  7a1cde:       48 8b 73 08             mov    0x8(%rbx),%rsi
    0.00 :	  7a1ce2:       48 8b 3b                mov    (%rbx),%rdi
    0.00 :	  7a1ce5:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  7a1ce9:       48 8b 43 e8             mov    -0x18(%rbx),%rax
    0.00 :	  7a1ced:       48 8b 5d b8             mov    -0x48(%rbp),%rbx
    0.00 :	  7a1cf1:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  7a1cf4:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  7a1cf8:       48 8b 43 f0             mov    -0x10(%rbx),%rax
    0.00 :	  7a1cfc:       48 8b 5d b8             mov    -0x48(%rbp),%rbx
    0.00 :	  7a1d00:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  7a1d04:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  7a1d08:       48 8b 43 f8             mov    -0x8(%rbx),%rax
    0.00 :	  7a1d0c:       48 8b 5d b8             mov    -0x48(%rbp),%rbx
    0.00 :	  7a1d10:       48 89 43 10             mov    %rax,0x10(%rbx)
    0.00 :	  7a1d14:       48 8b 45 c0             mov    -0x40(%rbp),%rax
         :	                                pa++;
    0.00 :	  7a1d18:       48 83 c3 18             add    $0x18,%rbx
         :	                while (pb <= pc && (r = cmp_ssup(pb, a, ssup)) <= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        if (r == 0)
         :	                        {
         :	                                swap(pa, pb);
    0.00 :	  7a1d1c:       89 50 fc                mov    %edx,-0x4(%rax)
    0.00 :	  7a1d1f:       88 48 f8                mov    %cl,-0x8(%rax)
    0.00 :	  7a1d22:       48 89 70 f0             mov    %rsi,-0x10(%rax)
    0.00 :	  7a1d26:       48 89 78 e8             mov    %rdi,-0x18(%rax)
         :	                                pa++;
    0.00 :	  7a1d2a:       48 89 5d b8             mov    %rbx,-0x48(%rbp)
    0.00 :	  7a1d2e:       66 90                   xchg   %ax,%ax
    0.00 :	  7a1d30:       48 83 45 c0 18          addq   $0x18,-0x40(%rbp)
    0.00 :	  7a1d35:       e9 ce fc ff ff          jmpq   7a1a08 <qsort_ssup+0x118>
    0.00 :	  7a1d3a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:134
   25.00 :	  7a1d40:       84 c0                   test   %al,%al
    0.00 :	  7a1d42:       0f 84 57 01 00 00       je     7a1e9f <qsort_ssup+0x5af>
         :	        {
         :	                if (ssup->ssup_nulls_first)
    0.00 :	  7a1d48:       48 8b 5d a8             mov    -0x58(%rbp),%rbx
    0.00 :	  7a1d4c:       80 7b 0d 00             cmpb   $0x0,0xd(%rbx)
    0.00 :	  7a1d50:       0f 85 7f 00 00 00       jne    7a1dd5 <qsort_ssup+0x4e5>
    0.00 :	  7a1d56:       e9 3f 02 00 00          jmpq   7a1f9a <qsort_ssup+0x6aa>
    0.00 :	  7a1d5b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
    0.00 :	  7a1d60:       31 db                   xor    %ebx,%ebx
    0.00 :	  7a1d62:       84 c0                   test   %al,%al
    0.00 :	  7a1d64:       0f 84 26 01 00 00       je     7a1e90 <qsort_ssup+0x5a0>
         :	                        }
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_ssup(pc, a, ssup)) >= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1d6a:       0f b6 05 1f 83 41 00    movzbl 0x41831f(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  7a1d71:       84 c0                   test   %al,%al
    0.00 :	  7a1d73:       0f 85 8f 00 00 00       jne    7a1e08 <qsort_ssup+0x518>
         :	                        if (r == 0)
    0.00 :	  7a1d79:       85 db                   test   %ebx,%ebx
    0.00 :	  7a1d7b:       75 42                   jne    7a1dbf <qsort_ssup+0x4cf>
         :	                        {
         :	                                swap(pc, pd);
    0.00 :	  7a1d7d:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  7a1d81:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  7a1d85:       41 0f b6 4c 24 10       movzbl 0x10(%r12),%ecx
    0.00 :	  7a1d8b:       41 8b 54 24 14          mov    0x14(%r12),%edx
    0.00 :	  7a1d90:       49 8b 74 24 08          mov    0x8(%r12),%rsi
    0.00 :	  7a1d95:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	  7a1d99:       49 8b 45 08             mov    0x8(%r13),%rax
    0.00 :	  7a1d9d:       49 89 44 24 08          mov    %rax,0x8(%r12)
    0.00 :	  7a1da2:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  7a1da6:       49 89 44 24 10          mov    %rax,0x10(%r12)
    0.00 :	  7a1dab:       41 89 55 14             mov    %edx,0x14(%r13)
    0.00 :	  7a1daf:       41 88 4d 10             mov    %cl,0x10(%r13)
    0.00 :	  7a1db3:       49 89 75 08             mov    %rsi,0x8(%r13)
    0.00 :	  7a1db7:       49 89 7d 00             mov    %rdi,0x0(%r13)
         :	                                pd--;
    0.00 :	  7a1dbb:       49 83 ed 18             sub    $0x18,%r13
         :	                        }
         :	                        pc--;
    0.00 :	  7a1dbf:       49 83 ec 18             sub    $0x18,%r12
         :	                                swap(pa, pb);
         :	                                pa++;
         :	                        }
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_ssup(pc, a, ssup)) >= 0)
    0.00 :	  7a1dc3:       4d 39 fc                cmp    %r15,%r12
    0.00 :	  7a1dc6:       0f 82 4d fc ff ff       jb     7a1a19 <qsort_ssup+0x129>
    0.00 :	  7a1dcc:       41 0f b6 46 10          movzbl 0x10(%r14),%eax
    0.00 :	  7a1dd1:       49 8b 76 08             mov    0x8(%r14),%rsi
         :	                                        Datum datum2, bool isNull2,
         :	                                        SortSupport ssup)
         :	{
         :	        int                     compare;
         :
         :	        if (isNull1)
    0.00 :	  7a1dd5:       41 80 7c 24 10 00       cmpb   $0x0,0x10(%r12)
    0.00 :	  7a1ddb:       49 8b 7c 24 08          mov    0x8(%r12),%rdi
    0.00 :	  7a1de0:       0f 85 7a ff ff ff       jne    7a1d60 <qsort_ssup+0x470>
         :	                else if (ssup->ssup_nulls_first)
         :	                        compare = -1;           /* NULL "<" NOT_NULL */
         :	                else
         :	                        compare = 1;            /* NULL ">" NOT_NULL */
         :	        }
         :	        else if (isNull2)
    0.00 :	  7a1de6:       84 c0                   test   %al,%al
    0.00 :	  7a1de8:       74 2e                   je     7a1e18 <qsort_ssup+0x528>
         :	        {
         :	                if (ssup->ssup_nulls_first)
    0.00 :	  7a1dea:       48 8b 5d a8             mov    -0x58(%rbp),%rbx
    0.00 :	  7a1dee:       80 7b 0d 00             cmpb   $0x0,0xd(%rbx)
    0.00 :	  7a1df2:       74 46                   je     7a1e3a <qsort_ssup+0x54a>
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1df4:       0f b6 05 95 82 41 00    movzbl 0x418295(%rip),%eax        # bba090 <InterruptPending>
         :	        if ((r = pd - pc) > 1)
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
         :	                n = r;
         :	                goto loop;
    0.00 :	  7a1dfb:       bb 01 00 00 00          mov    $0x1,%ebx
         :	                        }
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_ssup(pc, a, ssup)) >= 0)
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1e00:       84 c0                   test   %al,%al
    0.00 :	  7a1e02:       0f 84 71 ff ff ff       je     7a1d79 <qsort_ssup+0x489>
    0.00 :	  7a1e08:       e8 93 a4 ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  7a1e0d:       e9 67 ff ff ff          jmpq   7a1d79 <qsort_ssup+0x489>
    0.00 :	  7a1e12:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a1e18:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1e1c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a1e20:       ff 52 18                callq  *0x18(%rdx)
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1e23:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a1e27:       89 c3                   mov    %eax,%ebx
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1e29:       f7 d8                   neg    %eax
    0.00 :	  7a1e2b:       80 7a 0c 00             cmpb   $0x0,0xc(%rdx)
    0.00 :	  7a1e2f:       0f 45 d8                cmovne %eax,%ebx
         :	                                swap(pa, pb);
         :	                                pa++;
         :	                        }
         :	                        pb++;
         :	                }
         :	                while (pb <= pc && (r = cmp_ssup(pc, a, ssup)) >= 0)
    0.00 :	  7a1e32:       85 db                   test   %ebx,%ebx
    0.00 :	  7a1e34:       0f 89 30 ff ff ff       jns    7a1d6a <qsort_ssup+0x47a>
         :	                        }
         :	                        pc--;
         :	                }
         :	                if (pb > pc)
         :	                        break;
         :	                swap(pb, pc);
    0.00 :	  7a1e3a:       48 8b 4d c0             mov    -0x40(%rbp),%rcx
    0.00 :	  7a1e3e:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	  7a1e42:       48 89 cb                mov    %rcx,%rbx
    0.00 :	  7a1e45:       8b 51 fc                mov    -0x4(%rcx),%edx
    0.00 :	  7a1e48:       0f b6 49 f8             movzbl -0x8(%rcx),%ecx
    0.00 :	  7a1e4c:       48 8b 7b e8             mov    -0x18(%rbx),%rdi
    0.00 :	  7a1e50:       48 89 43 e8             mov    %rax,-0x18(%rbx)
    0.00 :	  7a1e54:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  7a1e59:       48 8b 73 f0             mov    -0x10(%rbx),%rsi
    0.00 :	  7a1e5d:       48 89 43 f0             mov    %rax,-0x10(%rbx)
    0.00 :	  7a1e61:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  7a1e66:       48 89 43 f8             mov    %rax,-0x8(%rbx)
    0.00 :	  7a1e6a:       41 89 54 24 14          mov    %edx,0x14(%r12)
    0.00 :	  7a1e6f:       41 88 4c 24 10          mov    %cl,0x10(%r12)
    0.00 :	  7a1e74:       49 89 74 24 08          mov    %rsi,0x8(%r12)
    0.00 :	  7a1e79:       49 89 3c 24             mov    %rdi,(%r12)
         :	                pb++;
         :	                pc--;
    0.00 :	  7a1e7d:       49 83 ec 18             sub    $0x18,%r12
         :	        }
    0.00 :	  7a1e81:       e9 aa fe ff ff          jmpq   7a1d30 <qsort_ssup+0x440>
    0.00 :	  7a1e86:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a1e8d:       00 00 00 
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
         :	                        compare = 0;            /* NULL "=" NULL */
         :	                else if (ssup->ssup_nulls_first)
    0.00 :	  7a1e90:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1e94:       80 79 0d 00             cmpb   $0x0,0xd(%rcx)
    0.00 :	  7a1e98:       75 a0                   jne    7a1e3a <qsort_ssup+0x54a>
    0.00 :	  7a1e9a:       e9 55 ff ff ff          jmpq   7a1df4 <qsort_ssup+0x504>
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a1e9f:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1ea3:       ff 52 18                callq  *0x18(%rdx)
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1ea6:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:143
   25.00 :	  7a1eaa:       89 c3                   mov    %eax,%ebx
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1eac:       f7 d8                   neg    %eax
    0.00 :	  7a1eae:       80 7a 0c 00             cmpb   $0x0,0xc(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/../../../../src/include/utils/sortsupport.h:145
   50.00 :	  7a1eb2:       0f 45 d8                cmovne %eax,%ebx
         :	        swap(a, pm);
         :	        pa = pb = a + 1;
         :	        pc = pd = a + (n - 1);
         :	        for (;;)
         :	        {
         :	                while (pb <= pc && (r = cmp_ssup(pb, a, ssup)) <= 0)
    0.00 :	  7a1eb5:       85 db                   test   %ebx,%ebx
    0.00 :	  7a1eb7:       0f 8f 0f ff ff ff       jg     7a1dcc <qsort_ssup+0x4dc>
         :	                {
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  7a1ebd:       0f b6 05 cc 81 41 00    movzbl 0x4181cc(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  7a1ec4:       84 c0                   test   %al,%al
    0.00 :	  7a1ec6:       0f 84 00 fe ff ff       je     7a1ccc <qsort_ssup+0x3dc>
    0.00 :	  7a1ecc:       e8 cf a3 ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  7a1ed1:       e9 f6 fd ff ff          jmpq   7a1ccc <qsort_ssup+0x3dc>
         :	                return;
         :	        pm = a + (n / 2);
         :	        if (n > 7)
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
    0.00 :	  7a1ed6:       4b 8d 44 6d fd          lea    -0x3(%r13,%r13,2),%rax
         :	                if (n > 40)
    0.00 :	  7a1edb:       49 83 fd 28             cmp    $0x28,%r13
    0.00 :	  7a1edf:       4d 89 f0                mov    %r14,%r8
         :	                return;
         :	        pm = a + (n / 2);
         :	        if (n > 7)
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
    0.00 :	  7a1ee2:       4d 8d 3c c6             lea    (%r14,%rax,8),%r15
         :	                if (n > 40)
    0.00 :	  7a1ee6:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  7a1ee9:       77 2a                   ja     7a1f15 <qsort_ssup+0x625>
         :	                        d = (n / 8);
         :	                        pl = med3_ssup(pl, pl + d, pl + 2 * d, ssup);
         :	                        pm = med3_ssup(pm - d, pm, pm + d, ssup);
         :	                        pn = med3_ssup(pn - 2 * d, pn - d, pn, ssup);
         :	                }
         :	                pm = med3_ssup(pl, pm, pn, ssup);
    0.00 :	  7a1eeb:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1eef:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  7a1ef2:       4c 89 c7                mov    %r8,%rdi
    0.00 :	  7a1ef5:       e8 86 f7 ff ff          callq  7a1680 <med3_ssup>
    0.00 :	  7a1efa:       49 89 c4                mov    %rax,%r12
    0.00 :	  7a1efd:       e9 ae fa ff ff          jmpq   7a19b0 <qsort_ssup+0xc0>
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
         :	                        compare = 0;            /* NULL "=" NULL */
         :	                else if (ssup->ssup_nulls_first)
    0.00 :	  7a1f02:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  7a1f06:       80 78 0d 00             cmpb   $0x0,0xd(%rax)
    0.00 :	  7a1f0a:       0f 85 40 fa ff ff       jne    7a1950 <qsort_ssup+0x60>
    0.00 :	  7a1f10:       e9 7c fa ff ff          jmpq   7a1991 <qsort_ssup+0xa1>
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
    0.00 :	  7a1f15:       4c 89 e8                mov    %r13,%rax
         :	                        pl = med3_ssup(pl, pl + d, pl + 2 * d, ssup);
    0.00 :	  7a1f18:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1f1c:       4c 89 f7                mov    %r14,%rdi
         :	        {
         :	                pl = a;
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
    0.00 :	  7a1f1f:       48 c1 e8 03             shr    $0x3,%rax
         :	                        pl = med3_ssup(pl, pl + d, pl + 2 * d, ssup);
    0.00 :	  7a1f23:       8d 1c 00                lea    (%rax,%rax,1),%ebx
    0.00 :	  7a1f26:       48 98                   cltq   
    0.00 :	  7a1f28:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  7a1f2c:       48 63 db                movslq %ebx,%rbx
    0.00 :	  7a1f2f:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  7a1f33:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  7a1f3a:       00 
    0.00 :	  7a1f3b:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  7a1f3f:       4b 8d 34 2e             lea    (%r14,%r13,1),%rsi
    0.00 :	  7a1f43:       49 8d 14 1e             lea    (%r14,%rbx,1),%rdx
    0.00 :	  7a1f47:       e8 34 f7 ff ff          callq  7a1680 <med3_ssup>
         :	                        pm = med3_ssup(pm - d, pm, pm + d, ssup);
    0.00 :	  7a1f4c:       4b 8d 14 2c             lea    (%r12,%r13,1),%rdx
    0.00 :	  7a1f50:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1f54:       49 f7 dd                neg    %r13
    0.00 :	  7a1f57:       4b 8d 3c 2c             lea    (%r12,%r13,1),%rdi
    0.00 :	  7a1f5b:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  7a1f5e:       48 89 45 a0             mov    %rax,-0x60(%rbp)
    0.00 :	  7a1f62:       e8 19 f7 ff ff          callq  7a1680 <med3_ssup>
         :	                        pn = med3_ssup(pn - 2 * d, pn - d, pn, ssup);
    0.00 :	  7a1f67:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1f6b:       4b 8d 34 2f             lea    (%r15,%r13,1),%rsi
    0.00 :	  7a1f6f:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  7a1f72:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  7a1f75:       48 29 df                sub    %rbx,%rdi
         :	                pn = a + (n - 1);
         :	                if (n > 40)
         :	                {
         :	                        d = (n / 8);
         :	                        pl = med3_ssup(pl, pl + d, pl + 2 * d, ssup);
         :	                        pm = med3_ssup(pm - d, pm, pm + d, ssup);
    0.00 :	  7a1f78:       49 89 c4                mov    %rax,%r12
         :	                        pn = med3_ssup(pn - 2 * d, pn - d, pn, ssup);
    0.00 :	  7a1f7b:       e8 00 f7 ff ff          callq  7a1680 <med3_ssup>
    0.00 :	  7a1f80:       4c 8b 45 a0             mov    -0x60(%rbp),%r8
    0.00 :	  7a1f84:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7a1f87:       e9 5f ff ff ff          jmpq   7a1eeb <qsort_ssup+0x5fb>
    0.00 :	  7a1f8c:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1f90:       80 79 0d 00             cmpb   $0x0,0xd(%rcx)
    0.00 :	  7a1f94:       0f 84 3b fe ff ff       je     7a1dd5 <qsort_ssup+0x4e5>
         :	        if ((r = pd - pc) > 1)
         :	        {
         :	                /* Iterate rather than recurse to save stack space */
         :	                a = pn - r;
         :	                n = r;
         :	                goto loop;
    0.00 :	  7a1f9a:       bb ff ff ff ff          mov    $0xffffffff,%ebx
    0.00 :	  7a1f9f:       e9 19 fd ff ff          jmpq   7a1cbd <qsort_ssup+0x3cd>
         :	                else
         :	                        compare = -1;           /* NOT_NULL "<" NULL */
         :	        }
         :	        else
         :	        {
         :	                compare = (*ssup->comparator) (datum1, datum2, ssup);
    0.00 :	  7a1fa4:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  7a1fa8:       ff 52 18                callq  *0x18(%rdx)
         :	                if (ssup->ssup_reverse)
         :	                        compare = -compare;
    0.00 :	  7a1fab:       48 8b 4d a8             mov    -0x58(%rbp),%rcx
    0.00 :	  7a1faf:       89 c2                   mov    %eax,%edx
    0.00 :	  7a1fb1:       f7 da                   neg    %edx
    0.00 :	  7a1fb3:       80 79 0c 00             cmpb   $0x0,0xc(%rcx)
    0.00 :	  7a1fb7:       0f 45 c2                cmovne %edx,%eax
         :	loop:
         :	        CHECK_FOR_INTERRUPTS();
         :	        if (n < 7)
         :	        {
         :	                for (pm = a + 1; pm < a + n; pm++)
         :	                        for (pl = pm; pl > a && cmp_ssup(pl - 1, pl, ssup) > 0; pl--)
    0.00 :	  7a1fba:       85 c0                   test   %eax,%eax
    0.00 :	  7a1fbc:       0f 8e 07 fc ff ff       jle    7a1bc9 <qsort_ssup+0x2d9>
    0.00 :	  7a1fc2:       44 0f b6 43 28          movzbl 0x28(%rbx),%r8d
    0.00 :	  7a1fc7:       48 8b 73 20             mov    0x20(%rbx),%rsi
    0.00 :	  7a1fcb:       e9 3a fc ff ff          jmpq   7a1c0a <qsort_ssup+0x31a>
         :
         :	        if (isNull1)
         :	        {
         :	                if (isNull2)
         :	                        compare = 0;            /* NULL "=" NULL */
         :	                else if (ssup->ssup_nulls_first)
    0.00 :	  7a1fd0:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  7a1fd4:       80 78 0d 00             cmpb   $0x0,0xd(%rax)
    0.00 :	  7a1fd8:       0f 85 eb fb ff ff       jne    7a1bc9 <qsort_ssup+0x2d9>
    0.00 :	  7a1fde:       66 90                   xchg   %ax,%ax
    0.00 :	  7a1fe0:       e9 25 fc ff ff          jmpq   7a1c0a <qsort_ssup+0x31a>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5600 <XidInMVCCSnapshot>:
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
    0.00 :	  7a5600:       55                      push   %rbp
    0.00 :	  7a5601:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   25.00 :	  7a5604:       41 54                   push   %r12
    0.00 :	  7a5606:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7a5609:       53                      push   %rbx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a560a:       8b 76 08                mov    0x8(%rsi),%esi
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
    0.00 :	  7a560d:       89 fb                   mov    %edi,%ebx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a560f:       e8 cc a9 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5614:       84 c0                   test   %al,%al
    0.00 :	  7a5616:       74 08                   je     7a5620 <XidInMVCCSnapshot+0x20>
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
   25.00 :	  7a5618:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5619:       31 c0                   xor    %eax,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a561b:       41 5c                   pop    %r12
    0.00 :	  7a561d:       c9                      leaveq 
   50.00 :	  7a561e:       c3                      retq   
    0.00 :	  7a561f:       90                      nop
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                return false;
         :	        /* Any xid >= xmax is in-progress */
         :	        if (TransactionIdFollowsOrEquals(xid, snapshot->xmax))
    0.00 :	  7a5620:       41 8b 74 24 0c          mov    0xc(%r12),%esi
    0.00 :	  7a5625:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5627:       e8 44 aa d1 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  7a562c:       84 c0                   test   %al,%al
    0.00 :	  7a562e:       0f 85 7c 00 00 00       jne    7a56b0 <XidInMVCCSnapshot+0xb0>
         :
         :	        /*
         :	         * Snapshot information is stored slightly differently in snapshots taken
         :	         * during recovery.
         :	         */
         :	        if (!snapshot->takenDuringRecovery)
    0.00 :	  7a5634:       41 80 7c 24 29 00       cmpb   $0x0,0x29(%r12)
    0.00 :	  7a563a:       0f 85 80 00 00 00       jne    7a56c0 <XidInMVCCSnapshot+0xc0>
         :	                 * check things is just to compare the given XID against both subxact
         :	                 * XIDs and top-level XIDs.  If the snapshot overflowed, we have to
         :	                 * use pg_subtrans to convert a subxact XID to its parent XID, but
         :	                 * then we need only look at top-level XIDs not subxacts.
         :	                 */
         :	                if (!snapshot->suboverflowed)
    0.00 :	  7a5640:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a5646:       0f 85 b4 00 00 00       jne    7a5700 <XidInMVCCSnapshot+0x100>
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a564c:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a5651:       85 f6                   test   %esi,%esi
    0.00 :	  7a5653:       7e 25                   jle    7a567a <XidInMVCCSnapshot+0x7a>
         :	                        {
         :	                                if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a5655:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a565a:       31 d2                   xor    %edx,%edx
    0.00 :	  7a565c:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a565e:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a5661:       75 10                   jne    7a5673 <XidInMVCCSnapshot+0x73>
    0.00 :	  7a5663:       eb 4b                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5665:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a5668:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a566b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a566f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a5671:       74 3d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                if (!snapshot->suboverflowed)
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5673:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a5676:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a5678:       7c ee                   jl     7a5668 <XidInMVCCSnapshot+0x68>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a567a:       41 8b 74 24 18          mov    0x18(%r12),%esi
    0.00 :	  7a567f:       85 f6                   test   %esi,%esi
    0.00 :	  7a5681:       74 95                   je     7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->xip[i]))
    0.00 :	  7a5683:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  7a5688:       31 d2                   xor    %edx,%edx
    0.00 :	  7a568a:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a568c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a568f:       75 12                   jne    7a56a3 <XidInMVCCSnapshot+0xa3>
    0.00 :	  7a5691:       eb 1d                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5693:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a5698:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a569b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a569f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56a1:       74 0d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a56a3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56a6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56a8:       72 ee                   jb     7a5698 <XidInMVCCSnapshot+0x98>
    0.00 :	  7a56aa:       e9 69 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56af:       90                      nop
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b0:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56b1:       b8 01 00 00 00          mov    $0x1,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b6:       41 5c                   pop    %r12
    0.00 :	  7a56b8:       c9                      leaveq 
    0.00 :	  7a56b9:       c3                      retq   
    0.00 :	  7a56ba:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * far the bigger array, and we mostly don't know which xids are
         :	                 * top-level and which are subxacts. The xip array is empty.
         :	                 *
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
    0.00 :	  7a56c0:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a56c6:       75 60                   jne    7a5728 <XidInMVCCSnapshot+0x128>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56c8:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a56cd:       85 f6                   test   %esi,%esi
    0.00 :	  7a56cf:       0f 8e 43 ff ff ff       jle    7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a56d5:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a56da:       31 d2                   xor    %edx,%edx
    0.00 :	  7a56dc:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a56de:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a56e1:       75 10                   jne    7a56f3 <XidInMVCCSnapshot+0xf3>
    0.00 :	  7a56e3:       eb cb                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a56e5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a56e8:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a56eb:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a56ef:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56f1:       74 bd                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56f3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56f6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56f8:       7c ee                   jl     7a56e8 <XidInMVCCSnapshot+0xe8>
    0.00 :	  7a56fa:       e9 19 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56ff:       90                      nop
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5700:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5702:       e8 e9 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5707:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a570c:       89 c7                   mov    %eax,%edi
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a570e:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5710:       e8 cb a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5715:       84 c0                   test   %al,%al
    0.00 :	  7a5717:       0f 84 5d ff ff ff       je     7a567a <XidInMVCCSnapshot+0x7a>
    0.00 :	  7a571d:       e9 f6 fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a5722:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5728:       89 df                   mov    %ebx,%edi
    0.00 :	  7a572a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5730:       e8 bb 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5735:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a573a:       89 c7                   mov    %eax,%edi
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a573c:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a573e:       e8 9d a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5743:       84 c0                   test   %al,%al
    0.00 :	  7a5745:       74 81                   je     7a56c8 <XidInMVCCSnapshot+0xc8>
    0.00 :	  7a5747:       e9 cc fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:47
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:49
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:48
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004906f0 <hashint4>:
         :	        return hash_uint32((int32) PG_GETARG_INT16(0));
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:47
   33.33 :	  4906f0:       55                      push   %rbp
         :	        return hash_uint32(PG_GETARG_INT32(0));
    0.00 :	  4906f1:       48 8b 7f 20             mov    0x20(%rdi),%rdi
         :	        return hash_uint32((int32) PG_GETARG_INT16(0));
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  4906f5:       48 89 e5                mov    %rsp,%rbp
         :	        return hash_uint32(PG_GETARG_INT32(0));
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:49
   33.33 :	  4906f8:       c9                      leaveq 
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
         :	        return hash_uint32(PG_GETARG_INT32(0));
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:48
   33.33 :	  4906f9:       e9 62 ff ff ff          jmpq   490660 <hash_uint32>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:60
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:87
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:111
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005a9440 <execTuplesMatch>:
         :	                                TupleTableSlot *slot2,
         :	                                int numCols,
         :	                                AttrNumber *matchColIdx,
         :	                                FmgrInfo *eqfunctions,
         :	                                MemoryContext evalContext)
         :	{
    0.00 :	  5a9440:       55                      push   %rbp
    0.00 :	  5a9441:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5a9444:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:60
   33.33 :	  5a9446:       49 89 cf                mov    %rcx,%r15
    0.00 :	  5a9449:       41 56                   push   %r14
    0.00 :	  5a944b:       41 55                   push   %r13
    0.00 :	  5a944d:       41 54                   push   %r12
    0.00 :	  5a944f:       41 89 d4                mov    %edx,%r12d
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a9452:       45 89 e5                mov    %r12d,%r13d
    0.00 :	  5a9455:       53                      push   %rbx
    0.00 :	  5a9456:       4c 89 cb                mov    %r9,%rbx
    0.00 :	  5a9459:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  5a945d:       48 89 7d b8             mov    %rdi,-0x48(%rbp)
         :	        MemoryContext oldContext;
         :	        bool            result;
         :	        int                     i;
         :
         :	        /* Reset and switch into the temp context. */
         :	        MemoryContextReset(evalContext);
    0.00 :	  5a9461:       4c 89 cf                mov    %r9,%rdi
         :	                                TupleTableSlot *slot2,
         :	                                int numCols,
         :	                                AttrNumber *matchColIdx,
         :	                                FmgrInfo *eqfunctions,
         :	                                MemoryContext evalContext)
         :	{
    0.00 :	  5a9464:       48 89 75 b0             mov    %rsi,-0x50(%rbp)
    0.00 :	  5a9468:       4c 89 45 a8             mov    %r8,-0x58(%rbp)
         :	        MemoryContext oldContext;
         :	        bool            result;
         :	        int                     i;
         :
         :	        /* Reset and switch into the temp context. */
         :	        MemoryContextReset(evalContext);
    0.00 :	  5a946c:       e8 3f f5 1e 00          callq  7989b0 <MemoryContextReset>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5a9471:       48 8b 05 e8 13 61 00    mov    0x6113e8(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a9478:       48 89 1d e1 13 61 00    mov    %rbx,0x6113e1(%rip)        # bba860 <CurrentMemoryContext>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5a947f:       48 89 45 c0             mov    %rax,-0x40(%rbp)
    0.00 :	  5a9483:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	         * comparing at the last field (least significant sort key). That's the
         :	         * most likely to be different if we are dealing with sorted input.
         :	         */
         :	        result = true;
         :
         :	        for (i = numCols; --i >= 0;)
    0.00 :	  5a9488:       41 83 ed 01             sub    $0x1,%r13d
    0.00 :	  5a948c:       78 72                   js     5a9500 <execTuplesMatch+0xc0>
         :	        {
         :	                AttrNumber      att = matchColIdx[i];
    0.00 :	  5a948e:       4d 63 e5                movslq %r13d,%r12
         :	                Datum           attr1,
         :	                                        attr2;
         :	                bool            isNull1,
         :	                                        isNull2;
         :
         :	                attr1 = slot_getattr(slot1, att, &isNull1);
    0.00 :	  5a9491:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5a9495:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5a9499:       43 0f bf 1c 67          movswl (%r15,%r12,2),%ebx
    0.00 :	  5a949e:       89 de                   mov    %ebx,%esi
    0.00 :	  5a94a0:       e8 5b 5f ec ff          callq  46f400 <slot_getattr>
         :
         :	                attr2 = slot_getattr(slot2, att, &isNull2);
    0.00 :	  5a94a5:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  5a94a9:       48 8d 55 d6             lea    -0x2a(%rbp),%rdx
    0.00 :	  5a94ad:       89 de                   mov    %ebx,%esi
         :	                Datum           attr1,
         :	                                        attr2;
         :	                bool            isNull1,
         :	                                        isNull2;
         :
         :	                attr1 = slot_getattr(slot1, att, &isNull1);
    0.00 :	  5a94af:       49 89 c6                mov    %rax,%r14
         :
         :	                attr2 = slot_getattr(slot2, att, &isNull2);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:87
   33.33 :	  5a94b2:       e8 49 5f ec ff          callq  46f400 <slot_getattr>
         :
         :	                if (isNull1 != isNull2)
    0.00 :	  5a94b7:       0f b6 55 d7             movzbl -0x29(%rbp),%edx
    0.00 :	  5a94bb:       3a 55 d6                cmp    -0x2a(%rbp),%dl
    0.00 :	  5a94be:       75 21                   jne    5a94e1 <execTuplesMatch+0xa1>
         :	                {
         :	                        result = false;         /* one null and one not; they aren't equal */
         :	                        break;
         :	                }
         :
         :	                if (isNull1)
    0.00 :	  5a94c0:       84 d2                   test   %dl,%dl
    0.00 :	  5a94c2:       75 c4                   jne    5a9488 <execTuplesMatch+0x48>
         :	                        continue;                       /* both are null, treat as equal */
         :
         :	                /* Apply the type-specific equality function */
         :
         :	                if (!DatumGetBool(FunctionCall2(&eqfunctions[i],
    0.00 :	  5a94c4:       4b 8d 3c 64             lea    (%r12,%r12,2),%rdi
    0.00 :	  5a94c8:       31 f6                   xor    %esi,%esi
    0.00 :	  5a94ca:       48 89 c1                mov    %rax,%rcx
    0.00 :	  5a94cd:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  5a94d0:       48 c1 e7 04             shl    $0x4,%rdi
    0.00 :	  5a94d4:       48 03 7d a8             add    -0x58(%rbp),%rdi
    0.00 :	  5a94d8:       e8 53 4b 1d 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  5a94dd:       84 c0                   test   %al,%al
    0.00 :	  5a94df:       75 a7                   jne    5a9488 <execTuplesMatch+0x48>
         :	         * comparing at the last field (least significant sort key). That's the
         :	         * most likely to be different if we are dealing with sorted input.
         :	         */
         :	        result = true;
         :
         :	        for (i = numCols; --i >= 0;)
    0.00 :	  5a94e1:       31 c0                   xor    %eax,%eax
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a94e3:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5a94e7:       48 89 15 72 13 61 00    mov    %rdx,0x611372(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return result;
         :	}
    0.00 :	  5a94ee:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5a94f2:       5b                      pop    %rbx
    0.00 :	  5a94f3:       41 5c                   pop    %r12
    0.00 :	  5a94f5:       41 5d                   pop    %r13
    0.00 :	  5a94f7:       41 5e                   pop    %r14
    0.00 :	  5a94f9:       41 5f                   pop    %r15
    0.00 :	  5a94fb:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:111
   33.33 :	  5a94fc:       c3                      retq   
    0.00 :	  5a94fd:       0f 1f 00                nopl   (%rax)
         :	         * comparing at the last field (least significant sort key). That's the
         :	         * most likely to be different if we are dealing with sorted input.
         :	         */
         :	        result = true;
         :
         :	        for (i = numCols; --i >= 0;)
    0.00 :	  5a9500:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5a9505:       eb dc                   jmp    5a94e3 <execTuplesMatch+0xa3>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1966
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1981
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1998
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b1430 <ExecMakeFunctionResultNoSets>:
         :	static Datum
         :	ExecMakeFunctionResultNoSets(FuncExprState *fcache,
         :	                                                         ExprContext *econtext,
         :	                                                         bool *isNull,
         :	                                                         ExprDoneCond *isDone)
         :	{
    0.00 :	  5b1430:       55                      push   %rbp
    0.00 :	  5b1431:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b1434:       41 57                   push   %r15
    0.00 :	  5b1436:       49 89 d7                mov    %rdx,%r15
    0.00 :	  5b1439:       41 56                   push   %r14
    0.00 :	  5b143b:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5b143e:       41 55                   push   %r13
    0.00 :	  5b1440:       49 89 fd                mov    %rdi,%r13
    0.00 :	  5b1443:       41 54                   push   %r12
    0.00 :	  5b1445:       53                      push   %rbx
    0.00 :	  5b1446:       48 89 cb                mov    %rcx,%rbx
    0.00 :	  5b1449:       48 83 ec 48             sub    $0x48,%rsp
         :	        FunctionCallInfo fcinfo;
         :	        PgStat_FunctionCallUsage fcusage;
         :	        int                     i;
         :
         :	        /* Guard against stack overflow due to overly complex expressions */
         :	        check_stack_depth();
    0.00 :	  5b144d:       e8 8e a5 0e 00          callq  69b9e0 <check_stack_depth>
         :
         :	        if (isDone)
    0.00 :	  5b1452:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b1455:       74 06                   je     5b145d <ExecMakeFunctionResultNoSets+0x2d>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b1457:       c7 03 00 00 00 00       movl   $0x0,(%rbx)
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b145d:       49 8b 45 18             mov    0x18(%r13),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5b1461:       48 85 c0                test   %rax,%rax
    0.00 :	  5b1464:       0f 84 c2 00 00 00       je     5b152c <ExecMakeFunctionResultNoSets+0xfc>
    0.00 :	  5b146a:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  5b146e:       4d 85 e4                test   %r12,%r12
    0.00 :	  5b1471:       0f 84 b5 00 00 00       je     5b152c <ExecMakeFunctionResultNoSets+0xfc>
    0.00 :	  5b1477:       31 db                   xor    %ebx,%ebx
    0.00 :	  5b1479:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                ExprState  *argstate = (ExprState *) lfirst(arg);
    0.00 :	  5b1480:       49 8b 04 24             mov    (%r12),%rax
         :
         :	                fcinfo->arg[i] = ExecEvalExpr(argstate,
    0.00 :	  5b1484:       49 8d 94 1d b0 03 00    lea    0x3b0(%r13,%rbx,1),%rdx
    0.00 :	  5b148b:       00 
    0.00 :	  5b148c:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b148e:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5b1491:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5b1494:       ff 50 10                callq  *0x10(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1966
   33.33 :	  5b1497:       49 89 84 dd 90 00 00    mov    %rax,0x90(%r13,%rbx,8)
    0.00 :	  5b149e:       00 
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b149f:       4d 8b 64 24 08          mov    0x8(%r12),%r12
         :	        {
         :	                ExprState  *argstate = (ExprState *) lfirst(arg);
         :
         :	                fcinfo->arg[i] = ExecEvalExpr(argstate,
    0.00 :	  5b14a4:       8d 53 01                lea    0x1(%rbx),%edx
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b14a7:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  5b14ab:       4d 85 e4                test   %r12,%r12
    0.00 :	  5b14ae:       75 d0                   jne    5b1480 <ExecMakeFunctionResultNoSets+0x50>
         :
         :	        /*
         :	         * If function is strict, and there are any NULL arguments, skip calling
         :	         * the function and return NULL.
         :	         */
         :	        if (fcache->func.fn_strict)
    0.00 :	  5b14b0:       41 80 7d 2e 00          cmpb   $0x0,0x2e(%r13)
    0.00 :	  5b14b5:       74 34                   je     5b14eb <ExecMakeFunctionResultNoSets+0xbb>
    0.00 :	  5b14b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5b14be:       00 00 
         :	        {
         :	                while (--i >= 0)
    0.00 :	  5b14c0:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5b14c3:       78 26                   js     5b14eb <ExecMakeFunctionResultNoSets+0xbb>
         :	                {
         :	                        if (fcinfo->argnull[i])
    0.00 :	  5b14c5:       48 63 c2                movslq %edx,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1981
   33.33 :	  5b14c8:       41 80 bc 05 b0 03 00    cmpb   $0x0,0x3b0(%r13,%rax,1)
    0.00 :	  5b14cf:       00 00 
    0.00 :	  5b14d1:       74 ed                   je     5b14c0 <ExecMakeFunctionResultNoSets+0x90>
         :	                        {
         :	                                *isNull = true;
    0.00 :	  5b14d3:       41 c6 07 01             movb   $0x1,(%r15)
    0.00 :	  5b14d7:       31 db                   xor    %ebx,%ebx
         :	        *isNull = fcinfo->isnull;
         :
         :	        pgstat_end_function_usage(&fcusage, true);
         :
         :	        return result;
         :	}
    0.00 :	  5b14d9:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5b14dd:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b14e0:       5b                      pop    %rbx
    0.00 :	  5b14e1:       41 5c                   pop    %r12
    0.00 :	  5b14e3:       41 5d                   pop    %r13
    0.00 :	  5b14e5:       41 5e                   pop    %r14
    0.00 :	  5b14e7:       41 5f                   pop    %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1998
   33.33 :	  5b14e9:       c9                      leaveq 
    0.00 :	  5b14ea:       c3                      retq   
         :
         :	        if (isDone)
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
    0.00 :	  5b14eb:       49 8d 5d 70             lea    0x70(%r13),%rbx
         :	                                return (Datum) 0;
         :	                        }
         :	                }
         :	        }
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
    0.00 :	  5b14ef:       4c 8d 65 90             lea    -0x70(%rbp),%r12
    0.00 :	  5b14f3:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b14f6:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5b14f9:       e8 82 12 09 00          callq  642780 <pgstat_init_function_usage>
         :
         :	        fcinfo->isnull = false;
         :	        result = FunctionCallInvoke(fcinfo);
    0.00 :	  5b14fe:       49 8b 45 70             mov    0x70(%r13),%rax
    0.00 :	  5b1502:       48 89 df                mov    %rbx,%rdi
         :	                }
         :	        }
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
         :
         :	        fcinfo->isnull = false;
    0.00 :	  5b1505:       41 c6 85 8c 00 00 00    movb   $0x0,0x8c(%r13)
    0.00 :	  5b150c:       00 
         :	        result = FunctionCallInvoke(fcinfo);
    0.00 :	  5b150d:       ff 10                   callq  *(%rax)
    0.00 :	  5b150f:       48 89 c3                mov    %rax,%rbx
         :	        *isNull = fcinfo->isnull;
    0.00 :	  5b1512:       41 0f b6 85 8c 00 00    movzbl 0x8c(%r13),%eax
    0.00 :	  5b1519:       00 
         :
         :	        pgstat_end_function_usage(&fcusage, true);
    0.00 :	  5b151a:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5b151f:       4c 89 e7                mov    %r12,%rdi
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
         :
         :	        fcinfo->isnull = false;
         :	        result = FunctionCallInvoke(fcinfo);
         :	        *isNull = fcinfo->isnull;
    0.00 :	  5b1522:       41 88 07                mov    %al,(%r15)
         :
         :	        pgstat_end_function_usage(&fcusage, true);
    0.00 :	  5b1525:       e8 a6 10 09 00          callq  6425d0 <pgstat_end_function_usage>
         :
         :	        return result;
         :	}
    0.00 :	  5b152a:       eb ad                   jmp    5b14d9 <ExecMakeFunctionResultNoSets+0xa9>
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b152c:       31 d2                   xor    %edx,%edx
    0.00 :	  5b152e:       eb 80                   jmp    5b14b0 <ExecMakeFunctionResultNoSets+0x80>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2778
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2780
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2788
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674e60 <ReleaseBuffer>:
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e60:       55                      push   %rbp
    0.00 :	  674e61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674e64:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  674e68:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  674e6c:       48 83 ec 10             sub    $0x10,%rsp
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e70:       85 ff                   test   %edi,%edi
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e72:       89 fb                   mov    %edi,%ebx
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e74:       74 7f                   je     674ef5 <ReleaseBuffer+0x95>
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
         :
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
    0.00 :	  674e76:       89 fe                   mov    %edi,%esi
    0.00 :	  674e78:       48 8b 3d 41 5a 54 00    mov    0x545a41(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674e7f:       e8 7c 5a 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674e84:       85 db                   test   %ebx,%ebx
    0.00 :	  674e86:       78 38                   js     674ec0 <ReleaseBuffer+0x60>
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
    0.00 :	  674e88:       31 d2                   xor    %edx,%edx
    0.00 :	  674e8a:       31 f6                   xor    %esi,%esi
    0.00 :	  674e8c:       89 df                   mov    %ebx,%edi
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2778
   33.33 :	  674e8e:       4c 8b 25 6b ac 54 00    mov    0x54ac6b(%rip),%r12        # bbfb00 <BufferDescriptors>
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2780
   33.33 :	  674e95:       e8 86 f6 ff ff          callq  674520 <GetPrivateRefCountEntry>
    0.00 :	  674e9a:       48 89 c2                mov    %rax,%rdx
         :	        Assert(ref != NULL);
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
    0.00 :	  674e9d:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  674ea0:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  674ea3:       7e 33                   jle    674ed8 <ReleaseBuffer+0x78>
         :	                ref->refcount--;
    0.00 :	  674ea5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674ea8:       89 42 04                mov    %eax,0x4(%rdx)
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674eab:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  674eaf:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eb4:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2788
   33.33 :	  674eb5:       c3                      retq   
    0.00 :	  674eb6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  674ebd:       00 00 00 
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
         :
         :	        if (BufferIsLocal(buffer))
         :	        {
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
    0.00 :	  674ec0:       f7 d3                   not    %ebx
    0.00 :	  674ec2:       48 63 c3                movslq %ebx,%rax
    0.00 :	  674ec5:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  674ec9:       48 03 05 50 82 50 00    add    0x508250(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  674ed0:       83 28 01                subl   $0x1,(%rax)
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674ed3:       eb d6                   jmp    674eab <ReleaseBuffer+0x4b>
    0.00 :	  674ed5:       0f 1f 00                nopl   (%rax)
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ed8:       48 63 c3                movslq %ebx,%rax
         :	}
    0.00 :	  674edb:       48 8b 1c 24             mov    (%rsp),%rbx
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674edf:       31 f6                   xor    %esi,%esi
    0.00 :	  674ee1:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674ee5:       49 8d 7c 04 c0          lea    -0x40(%r12,%rax,1),%rdi
         :	}
    0.00 :	  674eea:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eef:       c9                      leaveq 
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ef0:       e9 3b fe ff ff          jmpq   674d30 <UnpinBuffer>
         :	{
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
    0.00 :	  674ef5:       ba 34 a0 8a 00          mov    $0x8aa034,%edx
    0.00 :	  674efa:       be cf 0a 00 00          mov    $0xacf,%esi
    0.00 :	  674eff:       bf 53 9d 8a 00          mov    $0x8a9d53,%edi
    0.00 :	  674f04:       e8 17 65 10 00          callq  77b420 <elog_start>
    0.00 :	  674f09:       31 d2                   xor    %edx,%edx
    0.00 :	  674f0b:       be 5c 9d 8a 00          mov    $0x8a9d5c,%esi
    0.00 :	  674f10:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  674f15:       31 c0                   xor    %eax,%eax
    0.00 :	  674f17:       e8 14 63 10 00          callq  77b230 <elog_finish>
    0.00 :	  674f1c:       e8 af 45 df ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000677560 <StrategyGetBuffer>:
         :	 *      To ensure that no one else can pin the buffer before we do, we must
         :	 *      return the buffer with the buffer header spinlock still held.
         :	 */
         :	volatile BufferDesc *
         :	StrategyGetBuffer(BufferAccessStrategy strategy)
         :	{
    0.00 :	  677560:       55                      push   %rbp
    0.00 :	  677561:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  677564:       41 57                   push   %r15
    0.00 :	  677566:       41 56                   push   %r14
    0.00 :	  677568:       41 55                   push   %r13
    0.00 :	  67756a:       49 89 fd                mov    %rdi,%r13
    0.00 :	  67756d:       41 54                   push   %r12
    0.00 :	  67756f:       53                      push   %rbx
    0.00 :	  677570:       48 83 ec 08             sub    $0x8,%rsp
         :
         :	        /*
         :	         * If given a strategy object, see whether it can select a buffer. We
         :	         * assume strategy objects don't need buffer_strategy_lock.
         :	         */
         :	        if (strategy != NULL)
    0.00 :	  677574:       48 85 ff                test   %rdi,%rdi
    0.00 :	  677577:       74 65                   je     6775de <StrategyGetBuffer+0x7e>
         :	{
         :	        volatile BufferDesc *buf;
         :	        Buffer          bufnum;
         :
         :	        /* Advance to next ring slot */
         :	        if (++strategy->current >= strategy->ring_size)
    0.00 :	  677579:       8b 47 08                mov    0x8(%rdi),%eax
    0.00 :	  67757c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67757f:       3b 47 04                cmp    0x4(%rdi),%eax
    0.00 :	  677582:       89 47 08                mov    %eax,0x8(%rdi)
    0.00 :	  677585:       7c 09                   jl     677590 <StrategyGetBuffer+0x30>
         :	                strategy->current = 0;
    0.00 :	  677587:       c7 47 08 00 00 00 00    movl   $0x0,0x8(%rdi)
    0.00 :	  67758e:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * If the slot hasn't been filled yet, tell the caller to allocate a new
         :	         * buffer with the normal allocation strategy.  He will then fill this
         :	         * slot by calling AddBufferToRing with the new buffer.
         :	         */
         :	        bufnum = strategy->buffers[strategy->current];
    0.00 :	  677590:       48 98                   cltq   
    0.00 :	  677592:       41 8b 44 85 10          mov    0x10(%r13,%rax,4),%eax
         :	        if (bufnum == InvalidBuffer)
    0.00 :	  677597:       85 c0                   test   %eax,%eax
    0.00 :	  677599:       74 3e                   je     6775d9 <StrategyGetBuffer+0x79>
         :	         * since our own previous usage of the ring element would have left it
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
    0.00 :	  67759b:       48 98                   cltq   
    0.00 :	  67759d:       48 8d 58 ff             lea    -0x1(%rax),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  6775a1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  6775a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6775aa:       48 03 1d 4f 85 54 00    add    0x54854f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	        LockBufHdr(buf);
    0.00 :	  6775b1:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6775b5:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  6775b8:       84 c0                   test   %al,%al
    0.00 :	  6775ba:       0f 85 b8 02 00 00       jne    677878 <StrategyGetBuffer+0x318>
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
    0.00 :	  6775c0:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6775c3:       85 c0                   test   %eax,%eax
    0.00 :	  6775c5:       75 0e                   jne    6775d5 <StrategyGetBuffer+0x75>
    0.00 :	  6775c7:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  6775cb:       66 83 f8 01             cmp    $0x1,%ax
    0.00 :	  6775cf:       0f 86 92 02 00 00       jbe    677867 <StrategyGetBuffer+0x307>
         :	        {
         :	                strategy->current_was_in_ring = true;
         :	                return buf;
         :	        }
         :	        UnlockBufHdr(buf);
    0.00 :	  6775d5:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Tell caller to allocate a new buffer with the normal allocation
         :	         * strategy.  He'll then replace this ring element via AddBufferToRing.
         :	         */
         :	        strategy->current_was_in_ring = false;
    0.00 :	  6775d9:       41 c6 45 0c 00          movb   $0x0,0xc(%r13)
         :	        /*
         :	         * We count buffer allocation requests so that the bgwriter can estimate
         :	         * the rate of buffer consumption.  Note that buffers recycled by a
         :	         * strategy object are intentionally not counted here.
         :	         */
         :	        pg_atomic_fetch_add_u32(&StrategyControl->numBufferAllocs, 1);
    0.00 :	  6775de:       48 8b 05 1b 5b 50 00    mov    0x505b1b(%rip),%rax        # b7d100 <StrategyControl>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  6775e5:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  6775ea:       48 83 c0 14             add    $0x14,%rax
    0.00 :	  6775ee:       f0 0f c1 10             lock xadd %edx,(%rax)
         :	         * Since we're not guaranteed atomic 8 byte reads we need to acquire the
         :	         * spinlock if not null to be sure we get a correct pointer. Because we
         :	         * don't want to set the latch while holding the buffer_strategy_lock we
         :	         * just grab the lock to read and reset the pointer.
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  6775f2:       48 8b 15 07 5b 50 00    mov    0x505b07(%rip),%rdx        # b7d100 <StrategyControl>
         :	        if (bgwriterLatch)
    0.00 :	  6775f9:       48 83 7a 18 00          cmpq   $0x0,0x18(%rdx)
    0.00 :	  6775fe:       74 3e                   je     67763e <StrategyGetBuffer+0xde>
    0.00 :	  677600:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  677605:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677608:       84 c0                   test   %al,%al
    0.00 :	  67760a:       0f 85 21 02 00 00       jne    677831 <StrategyGetBuffer+0x2d1>
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  677610:       48 8b 05 e9 5a 50 00    mov    0x505ae9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677617:       48 8b 78 18             mov    0x18(%rax),%rdi
         :	                StrategyControl->bgwriterLatch = NULL;
    0.00 :	  67761b:       48 c7 40 18 00 00 00    movq   $0x0,0x18(%rax)
    0.00 :	  677622:       00 
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677623:       48 8b 05 d6 5a 50 00    mov    0x505ad6(%rip),%rax        # b7d100 <StrategyControl>
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  67762a:       48 85 ff                test   %rdi,%rdi
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	                StrategyControl->bgwriterLatch = NULL;
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67762d:       c6 00 00                movb   $0x0,(%rax)
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  677630:       74 05                   je     677637 <StrategyGetBuffer+0xd7>
         :	                        SetLatch(bgwriterLatch);
    0.00 :	  677632:       e8 89 1a fc ff          callq  6390c0 <SetLatch>
    0.00 :	  677637:       48 8b 15 c2 5a 50 00    mov    0x505ac2(%rip),%rdx        # b7d100 <StrategyControl>
         :	         *
         :	         * Note that the freeNext fields are considered to be protected by
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
    0.00 :	  67763e:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  677641:       85 c0                   test   %eax,%eax
    0.00 :	  677643:       0f 88 08 01 00 00       js     677751 <StrategyGetBuffer+0x1f1>
    0.00 :	  677649:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  67764e:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677651:       84 c0                   test   %al,%al
    0.00 :	  677653:       0f 85 f3 01 00 00       jne    67784c <StrategyGetBuffer+0x2ec>
    0.00 :	  677659:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  67765f:       eb 30                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677661:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
         :	                        if (buf->refcount == 0 && buf->usage_count == 0)
    0.00 :	  677668:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  67766b:       85 c0                   test   %eax,%eax
    0.00 :	  67766d:       75 0d                   jne    67767c <StrategyGetBuffer+0x11c>
    0.00 :	  67766f:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677673:       66 85 c0                test   %ax,%ax
    0.00 :	  677676:       0f 84 94 00 00 00       je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
    0.00 :	  67767c:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  677680:       44 89 e0                mov    %r12d,%eax
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677683:       48 8b 15 76 5a 50 00    mov    0x505a76(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  67768a:       f0 86 02                lock xchg %al,(%rdx)
    0.00 :	  67768d:       84 c0                   test   %al,%al
    0.00 :	  67768f:       75 5f                   jne    6776f0 <StrategyGetBuffer+0x190>
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :
         :	                while (StrategyControl->firstFreeBuffer >= 0)
    0.00 :	  677691:       48 8b 15 68 5a 50 00    mov    0x505a68(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  677698:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  67769b:       85 c0                   test   %eax,%eax
    0.00 :	  67769d:       0f 88 9d 00 00 00       js     677740 <StrategyGetBuffer+0x1e0>
         :	                {
         :	                        buf = &BufferDescriptors[StrategyControl->firstFreeBuffer];
    0.00 :	  6776a3:       48 63 d8                movslq %eax,%rbx
    0.00 :	  6776a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6776aa:       48 03 1d 4f 84 54 00    add    0x54844f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	                        Assert(buf->freeNext != FREENEXT_NOT_IN_LIST);
         :
         :	                        /* Unconditionally remove buffer from freelist */
         :	                        StrategyControl->firstFreeBuffer = buf->freeNext;
    0.00 :	  6776b1:       8b 43 28                mov    0x28(%rbx),%eax
    0.00 :	  6776b4:       89 42 08                mov    %eax,0x8(%rdx)
         :	                        buf->freeNext = FREENEXT_NOT_IN_LIST;
    0.00 :	  6776b7:       c7 43 28 fe ff ff ff    movl   $0xfffffffe,0x28(%rbx)
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776be:       48 8b 05 3b 5a 50 00    mov    0x505a3b(%rip),%rax        # b7d100 <StrategyControl>
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776c5:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776c9:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  6776cc:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6776cf:       f0 86 07                lock xchg %al,(%rdi)
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776d2:       84 c0                   test   %al,%al
    0.00 :	  6776d4:       74 92                   je     677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776d6:       ba d0 00 00 00          mov    $0xd0,%edx
    0.00 :	  6776db:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  6776e0:       e8 5b 89 01 00          callq  690040 <s_lock>
    0.00 :	  6776e5:       eb 81                   jmp    677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6776ee:       00 00 
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776f0:       48 8b 3d 09 5a 50 00    mov    0x505a09(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  6776f7:       ba da 00 00 00          mov    $0xda,%edx
    0.00 :	  6776fc:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677701:       e8 3a 89 01 00          callq  690040 <s_lock>
    0.00 :	  677706:       eb 89                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677708:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  67770f:       00 
         :	                                trycounter = NBuffers;
         :	                        }
         :	                        else
         :	                        {
         :	                                /* Found a usable buffer */
         :	                                if (strategy != NULL)
    0.00 :	  677710:       4d 85 ed                test   %r13,%r13
    0.00 :	  677713:       74 0f                   je     677724 <StrategyGetBuffer+0x1c4>
         :	 * is called with the spinlock held, it had better be quite cheap.
         :	 */
         :	static void
         :	AddBufferToRing(BufferAccessStrategy strategy, volatile BufferDesc *buf)
         :	{
         :	        strategy->buffers[strategy->current] = BufferDescriptorGetBuffer(buf);
    0.00 :	  677715:       8b 43 24                mov    0x24(%rbx),%eax
    0.00 :	  677718:       49 63 55 08             movslq 0x8(%r13),%rdx
    0.00 :	  67771c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67771f:       41 89 44 95 10          mov    %eax,0x10(%r13,%rdx,4)
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
         :	        }
         :	}
    0.00 :	  677724:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  677728:       48 89 d8                mov    %rbx,%rax
    0.00 :	  67772b:       5b                      pop    %rbx
    0.00 :	  67772c:       41 5c                   pop    %r12
    0.00 :	  67772e:       41 5d                   pop    %r13
    0.00 :	  677730:       41 5e                   pop    %r14
    0.00 :	  677732:       41 5f                   pop    %r15
    0.00 :	  677734:       c9                      leaveq 
    0.00 :	  677735:       c3                      retq   
    0.00 :	  677736:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67773d:       00 00 00 
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                }
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677740:       48 8b 05 b9 59 50 00    mov    0x5059b9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677747:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  67774a:       48 8b 15 af 59 50 00    mov    0x5059af(%rip),%rdx        # b7d100 <StrategyControl>
         :	        }
         :
         :	        /* Nothing on the freelist, so run the "clock sweep" algorithm */
         :	        trycounter = NBuffers;
    0.00 :	  677751:       44 8b 25 c8 13 4f 00    mov    0x4f13c8(%rip),%r12d        # b68b20 <NBuffers>
    0.00 :	  677758:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  67775e:       41 bf 01 00 00 00       mov    $0x1,%r15d
    0.00 :	  677764:       eb 30                   jmp    677796 <StrategyGetBuffer+0x236>
    0.00 :	  677766:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67776d:       00 00 00 
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
         :	                if (buf->refcount == 0)
         :	                {
         :	                        if (buf->usage_count > 0)
    0.00 :	  677770:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677774:       66 85 c0                test   %ax,%ax
    0.00 :	  677777:       74 97                   je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                buf->usage_count--;
    0.00 :	  677779:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  67777d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  677780:       66 89 43 16             mov    %ax,0x16(%rbx)
         :	                                trycounter = NBuffers;
    0.00 :	  677784:       44 8b 25 95 13 4f 00    mov    0x4f1395(%rip),%r12d        # b68b20 <NBuffers>
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
    0.00 :	  67778b:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  67778f:       48 8b 15 6a 59 50 00    mov    0x50596a(%rip),%rdx        # b7d100 <StrategyControl>
         :	        trycounter = NBuffers;
         :	        for (;;)
         :	        {
         :	                int victim;
         :
         :	                victim = pg_atomic_fetch_add_u32(&StrategyControl->nextVictimBuffer, 1);
    0.00 :	  677796:       48 8d 42 04             lea    0x4(%rdx),%rax
    0.00 :	  67779a:       44 89 f2                mov    %r14d,%edx
    0.00 :	  67779d:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                buf = &BufferDescriptors[victim % NBuffers];
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
   66.67 :	  6777a1:       89 d0                   mov    %edx,%eax
    0.00 :	  6777a3:       c1 fa 1f                sar    $0x1f,%edx
    0.00 :	  6777a6:       f7 3d 74 13 4f 00       idivl  0x4f1374(%rip)        # b68b20 <NBuffers>
    0.00 :	  6777ac:       48 63 da                movslq %edx,%rbx
    0.00 :	  6777af:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6777b3:       48 03 1d 46 83 54 00    add    0x548346(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :
         :	                if (victim % NBuffers == 0)
    0.00 :	  6777ba:       85 d2                   test   %edx,%edx
    0.00 :	  6777bc:       75 12                   jne    6777d0 <StrategyGetBuffer+0x270>
         :	                {
         :	                        pg_atomic_add_fetch_u32(&StrategyControl->completePasses, 1);
    0.00 :	  6777be:       48 8b 05 3b 59 50 00    mov    0x50593b(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  6777c5:       44 89 f2                mov    %r14d,%edx
    0.00 :	  6777c8:       48 83 c0 10             add    $0x10,%rax
    0.00 :	  6777cc:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  6777d0:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6777d4:       44 89 f8                mov    %r15d,%eax
    0.00 :	  6777d7:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
   33.33 :	  6777da:       84 c0                   test   %al,%al
    0.00 :	  6777dc:       75 42                   jne    677820 <StrategyGetBuffer+0x2c0>
         :	                if (buf->refcount == 0)
    0.00 :	  6777de:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6777e1:       85 c0                   test   %eax,%eax
    0.00 :	  6777e3:       74 8b                   je     677770 <StrategyGetBuffer+0x210>
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                }
         :	                else if (--trycounter == 0)
    0.00 :	  6777e5:       41 83 ec 01             sub    $0x1,%r12d
    0.00 :	  6777e9:       75 a0                   jne    67778b <StrategyGetBuffer+0x22b>
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777eb:       ba 80 a1 8a 00          mov    $0x8aa180,%edx
    0.00 :	  6777f0:       be 0c 01 00 00          mov    $0x10c,%esi
    0.00 :	  6777f5:       bf ec a0 8a 00          mov    $0x8aa0ec,%edi
         :	                         * so all the buffers are pinned (or were when we looked at them).
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
    0.00 :	  6777fa:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777fe:       e8 1d 3c 10 00          callq  77b420 <elog_start>
    0.00 :	  677803:       be 0e a1 8a 00          mov    $0x8aa10e,%esi
    0.00 :	  677808:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67780d:       31 c0                   xor    %eax,%eax
    0.00 :	  67780f:       e8 1c 3a 10 00          callq  77b230 <elog_finish>
    0.00 :	  677814:       e8 b7 1c df ff          callq  4694d0 <abort@plt>
    0.00 :	  677819:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  677820:       ba f2 00 00 00          mov    $0xf2,%edx
    0.00 :	  677825:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67782a:       e8 11 88 01 00          callq  690040 <s_lock>
    0.00 :	  67782f:       eb ad                   jmp    6777de <StrategyGetBuffer+0x27e>
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	        if (bgwriterLatch)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677831:       48 8b 3d c8 58 50 00    mov    0x5058c8(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677838:       ba 9f 00 00 00          mov    $0x9f,%edx
    0.00 :	  67783d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677842:       e8 f9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677847:       e9 c4 fd ff ff          jmpq   677610 <StrategyGetBuffer+0xb0>
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67784c:       48 8b 3d ad 58 50 00    mov    0x5058ad(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677853:       ba b8 00 00 00          mov    $0xb8,%edx
    0.00 :	  677858:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67785d:       e8 de 87 01 00          callq  690040 <s_lock>
    0.00 :	  677862:       e9 f2 fd ff ff          jmpq   677659 <StrategyGetBuffer+0xf9>
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
         :	        {
         :	                strategy->current_was_in_ring = true;
    0.00 :	  677867:       41 c6 45 0c 01          movb   $0x1,0xc(%r13)
    0.00 :	  67786c:       e9 b3 fe ff ff          jmpq   677724 <StrategyGetBuffer+0x1c4>
    0.00 :	  677871:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
    0.00 :	  677878:       ba 20 02 00 00          mov    $0x220,%edx
    0.00 :	  67787d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677882:       e8 b9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677887:       e9 34 fd ff ff          jmpq   6775c0 <StrategyGetBuffer+0x60>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:4064
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:4064
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000694660 <CheckForSerializableConflictOut>:
         :	 */
         :	void
         :	CheckForSerializableConflictOut(bool visible, Relation relation,
         :	                                                                HeapTuple tuple, Buffer buffer,
         :	                                                                Snapshot snapshot)
         :	{
    0.00 :	  694660:       55                      push   %rbp
    0.00 :	  694661:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  694664:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  694668:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  69466c:       49 89 d4                mov    %rdx,%r12
    0.00 :	  69466f:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  694673:       48 83 ec 30             sub    $0x30,%rsp
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694677:       48 8b 15 42 a0 4e 00    mov    0x4ea042(%rip),%rdx        # b7e6c0 <MySerializableXact>
         :	 */
         :	void
         :	CheckForSerializableConflictOut(bool visible, Relation relation,
         :	                                                                HeapTuple tuple, Buffer buffer,
         :	                                                                Snapshot snapshot)
         :	{
    0.00 :	  69467e:       41 89 fd                mov    %edi,%r13d
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694681:       48 85 d2                test   %rdx,%rdx
    0.00 :	  694684:       74 13                   je     694699 <CheckForSerializableConflictOut+0x39>
         :	         * This excludes things like CLUSTER and REINDEX. They use the wholesale
         :	         * functions TransferPredicateLocksToHeapRelation() and
         :	         * CheckTableForSerializableConflictIn() to participate serialization, but
         :	         * the scans involved don't need serialization.
         :	         */
         :	        if (!IsMVCCSnapshot(snapshot))
    0.00 :	  694686:       49 8b 00                mov    (%r8),%rax
    0.00 :	  694689:       48 3d 50 57 7a 00       cmp    $0x7a5750,%rax
    0.00 :	  69468f:       74 1f                   je     6946b0 <CheckForSerializableConflictOut+0x50>
    0.00 :	  694691:       48 3d 60 47 7a 00       cmp    $0x7a4760,%rax
    0.00 :	  694697:       74 17                   je     6946b0 <CheckForSerializableConflictOut+0x50>
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
         :	        LWLockRelease(SerializableXactHashLock);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:4064
   33.33 :	  694699:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  69469d:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6946a1:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
   66.67 :	  6946a5:       c9                      leaveq 
    0.00 :	  6946a6:       c3                      retq   
    0.00 :	  6946a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6946ae:       00 00 
         :	         *
         :	         * A transaction is flagged as RO_SAFE if all concurrent R/W transactions
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
    0.00 :	  6946b0:       8b 52 7c                mov    0x7c(%rdx),%edx
    0.00 :	  6946b3:       84 d2                   test   %dl,%dl
    0.00 :	  6946b5:       78 69                   js     694720 <CheckForSerializableConflictOut+0xc0>
         :	 * relations are exempt, as are materialized views.
         :	 */
         :	static inline bool
         :	PredicateLockingNeededForRelation(Relation relation)
         :	{
         :	        return !(relation->rd_id < FirstBootstrapObjectId ||
    0.00 :	  6946b7:       81 7e 40 0f 27 00 00    cmpl   $0x270f,0x40(%rsi)
    0.00 :	  6946be:       76 d9                   jbe    694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  6946c0:       48 8b 46 30             mov    0x30(%rsi),%rax
    0.00 :	  6946c4:       80 78 6e 74             cmpb   $0x74,0x6e(%rax)
    0.00 :	  6946c8:       74 cf                   je     694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  6946ca:       80 78 6f 6d             cmpb   $0x6d,0x6f(%rax)
    0.00 :	  6946ce:       66 90                   xchg   %ax,%ax
    0.00 :	  6946d0:       74 c7                   je     694699 <CheckForSerializableConflictOut+0x39>
         :
         :	        if (!SerializationNeededForRead(relation, snapshot))
         :	                return;
         :
         :	        /* Check if someone else has already decided that we need to die */
         :	        if (SxactIsDoomed(MySerializableXact))
    0.00 :	  6946d2:       83 e2 08                and    $0x8,%edx
    0.00 :	  6946d5:       0f 85 55 02 00 00       jne    694930 <CheckForSerializableConflictOut+0x2d0>
         :	         * transaction, either to create it not visible to us, or to delete it
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
    0.00 :	  6946db:       8b 35 77 e0 4d 00       mov    0x4de077(%rip),%esi        # b72758 <TransactionXmin>
    0.00 :	  6946e1:       89 ca                   mov    %ecx,%edx
    0.00 :	  6946e3:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6946e6:       e8 35 04 11 00          callq  7a4b20 <HeapTupleSatisfiesVacuum>
         :	        switch (htsvResult)
    0.00 :	  6946eb:       83 f8 04                cmp    $0x4,%eax
         :	         * transaction, either to create it not visible to us, or to delete it
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
    0.00 :	  6946ee:       89 c3                   mov    %eax,%ebx
         :	        switch (htsvResult)
    0.00 :	  6946f0:       76 3e                   jbe    694730 <CheckForSerializableConflictOut+0xd0>
         :	                        /*
         :	                         * The only way to get to this default clause is if a new value is
         :	                         * added to the enum type without adding it to this switch
         :	                         * statement.  That's a bug, so elog.
         :	                         */
         :	                        elog(ERROR, "unrecognized return value from HeapTupleSatisfiesVacuum: %u", htsvResult);
    0.00 :	  6946f2:       ba e0 da 8a 00          mov    $0x8adae0,%edx
    0.00 :	  6946f7:       be 56 0f 00 00          mov    $0xf56,%esi
    0.00 :	  6946fc:       bf d3 d1 8a 00          mov    $0x8ad1d3,%edi
    0.00 :	  694701:       e8 1a 6d 0e 00          callq  77b420 <elog_start>
    0.00 :	  694706:       89 da                   mov    %ebx,%edx
    0.00 :	  694708:       be a0 d8 8a 00          mov    $0x8ad8a0,%esi
    0.00 :	  69470d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694712:       31 c0                   xor    %eax,%eax
    0.00 :	  694714:       e8 17 6b 0e 00          callq  77b230 <elog_finish>
    0.00 :	  694719:       e8 b2 4d dd ff          callq  4694d0 <abort@plt>
    0.00 :	  69471e:       66 90                   xchg   %ax,%ax
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
         :	        {
         :	                ReleasePredicateLocks(false);
    0.00 :	  694720:       31 ff                   xor    %edi,%edi
    0.00 :	  694722:       e8 c9 e1 ff ff          callq  6928f0 <ReleasePredicateLocks>
    0.00 :	  694727:       e9 6d ff ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  69472c:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
         :	        switch (htsvResult)
    0.00 :	  694730:       89 c0                   mov    %eax,%eax
    0.00 :	  694732:       ff 24 c5 c0 d9 8a 00    jmpq   *0x8ad9c0(,%rax,8)
    0.00 :	  694739:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        if (visible)
         :	                                return;
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_RECENTLY_DEAD:
         :	                        if (!visible)
    0.00 :	  694740:       45 84 ed                test   %r13b,%r13b
    0.00 :	  694743:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  694748:       0f 84 4b ff ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :	                                return;
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
    0.00 :	  69474e:       49 8b 7c 24 10          mov    0x10(%r12),%rdi
    0.00 :	  694753:       0f b7 57 14             movzwl 0x14(%rdi),%edx
    0.00 :	  694757:       89 d0                   mov    %edx,%eax
    0.00 :	  694759:       25 00 18 00 00          and    $0x1800,%eax
    0.00 :	  69475e:       3d 00 10 00 00          cmp    $0x1000,%eax
    0.00 :	  694763:       0f 84 f7 00 00 00       je     694860 <CheckForSerializableConflictOut+0x200>
    0.00 :	  694769:       8b 5f 04                mov    0x4(%rdi),%ebx
         :
         :	        /*
         :	         * Find top level xid.  Bail out if xid is too early to be a conflict, or
         :	         * if it's our own xid.
         :	         */
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
    0.00 :	  69476c:       e8 0f c4 e2 ff          callq  4c0b80 <GetTopTransactionIdIfAny>
    0.00 :	  694771:       39 d8                   cmp    %ebx,%eax
    0.00 :	  694773:       0f 84 20 ff ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :	                return;
         :	        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  694779:       89 df                   mov    %ebx,%edi
    0.00 :	  69477b:       e8 70 21 e3 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	        if (TransactionIdPrecedes(xid, TransactionXmin))
    0.00 :	  694780:       8b 35 d2 df 4d 00       mov    0x4ddfd2(%rip),%esi        # b72758 <TransactionXmin>
    0.00 :	  694786:       89 c7                   mov    %eax,%edi
         :	         * Find top level xid.  Bail out if xid is too early to be a conflict, or
         :	         * if it's our own xid.
         :	         */
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
         :	                return;
         :	        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  694788:       89 c3                   mov    %eax,%ebx
         :	        if (TransactionIdPrecedes(xid, TransactionXmin))
    0.00 :	  69478a:       e8 51 b8 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  69478f:       84 c0                   test   %al,%al
    0.00 :	  694791:       0f 85 02 ff ff ff       jne    694699 <CheckForSerializableConflictOut+0x39>
         :	                return;
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
    0.00 :	  694797:       e8 e4 c3 e2 ff          callq  4c0b80 <GetTopTransactionIdIfAny>
    0.00 :	  69479c:       39 c3                   cmp    %eax,%ebx
    0.00 :	  69479e:       66 90                   xchg   %ax,%ax
    0.00 :	  6947a0:       0f 84 f3 fe ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :
         :	        /*
         :	         * Find sxact or summarized info for the top level xid.
         :	         */
         :	        sxidtag.xid = xid;
         :	        LWLockAcquire(SerializableXactHashLock, LW_EXCLUSIVE);
    0.00 :	  6947a6:       48 8b 3d 53 92 4e 00    mov    0x4e9253(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6947ad:       31 f6                   xor    %esi,%esi
         :	                return;
         :
         :	        /*
         :	         * Find sxact or summarized info for the top level xid.
         :	         */
         :	        sxidtag.xid = xid;
    0.00 :	  6947af:       89 5d d0                mov    %ebx,-0x30(%rbp)
         :	        LWLockAcquire(SerializableXactHashLock, LW_EXCLUSIVE);
    0.00 :	  6947b2:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  6947b9:       e8 32 b3 ff ff          callq  68faf0 <LWLockAcquire>
         :	        sxid = (SERIALIZABLEXID *)
    0.00 :	  6947be:       48 8b 3d 93 9f 4e 00    mov    0x4e9f93(%rip),%rdi        # b7e758 <SerializableXidHash>
    0.00 :	  6947c5:       48 8d 75 d0             lea    -0x30(%rbp),%rsi
    0.00 :	  6947c9:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6947cb:       31 d2                   xor    %edx,%edx
    0.00 :	  6947cd:       e8 ce fe 0e 00          callq  7846a0 <hash_search>
         :	                hash_search(SerializableXidHash, &sxidtag, HASH_FIND, NULL);
         :	        if (!sxid)
    0.00 :	  6947d2:       48 85 c0                test   %rax,%rax
    0.00 :	  6947d5:       0f 84 c5 01 00 00       je     6949a0 <CheckForSerializableConflictOut+0x340>
         :
         :	                /* It's not serializable or otherwise not important. */
         :	                LWLockRelease(SerializableXactHashLock);
         :	                return;
         :	        }
         :	        sxact = sxid->myXact;
    0.00 :	  6947db:       4c 8b 60 08             mov    0x8(%rax),%r12
         :	        Assert(TransactionIdEquals(sxact->topXid, xid));
         :	        if (sxact == MySerializableXact || SxactIsDoomed(sxact))
    0.00 :	  6947df:       48 8b 0d da 9e 4e 00    mov    0x4e9eda(%rip),%rcx        # b7e6c0 <MySerializableXact>
    0.00 :	  6947e6:       49 39 cc                cmp    %rcx,%r12
    0.00 :	  6947e9:       0f 84 b1 00 00 00       je     6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  6947ef:       41 8b 54 24 7c          mov    0x7c(%r12),%edx
    0.00 :	  6947f4:       f6 c2 08                test   $0x8,%dl
    0.00 :	  6947f7:       0f 85 a3 00 00 00       jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :	         * We have a conflict out to a transaction which has a conflict out to a
         :	         * summarized transaction.  That summarized transaction must have
         :	         * committed first, and we can't tell when it committed in relation to our
         :	         * snapshot acquisition, so something needs to be canceled.
         :	         */
         :	        if (SxactHasSummaryConflictOut(sxact))
    0.00 :	  6947fd:       f6 c6 04                test   $0x4,%dh
    0.00 :	  694800:       0f 84 b2 00 00 00       je     6948b8 <CheckForSerializableConflictOut+0x258>
         :	        {
         :	                if (!SxactIsPrepared(sxact))
    0.00 :	  694806:       f6 c2 02                test   $0x2,%dl
    0.00 :	  694809:       0f 85 39 03 00 00       jne    694b48 <CheckForSerializableConflictOut+0x4e8>
         :	                {
         :	                        sxact->flags |= SXACT_FLAG_DOOMED;
    0.00 :	  69480f:       83 ca 08                or     $0x8,%edx
    0.00 :	  694812:       41 89 54 24 7c          mov    %edx,0x7c(%r12)
         :	                        LWLockRelease(SerializableXactHashLock);
    0.00 :	  694817:       48 8b 3d e2 91 4e 00    mov    0x4e91e2(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  69481e:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  694825:       e8 76 ab ff ff          callq  68f3a0 <LWLockRelease>
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
         :	        LWLockRelease(SerializableXactHashLock);
         :	}
    0.00 :	  69482a:       e9 6a fe ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  69482f:       90                      nop
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
         :	        switch (htsvResult)
         :	        {
         :	                case HEAPTUPLE_LIVE:
         :	                        if (visible)
    0.00 :	  694830:       45 84 ed                test   %r13b,%r13b
    0.00 :	  694833:       0f 85 60 fe ff ff       jne    694699 <CheckForSerializableConflictOut+0x39>
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_INSERT_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
    0.00 :	  694839:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :	                        /*
         :	                         * The only way to get to this default clause is if a new value is
         :	                         * added to the enum type without adding it to this switch
         :	                         * statement.  That's a bug, so elog.
         :	                         */
         :	                        elog(ERROR, "unrecognized return value from HeapTupleSatisfiesVacuum: %u", htsvResult);
    0.00 :	  69483e:       bb 02 00 00 00          mov    $0x2,%ebx
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_INSERT_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
    0.00 :	  694843:       0f b7 42 14             movzwl 0x14(%rdx),%eax
    0.00 :	  694847:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  69484c:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  694851:       0f 84 15 ff ff ff       je     69476c <CheckForSerializableConflictOut+0x10c>
    0.00 :	  694857:       8b 1a                   mov    (%rdx),%ebx
    0.00 :	  694859:       e9 0e ff ff ff          jmpq   69476c <CheckForSerializableConflictOut+0x10c>
    0.00 :	  69485e:       66 90                   xchg   %ax,%ax
         :	                        if (!visible)
         :	                                return;
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
    0.00 :	  694860:       84 d2                   test   %dl,%dl
    0.00 :	  694862:       0f 88 01 ff ff ff       js     694769 <CheckForSerializableConflictOut+0x109>
    0.00 :	  694868:       e8 b3 28 e0 ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  69486d:       89 c3                   mov    %eax,%ebx
    0.00 :	  69486f:       90                      nop
    0.00 :	  694870:       e9 f7 fe ff ff          jmpq   69476c <CheckForSerializableConflictOut+0x10c>
         :	                /* This write was already in our snapshot; no conflict. */
         :	                LWLockRelease(SerializableXactHashLock);
         :	                return;
         :	        }
         :
         :	        if (RWConflictExists(MySerializableXact, sxact))
    0.00 :	  694875:       48 8b 3d 44 9e 4e 00    mov    0x4e9e44(%rip),%rdi        # b7e6c0 <MySerializableXact>
    0.00 :	  69487c:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  69487f:       e8 1c cc ff ff          callq  6914a0 <RWConflictExists>
    0.00 :	  694884:       84 c0                   test   %al,%al
    0.00 :	  694886:       75 18                   jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :
         :	        /*
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
    0.00 :	  694888:       48 8b 3d 31 9e 4e 00    mov    0x4e9e31(%rip),%rdi        # b7e6c0 <MySerializableXact>
    0.00 :	  69488f:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  694892:       e8 79 c5 ff ff          callq  690e10 <FlagRWConflict>
    0.00 :	  694897:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  69489e:       00 00 
         :	        LWLockRelease(SerializableXactHashLock);
    0.00 :	  6948a0:       48 8b 3d 59 91 4e 00    mov    0x4e9159(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6948a7:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  6948ae:       e8 ed aa ff ff          callq  68f3a0 <LWLockRelease>
    0.00 :	  6948b3:       e9 e1 fd ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
         :	        /*
         :	         * If this is a read-only transaction and the writing transaction has
         :	         * committed, and it doesn't have a rw-conflict to a transaction which
         :	         * committed before it, no conflict.
         :	         */
         :	        if (SxactIsReadOnly(MySerializableXact)
    0.00 :	  6948b8:       f6 41 7c 20             testb  $0x20,0x7c(%rcx)
    0.00 :	  6948bc:       74 10                   je     6948ce <CheckForSerializableConflictOut+0x26e>
    0.00 :	  6948be:       89 d0                   mov    %edx,%eax
    0.00 :	  6948c0:       25 01 04 00 00          and    $0x401,%eax
    0.00 :	  6948c5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  6948c8:       0f 84 e9 01 00 00       je     694ab7 <CheckForSerializableConflictOut+0x457>
         :	        uint32          i;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :	        Assert(!TransactionIdEquals(xid, GetTopTransactionIdIfAny()));
         :
         :	        snap = GetTransactionSnapshot();
    0.00 :	  6948ce:       e8 3d 2d 11 00          callq  7a7610 <GetTransactionSnapshot>
         :
         :	        if (TransactionIdPrecedes(xid, snap->xmin))
    0.00 :	  6948d3:       8b 70 08                mov    0x8(%rax),%esi
    0.00 :	  6948d6:       89 df                   mov    %ebx,%edi
         :	        uint32          i;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :	        Assert(!TransactionIdEquals(xid, GetTopTransactionIdIfAny()));
         :
         :	        snap = GetTransactionSnapshot();
    0.00 :	  6948d8:       49 89 c5                mov    %rax,%r13
         :
         :	        if (TransactionIdPrecedes(xid, snap->xmin))
    0.00 :	  6948db:       e8 00 b7 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  6948e0:       84 c0                   test   %al,%al
    0.00 :	  6948e2:       75 bc                   jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :	                return false;
         :
         :	        if (TransactionIdFollowsOrEquals(xid, snap->xmax))
    0.00 :	  6948e4:       41 8b 75 0c             mov    0xc(%r13),%esi
    0.00 :	  6948e8:       89 df                   mov    %ebx,%edi
    0.00 :	  6948ea:       e8 81 b7 e2 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  6948ef:       84 c0                   test   %al,%al
    0.00 :	  6948f1:       75 82                   jne    694875 <CheckForSerializableConflictOut+0x215>
         :	                return true;
         :
         :	        for (i = 0; i < snap->xcnt; i++)
    0.00 :	  6948f3:       41 8b 75 18             mov    0x18(%r13),%esi
    0.00 :	  6948f7:       85 f6                   test   %esi,%esi
    0.00 :	  6948f9:       74 a5                   je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	        {
         :	                if (xid == snap->xip[i])
    0.00 :	  6948fb:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  6948ff:       31 d2                   xor    %edx,%edx
    0.00 :	  694901:       3b 18                   cmp    (%rax),%ebx
    0.00 :	  694903:       48 89 c1                mov    %rax,%rcx
    0.00 :	  694906:       75 17                   jne    69491f <CheckForSerializableConflictOut+0x2bf>
    0.00 :	  694908:       e9 68 ff ff ff          jmpq   694875 <CheckForSerializableConflictOut+0x215>
    0.00 :	  69490d:       0f 1f 00                nopl   (%rax)
    0.00 :	  694910:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  694913:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  694917:       39 c3                   cmp    %eax,%ebx
    0.00 :	  694919:       0f 84 56 ff ff ff       je     694875 <CheckForSerializableConflictOut+0x215>
         :	                return false;
         :
         :	        if (TransactionIdFollowsOrEquals(xid, snap->xmax))
         :	                return true;
         :
         :	        for (i = 0; i < snap->xcnt; i++)
    0.00 :	  69491f:       83 c2 01                add    $0x1,%edx
    0.00 :	  694922:       39 f2                   cmp    %esi,%edx
    0.00 :	  694924:       72 ea                   jb     694910 <CheckForSerializableConflictOut+0x2b0>
    0.00 :	  694926:       e9 75 ff ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  69492b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                return;
         :
         :	        /* Check if someone else has already decided that we need to die */
         :	        if (SxactIsDoomed(MySerializableXact))
         :	        {
         :	                ereport(ERROR,
    0.00 :	  694930:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694933:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694938:       ba 30 0f 00 00          mov    $0xf30,%edx
    0.00 :	  69493d:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694942:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694947:       e8 74 61 0e 00          callq  77aac0 <errstart>
    0.00 :	  69494c:       84 c0                   test   %al,%al
    0.00 :	  69494e:       0f 84 c5 fd ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694954:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694959:       31 c0                   xor    %eax,%eax
    0.00 :	  69495b:       e8 40 73 0e 00          callq  77bca0 <errhint>
    0.00 :	  694960:       bf 48 d8 8a 00          mov    $0x8ad848,%edi
    0.00 :	  694965:       41 89 c5                mov    %eax,%r13d
         :	                        return;
         :	                }
         :	                else
         :	                {
         :	                        LWLockRelease(SerializableXactHashLock);
         :	                        ereport(ERROR,
    0.00 :	  694968:       31 c0                   xor    %eax,%eax
    0.00 :	  69496a:       e8 11 7a 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  69496f:       89 c3                   mov    %eax,%ebx
    0.00 :	  694971:       bf 48 d3 8a 00          mov    $0x8ad348,%edi
    0.00 :	  694976:       31 c0                   xor    %eax,%eax
    0.00 :	  694978:       e8 23 7f 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  69497d:       bf 04 00 00 01          mov    $0x1000004,%edi
    0.00 :	  694982:       41 89 c4                mov    %eax,%r12d
    0.00 :	  694985:       e8 c6 83 0e 00          callq  77cd50 <errcode>
    0.00 :	  69498a:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  69498d:       89 c7                   mov    %eax,%edi
    0.00 :	  69498f:       89 da                   mov    %ebx,%edx
    0.00 :	  694991:       44 89 e6                mov    %r12d,%esi
    0.00 :	  694994:       31 c0                   xor    %eax,%eax
    0.00 :	  694996:       e8 45 5c 0e 00          callq  77a5e0 <errfinish>
    0.00 :	  69499b:       e9 79 fd ff ff          jmpq   694719 <CheckForSerializableConflictOut+0xb9>
         :	        SerCommitSeqNo val;
         :	        int                     slotno;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
    0.00 :	  6949a0:       48 8b 3d 59 90 4e 00    mov    0x4e9059(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6949a7:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  6949ac:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
    0.00 :	  6949b3:       e8 38 b1 ff ff          callq  68faf0 <LWLockAcquire>
         :	        headXid = oldSerXidControl->headXid;
    0.00 :	  6949b8:       48 8b 05 79 9d 4e 00    mov    0x4e9d79(%rip),%rax        # b7e738 <oldSerXidControl>
         :	        tailXid = oldSerXidControl->tailXid;
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949bf:       48 8b 3d 3a 90 4e 00    mov    0x4e903a(%rip),%rdi        # b7da00 <MainLWLockArray>
         :	        int                     slotno;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
         :	        headXid = oldSerXidControl->headXid;
    0.00 :	  6949c6:       44 8b 60 04             mov    0x4(%rax),%r12d
         :	        tailXid = oldSerXidControl->tailXid;
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949ca:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
         :	        headXid = oldSerXidControl->headXid;
         :	        tailXid = oldSerXidControl->tailXid;
    0.00 :	  6949d1:       44 8b 68 08             mov    0x8(%rax),%r13d
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949d5:       e8 c6 a9 ff ff          callq  68f3a0 <LWLockRelease>
         :
         :	        if (!TransactionIdIsValid(headXid))
    0.00 :	  6949da:       45 85 e4                test   %r12d,%r12d
    0.00 :	  6949dd:       0f 84 bd fe ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	                return 0;
         :
         :	        Assert(TransactionIdIsValid(tailXid));
         :
         :	        if (TransactionIdPrecedes(xid, tailXid)
    0.00 :	  6949e3:       44 89 ee                mov    %r13d,%esi
    0.00 :	  6949e6:       89 df                   mov    %ebx,%edi
    0.00 :	  6949e8:       e8 f3 b5 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  6949ed:       84 c0                   test   %al,%al
    0.00 :	  6949ef:       0f 85 ab fe ff ff       jne    6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  6949f5:       44 89 e6                mov    %r12d,%esi
    0.00 :	  6949f8:       89 df                   mov    %ebx,%edi
    0.00 :	  6949fa:       e8 41 b6 e2 ff          callq  4c0040 <TransactionIdFollows>
    0.00 :	  6949ff:       84 c0                   test   %al,%al
    0.00 :	  694a01:       0f 85 99 fe ff ff       jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :
         :	        /*
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
    0.00 :	  694a07:       89 de                   mov    %ebx,%esi
    0.00 :	  694a09:       89 da                   mov    %ebx,%edx
    0.00 :	  694a0b:       bf e0 e6 b7 00          mov    $0xb7e6e0,%edi
    0.00 :	  694a10:       c1 ee 0a                shr    $0xa,%esi
    0.00 :	  694a13:       81 e6 ff ff 1f 00       and    $0x1fffff,%esi
    0.00 :	  694a19:       e8 02 1a e3 ff          callq  4c6420 <SimpleLruReadPage_ReadOnly>
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a1e:       48 8b 15 bb 9c 4e 00    mov    0x4e9cbb(%rip),%rdx        # b7e6e0 <OldSerXidSlruCtlData>
    0.00 :	  694a25:       48 98                   cltq   
    0.00 :	  694a27:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  694a2a:       81 e1 ff 03 00 00       and    $0x3ff,%ecx
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a30:       48 8b 3d c9 8f 4e 00    mov    0x4e8fc9(%rip),%rdi        # b7da00 <MainLWLockArray>
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a37:       48 8b 52 10             mov    0x10(%rdx),%rdx
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a3b:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a42:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  694a46:       4c 8b 24 c8             mov    (%rax,%rcx,8),%r12
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a4a:       e8 51 a9 ff ff          callq  68f3a0 <LWLockRelease>
         :	                 * got pushed out to SLRU storage for "old committed" transactions.
         :	                 */
         :	                SerCommitSeqNo conflictCommitSeqNo;
         :
         :	                conflictCommitSeqNo = OldSerXidGetMinConflictCommitSeqNo(xid);
         :	                if (conflictCommitSeqNo != 0)
    0.00 :	  694a4f:       4d 85 e4                test   %r12,%r12
    0.00 :	  694a52:       0f 84 48 fe ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	                {
         :	                        if (conflictCommitSeqNo != InvalidSerCommitSeqNo
    0.00 :	  694a58:       49 83 fc ff             cmp    $0xffffffffffffffff,%r12
    0.00 :	  694a5c:       74 77                   je     694ad5 <CheckForSerializableConflictOut+0x475>
    0.00 :	  694a5e:       48 8b 05 5b 9c 4e 00    mov    0x4e9c5b(%rip),%rax        # b7e6c0 <MySerializableXact>
    0.00 :	  694a65:       f6 40 7c 20             testb  $0x20,0x7c(%rax)
    0.00 :	  694a69:       74 06                   je     694a71 <CheckForSerializableConflictOut+0x411>
    0.00 :	  694a6b:       4c 39 60 18             cmp    %r12,0x18(%rax)
    0.00 :	  694a6f:       72 6b                   jb     694adc <CheckForSerializableConflictOut+0x47c>
         :	                                && (!SxactIsReadOnly(MySerializableXact)
         :	                                        || conflictCommitSeqNo
         :	                                        <= MySerializableXact->SeqNo.lastCommitBeforeSnapshot))
         :	                                ereport(ERROR,
    0.00 :	  694a71:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694a74:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694a79:       ba 89 0f 00 00          mov    $0xf89,%edx
    0.00 :	  694a7e:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694a83:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694a88:       e8 33 60 0e 00          callq  77aac0 <errstart>
    0.00 :	  694a8d:       84 c0                   test   %al,%al
    0.00 :	  694a8f:       0f 84 84 fc ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694a95:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694a9a:       31 c0                   xor    %eax,%eax
    0.00 :	  694a9c:       e8 ff 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694aa1:       89 de                   mov    %ebx,%esi
    0.00 :	  694aa3:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694aa6:       bf e0 d8 8a 00          mov    $0x8ad8e0,%edi
    0.00 :	  694aab:       31 c0                   xor    %eax,%eax
    0.00 :	  694aad:       e8 ce 78 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  694ab2:       e9 b8 fe ff ff          jmpq   69496f <CheckForSerializableConflictOut+0x30f>
         :	        /*
         :	         * If this is a read-only transaction and the writing transaction has
         :	         * committed, and it doesn't have a rw-conflict to a transaction which
         :	         * committed before it, no conflict.
         :	         */
         :	        if (SxactIsReadOnly(MySerializableXact)
    0.00 :	  694ab7:       83 e2 10                and    $0x10,%edx
    0.00 :	  694aba:       0f 84 e0 fd ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  694ac0:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  694ac5:       48 39 41 18             cmp    %rax,0x18(%rcx)
    0.00 :	  694ac9:       0f 83 ff fd ff ff       jae    6948ce <CheckForSerializableConflictOut+0x26e>
    0.00 :	  694acf:       90                      nop
    0.00 :	  694ad0:       e9 cb fd ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  694ad5:       48 8b 05 e4 9b 4e 00    mov    0x4e9be4(%rip),%rax        # b7e6c0 <MySerializableXact>
         :	                                                (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
         :	                                                 errmsg("could not serialize access due to read/write dependencies among transactions"),
         :	                                                 errdetail_internal("Reason code: Canceled on conflict out to old pivot %u.", xid),
         :	                                          errhint("The transaction might succeed if retried.")));
         :
         :	                        if (SxactHasSummaryConflictIn(MySerializableXact)
    0.00 :	  694adc:       f6 40 7d 02             testb  $0x2,0x7d(%rax)
    0.00 :	  694ae0:       75 0d                   jne    694aef <CheckForSerializableConflictOut+0x48f>
    0.00 :	  694ae2:       48 8d 78 30             lea    0x30(%rax),%rdi
    0.00 :	  694ae6:       e8 25 ea fe ff          callq  683510 <SHMQueueEmpty>
    0.00 :	  694aeb:       84 c0                   test   %al,%al
    0.00 :	  694aed:       75 46                   jne    694b35 <CheckForSerializableConflictOut+0x4d5>
         :	                                || !SHMQueueEmpty(&MySerializableXact->inConflicts))
         :	                                ereport(ERROR,
    0.00 :	  694aef:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694af2:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694af7:       ba 91 0f 00 00          mov    $0xf91,%edx
    0.00 :	  694afc:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694b01:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694b06:       e8 b5 5f 0e 00          callq  77aac0 <errstart>
    0.00 :	  694b0b:       84 c0                   test   %al,%al
    0.00 :	  694b0d:       0f 84 06 fc ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694b13:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694b18:       31 c0                   xor    %eax,%eax
    0.00 :	  694b1a:       e8 81 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694b1f:       89 de                   mov    %ebx,%esi
    0.00 :	  694b21:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694b24:       bf 18 d9 8a 00          mov    $0x8ad918,%edi
    0.00 :	  694b29:       31 c0                   xor    %eax,%eax
    0.00 :	  694b2b:       e8 50 78 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  694b30:       e9 3a fe ff ff          jmpq   69496f <CheckForSerializableConflictOut+0x30f>
         :	                                                (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
         :	                                                 errmsg("could not serialize access due to read/write dependencies among transactions"),
         :	                                                 errdetail_internal("Reason code: Canceled on identification as a pivot, with conflict out to old committed transaction %u.", xid),
         :	                                          errhint("The transaction might succeed if retried.")));
         :
         :	                        MySerializableXact->flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;
    0.00 :	  694b35:       48 8b 05 84 9b 4e 00    mov    0x4e9b84(%rip),%rax        # b7e6c0 <MySerializableXact>
    0.00 :	  694b3c:       81 48 7c 00 04 00 00    orl    $0x400,0x7c(%rax)
    0.00 :	  694b43:       e9 58 fd ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
         :	                        LWLockRelease(SerializableXactHashLock);
         :	                        return;
         :	                }
         :	                else
         :	                {
         :	                        LWLockRelease(SerializableXactHashLock);
    0.00 :	  694b48:       48 8b 3d b1 8e 4e 00    mov    0x4e8eb1(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  694b4f:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  694b56:       e8 45 a8 ff ff          callq  68f3a0 <LWLockRelease>
         :	                        ereport(ERROR,
    0.00 :	  694b5b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694b5e:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694b63:       ba b8 0f 00 00          mov    $0xfb8,%edx
    0.00 :	  694b68:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694b6d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694b72:       e8 49 5f 0e 00          callq  77aac0 <errstart>
    0.00 :	  694b77:       84 c0                   test   %al,%al
    0.00 :	  694b79:       0f 84 9a fb ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694b7f:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694b84:       31 c0                   xor    %eax,%eax
    0.00 :	  694b86:       e8 15 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694b8b:       bf 80 d9 8a 00          mov    $0x8ad980,%edi
    0.00 :	  694b90:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694b93:       e9 d0 fd ff ff          jmpq   694968 <CheckForSerializableConflictOut+0x308>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:748
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:738
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000758160 <bpcharne>:
         :	        PG_RETURN_BOOL(result);
         :	}
         :
         :	Datum
         :	bpcharne(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  758160:       55                      push   %rbp
    0.00 :	  758161:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  758164:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  758168:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  75816c:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  758170:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  758174:       49 89 fd                mov    %rdi,%r13
    0.00 :	  758177:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  75817b:       48 83 ec 30             sub    $0x30,%rsp
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  75817f:       48 8b 7f 20             mov    0x20(%rdi),%rdi
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  758183:       41 be 01 00 00 00       mov    $0x1,%r14d
         :	}
         :
         :	Datum
         :	bpcharne(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  758189:       e8 52 6b 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75818e:       49 8b 7d 28             mov    0x28(%r13),%rdi
         :	}
         :
         :	Datum
         :	bpcharne(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
    0.00 :	  758192:       49 89 c4                mov    %rax,%r12
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  758195:       e8 46 6b 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
   33.33 :	  75819a:       4c 89 e7                mov    %r12,%rdi
         :
         :	Datum
         :	bpcharne(PG_FUNCTION_ARGS)
         :	{
         :	        BpChar     *arg1 = PG_GETARG_BPCHAR_PP(0);
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
    0.00 :	  75819d:       48 89 c3                mov    %rax,%rbx
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  7581a0:       e8 eb fb ff ff          callq  757d90 <bcTruelen>
         :	        len2 = bcTruelen(arg2);
    0.00 :	  7581a5:       48 89 df                mov    %rbx,%rdi
         :	        BpChar     *arg2 = PG_GETARG_BPCHAR_PP(1);
         :	        int                     len1,
         :	                                len2;
         :	        bool            result;
         :
         :	        len1 = bcTruelen(arg1);
    0.00 :	  7581a8:       41 89 c7                mov    %eax,%r15d
         :	        len2 = bcTruelen(arg2);
    0.00 :	  7581ab:       e8 e0 fb ff ff          callq  757d90 <bcTruelen>
         :
         :	        /*
         :	         * Since we only care about equality or not-equality, we can avoid all the
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
    0.00 :	  7581b0:       41 39 c7                cmp    %eax,%r15d
    0.00 :	  7581b3:       74 3b                   je     7581f0 <bpcharne+0x90>
         :	                result = true;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) != 0);
         :
         :	        PG_FREE_IF_COPY(arg1, 0);
    0.00 :	  7581b5:       4d 3b 65 20             cmp    0x20(%r13),%r12
    0.00 :	  7581b9:       74 0a                   je     7581c5 <bpcharne+0x65>
    0.00 :	  7581bb:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7581be:       66 90                   xchg   %ax,%ax
    0.00 :	  7581c0:       e8 bb 09 04 00          callq  798b80 <pfree>
         :	        PG_FREE_IF_COPY(arg2, 1);
    0.00 :	  7581c5:       49 3b 5d 28             cmp    0x28(%r13),%rbx
    0.00 :	  7581c9:       74 08                   je     7581d3 <bpcharne+0x73>
    0.00 :	  7581cb:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7581ce:       e8 ad 09 04 00          callq  798b80 <pfree>
         :
         :	        PG_RETURN_BOOL(result);
         :	}
    0.00 :	  7581d3:       4c 89 f0                mov    %r14,%rax
    0.00 :	  7581d6:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  7581da:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  7581de:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  7581e2:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  7581e6:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  7581ea:       c9                      leaveq 
    0.00 :	  7581eb:       c3                      retq   
    0.00 :	  7581ec:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * expense of strcoll() here, and just do bitwise comparison.
         :	         */
         :	        if (len1 != len2)
         :	                result = true;
         :	        else
         :	                result = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) != 0);
    0.00 :	  7581f0:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  7581f3:       48 8d 43 04             lea    0x4(%rbx),%rax
    0.00 :	  7581f7:       48 8d 7b 01             lea    0x1(%rbx),%rdi
    0.00 :	  7581fb:       49 8d 74 24 01          lea    0x1(%r12),%rsi
    0.00 :	  758200:       49 63 cf                movslq %r15d,%rcx
    0.00 :	  758203:       48 0f 44 f8             cmove  %rax,%rdi
    0.00 :	  758207:       41 f6 04 24 01          testb  $0x1,(%r12)
    0.00 :	  75820c:       49 8d 44 24 04          lea    0x4(%r12),%rax
    0.00 :	  758211:       48 0f 44 f0             cmove  %rax,%rsi
    0.00 :	  758215:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  758218:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:748
   66.67 :	  75821a:       0f 97 c2                seta   %dl
    0.00 :	  75821d:       0f 92 c0                setb   %al
    0.00 :	  758220:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  758223:       38 c2                   cmp    %al,%dl
    0.00 :	  758225:       41 0f 95 c6             setne  %r14b
    0.00 :	  758229:       eb 8a                   jmp    7581b5 <bpcharne+0x55>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1581
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1612
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1604
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000075e600 <texteq>:
         :	 * need to be so careful.
         :	 */
         :
         :	Datum
         :	texteq(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  75e600:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1581
   33.33 :	  75e601:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  75e604:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  75e608:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  75e60c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  75e60f:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  75e613:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  75e617:       48 83 ec 20             sub    $0x20,%rsp
         :	        Datum           arg1 = PG_GETARG_DATUM(0);
    0.00 :	  75e61b:       48 8b 5f 20             mov    0x20(%rdi),%rbx
         :	        Datum           arg2 = PG_GETARG_DATUM(1);
    0.00 :	  75e61f:       4c 8b 6f 28             mov    0x28(%rdi),%r13
         :	         * expense of strcoll() here, and just do bitwise comparison.  In fact, we
         :	         * don't even have to do a bitwise comparison if we can show the lengths
         :	         * of the strings are unequal; which might save us from having to detoast
         :	         * one or both values.
         :	         */
         :	        len1 = toast_raw_datum_size(arg1);
    0.00 :	  75e623:       48 89 df                mov    %rbx,%rdi
    0.00 :	  75e626:       e8 75 2e d4 ff          callq  4a14a0 <toast_raw_datum_size>
         :	        len2 = toast_raw_datum_size(arg2);
    0.00 :	  75e62b:       4c 89 ef                mov    %r13,%rdi
         :	         * expense of strcoll() here, and just do bitwise comparison.  In fact, we
         :	         * don't even have to do a bitwise comparison if we can show the lengths
         :	         * of the strings are unequal; which might save us from having to detoast
         :	         * one or both values.
         :	         */
         :	        len1 = toast_raw_datum_size(arg1);
    0.00 :	  75e62e:       49 89 c6                mov    %rax,%r14
         :	        len2 = toast_raw_datum_size(arg2);
    0.00 :	  75e631:       e8 6a 2e d4 ff          callq  4a14a0 <toast_raw_datum_size>
         :	        if (len1 != len2)
    0.00 :	  75e636:       31 d2                   xor    %edx,%edx
    0.00 :	  75e638:       49 39 c6                cmp    %rax,%r14
    0.00 :	  75e63b:       74 1b                   je     75e658 <texteq+0x58>
         :	                PG_FREE_IF_COPY(targ1, 0);
         :	                PG_FREE_IF_COPY(targ2, 1);
         :	        }
         :
         :	        PG_RETURN_BOOL(result);
         :	}
    0.00 :	  75e63d:       48 89 d0                mov    %rdx,%rax
    0.00 :	  75e640:       48 8b 1c 24             mov    (%rsp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1612
   33.33 :	  75e644:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  75e649:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  75e64e:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  75e653:       c9                      leaveq 
    0.00 :	  75e654:       c3                      retq   
    0.00 :	  75e655:       0f 1f 00                nopl   (%rax)
         :	        len2 = toast_raw_datum_size(arg2);
         :	        if (len1 != len2)
         :	                result = false;
         :	        else
         :	        {
         :	                text       *targ1 = DatumGetTextPP(arg1);
    0.00 :	  75e658:       48 89 df                mov    %rbx,%rdi
    0.00 :	  75e65b:       e8 80 06 02 00          callq  77ece0 <pg_detoast_datum_packed>
         :	                text       *targ2 = DatumGetTextPP(arg2);
    0.00 :	  75e660:       4c 89 ef                mov    %r13,%rdi
         :	        len2 = toast_raw_datum_size(arg2);
         :	        if (len1 != len2)
         :	                result = false;
         :	        else
         :	        {
         :	                text       *targ1 = DatumGetTextPP(arg1);
    0.00 :	  75e663:       48 89 c3                mov    %rax,%rbx
         :	                text       *targ2 = DatumGetTextPP(arg2);
    0.00 :	  75e666:       e8 75 06 02 00          callq  77ece0 <pg_detoast_datum_packed>
    0.00 :	  75e66b:       49 89 c5                mov    %rax,%r13
         :
         :	                result = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),
    0.00 :	  75e66e:       48 8d 78 01             lea    0x1(%rax),%rdi
    0.00 :	  75e672:       48 8d 40 04             lea    0x4(%rax),%rax
    0.00 :	  75e676:       41 f6 45 00 01          testb  $0x1,0x0(%r13)
    0.00 :	  75e67b:       49 8d 4e fc             lea    -0x4(%r14),%rcx
    0.00 :	  75e67f:       48 8d 73 01             lea    0x1(%rbx),%rsi
    0.00 :	  75e683:       48 0f 44 f8             cmove  %rax,%rdi
    0.00 :	  75e687:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  75e68a:       48 8d 43 04             lea    0x4(%rbx),%rax
    0.00 :	  75e68e:       48 0f 44 f0             cmove  %rax,%rsi
    0.00 :	  75e692:       48 39 c9                cmp    %rcx,%rcx
    0.00 :	  75e695:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varlena.c:1604
   33.33 :	  75e697:       41 0f 94 c6             sete   %r14b
         :	                                                 len1 - VARHDRSZ) == 0);
         :
         :	                PG_FREE_IF_COPY(targ1, 0);
    0.00 :	  75e69b:       49 3b 5c 24 20          cmp    0x20(%r12),%rbx
    0.00 :	  75e6a0:       74 08                   je     75e6aa <texteq+0xaa>
    0.00 :	  75e6a2:       48 89 df                mov    %rbx,%rdi
    0.00 :	  75e6a5:       e8 d6 a4 03 00          callq  798b80 <pfree>
         :	                PG_FREE_IF_COPY(targ2, 1);
    0.00 :	  75e6aa:       4d 3b 6c 24 28          cmp    0x28(%r12),%r13
    0.00 :	  75e6af:       74 08                   je     75e6b9 <texteq+0xb9>
    0.00 :	  75e6b1:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  75e6b4:       e8 c7 a4 03 00          callq  798b80 <pfree>
    0.00 :	  75e6b9:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  75e6bc:       83 e2 01                and    $0x1,%edx
    0.00 :	  75e6bf:       e9 79 ff ff ff          jmpq   75e63d <texteq+0x3d>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2901
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2917
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a0920 <copytup_heap>:
         :	        return 0;
         :	}
         :
         :	static void
         :	copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup)
         :	{
    0.00 :	  7a0920:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2901
   66.67 :	  7a0921:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7a0924:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  7a0928:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  7a092c:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7a0930:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7a0934:       49 89 fd                mov    %rdi,%r13
    0.00 :	  7a0937:       48 83 ec 40             sub    $0x40,%rsp
    0.00 :	  7a093b:       49 89 f6                mov    %rsi,%r14
    0.00 :	  7a093e:       48 89 d7                mov    %rdx,%rdi
         :	        TupleTableSlot *slot = (TupleTableSlot *) tup;
         :	        MinimalTuple tuple;
         :	        HeapTupleData htup;
         :
         :	        /* copy the tuple into sort storage */
         :	        tuple = ExecCopySlotMinimalTuple(slot);
    0.00 :	  7a0941:       e8 ba 35 e1 ff          callq  5b3f00 <ExecCopySlotMinimalTuple>
         :	        stup->tuple = (void *) tuple;
    0.00 :	  7a0946:       49 89 06                mov    %rax,(%r14)
         :	        USEMEM(state, GetMemoryChunkSpace(tuple));
    0.00 :	  7a0949:       49 8b 5d 10             mov    0x10(%r13),%rbx
    0.00 :	  7a094d:       48 89 c7                mov    %rax,%rdi
         :	        TupleTableSlot *slot = (TupleTableSlot *) tup;
         :	        MinimalTuple tuple;
         :	        HeapTupleData htup;
         :
         :	        /* copy the tuple into sort storage */
         :	        tuple = ExecCopySlotMinimalTuple(slot);
    0.00 :	  7a0950:       49 89 c4                mov    %rax,%r12
         :	        stup->tuple = (void *) tuple;
         :	        USEMEM(state, GetMemoryChunkSpace(tuple));
    0.00 :	  7a0953:       e8 38 81 ff ff          callq  798a90 <GetMemoryChunkSpace>
    0.00 :	  7a0958:       48 29 c3                sub    %rax,%rbx
    0.00 :	  7a095b:       49 89 5d 10             mov    %rbx,0x10(%r13)
         :	        /* set up first-column key value */
         :	        htup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  7a095f:       41 8b 04 24             mov    (%r12),%eax
         :	        htup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);
    0.00 :	  7a0963:       49 83 ec 08             sub    $0x8,%r12
    0.00 :	  7a0967:       4c 89 65 d0             mov    %r12,-0x30(%rbp)
         :	        /* copy the tuple into sort storage */
         :	        tuple = ExecCopySlotMinimalTuple(slot);
         :	        stup->tuple = (void *) tuple;
         :	        USEMEM(state, GetMemoryChunkSpace(tuple));
         :	        /* set up first-column key value */
         :	        htup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  7a096b:       83 c0 08                add    $0x8,%eax
    0.00 :	  7a096e:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	        htup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);
         :	        stup->datum1 = heap_getattr(&htup,
    0.00 :	  7a0971:       49 8b 85 f8 00 00 00    mov    0xf8(%r13),%rax
    0.00 :	  7a0978:       0f b7 40 0e             movzwl 0xe(%rax),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:2917
   33.33 :	  7a097c:       66 85 c0                test   %ax,%ax
    0.00 :	  7a097f:       0f 8e eb 00 00 00       jle    7a0a70 <copytup_heap+0x150>
    0.00 :	  7a0985:       0f bf d0                movswl %ax,%edx
    0.00 :	  7a0988:       41 0f b7 44 24 12       movzwl 0x12(%r12),%eax
    0.00 :	  7a098e:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  7a0993:       39 c2                   cmp    %eax,%edx
    0.00 :	  7a0995:       7e 21                   jle    7a09b8 <copytup_heap+0x98>
    0.00 :	  7a0997:       41 c6 46 10 01          movb   $0x1,0x10(%r14)
    0.00 :	  7a099c:       31 c0                   xor    %eax,%eax
    0.00 :	  7a099e:       49 89 46 08             mov    %rax,0x8(%r14)
         :	                                                                state->sortKeys[0].ssup_attno,
         :	                                                                state->tupDesc,
         :	                                                                &stup->isnull1);
         :	}
    0.00 :	  7a09a2:       48 8b 5d e0             mov    -0x20(%rbp),%rbx
    0.00 :	  7a09a6:       4c 8b 65 e8             mov    -0x18(%rbp),%r12
    0.00 :	  7a09aa:       4c 8b 6d f0             mov    -0x10(%rbp),%r13
    0.00 :	  7a09ae:       4c 8b 75 f8             mov    -0x8(%rbp),%r14
    0.00 :	  7a09b2:       c9                      leaveq 
    0.00 :	  7a09b3:       c3                      retq   
    0.00 :	  7a09b4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        stup->tuple = (void *) tuple;
         :	        USEMEM(state, GetMemoryChunkSpace(tuple));
         :	        /* set up first-column key value */
         :	        htup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;
         :	        htup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);
         :	        stup->datum1 = heap_getattr(&htup,
    0.00 :	  7a09b8:       41 c6 46 10 00          movb   $0x0,0x10(%r14)
    0.00 :	  7a09bd:       41 f6 44 24 14 01       testb  $0x1,0x14(%r12)
    0.00 :	  7a09c3:       75 6b                   jne    7a0a30 <copytup_heap+0x110>
    0.00 :	  7a09c5:       49 8b 85 f8 00 00 00    mov    0xf8(%r13),%rax
    0.00 :	  7a09cc:       4d 8b 85 f0 00 00 00    mov    0xf0(%r13),%r8
    0.00 :	  7a09d3:       0f b7 48 0e             movzwl 0xe(%rax),%ecx
    0.00 :	  7a09d7:       49 8b 40 08             mov    0x8(%r8),%rax
    0.00 :	  7a09db:       48 0f bf d1             movswq %cx,%rdx
    0.00 :	  7a09df:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    0.00 :	  7a09e4:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  7a09e7:       85 c0                   test   %eax,%eax
    0.00 :	  7a09e9:       0f 88 b9 00 00 00       js     7a0aa8 <copytup_heap+0x188>
    0.00 :	  7a09ef:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  7a09f3:       0f 84 97 00 00 00       je     7a0a90 <copytup_heap+0x170>
    0.00 :	  7a09f9:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  7a09fd:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  7a0a01:       0f 84 d1 00 00 00       je     7a0ad8 <copytup_heap+0x1b8>
    0.00 :	  7a0a07:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  7a0a0b:       0f 84 af 00 00 00       je     7a0ac0 <copytup_heap+0x1a0>
    0.00 :	  7a0a11:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  7a0a15:       0f 84 d5 00 00 00       je     7a0af0 <copytup_heap+0x1d0>
    0.00 :	  7a0a1b:       41 0f b6 54 24 16       movzbl 0x16(%r12),%edx
    0.00 :	  7a0a21:       48 98                   cltq   
    0.00 :	  7a0a23:       49 8d 04 04             lea    (%r12,%rax,1),%rax
    0.00 :	  7a0a27:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  7a0a2b:       e9 6e ff ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0a30:       49 8b 85 f8 00 00 00    mov    0xf8(%r13),%rax
    0.00 :	  7a0a37:       0f bf 70 0e             movswl 0xe(%rax),%esi
    0.00 :	  7a0a3b:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  7a0a3e:       89 c8                   mov    %ecx,%eax
    0.00 :	  7a0a40:       83 e1 07                and    $0x7,%ecx
    0.00 :	  7a0a43:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  7a0a46:       48 98                   cltq   
    0.00 :	  7a0a48:       41 0f b6 44 04 17       movzbl 0x17(%r12,%rax,1),%eax
    0.00 :	  7a0a4e:       d3 f8                   sar    %cl,%eax
    0.00 :	  7a0a50:       a8 01                   test   $0x1,%al
    0.00 :	  7a0a52:       0f 84 3f ff ff ff       je     7a0997 <copytup_heap+0x77>
    0.00 :	  7a0a58:       49 8b 95 f0 00 00 00    mov    0xf0(%r13),%rdx
    0.00 :	  7a0a5f:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
    0.00 :	  7a0a63:       e8 28 ef cc ff          callq  46f990 <nocachegetattr>
    0.00 :	  7a0a68:       e9 31 ff ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0a6d:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a0a70:       49 8b 95 f0 00 00 00    mov    0xf0(%r13),%rdx
    0.00 :	  7a0a77:       49 8d 4e 10             lea    0x10(%r14),%rcx
    0.00 :	  7a0a7b:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
    0.00 :	  7a0a7f:       0f bf f0                movswl %ax,%esi
    0.00 :	  7a0a82:       e8 49 e2 cc ff          callq  46ecd0 <heap_getsysattr>
    0.00 :	  7a0a87:       e9 12 ff ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0a8c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a0a90:       41 0f b6 54 24 16       movzbl 0x16(%r12),%edx
    0.00 :	  7a0a96:       48 98                   cltq   
    0.00 :	  7a0a98:       48 01 d0                add    %rdx,%rax
    0.00 :	  7a0a9b:       49 8d 04 04             lea    (%r12,%rax,1),%rax
    0.00 :	  7a0a9f:       e9 fa fe ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0aa4:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a0aa8:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
    0.00 :	  7a0aac:       0f bf f1                movswl %cx,%esi
    0.00 :	  7a0aaf:       4c 89 c2                mov    %r8,%rdx
    0.00 :	  7a0ab2:       e8 d9 ee cc ff          callq  46f990 <nocachegetattr>
    0.00 :	  7a0ab7:       e9 e2 fe ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0abc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a0ac0:       41 0f b6 54 24 16       movzbl 0x16(%r12),%edx
    0.00 :	  7a0ac6:       48 98                   cltq   
    0.00 :	  7a0ac8:       49 8d 04 04             lea    (%r12,%rax,1),%rax
    0.00 :	  7a0acc:       8b 04 10                mov    (%rax,%rdx,1),%eax
    0.00 :	  7a0acf:       e9 ca fe ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0ad4:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7a0ad8:       41 0f b6 54 24 16       movzbl 0x16(%r12),%edx
    0.00 :	  7a0ade:       48 98                   cltq   
    0.00 :	  7a0ae0:       49 8d 04 04             lea    (%r12,%rax,1),%rax
    0.00 :	  7a0ae4:       48 8b 04 10             mov    (%rax,%rdx,1),%rax
    0.00 :	  7a0ae8:       e9 b1 fe ff ff          jmpq   7a099e <copytup_heap+0x7e>
    0.00 :	  7a0aed:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a0af0:       41 0f b6 54 24 16       movzbl 0x16(%r12),%edx
    0.00 :	  7a0af6:       48 98                   cltq   
    0.00 :	  7a0af8:       49 8d 04 04             lea    (%r12,%rax,1),%rax
    0.00 :	  7a0afc:       0f b7 04 10             movzwl (%rax,%rdx,1),%eax
    0.00 :	  7a0b00:       e9 99 fe ff ff          jmpq   7a099e <copytup_heap+0x7e>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   33.33 ??:0
   33.33 ??:0
   33.33 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000099390 <__gettimeofday>:
    0.00 :	   99390:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   99394:       48 8b 05 ad de 2d 00    mov    0x2ddead(%rip),%rax        # 377248 <__vdso_gettimeofday>
    0.00 :	   9939b:       48 c1 c8 11             ror    $0x11,%rax
 ??:0
   33.33 :	   9939f:       64 48 33 04 25 30 00    xor    %fs:0x30,%rax
    0.00 :	   993a6:       00 00 
   33.33 :	   993a8:       ff d0                   callq  *%rax
   33.33 :	   993aa:       3d 01 f0 ff ff          cmp    $0xfffff001,%eax
    0.00 :	   993af:       73 05                   jae    993b6 <__gettimeofday+0x26>
    0.00 :	   993b1:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   993b5:       c3                      retq   
    0.00 :	   993b6:       48 8b 0d 7b 8a 2d 00    mov    0x2d8a7b(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   993bd:       31 d2                   xor    %edx,%edx
    0.00 :	   993bf:       48 29 c2                sub    %rax,%rdx
    0.00 :	   993c2:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   993c5:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   993c9:       eb e6                   jmp    993b1 <__gettimeofday+0x21>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1407
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1445
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004704e0 <heap_form_minimal_tuple>:
         :	 */
         :	MinimalTuple
         :	heap_form_minimal_tuple(TupleDesc tupleDescriptor,
         :	                                                Datum *values,
         :	                                                bool *isnull)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1407
   50.00 :	  4704e0:       55                      push   %rbp
    0.00 :	  4704e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4704e4:       41 57                   push   %r15
    0.00 :	  4704e6:       49 89 d7                mov    %rdx,%r15
    0.00 :	  4704e9:       41 56                   push   %r14
    0.00 :	  4704eb:       49 89 fe                mov    %rdi,%r14
    0.00 :	  4704ee:       41 55                   push   %r13
    0.00 :	  4704f0:       41 54                   push   %r12
    0.00 :	  4704f2:       53                      push   %rbx
    0.00 :	  4704f3:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	  4704f7:       48 89 75 c0             mov    %rsi,-0x40(%rbp)
         :	        MinimalTuple tuple;                     /* return tuple */
         :	        Size            len,
         :	                                data_len;
         :	        int                     hoff;
         :	        bool            hasnull = false;
         :	        int                     numberOfAttributes = tupleDescriptor->natts;
    0.00 :	  4704fb:       44 8b 2f                mov    (%rdi),%r13d
         :	        int                     i;
         :
         :	        if (numberOfAttributes > MaxTupleAttributeNumber)
    0.00 :	  4704fe:       41 81 fd 80 06 00 00    cmp    $0x680,%r13d
    0.00 :	  470505:       0f 8f fb 00 00 00       jg     470606 <heap_form_minimal_tuple+0x126>
         :	                                                numberOfAttributes, MaxTupleAttributeNumber)));
         :
         :	        /*
         :	         * Check for nulls
         :	         */
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  47050b:       45 85 ed                test   %r13d,%r13d
    0.00 :	  47050e:       7e 28                   jle    470538 <heap_form_minimal_tuple+0x58>
         :	        {
         :	                if (isnull[i])
    0.00 :	  470510:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  470513:       31 d2                   xor    %edx,%edx
    0.00 :	  470515:       41 80 3f 00             cmpb   $0x0,(%r15)
    0.00 :	  470519:       74 15                   je     470530 <heap_form_minimal_tuple+0x50>
    0.00 :	  47051b:       e9 d0 00 00 00          jmpq   4705f0 <heap_form_minimal_tuple+0x110>
    0.00 :	  470520:       0f b6 41 01             movzbl 0x1(%rcx),%eax
    0.00 :	  470524:       48 83 c1 01             add    $0x1,%rcx
    0.00 :	  470528:       84 c0                   test   %al,%al
    0.00 :	  47052a:       0f 85 c0 00 00 00       jne    4705f0 <heap_form_minimal_tuple+0x110>
         :	                                                numberOfAttributes, MaxTupleAttributeNumber)));
         :
         :	        /*
         :	         * Check for nulls
         :	         */
         :	        for (i = 0; i < numberOfAttributes; i++)
    0.00 :	  470530:       83 c2 01                add    $0x1,%edx
    0.00 :	  470533:       41 39 d5                cmp    %edx,%r13d
    0.00 :	  470536:       7f e8                   jg     470520 <heap_form_minimal_tuple+0x40>
         :	         * Determine total space needed
         :	         */
         :	        len = offsetof(MinimalTupleData, t_bits);
         :
         :	        if (hasnull)
         :	                len += BITMAPLEN(numberOfAttributes);
    0.00 :	  470538:       ba 0f 00 00 00          mov    $0xf,%edx
    0.00 :	  47053d:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
         :
         :	        if (tupleDescriptor->tdhasoid)
         :	                len += sizeof(Oid);
    0.00 :	  470541:       41 80 7e 20 00          cmpb   $0x0,0x20(%r14)
    0.00 :	  470546:       48 8d 42 04             lea    0x4(%rdx),%rax
         :
         :	        hoff = len = MAXALIGN(len); /* align user data safely */
         :
         :	        data_len = heap_compute_data_size(tupleDescriptor, values, isnull);
    0.00 :	  47054a:       48 8b 75 c0             mov    -0x40(%rbp),%rsi
    0.00 :	  47054e:       4c 89 f7                mov    %r14,%rdi
         :
         :	        if (hasnull)
         :	                len += BITMAPLEN(numberOfAttributes);
         :
         :	        if (tupleDescriptor->tdhasoid)
         :	                len += sizeof(Oid);
    0.00 :	  470551:       48 0f 45 d0             cmovne %rax,%rdx
         :
         :	        hoff = len = MAXALIGN(len); /* align user data safely */
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1445
   50.00 :	  470555:       48 8d 5a 07             lea    0x7(%rdx),%rbx
         :
         :	        data_len = heap_compute_data_size(tupleDescriptor, values, isnull);
    0.00 :	  470559:       4c 89 fa                mov    %r15,%rdx
         :	                len += BITMAPLEN(numberOfAttributes);
         :
         :	        if (tupleDescriptor->tdhasoid)
         :	                len += sizeof(Oid);
         :
         :	        hoff = len = MAXALIGN(len); /* align user data safely */
    0.00 :	  47055c:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  470560:       89 5d d0                mov    %ebx,-0x30(%rbp)
         :
         :	        data_len = heap_compute_data_size(tupleDescriptor, values, isnull);
    0.00 :	  470563:       e8 08 fe ff ff          callq  470370 <heap_compute_data_size>
         :
         :	        len += data_len;
    0.00 :	  470568:       48 01 c3                add    %rax,%rbx
         :	        if (tupleDescriptor->tdhasoid)
         :	                len += sizeof(Oid);
         :
         :	        hoff = len = MAXALIGN(len); /* align user data safely */
         :
         :	        data_len = heap_compute_data_size(tupleDescriptor, values, isnull);
    0.00 :	  47056b:       48 89 45 c8             mov    %rax,-0x38(%rbp)
         :	        len += data_len;
         :
         :	        /*
         :	         * Allocate and zero the space needed.
         :	         */
         :	        tuple = (MinimalTuple) palloc0(len);
    0.00 :	  47056f:       48 89 df                mov    %rbx,%rdi
    0.00 :	  470572:       e8 f9 89 32 00          callq  798f70 <palloc0>
         :
         :	        /*
         :	         * And fill in the information.
         :	         */
         :	        tuple->t_len = len;
    0.00 :	  470577:       89 18                   mov    %ebx,(%rax)
         :	        len += data_len;
         :
         :	        /*
         :	         * Allocate and zero the space needed.
         :	         */
         :	        tuple = (MinimalTuple) palloc0(len);
    0.00 :	  470579:       49 89 c4                mov    %rax,%r12
         :
         :	        /*
         :	         * And fill in the information.
         :	         */
         :	        tuple->t_len = len;
         :	        HeapTupleHeaderSetNatts(tuple, numberOfAttributes);
    0.00 :	  47057c:       0f b7 40 0a             movzwl 0xa(%rax),%eax
    0.00 :	  470580:       66 25 00 f8             and    $0xf800,%ax
    0.00 :	  470584:       44 09 e8                or     %r13d,%eax
    0.00 :	  470587:       66 41 89 44 24 0a       mov    %ax,0xa(%r12)
         :	        tuple->t_hoff = hoff + MINIMAL_TUPLE_OFFSET;
    0.00 :	  47058d:       0f b6 45 d0             movzbl -0x30(%rbp),%eax
    0.00 :	  470591:       83 c0 08                add    $0x8,%eax
    0.00 :	  470594:       41 88 44 24 0e          mov    %al,0xe(%r12)
         :
         :	        if (tupleDescriptor->tdhasoid)          /* else leave infomask = 0 */
    0.00 :	  470599:       41 80 7e 20 00          cmpb   $0x0,0x20(%r14)
    0.00 :	  47059e:       74 08                   je     4705a8 <heap_form_minimal_tuple+0xc8>
         :	                tuple->t_infomask = HEAP_HASOID;
    0.00 :	  4705a0:       66 41 c7 44 24 0c 08    movw   $0x8,0xc(%r12)
    0.00 :	  4705a7:       00 
         :
         :	        heap_fill_tuple(tupleDescriptor,
    0.00 :	  4705a8:       48 63 4d d0             movslq -0x30(%rbp),%rcx
    0.00 :	  4705ac:       31 d2                   xor    %edx,%edx
    0.00 :	  4705ae:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  4705b2:       49 8d 44 24 0f          lea    0xf(%r12),%rax
    0.00 :	  4705b7:       4c 8b 45 c8             mov    -0x38(%rbp),%r8
    0.00 :	  4705bb:       48 8b 75 c0             mov    -0x40(%rbp),%rsi
    0.00 :	  4705bf:       4d 8d 4c 24 0c          lea    0xc(%r12),%r9
    0.00 :	  4705c4:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4705c7:       48 0f 45 d0             cmovne %rax,%rdx
    0.00 :	  4705cb:       49 8d 0c 0c             lea    (%r12,%rcx,1),%rcx
    0.00 :	  4705cf:       48 89 14 24             mov    %rdx,(%rsp)
    0.00 :	  4705d3:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  4705d6:       e8 85 f9 ff ff          callq  46ff60 <heap_fill_tuple>
         :	                                        data_len,
         :	                                        &tuple->t_infomask,
         :	                                        (hasnull ? tuple->t_bits : NULL));
         :
         :	        return tuple;
         :	}
    0.00 :	  4705db:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  4705df:       4c 89 e0                mov    %r12,%rax
    0.00 :	  4705e2:       5b                      pop    %rbx
    0.00 :	  4705e3:       41 5c                   pop    %r12
    0.00 :	  4705e5:       41 5d                   pop    %r13
    0.00 :	  4705e7:       41 5e                   pop    %r14
    0.00 :	  4705e9:       41 5f                   pop    %r15
    0.00 :	  4705eb:       c9                      leaveq 
    0.00 :	  4705ec:       c3                      retq   
    0.00 :	  4705ed:       0f 1f 00                nopl   (%rax)
         :	         * Determine total space needed
         :	         */
         :	        len = offsetof(MinimalTupleData, t_bits);
         :
         :	        if (hasnull)
         :	                len += BITMAPLEN(numberOfAttributes);
    0.00 :	  4705f0:       41 8d 45 07             lea    0x7(%r13),%eax
    0.00 :	  4705f4:       c6 45 d7 01             movb   $0x1,-0x29(%rbp)
    0.00 :	  4705f8:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4705fb:       48 98                   cltq   
    0.00 :	  4705fd:       48 8d 50 0f             lea    0xf(%rax),%rdx
    0.00 :	  470601:       e9 3b ff ff ff          jmpq   470541 <heap_form_minimal_tuple+0x61>
         :	        bool            hasnull = false;
         :	        int                     numberOfAttributes = tupleDescriptor->natts;
         :	        int                     i;
         :
         :	        if (numberOfAttributes > MaxTupleAttributeNumber)
         :	                ereport(ERROR,
    0.00 :	  470606:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  470609:       b9 90 f6 7a 00          mov    $0x7af690,%ecx
    0.00 :	  47060e:       ba 8c 05 00 00          mov    $0x58c,%edx
    0.00 :	  470613:       be f4 f5 7a 00          mov    $0x7af5f4,%esi
    0.00 :	  470618:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  47061d:       e8 9e a4 30 00          callq  77aac0 <errstart>
    0.00 :	  470622:       84 c0                   test   %al,%al
    0.00 :	  470624:       74 2b                   je     470651 <heap_form_minimal_tuple+0x171>
    0.00 :	  470626:       44 89 ee                mov    %r13d,%esi
    0.00 :	  470629:       ba 80 06 00 00          mov    $0x680,%edx
    0.00 :	  47062e:       bf e0 f7 7a 00          mov    $0x7af7e0,%edi
    0.00 :	  470633:       31 c0                   xor    %eax,%eax
    0.00 :	  470635:       e8 66 c2 30 00          callq  77c8a0 <errmsg>
    0.00 :	  47063a:       bf 05 01 04 01          mov    $0x1040105,%edi
    0.00 :	  47063f:       89 c3                   mov    %eax,%ebx
    0.00 :	  470641:       e8 0a c7 30 00          callq  77cd50 <errcode>
    0.00 :	  470646:       89 de                   mov    %ebx,%esi
    0.00 :	  470648:       89 c7                   mov    %eax,%edi
    0.00 :	  47064a:       31 c0                   xor    %eax,%eax
    0.00 :	  47064c:       e8 8f 9f 30 00          callq  77a5e0 <errfinish>
    0.00 :	  470651:       e8 7a 8e ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:449
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:454
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005a8e00 <FindTupleHashEntry>:
         :	 */
         :	TupleHashEntry
         :	FindTupleHashEntry(TupleHashTable hashtable, TupleTableSlot *slot,
         :	                                   FmgrInfo *eqfunctions,
         :	                                   FmgrInfo *hashfunctions)
         :	{
    0.00 :	  5a8e00:       55                      push   %rbp
    0.00 :	  5a8e01:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5a8e04:       41 54                   push   %r12
    0.00 :	  5a8e06:       53                      push   %rbx
    0.00 :	  5a8e07:       48 83 ec 10             sub    $0x10,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a8e0b:       48 8b 47 30             mov    0x30(%rdi),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5a8e0f:       4c 8b 25 4a 1a 61 00    mov    0x611a4a(%rip),%r12        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a8e16:       48 89 05 43 1a 61 00    mov    %rax,0x611a43(%rip)        # bba860 <CurrentMemoryContext>
         :	         * Set up data needed by hash and match functions
         :	         *
         :	         * We save and restore CurTupleHashTable just in case someone manages to
         :	         * invoke this code re-entrantly.
         :	         */
         :	        hashtable->inputslot = slot;
    0.00 :	  5a8e1d:       48 89 77 48             mov    %rsi,0x48(%rdi)
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:449
   50.00 :	  5a8e21:       48 8d 75 e0             lea    -0x20(%rbp),%rsi
         :	         *
         :	         * We save and restore CurTupleHashTable just in case someone manages to
         :	         * invoke this code re-entrantly.
         :	         */
         :	        hashtable->inputslot = slot;
         :	        hashtable->in_hash_funcs = hashfunctions;
    0.00 :	  5a8e25:       48 89 4f 50             mov    %rcx,0x50(%rdi)
         :	        hashtable->cur_eq_funcs = eqfunctions;
    0.00 :	  5a8e29:       48 89 57 58             mov    %rdx,0x58(%rdi)
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8e2d:       31 c9                   xor    %ecx,%ecx
         :	         */
         :	        hashtable->inputslot = slot;
         :	        hashtable->in_hash_funcs = hashfunctions;
         :	        hashtable->cur_eq_funcs = eqfunctions;
         :
         :	        saveCurHT = CurTupleHashTable;
    0.00 :	  5a8e2f:       48 8b 1d 8a 0a 5d 00    mov    0x5d0a8a(%rip),%rbx        # b798c0 <CurTupleHashTable>
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
    0.00 :	  5a8e36:       48 c7 45 e0 00 00 00    movq   $0x0,-0x20(%rbp)
    0.00 :	  5a8e3d:       00 
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8e3e:       31 d2                   xor    %edx,%edx
         :	        hashtable->inputslot = slot;
         :	        hashtable->in_hash_funcs = hashfunctions;
         :	        hashtable->cur_eq_funcs = eqfunctions;
         :
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
    0.00 :	  5a8e40:       48 89 3d 79 0a 5d 00    mov    %rdi,0x5d0a79(%rip)        # b798c0 <CurTupleHashTable>
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8e47:       48 8b 3f                mov    (%rdi),%rdi
    0.00 :	  5a8e4a:       e8 51 b8 1d 00          callq  7846a0 <hash_search>
         :	                                                                                 &dummy,
         :	                                                                                 HASH_FIND,
         :	                                                                                 NULL);
         :
         :	        CurTupleHashTable = saveCurHT;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:454
   50.00 :	  5a8e4f:       48 89 1d 6a 0a 5d 00    mov    %rbx,0x5d0a6a(%rip)        # b798c0 <CurTupleHashTable>
    0.00 :	  5a8e56:       4c 89 25 03 1a 61 00    mov    %r12,0x611a03(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return entry;
         :	}
    0.00 :	  5a8e5d:       48 83 c4 10             add    $0x10,%rsp
    0.00 :	  5a8e61:       5b                      pop    %rbx
    0.00 :	  5a8e62:       41 5c                   pop    %r12
    0.00 :	  5a8e64:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1051
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005aca20 <ExecEvalConst>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1051
  100.00 :	  5aca20:       55                      push   %rbp
         :	        Const      *con = (Const *) exprstate->expr;
         :
         :	        if (isDone)
    0.00 :	  5aca21:       48 85 c9                test   %rcx,%rcx
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        Const      *con = (Const *) exprstate->expr;
    0.00 :	  5aca24:       48 8b 77 08             mov    0x8(%rdi),%rsi
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5aca28:       48 89 e5                mov    %rsp,%rbp
         :	        Const      *con = (Const *) exprstate->expr;
         :
         :	        if (isDone)
    0.00 :	  5aca2b:       74 06                   je     5aca33 <ExecEvalConst+0x13>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5aca2d:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        *isNull = con->constisnull;
    0.00 :	  5aca33:       0f b6 46 20             movzbl 0x20(%rsi),%eax
    0.00 :	  5aca37:       88 02                   mov    %al,(%rdx)
    0.00 :	  5aca39:       48 8b 46 18             mov    0x18(%rsi),%rax
         :	        return con->constvalue;
         :	}
    0.00 :	  5aca3d:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5130
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5130
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005acf10 <ExecQual>:
         :	 *
         :	 * ----------------------------------------------------------------
         :	 */
         :	bool
         :	ExecQual(List *qual, ExprContext *econtext, bool resultForNull)
         :	{
    0.00 :	  5acf10:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5130
   50.00 :	  5acf11:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5acf14:       41 57                   push   %r15
    0.00 :	  5acf16:       41 56                   push   %r14
    0.00 :	  5acf18:       41 89 d6                mov    %edx,%r14d
    0.00 :	  5acf1b:       41 55                   push   %r13
    0.00 :	  5acf1d:       41 54                   push   %r12
   50.00 :	  5acf1f:       49 89 f4                mov    %rsi,%r12
    0.00 :	  5acf22:       53                      push   %rbx
    0.00 :	  5acf23:       48 83 ec 18             sub    $0x18,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf27:       48 8b 46 28             mov    0x28(%rsi),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5acf2b:       48 85 ff                test   %rdi,%rdi
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5acf2e:       4c 8b 3d 2b d9 60 00    mov    0x60d92b(%rip),%r15        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf35:       48 89 05 24 d9 60 00    mov    %rax,0x60d924(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5acf3c:       74 4a                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf3e:       48 8b 5f 08             mov    0x8(%rdi),%rbx
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf42:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf45:       74 41                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf47:       4c 8d 6d d7             lea    -0x29(%rbp),%r13
    0.00 :	  5acf4b:       eb 11                   jmp    5acf5e <ExecQual+0x4e>
    0.00 :	  5acf4d:       0f 1f 00                nopl   (%rax)
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
         :
         :	                if (isNull)
         :	                {
         :	                        if (resultForNull == false)
    0.00 :	  5acf50:       45 84 f6                test   %r14b,%r14b
    0.00 :	  5acf53:       74 24                   je     5acf79 <ExecQual+0x69>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf55:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5acf59:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf5c:       74 2a                   je     5acf88 <ExecQual+0x78>
         :	        {
         :	                ExprState  *clause = (ExprState *) lfirst(l);
    0.00 :	  5acf5e:       48 8b 03                mov    (%rbx),%rax
         :	                Datum           expr_value;
         :	                bool            isNull;
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
    0.00 :	  5acf61:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5acf63:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  5acf66:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5acf69:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5acf6c:       ff 50 10                callq  *0x10(%rax)
         :
         :	                if (isNull)
    0.00 :	  5acf6f:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  5acf73:       75 db                   jne    5acf50 <ExecQual+0x40>
         :	                                break;
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        if (!DatumGetBool(expr_value))
    0.00 :	  5acf75:       84 c0                   test   %al,%al
    0.00 :	  5acf77:       75 dc                   jne    5acf55 <ExecQual+0x45>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf79:       31 c0                   xor    %eax,%eax
    0.00 :	  5acf7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5acf80:       eb 0b                   jmp    5acf8d <ExecQual+0x7d>
    0.00 :	  5acf82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5acf88:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5acf8d:       4c 89 3d cc d8 60 00    mov    %r15,0x60d8cc(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return result;
         :	}
    0.00 :	  5acf94:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5acf98:       5b                      pop    %rbx
    0.00 :	  5acf99:       41 5c                   pop    %r12
    0.00 :	  5acf9b:       41 5d                   pop    %r13
    0.00 :	  5acf9d:       41 5e                   pop    %r14
    0.00 :	  5acf9f:       41 5f                   pop    %r15
    0.00 :	  5acfa1:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:511
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:511
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b3a20 <ExecStoreVirtualTuple>:
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
         :	        slot->tts_nvalid = slot->tts_tupleDescriptor->natts;
    0.00 :	  5b3a20:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	 * This is a bit unclean but it avoids one round of data copying.
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecStoreVirtualTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3a24:       55                      push   %rbp
         :	         */
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
    0.00 :	  5b3a25:       c6 47 04 00             movb   $0x0,0x4(%rdi)
         :	 * This is a bit unclean but it avoids one round of data copying.
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecStoreVirtualTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3a29:       48 89 e5                mov    %rsp,%rbp
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
         :	        slot->tts_nvalid = slot->tts_tupleDescriptor->natts;
    0.00 :	  5b3a2c:       8b 00                   mov    (%rax),%eax
    0.00 :	  5b3a2e:       89 47 24                mov    %eax,0x24(%rdi)
         :
         :	        return slot;
         :	}
    0.00 :	  5b3a31:       48 89 f8                mov    %rdi,%rax
  100.00 :	  5b3a34:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:599
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:607
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b3f00 <ExecCopySlotMinimalTuple>:
         :	 *                      The slot itself is undisturbed.
         :	 * --------------------------------
         :	 */
         :	MinimalTuple
         :	ExecCopySlotMinimalTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3f00:       55                      push   %rbp
    0.00 :	  5b3f01:       48 89 f8                mov    %rdi,%rax
         :
         :	        /*
         :	         * If we have a physical tuple then just copy it.  Prefer to copy
         :	         * tts_mintuple since that's a tad cheaper.
         :	         */
         :	        if (slot->tts_mintuple)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:599
   50.00 :	  5b3f04:       48 8b 7f 38             mov    0x38(%rdi),%rdi
         :	 *                      The slot itself is undisturbed.
         :	 * --------------------------------
         :	 */
         :	MinimalTuple
         :	ExecCopySlotMinimalTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3f08:       48 89 e5                mov    %rsp,%rbp
         :
         :	        /*
         :	         * If we have a physical tuple then just copy it.  Prefer to copy
         :	         * tts_mintuple since that's a tad cheaper.
         :	         */
         :	        if (slot->tts_mintuple)
    0.00 :	  5b3f0b:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b3f0e:       74 10                   je     5b3f20 <ExecCopySlotMinimalTuple+0x20>
         :	         * Otherwise we need to build a tuple from the Datum array.
         :	         */
         :	        return heap_form_minimal_tuple(slot->tts_tupleDescriptor,
         :	                                                                   slot->tts_values,
         :	                                                                   slot->tts_isnull);
         :	}
    0.00 :	  5b3f10:       c9                      leaveq 
         :	        /*
         :	         * If we have a physical tuple then just copy it.  Prefer to copy
         :	         * tts_mintuple since that's a tad cheaper.
         :	         */
         :	        if (slot->tts_mintuple)
         :	                return heap_copy_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b3f11:       e9 ca ab eb ff          jmpq   46eae0 <heap_copy_minimal_tuple>
    0.00 :	  5b3f16:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b3f1d:       00 00 00 
         :	        if (slot->tts_tuple)
    0.00 :	  5b3f20:       48 8b 78 08             mov    0x8(%rax),%rdi
    0.00 :	  5b3f24:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b3f27:       74 07                   je     5b3f30 <ExecCopySlotMinimalTuple+0x30>
         :	         * Otherwise we need to build a tuple from the Datum array.
         :	         */
         :	        return heap_form_minimal_tuple(slot->tts_tupleDescriptor,
         :	                                                                   slot->tts_values,
         :	                                                                   slot->tts_isnull);
         :	}
    0.00 :	  5b3f29:       c9                      leaveq 
         :	         * tts_mintuple since that's a tad cheaper.
         :	         */
         :	        if (slot->tts_mintuple)
         :	                return heap_copy_minimal_tuple(slot->tts_mintuple);
         :	        if (slot->tts_tuple)
         :	                return minimal_tuple_from_heap_tuple(slot->tts_tuple);
    0.00 :	  5b3f2a:       e9 51 ab eb ff          jmpq   46ea80 <minimal_tuple_from_heap_tuple>
    0.00 :	  5b3f2f:       90                      nop
         :
         :	        /*
         :	         * Otherwise we need to build a tuple from the Datum array.
         :	         */
         :	        return heap_form_minimal_tuple(slot->tts_tupleDescriptor,
    0.00 :	  5b3f30:       48 8b 50 30             mov    0x30(%rax),%rdx
    0.00 :	  5b3f34:       48 8b 70 28             mov    0x28(%rax),%rsi
    0.00 :	  5b3f38:       48 8b 78 10             mov    0x10(%rax),%rdi
         :	                                                                   slot->tts_values,
         :	                                                                   slot->tts_isnull);
         :	}
    0.00 :	  5b3f3c:       c9                      leaveq 
         :	                return minimal_tuple_from_heap_tuple(slot->tts_tuple);
         :
         :	        /*
         :	         * Otherwise we need to build a tuple from the Datum array.
         :	         */
         :	        return heap_form_minimal_tuple(slot->tts_tupleDescriptor,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:607
   50.00 :	  5b3f3d:       e9 9e c5 eb ff          jmpq   4704e0 <heap_form_minimal_tuple>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:531
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:544
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b9950 <advance_aggregates>:
         :	 *
         :	 * When called, CurrentMemoryContext should be the per-query context.
         :	 */
         :	static void
         :	advance_aggregates(AggState *aggstate, AggStatePerGroup pergroup)
         :	{
    0.00 :	  5b9950:       55                      push   %rbp
    0.00 :	  5b9951:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b9954:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:531
   50.00 :	  5b9956:       49 89 ff                mov    %rdi,%r15
    0.00 :	  5b9959:       41 56                   push   %r14
    0.00 :	  5b995b:       41 55                   push   %r13
    0.00 :	  5b995d:       41 54                   push   %r12
    0.00 :	  5b995f:       53                      push   %rbx
    0.00 :	  5b9960:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  5b9964:       48 89 75 c0             mov    %rsi,-0x40(%rbp)
         :	        int                     aggno;
         :
         :	        for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9968:       44 8b 9f 98 00 00 00    mov    0x98(%rdi),%r11d
    0.00 :	  5b996f:       45 85 db                test   %r11d,%r11d
    0.00 :	  5b9972:       0f 8e c1 00 00 00       jle    5b9a39 <advance_aggregates+0xe9>
    0.00 :	  5b9978:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  5b997b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                AggStatePerAgg peraggstate = &aggstate->peragg[aggno];
    0.00 :	  5b9980:       4d 63 ee                movslq %r14d,%r13
    0.00 :	  5b9983:       49 69 dd a8 04 00 00    imul   $0x4a8,%r13,%rbx
    0.00 :	  5b998a:       49 03 9f b0 00 00 00    add    0xb0(%r15),%rbx
         :	                AggStatePerGroup pergroupstate = &pergroup[aggno];
         :	                ExprState  *filter = peraggstate->aggrefstate->aggfilter;
    0.00 :	  5b9991:       48 8b 03                mov    (%rbx),%rax
         :	                int                     numTransInputs = peraggstate->numTransInputs;
    0.00 :	  5b9994:       44 8b 63 18             mov    0x18(%rbx),%r12d
         :
         :	        for (aggno = 0; aggno < aggstate->numaggs; aggno++)
         :	        {
         :	                AggStatePerAgg peraggstate = &aggstate->peragg[aggno];
         :	                AggStatePerGroup pergroupstate = &pergroup[aggno];
         :	                ExprState  *filter = peraggstate->aggrefstate->aggfilter;
    0.00 :	  5b9998:       48 8b 78 28             mov    0x28(%rax),%rdi
         :	                int                     numTransInputs = peraggstate->numTransInputs;
         :	                int                     i;
         :	                TupleTableSlot *slot;
         :
         :	                /* Skip anything FILTERed out */
         :	                if (filter)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:544
   50.00 :	  5b999c:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b999f:       74 1c                   je     5b99bd <advance_aggregates+0x6d>
         :	                {
         :	                        Datum           res;
         :	                        bool            isnull;
         :
         :	                        res = ExecEvalExprSwitchContext(filter, aggstate->tmpcontext,
    0.00 :	  5b99a1:       49 8b b7 c0 00 00 00    mov    0xc0(%r15),%rsi
    0.00 :	  5b99a8:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5b99ac:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b99ae:       e8 2d 35 ff ff          callq  5acee0 <ExecEvalExprSwitchContext>
         :	                                                                                        &isnull, NULL);
         :	                        if (isnull || !DatumGetBool(res))
    0.00 :	  5b99b3:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  5b99b7:       75 6f                   jne    5b9a28 <advance_aggregates+0xd8>
    0.00 :	  5b99b9:       84 c0                   test   %al,%al
    0.00 :	  5b99bb:       74 6b                   je     5b9a28 <advance_aggregates+0xd8>
         :	                                continue;
         :	                }
         :
         :	                /* Evaluate the current input expressions for this aggregate */
         :	                slot = ExecProject(peraggstate->evalproj, NULL);
    0.00 :	  5b99bd:       48 8b bb e0 00 00 00    mov    0xe0(%rbx),%rdi
    0.00 :	  5b99c4:       31 f6                   xor    %esi,%esi
    0.00 :	  5b99c6:       e8 35 36 ff ff          callq  5ad000 <ExecProject>
         :
         :	                if (peraggstate->numSortCols > 0)
    0.00 :	  5b99cb:       44 8b 93 8c 00 00 00    mov    0x8c(%rbx),%r10d
         :	                        if (isnull || !DatumGetBool(res))
         :	                                continue;
         :	                }
         :
         :	                /* Evaluate the current input expressions for this aggregate */
         :	                slot = ExecProject(peraggstate->evalproj, NULL);
    0.00 :	  5b99d2:       48 89 c1                mov    %rax,%rcx
         :
         :	                if (peraggstate->numSortCols > 0)
    0.00 :	  5b99d5:       45 85 d2                test   %r10d,%r10d
    0.00 :	  5b99d8:       7e 76                   jle    5b9a50 <advance_aggregates+0x100>
         :	                         * storing the row in the sorter, to save space if there are a lot
         :	                         * of nulls.  Note that we must only check numTransInputs columns,
         :	                         * not numInputs, since nullity in columns used only for sorting
         :	                         * is not relevant here.
         :	                         */
         :	                        if (peraggstate->transfn.fn_strict)
    0.00 :	  5b99da:       80 7b 36 00             cmpb   $0x0,0x36(%rbx)
    0.00 :	  5b99de:       74 2c                   je     5b9a0c <advance_aggregates+0xbc>
         :	                        {
         :	                                for (i = 0; i < numTransInputs; i++)
    0.00 :	  5b99e0:       45 85 e4                test   %r12d,%r12d
    0.00 :	  5b99e3:       7e 27                   jle    5b9a0c <advance_aggregates+0xbc>
         :	                                {
         :	                                        if (slot->tts_isnull[i])
    0.00 :	  5b99e5:       48 8b 40 30             mov    0x30(%rax),%rax
    0.00 :	  5b99e9:       31 d2                   xor    %edx,%edx
    0.00 :	  5b99eb:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  5b99ee:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5b99f1:       74 11                   je     5b9a04 <advance_aggregates+0xb4>
    0.00 :	  5b99f3:       eb 33                   jmp    5b9a28 <advance_aggregates+0xd8>
    0.00 :	  5b99f5:       0f 1f 00                nopl   (%rax)
    0.00 :	  5b99f8:       0f b6 46 01             movzbl 0x1(%rsi),%eax
    0.00 :	  5b99fc:       48 83 c6 01             add    $0x1,%rsi
    0.00 :	  5b9a00:       84 c0                   test   %al,%al
    0.00 :	  5b9a02:       75 24                   jne    5b9a28 <advance_aggregates+0xd8>
         :	                         * not numInputs, since nullity in columns used only for sorting
         :	                         * is not relevant here.
         :	                         */
         :	                        if (peraggstate->transfn.fn_strict)
         :	                        {
         :	                                for (i = 0; i < numTransInputs; i++)
    0.00 :	  5b9a04:       83 c2 01                add    $0x1,%edx
    0.00 :	  5b9a07:       41 39 d4                cmp    %edx,%r12d
    0.00 :	  5b9a0a:       7f ec                   jg     5b99f8 <advance_aggregates+0xa8>
         :	                                if (i < numTransInputs)
         :	                                        continue;
         :	                        }
         :
         :	                        /* OK, put the tuple into the tuplesort object */
         :	                        if (peraggstate->numInputs == 1)
    0.00 :	  5b9a0c:       83 7b 14 01             cmpl   $0x1,0x14(%rbx)
    0.00 :	  5b9a10:       0f 84 8a 00 00 00       je     5b9aa0 <advance_aggregates+0x150>
         :	                                tuplesort_putdatum(peraggstate->sortstate,
         :	                                                                   slot->tts_values[0],
         :	                                                                   slot->tts_isnull[0]);
         :	                        else
         :	                                tuplesort_puttupleslot(peraggstate->sortstate, slot);
    0.00 :	  5b9a16:       48 8b bb f8 00 00 00    mov    0xf8(%rbx),%rdi
    0.00 :	  5b9a1d:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  5b9a20:       e8 0b 56 1e 00          callq  79f030 <tuplesort_puttupleslot>
    0.00 :	  5b9a25:       0f 1f 00                nopl   (%rax)
         :	static void
         :	advance_aggregates(AggState *aggstate, AggStatePerGroup pergroup)
         :	{
         :	        int                     aggno;
         :
         :	        for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9a28:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  5b9a2c:       45 39 b7 98 00 00 00    cmp    %r14d,0x98(%r15)
    0.00 :	  5b9a33:       0f 8f 47 ff ff ff       jg     5b9980 <advance_aggregates+0x30>
         :	                        }
         :
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
         :	                }
         :	        }
         :	}
    0.00 :	  5b9a39:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5b9a3d:       5b                      pop    %rbx
    0.00 :	  5b9a3e:       41 5c                   pop    %r12
    0.00 :	  5b9a40:       41 5d                   pop    %r13
    0.00 :	  5b9a42:       41 5e                   pop    %r14
    0.00 :	  5b9a44:       41 5f                   pop    %r15
    0.00 :	  5b9a46:       c9                      leaveq 
    0.00 :	  5b9a47:       c3                      retq   
    0.00 :	  5b9a48:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b9a4f:       00 
         :	                        if (peraggstate->numInputs == 1)
         :	                                tuplesort_putdatum(peraggstate->sortstate,
         :	                                                                   slot->tts_values[0],
         :	                                                                   slot->tts_isnull[0]);
         :	                        else
         :	                                tuplesort_puttupleslot(peraggstate->sortstate, slot);
    0.00 :	  5b9a50:       31 d2                   xor    %edx,%edx
         :	                        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        Assert(slot->tts_nvalid >= numTransInputs);
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5b9a52:       45 85 e4                test   %r12d,%r12d
    0.00 :	  5b9a55:       7e 31                   jle    5b9a88 <advance_aggregates+0x138>
    0.00 :	  5b9a57:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5b9a5e:       00 00 
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot->tts_values[i];
    0.00 :	  5b9a60:       48 8b 41 28             mov    0x28(%rcx),%rax
    0.00 :	  5b9a64:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  5b9a68:       48 89 84 d3 28 01 00    mov    %rax,0x128(%rbx,%rdx,8)
    0.00 :	  5b9a6f:       00 
         :	                                fcinfo->argnull[i + 1] = slot->tts_isnull[i];
    0.00 :	  5b9a70:       48 8b 41 30             mov    0x30(%rcx),%rax
    0.00 :	  5b9a74:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  5b9a78:       88 84 13 41 04 00 00    mov    %al,0x441(%rbx,%rdx,1)
    0.00 :	  5b9a7f:       48 83 c2 01             add    $0x1,%rdx
         :	                        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        Assert(slot->tts_nvalid >= numTransInputs);
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5b9a83:       41 39 d4                cmp    %edx,%r12d
    0.00 :	  5b9a86:       7f d8                   jg     5b9a60 <advance_aggregates+0x110>
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot->tts_values[i];
         :	                                fcinfo->argnull[i + 1] = slot->tts_isnull[i];
         :	                        }
         :
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5b9a88:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5b9a8c:       49 c1 e5 04             shl    $0x4,%r13
    0.00 :	  5b9a90:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b9a93:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5b9a96:       4c 01 ea                add    %r13,%rdx
    0.00 :	  5b9a99:       e8 f2 fc ff ff          callq  5b9790 <advance_transition_function>
    0.00 :	  5b9a9e:       eb 88                   jmp    5b9a28 <advance_aggregates+0xd8>
         :	                                        continue;
         :	                        }
         :
         :	                        /* OK, put the tuple into the tuplesort object */
         :	                        if (peraggstate->numInputs == 1)
         :	                                tuplesort_putdatum(peraggstate->sortstate,
    0.00 :	  5b9aa0:       48 8b 41 30             mov    0x30(%rcx),%rax
    0.00 :	  5b9aa4:       48 8b bb f8 00 00 00    mov    0xf8(%rbx),%rdi
    0.00 :	  5b9aab:       0f be 10                movsbl (%rax),%edx
    0.00 :	  5b9aae:       48 8b 41 28             mov    0x28(%rcx),%rax
    0.00 :	  5b9ab2:       48 8b 30                mov    (%rax),%rsi
    0.00 :	  5b9ab5:       e8 66 54 1e 00          callq  79ef20 <tuplesort_putdatum>
    0.00 :	  5b9aba:       e9 69 ff ff ff          jmpq   5b9a28 <advance_aggregates+0xd8>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:1244
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:664
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b9d80 <ExecAgg>:
         :	 *        stored in the expression context to be used when ExecProject evaluates
         :	 *        the result tuple.
         :	 */
         :	TupleTableSlot *
         :	ExecAgg(AggState *node)
         :	{
    0.00 :	  5b9d80:       55                      push   %rbp
    0.00 :	  5b9d81:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b9d84:       41 57                   push   %r15
    0.00 :	  5b9d86:       41 56                   push   %r14
    0.00 :	  5b9d88:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5b9d8b:       41 55                   push   %r13
    0.00 :	  5b9d8d:       41 54                   push   %r12
    0.00 :	  5b9d8f:       53                      push   %rbx
    0.00 :	  5b9d90:       48 81 ec d8 00 00 00    sub    $0xd8,%rsp
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous agg
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ss.ps.ps_TupFromTlist)
    0.00 :	  5b9d97:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
    0.00 :	  5b9d9b:       74 1c                   je     5b9db9 <ExecAgg+0x39>
         :	        {
         :	                TupleTableSlot *result;
         :	                ExprDoneCond isDone;
         :
         :	                result = ExecProject(node->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5b9d9d:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5b9da1:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b9da5:       e8 56 32 ff ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b9daa:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5b9dae:       0f 84 04 02 00 00       je     5b9fb8 <ExecAgg+0x238>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->ss.ps.ps_TupFromTlist = false;
    0.00 :	  5b9db4:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
         :	        /*
         :	         * Exit if nothing left to do.  (We must do the ps_TupFromTlist check
         :	         * first, because in some cases agg_done gets set before we emit the final
         :	         * aggregate tuple, and we have to finish running SRFs for it.)
         :	         */
         :	        if (node->agg_done)
    0.00 :	  5b9db9:       31 c0                   xor    %eax,%eax
    0.00 :	  5b9dbb:       41 80 be d0 00 00 00    cmpb   $0x0,0xd0(%r14)
    0.00 :	  5b9dc2:       00 
    0.00 :	  5b9dc3:       0f 85 ef 01 00 00       jne    5b9fb8 <ExecAgg+0x238>
         :	                return NULL;
         :
         :	        /* Dispatch based on strategy */
         :	        if (((Agg *) node->ss.ps.plan)->aggstrategy == AGG_HASHED)
    0.00 :	  5b9dc9:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  5b9dcd:       48 89 85 10 ff ff ff    mov    %rax,-0xf0(%rbp)
    0.00 :	  5b9dd4:       83 78 60 02             cmpl   $0x2,0x60(%rax)
    0.00 :	  5b9dd8:       0f 85 ec 01 00 00       jne    5b9fca <ExecAgg+0x24a>
         :	        {
         :	                if (!node->table_filled)
    0.00 :	  5b9dde:       31 c0                   xor    %eax,%eax
    0.00 :	  5b9de0:       41 80 be 00 01 00 00    cmpb   $0x0,0x100(%r14)
    0.00 :	  5b9de7:       00 
    0.00 :	  5b9de8:       4d 8d be 08 01 00 00    lea    0x108(%r14),%r15
    0.00 :	  5b9def:       0f 84 5d 07 00 00       je     5ba552 <ExecAgg+0x7d2>
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9df5:       4d 8b 6e 60             mov    0x60(%r14),%r13
         :	        aggvalues = econtext->ecxt_aggvalues;
    0.00 :	  5b9df9:       49 8b 55 40             mov    0x40(%r13),%rdx
    0.00 :	  5b9dfd:       48 89 95 30 ff ff ff    mov    %rdx,-0xd0(%rbp)
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9e04:       49 8b 55 48             mov    0x48(%r13),%rdx
    0.00 :	  5b9e08:       48 89 95 28 ff ff ff    mov    %rdx,-0xd8(%rbp)
         :	        peragg = aggstate->peragg;
    0.00 :	  5b9e0f:       49 8b 96 b0 00 00 00    mov    0xb0(%r14),%rdx
    0.00 :	  5b9e16:       48 89 95 20 ff ff ff    mov    %rdx,-0xe0(%rbp)
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5b9e1d:       49 8b 96 88 00 00 00    mov    0x88(%r14),%rdx
    0.00 :	  5b9e24:       48 89 95 18 ff ff ff    mov    %rdx,-0xe8(%rbp)
         :
         :	        /*
         :	         * We loop retrieving groups until we find one satisfying
         :	         * aggstate->ss.ps.qual
         :	         */
         :	        while (!aggstate->agg_done)
    0.00 :	  5b9e2b:       84 c0                   test   %al,%al
    0.00 :	  5b9e2d:       0f 85 83 01 00 00       jne    5b9fb6 <ExecAgg+0x236>
         :	        {
         :	                /*
         :	                 * Find the next entry in the hash table
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
    0.00 :	  5b9e33:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5b9e36:       e8 85 9c 1c 00          callq  783ac0 <hash_seq_search>
         :	                if (entry == NULL)
    0.00 :	  5b9e3b:       48 85 c0                test   %rax,%rax
         :	        while (!aggstate->agg_done)
         :	        {
         :	                /*
         :	                 * Find the next entry in the hash table
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
    0.00 :	  5b9e3e:       49 89 c4                mov    %rax,%r12
         :	                if (entry == NULL)
    0.00 :	  5b9e41:       0f 84 fc 06 00 00       je     5ba543 <ExecAgg+0x7c3>
         :	                 *
         :	                 * We intentionally don't use ReScanExprContext here; if any aggs have
         :	                 * registered shutdown callbacks, they mustn't be called yet, since we
         :	                 * might not be done with that agg.
         :	                 */
         :	                ResetExprContext(econtext);
    0.00 :	  5b9e47:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b9e4b:       e8 60 eb 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                /*
         :	                 * Store the copied first input tuple in the tuple table slot reserved
         :	                 * for it, so that it can be used in ExecProject.
         :	                 */
         :	                ExecStoreMinimalTuple(entry->shared.firstTuple,
    0.00 :	  5b9e50:       48 8b b5 18 ff ff ff    mov    -0xe8(%rbp),%rsi
    0.00 :	  5b9e57:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5b9e5b:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9e5d:       e8 7e a5 ff ff          callq  5b43e0 <ExecStoreMinimalTuple>
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9e62:       41 8b 96 98 00 00 00    mov    0x98(%r14),%edx
    0.00 :	  5b9e69:       85 d2                   test   %edx,%edx
    0.00 :	  5b9e6b:       7e 49                   jle    5b9eb6 <ExecAgg+0x136>
    0.00 :	  5b9e6d:       31 db                   xor    %ebx,%ebx
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
         :
         :	                        Assert(peraggstate->numSortCols == 0);
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9e6f:       48 8b 85 30 ff ff ff    mov    -0xd0(%rbp),%rax
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
    0.00 :	  5b9e76:       48 63 fb                movslq %ebx,%rdi
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9e79:       83 c3 01                add    $0x1,%ebx
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
         :
         :	                        Assert(peraggstate->numSortCols == 0);
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9e7c:       48 69 f7 a8 04 00 00    imul   $0x4a8,%rdi,%rsi
    0.00 :	  5b9e83:       48 03 b5 20 ff ff ff    add    -0xe0(%rbp),%rsi
    0.00 :	  5b9e8a:       48 8d 0c f8             lea    (%rax,%rdi,8),%rcx
    0.00 :	  5b9e8e:       48 89 f8                mov    %rdi,%rax
    0.00 :	  5b9e91:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  5b9e95:       49 8d 54 04 08          lea    0x8(%r12,%rax,1),%rdx
    0.00 :	  5b9e9a:       48 8b 85 28 ff ff ff    mov    -0xd8(%rbp),%rax
    0.00 :	  5b9ea1:       4c 8d 04 38             lea    (%rax,%rdi,1),%r8
    0.00 :	  5b9ea5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b9ea8:       e8 13 fc ff ff          callq  5b9ac0 <finalize_aggregate>
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9ead:       41 3b 9e 98 00 00 00    cmp    0x98(%r14),%ebx
    0.00 :	  5b9eb4:       7c b9                   jl     5b9e6f <ExecAgg+0xef>
         :
         :	                /*
         :	                 * Use the representative input tuple for any references to
         :	                 * non-aggregated input columns in the qual and tlist.
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5b9eb6:       48 8b 95 18 ff ff ff    mov    -0xe8(%rbp),%rdx
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9ebd:       4c 89 ee                mov    %r13,%rsi
         :
         :	                /*
         :	                 * Use the representative input tuple for any references to
         :	                 * non-aggregated input columns in the qual and tlist.
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5b9ec0:       49 89 55 18             mov    %rdx,0x18(%r13)
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9ec4:       49 8b 7e 28             mov    0x28(%r14),%rdi
    0.00 :	  5b9ec8:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9eca:       e8 41 30 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b9ecf:       84 c0                   test   %al,%al
    0.00 :	  5b9ed1:       0f 85 4e 06 00 00       jne    5ba525 <ExecAgg+0x7a5>
         :	                                        (isDone == ExprMultipleResult);
         :	                                return result;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(aggstate, 1);
    0.00 :	  5b9ed7:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5b9edb:       48 85 c0                test   %rax,%rax
    0.00 :	  5b9ede:       74 18                   je     5b9ef8 <ExecAgg+0x178>
    0.00 :	  5b9ee0:       f2 0f 10 05 70 52 1f    movsd  0x1f5270(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b9ee7:       00 
    0.00 :	  5b9ee8:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b9eef:       00 
    0.00 :	  5b9ef0:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b9ef7:       00 
    0.00 :	  5b9ef8:       41 0f b6 86 d0 00 00    movzbl 0xd0(%r14),%eax
    0.00 :	  5b9eff:       00 
    0.00 :	  5b9f00:       e9 26 ff ff ff          jmpq   5b9e2b <ExecAgg+0xab>
         :	                        MemoryContextReset(workcontext);
         :
         :	                ExecClearTuple(slot1);
         :	        }
         :
         :	        if (slot2)
    0.00 :	  5b9f05:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b9f08:       74 08                   je     5b9f12 <ExecAgg+0x192>
         :	                ExecClearTuple(slot2);
    0.00 :	  5b9f0a:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5b9f0d:       e8 fe a1 ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	        tuplesort_end(peraggstate->sortstate);
    0.00 :	  5b9f12:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5b9f19:       00 
    0.00 :	  5b9f1a:       e8 c1 52 1e 00          callq  79f1e0 <tuplesort_end>
         :	        peraggstate->sortstate = NULL;
    0.00 :	  5b9f1f:       49 c7 84 24 f8 00 00    movq   $0x0,0xf8(%r12)
    0.00 :	  5b9f26:       00 00 00 00 00 
         :	                                        process_ordered_aggregate_multi(aggstate,
         :	                                                                                                        peraggstate,
         :	                                                                                                        pergroupstate);
         :	                        }
         :
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9f2b:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  5b9f2f:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  5b9f36:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5b9f39:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b9f3c:       48 8d 0c d0             lea    (%rax,%rdx,8),%rcx
    0.00 :	  5b9f40:       48 8b 85 60 ff ff ff    mov    -0xa0(%rbp),%rax
    0.00 :	  5b9f47:       4c 8d 04 10             lea    (%rax,%rdx,1),%r8
    0.00 :	  5b9f4b:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5b9f52:       e8 69 fb ff ff          callq  5b9ac0 <finalize_aggregate>
         :
         :	                /*
         :	                 * Done scanning input tuple group. Finalize each aggregate
         :	                 * calculation, and stash results in the per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9f57:       83 85 44 ff ff ff 01    addl   $0x1,-0xbc(%rbp)
    0.00 :	  5b9f5e:       8b 95 44 ff ff ff       mov    -0xbc(%rbp),%edx
    0.00 :	  5b9f64:       41 3b 96 98 00 00 00    cmp    0x98(%r14),%edx
    0.00 :	  5b9f6b:       0f 8c f6 01 00 00       jl     5ba167 <ExecAgg+0x3e7>
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9f71:       49 8b 7e 28             mov    0x28(%r14),%rdi
    0.00 :	  5b9f75:       48 8b b5 78 ff ff ff    mov    -0x88(%rbp),%rsi
    0.00 :	  5b9f7c:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9f7e:       e8 8d 2f ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b9f83:       84 c0                   test   %al,%al
    0.00 :	  5b9f85:       0f 85 18 05 00 00       jne    5ba4a3 <ExecAgg+0x723>
         :	                                        (isDone == ExprMultipleResult);
         :	                                return result;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(aggstate, 1);
    0.00 :	  5b9f8b:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5b9f8f:       48 85 c0                test   %rax,%rax
    0.00 :	  5b9f92:       74 18                   je     5b9fac <ExecAgg+0x22c>
    0.00 :	  5b9f94:       f2 0f 10 05 bc 51 1f    movsd  0x1f51bc(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b9f9b:       00 
    0.00 :	  5b9f9c:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b9fa3:       00 
    0.00 :	  5b9fa4:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b9fab:       00 
         :
         :	        /*
         :	         * We loop retrieving groups until we find one matching
         :	         * aggstate->ss.ps.qual
         :	         */
         :	        while (!aggstate->agg_done)
    0.00 :	  5b9fac:       41 80 be d0 00 00 00    cmpb   $0x0,0xd0(%r14)
    0.00 :	  5b9fb3:       00 
    0.00 :	  5b9fb4:       74 75                   je     5ba02b <ExecAgg+0x2ab>
    0.00 :	  5b9fb6:       31 c0                   xor    %eax,%eax
         :	                        agg_fill_hash_table(node);
         :	                return agg_retrieve_hash_table(node);
         :	        }
         :	        else
         :	                return agg_retrieve_direct(node);
         :	}
    0.00 :	  5b9fb8:       48 81 c4 d8 00 00 00    add    $0xd8,%rsp
    0.00 :	  5b9fbf:       5b                      pop    %rbx
    0.00 :	  5b9fc0:       41 5c                   pop    %r12
    0.00 :	  5b9fc2:       41 5d                   pop    %r13
    0.00 :	  5b9fc4:       41 5e                   pop    %r14
    0.00 :	  5b9fc6:       41 5f                   pop    %r15
    0.00 :	  5b9fc8:       c9                      leaveq 
    0.00 :	  5b9fc9:       c3                      retq   
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9fca:       49 8b 56 60             mov    0x60(%r14),%rdx
         :	        int                     aggno;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5b9fce:       49 8b 46 30             mov    0x30(%r14),%rax
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9fd2:       48 89 95 78 ff ff ff    mov    %rdx,-0x88(%rbp)
         :	        int                     aggno;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5b9fd9:       48 89 45 80             mov    %rax,-0x80(%rbp)
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
    0.00 :	  5b9fdd:       48 8b 42 40             mov    0x40(%rdx),%rax
    0.00 :	  5b9fe1:       48 89 85 68 ff ff ff    mov    %rax,-0x98(%rbp)
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9fe8:       48 8b 52 48             mov    0x48(%rdx),%rdx
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5b9fec:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9ff3:       48 89 95 60 ff ff ff    mov    %rdx,-0xa0(%rbp)
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
    0.00 :	  5b9ffa:       49 8b 96 b0 00 00 00    mov    0xb0(%r14),%rdx
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5ba001:       48 89 85 70 ff ff ff    mov    %rax,-0x90(%rbp)
         :	        peragg = aggstate->peragg;
         :	        pergroup = aggstate->pergroup;
    0.00 :	  5ba008:       49 8b 86 d8 00 00 00    mov    0xd8(%r14),%rax
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
    0.00 :	  5ba00f:       48 89 95 58 ff ff ff    mov    %rdx,-0xa8(%rbp)
         :	        pergroup = aggstate->pergroup;
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5ba016:       49 8b 96 88 00 00 00    mov    0x88(%r14),%rdx
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
         :	        pergroup = aggstate->pergroup;
    0.00 :	  5ba01d:       48 89 85 50 ff ff ff    mov    %rax,-0xb0(%rbp)
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5ba024:       48 89 95 48 ff ff ff    mov    %rdx,-0xb8(%rbp)
         :	        {
         :	                /*
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
    0.00 :	  5ba02b:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5ba032:       00 
    0.00 :	  5ba033:       0f 84 a4 04 00 00       je     5ba4dd <ExecAgg+0x75d>
         :	                 * We use ReScanExprContext not just ResetExprContext because we want
         :	                 * any registered shutdown callbacks to be called.  That allows
         :	                 * aggregate functions to ensure they've cleaned up any non-memory
         :	                 * resources.
         :	                 */
         :	                ReScanExprContext(econtext);
    0.00 :	  5ba039:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
    0.00 :	  5ba040:       e8 3b b1 ff ff          callq  5b5180 <ReScanExprContext>
         :
         :	                MemoryContextResetAndDeleteChildren(aggstate->aggcontext);
    0.00 :	  5ba045:       49 8b be b8 00 00 00    mov    0xb8(%r14),%rdi
    0.00 :	  5ba04c:       e8 bf eb 1d 00          callq  798c10 <MemoryContextResetAndDeleteChildren>
         :
         :	                /*
         :	                 * Initialize working state for a new input tuple group
         :	                 */
         :	                initialize_aggregates(aggstate, peragg, pergroup);
    0.00 :	  5ba051:       48 8b 95 50 ff ff ff    mov    -0xb0(%rbp),%rdx
    0.00 :	  5ba058:       48 8b b5 58 ff ff ff    mov    -0xa8(%rbp),%rsi
    0.00 :	  5ba05f:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba062:       e8 69 f5 ff ff          callq  5b95d0 <initialize_aggregates>
         :
         :	                if (aggstate->grp_firstTuple != NULL)
    0.00 :	  5ba067:       49 8b be e0 00 00 00    mov    0xe0(%r14),%rdi
    0.00 :	  5ba06e:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ba071:       0f 84 c5 00 00 00       je     5ba13c <ExecAgg+0x3bc>
         :	                        /*
         :	                         * Store the copied first input tuple in the tuple table slot
         :	                         * reserved for it.  The tuple will be deleted when it is cleared
         :	                         * from the slot.
         :	                         */
         :	                        ExecStoreTuple(aggstate->grp_firstTuple,
    0.00 :	  5ba077:       48 8b b5 48 ff ff ff    mov    -0xb8(%rbp),%rsi
    0.00 :	  5ba07e:       31 d2                   xor    %edx,%edx
    0.00 :	  5ba080:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  5ba085:       e8 f6 a3 ff ff          callq  5b4480 <ExecStoreTuple>
         :	                                                   InvalidBuffer,
         :	                                                   true);
         :	                        aggstate->grp_firstTuple = NULL;        /* don't keep two pointers */
         :
         :	                        /* set up for first advance_aggregates call */
         :	                        tmpcontext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba08a:       48 8b 85 48 ff ff ff    mov    -0xb8(%rbp),%rax
    0.00 :	  5ba091:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
         :	                         */
         :	                        ExecStoreTuple(aggstate->grp_firstTuple,
         :	                                                   firstSlot,
         :	                                                   InvalidBuffer,
         :	                                                   true);
         :	                        aggstate->grp_firstTuple = NULL;        /* don't keep two pointers */
    0.00 :	  5ba098:       49 c7 86 e0 00 00 00    movq   $0x0,0xe0(%r14)
    0.00 :	  5ba09f:       00 00 00 00 
         :
         :	                        /* set up for first advance_aggregates call */
         :	                        tmpcontext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba0a3:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	                         * Process each outer-plan tuple, and then fetch the next one,
         :	                         * until we exhaust the outer plan or cross a group boundary.
         :	                         */
         :	                        for (;;)
         :	                        {
         :	                                advance_aggregates(aggstate, pergroup);
    0.00 :	  5ba0a7:       48 8b b5 50 ff ff ff    mov    -0xb0(%rbp),%rsi
    0.00 :	  5ba0ae:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba0b1:       e8 9a f8 ff ff          callq  5b9950 <advance_aggregates>
         :
         :	                                /* Reset per-input-tuple context after each tuple */
         :	                                ResetExprContext(tmpcontext);
    0.00 :	  5ba0b6:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5ba0bd:       48 8b 7a 28             mov    0x28(%rdx),%rdi
    0.00 :	  5ba0c1:       e8 ea e8 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba0c6:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  5ba0ca:       e8 d1 23 ff ff          callq  5ac4a0 <ExecProcNode>
         :	                                if (TupIsNull(outerslot))
    0.00 :	  5ba0cf:       48 85 c0                test   %rax,%rax
         :	                                advance_aggregates(aggstate, pergroup);
         :
         :	                                /* Reset per-input-tuple context after each tuple */
         :	                                ResetExprContext(tmpcontext);
         :
         :	                                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba0d2:       48 89 c3                mov    %rax,%rbx
         :	                                if (TupIsNull(outerslot))
    0.00 :	  5ba0d5:       0f 84 f5 03 00 00       je     5ba4d0 <ExecAgg+0x750>
    0.00 :	  5ba0db:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba0df:       0f 85 eb 03 00 00       jne    5ba4d0 <ExecAgg+0x750>
         :	                                        /* no more outer-plan tuples available */
         :	                                        aggstate->agg_done = true;
         :	                                        break;
         :	                                }
         :	                                /* set up for next advance_aggregates call */
         :	                                tmpcontext->ecxt_outertuple = outerslot;
    0.00 :	  5ba0e5:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5ba0ec:       48 89 58 18             mov    %rbx,0x18(%rax)
         :
         :	                                /*
         :	                                 * If we are grouping, check whether we've crossed a group
         :	                                 * boundary.
         :	                                 */
         :	                                if (node->aggstrategy == AGG_SORTED)
    0.00 :	  5ba0f0:       48 8b 95 10 ff ff ff    mov    -0xf0(%rbp),%rdx
    0.00 :	  5ba0f7:       83 7a 60 01             cmpl   $0x1,0x60(%rdx)
    0.00 :	  5ba0fb:       75 aa                   jne    5ba0a7 <ExecAgg+0x327>
         :	                                {
         :	                                        if (!execTuplesMatch(firstSlot,
    0.00 :	  5ba0fd:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5ba104:       48 8b 4a 68             mov    0x68(%rdx),%rcx
    0.00 :	  5ba108:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5ba10b:       8b 52 64                mov    0x64(%rdx),%edx
    0.00 :	  5ba10e:       4d 8b 86 a0 00 00 00    mov    0xa0(%r14),%r8
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:1244
   50.00 :	  5ba115:       48 8b bd 48 ff ff ff    mov    -0xb8(%rbp),%rdi
    0.00 :	  5ba11c:       4c 8b 48 28             mov    0x28(%rax),%r9
    0.00 :	  5ba120:       e8 1b f3 fe ff          callq  5a9440 <execTuplesMatch>
    0.00 :	  5ba125:       84 c0                   test   %al,%al
    0.00 :	  5ba127:       0f 85 7a ff ff ff       jne    5ba0a7 <ExecAgg+0x327>
         :	                                                                                 tmpcontext->ecxt_per_tuple_memory))
         :	                                        {
         :	                                                /*
         :	                                                 * Save the first input tuple of the next group.
         :	                                                 */
         :	                                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
    0.00 :	  5ba12d:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba130:       e8 7b 9e ff ff          callq  5b3fb0 <ExecCopySlotTuple>
    0.00 :	  5ba135:       49 89 86 e0 00 00 00    mov    %rax,0xe0(%r14)
         :	                 * qual, and the tlist.  (If we are not grouping, and there are no
         :	                 * input rows at all, we will come here with an empty firstSlot ...
         :	                 * but if not grouping, there can't be any references to
         :	                 * non-aggregated input columns, so no problem.)
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba13c:       48 8b 85 48 ff ff ff    mov    -0xb8(%rbp),%rax
    0.00 :	  5ba143:       48 8b 95 78 ff ff ff    mov    -0x88(%rbp),%rdx
    0.00 :	  5ba14a:       48 89 42 18             mov    %rax,0x18(%rdx)
         :
         :	                /*
         :	                 * Done scanning input tuple group. Finalize each aggregate
         :	                 * calculation, and stash results in the per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5ba14e:       41 8b 86 98 00 00 00    mov    0x98(%r14),%eax
    0.00 :	  5ba155:       85 c0                   test   %eax,%eax
    0.00 :	  5ba157:       0f 8e 14 fe ff ff       jle    5b9f71 <ExecAgg+0x1f1>
    0.00 :	  5ba15d:       c7 85 44 ff ff ff 00    movl   $0x0,-0xbc(%rbp)
    0.00 :	  5ba164:       00 00 00 
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
    0.00 :	  5ba167:       48 63 95 44 ff ff ff    movslq -0xbc(%rbp),%rdx
    0.00 :	  5ba16e:       4c 8b a5 58 ff ff ff    mov    -0xa8(%rbp),%r12
    0.00 :	  5ba175:       48 69 c2 a8 04 00 00    imul   $0x4a8,%rdx,%rax
    0.00 :	  5ba17c:       48 89 55 88             mov    %rdx,-0x78(%rbp)
    0.00 :	  5ba180:       49 01 c4                add    %rax,%r12
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
    0.00 :	  5ba183:       48 89 d0                mov    %rdx,%rax
    0.00 :	  5ba186:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  5ba18a:       48 03 85 50 ff ff ff    add    -0xb0(%rbp),%rax
    0.00 :	  5ba191:       48 89 85 38 ff ff ff    mov    %rax,-0xc8(%rbp)
         :
         :	                        if (peraggstate->numSortCols > 0)
    0.00 :	  5ba198:       41 8b 84 24 8c 00 00    mov    0x8c(%r12),%eax
    0.00 :	  5ba19f:       00 
    0.00 :	  5ba1a0:       85 c0                   test   %eax,%eax
    0.00 :	  5ba1a2:       0f 8e 83 fd ff ff       jle    5b9f2b <ExecAgg+0x1ab>
         :	                        {
         :	                                if (peraggstate->numInputs == 1)
    0.00 :	  5ba1a8:       41 83 7c 24 14 01       cmpl   $0x1,0x14(%r12)
    0.00 :	  5ba1ae:       0f 84 3e 01 00 00       je     5ba2f2 <ExecAgg+0x572>
         :	static void
         :	process_ordered_aggregate_multi(AggState *aggstate,
         :	                                                                AggStatePerAgg peraggstate,
         :	                                                                AggStatePerGroup pergroupstate)
         :	{
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba1b4:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
    0.00 :	  5ba1bb:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ba1bf:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :	        TupleTableSlot *slot1 = peraggstate->evalslot;
         :	        TupleTableSlot *slot2 = peraggstate->uniqslot;
         :	        int                     numTransInputs = peraggstate->numTransInputs;
         :	        int                     numDistinctCols = peraggstate->numDistinctCols;
    0.00 :	  5ba1c3:       41 8b 84 24 90 00 00    mov    0x90(%r12),%eax
    0.00 :	  5ba1ca:       00 
         :	                                                                AggStatePerAgg peraggstate,
         :	                                                                AggStatePerGroup pergroupstate)
         :	{
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
         :	        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :	        TupleTableSlot *slot1 = peraggstate->evalslot;
    0.00 :	  5ba1cb:       49 8b 9c 24 e8 00 00    mov    0xe8(%r12),%rbx
    0.00 :	  5ba1d2:       00 
         :	        TupleTableSlot *slot2 = peraggstate->uniqslot;
    0.00 :	  5ba1d3:       4d 8b bc 24 f0 00 00    mov    0xf0(%r12),%r15
    0.00 :	  5ba1da:       00 
         :	        int                     numTransInputs = peraggstate->numTransInputs;
    0.00 :	  5ba1db:       45 8b 6c 24 18          mov    0x18(%r12),%r13d
         :	        int                     numDistinctCols = peraggstate->numDistinctCols;
    0.00 :	  5ba1e0:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	        bool            haveOldValue = false;
         :	        int                     i;
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
    0.00 :	  5ba1e3:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba1ea:       00 
    0.00 :	  5ba1eb:       e8 00 7e 1e 00          callq  7a1ff0 <tuplesort_performsort>
         :
         :	        ExecClearTuple(slot1);
    0.00 :	  5ba1f0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba1f3:       e8 18 9f ff ff          callq  5b4110 <ExecClearTuple>
         :	        if (slot2)
    0.00 :	  5ba1f8:       4d 85 ff                test   %r15,%r15
    0.00 :	  5ba1fb:       74 08                   je     5ba205 <ExecAgg+0x485>
         :	                ExecClearTuple(slot2);
    0.00 :	  5ba1fd:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba200:       e8 0b 9f ff ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5ba205:       c6 45 bb 00             movb   $0x0,-0x45(%rbp)
    0.00 :	  5ba209:       eb 3d                   jmp    5ba248 <ExecAgg+0x4c8>
         :	                 * transfn.  (This will help execTuplesMatch too, so we do it
         :	                 * immediately.)
         :	                 */
         :	                slot_getsomeattrs(slot1, numTransInputs);
         :
         :	                if (numDistinctCols == 0 ||
    0.00 :	  5ba20b:       80 7d bb 00             cmpb   $0x0,-0x45(%rbp)
    0.00 :	  5ba20f:       90                      nop
    0.00 :	  5ba210:       74 6c                   je     5ba27e <ExecAgg+0x4fe>
    0.00 :	  5ba212:       49 8b 8c 24 98 00 00    mov    0x98(%r12),%rcx
    0.00 :	  5ba219:       00 
    0.00 :	  5ba21a:       4c 8b 4d c0             mov    -0x40(%rbp),%r9
    0.00 :	  5ba21e:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5ba221:       4d 8b 84 24 b8 00 00    mov    0xb8(%r12),%r8
    0.00 :	  5ba228:       00 
    0.00 :	  5ba229:       8b 55 bc                mov    -0x44(%rbp),%edx
    0.00 :	  5ba22c:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba22f:       e8 0c f2 fe ff          callq  5a9440 <execTuplesMatch>
    0.00 :	  5ba234:       84 c0                   test   %al,%al
    0.00 :	  5ba236:       74 46                   je     5ba27e <ExecAgg+0x4fe>
    0.00 :	  5ba238:       c6 45 bb 01             movb   $0x1,-0x45(%rbp)
    0.00 :	  5ba23c:       0f 1f 40 00             nopl   0x0(%rax)
         :
         :	                /* Reset context each time, unless execTuplesMatch did it for us */
         :	                if (numDistinctCols == 0)
         :	                        MemoryContextReset(workcontext);
         :
         :	                ExecClearTuple(slot1);
    0.00 :	  5ba240:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba243:       e8 c8 9e ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	        ExecClearTuple(slot1);
         :	        if (slot2)
         :	                ExecClearTuple(slot2);
         :
         :	        while (tuplesort_gettupleslot(peraggstate->sortstate, true, slot1))
    0.00 :	  5ba248:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba24f:       00 
    0.00 :	  5ba250:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5ba253:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5ba258:       e8 33 40 1e 00          callq  79e290 <tuplesort_gettupleslot>
    0.00 :	  5ba25d:       84 c0                   test   %al,%al
    0.00 :	  5ba25f:       0f 84 a0 fc ff ff       je     5b9f05 <ExecAgg+0x185>
         :	                /*
         :	                 * Extract the first numTransInputs columns as datums to pass to the
         :	                 * transfn.  (This will help execTuplesMatch too, so we do it
         :	                 * immediately.)
         :	                 */
         :	                slot_getsomeattrs(slot1, numTransInputs);
    0.00 :	  5ba265:       44 89 ee                mov    %r13d,%esi
    0.00 :	  5ba268:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba26b:       e8 f0 4f eb ff          callq  46f260 <slot_getsomeattrs>
         :
         :	                if (numDistinctCols == 0 ||
    0.00 :	  5ba270:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  5ba273:       85 c0                   test   %eax,%eax
    0.00 :	  5ba275:       0f 94 85 0f ff ff ff    sete   -0xf1(%rbp)
    0.00 :	  5ba27c:       75 8d                   jne    5ba20b <ExecAgg+0x48b>
         :	                                                         peraggstate->equalfns,
         :	                                                         workcontext))
         :	                {
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5ba27e:       45 85 ed                test   %r13d,%r13d
    0.00 :	  5ba281:       7e 2e                   jle    5ba2b1 <ExecAgg+0x531>
    0.00 :	  5ba283:       31 d2                   xor    %edx,%edx
    0.00 :	  5ba285:       0f 1f 00                nopl   (%rax)
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot1->tts_values[i];
    0.00 :	  5ba288:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  5ba28c:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  5ba290:       49 89 84 d4 28 01 00    mov    %rax,0x128(%r12,%rdx,8)
    0.00 :	  5ba297:       00 
         :	                                fcinfo->argnull[i + 1] = slot1->tts_isnull[i];
    0.00 :	  5ba298:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  5ba29c:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  5ba2a0:       41 88 84 14 41 04 00    mov    %al,0x441(%r12,%rdx,1)
    0.00 :	  5ba2a7:       00 
    0.00 :	  5ba2a8:       48 83 c2 01             add    $0x1,%rdx
         :	                                                         peraggstate->equalfns,
         :	                                                         workcontext))
         :	                {
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5ba2ac:       41 39 d5                cmp    %edx,%r13d
    0.00 :	  5ba2af:       7f d7                   jg     5ba288 <ExecAgg+0x508>
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot1->tts_values[i];
         :	                                fcinfo->argnull[i + 1] = slot1->tts_isnull[i];
         :	                        }
         :
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba2b1:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba2b8:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba2bb:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba2be:       e8 cd f4 ff ff          callq  5b9790 <advance_transition_function>
         :
         :	                        if (numDistinctCols > 0)
    0.00 :	  5ba2c3:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  5ba2c6:       85 c0                   test   %eax,%eax
    0.00 :	  5ba2c8:       7e 0d                   jle    5ba2d7 <ExecAgg+0x557>
    0.00 :	  5ba2ca:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba2cd:       c6 45 bb 01             movb   $0x1,-0x45(%rbp)
    0.00 :	  5ba2d1:       4c 89 fb                mov    %r15,%rbx
    0.00 :	  5ba2d4:       49 89 ff                mov    %rdi,%r15
         :	                                haveOldValue = true;
         :	                        }
         :	                }
         :
         :	                /* Reset context each time, unless execTuplesMatch did it for us */
         :	                if (numDistinctCols == 0)
    0.00 :	  5ba2d7:       80 bd 0f ff ff ff 00    cmpb   $0x0,-0xf1(%rbp)
    0.00 :	  5ba2de:       0f 84 5c ff ff ff       je     5ba240 <ExecAgg+0x4c0>
         :	                        MemoryContextReset(workcontext);
    0.00 :	  5ba2e4:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5ba2e8:       e8 c3 e6 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba2ed:       e9 4e ff ff ff          jmpq   5ba240 <ExecAgg+0x4c0>
         :	                                                                 AggStatePerGroup pergroupstate)
         :	{
         :	        Datum           oldVal = (Datum) 0;
         :	        bool            oldIsNull = true;
         :	        bool            haveOldVal = false;
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba2f2:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba2f9:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5ba2fc:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  5ba301:       45 31 ff                xor    %r15d,%r15d
         :	                                                                 AggStatePerGroup pergroupstate)
         :	{
         :	        Datum           oldVal = (Datum) 0;
         :	        bool            oldIsNull = true;
         :	        bool            haveOldVal = false;
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba304:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ba308:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :	        MemoryContext oldContext;
         :	        bool            isDistinct = (peraggstate->numDistinctCols > 0);
    0.00 :	  5ba30c:       41 8b 84 24 90 00 00    mov    0x90(%r12),%eax
    0.00 :	  5ba313:       00 
    0.00 :	  5ba314:       89 45 b4                mov    %eax,-0x4c(%rbp)
         :	        Datum      *newVal;
         :	        bool       *isNull;
         :
         :	        Assert(peraggstate->numDistinctCols < 2);
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
    0.00 :	  5ba317:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba31e:       00 
    0.00 :	  5ba31f:       e8 cc 7c 1e 00          callq  7a1ff0 <tuplesort_performsort>
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
    0.00 :	  5ba324:       49 8d 94 24 28 01 00    lea    0x128(%r12),%rdx
    0.00 :	  5ba32b:       00 
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba32c:       49 8d 84 24 41 04 00    lea    0x441(%r12),%rax
    0.00 :	  5ba333:       00 
         :	        Assert(peraggstate->numDistinctCols < 2);
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
    0.00 :	  5ba334:       48 89 55 98             mov    %rdx,-0x68(%rbp)
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba338:       48 89 45 90             mov    %rax,-0x70(%rbp)
    0.00 :	  5ba33c:       eb 3c                   jmp    5ba37a <ExecAgg+0x5fa>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba33e:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba345:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba348:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba34b:       e8 40 f4 ff ff          callq  5b9790 <advance_transition_function>
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba350:       84 db                   test   %bl,%bl
    0.00 :	  5ba352:       0f 84 98 00 00 00       je     5ba3f0 <ExecAgg+0x670>
         :	                                pfree(DatumGetPointer(oldVal));
         :	                        /* and remember the new one for subsequent equality checks */
         :	                        oldVal = *newVal;
         :	                        oldIsNull = *isNull;
    0.00 :	  5ba358:       41 0f b6 9c 24 41 04    movzbl 0x441(%r12),%ebx
    0.00 :	  5ba35f:       00 00 
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
         :	                                pfree(DatumGetPointer(oldVal));
         :	                        /* and remember the new one for subsequent equality checks */
         :	                        oldVal = *newVal;
    0.00 :	  5ba361:       4d 8b bc 24 28 01 00    mov    0x128(%r12),%r15
    0.00 :	  5ba368:       00 
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ba369:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ba36d:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  5ba373:       48 89 15 e6 04 60 00    mov    %rdx,0x6004e6(%rip)        # bba860 <CurrentMemoryContext>
         :	         * Note: if input type is pass-by-ref, the datums returned by the sort are
         :	         * freshly palloc'd in the per-query context, so we must be careful to
         :	         * pfree them when they are no longer needed.
         :	         */
         :
         :	        while (tuplesort_getdatum(peraggstate->sortstate, true,
    0.00 :	  5ba37a:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba381:       00 
    0.00 :	  5ba382:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  5ba386:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5ba38b:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5ba38f:       e8 2c 3e 1e 00          callq  79e1c0 <tuplesort_getdatum>
    0.00 :	  5ba394:       84 c0                   test   %al,%al
    0.00 :	  5ba396:       0f 84 e0 00 00 00       je     5ba47c <ExecAgg+0x6fc>
         :	        {
         :	                /*
         :	                 * Clear and select the working context for evaluation of the equality
         :	                 * function and transition function.
         :	                 */
         :	                MemoryContextReset(workcontext);
    0.00 :	  5ba39c:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:664
   50.00 :	  5ba3a0:       e8 0b e6 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba3a5:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ba3a9:       48 8b 15 b0 04 60 00    mov    0x6004b0(%rip),%rdx        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ba3b0:       48 89 05 a9 04 60 00    mov    %rax,0x6004a9(%rip)        # bba860 <CurrentMemoryContext>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba3b7:       8b 45 b4                mov    -0x4c(%rbp),%eax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ba3ba:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
    0.00 :	  5ba3be:       85 c0                   test   %eax,%eax
    0.00 :	  5ba3c0:       0f 8e 78 ff ff ff       jle    5ba33e <ExecAgg+0x5be>
    0.00 :	  5ba3c6:       45 84 ed                test   %r13b,%r13b
    0.00 :	  5ba3c9:       0f 84 6f ff ff ff       je     5ba33e <ExecAgg+0x5be>
    0.00 :	  5ba3cf:       84 db                   test   %bl,%bl
    0.00 :	  5ba3d1:       75 39                   jne    5ba40c <ExecAgg+0x68c>
    0.00 :	  5ba3d3:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba3da:       00 00 
    0.00 :	  5ba3dc:       74 50                   je     5ba42e <ExecAgg+0x6ae>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba3de:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba3e5:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba3e8:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba3eb:       e8 a0 f3 ff ff          callq  5b9790 <advance_transition_function>
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba3f0:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba3f7:       00 00 
    0.00 :	  5ba3f9:       0f 85 59 ff ff ff       jne    5ba358 <ExecAgg+0x5d8>
         :	                                pfree(DatumGetPointer(oldVal));
    0.00 :	  5ba3ff:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba402:       e8 79 e7 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba407:       e9 4c ff ff ff          jmpq   5ba358 <ExecAgg+0x5d8>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba40c:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba413:       00 00 
    0.00 :	  5ba415:       75 35                   jne    5ba44c <ExecAgg+0x6cc>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba417:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba41e:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba421:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba424:       e8 67 f3 ff ff          callq  5b9790 <advance_transition_function>
    0.00 :	  5ba429:       e9 2a ff ff ff          jmpq   5ba358 <ExecAgg+0x5d8>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba42e:       49 8b 8c 24 28 01 00    mov    0x128(%r12),%rcx
    0.00 :	  5ba435:       00 
    0.00 :	  5ba436:       49 8b bc 24 b8 00 00    mov    0xb8(%r12),%rdi
    0.00 :	  5ba43d:       00 
    0.00 :	  5ba43e:       31 f6                   xor    %esi,%esi
    0.00 :	  5ba440:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  5ba443:       e8 e8 3b 1c 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  5ba448:       84 c0                   test   %al,%al
    0.00 :	  5ba44a:       74 92                   je     5ba3de <ExecAgg+0x65e>
         :	                         (!oldIsNull && !*isNull &&
         :	                          DatumGetBool(FunctionCall2(&peraggstate->equalfns[0],
         :	                                                                                 oldVal, *newVal)))))
         :	                {
         :	                        /* equal to prior, so forget this one */
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
    0.00 :	  5ba44c:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba453:       00 00 
    0.00 :	  5ba455:       0f 85 0e ff ff ff       jne    5ba369 <ExecAgg+0x5e9>
    0.00 :	  5ba45b:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba462:       00 00 
    0.00 :	  5ba464:       0f 85 ff fe ff ff       jne    5ba369 <ExecAgg+0x5e9>
         :	                                pfree(DatumGetPointer(*newVal));
    0.00 :	  5ba46a:       49 8b bc 24 28 01 00    mov    0x128(%r12),%rdi
    0.00 :	  5ba471:       00 
    0.00 :	  5ba472:       e8 09 e7 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba477:       e9 ed fe ff ff          jmpq   5ba369 <ExecAgg+0x5e9>
         :	                }
         :
         :	                MemoryContextSwitchTo(oldContext);
         :	        }
         :
         :	        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba47c:       84 db                   test   %bl,%bl
    0.00 :	  5ba47e:       0f 85 8e fa ff ff       jne    5b9f12 <ExecAgg+0x192>
    0.00 :	  5ba484:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba48b:       00 00 
    0.00 :	  5ba48d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5ba490:       0f 85 7c fa ff ff       jne    5b9f12 <ExecAgg+0x192>
         :	                pfree(DatumGetPointer(oldVal));
    0.00 :	  5ba496:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba499:       e8 e2 e6 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba49e:       e9 6f fa ff ff          jmpq   5b9f12 <ExecAgg+0x192>
         :	                         * and the representative input tuple.
         :	                         */
         :	                        TupleTableSlot *result;
         :	                        ExprDoneCond isDone;
         :
         :	                        result = ExecProject(aggstate->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5ba4a3:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5ba4a7:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5ba4ab:       e8 50 2b ff ff          callq  5ad000 <ExecProject>
         :
         :	                        if (isDone != ExprEndResult)
    0.00 :	  5ba4b0:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5ba4b3:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5ba4b6:       0f 84 f0 fa ff ff       je     5b9fac <ExecAgg+0x22c>
         :	                        {
         :	                                aggstate->ss.ps.ps_TupFromTlist =
    0.00 :	  5ba4bc:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5ba4bf:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5ba4c4:       e9 ef fa ff ff          jmpq   5b9fb8 <ExecAgg+0x238>
    0.00 :	  5ba4c9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                                outerslot = ExecProcNode(outerPlan);
         :	                                if (TupIsNull(outerslot))
         :	                                {
         :	                                        /* no more outer-plan tuples available */
         :	                                        aggstate->agg_done = true;
    0.00 :	  5ba4d0:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba4d7:       01 
    0.00 :	  5ba4d8:       e9 5f fc ff ff          jmpq   5ba13c <ExecAgg+0x3bc>
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
         :	                {
         :	                        outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba4dd:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  5ba4e1:       e8 ba 1f ff ff          callq  5ac4a0 <ExecProcNode>
         :	                        if (!TupIsNull(outerslot))
    0.00 :	  5ba4e6:       48 85 c0                test   %rax,%rax
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
         :	                {
         :	                        outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba4e9:       48 89 c7                mov    %rax,%rdi
         :	                        if (!TupIsNull(outerslot))
    0.00 :	  5ba4ec:       74 06                   je     5ba4f4 <ExecAgg+0x774>
    0.00 :	  5ba4ee:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba4f2:       74 1f                   je     5ba513 <ExecAgg+0x793>
         :	                        else
         :	                        {
         :	                                /* outer plan produced no tuples at all */
         :	                                aggstate->agg_done = true;
         :	                                /* If we are grouping, we should produce no tuples too */
         :	                                if (node->aggstrategy != AGG_PLAIN)
    0.00 :	  5ba4f4:       48 8b 85 10 ff ff ff    mov    -0xf0(%rbp),%rax
         :	                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
         :	                        }
         :	                        else
         :	                        {
         :	                                /* outer plan produced no tuples at all */
         :	                                aggstate->agg_done = true;
    0.00 :	  5ba4fb:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba502:       01 
         :	                                /* If we are grouping, we should produce no tuples too */
         :	                                if (node->aggstrategy != AGG_PLAIN)
    0.00 :	  5ba503:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5ba506:       85 c0                   test   %eax,%eax
    0.00 :	  5ba508:       0f 84 2b fb ff ff       je     5ba039 <ExecAgg+0x2b9>
    0.00 :	  5ba50e:       e9 a3 fa ff ff          jmpq   5b9fb6 <ExecAgg+0x236>
         :	                        {
         :	                                /*
         :	                                 * Make a copy of the first input tuple; we will use this for
         :	                                 * comparisons (in group mode) and for projection.
         :	                                 */
         :	                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
    0.00 :	  5ba513:       e8 98 9a ff ff          callq  5b3fb0 <ExecCopySlotTuple>
    0.00 :	  5ba518:       49 89 86 e0 00 00 00    mov    %rax,0xe0(%r14)
    0.00 :	  5ba51f:       90                      nop
    0.00 :	  5ba520:       e9 14 fb ff ff          jmpq   5ba039 <ExecAgg+0x2b9>
         :	                         * and the representative input tuple.
         :	                         */
         :	                        TupleTableSlot *result;
         :	                        ExprDoneCond isDone;
         :
         :	                        result = ExecProject(aggstate->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5ba525:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5ba529:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5ba52d:       e8 ce 2a ff ff          callq  5ad000 <ExecProject>
         :
         :	                        if (isDone != ExprEndResult)
    0.00 :	  5ba532:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5ba535:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5ba538:       0f 84 ba f9 ff ff       je     5b9ef8 <ExecAgg+0x178>
    0.00 :	  5ba53e:       e9 79 ff ff ff          jmpq   5ba4bc <ExecAgg+0x73c>
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
         :	                if (entry == NULL)
         :	                {
         :	                        /* No more entries in hashtable, so done */
         :	                        aggstate->agg_done = TRUE;
    0.00 :	  5ba543:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba54a:       01 
    0.00 :	  5ba54b:       31 c0                   xor    %eax,%eax
    0.00 :	  5ba54d:       e9 66 fa ff ff          jmpq   5b9fb8 <ExecAgg+0x238>
         :	        TupleTableSlot *outerslot;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5ba552:       4d 8b 6e 30             mov    0x30(%r14),%r13
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5ba556:       4d 8b be c0 00 00 00    mov    0xc0(%r14),%r15
         :	         * Process each outer-plan tuple, and then fetch the next one, until we
         :	         * exhaust the outer plan.
         :	         */
         :	        for (;;)
         :	        {
         :	                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba55d:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5ba560:       e8 3b 1f ff ff          callq  5ac4a0 <ExecProcNode>
         :	                if (TupIsNull(outerslot))
    0.00 :	  5ba565:       48 85 c0                test   %rax,%rax
         :	         * Process each outer-plan tuple, and then fetch the next one, until we
         :	         * exhaust the outer plan.
         :	         */
         :	        for (;;)
         :	        {
         :	                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba568:       48 89 c3                mov    %rax,%rbx
         :	                if (TupIsNull(outerslot))
    0.00 :	  5ba56b:       0f 84 db 00 00 00       je     5ba64c <ExecAgg+0x8cc>
    0.00 :	  5ba571:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba575:       0f 85 d1 00 00 00       jne    5ba64c <ExecAgg+0x8cc>
         :	                        break;
         :	                /* set up for advance_aggregates call */
         :	                tmpcontext->ecxt_outertuple = outerslot;
    0.00 :	  5ba57b:       49 89 47 18             mov    %rax,0x18(%r15)
         :	 * When called, CurrentMemoryContext should be the per-query context.
         :	 */
         :	static AggHashEntry
         :	lookup_hash_entry(AggState *aggstate, TupleTableSlot *inputslot)
         :	{
         :	        TupleTableSlot *hashslot = aggstate->hashslot;
    0.00 :	  5ba57f:       4d 8b a6 f0 00 00 00    mov    0xf0(%r14),%r12
         :	        ListCell   *l;
         :	        AggHashEntry entry;
         :	        bool            isnew;
         :
         :	        /* if first time through, initialize hashslot by cloning input slot */
         :	        if (hashslot->tts_tupleDescriptor == NULL)
    0.00 :	  5ba586:       49 83 7c 24 10 00       cmpq   $0x0,0x10(%r12)
    0.00 :	  5ba58c:       75 14                   jne    5ba5a2 <ExecAgg+0x822>
         :	        {
         :	                ExecSetSlotDescriptor(hashslot, inputslot->tts_tupleDescriptor);
    0.00 :	  5ba58e:       48 8b 70 10             mov    0x10(%rax),%rsi
    0.00 :	  5ba592:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ba595:       e8 16 a0 ff ff          callq  5b45b0 <ExecSetSlotDescriptor>
         :	                /* Make sure all unused columns are NULLs */
         :	                ExecStoreAllNullTuple(hashslot);
    0.00 :	  5ba59a:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ba59d:       e8 1e 9d ff ff          callq  5b42c0 <ExecStoreAllNullTuple>
         :	        }
         :
         :	        /* transfer just the needed columns into hashslot */
         :	        slot_getsomeattrs(inputslot, linitial_int(aggstate->hash_needed));
    0.00 :	  5ba5a2:       49 8b 96 f8 00 00 00    mov    0xf8(%r14),%rdx
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5ba5a9:       31 c0                   xor    %eax,%eax
    0.00 :	  5ba5ab:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5ba5ae:       74 04                   je     5ba5b4 <ExecAgg+0x834>
    0.00 :	  5ba5b0:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ba5b4:       8b 30                   mov    (%rax),%esi
    0.00 :	  5ba5b6:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba5b9:       e8 a2 4c eb ff          callq  46f260 <slot_getsomeattrs>
         :	        foreach(l, aggstate->hash_needed)
    0.00 :	  5ba5be:       49 8b 86 f8 00 00 00    mov    0xf8(%r14),%rax
    0.00 :	  5ba5c5:       48 85 c0                test   %rax,%rax
    0.00 :	  5ba5c8:       74 3a                   je     5ba604 <ExecAgg+0x884>
    0.00 :	  5ba5ca:       48 8b 70 08             mov    0x8(%rax),%rsi
    0.00 :	  5ba5ce:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5ba5d1:       74 31                   je     5ba604 <ExecAgg+0x884>
         :	        {
         :	                int                     varNumber = lfirst_int(l) - 1;
         :
         :	                hashslot->tts_values[varNumber] = inputslot->tts_values[varNumber];
    0.00 :	  5ba5d3:       8b 06                   mov    (%rsi),%eax
    0.00 :	  5ba5d5:       48 8b 53 28             mov    0x28(%rbx),%rdx
    0.00 :	  5ba5d9:       49 8b 4c 24 28          mov    0x28(%r12),%rcx
    0.00 :	  5ba5de:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ba5e1:       48 98                   cltq   
    0.00 :	  5ba5e3:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  5ba5e7:       48 89 14 c1             mov    %rdx,(%rcx,%rax,8)
         :	                hashslot->tts_isnull[varNumber] = inputslot->tts_isnull[varNumber];
    0.00 :	  5ba5eb:       48 8b 53 30             mov    0x30(%rbx),%rdx
    0.00 :	  5ba5ef:       49 8b 4c 24 30          mov    0x30(%r12),%rcx
    0.00 :	  5ba5f4:       0f b6 14 02             movzbl (%rdx,%rax,1),%edx
    0.00 :	  5ba5f8:       88 14 01                mov    %dl,(%rcx,%rax,1)
         :	                ExecStoreAllNullTuple(hashslot);
         :	        }
         :
         :	        /* transfer just the needed columns into hashslot */
         :	        slot_getsomeattrs(inputslot, linitial_int(aggstate->hash_needed));
         :	        foreach(l, aggstate->hash_needed)
    0.00 :	  5ba5fb:       48 8b 76 08             mov    0x8(%rsi),%rsi
    0.00 :	  5ba5ff:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5ba602:       75 cf                   jne    5ba5d3 <ExecAgg+0x853>
         :	                hashslot->tts_values[varNumber] = inputslot->tts_values[varNumber];
         :	                hashslot->tts_isnull[varNumber] = inputslot->tts_isnull[varNumber];
         :	        }
         :
         :	        /* find or create the hashtable entry using the filtered tuple */
         :	        entry = (AggHashEntry) LookupTupleHashEntry(aggstate->hashtable,
    0.00 :	  5ba604:       49 8b be e8 00 00 00    mov    0xe8(%r14),%rdi
    0.00 :	  5ba60b:       48 8d 55 d4             lea    -0x2c(%rbp),%rdx
    0.00 :	  5ba60f:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba612:       e8 59 e8 fe ff          callq  5a8e70 <LookupTupleHashEntry>
         :	                                                                                                hashslot,
         :	                                                                                                &isnew);
         :
         :	        if (isnew)
    0.00 :	  5ba617:       80 7d d4 00             cmpb   $0x0,-0x2c(%rbp)
    0.00 :	  5ba61b:       48 8d 58 08             lea    0x8(%rax),%rbx
    0.00 :	  5ba61f:       74 12                   je     5ba633 <ExecAgg+0x8b3>
         :	        {
         :	                /* initialize aggregates for new tuple group */
         :	                initialize_aggregates(aggstate, aggstate->peragg, entry->pergroup);
    0.00 :	  5ba621:       49 8b b6 b0 00 00 00    mov    0xb0(%r14),%rsi
    0.00 :	  5ba628:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5ba62b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba62e:       e8 9d ef ff ff          callq  5b95d0 <initialize_aggregates>
         :
         :	                /* Find or build hashtable entry for this tuple's group */
         :	                entry = lookup_hash_entry(aggstate, outerslot);
         :
         :	                /* Advance the aggregates */
         :	                advance_aggregates(aggstate, entry->pergroup);
    0.00 :	  5ba633:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba636:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5ba639:       e8 12 f3 ff ff          callq  5b9950 <advance_aggregates>
         :
         :	                /* Reset per-input-tuple context after each tuple */
         :	                ResetExprContext(tmpcontext);
    0.00 :	  5ba63e:       49 8b 7f 28             mov    0x28(%r15),%rdi
    0.00 :	  5ba642:       e8 69 e3 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba647:       e9 11 ff ff ff          jmpq   5ba55d <ExecAgg+0x7dd>
         :	        }
         :
         :	        aggstate->table_filled = true;
         :	        /* Initialize to walk the hash table */
         :	        ResetTupleHashIterator(aggstate->hashtable, &aggstate->hashiter);
    0.00 :	  5ba64c:       49 8b 86 e8 00 00 00    mov    0xe8(%r14),%rax
         :
         :	                /* Reset per-input-tuple context after each tuple */
         :	                ResetExprContext(tmpcontext);
         :	        }
         :
         :	        aggstate->table_filled = true;
    0.00 :	  5ba653:       41 c6 86 00 01 00 00    movb   $0x1,0x100(%r14)
    0.00 :	  5ba65a:       01 
         :	        /* Initialize to walk the hash table */
         :	        ResetTupleHashIterator(aggstate->hashtable, &aggstate->hashiter);
    0.00 :	  5ba65b:       4d 8d be 08 01 00 00    lea    0x108(%r14),%r15
    0.00 :	  5ba662:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5ba665:       e8 f6 92 1c 00          callq  783960 <hash_freeze>
    0.00 :	  5ba66a:       49 8b 86 e8 00 00 00    mov    0xe8(%r14),%rax
    0.00 :	  5ba671:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba674:       48 8b 30                mov    (%rax),%rsi
    0.00 :	  5ba677:       e8 b4 97 1c 00          callq  783e30 <hash_seq_init>
    0.00 :	  5ba67c:       41 0f b6 86 d0 00 00    movzbl 0xd0(%r14),%eax
    0.00 :	  5ba683:       00 
    0.00 :	  5ba684:       e9 6c f7 ff ff          jmpq   5b9df5 <ExecAgg+0x75>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c5930 <SeqNext>:
         :	 *              This is a workhorse for ExecSeqScan
         :	 * ----------------------------------------------------------------
         :	 */
         :	static TupleTableSlot *
         :	SeqNext(SeqScanState *node)
         :	{
    0.00 :	  5c5930:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
   50.00 :	  5c5931:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c5934:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  5c5938:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
   50.00 :	  5c593c:       48 83 ec 10             sub    $0x10,%rsp
         :	        slot = node->ss_ScanTupleSlot;
         :
         :	        /*
         :	         * get the next tuple from the table
         :	         */
         :	        tuple = heap_getnext(scandesc, direction);
    0.00 :	  5c5940:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	        TupleTableSlot *slot;
         :
         :	        /*
         :	         * get information from the estate and scan state
         :	         */
         :	        scandesc = node->ss_currentScanDesc;
    0.00 :	  5c5944:       4c 8b a7 80 00 00 00    mov    0x80(%rdi),%r12
         :	        estate = node->ps.state;
         :	        direction = estate->es_direction;
         :	        slot = node->ss_ScanTupleSlot;
    0.00 :	  5c594b:       48 8b 9f 88 00 00 00    mov    0x88(%rdi),%rbx
         :
         :	        /*
         :	         * get the next tuple from the table
         :	         */
         :	        tuple = heap_getnext(scandesc, direction);
    0.00 :	  5c5952:       8b 70 04                mov    0x4(%rax),%esi
    0.00 :	  5c5955:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c5958:       e8 33 15 ed ff          callq  496e90 <heap_getnext>
         :	         * tuples returned by heap_getnext() are pointers onto disk pages and were
         :	         * not created with palloc() and so should not be pfree()'d.  Note also
         :	         * that ExecStoreTuple will increment the refcount of the buffer; the
         :	         * refcount will not be dropped until the tuple table slot is cleared.
         :	         */
         :	        if (tuple)
    0.00 :	  5c595d:       48 85 c0                test   %rax,%rax
    0.00 :	  5c5960:       74 26                   je     5c5988 <SeqNext+0x58>
         :	                ExecStoreTuple(tuple,   /* tuple to store */
    0.00 :	  5c5962:       41 8b 54 24 64          mov    0x64(%r12),%edx
    0.00 :	  5c5967:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5c5969:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5c596c:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5c596f:       e8 0c eb fe ff          callq  5b4480 <ExecStoreTuple>
         :	                                           false);      /* don't pfree this pointer */
         :	        else
         :	                ExecClearTuple(slot);
         :
         :	        return slot;
         :	}
    0.00 :	  5c5974:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5c5977:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  5c597c:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5c5980:       c9                      leaveq 
    0.00 :	  5c5981:       c3                      retq   
    0.00 :	  5c5982:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                           slot,        /* slot to store in */
         :	                                           scandesc->rs_cbuf,           /* buffer associated with this
         :	                                                                                                 * tuple */
         :	                                           false);      /* don't pfree this pointer */
         :	        else
         :	                ExecClearTuple(slot);
    0.00 :	  5c5988:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5c598b:       e8 80 e7 fe ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5c5990:       eb e2                   jmp    5c5974 <SeqNext+0x44>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSort.c:61
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSort.c:103
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c6340 <ExecSort>:
         :	 *                -- the outer child is prepared to return the first tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecSort(SortState *node)
         :	{
    0.00 :	  5c6340:       55                      push   %rbp
    0.00 :	  5c6341:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c6344:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  5c6348:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  5c634c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5c634f:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  5c6353:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  5c6357:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  5c635b:       48 83 ec 40             sub    $0x40,%rsp
         :	         * get state info from node
         :	         */
         :	        SO1_printf("ExecSort: %s\n",
         :	                           "entering routine");
         :
         :	        estate = node->ss.ps.state;
    0.00 :	  5c635f:       4c 8b 7f 10             mov    0x10(%rdi),%r15
         :	        /*
         :	         * If first time through, read all tuples from outer plan and pass them to
         :	         * tuplesort.c. Subsequent calls just fetch tuples from tuplesort.
         :	         */
         :
         :	        if (!node->sort_Done)
    0.00 :	  5c6363:       41 80 bc 24 a0 00 00    cmpb   $0x0,0xa0(%r12)
    0.00 :	  5c636a:       00 00 
         :	         */
         :	        SO1_printf("ExecSort: %s\n",
         :	                           "entering routine");
         :
         :	        estate = node->ss.ps.state;
         :	        dir = estate->es_direction;
    0.00 :	  5c636c:       41 8b 47 04             mov    0x4(%r15),%eax
    0.00 :	  5c6370:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :	        tuplesortstate = (Tuplesortstate *) node->tuplesortstate;
    0.00 :	  5c6373:       48 8b bf b0 00 00 00    mov    0xb0(%rdi),%rdi
    0.00 :	  5c637a:       49 89 fd                mov    %rdi,%r13
         :	        /*
         :	         * If first time through, read all tuples from outer plan and pass them to
         :	         * tuplesort.c. Subsequent calls just fetch tuples from tuplesort.
         :	         */
         :
         :	        if (!node->sort_Done)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSort.c:61
   50.00 :	  5c637d:       74 39                   je     5c63b8 <ExecSort+0x78>
         :	        /*
         :	         * Get the first or next tuple from tuplesort. Returns NULL if no more
         :	         * tuples.
         :	         */
         :	        slot = node->ss.ps.ps_ResultTupleSlot;
         :	        (void) tuplesort_gettupleslot(tuplesortstate,
    0.00 :	  5c637f:       31 f6                   xor    %esi,%esi
    0.00 :	  5c6381:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
         :
         :	        /*
         :	         * Get the first or next tuple from tuplesort. Returns NULL if no more
         :	         * tuples.
         :	         */
         :	        slot = node->ss.ps.ps_ResultTupleSlot;
    0.00 :	  5c6385:       49 8b 5c 24 58          mov    0x58(%r12),%rbx
         :	        (void) tuplesort_gettupleslot(tuplesortstate,
    0.00 :	  5c638a:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5c638d:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5c6390:       40 0f 94 c6             sete   %sil
    0.00 :	  5c6394:       e8 f7 7e 1d 00          callq  79e290 <tuplesort_gettupleslot>
         :	                                                                  ScanDirectionIsForward(dir),
         :	                                                                  slot);
         :	        return slot;
         :	}
    0.00 :	  5c6399:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5c639c:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5c63a0:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5c63a4:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5c63a8:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5c63ac:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5c63b0:       c9                      leaveq 
    0.00 :	  5c63b1:       c3                      retq   
    0.00 :	  5c63b2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * tuplesort.c. Subsequent calls just fetch tuples from tuplesort.
         :	         */
         :
         :	        if (!node->sort_Done)
         :	        {
         :	                Sort       *plannode = (Sort *) node->ss.ps.plan;
    0.00 :	  5c63b8:       49 8b 5c 24 08          mov    0x8(%r12),%rbx
         :
         :	                /*
         :	                 * Want to scan subplan in the forward direction while creating the
         :	                 * sorted data.
         :	                 */
         :	                estate->es_direction = ForwardScanDirection;
    0.00 :	  5c63bd:       41 c7 47 04 01 00 00    movl   $0x1,0x4(%r15)
    0.00 :	  5c63c4:       00 
         :	                 * Initialize tuplesort module.
         :	                 */
         :	                SO1_printf("ExecSort: %s\n",
         :	                                   "calling tuplesort_begin");
         :
         :	                outerNode = outerPlanState(node);
    0.00 :	  5c63c5:       4d 8b 74 24 30          mov    0x30(%r12),%r14
         :	                tupDesc = ExecGetResultType(outerNode);
    0.00 :	  5c63ca:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5c63cd:       e8 3e e5 fe ff          callq  5b4910 <ExecGetResultType>
    0.00 :	  5c63d2:       48 89 c7                mov    %rax,%rdi
         :
         :	                tuplesortstate = tuplesort_begin_heap(tupDesc,
    0.00 :	  5c63d5:       41 0f be 84 24 90 00    movsbl 0x90(%r12),%eax
    0.00 :	  5c63dc:       00 00 
    0.00 :	  5c63de:       4c 8b 8b 80 00 00 00    mov    0x80(%rbx),%r9
    0.00 :	  5c63e5:       4c 8b 43 78             mov    0x78(%rbx),%r8
    0.00 :	  5c63e9:       48 8b 4b 70             mov    0x70(%rbx),%rcx
    0.00 :	  5c63ed:       48 8b 53 68             mov    0x68(%rbx),%rdx
    0.00 :	  5c63f1:       8b 73 60                mov    0x60(%rbx),%esi
    0.00 :	  5c63f4:       89 44 24 08             mov    %eax,0x8(%rsp)
    0.00 :	  5c63f8:       8b 05 1a 27 5a 00       mov    0x5a271a(%rip),%eax        # b68b18 <work_mem>
    0.00 :	  5c63fe:       89 04 24                mov    %eax,(%rsp)
    0.00 :	  5c6401:       e8 ea 92 1d 00          callq  79f6f0 <tuplesort_begin_heap>
         :	                                                                                          plannode->sortOperators,
         :	                                                                                          plannode->collations,
         :	                                                                                          plannode->nullsFirst,
         :	                                                                                          work_mem,
         :	                                                                                          node->randomAccess);
         :	                if (node->bounded)
    0.00 :	  5c6406:       41 80 bc 24 91 00 00    cmpb   $0x0,0x91(%r12)
    0.00 :	  5c640d:       00 00 
         :	                                   "calling tuplesort_begin");
         :
         :	                outerNode = outerPlanState(node);
         :	                tupDesc = ExecGetResultType(outerNode);
         :
         :	                tuplesortstate = tuplesort_begin_heap(tupDesc,
    0.00 :	  5c640f:       49 89 c5                mov    %rax,%r13
         :	                                                                                          plannode->sortOperators,
         :	                                                                                          plannode->collations,
         :	                                                                                          plannode->nullsFirst,
         :	                                                                                          work_mem,
         :	                                                                                          node->randomAccess);
         :	                if (node->bounded)
    0.00 :	  5c6412:       75 6c                   jne    5c6480 <ExecSort+0x140>
         :	                        tuplesort_set_bound(tuplesortstate, node->bound);
         :	                node->tuplesortstate = (void *) tuplesortstate;
    0.00 :	  5c6414:       4d 89 ac 24 b0 00 00    mov    %r13,0xb0(%r12)
    0.00 :	  5c641b:       00 
    0.00 :	  5c641c:       eb 13                   jmp    5c6431 <ExecSort+0xf1>
    0.00 :	  5c641e:       66 90                   xchg   %ax,%ax
         :
         :	                for (;;)
         :	                {
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                        if (TupIsNull(slot))
    0.00 :	  5c6420:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c6424:       75 18                   jne    5c643e <ExecSort+0xfe>
         :	                                break;
         :
         :	                        tuplesort_puttupleslot(tuplesortstate, slot);
    0.00 :	  5c6426:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5c6429:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5c642c:       e8 ff 8b 1d 00          callq  79f030 <tuplesort_puttupleslot>
         :	                 * Scan the subplan and feed all the tuples to tuplesort.
         :	                 */
         :
         :	                for (;;)
         :	                {
         :	                        slot = ExecProcNode(outerNode);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSort.c:103
   50.00 :	  5c6431:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5c6434:       e8 67 60 fe ff          callq  5ac4a0 <ExecProcNode>
         :
         :	                        if (TupIsNull(slot))
    0.00 :	  5c6439:       48 85 c0                test   %rax,%rax
    0.00 :	  5c643c:       75 e2                   jne    5c6420 <ExecSort+0xe0>
         :	                }
         :
         :	                /*
         :	                 * Complete the sort.
         :	                 */
         :	                tuplesort_performsort(tuplesortstate);
    0.00 :	  5c643e:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5c6441:       e8 aa bb 1d 00          callq  7a1ff0 <tuplesort_performsort>
         :
         :	                /*
         :	                 * restore to user specified direction
         :	                 */
         :	                estate->es_direction = dir;
    0.00 :	  5c6446:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  5c6449:       41 89 47 04             mov    %eax,0x4(%r15)
         :
         :	                /*
         :	                 * finally set the sorted flag to true
         :	                 */
         :	                node->sort_Done = true;
         :	                node->bounded_Done = node->bounded;
    0.00 :	  5c644d:       41 0f b6 84 24 91 00    movzbl 0x91(%r12),%eax
    0.00 :	  5c6454:       00 00 
         :	                estate->es_direction = dir;
         :
         :	                /*
         :	                 * finally set the sorted flag to true
         :	                 */
         :	                node->sort_Done = true;
    0.00 :	  5c6456:       41 c6 84 24 a0 00 00    movb   $0x1,0xa0(%r12)
    0.00 :	  5c645d:       00 01 
         :	                node->bounded_Done = node->bounded;
    0.00 :	  5c645f:       41 88 84 24 a1 00 00    mov    %al,0xa1(%r12)
    0.00 :	  5c6466:       00 
         :	                node->bound_Done = node->bound;
    0.00 :	  5c6467:       49 8b 84 24 98 00 00    mov    0x98(%r12),%rax
    0.00 :	  5c646e:       00 
    0.00 :	  5c646f:       49 89 84 24 a8 00 00    mov    %rax,0xa8(%r12)
    0.00 :	  5c6476:       00 
    0.00 :	  5c6477:       e9 03 ff ff ff          jmpq   5c637f <ExecSort+0x3f>
    0.00 :	  5c647c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                                                                          plannode->collations,
         :	                                                                                          plannode->nullsFirst,
         :	                                                                                          work_mem,
         :	                                                                                          node->randomAccess);
         :	                if (node->bounded)
         :	                        tuplesort_set_bound(tuplesortstate, node->bound);
    0.00 :	  5c6480:       49 8b b4 24 98 00 00    mov    0x98(%r12),%rsi
    0.00 :	  5c6487:       00 
    0.00 :	  5c6488:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5c648b:       e8 40 66 1d 00          callq  79cad0 <tuplesort_set_bound>
    0.00 :	  5c6490:       eb 82                   jmp    5c6414 <ExecSort+0xd4>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1364
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1362
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674d30 <UnpinBuffer>:
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    0.00 :	  674d30:       55                      push   %rbp
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1364
   50.00 :	  674d31:       31 d2                   xor    %edx,%edx
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    0.00 :	  674d33:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674d36:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  674d3a:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  674d3e:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  674d41:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  674d45:       48 83 ec 30             sub    $0x30,%rsp
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1362
   50.00 :	  674d49:       8b 7f 24                mov    0x24(%rdi),%edi
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    0.00 :	  674d4c:       41 89 f4                mov    %esi,%r12d
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
    0.00 :	  674d4f:       31 f6                   xor    %esi,%esi
    0.00 :	  674d51:       83 c7 01                add    $0x1,%edi
    0.00 :	  674d54:       e8 c7 f7 ff ff          callq  674520 <GetPrivateRefCountEntry>
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
    0.00 :	  674d59:       45 84 e4                test   %r12b,%r12b
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
    0.00 :	  674d5c:       49 89 c5                mov    %rax,%r13
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
    0.00 :	  674d5f:       0f 85 b3 00 00 00       jne    674e18 <UnpinBuffer+0xe8>
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
         :	                                                                  BufferDescriptorGetBuffer(buf));
         :
         :	        Assert(ref->refcount > 0);
         :	        ref->refcount--;
    0.00 :	  674d65:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  674d69:       83 e8 01                sub    $0x1,%eax
         :	        if (ref->refcount == 0)
    0.00 :	  674d6c:       85 c0                   test   %eax,%eax
         :	        if (fixOwner)
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
         :	                                                                  BufferDescriptorGetBuffer(buf));
         :
         :	        Assert(ref->refcount > 0);
         :	        ref->refcount--;
    0.00 :	  674d6e:       41 89 45 04             mov    %eax,0x4(%r13)
         :	        if (ref->refcount == 0)
    0.00 :	  674d72:       75 66                   jne    674dda <UnpinBuffer+0xaa>
         :	        {
         :	                /* I'd better not still hold any locks on the buffer */
         :	                Assert(!LWLockHeldByMe(buf->content_lock));
         :	                Assert(!LWLockHeldByMe(buf->io_in_progress_lock));
         :
         :	                LockBufHdr(buf);
    0.00 :	  674d74:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  674d78:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  674d7d:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  674d80:       84 c0                   test   %al,%al
    0.00 :	  674d82:       0f 85 a8 00 00 00       jne    674e30 <UnpinBuffer+0x100>
         :
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
    0.00 :	  674d88:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674d8b:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674d8e:       89 43 18                mov    %eax,0x18(%rbx)
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674d91:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674d95:       a8 40                   test   $0x40,%al
    0.00 :	  674d97:       75 57                   jne    674df0 <UnpinBuffer+0xc0>
         :	                        buf->flags &= ~BM_PIN_COUNT_WAITER;
         :	                        UnlockBufHdr(buf);
         :	                        ProcSendSignal(wait_backend_pid);
         :	                }
         :	                else
         :	                        UnlockBufHdr(buf);
    0.00 :	  674d99:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	static void
         :	ForgetPrivateRefCountEntry(PrivateRefCountEntry *ref)
         :	{
         :	        Assert(ref->refcount == 0);
         :
         :	        if (ref >= &PrivateRefCountArray[0] &&
    0.00 :	  674d9d:       49 81 fd c0 d0 b7 00    cmp    $0xb7d0c0,%r13
    0.00 :	  674da4:       72 0d                   jb     674db3 <UnpinBuffer+0x83>
    0.00 :	  674da6:       49 81 fd 00 d1 b7 00    cmp    $0xb7d100,%r13
    0.00 :	  674dad:       0f 82 95 00 00 00       jb     674e48 <UnpinBuffer+0x118>
         :	                ref->buffer = InvalidBuffer;
         :	        }
         :	        else
         :	        {
         :	                bool found;
         :	                Buffer buffer = ref->buffer;
    0.00 :	  674db3:       41 8b 45 00             mov    0x0(%r13),%eax
         :	                hash_search(PrivateRefCountHash,
    0.00 :	  674db7:       48 8b 3d ba 82 50 00    mov    0x5082ba(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  674dbe:       48 8d 4d e7             lea    -0x19(%rbp),%rcx
    0.00 :	  674dc2:       48 8d 75 e0             lea    -0x20(%rbp),%rsi
    0.00 :	  674dc6:       ba 02 00 00 00          mov    $0x2,%edx
         :	                ref->buffer = InvalidBuffer;
         :	        }
         :	        else
         :	        {
         :	                bool found;
         :	                Buffer buffer = ref->buffer;
    0.00 :	  674dcb:       89 45 e0                mov    %eax,-0x20(%rbp)
         :	                hash_search(PrivateRefCountHash,
    0.00 :	  674dce:       e8 cd f8 10 00          callq  7846a0 <hash_search>
         :	                                        (void *) &buffer,
         :	                                        HASH_REMOVE,
         :	                                        &found);
         :	                Assert(found);
         :	                Assert(PrivateRefCountOverflowed > 0);
         :	                PrivateRefCountOverflowed--;
    0.00 :	  674dd3:       83 2d 96 82 50 00 01    subl   $0x1,0x508296(%rip)        # b7d070 <PrivateRefCountOverflowed>
         :	                else
         :	                        UnlockBufHdr(buf);
         :
         :	                ForgetPrivateRefCountEntry(ref);
         :	        }
         :	}
    0.00 :	  674dda:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  674dde:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  674de2:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  674de6:       c9                      leaveq 
    0.00 :	  674de7:       c3                      retq   
    0.00 :	  674de8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  674def:       00 
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674df0:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674df3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674df6:       75 a1                   jne    674d99 <UnpinBuffer+0x69>
         :	                        buf->refcount == 1)
         :	                {
         :	                        /* we just released the last pin other than the waiter's */
         :	                        int                     wait_backend_pid = buf->wait_backend_pid;
    0.00 :	  674df8:       8b 7b 1c                mov    0x1c(%rbx),%edi
         :
         :	                        buf->flags &= ~BM_PIN_COUNT_WAITER;
    0.00 :	  674dfb:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674dff:       83 e0 bf                and    $0xffffffbf,%eax
    0.00 :	  674e02:       66 89 43 14             mov    %ax,0x14(%rbx)
         :	                        UnlockBufHdr(buf);
    0.00 :	  674e06:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                        ProcSendSignal(wait_backend_pid);
    0.00 :	  674e0a:       e8 b1 76 01 00          callq  68c4c0 <ProcSendSignal>
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674e0f:       eb 8c                   jmp    674d9d <UnpinBuffer+0x6d>
    0.00 :	  674e11:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
    0.00 :	  674e18:       8b 73 24                mov    0x24(%rbx),%esi
    0.00 :	  674e1b:       48 8b 3d 9e 5a 54 00    mov    0x545a9e(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674e22:       83 c6 01                add    $0x1,%esi
    0.00 :	  674e25:       e8 d6 5a 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
    0.00 :	  674e2a:       e9 36 ff ff ff          jmpq   674d65 <UnpinBuffer+0x35>
    0.00 :	  674e2f:       90                      nop
         :	        {
         :	                /* I'd better not still hold any locks on the buffer */
         :	                Assert(!LWLockHeldByMe(buf->content_lock));
         :	                Assert(!LWLockHeldByMe(buf->io_in_progress_lock));
         :
         :	                LockBufHdr(buf);
    0.00 :	  674e30:       ba 63 05 00 00          mov    $0x563,%edx
    0.00 :	  674e35:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  674e3a:       e8 01 b2 01 00          callq  690040 <s_lock>
    0.00 :	  674e3f:       e9 44 ff ff ff          jmpq   674d88 <UnpinBuffer+0x58>
    0.00 :	  674e44:       0f 1f 40 00             nopl   0x0(%rax)
         :	        Assert(ref->refcount == 0);
         :
         :	        if (ref >= &PrivateRefCountArray[0] &&
         :	                ref < &PrivateRefCountArray[REFCOUNT_ARRAY_ENTRIES])
         :	        {
         :	                ref->buffer = InvalidBuffer;
    0.00 :	  674e48:       41 c7 45 00 00 00 00    movl   $0x0,0x0(%r13)
    0.00 :	  674e4f:       00 
    0.00 :	  674e50:       eb 88                   jmp    674dda <UnpinBuffer+0xaa>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:580
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1039
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000675ca0 <ReadBuffer_common>:
         :	 */
         :	static Buffer
         :	ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
         :	                                  BlockNumber blockNum, ReadBufferMode mode,
         :	                                  BufferAccessStrategy strategy, bool *hit)
         :	{
    0.00 :	  675ca0:       55                      push   %rbp
    0.00 :	  675ca1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  675ca4:       41 57                   push   %r15
    0.00 :	  675ca6:       4d 89 cf                mov    %r9,%r15
    0.00 :	  675ca9:       41 56                   push   %r14
    0.00 :	  675cab:       41 55                   push   %r13
    0.00 :	  675cad:       41 54                   push   %r12
    0.00 :	  675caf:       53                      push   %rbx
    0.00 :	  675cb0:       48 83 ec 68             sub    $0x68,%rsp
    0.00 :	  675cb4:       48 89 7d 80             mov    %rdi,-0x80(%rbp)
    0.00 :	  675cb8:       89 95 78 ff ff ff       mov    %edx,-0x88(%rbp)
    0.00 :	  675cbe:       89 8d 74 ff ff ff       mov    %ecx,-0x8c(%rbp)
    0.00 :	  675cc4:       44 89 85 70 ff ff ff    mov    %r8d,-0x90(%rbp)
    0.00 :	  675ccb:       40 88 b5 7f ff ff ff    mov    %sil,-0x81(%rbp)
         :	        volatile BufferDesc *bufHdr;
         :	        Block           bufBlock;
         :	        bool            found;
         :	        bool            isExtend;
         :	        bool            isLocalBuf = SmgrIsTemp(smgr);
    0.00 :	  675cd2:       83 7f 0c ff             cmpl   $0xffffffff,0xc(%rdi)
         :
         :	        *hit = false;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:580
   50.00 :	  675cd6:       48 8b 45 10             mov    0x10(%rbp),%rax
         :	{
         :	        volatile BufferDesc *bufHdr;
         :	        Block           bufBlock;
         :	        bool            found;
         :	        bool            isExtend;
         :	        bool            isLocalBuf = SmgrIsTemp(smgr);
    0.00 :	  675cda:       0f 95 45 8f             setne  -0x71(%rbp)
         :
         :	        *hit = false;
    0.00 :	  675cde:       c6 00 00                movb   $0x0,(%rax)
         :
         :	        /* Make sure we will have room to remember the buffer pin */
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  675ce1:       48 8b 3d d8 4b 54 00    mov    0x544bd8(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  675ce8:       e8 83 51 12 00          callq  79ae70 <ResourceOwnerEnlargeBuffers>
         :
         :	        isExtend = (blockNum == P_NEW);
    0.00 :	  675ced:       83 bd 74 ff ff ff ff    cmpl   $0xffffffff,-0x8c(%rbp)
         :	                                                                           smgr->smgr_rnode.node.relNode,
         :	                                                                           smgr->smgr_rnode.backend,
         :	                                                                           isExtend);
         :
         :	        /* Substitute proper block number if caller asked for P_NEW */
         :	        if (isExtend)
    0.00 :	  675cf4:       0f 94 45 8e             sete   -0x72(%rbp)
    0.00 :	  675cf8:       0f 84 2f 05 00 00       je     67622d <ReadBuffer_common+0x58d>
         :	                blockNum = smgrnblocks(smgr, forkNum);
         :
         :	        if (isLocalBuf)
    0.00 :	  675cfe:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675d02:       74 7b                   je     675d7f <ReadBuffer_common+0xdf>
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
    0.00 :	  675d04:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675d0a:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  675d10:       48 8d 4d cf             lea    -0x31(%rbp),%rcx
    0.00 :	  675d14:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  675d18:       e8 c3 20 00 00          callq  677de0 <LocalBufferAlloc>
         :	                if (found)
    0.00 :	  675d1d:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :	        if (isExtend)
         :	                blockNum = smgrnblocks(smgr, forkNum);
         :
         :	        if (isLocalBuf)
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
    0.00 :	  675d21:       49 89 c6                mov    %rax,%r14
         :	                if (found)
    0.00 :	  675d24:       0f 85 1b 04 00 00       jne    676145 <ReadBuffer_common+0x4a5>
         :	                        pgBufferUsage.local_blks_hit++;
         :	                else
         :	                        pgBufferUsage.local_blks_read++;
    0.00 :	  675d2a:       48 83 05 56 9a 54 00    addq   $0x1,0x549a56(%rip)        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  675d31:       01 
         :	        }
         :
         :	        /* At this point we do NOT hold any locks. */
         :
         :	        /* if it was already in the buffer pool, we're done */
         :	        if (found)
    0.00 :	  675d32:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  675d36:       0f 84 fa 00 00 00       je     675e36 <ReadBuffer_common+0x196>
         :	        {
         :	                if (!isExtend)
    0.00 :	  675d3c:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
    0.00 :	  675d40:       0f 85 01 05 00 00       jne    676247 <ReadBuffer_common+0x5a7>
         :	                {
         :	                        /* Just need to update stats before we exit */
         :	                        *hit = true;
    0.00 :	  675d46:       48 8b 45 10             mov    0x10(%rbp),%rax
    0.00 :	  675d4a:       c6 00 01                movb   $0x1,(%rax)
         :	                        VacuumPageHit++;
    0.00 :	  675d4d:       83 05 80 43 54 00 01    addl   $0x1,0x544380(%rip)        # bba0d4 <VacuumPageHit>
         :
         :	                        if (VacuumCostActive)
    0.00 :	  675d54:       80 3d 89 43 54 00 00    cmpb   $0x0,0x544389(%rip)        # bba0e4 <VacuumCostActive>
    0.00 :	  675d5b:       74 0c                   je     675d69 <ReadBuffer_common+0xc9>
         :	                                VacuumCostBalance += VacuumCostPageHit;
    0.00 :	  675d5d:       8b 05 c9 2d 4f 00       mov    0x4f2dc9(%rip),%eax        # b68b2c <VacuumCostPageHit>
    0.00 :	  675d63:       01 05 77 43 54 00       add    %eax,0x544377(%rip)        # bba0e0 <VacuumCostBalance>
         :	                                                                          smgr->smgr_rnode.node.relNode,
         :	                                                                          smgr->smgr_rnode.backend,
         :	                                                                          isExtend,
         :	                                                                          found);
         :
         :	        return BufferDescriptorGetBuffer(bufHdr);
    0.00 :	  675d69:       41 8b 46 24             mov    0x24(%r14),%eax
         :	}
    0.00 :	  675d6d:       48 83 c4 68             add    $0x68,%rsp
    0.00 :	  675d71:       5b                      pop    %rbx
    0.00 :	  675d72:       41 5c                   pop    %r12
    0.00 :	  675d74:       41 5d                   pop    %r13
    0.00 :	  675d76:       41 5e                   pop    %r14
         :	                                                                          smgr->smgr_rnode.node.relNode,
         :	                                                                          smgr->smgr_rnode.backend,
         :	                                                                          isExtend,
         :	                                                                          found);
         :
         :	        return BufferDescriptorGetBuffer(bufHdr);
    0.00 :	  675d78:       83 c0 01                add    $0x1,%eax
         :	}
    0.00 :	  675d7b:       41 5f                   pop    %r15
    0.00 :	  675d7d:       c9                      leaveq 
    0.00 :	  675d7e:       c3                      retq   
         :	        int                     buf_id;
         :	        volatile BufferDesc *buf;
         :	        bool            valid;
         :
         :	        /* create a tag so we can lookup the buffer */
         :	        INIT_BUFFERTAG(newTag, smgr->smgr_rnode.node, forkNum, blockNum);
    0.00 :	  675d7f:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  675d83:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  675d86:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  675d8a:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  675d8d:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675d93:       89 45 b8                mov    %eax,-0x48(%rbp)
    0.00 :	  675d96:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
    0.00 :	  675d9c:       89 55 c0                mov    %edx,-0x40(%rbp)
    0.00 :	  675d9f:       89 45 bc                mov    %eax,-0x44(%rbp)
    0.00 :	  675da2:       eb 11                   jmp    675db5 <ReadBuffer_common+0x115>
    0.00 :	  675da4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                valid = PinBuffer(foundbuf, strategy);
         :
         :	                /* Check whether someone recycled the buffer before we pinned it. */
         :	                if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
         :	                {
         :	                        UnpinBuffer(foundbuf, true);
    0.00 :	  675da8:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675dad:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675db0:       e8 7b ef ff ff          callq  674d30 <UnpinBuffer>
         :	        /* create a tag so we can lookup the buffer */
         :	        INIT_BUFFERTAG(newTag, smgr->smgr_rnode.node, forkNum, blockNum);
         :
         :	        /* see if the block is in the buffer pool already */
         :	start:
         :	        buf_id = BufTableLookup(&newTag);
    0.00 :	  675db5:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  675db9:       e8 22 e0 ff ff          callq  673de0 <BufTableLookup>
         :	        if (buf_id >= 0)
    0.00 :	  675dbe:       85 c0                   test   %eax,%eax
    0.00 :	  675dc0:       0f 88 bb 01 00 00       js     675f81 <ReadBuffer_common+0x2e1>
         :
         :	                /*
         :	                 * Found it.  Now, pin the buffer so no one can steal it from the
         :	                 * buffer pool.
         :	                 */
         :	                foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675dc6:       48 63 d8                movslq %eax,%rbx
         :
         :	                valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675dc9:       4c 89 fe                mov    %r15,%rsi
         :
         :	                /*
         :	                 * Found it.  Now, pin the buffer so no one can steal it from the
         :	                 * buffer pool.
         :	                 */
         :	                foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675dcc:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  675dd0:       48 03 1d 29 9d 54 00    add    0x549d29(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :
         :	                valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675dd7:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675dda:       49 89 dc                mov    %rbx,%r12
    0.00 :	  675ddd:       e8 4e ee ff ff          callq  674c30 <PinBuffer>
    0.00 :	  675de2:       89 c2                   mov    %eax,%edx
         :
         :	                /* Check whether someone recycled the buffer before we pinned it. */
         :	                if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
    0.00 :	  675de4:       8b 45 b8                mov    -0x48(%rbp),%eax
    0.00 :	  675de7:       3b 43 08                cmp    0x8(%rbx),%eax
    0.00 :	  675dea:       75 bc                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675dec:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  675def:       3b 43 04                cmp    0x4(%rbx),%eax
    0.00 :	  675df2:       75 b4                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675df4:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  675df7:       3b 03                   cmp    (%rbx),%eax
    0.00 :	  675df9:       75 ad                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675dfb:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  675dfe:       3b 43 10                cmp    0x10(%rbx),%eax
    0.00 :	  675e01:       75 a5                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675e03:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  675e06:       3b 43 0c                cmp    0xc(%rbx),%eax
    0.00 :	  675e09:       75 9d                   jne    675da8 <ReadBuffer_common+0x108>
         :	                }
         :
         :	                *foundPtr = TRUE;
         :
         :	                /* Check to see if the correct data has been loaded into the buffer. */
         :	                if (!valid)
    0.00 :	  675e0b:       84 d2                   test   %dl,%dl
         :	                {
         :	                        UnpinBuffer(foundbuf, true);
         :	                        goto start;
         :	                }
         :
         :	                *foundPtr = TRUE;
    0.00 :	  675e0d:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
         :
         :	                /* Check to see if the correct data has been loaded into the buffer. */
         :	                if (!valid)
    0.00 :	  675e11:       0f 84 33 02 00 00       je     67604a <ReadBuffer_common+0x3aa>
         :	                 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
         :	                 * not currently in memory.
         :	                 */
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
    0.00 :	  675e17:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :	                        pgBufferUsage.shared_blks_hit++;
    0.00 :	  675e1b:       4d 89 e6                mov    %r12,%r14
         :	                 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
         :	                 * not currently in memory.
         :	                 */
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
    0.00 :	  675e1e:       0f 84 9a 03 00 00       je     6761be <ReadBuffer_common+0x51e>
         :	                        pgBufferUsage.shared_blks_hit++;
    0.00 :	  675e24:       48 83 05 34 99 54 00    addq   $0x1,0x549934(%rip)        # bbf760 <pgBufferUsage>
    0.00 :	  675e2b:       01 
         :	        }
         :
         :	        /* At this point we do NOT hold any locks. */
         :
         :	        /* if it was already in the buffer pool, we're done */
         :	        if (found)
    0.00 :	  675e2c:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  675e30:       0f 85 06 ff ff ff       jne    675d3c <ReadBuffer_common+0x9c>
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  675e36:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675e3a:       0f 84 8b 03 00 00       je     6761cb <ReadBuffer_common+0x52b>
    0.00 :	  675e40:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  675e44:       ba fe ff ff ff          mov    $0xfffffffe,%edx
    0.00 :	  675e49:       29 c2                   sub    %eax,%edx
         :
         :	        if (isExtend)
    0.00 :	  675e4b:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  675e4f:       48 8b 05 c2 72 50 00    mov    0x5072c2(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  675e56:       48 63 d2                movslq %edx,%rdx
    0.00 :	  675e59:       4c 8b 24 d0             mov    (%rax,%rdx,8),%r12
         :
         :	        if (isExtend)
    0.00 :	  675e5d:       0f 85 84 03 00 00       jne    6761e7 <ReadBuffer_common+0x547>
         :	        {
         :	                /*
         :	                 * Read in the page, unless the caller intends to overwrite it and
         :	                 * just wants us to allocate a buffer.
         :	                 */
         :	                if (mode == RBM_ZERO)
    0.00 :	  675e63:       83 bd 70 ff ff ff 01    cmpl   $0x1,-0x90(%rbp)
    0.00 :	  675e6a:       74 7e                   je     675eea <ReadBuffer_common+0x24a>
         :	                else
         :	                {
         :	                        instr_time      io_start,
         :	                                                io_time;
         :
         :	                        if (track_io_timing)
    0.00 :	  675e6c:       80 3d ee 71 50 00 00    cmpb   $0x0,0x5071ee(%rip)        # b7d061 <track_io_timing>
    0.00 :	  675e73:       0f 85 d1 04 00 00       jne    67634a <ReadBuffer_common+0x6aa>
         :	                                INSTR_TIME_SET_CURRENT(io_start);
         :
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
    0.00 :	  675e79:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675e7f:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  675e85:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  675e88:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  675e8c:       e8 7f 35 02 00          callq  699410 <smgrread>
         :
         :	                        if (track_io_timing)
    0.00 :	  675e91:       80 3d c9 71 50 00 00    cmpb   $0x0,0x5071c9(%rip)        # b7d061 <track_io_timing>
    0.00 :	  675e98:       0f 85 bc 04 00 00       jne    67635a <ReadBuffer_common+0x6ba>
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
         :	                        }
         :
         :	                        /* check for garbage data */
         :	                        if (!PageIsVerified((Page) bufBlock, blockNum))
    0.00 :	  675e9e:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  675ea4:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  675ea7:       e8 24 f0 01 00          callq  694ed0 <PageIsVerified>
    0.00 :	  675eac:       84 c0                   test   %al,%al
    0.00 :	  675eae:       75 47                   jne    675ef7 <ReadBuffer_common+0x257>
         :	                        {
         :	                                if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
    0.00 :	  675eb0:       83 bd 70 ff ff ff 02    cmpl   $0x2,-0x90(%rbp)
    0.00 :	  675eb7:       74 0d                   je     675ec6 <ReadBuffer_common+0x226>
    0.00 :	  675eb9:       80 3d a0 71 50 00 00    cmpb   $0x0,0x5071a0(%rip)        # b7d060 <zero_damaged_pages>
    0.00 :	  675ec0:       0f 84 51 05 00 00       je     676417 <ReadBuffer_common+0x777>
         :	                                {
         :	                                        ereport(WARNING,
    0.00 :	  675ec6:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  675ec9:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  675ece:       ba f0 02 00 00          mov    $0x2f0,%edx
    0.00 :	  675ed3:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  675ed8:       bf 13 00 00 00          mov    $0x13,%edi
    0.00 :	  675edd:       e8 de 4b 10 00          callq  77aac0 <errstart>
    0.00 :	  675ee2:       84 c0                   test   %al,%al
    0.00 :	  675ee4:       0f 85 11 04 00 00       jne    6762fb <ReadBuffer_common+0x65b>
         :	                                                        (errcode(ERRCODE_DATA_CORRUPTED),
         :	                                                         errmsg("invalid page in block %u of relation %s; zeroing out page",
         :	                                                                        blockNum,
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                                        MemSet((char *) bufBlock, 0, BLCKSZ);
    0.00 :	  675eea:       b9 00 04 00 00          mov    $0x400,%ecx
    0.00 :	  675eef:       31 c0                   xor    %eax,%eax
    0.00 :	  675ef1:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  675ef4:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                        }
         :	                }
         :	        }
         :
         :	        if (isLocalBuf)
    0.00 :	  675ef7:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675efb:       0f 84 18 03 00 00       je     676219 <ReadBuffer_common+0x579>
         :	        {
         :	                /* Only need to adjust flags */
         :	                bufHdr->flags |= BM_VALID;
    0.00 :	  675f01:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  675f06:       83 c8 02                or     $0x2,%eax
    0.00 :	  675f09:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        {
         :	                /* Set BM_VALID, terminate IO, and wake up any waiters */
         :	                TerminateBufferIO(bufHdr, false, BM_VALID);
         :	        }
         :
         :	        VacuumPageMiss++;
    0.00 :	  675f0e:       83 05 c3 41 54 00 01    addl   $0x1,0x5441c3(%rip)        # bba0d8 <VacuumPageMiss>
         :	        if (VacuumCostActive)
    0.00 :	  675f15:       80 3d c8 41 54 00 00    cmpb   $0x0,0x5441c8(%rip)        # bba0e4 <VacuumCostActive>
    0.00 :	  675f1c:       0f 84 47 fe ff ff       je     675d69 <ReadBuffer_common+0xc9>
         :	                VacuumCostBalance += VacuumCostPageMiss;
    0.00 :	  675f22:       8b 05 08 2c 4f 00       mov    0x4f2c08(%rip),%eax        # b68b30 <VacuumCostPageMiss>
    0.00 :	  675f28:       01 05 b2 41 54 00       add    %eax,0x5441b2(%rip)        # bba0e0 <VacuumCostBalance>
    0.00 :	  675f2e:       e9 36 fe ff ff          jmpq   675d69 <ReadBuffer_common+0xc9>
    0.00 :	  675f33:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                }
         :
         :	                /*
         :	                 * Need to lock the buffer header too in order to change its tag.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  675f38:       49 8d 5e 20             lea    0x20(%r14),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  675f3c:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  675f41:       f0 86 03                lock xchg %al,(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1039
   50.00 :	  675f44:       84 c0                   test   %al,%al
    0.00 :	  675f46:       0f 85 a4 01 00 00       jne    6760f0 <ReadBuffer_common+0x450>
         :	                 * Somebody could have pinned or re-dirtied the buffer while we were
         :	                 * doing the I/O and making the new hashtable entry.  If so, we can't
         :	                 * recycle this buffer; we must undo everything we've done and start
         :	                 * over with a new victim buffer.
         :	                 */
         :	                oldFlags = buf->flags;
    0.00 :	  675f4c:       41 0f b7 56 14          movzwl 0x14(%r14),%edx
         :	                if (buf->refcount == 1 && !(oldFlags & BM_DIRTY))
    0.00 :	  675f51:       41 8b 46 18             mov    0x18(%r14),%eax
    0.00 :	  675f55:       83 e8 01                sub    $0x1,%eax
    0.00 :	  675f58:       75 0c                   jne    675f66 <ReadBuffer_common+0x2c6>
    0.00 :	  675f5a:       0f b7 d2                movzwl %dx,%edx
    0.00 :	  675f5d:       f6 c2 01                test   $0x1,%dl
    0.00 :	  675f60:       0f 84 ec 01 00 00       je     676152 <ReadBuffer_common+0x4b2>
         :	                        break;
         :
         :	                UnlockBufHdr(buf);
         :	                BufTableDelete(&newTag);
    0.00 :	  675f66:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
         :	                 */
         :	                oldFlags = buf->flags;
         :	                if (buf->refcount == 1 && !(oldFlags & BM_DIRTY))
         :	                        break;
         :
         :	                UnlockBufHdr(buf);
    0.00 :	  675f6a:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :	                BufTableDelete(&newTag);
    0.00 :	  675f6f:       e8 dc dd ff ff          callq  673d50 <BufTableDelete>
         :	                UnpinBuffer(buf, true);
    0.00 :	  675f74:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675f79:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  675f7c:       e8 af ed ff ff          callq  674d30 <UnpinBuffer>
         :	        {
         :	                /*
         :	                 * Select a victim buffer.  The buffer is returned with its header
         :	                 * spinlock still held!
         :	                 */
         :	                buf = StrategyGetBuffer(strategy);
    0.00 :	  675f81:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  675f84:       e8 d7 15 00 00          callq  677560 <StrategyGetBuffer>
         :
         :	                Assert(buf->refcount == 0);
         :
         :	                /* Must copy buffer flags while we still hold the spinlock */
         :	                oldFlags = buf->flags;
    0.00 :	  675f89:       0f b7 58 14             movzwl 0x14(%rax),%ebx
         :
         :	                /* Pin the buffer and then release the buffer spinlock */
         :	                PinBuffer_Locked(buf);
    0.00 :	  675f8d:       48 89 c7                mov    %rax,%rdi
         :	        {
         :	                /*
         :	                 * Select a victim buffer.  The buffer is returned with its header
         :	                 * spinlock still held!
         :	                 */
         :	                buf = StrategyGetBuffer(strategy);
    0.00 :	  675f90:       49 89 c6                mov    %rax,%r14
         :
         :	                /* Must copy buffer flags while we still hold the spinlock */
         :	                oldFlags = buf->flags;
         :
         :	                /* Pin the buffer and then release the buffer spinlock */
         :	                PinBuffer_Locked(buf);
    0.00 :	  675f93:       e8 38 ec ff ff          callq  674bd0 <PinBuffer_Locked>
         :	                 * condition here, in that someone might dirty it after we released it
         :	                 * above, or even while we are writing it out (since our share-lock
         :	                 * won't prevent hint-bit updates).  We will recheck the dirty bit
         :	                 * after re-locking the buffer header.
         :	                 */
         :	                if (oldFlags & BM_DIRTY)
    0.00 :	  675f98:       0f b7 db                movzwl %bx,%ebx
    0.00 :	  675f9b:       f6 c3 01                test   $0x1,%bl
    0.00 :	  675f9e:       0f 85 cc 00 00 00       jne    676070 <ReadBuffer_common+0x3d0>
         :
         :	                /*
         :	                 * To change the association of a valid buffer, we'll need to have
         :	                 * exclusive lock on both the old and new mapping partitions.
         :	                 */
         :	                if (oldFlags & BM_TAG_VALID)
    0.00 :	  675fa4:       83 e3 04                and    $0x4,%ebx
    0.00 :	  675fa7:       74 2c                   je     675fd5 <ReadBuffer_common+0x335>
         :	                {
         :	                        /* Save old tag. */
         :	                        oldTag = buf->tag;
    0.00 :	  675fa9:       49 8b 06                mov    (%r14),%rax
    0.00 :	  675fac:       48 89 45 90             mov    %rax,-0x70(%rbp)
    0.00 :	  675fb0:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  675fb4:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	  675fb8:       41 8b 46 10             mov    0x10(%r14),%eax
    0.00 :	  675fbc:       89 45 a0                mov    %eax,-0x60(%rbp)
    0.00 :	  675fbf:       eb 14                   jmp    675fd5 <ReadBuffer_common+0x335>
    0.00 :	  675fc1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
         :	                        valid = PinBuffer(foundbuf, strategy);
         :	                        if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
         :	                        {
         :	                                UnpinBuffer(foundbuf, true);
    0.00 :	  675fc8:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675fcd:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675fd0:       e8 5b ed ff ff          callq  674d30 <UnpinBuffer>
         :	                 * allocated another buffer for the same block we want to read in.
         :	                 * Note that we have not yet removed the hashtable entry for the old
         :	                 * tag.
         :	                 */
         :	enter:
         :	                buf_id = BufTableInsert(&newTag, buf->buf_id);
    0.00 :	  675fd5:       41 8b 76 24             mov    0x24(%r14),%esi
    0.00 :	  675fd9:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  675fdd:       e8 be dd ff ff          callq  673da0 <BufTableInsert>
         :
         :	                if (buf_id >= 0)
    0.00 :	  675fe2:       85 c0                   test   %eax,%eax
    0.00 :	  675fe4:       0f 88 4e ff ff ff       js     675f38 <ReadBuffer_common+0x298>
         :	                         * did what we were about to do.  We can handle this as if we had
         :	                         * found the buffer in the pool in the first place, but we must
         :	                         * recheck the buffer tag after pinning it, because it could still
         :	                         * get renamed under us.
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675fea:       48 63 d8                movslq %eax,%rbx
         :	                        valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675fed:       4c 89 fe                mov    %r15,%rsi
         :	                         * did what we were about to do.  We can handle this as if we had
         :	                         * found the buffer in the pool in the first place, but we must
         :	                         * recheck the buffer tag after pinning it, because it could still
         :	                         * get renamed under us.
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675ff0:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  675ff4:       48 03 1d 05 9b 54 00    add    0x549b05(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	                        valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675ffb:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675ffe:       49 89 dc                mov    %rbx,%r12
    0.00 :	  676001:       e8 2a ec ff ff          callq  674c30 <PinBuffer>
    0.00 :	  676006:       41 89 c5                mov    %eax,%r13d
         :	                        if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
    0.00 :	  676009:       8b 45 b8                mov    -0x48(%rbp),%eax
    0.00 :	  67600c:       3b 43 08                cmp    0x8(%rbx),%eax
    0.00 :	  67600f:       75 b7                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676011:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  676014:       3b 43 04                cmp    0x4(%rbx),%eax
    0.00 :	  676017:       75 af                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676019:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  67601c:       3b 03                   cmp    (%rbx),%eax
    0.00 :	  67601e:       75 a8                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676020:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  676023:       3b 43 10                cmp    0x10(%rbx),%eax
    0.00 :	  676026:       75 a0                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676028:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  67602b:       3b 43 0c                cmp    0xc(%rbx),%eax
    0.00 :	  67602e:       75 98                   jne    675fc8 <ReadBuffer_common+0x328>
         :
         :	                        /*
         :	                         * Collision confirmed.  Give up the buffer we were planning to
         :	                         * use.
         :	                         */
         :	                        UnpinBuffer(buf, true);
    0.00 :	  676030:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676035:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676038:       e8 f3 ec ff ff          callq  674d30 <UnpinBuffer>
         :
         :	                        *foundPtr = TRUE;
         :
         :	                        if (!valid)
    0.00 :	  67603d:       45 84 ed                test   %r13b,%r13b
         :	                         * Collision confirmed.  Give up the buffer we were planning to
         :	                         * use.
         :	                         */
         :	                        UnpinBuffer(buf, true);
         :
         :	                        *foundPtr = TRUE;
    0.00 :	  676040:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
         :
         :	                        if (!valid)
    0.00 :	  676044:       0f 85 cd fd ff ff       jne    675e17 <ReadBuffer_common+0x177>
         :	                                 * in the page, or (b) a previous read attempt failed.  We
         :	                                 * have to wait for any active read attempt to finish, and
         :	                                 * then set up our own read attempt if the page is still not
         :	                                 * BM_VALID.  StartBufferIO does it all.
         :	                                 */
         :	                                if (StartBufferIO(foundbuf, true))
    0.00 :	  67604a:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67604f:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  676052:       e8 e9 e3 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  676057:       84 c0                   test   %al,%al
    0.00 :	  676059:       0f 84 b8 fd ff ff       je     675e17 <ReadBuffer_common+0x177>
         :	                                {
         :	                                        /*
         :	                                         * If we get here, previous attempts to read the buffer
         :	                                         * must have failed ... but we shall bravely try again.
         :	                                         */
         :	                                        *foundPtr = FALSE;
    0.00 :	  67605f:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
    0.00 :	  676063:       e9 af fd ff ff          jmpq   675e17 <ReadBuffer_common+0x177>
    0.00 :	  676068:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  67606f:       00 
         :	                         * (This has been observed to happen when two backends are both
         :	                         * trying to split btree index pages, and the second one just
         :	                         * happens to be trying to split the page the first one got from
         :	                         * StrategyGetBuffer.)
         :	                         */
         :	                        if (LWLockConditionalAcquire(buf->content_lock, LW_SHARED))
    0.00 :	  676070:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  676074:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676079:       e8 22 8f 01 00          callq  68efa0 <LWLockConditionalAcquire>
    0.00 :	  67607e:       84 c0                   test   %al,%al
    0.00 :	  676080:       0f 84 ee fe ff ff       je     675f74 <ReadBuffer_common+0x2d4>
         :	                                 * would require a WAL flush, let the strategy decide whether
         :	                                 * to go ahead and write/reuse the buffer or to choose another
         :	                                 * victim.  We need lock to inspect the page LSN, so this
         :	                                 * can't be done inside StrategyGetBuffer.
         :	                                 */
         :	                                if (strategy != NULL)
    0.00 :	  676086:       4d 85 ff                test   %r15,%r15
    0.00 :	  676089:       74 4c                   je     6760d7 <ReadBuffer_common+0x437>
         :	                                {
         :	                                        XLogRecPtr      lsn;
         :
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
    0.00 :	  67608b:       49 8d 7e 20             lea    0x20(%r14),%rdi
    0.00 :	  67608f:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  676094:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  676097:       84 c0                   test   %al,%al
    0.00 :	  676099:       0f 85 92 00 00 00       jne    676131 <ReadBuffer_common+0x491>
         :	                                        lsn = BufferGetLSN(buf);
    0.00 :	  67609f:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6760a3:       41 8b 56 24             mov    0x24(%r14),%edx
    0.00 :	  6760a7:       48 8b 0d 4a 9a 54 00    mov    0x549a4a(%rip),%rcx        # bbfaf8 <BufferBlocks>
    0.00 :	  6760ae:       48 98                   cltq   
    0.00 :	  6760b0:       48 63 d2                movslq %edx,%rdx
    0.00 :	  6760b3:       48 c1 e0 0d             shl    $0xd,%rax
    0.00 :	  6760b7:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  6760bb:       8b 3c 01                mov    (%rcx,%rax,1),%edi
    0.00 :	  6760be:       8b 44 11 04             mov    0x4(%rcx,%rdx,1),%eax
    0.00 :	  6760c2:       48 c1 e7 20             shl    $0x20,%rdi
    0.00 :	  6760c6:       48 09 c7                or     %rax,%rdi
         :	                                        UnlockBufHdr(buf);
    0.00 :	  6760c9:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :
         :	                                        if (XLogNeedsFlush(lsn) &&
    0.00 :	  6760ce:       e8 dd dc e5 ff          callq  4d3db0 <XLogNeedsFlush>
    0.00 :	  6760d3:       84 c0                   test   %al,%al
    0.00 :	  6760d5:       75 30                   jne    676107 <ReadBuffer_common+0x467>
         :	                                TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START(forkNum, blockNum,
         :	                                                                                           smgr->smgr_rnode.node.spcNode,
         :	                                                                                                smgr->smgr_rnode.node.dbNode,
         :	                                                                                          smgr->smgr_rnode.node.relNode);
         :
         :	                                FlushBuffer(buf, NULL);
    0.00 :	  6760d7:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6760da:       31 f6                   xor    %esi,%esi
    0.00 :	  6760dc:       e8 6f ee ff ff          callq  674f50 <FlushBuffer>
         :	                                LWLockRelease(buf->content_lock);
    0.00 :	  6760e1:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  6760e5:       e8 b6 92 01 00          callq  68f3a0 <LWLockRelease>
    0.00 :	  6760ea:       e9 b5 fe ff ff          jmpq   675fa4 <ReadBuffer_common+0x304>
    0.00 :	  6760ef:       90                      nop
         :	                }
         :
         :	                /*
         :	                 * Need to lock the buffer header too in order to change its tag.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  6760f0:       ba 0f 04 00 00          mov    $0x40f,%edx
    0.00 :	  6760f5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6760fa:       48 89 df                mov    %rbx,%rdi
    0.00 :	  6760fd:       e8 3e 9f 01 00          callq  690040 <s_lock>
    0.00 :	  676102:       e9 45 fe ff ff          jmpq   675f4c <ReadBuffer_common+0x2ac>
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
         :	                                        lsn = BufferGetLSN(buf);
         :	                                        UnlockBufHdr(buf);
         :
         :	                                        if (XLogNeedsFlush(lsn) &&
    0.00 :	  676107:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  67610a:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  67610d:       e8 0e 11 00 00          callq  677220 <StrategyRejectBuffer>
    0.00 :	  676112:       84 c0                   test   %al,%al
    0.00 :	  676114:       74 c1                   je     6760d7 <ReadBuffer_common+0x437>
         :	                                                StrategyRejectBuffer(strategy, buf))
         :	                                        {
         :	                                                /* Drop lock/pin and loop around for another buffer */
         :	                                                LWLockRelease(buf->content_lock);
    0.00 :	  676116:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  67611a:       e8 81 92 01 00          callq  68f3a0 <LWLockRelease>
         :	                                                UnpinBuffer(buf, true);
    0.00 :	  67611f:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676124:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676127:       e8 04 ec ff ff          callq  674d30 <UnpinBuffer>
    0.00 :	  67612c:       e9 50 fe ff ff          jmpq   675f81 <ReadBuffer_common+0x2e1>
         :	                                if (strategy != NULL)
         :	                                {
         :	                                        XLogRecPtr      lsn;
         :
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
    0.00 :	  676131:       ba a0 03 00 00          mov    $0x3a0,%edx
    0.00 :	  676136:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  67613b:       e8 00 9f 01 00          callq  690040 <s_lock>
    0.00 :	  676140:       e9 5a ff ff ff          jmpq   67609f <ReadBuffer_common+0x3ff>
         :
         :	        if (isLocalBuf)
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
         :	                if (found)
         :	                        pgBufferUsage.local_blks_hit++;
    0.00 :	  676145:       48 83 05 33 96 54 00    addq   $0x1,0x549633(%rip)        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  67614c:       01 
    0.00 :	  67614d:       e9 e0 fb ff ff          jmpq   675d32 <ReadBuffer_common+0x92>
         :	         * Clearing BM_VALID here is necessary, clearing the dirtybits is just
         :	         * paranoia.  We also reset the usage_count since any recency of use of
         :	         * the old content is no longer relevant.  (The usage_count starts out at
         :	         * 1 so that the buffer can survive one clock-sweep pass.)
         :	         */
         :	        buf->tag = newTag;
    0.00 :	  676152:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  676156:       49 89 06                mov    %rax,(%r14)
    0.00 :	  676159:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  67615d:       49 89 46 08             mov    %rax,0x8(%r14)
    0.00 :	  676161:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  676164:       41 89 46 10             mov    %eax,0x10(%r14)
         :	        buf->flags &= ~(BM_VALID | BM_DIRTY | BM_JUST_DIRTIED | BM_CHECKPOINT_NEEDED | BM_IO_ERROR | BM_PERMANENT);
    0.00 :	  676168:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  67616d:       66 25 4c fe             and    $0xfe4c,%ax
    0.00 :	  676171:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        if (relpersistence == RELPERSISTENCE_PERMANENT)
    0.00 :	  676176:       80 bd 7f ff ff ff 70    cmpb   $0x70,-0x81(%rbp)
    0.00 :	  67617d:       0f 84 73 02 00 00       je     6763f6 <ReadBuffer_common+0x756>
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
         :	        else
         :	                buf->flags |= BM_TAG_VALID;
    0.00 :	  676183:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  676188:       83 c8 04                or     $0x4,%eax
    0.00 :	  67618b:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        buf->usage_count = 1;
    0.00 :	  676190:       66 41 c7 46 16 01 00    movw   $0x1,0x16(%r14)
         :
         :	        UnlockBufHdr(buf);
         :
         :	        if (oldFlags & BM_TAG_VALID)
    0.00 :	  676197:       83 e2 04                and    $0x4,%edx
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
         :	        else
         :	                buf->flags |= BM_TAG_VALID;
         :	        buf->usage_count = 1;
         :
         :	        UnlockBufHdr(buf);
    0.00 :	  67619a:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :
         :	        if (oldFlags & BM_TAG_VALID)
    0.00 :	  67619f:       0f 85 64 02 00 00       jne    676409 <ReadBuffer_common+0x769>
         :	        /*
         :	         * Buffer contents are currently invalid.  Try to get the io_in_progress
         :	         * lock.  If StartBufferIO returns false, then someone else managed to
         :	         * read it before we did, so there's nothing left for BufferAlloc() to do.
         :	         */
         :	        if (StartBufferIO(buf, true))
    0.00 :	  6761a5:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  6761aa:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6761ad:       e8 8e e2 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  6761b2:       84 c0                   test   %al,%al
    0.00 :	  6761b4:       0f 84 d5 00 00 00       je     67628f <ReadBuffer_common+0x5ef>
         :	                *foundPtr = FALSE;
    0.00 :	  6761ba:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
         :	                        pgBufferUsage.shared_blks_hit++;
         :	                else
         :	                        pgBufferUsage.shared_blks_read++;
    0.00 :	  6761be:       48 83 05 a2 95 54 00    addq   $0x1,0x5495a2(%rip)        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  6761c5:       01 
    0.00 :	  6761c6:       e9 67 fb ff ff          jmpq   675d32 <ReadBuffer_common+0x92>
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  6761cb:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6761cf:       4c 63 e0                movslq %eax,%r12
    0.00 :	  6761d2:       49 c1 e4 0d             shl    $0xd,%r12
    0.00 :	  6761d6:       4c 03 25 1b 99 54 00    add    0x54991b(%rip),%r12        # bbfaf8 <BufferBlocks>
         :
         :	        if (isExtend)
    0.00 :	  6761dd:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
    0.00 :	  6761e1:       0f 84 7c fc ff ff       je     675e63 <ReadBuffer_common+0x1c3>
         :	        {
         :	                /* new buffers are zero-filled */
         :	                MemSet((char *) bufBlock, 0, BLCKSZ);
    0.00 :	  6761e7:       31 c0                   xor    %eax,%eax
    0.00 :	  6761e9:       b9 00 04 00 00          mov    $0x400,%ecx
    0.00 :	  6761ee:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6761f1:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                /* don't set checksum for all-zero page */
         :	                smgrextend(smgr, forkNum, blockNum, (char *) bufBlock, false);
    0.00 :	  6761f4:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6761f7:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  6761fa:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  676200:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  676206:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  67620a:       e8 c1 31 02 00          callq  6993d0 <smgrextend>
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                        }
         :	                }
         :	        }
         :
         :	        if (isLocalBuf)
    0.00 :	  67620f:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  676213:       0f 85 e8 fc ff ff       jne    675f01 <ReadBuffer_common+0x261>
         :	                bufHdr->flags |= BM_VALID;
         :	        }
         :	        else
         :	        {
         :	                /* Set BM_VALID, terminate IO, and wake up any waiters */
         :	                TerminateBufferIO(bufHdr, false, BM_VALID);
    0.00 :	  676219:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  67621e:       31 f6                   xor    %esi,%esi
    0.00 :	  676220:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676223:       e8 a8 df ff ff          callq  6741d0 <TerminateBufferIO>
    0.00 :	  676228:       e9 e1 fc ff ff          jmpq   675f0e <ReadBuffer_common+0x26e>
         :	                                                                           smgr->smgr_rnode.backend,
         :	                                                                           isExtend);
         :
         :	        /* Substitute proper block number if caller asked for P_NEW */
         :	        if (isExtend)
         :	                blockNum = smgrnblocks(smgr, forkNum);
    0.00 :	  67622d:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  676233:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  676237:       e8 14 32 02 00          callq  699450 <smgrnblocks>
    0.00 :	  67623c:       89 85 74 ff ff ff       mov    %eax,-0x8c(%rbp)
    0.00 :	  676242:       e9 b7 fa ff ff          jmpq   675cfe <ReadBuffer_common+0x5e>
         :	                 * lseek(SEEK_END) result that doesn't account for a recent write. In
         :	                 * that situation, the pre-existing buffer would contain valid data
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  676247:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  67624b:       0f 85 8c 00 00 00       jne    6762dd <ReadBuffer_common+0x63d>
    0.00 :	  676251:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  676255:       48 98                   cltq   
    0.00 :	  676257:       48 c1 e0 0d             shl    $0xd,%rax
    0.00 :	  67625b:       48 03 05 96 98 54 00    add    0x549896(%rip),%rax        # bbfaf8 <BufferBlocks>
         :	                if (!PageIsNew((Page) bufBlock))
    0.00 :	  676262:       66 83 78 0e 00          cmpw   $0x0,0xe(%rax)
    0.00 :	  676267:       0f 85 19 02 00 00       jne    676486 <ReadBuffer_common+0x7e6>
         :	                 * We *must* do smgrextend before succeeding, else the page will not
         :	                 * be reserved by the kernel, and the next P_NEW call will decide to
         :	                 * return the same page.  Clear the BM_VALID bit, do the StartBufferIO
         :	                 * call that BufferAlloc didn't, and proceed.
         :	                 */
         :	                if (isLocalBuf)
    0.00 :	  67626d:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  676271:       49 8d 5e 20             lea    0x20(%r14),%rbx
    0.00 :	  676275:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  67627b:       74 54                   je     6762d1 <ReadBuffer_common+0x631>
         :	                {
         :	                        /* Only need to adjust flags */
         :	                        Assert(bufHdr->flags & BM_VALID);
         :	                        bufHdr->flags &= ~BM_VALID;
    0.00 :	  67627d:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  676282:       83 e0 fd                and    $0xfffffffd,%eax
    0.00 :	  676285:       66 41 89 46 14          mov    %ax,0x14(%r14)
    0.00 :	  67628a:       e9 b1 fb ff ff          jmpq   675e40 <ReadBuffer_common+0x1a0>
         :	         * read it before we did, so there's nothing left for BufferAlloc() to do.
         :	         */
         :	        if (StartBufferIO(buf, true))
         :	                *foundPtr = FALSE;
         :	        else
         :	                *foundPtr = TRUE;
    0.00 :	  67628f:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
    0.00 :	  676293:       e9 8c fb ff ff          jmpq   675e24 <ReadBuffer_common+0x184>
         :	                         * BM_VALID between our clearing it and StartBufferIO inspecting
         :	                         * it.
         :	                         */
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
    0.00 :	  676298:       ba ae 02 00 00          mov    $0x2ae,%edx
    0.00 :	  67629d:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6762a2:       48 89 df                mov    %rbx,%rdi
    0.00 :	  6762a5:       e8 96 9d 01 00          callq  690040 <s_lock>
         :	                                Assert(bufHdr->flags & BM_VALID);
         :	                                bufHdr->flags &= ~BM_VALID;
    0.00 :	  6762aa:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  6762af:       83 e0 fd                and    $0xfffffffd,%eax
    0.00 :	  6762b2:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	                                UnlockBufHdr(bufHdr);
         :	                        } while (!StartBufferIO(bufHdr, true));
    0.00 :	  6762b7:       be 01 00 00 00          mov    $0x1,%esi
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
         :	                                Assert(bufHdr->flags & BM_VALID);
         :	                                bufHdr->flags &= ~BM_VALID;
         :	                                UnlockBufHdr(bufHdr);
    0.00 :	  6762bc:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :	                        } while (!StartBufferIO(bufHdr, true));
    0.00 :	  6762c1:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6762c4:       e8 77 e1 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  6762c9:       84 c0                   test   %al,%al
    0.00 :	  6762cb:       0f 85 fa fe ff ff       jne    6761cb <ReadBuffer_common+0x52b>
    0.00 :	  6762d1:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6762d4:       f0 86 03                lock xchg %al,(%rbx)
         :	                         * BM_VALID between our clearing it and StartBufferIO inspecting
         :	                         * it.
         :	                         */
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
    0.00 :	  6762d7:       84 c0                   test   %al,%al
    0.00 :	  6762d9:       74 cf                   je     6762aa <ReadBuffer_common+0x60a>
    0.00 :	  6762db:       eb bb                   jmp    676298 <ReadBuffer_common+0x5f8>
         :	                 * lseek(SEEK_END) result that doesn't account for a recent write. In
         :	                 * that situation, the pre-existing buffer would contain valid data
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  6762dd:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6762e1:       ba fe ff ff ff          mov    $0xfffffffe,%edx
    0.00 :	  6762e6:       29 c2                   sub    %eax,%edx
    0.00 :	  6762e8:       48 8b 05 29 6e 50 00    mov    0x506e29(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  6762ef:       48 63 d2                movslq %edx,%rdx
    0.00 :	  6762f2:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  6762f6:       e9 67 ff ff ff          jmpq   676262 <ReadBuffer_common+0x5c2>
         :	                        /* check for garbage data */
         :	                        if (!PageIsVerified((Page) bufBlock, blockNum))
         :	                        {
         :	                                if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
         :	                                {
         :	                                        ereport(WARNING,
    0.00 :	  6762fb:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  6762ff:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  676306:       48 89 d0                mov    %rdx,%rax
    0.00 :	  676309:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  67630c:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  67630f:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  676312:       8b 30                   mov    (%rax),%esi
    0.00 :	  676314:       e8 b7 82 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  676319:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  67631f:       48 89 c2                mov    %rax,%rdx
    0.00 :	  676322:       bf c8 9e 8a 00          mov    $0x8a9ec8,%edi
    0.00 :	  676327:       31 c0                   xor    %eax,%eax
    0.00 :	  676329:       e8 72 65 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67632e:       bf 28 0a 00 01          mov    $0x1000a28,%edi
    0.00 :	  676333:       89 c3                   mov    %eax,%ebx
    0.00 :	  676335:       e8 16 6a 10 00          callq  77cd50 <errcode>
    0.00 :	  67633a:       89 de                   mov    %ebx,%esi
    0.00 :	  67633c:       89 c7                   mov    %eax,%edi
    0.00 :	  67633e:       31 c0                   xor    %eax,%eax
    0.00 :	  676340:       e8 9b 42 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676345:       e9 a0 fb ff ff          jmpq   675eea <ReadBuffer_common+0x24a>
         :	                {
         :	                        instr_time      io_start,
         :	                                                io_time;
         :
         :	                        if (track_io_timing)
         :	                                INSTR_TIME_SET_CURRENT(io_start);
    0.00 :	  67634a:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  67634e:       31 f6                   xor    %esi,%esi
    0.00 :	  676350:       e8 6b 32 df ff          callq  4695c0 <gettimeofday@plt>
    0.00 :	  676355:       e9 1f fb ff ff          jmpq   675e79 <ReadBuffer_common+0x1d9>
         :
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
    0.00 :	  67635a:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  67635e:       31 f6                   xor    %esi,%esi
    0.00 :	  676360:       e8 5b 32 df ff          callq  4695c0 <gettimeofday@plt>
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
    0.00 :	  676365:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  676369:       48 2b 55 98             sub    -0x68(%rbp),%rdx
    0.00 :	  67636d:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  676371:       48 2b 45 90             sub    -0x70(%rbp),%rax
    0.00 :	  676375:       48 85 d2                test   %rdx,%rdx
    0.00 :	  676378:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
    0.00 :	  67637c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  67637f:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  676383:       79 18                   jns    67639d <ReadBuffer_common+0x6fd>
         :	 */
         :	static Buffer
         :	ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
         :	                                  BlockNumber blockNum, ReadBufferMode mode,
         :	                                  BufferAccessStrategy strategy, bool *hit)
         :	{
    0.00 :	  676385:       48 83 e8 01             sub    $0x1,%rax
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
    0.00 :	  676389:       48 81 c2 40 42 0f 00    add    $0xf4240,%rdx
    0.00 :	  676390:       78 f3                   js     676385 <ReadBuffer_common+0x6e5>
    0.00 :	  676392:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  676396:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
    0.00 :	  67639a:       48 89 c1                mov    %rax,%rcx
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
    0.00 :	  67639d:       48 69 c1 40 42 0f 00    imul   $0xf4240,%rcx,%rax
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
    0.00 :	  6763a4:       48 01 0d 05 94 54 00    add    %rcx,0x549405(%rip)        # bbf7b0 <pgBufferUsage+0x50>
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
    0.00 :	  6763ab:       48 8d 04 02             lea    (%rdx,%rax,1),%rax
    0.00 :	  6763af:       48 01 05 0a 58 50 00    add    %rax,0x50580a(%rip)        # b7bbc0 <pgStatBlockReadTime>
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
    0.00 :	  6763b6:       48 8b 05 fb 93 54 00    mov    0x5493fb(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763bd:       48 03 45 b8             add    -0x48(%rbp),%rax
    0.00 :	  6763c1:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6763c7:       48 89 05 ea 93 54 00    mov    %rax,0x5493ea(%rip)        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763ce:       0f 8e ca fa ff ff       jle    675e9e <ReadBuffer_common+0x1fe>
    0.00 :	  6763d4:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  6763da:       48 83 05 ce 93 54 00    addq   $0x1,0x5493ce(%rip)        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  6763e1:       01 
    0.00 :	  6763e2:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6763e8:       48 89 05 c9 93 54 00    mov    %rax,0x5493c9(%rip)        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763ef:       7f e3                   jg     6763d4 <ReadBuffer_common+0x734>
    0.00 :	  6763f1:       e9 a8 fa ff ff          jmpq   675e9e <ReadBuffer_common+0x1fe>
         :	         * 1 so that the buffer can survive one clock-sweep pass.)
         :	         */
         :	        buf->tag = newTag;
         :	        buf->flags &= ~(BM_VALID | BM_DIRTY | BM_JUST_DIRTIED | BM_CHECKPOINT_NEEDED | BM_IO_ERROR | BM_PERMANENT);
         :	        if (relpersistence == RELPERSISTENCE_PERMANENT)
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
    0.00 :	  6763f6:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  6763fb:       66 0d 04 01             or     $0x104,%ax
    0.00 :	  6763ff:       66 41 89 46 14          mov    %ax,0x14(%r14)
    0.00 :	  676404:       e9 87 fd ff ff          jmpq   676190 <ReadBuffer_common+0x4f0>
         :	        buf->usage_count = 1;
         :
         :	        UnlockBufHdr(buf);
         :
         :	        if (oldFlags & BM_TAG_VALID)
         :	                BufTableDelete(&oldTag);
    0.00 :	  676409:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  67640d:       e8 3e d9 ff ff          callq  673d50 <BufTableDelete>
    0.00 :	  676412:       e9 8e fd ff ff          jmpq   6761a5 <ReadBuffer_common+0x505>
         :	                                                                        blockNum,
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                                        MemSet((char *) bufBlock, 0, BLCKSZ);
         :	                                }
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  676417:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  67641a:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  67641f:       ba f8 02 00 00          mov    $0x2f8,%edx
    0.00 :	  676424:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676429:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67642e:       e8 8d 46 10 00          callq  77aac0 <errstart>
    0.00 :	  676433:       84 c0                   test   %al,%al
    0.00 :	  676435:       74 4a                   je     676481 <ReadBuffer_common+0x7e1>
    0.00 :	  676437:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  67643b:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  676442:       48 89 d0                mov    %rdx,%rax
    0.00 :	  676445:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  676448:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  67644b:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  67644e:       8b 30                   mov    (%rax),%esi
    0.00 :	  676450:       e8 7b 81 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  676455:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  67645b:       48 89 c2                mov    %rax,%rdx
    0.00 :	  67645e:       bf 48 28 88 00          mov    $0x882848,%edi
    0.00 :	  676463:       31 c0                   xor    %eax,%eax
    0.00 :	  676465:       e8 36 64 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67646a:       bf 28 0a 00 01          mov    $0x1000a28,%edi
    0.00 :	  67646f:       89 c3                   mov    %eax,%ebx
    0.00 :	  676471:       e8 da 68 10 00          callq  77cd50 <errcode>
    0.00 :	  676476:       89 de                   mov    %ebx,%esi
    0.00 :	  676478:       89 c7                   mov    %eax,%edi
    0.00 :	  67647a:       31 c0                   xor    %eax,%eax
    0.00 :	  67647c:       e8 5f 41 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676481:       e8 4a 30 df ff          callq  4694d0 <abort@plt>
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
         :	                if (!PageIsNew((Page) bufBlock))
         :	                        ereport(ERROR,
    0.00 :	  676486:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  676489:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  67648e:       ba 97 02 00 00          mov    $0x297,%edx
    0.00 :	  676493:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676498:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67649d:       e8 1e 46 10 00          callq  77aac0 <errstart>
    0.00 :	  6764a2:       84 c0                   test   %al,%al
    0.00 :	  6764a4:       74 db                   je     676481 <ReadBuffer_common+0x7e1>
    0.00 :	  6764a6:       bf 40 9e 8a 00          mov    $0x8a9e40,%edi
    0.00 :	  6764ab:       31 c0                   xor    %eax,%eax
    0.00 :	  6764ad:       e8 ee 57 10 00          callq  77bca0 <errhint>
    0.00 :	  6764b2:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  6764b6:       89 c3                   mov    %eax,%ebx
    0.00 :	  6764b8:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  6764bf:       48 89 d0                mov    %rdx,%rax
    0.00 :	  6764c2:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  6764c5:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  6764c8:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  6764cb:       8b 30                   mov    (%rax),%esi
    0.00 :	  6764cd:       e8 fe 80 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  6764d2:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  6764d8:       48 89 c2                mov    %rax,%rdx
    0.00 :	  6764db:       bf 90 9e 8a 00          mov    $0x8a9e90,%edi
    0.00 :	  6764e0:       31 c0                   xor    %eax,%eax
    0.00 :	  6764e2:       e8 b9 63 10 00          callq  77c8a0 <errmsg>
    0.00 :	  6764e7:       89 de                   mov    %ebx,%esi
    0.00 :	  6764e9:       89 c7                   mov    %eax,%edi
    0.00 :	  6764eb:       31 c0                   xor    %eax,%eax
    0.00 :	  6764ed:       e8 ee 40 10 00          callq  77a5e0 <errfinish>
    0.00 :	  6764f2:       eb 8d                   jmp    676481 <ReadBuffer_common+0x7e1>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1565
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068f3a0 <LWLockRelease>:
         :	/*
         :	 * LWLockRelease - release a previously acquired lock
         :	 */
         :	void
         :	LWLockRelease(LWLock *lock)
         :	{
    0.00 :	  68f3a0:       55                      push   %rbp
    0.00 :	  68f3a1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  68f3a4:       41 55                   push   %r13
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1565
   50.00 :	  68f3a6:       41 54                   push   %r12
    0.00 :	  68f3a8:       49 89 fc                mov    %rdi,%r12
    0.00 :	  68f3ab:       53                      push   %rbx
    0.00 :	  68f3ac:       48 83 ec 18             sub    $0x18,%rsp
         :
         :	        /*
         :	         * Remove lock from list of locks held.  Usually, but not always, it will
         :	         * be the latest-acquired lock; so search array backwards.
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
    0.00 :	  68f3b0:       8b 35 52 e6 4e 00       mov    0x4ee652(%rip),%esi        # b7da08 <num_held_lwlocks>
    0.00 :	  68f3b6:       89 f0                   mov    %esi,%eax
    0.00 :	  68f3b8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  68f3bf:       00 
    0.00 :	  68f3c0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  68f3c3:       0f 88 1f 02 00 00       js     68f5e8 <LWLockRelease+0x248>
         :	        {
         :	                if (lock == held_lwlocks[i].lock)
    0.00 :	  68f3c9:       48 63 d0                movslq %eax,%rdx
    0.00 :	  68f3cc:       41 b9 40 da b7 00       mov    $0xb7da40,%r9d
    0.00 :	  68f3d2:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  68f3d5:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	  68f3d9:       48 8b 99 40 da b7 00    mov    0xb7da40(%rcx),%rbx
    0.00 :	  68f3e0:       4c 39 e3                cmp    %r12,%rbx
    0.00 :	  68f3e3:       75 db                   jne    68f3c0 <LWLockRelease+0x20>
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
    0.00 :	  68f3e5:       44 8d 46 ff             lea    -0x1(%rsi),%r8d
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
         :	        {
         :	                if (lock == held_lwlocks[i].lock)
         :	                {
         :	                        mode = held_lwlocks[i].mode;
    0.00 :	  68f3e9:       44 8b 91 48 da b7 00    mov    0xb7da48(%rcx),%r10d
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f3f0:       41 39 c0                cmp    %eax,%r8d
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
    0.00 :	  68f3f3:       44 89 05 0e e6 4e 00    mov    %r8d,0x4ee60e(%rip)        # b7da08 <num_held_lwlocks>
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f3fa:       7f 09                   jg     68f405 <LWLockRelease+0x65>
    0.00 :	  68f3fc:       eb 3a                   jmp    68f438 <LWLockRelease+0x98>
    0.00 :	  68f3fe:       66 90                   xchg   %ax,%ax
         :
         :	        /*
         :	         * Remove lock from list of locks held.  Usually, but not always, it will
         :	         * be the latest-acquired lock; so search array backwards.
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
    0.00 :	  68f400:       89 f0                   mov    %esi,%eax
    0.00 :	  68f402:       48 89 fa                mov    %rdi,%rdx
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
         :	                held_lwlocks[i] = held_lwlocks[i + 1];
    0.00 :	  68f405:       8d 70 01                lea    0x1(%rax),%esi
    0.00 :	  68f408:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  68f40b:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	  68f40f:       48 63 fe                movslq %esi,%rdi
    0.00 :	  68f412:       48 89 fa                mov    %rdi,%rdx
    0.00 :	  68f415:       48 c1 e2 04             shl    $0x4,%rdx
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f419:       41 39 f0                cmp    %esi,%r8d
         :	                held_lwlocks[i] = held_lwlocks[i + 1];
    0.00 :	  68f41c:       48 8b 82 40 da b7 00    mov    0xb7da40(%rdx),%rax
    0.00 :	  68f423:       48 89 81 40 da b7 00    mov    %rax,0xb7da40(%rcx)
    0.00 :	  68f42a:       48 8b 82 48 da b7 00    mov    0xb7da48(%rdx),%rax
    0.00 :	  68f431:       49 89 44 09 08          mov    %rax,0x8(%r9,%rcx,1)
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f436:       7f c8                   jg     68f400 <LWLockRelease+0x60>
         :
         :	        /*
         :	         * Release my hold on lock, after that it can immediately be acquired by
         :	         * others, even if we still have to wakeup other waiters.
         :	         */
         :	        if (mode == LW_EXCLUSIVE)
    0.00 :	  68f438:       45 85 d2                test   %r10d,%r10d
    0.00 :	  68f43b:       0f 84 77 01 00 00       je     68f5b8 <LWLockRelease+0x218>
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, EXCLUSIVE_LOCK);
         :	        else
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, 1);
    0.00 :	  68f441:       49 8d 54 24 04          lea    0x4(%r12),%rdx
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68f446:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68f44b:       f0 0f c1 02             lock xadd %eax,(%rdx)
         :	#if !defined(PG_HAVE_ATOMIC_SUB_FETCH_U32) && defined(PG_HAVE_ATOMIC_FETCH_SUB_U32)
         :	#define PG_HAVE_ATOMIC_SUB_FETCH_U32
         :	static inline uint32
         :	pg_atomic_sub_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
         :	{
         :	        return pg_atomic_fetch_sub_u32_impl(ptr, sub_) - sub_;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
   50.00 :	  68f44f:       8d 50 ff                lea    -0x1(%rax),%edx
         :	#ifndef PG_HAVE_ATOMIC_READ_U32
         :	#define PG_HAVE_ATOMIC_READ_U32
         :	static inline uint32
         :	pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
         :	{
         :	        return *(&ptr->value);
    0.00 :	  68f452:       8b 43 08                mov    0x8(%rbx),%eax
         :	        /*
         :	         * Anybody we need to wakeup needs to have started queueing before we
         :	         * removed ourselves from the queue and the atomic operations above are
         :	         * full barriers. So we can just do plain read.
         :	         */
         :	        if (pg_atomic_read_u32(&lock->nwaiters) > 0)
    0.00 :	  68f455:       85 c0                   test   %eax,%eax
    0.00 :	  68f457:       0f 84 3a 01 00 00       je     68f597 <LWLockRelease+0x1f7>
         :	        /*
         :	         * If we just released an exclusive lock always wakeup waiters, even if
         :	         * lockcount is still > 0. A shared acquisition temporarily (and
         :	         * spuriously) might have increased the value.
         :	         */
         :	        if (mode == LW_EXCLUSIVE && have_waiters)
    0.00 :	  68f45d:       45 85 d2                test   %r10d,%r10d
    0.00 :	  68f460:       0f 85 fc 01 00 00       jne    68f662 <LWLockRelease+0x2c2>
         :	 * Previous state will be thrown away without any cleanup.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_init(dlist_head *head)
         :	{
         :	        head->head.next = head->head.prev = &head->head;
    0.00 :	  68f466:       4c 8d 6d d0             lea    -0x30(%rbp),%r13
    0.00 :	  68f46a:       4c 89 6d d0             mov    %r13,-0x30(%rbp)
    0.00 :	  68f46e:       4c 89 6d d8             mov    %r13,-0x28(%rbp)
         :	        /*
         :	         * We're still waiting for backends to get scheduled, don't wake them up
         :	         * again.
         :	         */
         :	        pg_read_barrier(); /* pairs with nwaiters-- */
         :	        if (!BOOL_ACCESS_ONCE(lock->releaseOK))
    0.00 :	  68f472:       0f b6 43 01             movzbl 0x1(%rbx),%eax
    0.00 :	  68f476:       84 c0                   test   %al,%al
    0.00 :	  68f478:       0f 84 19 01 00 00       je     68f597 <LWLockRelease+0x1f7>
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  68f47e:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  68f483:       f0 86 03                lock xchg %al,(%rbx)
         :
         :	        /* Acquire mutex.  Time spent holding mutex should be short! */
         :	#ifdef LWLOCK_STATS
         :	        lwstats->spin_delay_count += SpinLockAcquire(&lock->mutex);
         :	#else
         :	        SpinLockAcquire(&lock->mutex);
    0.00 :	  68f486:       84 c0                   test   %al,%al
    0.00 :	  68f488:       0f 85 b2 01 00 00       jne    68f640 <LWLockRelease+0x2a0>
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f48e:       48 8b 53 18             mov    0x18(%rbx),%rdx
    0.00 :	  68f492:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68f495:       0f 84 bc 01 00 00       je     68f657 <LWLockRelease+0x2b7>
    0.00 :	  68f49b:       4d 8d 4c 24 10          lea    0x10(%r12),%r9
    0.00 :	  68f4a0:       48 8b 72 08             mov    0x8(%rdx),%rsi
    0.00 :	  68f4a4:       49 39 d1                cmp    %rdx,%r9
    0.00 :	  68f4a7:       0f 84 aa 01 00 00       je     68f657 <LWLockRelease+0x2b7>
    0.00 :	  68f4ad:       31 ff                   xor    %edi,%edi
    0.00 :	  68f4af:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  68f4b5:       eb 23                   jmp    68f4da <LWLockRelease+0x13a>
    0.00 :	  68f4b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  68f4be:       00 00 
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4c0:       80 7a fa 00             cmpb   $0x0,-0x6(%rdx)
    0.00 :	  68f4c4:       75 1d                   jne    68f4e3 <LWLockRelease+0x143>
    0.00 :	  68f4c6:       bf 01 00 00 00          mov    $0x1,%edi
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f4cb:       49 39 f1                cmp    %rsi,%r9
    0.00 :	  68f4ce:       48 8b 46 08             mov    0x8(%rsi),%rax
    0.00 :	  68f4d2:       74 6a                   je     68f53e <LWLockRelease+0x19e>
    0.00 :	  68f4d4:       48 89 f2                mov    %rsi,%rdx
    0.00 :	  68f4d7:       48 89 c6                mov    %rax,%rsi
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4da:       40 84 ff                test   %dil,%dil
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
    0.00 :	  68f4dd:       48 8d 4a b8             lea    -0x48(%rdx),%rcx
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4e1:       75 dd                   jne    68f4c0 <LWLockRelease+0x120>
         :	 * Delete 'node' from its list (it must be in one).
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_delete(dlist_node *node)
         :	{
         :	        node->prev->next = node->next;
    0.00 :	  68f4e3:       48 8b 51 48             mov    0x48(%rcx),%rdx
    0.00 :	  68f4e7:       48 8b 41 50             mov    0x50(%rcx),%rax
    0.00 :	  68f4eb:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	        node->next->prev = node->prev;
    0.00 :	  68f4ef:       48 8b 51 50             mov    0x50(%rcx),%rdx
    0.00 :	  68f4f3:       48 8b 41 48             mov    0x48(%rcx),%rax
    0.00 :	  68f4f7:       48 89 02                mov    %rax,(%rdx)
         :	 * Insert a node at the end of the list.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_push_tail(dlist_head *head, dlist_node *node)
         :	{
         :	        if (head->head.next == NULL)    /* convert NULL header to circular */
    0.00 :	  68f4fa:       48 83 7d d8 00          cmpq   $0x0,-0x28(%rbp)
         :	                        continue;
         :
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                dlist_push_tail(&wakeup, &waiter->lwWaitLink);
    0.00 :	  68f4ff:       48 8d 51 48             lea    0x48(%rcx),%rdx
    0.00 :	  68f503:       0f 84 cf 00 00 00       je     68f5d8 <LWLockRelease+0x238>
         :	                dlist_init(head);
         :
         :	        node->next = &head->head;
    0.00 :	  68f509:       4c 89 69 50             mov    %r13,0x50(%rcx)
         :	        node->prev = head->head.prev;
    0.00 :	  68f50d:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  68f511:       48 89 41 48             mov    %rax,0x48(%rcx)
         :	        node->prev->next = node;
    0.00 :	  68f515:       48 89 50 08             mov    %rdx,0x8(%rax)
         :	        head->head.prev = node;
    0.00 :	  68f519:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
         :
         :	                if (waiter->lwWaitMode != LW_WAIT_UNTIL_FREE)
    0.00 :	  68f51d:       0f b6 41 42             movzbl 0x42(%rcx),%eax
    0.00 :	  68f521:       3c 02                   cmp    $0x2,%al
    0.00 :	  68f523:       74 a6                   je     68f4cb <LWLockRelease+0x12b>
         :
         :	                /*
         :	                 * Once we've woken up an exclusive lock, there's no point in waking
         :	                 * up anybody else.
         :	                 */
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f525:       84 c0                   test   %al,%al
    0.00 :	  68f527:       0f 84 0b 01 00 00       je     68f638 <LWLockRelease+0x298>
    0.00 :	  68f52d:       45 31 c0                xor    %r8d,%r8d
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f530:       49 39 f1                cmp    %rsi,%r9
         :
         :	                /*
         :	                 * Once we've woken up an exclusive lock, there's no point in waking
         :	                 * up anybody else.
         :	                 */
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f533:       bf 01 00 00 00          mov    $0x1,%edi
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f538:       48 8b 46 08             mov    0x8(%rsi),%rax
    0.00 :	  68f53c:       75 96                   jne    68f4d4 <LWLockRelease+0x134>
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
         :	                        break;
         :	        }
         :
         :	        /* The SpinLockRelease() below provides barrier semantics */
         :	        BOOL_ACCESS_ONCE(lock->releaseOK) = releaseOK;
    0.00 :	  68f53e:       44 88 43 01             mov    %r8b,0x1(%rbx)
         :	        SpinLockRelease(&lock->mutex);
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f542:       48 8b 4d d8             mov    -0x28(%rbp),%rcx
         :
         :	        /* The SpinLockRelease() below provides barrier semantics */
         :	        BOOL_ACCESS_ONCE(lock->releaseOK) = releaseOK;
         :
         :	        /* We are done updating shared state of the lock queue. */
         :	        SpinLockRelease(&lock->mutex);
    0.00 :	  68f546:       41 c6 04 24 00          movb   $0x0,(%r12)
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f54b:       48 85 c9                test   %rcx,%rcx
    0.00 :	  68f54e:       74 47                   je     68f597 <LWLockRelease+0x1f7>
    0.00 :	  68f550:       4c 39 e9                cmp    %r13,%rcx
    0.00 :	  68f553:       48 8b 59 08             mov    0x8(%rcx),%rbx
    0.00 :	  68f557:       75 0d                   jne    68f566 <LWLockRelease+0x1c6>
    0.00 :	  68f559:       eb 3c                   jmp    68f597 <LWLockRelease+0x1f7>
    0.00 :	  68f55b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  68f560:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  68f563:       48 89 c3                mov    %rax,%rbx
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
    0.00 :	  68f566:       48 8d 79 b8             lea    -0x48(%rcx),%rdi
         :	 * Delete 'node' from its list (it must be in one).
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_delete(dlist_node *node)
         :	{
         :	        node->prev->next = node->next;
    0.00 :	  68f56a:       48 8b 57 48             mov    0x48(%rdi),%rdx
    0.00 :	  68f56e:       48 8b 47 50             mov    0x50(%rdi),%rax
    0.00 :	  68f572:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	        node->next->prev = node->prev;
    0.00 :	  68f576:       48 8b 57 50             mov    0x50(%rdi),%rdx
    0.00 :	  68f57a:       48 8b 47 48             mov    0x48(%rdi),%rax
    0.00 :	  68f57e:       48 89 02                mov    %rax,(%rdx)
         :
         :	                LOG_LWDEBUG("LWLockRelease", lock, "release waiter");
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                pg_write_barrier();
         :	                waiter->lwWaiting = false;
         :	                PGSemaphoreUnlock(&waiter->sem);
    0.00 :	  68f581:       48 83 c7 10             add    $0x10,%rdi
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                LOG_LWDEBUG("LWLockRelease", lock, "release waiter");
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                pg_write_barrier();
         :	                waiter->lwWaiting = false;
    0.00 :	  68f585:       c6 41 f9 00             movb   $0x0,-0x7(%rcx)
         :	                PGSemaphoreUnlock(&waiter->sem);
    0.00 :	  68f589:       e8 02 8b fa ff          callq  638090 <PGSemaphoreUnlock>
         :	        SpinLockRelease(&lock->mutex);
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f58e:       4c 39 eb                cmp    %r13,%rbx
    0.00 :	  68f591:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  68f595:       75 c9                   jne    68f560 <LWLockRelease+0x1c0>
         :	        TRACE_POSTGRESQL_LWLOCK_RELEASE(T_NAME(lock), T_ID(lock));
         :
         :	        /*
         :	         * Now okay to allow cancel/die interrupts.
         :	         */
         :	        RESUME_INTERRUPTS();
    0.00 :	  68f597:       8b 05 fb aa 52 00       mov    0x52aafb(%rip),%eax        # bba098 <InterruptHoldoffCount>
    0.00 :	  68f59d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  68f5a0:       89 05 f2 aa 52 00       mov    %eax,0x52aaf2(%rip)        # bba098 <InterruptHoldoffCount>
         :	}
    0.00 :	  68f5a6:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  68f5aa:       5b                      pop    %rbx
    0.00 :	  68f5ab:       41 5c                   pop    %r12
    0.00 :	  68f5ad:       41 5d                   pop    %r13
    0.00 :	  68f5af:       c9                      leaveq 
    0.00 :	  68f5b0:       c3                      retq   
    0.00 :	  68f5b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * Release my hold on lock, after that it can immediately be acquired by
         :	         * others, even if we still have to wakeup other waiters.
         :	         */
         :	        if (mode == LW_EXCLUSIVE)
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, EXCLUSIVE_LOCK);
    0.00 :	  68f5b8:       49 8d 54 24 04          lea    0x4(%r12),%rdx
    0.00 :	  68f5bd:       b8 00 00 00 c0          mov    $0xc0000000,%eax
    0.00 :	  68f5c2:       f0 0f c1 02             lock xadd %eax,(%rdx)
         :	#if !defined(PG_HAVE_ATOMIC_SUB_FETCH_U32) && defined(PG_HAVE_ATOMIC_FETCH_SUB_U32)
         :	#define PG_HAVE_ATOMIC_SUB_FETCH_U32
         :	static inline uint32
         :	pg_atomic_sub_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
         :	{
         :	        return pg_atomic_fetch_sub_u32_impl(ptr, sub_) - sub_;
    0.00 :	  68f5c6:       8d 90 00 00 00 c0       lea    -0x40000000(%rax),%edx
    0.00 :	  68f5cc:       e9 81 fe ff ff          jmpq   68f452 <LWLockRelease+0xb2>
    0.00 :	  68f5d1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	 * Previous state will be thrown away without any cleanup.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_init(dlist_head *head)
         :	{
         :	        head->head.next = head->head.prev = &head->head;
    0.00 :	  68f5d8:       4c 89 6d d0             mov    %r13,-0x30(%rbp)
    0.00 :	  68f5dc:       4c 89 6d d8             mov    %r13,-0x28(%rbp)
    0.00 :	  68f5e0:       e9 24 ff ff ff          jmpq   68f509 <LWLockRelease+0x169>
    0.00 :	  68f5e5:       0f 1f 00                nopl   (%rax)
         :	                        mode = held_lwlocks[i].mode;
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
    0.00 :	  68f5e8:       ba 10 d1 8a 00          mov    $0x8ad110,%edx
    0.00 :	  68f5ed:       be 31 06 00 00          mov    $0x631,%esi
    0.00 :	  68f5f2:       bf 85 d0 8a 00          mov    $0x8ad085,%edi
    0.00 :	  68f5f7:       e8 24 be 0e 00          callq  77b420 <elog_start>
    0.00 :	  68f5fc:       49 63 54 24 0c          movslq 0xc(%r12),%rdx
    0.00 :	  68f601:       48 8b 05 08 e4 4e 00    mov    0x4ee408(%rip),%rax        # b7da10 <LWLockTrancheArray>
    0.00 :	  68f608:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  68f60d:       48 8b 34 d0             mov    (%rax,%rdx,8),%rsi
    0.00 :	  68f611:       31 d2                   xor    %edx,%edx
    0.00 :	  68f613:       4c 2b 66 08             sub    0x8(%rsi),%r12
    0.00 :	  68f617:       4c 89 e0                mov    %r12,%rax
    0.00 :	  68f61a:       48 f7 76 10             divq   0x10(%rsi)
    0.00 :	  68f61e:       48 8b 16                mov    (%rsi),%rdx
    0.00 :	  68f621:       be bf d0 8a 00          mov    $0x8ad0bf,%esi
    0.00 :	  68f626:       89 c1                   mov    %eax,%ecx
    0.00 :	  68f628:       31 c0                   xor    %eax,%eax
    0.00 :	  68f62a:       e8 01 bc 0e 00          callq  77b230 <elog_finish>
    0.00 :	  68f62f:       e8 9c 9e dd ff          callq  4694d0 <abort@plt>
    0.00 :	  68f634:       0f 1f 40 00             nopl   0x0(%rax)
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f638:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  68f63b:       e9 fe fe ff ff          jmpq   68f53e <LWLockRelease+0x19e>
         :
         :	        /* Acquire mutex.  Time spent holding mutex should be short! */
         :	#ifdef LWLOCK_STATS
         :	        lwstats->spin_delay_count += SpinLockAcquire(&lock->mutex);
         :	#else
         :	        SpinLockAcquire(&lock->mutex);
    0.00 :	  68f640:       ba e1 02 00 00          mov    $0x2e1,%edx
    0.00 :	  68f645:       be 85 d0 8a 00          mov    $0x8ad085,%esi
    0.00 :	  68f64a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  68f64d:       e8 ee 09 00 00          callq  690040 <s_lock>
    0.00 :	  68f652:       e9 37 fe ff ff          jmpq   68f48e <LWLockRelease+0xee>
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f657:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  68f65d:       e9 dc fe ff ff          jmpq   68f53e <LWLockRelease+0x19e>
         :	        if (mode == LW_EXCLUSIVE && have_waiters)
         :	                check_waiters = true;
         :	        /*
         :	         * nobody has this locked anymore, potential exclusive lockers get a chance
         :	         */
         :	        else if (lockcount == 0 && have_waiters)
    0.00 :	  68f662:       85 d2                   test   %edx,%edx
    0.00 :	  68f664:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  68f668:       0f 84 f8 fd ff ff       je     68f466 <LWLockRelease+0xc6>
    0.00 :	  68f66e:       66 90                   xchg   %ax,%ax
    0.00 :	  68f670:       e9 22 ff ff ff          jmpq   68f597 <LWLockRelease+0x1f7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3066
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3089
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000069b9e0 <check_stack_depth>:
         :	 * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves
         :	 * before hitting the hardware limit.
         :	 */
         :	void
         :	check_stack_depth(void)
         :	{
    0.00 :	  69b9e0:       55                      push   %rbp
    0.00 :	  69b9e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  69b9e4:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3066
   50.00 :	  69b9e8:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  69b9ec:       48 83 ec 20             sub    $0x20,%rsp
         :	        long            stack_depth;
         :
         :	        /*
         :	         * Compute distance from reference point to my local variables
         :	         */
         :	        stack_depth = (long) (stack_base_ptr - &stack_top_loc);
    0.00 :	  69b9f0:       48 8b 0d f9 2d 4e 00    mov    0x4e2df9(%rip),%rcx        # b7e7f0 <stack_base_ptr>
    0.00 :	  69b9f7:       48 8d 45 ef             lea    -0x11(%rbp),%rax
    0.00 :	  69b9fb:       48 89 ca                mov    %rcx,%rdx
    0.00 :	  69b9fe:       48 29 c2                sub    %rax,%rdx
    0.00 :	  69ba01:       48 89 d0                mov    %rdx,%rax
         :	         * The test on stack_base_ptr prevents us from erroring out if called
         :	         * during process setup or in a non-backend process.  Logically it should
         :	         * be done first, but putting it here avoids wasting cycles during normal
         :	         * cases.
         :	         */
         :	        if (stack_depth > max_stack_depth_bytes &&
    0.00 :	  69ba04:       48 c1 fa 3f             sar    $0x3f,%rdx
    0.00 :	  69ba08:       48 31 d0                xor    %rdx,%rax
    0.00 :	  69ba0b:       48 29 d0                sub    %rdx,%rax
    0.00 :	  69ba0e:       48 39 05 a3 cd 4c 00    cmp    %rax,0x4ccda3(%rip)        # b687b8 <max_stack_depth_bytes>
 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3089
   50.00 :	  69ba15:       7d 05                   jge    69ba1c <check_stack_depth+0x3c>
    0.00 :	  69ba17:       48 85 c9                test   %rcx,%rcx
    0.00 :	  69ba1a:       75 0a                   jne    69ba26 <check_stack_depth+0x46>
         :	                                 errhint("Increase the configuration parameter \"max_stack_depth\" (currently %dkB), "
         :	                          "after ensuring the platform's stack depth limit is adequate.",
         :	                                                 max_stack_depth)));
         :	        }
         :	#endif   /* IA64 */
         :	}
    0.00 :	  69ba1c:       48 8b 5d f0             mov    -0x10(%rbp),%rbx
    0.00 :	  69ba20:       4c 8b 65 f8             mov    -0x8(%rbp),%r12
    0.00 :	  69ba24:       c9                      leaveq 
    0.00 :	  69ba25:       c3                      retq   
         :	         * cases.
         :	         */
         :	        if (stack_depth > max_stack_depth_bytes &&
         :	                stack_base_ptr != NULL)
         :	        {
         :	                ereport(ERROR,
    0.00 :	  69ba26:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  69ba29:       b9 e0 00 8b 00          mov    $0x8b00e0,%ecx
    0.00 :	  69ba2e:       ba 19 0c 00 00          mov    $0xc19,%edx
    0.00 :	  69ba33:       be d0 e8 8a 00          mov    $0x8ae8d0,%esi
    0.00 :	  69ba38:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  69ba3d:       e8 7e f0 0d 00          callq  77aac0 <errstart>
    0.00 :	  69ba42:       84 c0                   test   %al,%al
    0.00 :	  69ba44:       75 05                   jne    69ba4b <check_stack_depth+0x6b>
    0.00 :	  69ba46:       e8 85 da dc ff          callq  4694d0 <abort@plt>
    0.00 :	  69ba4b:       8b 35 5b cd 4c 00       mov    0x4ccd5b(%rip),%esi        # b687ac <max_stack_depth>
    0.00 :	  69ba51:       bf 60 f0 8a 00          mov    $0x8af060,%edi
    0.00 :	  69ba56:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba58:       e8 43 02 0e 00          callq  77bca0 <errhint>
    0.00 :	  69ba5d:       bf 00 ea 8a 00          mov    $0x8aea00,%edi
    0.00 :	  69ba62:       41 89 c4                mov    %eax,%r12d
    0.00 :	  69ba65:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba67:       e8 34 0e 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  69ba6c:       bf 05 01 00 01          mov    $0x1000105,%edi
    0.00 :	  69ba71:       89 c3                   mov    %eax,%ebx
    0.00 :	  69ba73:       e8 d8 12 0e 00          callq  77cd50 <errcode>
    0.00 :	  69ba78:       44 89 e2                mov    %r12d,%edx
    0.00 :	  69ba7b:       89 c7                   mov    %eax,%edi
    0.00 :	  69ba7d:       89 de                   mov    %ebx,%esi
    0.00 :	  69ba7f:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba81:       e8 5a eb 0d 00          callq  77a5e0 <errfinish>
    0.00 :	  69ba86:       eb be                   jmp    69ba46 <check_stack_depth+0x66>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1217
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1318
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079e830 <puttuple_common>:
         :	/*
         :	 * Shared code for tuple and datum cases.
         :	 */
         :	static void
         :	puttuple_common(Tuplesortstate *state, SortTuple *tuple)
         :	{
    0.00 :	  79e830:       55                      push   %rbp
    0.00 :	  79e831:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79e834:       41 57                   push   %r15
    0.00 :	  79e836:       41 56                   push   %r14
    0.00 :	  79e838:       41 55                   push   %r13
    0.00 :	  79e83a:       49 89 f5                mov    %rsi,%r13
    0.00 :	  79e83d:       41 54                   push   %r12
    0.00 :	  79e83f:       49 89 fc                mov    %rdi,%r12
    0.00 :	  79e842:       53                      push   %rbx
    0.00 :	  79e843:       48 83 ec 28             sub    $0x28,%rsp
         :	        switch (state->status)
    0.00 :	  79e847:       8b 07                   mov    (%rdi),%eax
    0.00 :	  79e849:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  79e84c:       0f 84 fe 02 00 00       je     79eb50 <puttuple_common+0x320>
    0.00 :	  79e852:       72 3c                   jb     79e890 <puttuple_common+0x60>
    0.00 :	  79e854:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  79e857:       0f 84 43 03 00 00       je     79eba0 <puttuple_common+0x370>
         :	                         */
         :	                        dumptuples(state, false);
         :	                        break;
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
    0.00 :	  79e85d:       ba d0 2e 8e 00          mov    $0x8e2ed0,%edx
    0.00 :	  79e862:       be 23 05 00 00          mov    $0x523,%esi
    0.00 :	  79e867:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79e86c:       e8 af cb fd ff          callq  77b420 <elog_start>
    0.00 :	  79e871:       be f0 29 8e 00          mov    $0x8e29f0,%esi
    0.00 :	  79e876:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79e87b:       31 c0                   xor    %eax,%eax
    0.00 :	  79e87d:       e8 ae c9 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79e882:       e8 49 ac cc ff          callq  4694d0 <abort@plt>
    0.00 :	  79e887:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  79e88e:       00 00 
         :	                         * as needed.  Note that we try to grow the array when there is
         :	                         * still one free slot remaining --- if we fail, there'll still be
         :	                         * room to store the incoming tuple, and then we'll switch to
         :	                         * tape-based operation.
         :	                         */
         :	                        if (state->memtupcount >= state->memtupsize - 1)
    0.00 :	  79e890:       41 8b 4c 24 6c          mov    0x6c(%r12),%ecx
    0.00 :	  79e895:       8b 57 68                mov    0x68(%rdi),%edx
    0.00 :	  79e898:       8d 41 ff                lea    -0x1(%rcx),%eax
    0.00 :	  79e89b:       89 d7                   mov    %edx,%edi
    0.00 :	  79e89d:       39 c2                   cmp    %eax,%edx
    0.00 :	  79e89f:       0f 8d 63 03 00 00       jge    79ec08 <puttuple_common+0x3d8>
         :	                        {
         :	                                (void) grow_memtuples(state);
         :	                                Assert(state->memtupcount < state->memtupsize);
         :	                        }
         :	                        state->memtuples[state->memtupcount++] = *tuple;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1217
   50.00 :	  79e8a5:       49 8b 55 00             mov    0x0(%r13),%rdx
    0.00 :	  79e8a9:       49 8b 4c 24 60          mov    0x60(%r12),%rcx
    0.00 :	  79e8ae:       48 63 c7                movslq %edi,%rax
    0.00 :	  79e8b1:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79e8b5:       48 89 14 c1             mov    %rdx,(%rcx,%rax,8)
    0.00 :	  79e8b9:       48 8d 34 c5 00 00 00    lea    0x0(,%rax,8),%rsi
    0.00 :	  79e8c0:       00 
    0.00 :	  79e8c1:       49 8b 45 08             mov    0x8(%r13),%rax
    0.00 :	  79e8c5:       8d 57 01                lea    0x1(%rdi),%edx
    0.00 :	  79e8c8:       48 89 44 0e 08          mov    %rax,0x8(%rsi,%rcx,1)
    0.00 :	  79e8cd:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  79e8d1:       48 89 44 0e 10          mov    %rax,0x10(%rsi,%rcx,1)
         :	                         * Note that once we enter TSS_BOUNDED state we will always try to
         :	                         * complete the sort that way.  In the worst case, if later input
         :	                         * tuples are larger than earlier ones, this might cause us to
         :	                         * exceed workMem significantly.
         :	                         */
         :	                        if (state->bounded &&
    0.00 :	  79e8d6:       41 80 7c 24 09 00       cmpb   $0x0,0x9(%r12)
         :	                        if (state->memtupcount >= state->memtupsize - 1)
         :	                        {
         :	                                (void) grow_memtuples(state);
         :	                                Assert(state->memtupcount < state->memtupsize);
         :	                        }
         :	                        state->memtuples[state->memtupcount++] = *tuple;
    0.00 :	  79e8dc:       41 89 54 24 68          mov    %edx,0x68(%r12)
         :	                         * Note that once we enter TSS_BOUNDED state we will always try to
         :	                         * complete the sort that way.  In the worst case, if later input
         :	                         * tuples are larger than earlier ones, this might cause us to
         :	                         * exceed workMem significantly.
         :	                         */
         :	                        if (state->bounded &&
    0.00 :	  79e8e1:       74 1d                   je     79e900 <puttuple_common+0xd0>
    0.00 :	  79e8e3:       41 8b 4c 24 0c          mov    0xc(%r12),%ecx
    0.00 :	  79e8e8:       8d 04 09                lea    (%rcx,%rcx,1),%eax
    0.00 :	  79e8eb:       39 c2                   cmp    %eax,%edx
    0.00 :	  79e8ed:       0f 8f ad 03 00 00       jg     79eca0 <puttuple_common+0x470>
    0.00 :	  79e8f3:       39 ca                   cmp    %ecx,%edx
    0.00 :	  79e8f5:       0f 8f 95 03 00 00       jg     79ec90 <puttuple_common+0x460>
    0.00 :	  79e8fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :
         :	                        /*
         :	                         * Done if we still fit in available memory and have array slots.
         :	                         */
         :	                        if (state->memtupcount < state->memtupsize && !LACKMEM(state))
    0.00 :	  79e900:       41 8b 74 24 6c          mov    0x6c(%r12),%esi
    0.00 :	  79e905:       39 f2                   cmp    %esi,%edx
    0.00 :	  79e907:       7d 0d                   jge    79e916 <puttuple_common+0xe6>
    0.00 :	  79e909:       49 83 7c 24 10 00       cmpq   $0x0,0x10(%r12)
    0.00 :	  79e90f:       90                      nop
    0.00 :	  79e910:       0f 89 c0 02 00 00       jns    79ebd6 <puttuple_common+0x3a6>
         :	         *
         :	         * Note: you might be thinking we need to account for the memtuples[]
         :	         * array in this calculation, but we effectively treat that as part of the
         :	         * MERGE_BUFFER_SIZE workspace.
         :	         */
         :	        mOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /
    0.00 :	  79e916:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  79e91b:       48 ba a1 0e ea a0 0e    movabs $0xea0ea0ea0ea0ea1,%rdx
    0.00 :	  79e922:       ea a0 0e 
    0.00 :	  79e925:       48 8d 88 00 a0 ff ff    lea    -0x6000(%rax),%rcx
    0.00 :	  79e92c:       48 89 c8                mov    %rcx,%rax
    0.00 :	  79e92f:       48 c1 f9 3f             sar    $0x3f,%rcx
    0.00 :	  79e933:       48 f7 ea                imul   %rdx
         :	        /*
         :	         * We must have at least 2*maxTapes slots in the memtuples[] array, else
         :	         * we'd not have room for merge heap plus preread.  It seems unlikely that
         :	         * this case would ever occur, but be safe.
         :	         */
         :	        maxTapes = Min(maxTapes, state->memtupsize / 2);
    0.00 :	  79e936:       89 f0                   mov    %esi,%eax
         :	         *
         :	         * Note: you might be thinking we need to account for the memtuples[]
         :	         * array in this calculation, but we effectively treat that as part of the
         :	         * MERGE_BUFFER_SIZE workspace.
         :	         */
         :	        mOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /
    0.00 :	  79e938:       48 c1 fa 0e             sar    $0xe,%rdx
    0.00 :	  79e93c:       29 ca                   sub    %ecx,%edx
         :	                                ntuples,
         :	                                j;
         :	        int64           tapeSpace;
         :
         :	        /* Compute number of tapes to use: merge order plus 1 */
         :	        maxTapes = tuplesort_merge_order(state->allowedMem) + 1;
    0.00 :	  79e93e:       b9 06 00 00 00          mov    $0x6,%ecx
    0.00 :	  79e943:       83 fa 06                cmp    $0x6,%edx
    0.00 :	  79e946:       0f 4d ca                cmovge %edx,%ecx
         :	        /*
         :	         * We must have at least 2*maxTapes slots in the memtuples[] array, else
         :	         * we'd not have room for merge heap plus preread.  It seems unlikely that
         :	         * this case would ever occur, but be safe.
         :	         */
         :	        maxTapes = Min(maxTapes, state->memtupsize / 2);
    0.00 :	  79e949:       c1 e8 1f                shr    $0x1f,%eax
    0.00 :	  79e94c:       01 f0                   add    %esi,%eax
         :	                                ntuples,
         :	                                j;
         :	        int64           tapeSpace;
         :
         :	        /* Compute number of tapes to use: merge order plus 1 */
         :	        maxTapes = tuplesort_merge_order(state->allowedMem) + 1;
    0.00 :	  79e94e:       83 c1 01                add    $0x1,%ecx
         :	        /*
         :	         * We must have at least 2*maxTapes slots in the memtuples[] array, else
         :	         * we'd not have room for merge heap plus preread.  It seems unlikely that
         :	         * this case would ever occur, but be safe.
         :	         */
         :	        maxTapes = Min(maxTapes, state->memtupsize / 2);
    0.00 :	  79e951:       d1 f8                   sar    %eax
    0.00 :	  79e953:       39 c1                   cmp    %eax,%ecx
    0.00 :	  79e955:       41 89 c7                mov    %eax,%r15d
    0.00 :	  79e958:       44 0f 4e f9             cmovle %ecx,%r15d
         :
         :	        state->maxTapes = maxTapes;
         :	        state->tapeRange = maxTapes - 1;
    0.00 :	  79e95c:       41 8d 47 ff             lea    -0x1(%r15),%eax
         :	         * we'd not have room for merge heap plus preread.  It seems unlikely that
         :	         * this case would ever occur, but be safe.
         :	         */
         :	        maxTapes = Min(maxTapes, state->memtupsize / 2);
         :
         :	        state->maxTapes = maxTapes;
    0.00 :	  79e960:       45 89 7c 24 20          mov    %r15d,0x20(%r12)
         :	        state->tapeRange = maxTapes - 1;
    0.00 :	  79e965:       41 89 44 24 24          mov    %eax,0x24(%r12)
         :
         :	#ifdef TRACE_SORT
         :	        if (trace_sort)
    0.00 :	  79e96a:       80 3d 6f bf 41 00 00    cmpb   $0x0,0x41bf6f(%rip)        # bba8e0 <trace_sort>
    0.00 :	  79e971:       0f 85 89 04 00 00       jne    79ee00 <puttuple_common+0x5d0>
         :	         * other scenarios the memtuples[] array is unlikely to occupy more than
         :	         * half of allowedMem.  In the pass-by-value case it's not important to
         :	         * account for tuple space, so we don't care if LACKMEM becomes
         :	         * inaccurate.)
         :	         */
         :	        tapeSpace = (int64) maxTapes *TAPE_BUFFER_OVERHEAD;
    0.00 :	  79e977:       4d 63 ef                movslq %r15d,%r13
         :
         :	        if (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)
    0.00 :	  79e97a:       49 8b 7c 24 60          mov    0x60(%r12),%rdi
         :	         * other scenarios the memtuples[] array is unlikely to occupy more than
         :	         * half of allowedMem.  In the pass-by-value case it's not important to
         :	         * account for tuple space, so we don't care if LACKMEM becomes
         :	         * inaccurate.)
         :	         */
         :	        tapeSpace = (int64) maxTapes *TAPE_BUFFER_OVERHEAD;
    0.00 :	  79e97f:       4b 8d 5c 6d 00          lea    0x0(%r13,%r13,2),%rbx
    0.00 :	  79e984:       48 c1 e3 0d             shl    $0xd,%rbx
         :
         :	        if (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)
    0.00 :	  79e988:       e8 03 a1 ff ff          callq  798a90 <GetMemoryChunkSpace>
    0.00 :	  79e98d:       48 01 d8                add    %rbx,%rax
    0.00 :	  79e990:       49 3b 44 24 18          cmp    0x18(%r12),%rax
    0.00 :	  79e995:       0f 82 0d 04 00 00       jb     79eda8 <puttuple_common+0x578>
         :	         * Create the tape set and allocate the per-tape data arrays.
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e99b:       4a 8d 1c ad 00 00 00    lea    0x0(,%r13,4),%rbx
    0.00 :	  79e9a2:       00 
         :
         :	        /*
         :	         * Make sure that the temp file(s) underlying the tape set are created in
         :	         * suitable temp tablespaces.
         :	         */
         :	        PrepareTempTablespaces();
    0.00 :	  79e9a3:       e8 c8 05 df ff          callq  58ef70 <PrepareTempTablespaces>
         :
         :	        /*
         :	         * Create the tape set and allocate the per-tape data arrays.
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
    0.00 :	  79e9a8:       44 89 ff                mov    %r15d,%edi
    0.00 :	  79e9ab:       e8 b0 dd ff ff          callq  79c760 <LogicalTapeSetCreate>
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
    0.00 :	  79e9b0:       4c 89 ef                mov    %r13,%rdi
         :	        PrepareTempTablespaces();
         :
         :	        /*
         :	         * Create the tape set and allocate the per-tape data arrays.
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
    0.00 :	  79e9b3:       49 89 44 24 30          mov    %rax,0x30(%r12)
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
    0.00 :	  79e9b8:       e8 b3 a5 ff ff          callq  798f70 <palloc0>
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9bd:       48 89 df                mov    %rbx,%rdi
         :	        /*
         :	         * Create the tape set and allocate the per-tape data arrays.
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
    0.00 :	  79e9c0:       49 89 44 24 78          mov    %rax,0x78(%r12)
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9c5:       e8 a6 a5 ff ff          callq  798f70 <palloc0>
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9ca:       48 89 df                mov    %rbx,%rdi
         :	         * Create the tape set and allocate the per-tape data arrays.
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9cd:       49 89 84 24 80 00 00    mov    %rax,0x80(%r12)
    0.00 :	  79e9d4:       00 
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9d5:       e8 96 a5 ff ff          callq  798f70 <palloc0>
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9da:       48 89 df                mov    %rbx,%rdi
         :	         */
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9dd:       49 89 84 24 88 00 00    mov    %rax,0x88(%r12)
    0.00 :	  79e9e4:       00 
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9e5:       e8 86 a5 ff ff          callq  798f70 <palloc0>
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
    0.00 :	  79e9ea:       4a 8d 3c ed 00 00 00    lea    0x0(,%r13,8),%rdi
    0.00 :	  79e9f1:       00 
         :	        state->tapeset = LogicalTapeSetCreate(maxTapes);
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9f2:       49 89 84 24 90 00 00    mov    %rax,0x90(%r12)
    0.00 :	  79e9f9:       00 
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
    0.00 :	  79e9fa:       e8 71 a5 ff ff          callq  798f70 <palloc0>
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79e9ff:       48 89 df                mov    %rbx,%rdi
         :
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
    0.00 :	  79ea02:       49 89 84 24 98 00 00    mov    %rax,0x98(%r12)
    0.00 :	  79ea09:       00 
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea0a:       e8 61 a5 ff ff          callq  798f70 <palloc0>
         :	        state->tp_runs = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea0f:       48 89 df                mov    %rbx,%rdi
         :	        state->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea12:       49 89 84 24 b0 00 00    mov    %rax,0xb0(%r12)
    0.00 :	  79ea19:       00 
         :	        state->tp_runs = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea1a:       e8 51 a5 ff ff          callq  798f70 <palloc0>
         :	        state->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea1f:       48 89 df                mov    %rbx,%rdi
         :	        state->mergenext = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_runs = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea22:       49 89 84 24 b8 00 00    mov    %rax,0xb8(%r12)
    0.00 :	  79ea29:       00 
         :	        state->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea2a:       e8 41 a5 ff ff          callq  798f70 <palloc0>
         :	        state->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea2f:       48 89 df                mov    %rbx,%rdi
         :	        state->mergelast = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_runs = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea32:       49 89 84 24 c0 00 00    mov    %rax,0xc0(%r12)
    0.00 :	  79ea39:       00 
         :	        state->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea3a:       e8 31 a5 ff ff          callq  798f70 <palloc0>
         :	         *
         :	         * NOTE: we pass false for checkIndex since there's no point in comparing
         :	         * indexes in this step, even though we do intend the indexes to be part
         :	         * of the sort key...
         :	         */
         :	        ntuples = state->memtupcount;
    0.00 :	  79ea3f:       45 8b 74 24 68          mov    0x68(%r12),%r14d
         :	        state->mergeavailslots = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->mergeavailmem = (int64 *) palloc0(maxTapes * sizeof(int64));
         :	        state->tp_fib = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_runs = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));
         :	        state->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));
    0.00 :	  79ea44:       49 89 84 24 c8 00 00    mov    %rax,0xc8(%r12)
    0.00 :	  79ea4b:       00 
         :	         * NOTE: we pass false for checkIndex since there's no point in comparing
         :	         * indexes in this step, even though we do intend the indexes to be part
         :	         * of the sort key...
         :	         */
         :	        ntuples = state->memtupcount;
         :	        state->memtupcount = 0;         /* make the heap empty */
    0.00 :	  79ea4c:       41 c7 44 24 68 00 00    movl   $0x0,0x68(%r12)
    0.00 :	  79ea53:       00 00 
         :	        for (j = 0; j < ntuples; j++)
    0.00 :	  79ea55:       45 85 f6                test   %r14d,%r14d
    0.00 :	  79ea58:       7e 42                   jle    79ea9c <puttuple_common+0x26c>
    0.00 :	  79ea5a:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  79ea5d:       31 db                   xor    %ebx,%ebx
    0.00 :	  79ea5f:       90                      nop
         :	        {
         :	                /* Must copy source tuple to avoid possible overwrite */
         :	                SortTuple       stup = state->memtuples[j];
    0.00 :	  79ea60:       49 8b 54 24 60          mov    0x60(%r12),%rdx
         :
         :	                tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ea65:       48 8d 75 b0             lea    -0x50(%rbp),%rsi
    0.00 :	  79ea69:       31 c9                   xor    %ecx,%ecx
    0.00 :	  79ea6b:       4c 89 e7                mov    %r12,%rdi
         :	         * indexes in this step, even though we do intend the indexes to be part
         :	         * of the sort key...
         :	         */
         :	        ntuples = state->memtupcount;
         :	        state->memtupcount = 0;         /* make the heap empty */
         :	        for (j = 0; j < ntuples; j++)
    0.00 :	  79ea6e:       41 83 c5 01             add    $0x1,%r13d
         :	        {
         :	                /* Must copy source tuple to avoid possible overwrite */
         :	                SortTuple       stup = state->memtuples[j];
    0.00 :	  79ea72:       48 8b 04 1a             mov    (%rdx,%rbx,1),%rax
    0.00 :	  79ea76:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  79ea7a:       48 8b 44 1a 08          mov    0x8(%rdx,%rbx,1),%rax
    0.00 :	  79ea7f:       48 89 45 b8             mov    %rax,-0x48(%rbp)
    0.00 :	  79ea83:       48 8b 44 1a 10          mov    0x10(%rdx,%rbx,1),%rax
         :
         :	                tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ea88:       31 d2                   xor    %edx,%edx
         :	         * indexes in this step, even though we do intend the indexes to be part
         :	         * of the sort key...
         :	         */
         :	        ntuples = state->memtupcount;
         :	        state->memtupcount = 0;         /* make the heap empty */
         :	        for (j = 0; j < ntuples; j++)
    0.00 :	  79ea8a:       48 83 c3 18             add    $0x18,%rbx
         :	        {
         :	                /* Must copy source tuple to avoid possible overwrite */
         :	                SortTuple       stup = state->memtuples[j];
    0.00 :	  79ea8e:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :
         :	                tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ea92:       e8 39 e7 ff ff          callq  79d1d0 <tuplesort_heap_insert>
         :	         * indexes in this step, even though we do intend the indexes to be part
         :	         * of the sort key...
         :	         */
         :	        ntuples = state->memtupcount;
         :	        state->memtupcount = 0;         /* make the heap empty */
         :	        for (j = 0; j < ntuples; j++)
    0.00 :	  79ea97:       45 39 ee                cmp    %r13d,%r14d
    0.00 :	  79ea9a:       7f c4                   jg     79ea60 <puttuple_common+0x230>
         :	        state->currentRun = 0;
         :
         :	        /*
         :	         * Initialize variables of Algorithm D (step D1).
         :	         */
         :	        for (j = 0; j < maxTapes; j++)
    0.00 :	  79ea9c:       45 85 ff                test   %r15d,%r15d
         :
         :	                tuplesort_heap_insert(state, &stup, 0, false);
         :	        }
         :	        Assert(state->memtupcount == ntuples);
         :
         :	        state->currentRun = 0;
    0.00 :	  79ea9f:       41 c7 44 24 74 00 00    movl   $0x0,0x74(%r12)
    0.00 :	  79eaa6:       00 00 
         :
         :	        /*
         :	         * Initialize variables of Algorithm D (step D1).
         :	         */
         :	        for (j = 0; j < maxTapes; j++)
    0.00 :	  79eaa8:       7e 4a                   jle    79eaf4 <puttuple_common+0x2c4>
    0.00 :	  79eaaa:       31 c9                   xor    %ecx,%ecx
    0.00 :	  79eaac:       31 d2                   xor    %edx,%edx
    0.00 :	  79eaae:       66 90                   xchg   %ax,%ax
         :	        {
         :	                state->tp_fib[j] = 1;
    0.00 :	  79eab0:       49 8b 84 24 b0 00 00    mov    0xb0(%r12),%rax
    0.00 :	  79eab7:       00 
    0.00 :	  79eab8:       c7 04 10 01 00 00 00    movl   $0x1,(%rax,%rdx,1)
         :	                state->tp_runs[j] = 0;
    0.00 :	  79eabf:       49 8b 84 24 b8 00 00    mov    0xb8(%r12),%rax
    0.00 :	  79eac6:       00 
    0.00 :	  79eac7:       c7 04 10 00 00 00 00    movl   $0x0,(%rax,%rdx,1)
         :	                state->tp_dummy[j] = 1;
    0.00 :	  79eace:       49 8b 84 24 c0 00 00    mov    0xc0(%r12),%rax
    0.00 :	  79ead5:       00 
    0.00 :	  79ead6:       c7 04 10 01 00 00 00    movl   $0x1,(%rax,%rdx,1)
         :	                state->tp_tapenum[j] = j;
    0.00 :	  79eadd:       49 8b 84 24 c8 00 00    mov    0xc8(%r12),%rax
    0.00 :	  79eae4:       00 
    0.00 :	  79eae5:       89 0c 10                mov    %ecx,(%rax,%rdx,1)
         :	        state->currentRun = 0;
         :
         :	        /*
         :	         * Initialize variables of Algorithm D (step D1).
         :	         */
         :	        for (j = 0; j < maxTapes; j++)
    0.00 :	  79eae8:       83 c1 01                add    $0x1,%ecx
    0.00 :	  79eaeb:       48 83 c2 04             add    $0x4,%rdx
    0.00 :	  79eaef:       41 39 cf                cmp    %ecx,%r15d
    0.00 :	  79eaf2:       7f bc                   jg     79eab0 <puttuple_common+0x280>
         :	                state->tp_fib[j] = 1;
         :	                state->tp_runs[j] = 0;
         :	                state->tp_dummy[j] = 1;
         :	                state->tp_tapenum[j] = j;
         :	        }
         :	        state->tp_fib[state->tapeRange] = 0;
    0.00 :	  79eaf4:       49 63 54 24 24          movslq 0x24(%r12),%rdx
    0.00 :	  79eaf9:       49 8b 84 24 b0 00 00    mov    0xb0(%r12),%rax
    0.00 :	  79eb00:       00 
         :	                        inittapes(state);
         :
         :	                        /*
         :	                         * Dump tuples until we are back under the limit.
         :	                         */
         :	                        dumptuples(state, false);
    0.00 :	  79eb01:       31 f6                   xor    %esi,%esi
    0.00 :	  79eb03:       4c 89 e7                mov    %r12,%rdi
         :	                state->tp_fib[j] = 1;
         :	                state->tp_runs[j] = 0;
         :	                state->tp_dummy[j] = 1;
         :	                state->tp_tapenum[j] = j;
         :	        }
         :	        state->tp_fib[state->tapeRange] = 0;
    0.00 :	  79eb06:       c7 04 90 00 00 00 00    movl   $0x0,(%rax,%rdx,4)
         :	        state->tp_dummy[state->tapeRange] = 0;
    0.00 :	  79eb0d:       49 63 54 24 24          movslq 0x24(%r12),%rdx
    0.00 :	  79eb12:       49 8b 84 24 c0 00 00    mov    0xc0(%r12),%rax
    0.00 :	  79eb19:       00 
    0.00 :	  79eb1a:       c7 04 90 00 00 00 00    movl   $0x0,(%rax,%rdx,4)
         :
         :	        state->Level = 1;
    0.00 :	  79eb21:       41 c7 84 24 a8 00 00    movl   $0x1,0xa8(%r12)
    0.00 :	  79eb28:       00 01 00 00 00 
         :	        state->destTape = 0;
    0.00 :	  79eb2d:       41 c7 84 24 ac 00 00    movl   $0x0,0xac(%r12)
    0.00 :	  79eb34:       00 00 00 00 00 
         :
         :	        state->status = TSS_BUILDRUNS;
    0.00 :	  79eb39:       41 c7 04 24 02 00 00    movl   $0x2,(%r12)
    0.00 :	  79eb40:       00 
         :	                        inittapes(state);
         :
         :	                        /*
         :	                         * Dump tuples until we are back under the limit.
         :	                         */
         :	                        dumptuples(state, false);
    0.00 :	  79eb41:       e8 da f7 ff ff          callq  79e320 <dumptuples>
         :	                        break;
    0.00 :	  79eb46:       e9 8b 00 00 00          jmpq   79ebd6 <puttuple_common+0x3a6>
    0.00 :	  79eb4b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * good speed optimization, too, since when there are many more
         :	                         * input tuples than the bound, most input tuples can be discarded
         :	                         * with just this one comparison.  Note that because we currently
         :	                         * have the sort direction reversed, we must check for <= not >=.
         :	                         */
         :	                        if (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)
    0.00 :	  79eb50:       48 8b 77 60             mov    0x60(%rdi),%rsi
    0.00 :	  79eb54:       48 89 fa                mov    %rdi,%rdx
    0.00 :	  79eb57:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  79eb5a:       41 ff 54 24 38          callq  *0x38(%r12)
    0.00 :	  79eb5f:       85 c0                   test   %eax,%eax
    0.00 :	  79eb61:       0f 8e 81 00 00 00       jle    79ebe8 <puttuple_common+0x3b8>
         :	                                CHECK_FOR_INTERRUPTS();
         :	                        }
         :	                        else
         :	                        {
         :	                                /* discard top of heap, sift up, insert new tuple */
         :	                                free_sort_tuple(state, &state->memtuples[0]);
    0.00 :	  79eb67:       49 8b 74 24 60          mov    0x60(%r12),%rsi
    0.00 :	  79eb6c:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79eb6f:       e8 1c ed ff ff          callq  79d890 <free_sort_tuple>
         :	                                tuplesort_heap_siftup(state, false);
    0.00 :	  79eb74:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79eb77:       31 f6                   xor    %esi,%esi
    0.00 :	  79eb79:       e8 62 e4 ff ff          callq  79cfe0 <tuplesort_heap_siftup>
         :	                                tuplesort_heap_insert(state, tuple, 0, false);
    0.00 :	  79eb7e:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  79eb81:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79eb84:       31 c9                   xor    %ecx,%ecx
    0.00 :	  79eb86:       31 d2                   xor    %edx,%edx
    0.00 :	  79eb88:       e8 43 e6 ff ff          callq  79d1d0 <tuplesort_heap_insert>
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        break;
         :	        }
         :	}
    0.00 :	  79eb8d:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  79eb91:       5b                      pop    %rbx
    0.00 :	  79eb92:       41 5c                   pop    %r12
    0.00 :	  79eb94:       41 5d                   pop    %r13
    0.00 :	  79eb96:       41 5e                   pop    %r14
    0.00 :	  79eb98:       41 5f                   pop    %r15
    0.00 :	  79eb9a:       c9                      leaveq 
    0.00 :	  79eb9b:       c3                      retq   
    0.00 :	  79eb9c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                         *
         :	                         * Note there will always be at least one tuple in the heap at
         :	                         * this point; see dumptuples.
         :	                         */
         :	                        Assert(state->memtupcount > 0);
         :	                        if (COMPARETUP(state, tuple, &state->memtuples[0]) >= 0)
    0.00 :	  79eba0:       48 8b 77 60             mov    0x60(%rdi),%rsi
    0.00 :	  79eba4:       48 89 fa                mov    %rdi,%rdx
    0.00 :	  79eba7:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  79ebaa:       41 ff 54 24 38          callq  *0x38(%r12)
    0.00 :	  79ebaf:       85 c0                   test   %eax,%eax
    0.00 :	  79ebb1:       0f 88 b9 00 00 00       js     79ec70 <puttuple_common+0x440>
         :	                                tuplesort_heap_insert(state, tuple, state->currentRun, true);
    0.00 :	  79ebb7:       41 8b 54 24 74          mov    0x74(%r12),%edx
    0.00 :	  79ebbc:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  79ebc1:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  79ebc4:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ebc7:       e8 04 e6 ff ff          callq  79d1d0 <tuplesort_heap_insert>
         :	                                tuplesort_heap_insert(state, tuple, state->currentRun + 1, true);
         :
         :	                        /*
         :	                         * If we are over the memory limit, dump tuples till we're under.
         :	                         */
         :	                        dumptuples(state, false);
    0.00 :	  79ebcc:       31 f6                   xor    %esi,%esi
    0.00 :	  79ebce:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ebd1:       e8 4a f7 ff ff          callq  79e320 <dumptuples>
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        break;
         :	        }
         :	}
    0.00 :	  79ebd6:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  79ebda:       5b                      pop    %rbx
    0.00 :	  79ebdb:       41 5c                   pop    %r12
    0.00 :	  79ebdd:       41 5d                   pop    %r13
    0.00 :	  79ebdf:       41 5e                   pop    %r14
    0.00 :	  79ebe1:       41 5f                   pop    %r15
    0.00 :	  79ebe3:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1318
   50.00 :	  79ebe4:       c3                      retq   
    0.00 :	  79ebe5:       0f 1f 00                nopl   (%rax)
         :	                         * have the sort direction reversed, we must check for <= not >=.
         :	                         */
         :	                        if (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)
         :	                        {
         :	                                /* new tuple <= top of the heap, so we can discard it */
         :	                                free_sort_tuple(state, tuple);
    0.00 :	  79ebe8:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  79ebeb:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ebee:       e8 9d ec ff ff          callq  79d890 <free_sort_tuple>
         :	                                CHECK_FOR_INTERRUPTS();
    0.00 :	  79ebf3:       0f b6 05 96 b4 41 00    movzbl 0x41b496(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  79ebfa:       84 c0                   test   %al,%al
    0.00 :	  79ebfc:       74 d8                   je     79ebd6 <puttuple_common+0x3a6>
    0.00 :	  79ebfe:       e8 9d d6 ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  79ec03:       eb d1                   jmp    79ebd6 <puttuple_common+0x3a6>
    0.00 :	  79ec05:       0f 1f 00                nopl   (%rax)
         :	        int                     newmemtupsize;
         :	        int                     memtupsize = state->memtupsize;
         :	        int64           memNowUsed = state->allowedMem - state->availMem;
         :
         :	        /* Forget it if we've already maxed out memtuples, per comment above */
         :	        if (!state->growmemtuples)
    0.00 :	  79ec08:       41 80 7c 24 70 00       cmpb   $0x0,0x70(%r12)
         :	static bool
         :	grow_memtuples(Tuplesortstate *state)
         :	{
         :	        int                     newmemtupsize;
         :	        int                     memtupsize = state->memtupsize;
         :	        int64           memNowUsed = state->allowedMem - state->availMem;
    0.00 :	  79ec0e:       49 8b 74 24 18          mov    0x18(%r12),%rsi
    0.00 :	  79ec13:       4d 8b 74 24 10          mov    0x10(%r12),%r14
         :
         :	        /* Forget it if we've already maxed out memtuples, per comment above */
         :	        if (!state->growmemtuples)
    0.00 :	  79ec18:       0f 84 87 fc ff ff       je     79e8a5 <puttuple_common+0x75>
         :	static bool
         :	grow_memtuples(Tuplesortstate *state)
         :	{
         :	        int                     newmemtupsize;
         :	        int                     memtupsize = state->memtupsize;
         :	        int64           memNowUsed = state->allowedMem - state->availMem;
    0.00 :	  79ec1e:       48 89 f0                mov    %rsi,%rax
    0.00 :	  79ec21:       4c 29 f0                sub    %r14,%rax
         :	        /* Forget it if we've already maxed out memtuples, per comment above */
         :	        if (!state->growmemtuples)
         :	                return false;
         :
         :	        /* Select new value of memtupsize */
         :	        if (memNowUsed <= state->availMem)
    0.00 :	  79ec24:       49 39 c6                cmp    %rax,%r14
    0.00 :	  79ec27:       0f 8c 13 02 00 00       jl     79ee40 <puttuple_common+0x610>
         :	        {
         :	                /*
         :	                 * We've used no more than half of allowedMem; double our usage,
         :	                 * clamping at INT_MAX tuples.
         :	                 */
         :	                if (memtupsize < INT_MAX / 2)
    0.00 :	  79ec2d:       81 f9 fe ff ff 3f       cmp    $0x3ffffffe,%ecx
    0.00 :	  79ec33:       0f 8f 47 02 00 00       jg     79ee80 <puttuple_common+0x650>
         :	                        newmemtupsize = memtupsize * 2;
    0.00 :	  79ec39:       8d 1c 09                lea    (%rcx,%rcx,1),%ebx
         :	                /* We won't make any further enlargement attempts */
         :	                state->growmemtuples = false;
         :	        }
         :
         :	        /* Must enlarge array by at least one element, else report failure */
         :	        if (newmemtupsize <= memtupsize)
    0.00 :	  79ec3c:       39 d9                   cmp    %ebx,%ecx
    0.00 :	  79ec3e:       7d 1f                   jge    79ec5f <puttuple_common+0x42f>
         :	         * to ensure our request won't be rejected.  Note that we can easily
         :	         * exhaust address space before facing this outcome.  (This is presently
         :	         * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but
         :	         * don't rely on that at this distance.)
         :	         */
         :	        if ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))
    0.00 :	  79ec40:       85 db                   test   %ebx,%ebx
    0.00 :	  79ec42:       0f 88 9d 02 00 00       js     79eee5 <puttuple_common+0x6b5>
         :	         * array were to increase.  That shouldn't happen with any sane value of
         :	         * allowedMem, because at any array size large enough to risk LACKMEM,
         :	         * palloc would be treating both old and new arrays as separate chunks.
         :	         * But we'll check LACKMEM explicitly below just in case.)
         :	         */
         :	        if (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))
    0.00 :	  79ec48:       89 d8                   mov    %ebx,%eax
    0.00 :	  79ec4a:       29 c8                   sub    %ecx,%eax
    0.00 :	  79ec4c:       48 98                   cltq   
    0.00 :	  79ec4e:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79ec52:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  79ec56:       49 39 c6                cmp    %rax,%r14
    0.00 :	  79ec59:       0f 8d 31 02 00 00       jge    79ee90 <puttuple_common+0x660>
         :	                elog(ERROR, "unexpected out-of-memory situation during sort");
         :	        return true;
         :
         :	noalloc:
         :	        /* If for any reason we didn't realloc, shut off future attempts */
         :	        state->growmemtuples = false;
    0.00 :	  79ec5f:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  79ec65:       89 d7                   mov    %edx,%edi
    0.00 :	  79ec67:       e9 39 fc ff ff          jmpq   79e8a5 <puttuple_common+0x75>
    0.00 :	  79ec6c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                         */
         :	                        Assert(state->memtupcount > 0);
         :	                        if (COMPARETUP(state, tuple, &state->memtuples[0]) >= 0)
         :	                                tuplesort_heap_insert(state, tuple, state->currentRun, true);
         :	                        else
         :	                                tuplesort_heap_insert(state, tuple, state->currentRun + 1, true);
    0.00 :	  79ec70:       41 8b 54 24 74          mov    0x74(%r12),%edx
    0.00 :	  79ec75:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  79ec7a:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  79ec7d:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ec80:       83 c2 01                add    $0x1,%edx
    0.00 :	  79ec83:       e8 48 e5 ff ff          callq  79d1d0 <tuplesort_heap_insert>
    0.00 :	  79ec88:       e9 3f ff ff ff          jmpq   79ebcc <puttuple_common+0x39c>
    0.00 :	  79ec8d:       0f 1f 00                nopl   (%rax)
         :	                         * Note that once we enter TSS_BOUNDED state we will always try to
         :	                         * complete the sort that way.  In the worst case, if later input
         :	                         * tuples are larger than earlier ones, this might cause us to
         :	                         * exceed workMem significantly.
         :	                         */
         :	                        if (state->bounded &&
    0.00 :	  79ec90:       49 83 7c 24 10 00       cmpq   $0x0,0x10(%r12)
    0.00 :	  79ec96:       0f 89 64 fc ff ff       jns    79e900 <puttuple_common+0xd0>
    0.00 :	  79ec9c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                (state->memtupcount > state->bound * 2 ||
         :	                                 (state->memtupcount > state->bound && LACKMEM(state))))
         :	                        {
         :	#ifdef TRACE_SORT
         :	                                if (trace_sort)
    0.00 :	  79eca0:       80 3d 39 bc 41 00 00    cmpb   $0x0,0x41bc39(%rip)        # bba8e0 <trace_sort>
    0.00 :	  79eca7:       0f 85 0b 01 00 00       jne    79edb8 <puttuple_common+0x588>
         :	 * the direction of comparison for tupindexes.
         :	 */
         :	static void
         :	make_bounded_heap(Tuplesortstate *state)
         :	{
         :	        int                     tupcount = state->memtupcount;
    0.00 :	  79ecad:       45 8b 6c 24 68          mov    0x68(%r12),%r13d
         :	        Assert(state->status == TSS_INITIAL);
         :	        Assert(state->bounded);
         :	        Assert(tupcount >= state->bound);
         :
         :	        /* Reverse sort direction so largest entry will be at root */
         :	        REVERSEDIRECTION(state);
    0.00 :	  79ecb2:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ecb5:       41 ff 54 24 58          callq  *0x58(%r12)
         :
         :	        state->memtupcount = 0;         /* make the heap empty */
    0.00 :	  79ecba:       41 c7 44 24 68 00 00    movl   $0x0,0x68(%r12)
    0.00 :	  79ecc1:       00 00 
         :	        for (i = 0; i < tupcount; i++)
    0.00 :	  79ecc3:       45 85 ed                test   %r13d,%r13d
    0.00 :	  79ecc6:       0f 8e 9c 00 00 00       jle    79ed68 <puttuple_common+0x538>
    0.00 :	  79eccc:       41 8d 45 ff             lea    -0x1(%r13),%eax
    0.00 :	  79ecd0:       31 db                   xor    %ebx,%ebx
         :	                {
         :	                        /* Insert next tuple into heap */
         :	                        /* Must copy source tuple to avoid possible overwrite */
         :	                        SortTuple       stup = state->memtuples[i];
         :
         :	                        tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ecd2:       4c 8d 75 b0             lea    -0x50(%rbp),%r14
         :
         :	        /* Reverse sort direction so largest entry will be at root */
         :	        REVERSEDIRECTION(state);
         :
         :	        state->memtupcount = 0;         /* make the heap empty */
         :	        for (i = 0; i < tupcount; i++)
    0.00 :	  79ecd6:       48 8d 44 40 03          lea    0x3(%rax,%rax,2),%rax
    0.00 :	  79ecdb:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  79ece2:       00 
    0.00 :	  79ece3:       eb 0c                   jmp    79ecf1 <puttuple_common+0x4c1>
    0.00 :	  79ece5:       0f 1f 00                nopl   (%rax)
         :
         :	                        /* If heap too full, discard largest entry */
         :	                        if (state->memtupcount > state->bound)
         :	                        {
         :	                                free_sort_tuple(state, &state->memtuples[0]);
         :	                                tuplesort_heap_siftup(state, false);
    0.00 :	  79ece8:       48 83 c3 18             add    $0x18,%rbx
         :
         :	        /* Reverse sort direction so largest entry will be at root */
         :	        REVERSEDIRECTION(state);
         :
         :	        state->memtupcount = 0;         /* make the heap empty */
         :	        for (i = 0; i < tupcount; i++)
    0.00 :	  79ecec:       4c 39 eb                cmp    %r13,%rbx
    0.00 :	  79ecef:       74 77                   je     79ed68 <puttuple_common+0x538>
         :	        {
         :	                if (state->memtupcount >= state->bound &&
    0.00 :	  79ecf1:       41 8b 44 24 68          mov    0x68(%r12),%eax
    0.00 :	  79ecf6:       41 3b 44 24 0c          cmp    0xc(%r12),%eax
    0.00 :	  79ecfb:       7c 15                   jl     79ed12 <puttuple_common+0x4e2>
    0.00 :	  79ecfd:       49 8b 74 24 60          mov    0x60(%r12),%rsi
    0.00 :	  79ed02:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  79ed05:       48 8d 3c 1e             lea    (%rsi,%rbx,1),%rdi
    0.00 :	  79ed09:       41 ff 54 24 38          callq  *0x38(%r12)
    0.00 :	  79ed0e:       85 c0                   test   %eax,%eax
    0.00 :	  79ed10:       7e 66                   jle    79ed78 <puttuple_common+0x548>
         :	                }
         :	                else
         :	                {
         :	                        /* Insert next tuple into heap */
         :	                        /* Must copy source tuple to avoid possible overwrite */
         :	                        SortTuple       stup = state->memtuples[i];
    0.00 :	  79ed12:       49 8b 54 24 60          mov    0x60(%r12),%rdx
         :
         :	                        tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ed17:       31 c9                   xor    %ecx,%ecx
    0.00 :	  79ed19:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  79ed1c:       4c 89 e7                mov    %r12,%rdi
         :	                }
         :	                else
         :	                {
         :	                        /* Insert next tuple into heap */
         :	                        /* Must copy source tuple to avoid possible overwrite */
         :	                        SortTuple       stup = state->memtuples[i];
    0.00 :	  79ed1f:       48 8b 04 1a             mov    (%rdx,%rbx,1),%rax
    0.00 :	  79ed23:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  79ed27:       48 8b 44 1a 08          mov    0x8(%rdx,%rbx,1),%rax
    0.00 :	  79ed2c:       48 89 45 b8             mov    %rax,-0x48(%rbp)
    0.00 :	  79ed30:       48 8b 44 1a 10          mov    0x10(%rdx,%rbx,1),%rax
         :
         :	                        tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ed35:       31 d2                   xor    %edx,%edx
         :	                }
         :	                else
         :	                {
         :	                        /* Insert next tuple into heap */
         :	                        /* Must copy source tuple to avoid possible overwrite */
         :	                        SortTuple       stup = state->memtuples[i];
    0.00 :	  79ed37:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :
         :	                        tuplesort_heap_insert(state, &stup, 0, false);
    0.00 :	  79ed3b:       e8 90 e4 ff ff          callq  79d1d0 <tuplesort_heap_insert>
         :
         :	                        /* If heap too full, discard largest entry */
         :	                        if (state->memtupcount > state->bound)
    0.00 :	  79ed40:       41 8b 44 24 68          mov    0x68(%r12),%eax
    0.00 :	  79ed45:       41 3b 44 24 0c          cmp    0xc(%r12),%eax
    0.00 :	  79ed4a:       7e 9c                   jle    79ece8 <puttuple_common+0x4b8>
         :	                        {
         :	                                free_sort_tuple(state, &state->memtuples[0]);
    0.00 :	  79ed4c:       49 8b 74 24 60          mov    0x60(%r12),%rsi
    0.00 :	  79ed51:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ed54:       e8 37 eb ff ff          callq  79d890 <free_sort_tuple>
         :	                                tuplesort_heap_siftup(state, false);
    0.00 :	  79ed59:       31 f6                   xor    %esi,%esi
    0.00 :	  79ed5b:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ed5e:       e8 7d e2 ff ff          callq  79cfe0 <tuplesort_heap_siftup>
    0.00 :	  79ed63:       eb 83                   jmp    79ece8 <puttuple_common+0x4b8>
    0.00 :	  79ed65:       0f 1f 00                nopl   (%rax)
         :	                        }
         :	                }
         :	        }
         :
         :	        Assert(state->memtupcount == state->bound);
         :	        state->status = TSS_BOUNDED;
    0.00 :	  79ed68:       41 c7 04 24 01 00 00    movl   $0x1,(%r12)
    0.00 :	  79ed6f:       00 
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        break;
         :	        }
         :	}
    0.00 :	  79ed70:       e9 61 fe ff ff          jmpq   79ebd6 <puttuple_common+0x3a6>
    0.00 :	  79ed75:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                if (state->memtupcount >= state->bound &&
         :	                  COMPARETUP(state, &state->memtuples[i], &state->memtuples[0]) <= 0)
         :	                {
         :	                        /* New tuple would just get thrown out, so skip it */
         :	                        free_sort_tuple(state, &state->memtuples[i]);
    0.00 :	  79ed78:       48 89 de                mov    %rbx,%rsi
    0.00 :	  79ed7b:       49 03 74 24 60          add    0x60(%r12),%rsi
    0.00 :	  79ed80:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  79ed83:       e8 08 eb ff ff          callq  79d890 <free_sort_tuple>
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  79ed88:       0f b6 05 01 b3 41 00    movzbl 0x41b301(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  79ed8f:       84 c0                   test   %al,%al
    0.00 :	  79ed91:       0f 84 51 ff ff ff       je     79ece8 <puttuple_common+0x4b8>
    0.00 :	  79ed97:       e8 04 d5 ef ff          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  79ed9c:       e9 47 ff ff ff          jmpq   79ece8 <puttuple_common+0x4b8>
    0.00 :	  79eda1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * inaccurate.)
         :	         */
         :	        tapeSpace = (int64) maxTapes *TAPE_BUFFER_OVERHEAD;
         :
         :	        if (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)
         :	                USEMEM(state, tapeSpace);
    0.00 :	  79eda8:       49 29 5c 24 10          sub    %rbx,0x10(%r12)
    0.00 :	  79edad:       0f 1f 00                nopl   (%rax)
    0.00 :	  79edb0:       e9 e6 fb ff ff          jmpq   79e99b <puttuple_common+0x16b>
    0.00 :	  79edb5:       0f 1f 00                nopl   (%rax)
         :	                                (state->memtupcount > state->bound * 2 ||
         :	                                 (state->memtupcount > state->bound && LACKMEM(state))))
         :	                        {
         :	#ifdef TRACE_SORT
         :	                                if (trace_sort)
         :	                                        elog(LOG, "switching to bounded heapsort at %d tuples: %s",
    0.00 :	  79edb8:       ba d0 2e 8e 00          mov    $0x8e2ed0,%edx
    0.00 :	  79edbd:       be d7 04 00 00          mov    $0x4d7,%esi
    0.00 :	  79edc2:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79edc7:       e8 54 c6 fd ff          callq  77b420 <elog_start>
    0.00 :	  79edcc:       49 8d bc 24 48 01 00    lea    0x148(%r12),%rdi
    0.00 :	  79edd3:       00 
    0.00 :	  79edd4:       e8 b7 6c ff ff          callq  795a90 <pg_rusage_show>
    0.00 :	  79edd9:       41 8b 54 24 68          mov    0x68(%r12),%edx
    0.00 :	  79edde:       48 89 c1                mov    %rax,%rcx
    0.00 :	  79ede1:       be 88 2b 8e 00          mov    $0x8e2b88,%esi
    0.00 :	  79ede6:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  79edeb:       31 c0                   xor    %eax,%eax
    0.00 :	  79eded:       e8 3e c4 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79edf2:       e9 b6 fe ff ff          jmpq   79ecad <puttuple_common+0x47d>
    0.00 :	  79edf7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  79edfe:       00 00 
         :	        state->maxTapes = maxTapes;
         :	        state->tapeRange = maxTapes - 1;
         :
         :	#ifdef TRACE_SORT
         :	        if (trace_sort)
         :	                elog(LOG, "switching to external sort with %d tapes: %s",
    0.00 :	  79ee00:       ba ef 2e 8e 00          mov    $0x8e2eef,%edx
    0.00 :	  79ee05:       be 3c 07 00 00          mov    $0x73c,%esi
    0.00 :	  79ee0a:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79ee0f:       e8 0c c6 fd ff          callq  77b420 <elog_start>
    0.00 :	  79ee14:       49 8d bc 24 48 01 00    lea    0x148(%r12),%rdi
    0.00 :	  79ee1b:       00 
    0.00 :	  79ee1c:       e8 6f 6c ff ff          callq  795a90 <pg_rusage_show>
    0.00 :	  79ee21:       44 89 fa                mov    %r15d,%edx
    0.00 :	  79ee24:       48 89 c1                mov    %rax,%rcx
    0.00 :	  79ee27:       be b8 2b 8e 00          mov    $0x8e2bb8,%esi
    0.00 :	  79ee2c:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  79ee31:       31 c0                   xor    %eax,%eax
    0.00 :	  79ee33:       e8 f8 c3 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79ee38:       e9 3a fb ff ff          jmpq   79e977 <puttuple_common+0x147>
    0.00 :	  79ee3d:       0f 1f 00                nopl   (%rax)
         :	                 * really bad from happening.
         :	                 */
         :	                double          grow_ratio;
         :
         :	                grow_ratio = (double) state->allowedMem / (double) memNowUsed;
         :	                if (memtupsize * grow_ratio < INT_MAX)
    0.00 :	  79ee40:       f2 48 0f 2a c0          cvtsi2sd %rax,%xmm0
    0.00 :	  79ee45:       bb ff ff ff 7f          mov    $0x7fffffff,%ebx
    0.00 :	  79ee4a:       f2 48 0f 2a ce          cvtsi2sd %rsi,%xmm1
    0.00 :	  79ee4f:       f2 0f 5e c8             divsd  %xmm0,%xmm1
    0.00 :	  79ee53:       f2 0f 2a c1             cvtsi2sd %ecx,%xmm0
    0.00 :	  79ee57:       f2 0f 59 c8             mulsd  %xmm0,%xmm1
    0.00 :	  79ee5b:       66 0f 2e 0d b5 24 01    ucomisd 0x124b5(%rip),%xmm1        # 7b1318 <__func__.11700+0x18>
    0.00 :	  79ee62:       00 
    0.00 :	  79ee63:       73 06                   jae    79ee6b <puttuple_common+0x63b>
    0.00 :	  79ee65:       7a 04                   jp     79ee6b <puttuple_common+0x63b>
         :	                        newmemtupsize = (int) (memtupsize * grow_ratio);
    0.00 :	  79ee67:       f2 0f 2c d9             cvttsd2si %xmm1,%ebx
         :	                else
         :	                        newmemtupsize = INT_MAX;
         :
         :	                /* We won't make any further enlargement attempts */
         :	                state->growmemtuples = false;
    0.00 :	  79ee6b:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  79ee71:       e9 c6 fd ff ff          jmpq   79ec3c <puttuple_common+0x40c>
    0.00 :	  79ee76:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  79ee7d:       00 00 00 
         :	                if (memtupsize < INT_MAX / 2)
         :	                        newmemtupsize = memtupsize * 2;
         :	                else
         :	                {
         :	                        newmemtupsize = INT_MAX;
         :	                        state->growmemtuples = false;
    0.00 :	  79ee80:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  79ee86:       bb ff ff ff 7f          mov    $0x7fffffff,%ebx
    0.00 :	  79ee8b:       e9 ac fd ff ff          jmpq   79ec3c <puttuple_common+0x40c>
         :	         */
         :	        if (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))
         :	                goto noalloc;
         :
         :	        /* OK, do it */
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79ee90:       49 8b 7c 24 60          mov    0x60(%r12),%rdi
    0.00 :	  79ee95:       e8 f6 9b ff ff          callq  798a90 <GetMemoryChunkSpace>
         :	        state->memtupsize = newmemtupsize;
         :	        state->memtuples = (SortTuple *)
    0.00 :	  79ee9a:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  79ee9d:       49 8b 7c 24 60          mov    0x60(%r12),%rdi
         :	         */
         :	        if (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))
         :	                goto noalloc;
         :
         :	        /* OK, do it */
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79eea2:       4c 01 f0                add    %r14,%rax
         :	        state->memtupsize = newmemtupsize;
         :	        state->memtuples = (SortTuple *)
    0.00 :	  79eea5:       48 8d 34 76             lea    (%rsi,%rsi,2),%rsi
         :	        if (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))
         :	                goto noalloc;
         :
         :	        /* OK, do it */
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
         :	        state->memtupsize = newmemtupsize;
    0.00 :	  79eea9:       41 89 5c 24 6c          mov    %ebx,0x6c(%r12)
         :	         */
         :	        if (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))
         :	                goto noalloc;
         :
         :	        /* OK, do it */
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79eeae:       49 89 44 24 10          mov    %rax,0x10(%r12)
         :	        state->memtupsize = newmemtupsize;
         :	        state->memtuples = (SortTuple *)
    0.00 :	  79eeb3:       48 c1 e6 03             shl    $0x3,%rsi
    0.00 :	  79eeb7:       e8 74 9d ff ff          callq  798c30 <repalloc_huge>
         :	                repalloc_huge(state->memtuples,
         :	                                          state->memtupsize * sizeof(SortTuple));
         :	        USEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79eebc:       49 8b 5c 24 10          mov    0x10(%r12),%rbx
         :	                goto noalloc;
         :
         :	        /* OK, do it */
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
         :	        state->memtupsize = newmemtupsize;
         :	        state->memtuples = (SortTuple *)
    0.00 :	  79eec1:       48 89 c7                mov    %rax,%rdi
    0.00 :	  79eec4:       49 89 44 24 60          mov    %rax,0x60(%r12)
         :	                repalloc_huge(state->memtuples,
         :	                                          state->memtupsize * sizeof(SortTuple));
         :	        USEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79eec9:       e8 c2 9b ff ff          callq  798a90 <GetMemoryChunkSpace>
    0.00 :	  79eece:       48 29 c3                sub    %rax,%rbx
         :	        if (LACKMEM(state))
    0.00 :	  79eed1:       48 85 db                test   %rbx,%rbx
         :	        FREEMEM(state, GetMemoryChunkSpace(state->memtuples));
         :	        state->memtupsize = newmemtupsize;
         :	        state->memtuples = (SortTuple *)
         :	                repalloc_huge(state->memtuples,
         :	                                          state->memtupsize * sizeof(SortTuple));
         :	        USEMEM(state, GetMemoryChunkSpace(state->memtuples));
    0.00 :	  79eed4:       49 89 5c 24 10          mov    %rbx,0x10(%r12)
         :	        if (LACKMEM(state))
    0.00 :	  79eed9:       78 1a                   js     79eef5 <puttuple_common+0x6c5>
    0.00 :	  79eedb:       41 8b 7c 24 68          mov    0x68(%r12),%edi
    0.00 :	  79eee0:       e9 c0 f9 ff ff          jmpq   79e8a5 <puttuple_common+0x75>
         :	         * don't rely on that at this distance.)
         :	         */
         :	        if ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))
         :	        {
         :	                newmemtupsize = (int) (MaxAllocHugeSize / sizeof(SortTuple));
         :	                state->growmemtuples = false;   /* can't grow any more */
    0.00 :	  79eee5:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  79eeeb:       bb 55 55 55 55          mov    $0x55555555,%ebx
    0.00 :	  79eef0:       e9 53 fd ff ff          jmpq   79ec48 <puttuple_common+0x418>
         :	        state->memtuples = (SortTuple *)
         :	                repalloc_huge(state->memtuples,
         :	                                          state->memtupsize * sizeof(SortTuple));
         :	        USEMEM(state, GetMemoryChunkSpace(state->memtuples));
         :	        if (LACKMEM(state))
         :	                elog(ERROR, "unexpected out-of-memory situation during sort");
    0.00 :	  79eef5:       ba e0 2e 8e 00          mov    $0x8e2ee0,%edx
    0.00 :	  79eefa:       be 3b 04 00 00          mov    $0x43b,%esi
    0.00 :	  79eeff:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79ef04:       e8 17 c5 fd ff          callq  77b420 <elog_start>
    0.00 :	  79ef09:       be 58 2b 8e 00          mov    $0x8e2b58,%esi
    0.00 :	  79ef0e:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79ef13:       31 c0                   xor    %eax,%eax
    0.00 :	  79ef15:       e8 16 c3 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79ef1a:       e8 b1 a5 cc ff          callq  4694d0 <abort@plt>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   50.00 ??:0
   50.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000084750 <memcpy>:
 ??:0
   50.00 :	   84750:       48 83 fa 20             cmp    $0x20,%rdx
    0.00 :	   84754:       48 89 f8                mov    %rdi,%rax
    0.00 :	   84757:       73 77                   jae    847d0 <memcpy+0x80>
    0.00 :	   84759:       f6 c2 01                test   $0x1,%dl
    0.00 :	   8475c:       74 0b                   je     84769 <memcpy+0x19>
    0.00 :	   8475e:       0f b6 0e                movzbl (%rsi),%ecx
    0.00 :	   84761:       88 0f                   mov    %cl,(%rdi)
    0.00 :	   84763:       48 ff c6                inc    %rsi
    0.00 :	   84766:       48 ff c7                inc    %rdi
    0.00 :	   84769:       f6 c2 02                test   $0x2,%dl
    0.00 :	   8476c:       74 12                   je     84780 <memcpy+0x30>
    0.00 :	   8476e:       0f b7 0e                movzwl (%rsi),%ecx
   50.00 :	   84771:       66 89 0f                mov    %cx,(%rdi)
    0.00 :	   84774:       48 83 c6 02             add    $0x2,%rsi
    0.00 :	   84778:       48 83 c7 02             add    $0x2,%rdi
    0.00 :	   8477c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   84780:       f6 c2 04                test   $0x4,%dl
    0.00 :	   84783:       74 0c                   je     84791 <memcpy+0x41>
    0.00 :	   84785:       8b 0e                   mov    (%rsi),%ecx
    0.00 :	   84787:       89 0f                   mov    %ecx,(%rdi)
    0.00 :	   84789:       48 83 c6 04             add    $0x4,%rsi
    0.00 :	   8478d:       48 83 c7 04             add    $0x4,%rdi
    0.00 :	   84791:       f6 c2 08                test   $0x8,%dl
    0.00 :	   84794:       74 0e                   je     847a4 <memcpy+0x54>
    0.00 :	   84796:       48 8b 0e                mov    (%rsi),%rcx
    0.00 :	   84799:       48 89 0f                mov    %rcx,(%rdi)
    0.00 :	   8479c:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	   847a0:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	   847a4:       81 e2 f0 00 00 00       and    $0xf0,%edx
    0.00 :	   847aa:       74 1f                   je     847cb <memcpy+0x7b>
    0.00 :	   847ac:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   847b0:       48 8b 0e                mov    (%rsi),%rcx
    0.00 :	   847b3:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   847b7:       48 89 0f                mov    %rcx,(%rdi)
    0.00 :	   847ba:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   847be:       83 ea 10                sub    $0x10,%edx
    0.00 :	   847c1:       48 8d 76 10             lea    0x10(%rsi),%rsi
    0.00 :	   847c5:       48 8d 7f 10             lea    0x10(%rdi),%rdi
    0.00 :	   847c9:       75 e5                   jne    847b0 <memcpy+0x60>
    0.00 :	   847cb:       f3 c3                   repz retq 
    0.00 :	   847cd:       0f 1f 00                nopl   (%rax)
    0.00 :	   847d0:       48 89 44 24 f8          mov    %rax,-0x8(%rsp)
    0.00 :	   847d5:       89 f1                   mov    %esi,%ecx
    0.00 :	   847d7:       83 e1 07                and    $0x7,%ecx
    0.00 :	   847da:       74 34                   je     84810 <memcpy+0xc0>
    0.00 :	   847dc:       48 8d 54 11 f8          lea    -0x8(%rcx,%rdx,1),%rdx
    0.00 :	   847e1:       83 e9 08                sub    $0x8,%ecx
    0.00 :	   847e4:       66 66 66 2e 0f 1f 84    data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   847eb:       00 00 00 00 00 
    0.00 :	   847f0:       0f b6 06                movzbl (%rsi),%eax
    0.00 :	   847f3:       88 07                   mov    %al,(%rdi)
    0.00 :	   847f5:       ff c1                   inc    %ecx
    0.00 :	   847f7:       48 8d 76 01             lea    0x1(%rsi),%rsi
    0.00 :	   847fb:       48 8d 7f 01             lea    0x1(%rdi),%rdi
    0.00 :	   847ff:       75 ef                   jne    847f0 <memcpy+0xa0>
    0.00 :	   84801:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   84808:       0f 1f 84 00 00 00 00 
    0.00 :	   8480f:       00 
    0.00 :	   84810:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	   84817:       77 77                   ja     84890 <memcpy+0x140>
    0.00 :	   84819:       89 d1                   mov    %edx,%ecx
    0.00 :	   8481b:       c1 e9 05                shr    $0x5,%ecx
    0.00 :	   8481e:       74 60                   je     84880 <memcpy+0x130>
    0.00 :	   84820:       ff c9                   dec    %ecx
    0.00 :	   84822:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84825:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84829:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8482d:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84831:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84834:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   84838:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8483c:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84840:       48 8d 76 20             lea    0x20(%rsi),%rsi
    0.00 :	   84844:       48 8d 7f 20             lea    0x20(%rdi),%rdi
    0.00 :	   84848:       74 36                   je     84880 <memcpy+0x130>
    0.00 :	   8484a:       ff c9                   dec    %ecx
    0.00 :	   8484c:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   8484f:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84853:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84857:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   8485b:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   8485e:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   84862:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84866:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8486a:       48 8d 76 20             lea    0x20(%rsi),%rsi
    0.00 :	   8486e:       48 8d 7f 20             lea    0x20(%rdi),%rdi
    0.00 :	   84872:       75 ac                   jne    84820 <memcpy+0xd0>
    0.00 :	   84874:       66 66 66 2e 0f 1f 84    data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   8487b:       00 00 00 00 00 
    0.00 :	   84880:       83 e2 1f                and    $0x1f,%edx
    0.00 :	   84883:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84888:       0f 85 cb fe ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   8488e:       f3 c3                   repz retq 
    0.00 :	   84890:       4c 8b 1d 79 d8 2e 00    mov    0x2ed879(%rip),%r11        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	   84897:       49 39 d3                cmp    %rdx,%r11
    0.00 :	   8489a:       4c 0f 47 da             cmova  %rdx,%r11
    0.00 :	   8489e:       4c 89 d9                mov    %r11,%rcx
    0.00 :	   848a1:       49 83 e3 f8             and    $0xfffffffffffffff8,%r11
    0.00 :	   848a5:       48 c1 e9 03             shr    $0x3,%rcx
    0.00 :	   848a9:       74 05                   je     848b0 <memcpy+0x160>
    0.00 :	   848ab:       f3 48 a5                rep movsq %ds:(%rsi),%es:(%rdi)
    0.00 :	   848ae:       66 90                   xchg   %ax,%ax
    0.00 :	   848b0:       4c 29 da                sub    %r11,%rdx
    0.00 :	   848b3:       48 f7 c2 f8 ff ff ff    test   $0xfffffffffffffff8,%rdx
    0.00 :	   848ba:       75 14                   jne    848d0 <memcpy+0x180>
    0.00 :	   848bc:       83 e2 07                and    $0x7,%edx
    0.00 :	   848bf:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   848c4:       0f 85 8f fe ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   848ca:       f3 c3                   repz retq 
    0.00 :	   848cc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   848d0:       4c 8b 05 59 d8 2e 00    mov    0x2ed859(%rip),%r8        # 372130 <__x86_64_shared_cache_size_half>
    0.00 :	   848d7:       49 39 d0                cmp    %rdx,%r8
    0.00 :	   848da:       4c 0f 47 c2             cmova  %rdx,%r8
    0.00 :	   848de:       4c 89 c1                mov    %r8,%rcx
    0.00 :	   848e1:       49 83 e0 c0             and    $0xffffffffffffffc0,%r8
    0.00 :	   848e5:       48 c1 e9 06             shr    $0x6,%rcx
    0.00 :	   848e9:       0f 84 ab 01 00 00       je     84a9a <memcpy+0x34a>
    0.00 :	   848ef:       4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
    0.00 :	   848f4:       4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
    0.00 :	   848f9:       4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
    0.00 :	   848fe:       48 89 5c 24 d8          mov    %rbx,-0x28(%rsp)
    0.00 :	   84903:       83 3d 06 2b 2f 00 00    cmpl   $0x0,0x2f2b06(%rip)        # 377410 <__x86_64_prefetchw>
    0.00 :	   8490a:       0f 84 c0 00 00 00       je     849d0 <memcpy+0x280>
    0.00 :	   84910:       48 ff c9                dec    %rcx
    0.00 :	   84913:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84916:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   8491a:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8491e:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84922:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84926:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   8492a:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   8492e:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84932:       0f 18 8e 80 03 00 00    prefetcht0 0x380(%rsi)
    0.00 :	   84939:       0f 18 8e c0 03 00 00    prefetcht0 0x3c0(%rsi)
    0.00 :	   84940:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84943:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84947:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8494b:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8494f:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84953:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84957:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   8495b:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   8495f:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84963:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84967:       0f 84 19 01 00 00       je     84a86 <memcpy+0x336>
    0.00 :	   8496d:       48 ff c9                dec    %rcx
    0.00 :	   84970:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84973:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   84977:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8497b:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   8497f:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84983:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84987:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   8498b:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   8498f:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84992:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84996:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8499a:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8499e:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   849a2:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   849a6:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   849aa:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   849ae:       0f 0d 8f 40 03 00 00    prefetchw 0x340(%rdi)
    0.00 :	   849b5:       0f 0d 8f 80 03 00 00    prefetchw 0x380(%rdi)
    0.00 :	   849bc:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   849c0:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   849c4:       0f 85 46 ff ff ff       jne    84910 <memcpy+0x1c0>
    0.00 :	   849ca:       e9 b7 00 00 00          jmpq   84a86 <memcpy+0x336>
    0.00 :	   849cf:       90                      nop
    0.00 :	   849d0:       48 ff c9                dec    %rcx
    0.00 :	   849d3:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   849d6:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   849da:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   849de:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   849e2:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   849e6:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   849ea:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   849ee:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   849f2:       0f 18 8e 80 03 00 00    prefetcht0 0x380(%rsi)
    0.00 :	   849f9:       0f 18 8e c0 03 00 00    prefetcht0 0x3c0(%rsi)
    0.00 :	   84a00:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84a03:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84a07:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84a0b:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84a0f:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84a13:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84a17:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   84a1b:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   84a1f:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84a23:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84a27:       74 5d                   je     84a86 <memcpy+0x336>
    0.00 :	   84a29:       48 ff c9                dec    %rcx
    0.00 :	   84a2c:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84a2f:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   84a33:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84a37:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84a3b:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84a3f:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84a43:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   84a47:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84a4b:       0f 18 8f 40 03 00 00    prefetcht0 0x340(%rdi)
    0.00 :	   84a52:       0f 18 8f 80 03 00 00    prefetcht0 0x380(%rdi)
    0.00 :	   84a59:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84a5c:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84a60:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84a64:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84a68:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84a6c:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84a70:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   84a74:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   84a78:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84a7c:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84a80:       0f 85 4a ff ff ff       jne    849d0 <memcpy+0x280>
    0.00 :	   84a86:       48 8b 5c 24 d8          mov    -0x28(%rsp),%rbx
    0.00 :	   84a8b:       4c 8b 64 24 e0          mov    -0x20(%rsp),%r12
    0.00 :	   84a90:       4c 8b 6c 24 e8          mov    -0x18(%rsp),%r13
    0.00 :	   84a95:       4c 8b 74 24 f0          mov    -0x10(%rsp),%r14
    0.00 :	   84a9a:       4c 29 c2                sub    %r8,%rdx
    0.00 :	   84a9d:       48 f7 c2 c0 ff ff ff    test   $0xffffffffffffffc0,%rdx
    0.00 :	   84aa4:       75 1a                   jne    84ac0 <memcpy+0x370>
    0.00 :	   84aa6:       83 e2 3f                and    $0x3f,%edx
    0.00 :	   84aa9:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84aae:       0f 85 a5 fc ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   84ab4:       f3 c3                   repz retq 
    0.00 :	   84ab6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	   84abd:       00 00 00 
    0.00 :	   84ac0:       48 89 d1                mov    %rdx,%rcx
    0.00 :	   84ac3:       48 c1 e9 07             shr    $0x7,%rcx
    0.00 :	   84ac7:       0f 84 d8 00 00 00       je     84ba5 <memcpy+0x455>
    0.00 :	   84acd:       4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
    0.00 :	   84ad2:       4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
    0.00 :	   84ad7:       4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
    0.00 :	   84adc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   84ae0:       0f 18 86 00 03 00 00    prefetchnta 0x300(%rsi)
    0.00 :	   84ae7:       0f 18 86 40 03 00 00    prefetchnta 0x340(%rsi)
    0.00 :	   84aee:       48 ff c9                dec    %rcx
    0.00 :	   84af1:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84af4:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84af8:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84afc:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84b00:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84b04:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84b08:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   84b0c:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84b10:       48 0f c3 07             movnti %rax,(%rdi)
    0.00 :	   84b14:       4c 0f c3 47 08          movnti %r8,0x8(%rdi)
    0.00 :	   84b19:       4c 0f c3 4f 10          movnti %r9,0x10(%rdi)
    0.00 :	   84b1e:       4c 0f c3 57 18          movnti %r10,0x18(%rdi)
    0.00 :	   84b23:       4c 0f c3 5f 20          movnti %r11,0x20(%rdi)
    0.00 :	   84b28:       4c 0f c3 67 28          movnti %r12,0x28(%rdi)
    0.00 :	   84b2d:       4c 0f c3 6f 30          movnti %r13,0x30(%rdi)
    0.00 :	   84b32:       4c 0f c3 77 38          movnti %r14,0x38(%rdi)
    0.00 :	   84b37:       48 8b 46 40             mov    0x40(%rsi),%rax
    0.00 :	   84b3b:       4c 8b 46 48             mov    0x48(%rsi),%r8
    0.00 :	   84b3f:       4c 8b 4e 50             mov    0x50(%rsi),%r9
    0.00 :	   84b43:       4c 8b 56 58             mov    0x58(%rsi),%r10
    0.00 :	   84b47:       4c 8b 5e 60             mov    0x60(%rsi),%r11
    0.00 :	   84b4b:       4c 8b 66 68             mov    0x68(%rsi),%r12
    0.00 :	   84b4f:       4c 8b 6e 70             mov    0x70(%rsi),%r13
    0.00 :	   84b53:       4c 8b 76 78             mov    0x78(%rsi),%r14
    0.00 :	   84b57:       48 0f c3 47 40          movnti %rax,0x40(%rdi)
    0.00 :	   84b5c:       4c 0f c3 47 48          movnti %r8,0x48(%rdi)
    0.00 :	   84b61:       4c 0f c3 4f 50          movnti %r9,0x50(%rdi)
    0.00 :	   84b66:       4c 0f c3 57 58          movnti %r10,0x58(%rdi)
    0.00 :	   84b6b:       4c 0f c3 5f 60          movnti %r11,0x60(%rdi)
    0.00 :	   84b70:       4c 0f c3 67 68          movnti %r12,0x68(%rdi)
    0.00 :	   84b75:       4c 0f c3 6f 70          movnti %r13,0x70(%rdi)
    0.00 :	   84b7a:       4c 0f c3 77 78          movnti %r14,0x78(%rdi)
    0.00 :	   84b7f:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	   84b86:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   84b8d:       0f 85 4d ff ff ff       jne    84ae0 <memcpy+0x390>
    0.00 :	   84b93:       0f ae f8                sfence 
    0.00 :	   84b96:       4c 8b 64 24 e0          mov    -0x20(%rsp),%r12
    0.00 :	   84b9b:       4c 8b 6c 24 e8          mov    -0x18(%rsp),%r13
    0.00 :	   84ba0:       4c 8b 74 24 f0          mov    -0x10(%rsp),%r14
    0.00 :	   84ba5:       83 e2 7f                and    $0x7f,%edx
    0.00 :	   84ba8:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84bad:       0f 85 a6 fb ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   84bb3:       f3 c3                   repz retq 

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/ixgbe/ixgbe.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/ixgbe/ixgbe.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000088b0 <ixgbe_clean_tx_irq>:
         :	 * @q_vector: structure containing interrupt and ring information
         :	 * @tx_ring: tx ring to clean
         :	 **/
         :	static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
         :	                               struct ixgbe_ring *tx_ring)
         :	{
    0.00 :	    88b0:       41 57                   push   %r15
    0.00 :	    88b2:       41 56                   push   %r14
    0.00 :	    88b4:       49 89 f6                mov    %rsi,%r14
    0.00 :	    88b7:       41 55                   push   %r13
    0.00 :	    88b9:       41 54                   push   %r12
    0.00 :	    88bb:       55                      push   %rbp
    0.00 :	    88bc:       53                      push   %rbx
    0.00 :	    88bd:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	    88c1:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
         :	        struct ixgbe_adapter *adapter = q_vector->adapter;
    0.00 :	    88c6:       4c 8b 3f                mov    (%rdi),%r15
         :	        struct ixgbe_tx_buffer *tx_buffer;
         :	        union ixgbe_adv_tx_desc *tx_desc;
         :	        unsigned int total_bytes = 0, total_packets = 0;
         :	        unsigned int budget = q_vector->tx.work_limit;
    0.00 :	    88c9:       0f b7 4f 38             movzwl 0x38(%rdi),%ecx
         :	        unsigned int i = tx_ring->next_to_clean;
    0.00 :	    88cd:       0f b7 56 52             movzwl 0x52(%rsi),%edx
         :	        return oldbit;
         :	}
         :
         :	static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
         :	{
         :	        return ((1UL << (nr % BITS_PER_LONG)) &
    0.00 :	    88d1:       49 8b 87 10 02 00 00    mov    0x210(%r15),%rax
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
    0.00 :	    88d8:       a8 04                   test   $0x4,%al
    0.00 :	    88da:       0f 85 88 02 00 00       jne    8b68 <ixgbe_clean_tx_irq+0x2b8>
         :	        struct ixgbe_adapter *adapter = q_vector->adapter;
         :	        struct ixgbe_tx_buffer *tx_buffer;
         :	        union ixgbe_adv_tx_desc *tx_desc;
         :	        unsigned int total_bytes = 0, total_packets = 0;
         :	        unsigned int budget = q_vector->tx.work_limit;
         :	        unsigned int i = tx_ring->next_to_clean;
    0.00 :	    88e0:       0f b7 c2                movzwl %dx,%eax
         :	{
         :	        struct ixgbe_adapter *adapter = q_vector->adapter;
         :	        struct ixgbe_tx_buffer *tx_buffer;
         :	        union ixgbe_adv_tx_desc *tx_desc;
         :	        unsigned int total_bytes = 0, total_packets = 0;
         :	        unsigned int budget = q_vector->tx.work_limit;
    0.00 :	    88e3:       0f b7 c9                movzwl %cx,%ecx
         :	        unsigned int i = tx_ring->next_to_clean;
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
         :	                return true;
         :
         :	        tx_buffer = &tx_ring->tx_buffer_info[i];
    0.00 :	    88e6:       89 c2                   mov    %eax,%edx
         :	{
         :	        struct ixgbe_adapter *adapter = q_vector->adapter;
         :	        struct ixgbe_tx_buffer *tx_buffer;
         :	        union ixgbe_adv_tx_desc *tx_desc;
         :	        unsigned int total_bytes = 0, total_packets = 0;
         :	        unsigned int budget = q_vector->tx.work_limit;
    0.00 :	    88e8:       89 4c 24 24             mov    %ecx,0x24(%rsp)
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
         :	                return true;
         :
         :	        tx_buffer = &tx_ring->tx_buffer_info[i];
         :	        tx_desc = IXGBE_TX_DESC(tx_ring, i);
         :	        i -= tx_ring->count;
    0.00 :	    88ec:       41 89 c4                mov    %eax,%r12d
         :	        unsigned int i = tx_ring->next_to_clean;
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
         :	                return true;
         :
         :	        tx_buffer = &tx_ring->tx_buffer_info[i];
    0.00 :	    88ef:       48 8d 1c 52             lea    (%rdx,%rdx,2),%rbx
         :	        tx_desc = IXGBE_TX_DESC(tx_ring, i);
    0.00 :	    88f3:       48 89 d5                mov    %rdx,%rbp
         :	        i -= tx_ring->count;
    0.00 :	    88f6:       0f b7 56 4c             movzwl 0x4c(%rsi),%edx
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
         :	                return true;
         :
         :	        tx_buffer = &tx_ring->tx_buffer_info[i];
         :	        tx_desc = IXGBE_TX_DESC(tx_ring, i);
    0.00 :	    88fa:       48 c1 e5 04             shl    $0x4,%rbp
    0.00 :	    88fe:       48 03 6e 20             add    0x20(%rsi),%rbp
         :	        unsigned int i = tx_ring->next_to_clean;
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state))
         :	                return true;
         :
         :	        tx_buffer = &tx_ring->tx_buffer_info[i];
    0.00 :	    8902:       48 c1 e3 04             shl    $0x4,%rbx
    0.00 :	    8906:       48 03 5e 28             add    0x28(%rsi),%rbx
         :	        tx_desc = IXGBE_TX_DESC(tx_ring, i);
         :	        i -= tx_ring->count;
    0.00 :	    890a:       c7 44 24 1c 00 00 00    movl   $0x0,0x1c(%rsp)
    0.00 :	    8911:       00 
    0.00 :	    8912:       c7 44 24 20 00 00 00    movl   $0x0,0x20(%rsp)
    0.00 :	    8919:       00 
    0.00 :	    891a:       41 29 d4                sub    %edx,%r12d
    0.00 :	    891d:       0f 1f 00                nopl   (%rax)
         :
         :	        do {
         :	                union ixgbe_adv_tx_desc *eop_desc = tx_buffer->next_to_watch;
    0.00 :	    8920:       4c 8b 2b                mov    (%rbx),%r13
         :
         :	                /* if next_to_watch is not set then there is no work pending */
         :	                if (!eop_desc)
    0.00 :	    8923:       4d 85 ed                test   %r13,%r13
    0.00 :	    8926:       0f 84 f5 00 00 00       je     8a21 <ixgbe_clean_tx_irq+0x171>
         :	                        break;
         :
         :	                /* prevent any other reads prior to eop_desc */
         :	                rmb();
    0.00 :	    892c:       0f ae e8                lfence 
         :
         :	                /* if DD is not set pending work has not been completed */
         :	                if (!(eop_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)))
    0.00 :	    892f:       41 f6 45 0c 01          testb  $0x1,0xc(%r13)
    0.00 :	    8934:       0f 84 e7 00 00 00       je     8a21 <ixgbe_clean_tx_irq+0x171>
         :
         :	                /* clear next_to_watch to prevent false hangs */
         :	                tx_buffer->next_to_watch = NULL;
         :
         :	                /* update the statistics for this packet */
         :	                total_bytes += tx_buffer->bytecount;
    0.00 :	    893a:       8b 43 18                mov    0x18(%rbx),%eax
         :	                /* if DD is not set pending work has not been completed */
         :	                if (!(eop_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)))
         :	                        break;
         :
         :	                /* clear next_to_watch to prevent false hangs */
         :	                tx_buffer->next_to_watch = NULL;
    0.00 :	    893d:       48 c7 03 00 00 00 00    movq   $0x0,(%rbx)
         :
         :	                /* update the statistics for this packet */
         :	                total_bytes += tx_buffer->bytecount;
    0.00 :	    8944:       01 44 24 1c             add    %eax,0x1c(%rsp)
         :	                total_packets += tx_buffer->gso_segs;
    0.00 :	    8948:       0f b7 43 1c             movzwl 0x1c(%rbx),%eax
    0.00 :	    894c:       01 44 24 20             add    %eax,0x20(%rsp)
         :	                                              tx_buffer->skb);
         :
         :
         :	#endif
         :	                /* free the skb */
         :	                dev_kfree_skb_any(tx_buffer->skb);
    0.00 :	    8950:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	    8954:       e8 00 00 00 00          callq  8959 <ixgbe_clean_tx_irq+0xa9>
         :
         :	                /* unmap skb header data */
         :	                dma_unmap_single(tx_ring->dev,
    0.00 :	    8959:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	    895d:       8b 53 28                mov    0x28(%rbx),%edx
    0.00 :	    8960:       48 8b 73 20             mov    0x20(%rbx),%rsi
         :	static inline struct dma_map_ops *get_dma_ops(struct device *dev)
         :	{
         :	#ifdef CONFIG_X86_32
         :	        return dma_ops;
         :	#else
         :	        if (unlikely(!dev) || !dev->archdata.dma_ops)
    0.00 :	    8964:       48 85 ff                test   %rdi,%rdi
    0.00 :	    8967:       0f 84 83 01 00 00       je     8af0 <ixgbe_clean_tx_irq+0x240>
    0.00 :	    896d:       48 8b 87 00 02 00 00    mov    0x200(%rdi),%rax
    0.00 :	    8974:       48 85 c0                test   %rax,%rax
    0.00 :	    8977:       0f 84 73 01 00 00       je     8af0 <ixgbe_clean_tx_irq+0x240>
         :	                                          struct dma_attrs *attrs)
         :	{
         :	        struct dma_map_ops *ops = get_dma_ops(dev);
         :
         :	        BUG_ON(!valid_dma_direction(dir));
         :	        if (ops->unmap_page)
    0.00 :	    897d:       48 8b 40 18             mov    0x18(%rax),%rax
    0.00 :	    8981:       48 85 c0                test   %rax,%rax
    0.00 :	    8984:       74 0c                   je     8992 <ixgbe_clean_tx_irq+0xe2>
         :	                ops->unmap_page(dev, addr, size, dir, attrs);
    0.00 :	    8986:       89 d2                   mov    %edx,%edx
    0.00 :	    8988:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    898b:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    8990:       ff d0                   callq  *%rax
         :	                                 dma_unmap_addr(tx_buffer, dma),
         :	                                 dma_unmap_len(tx_buffer, len),
         :	                                 DMA_TO_DEVICE);
         :
         :	                /* clear tx_buffer data */
         :	                tx_buffer->skb = NULL;
    0.00 :	    8992:       48 c7 43 10 00 00 00    movq   $0x0,0x10(%rbx)
    0.00 :	    8999:       00 
         :	                dma_unmap_len_set(tx_buffer, len, 0);
    0.00 :	    899a:       c7 43 28 00 00 00 00    movl   $0x0,0x28(%rbx)
         :
         :	                /* unmap remaining buffers */
         :	                while (tx_desc != eop_desc) {
    0.00 :	    89a1:       4c 39 ed                cmp    %r13,%rbp
    0.00 :	    89a4:       74 5a                   je     8a00 <ixgbe_clean_tx_irq+0x150>
         :	                        tx_buffer++;
         :	                        tx_desc++;
         :	                        i++;
         :	                        if (unlikely(!i)) {
    0.00 :	    89a6:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	    89aa:       0f 84 4c 01 00 00       je     8afc <ixgbe_clean_tx_irq+0x24c>
         :	                tx_buffer->skb = NULL;
         :	                dma_unmap_len_set(tx_buffer, len, 0);
         :
         :	                /* unmap remaining buffers */
         :	                while (tx_desc != eop_desc) {
         :	                        tx_buffer++;
    0.00 :	    89b0:       48 83 c3 30             add    $0x30,%rbx
         :	                        tx_desc++;
    0.00 :	    89b4:       48 83 c5 10             add    $0x10,%rbp
         :	                                tx_buffer = tx_ring->tx_buffer_info;
         :	                                tx_desc = IXGBE_TX_DESC(tx_ring, 0);
         :	                        }
         :
         :	                        /* unmap any remaining paged data */
         :	                        if (dma_unmap_len(tx_buffer, len)) {
    0.00 :	    89b8:       8b 53 28                mov    0x28(%rbx),%edx
    0.00 :	    89bb:       85 d2                   test   %edx,%edx
    0.00 :	    89bd:       74 e2                   je     89a1 <ixgbe_clean_tx_irq+0xf1>
         :	                                dma_unmap_page(tx_ring->dev,
    0.00 :	    89bf:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	    89c3:       48 8b 73 20             mov    0x20(%rbx),%rsi
    0.00 :	    89c7:       48 85 ff                test   %rdi,%rdi
    0.00 :	    89ca:       0f 84 10 01 00 00       je     8ae0 <ixgbe_clean_tx_irq+0x230>
    0.00 :	    89d0:       48 8b 87 00 02 00 00    mov    0x200(%rdi),%rax
    0.00 :	    89d7:       48 85 c0                test   %rax,%rax
    0.00 :	    89da:       0f 84 00 01 00 00       je     8ae0 <ixgbe_clean_tx_irq+0x230>
         :	                                  size_t size, enum dma_data_direction dir)
         :	{
         :	        struct dma_map_ops *ops = get_dma_ops(dev);
         :
         :	        BUG_ON(!valid_dma_direction(dir));
         :	        if (ops->unmap_page)
    0.00 :	    89e0:       48 8b 40 18             mov    0x18(%rax),%rax
    0.00 :	    89e4:       48 85 c0                test   %rax,%rax
    0.00 :	    89e7:       74 b1                   je     899a <ixgbe_clean_tx_irq+0xea>
         :	                ops->unmap_page(dev, addr, size, dir, NULL);
    0.00 :	    89e9:       89 d2                   mov    %edx,%edx
    0.00 :	    89eb:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    89ee:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    89f3:       ff d0                   callq  *%rax
    0.00 :	    89f5:       eb a3                   jmp    899a <ixgbe_clean_tx_irq+0xea>
    0.00 :	    89f7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	    89fe:       00 00 
         :
         :	                /* move us one more past the eop_desc for start of next pkt */
         :	                tx_buffer++;
         :	                tx_desc++;
         :	                i++;
         :	                if (unlikely(!i)) {
    0.00 :	    8a00:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	    8a04:       0f 84 10 02 00 00       je     8c1a <ixgbe_clean_tx_irq+0x36a>
         :	                                dma_unmap_len_set(tx_buffer, len, 0);
         :	                        }
         :	                }
         :
         :	                /* move us one more past the eop_desc for start of next pkt */
         :	                tx_buffer++;
    0.00 :	    8a0a:       48 83 c3 30             add    $0x30,%rbx
         :	                tx_desc++;
    0.00 :	    8a0e:       48 83 c5 10             add    $0x10,%rbp
         :	 * It's not worth to care about 3dnow prefetches for the K6
         :	 * because they are microcoded there and very slow.
         :	 */
         :	static inline void prefetch(const void *x)
         :	{
         :	        alternative_input(BASE_PREFETCH,
    0.00 :	    8a12:       0f 18 4d 00             prefetcht0 0x0(%rbp)
         :	                /* issue prefetch for next Tx descriptor */
         :	                prefetch(tx_desc);
         :
         :	                /* update budget accounting */
         :	                budget--;
         :	        } while (likely(budget));
    0.00 :	    8a16:       83 6c 24 24 01          subl   $0x1,0x24(%rsp)
    0.00 :	    8a1b:       0f 85 ff fe ff ff       jne    8920 <ixgbe_clean_tx_irq+0x70>
         :
         :	        i += tx_ring->count;
    0.00 :	    8a21:       41 0f b7 46 4c          movzwl 0x4c(%r14),%eax
         :	        tx_ring->next_to_clean = i;
         :	        tx_ring->stats.bytes += total_bytes;
         :	        tx_ring->stats.packets += total_packets;
         :	        q_vector->tx.total_bytes += total_bytes;
    0.00 :	    8a26:       48 8b 54 24 10          mov    0x10(%rsp),%rdx
         :	        q_vector->tx.total_packets += total_packets;
         :
         :	        if (check_for_tx_hang(tx_ring) && ixgbe_check_tx_hang(tx_ring)) {
    0.00 :	    8a2b:       49 8d 4e 30             lea    0x30(%r14),%rcx
         :
         :	                /* update budget accounting */
         :	                budget--;
         :	        } while (likely(budget));
         :
         :	        i += tx_ring->count;
    0.00 :	    8a2f:       41 8d 1c 04             lea    (%r12,%rax,1),%ebx
         :	        tx_ring->next_to_clean = i;
         :	        tx_ring->stats.bytes += total_bytes;
    0.00 :	    8a33:       8b 44 24 1c             mov    0x1c(%rsp),%eax
    0.00 :	    8a37:       49 01 46 60             add    %rax,0x60(%r14)
         :	        tx_ring->stats.packets += total_packets;
    0.00 :	    8a3b:       8b 44 24 20             mov    0x20(%rsp),%eax
    0.00 :	    8a3f:       49 01 46 58             add    %rax,0x58(%r14)
         :	                /* update budget accounting */
         :	                budget--;
         :	        } while (likely(budget));
         :
         :	        i += tx_ring->count;
         :	        tx_ring->next_to_clean = i;
    0.00 :	    8a43:       66 41 89 5e 52          mov    %bx,0x52(%r14)
         :	        tx_ring->stats.bytes += total_bytes;
         :	        tx_ring->stats.packets += total_packets;
         :	        q_vector->tx.total_bytes += total_bytes;
    0.00 :	    8a48:       8b 44 24 1c             mov    0x1c(%rsp),%eax
    0.00 :	    8a4c:       01 42 30                add    %eax,0x30(%rdx)
         :	        q_vector->tx.total_packets += total_packets;
    0.00 :	    8a4f:       8b 44 24 20             mov    0x20(%rsp),%eax
    0.00 :	    8a53:       01 42 34                add    %eax,0x34(%rdx)
    0.00 :	    8a56:       49 8b 46 30             mov    0x30(%r14),%rax
         :
         :	        if (check_for_tx_hang(tx_ring) && ixgbe_check_tx_hang(tx_ring)) {
    0.00 :	    8a5a:       a8 02                   test   $0x2,%al
    0.00 :	    8a5c:       74 63                   je     8ac1 <ixgbe_clean_tx_irq+0x211>
         :	        return ring->stats.packets;
         :	}
         :
         :	static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring)
         :	{
         :	        struct ixgbe_adapter *adapter = ring->q_vector->adapter;
    0.00 :	    8a5e:       49 8b 46 08             mov    0x8(%r14),%rax
         :	        return ((head <= tail) ? tail : tail + ring->count) - head;
         :	}
         :
         :	static bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
         :	{
         :	        u32 tx_done = ixgbe_get_tx_completed(tx_ring);
    0.00 :	    8a62:       41 8b 7e 58             mov    0x58(%r14),%edi
         :	        u32 tx_done_old = tx_ring->tx_stats.tx_done_old;
    0.00 :	    8a66:       4d 8b 46 78             mov    0x78(%r14),%r8
         :	        return ring->stats.packets;
         :	}
         :
         :	static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring)
         :	{
         :	        struct ixgbe_adapter *adapter = ring->q_vector->adapter;
    0.00 :	    8a6a:       48 8b 10                mov    (%rax),%rdx
         :	{ asm volatile("mov" size " %0,%1": :reg (val), \
         :	"m" (*(volatile type __force *)addr) barrier); }
         :
         :	build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
         :	build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
         :	build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    0.00 :	    8a6d:       41 0f b6 46 4f          movzbl 0x4f(%r14),%eax
    0.00 :	    8a72:       c1 e0 06                shl    $0x6,%eax
    0.00 :	    8a75:       48 98                   cltq   
    0.00 :	    8a77:       48 05 10 60 00 00       add    $0x6010,%rax
    0.00 :	    8a7d:       48 03 82 80 0e 00 00    add    0xe80(%rdx),%rax
    0.00 :	    8a84:       8b 30                   mov    (%rax),%esi
    0.00 :	    8a86:       41 0f b6 46 4f          movzbl 0x4f(%r14),%eax
    0.00 :	    8a8b:       c1 e0 06                shl    $0x6,%eax
    0.00 :	    8a8e:       48 98                   cltq   
    0.00 :	    8a90:       48 05 18 60 00 00       add    $0x6018,%rax
    0.00 :	    8a96:       48 03 82 80 0e 00 00    add    0xe80(%rdx),%rax
    0.00 :	    8a9d:       8b 10                   mov    (%rax),%edx
         :	        struct ixgbe_hw *hw = &adapter->hw;
         :
         :	        u32 head = IXGBE_READ_REG(hw, IXGBE_TDH(ring->reg_idx));
         :	        u32 tail = IXGBE_READ_REG(hw, IXGBE_TDT(ring->reg_idx));
         :
         :	        return ((head <= tail) ? tail : tail + ring->count) - head;
 ??:0
  100.00 :	    8a9f:       39 d6                   cmp    %edx,%esi
    0.00 :	    8aa1:       76 07                   jbe    8aaa <ixgbe_clean_tx_irq+0x1fa>
    0.00 :	    8aa3:       41 0f b7 46 4c          movzwl 0x4c(%r14),%eax
    0.00 :	    8aa8:       01 c2                   add    %eax,%edx
         :	 */
         :	static __always_inline void
         :	clear_bit(int nr, volatile unsigned long *addr)
         :	{
         :	        if (IS_IMMEDIATE(nr)) {
         :	                asm volatile(LOCK_PREFIX "andb %1,%0"
    0.00 :	    8aaa:       f0 41 80 66 30 fd       lock andb $0xfd,0x30(%r14)
         :	         * requiring this to fail twice we avoid races with
         :	         * PFC clearing the ARMED bit and conditions where we
         :	         * run the check_tx_hang logic with a transmit completion
         :	         * pending but without time to complete it yet.
         :	         */
         :	        if ((tx_done_old == tx_done) && tx_pending) {
    0.00 :	    8ab0:       44 39 c7                cmp    %r8d,%edi
    0.00 :	    8ab3:       74 5c                   je     8b11 <ixgbe_clean_tx_irq+0x261>
         :	                /* make sure it is true for two checks in a row */
         :	                ret = test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
         :	                                       &tx_ring->state);
         :	        } else {
         :	                /* update completed stats and continue */
         :	                tx_ring->tx_stats.tx_done_old = tx_done;
    0.00 :	    8ab5:       89 ff                   mov    %edi,%edi
    0.00 :	    8ab7:       49 89 7e 78             mov    %rdi,0x78(%r14)
    0.00 :	    8abb:       f0 41 80 66 30 fb       lock andb $0xfb,0x30(%r14)
         :	                /* the adapter is about to reset, no point in enabling stuff */
         :	                return true;
         :	        }
         :
         :	#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)
         :	        if (unlikely(total_packets && netif_carrier_ok(netdev_ring(tx_ring)) &&
    0.00 :	    8ac1:       8b 7c 24 20             mov    0x20(%rsp),%edi
    0.00 :	    8ac5:       85 ff                   test   %edi,%edi
    0.00 :	    8ac7:       0f 85 af 00 00 00       jne    8b7c <ixgbe_clean_tx_irq+0x2cc>
         :	                        ++tx_ring->tx_stats.restart_queue;
         :	                }
         :	#endif
         :	        }
         :
         :	        return !!budget;
    0.00 :	    8acd:       8b 74 24 24             mov    0x24(%rsp),%esi
    0.00 :	    8ad1:       85 f6                   test   %esi,%esi
    0.00 :	    8ad3:       0f 95 c0                setne  %al
         :	}
    0.00 :	    8ad6:       e9 92 00 00 00          jmpq   8b6d <ixgbe_clean_tx_irq+0x2bd>
    0.00 :	    8adb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                return dma_ops;
    0.00 :	    8ae0:       48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 8ae7 <ixgbe_clean_tx_irq+0x237>
    0.00 :	    8ae7:       e9 f4 fe ff ff          jmpq   89e0 <ixgbe_clean_tx_irq+0x130>
    0.00 :	    8aec:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    8af0:       48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 8af7 <ixgbe_clean_tx_irq+0x247>
    0.00 :	    8af7:       e9 81 fe ff ff          jmpq   897d <ixgbe_clean_tx_irq+0xcd>
         :	                while (tx_desc != eop_desc) {
         :	                        tx_buffer++;
         :	                        tx_desc++;
         :	                        i++;
         :	                        if (unlikely(!i)) {
         :	                                i -= tx_ring->count;
    0.00 :	    8afc:       45 0f b7 66 4c          movzwl 0x4c(%r14),%r12d
         :	                                tx_buffer = tx_ring->tx_buffer_info;
    0.00 :	    8b01:       49 8b 5e 28             mov    0x28(%r14),%rbx
         :	                                tx_desc = IXGBE_TX_DESC(tx_ring, 0);
    0.00 :	    8b05:       49 8b 6e 20             mov    0x20(%r14),%rbp
         :	                while (tx_desc != eop_desc) {
         :	                        tx_buffer++;
         :	                        tx_desc++;
         :	                        i++;
         :	                        if (unlikely(!i)) {
         :	                                i -= tx_ring->count;
    0.00 :	    8b09:       41 f7 dc                neg    %r12d
    0.00 :	    8b0c:       e9 a7 fe ff ff          jmpq   89b8 <ixgbe_clean_tx_irq+0x108>
         :	         * requiring this to fail twice we avoid races with
         :	         * PFC clearing the ARMED bit and conditions where we
         :	         * run the check_tx_hang logic with a transmit completion
         :	         * pending but without time to complete it yet.
         :	         */
         :	        if ((tx_done_old == tx_done) && tx_pending) {
    0.00 :	    8b11:       39 f2                   cmp    %esi,%edx
    0.00 :	    8b13:       74 a0                   je     8ab5 <ixgbe_clean_tx_irq+0x205>
         :	 */
         :	static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
         :	{
         :	        int oldbit;
         :
         :	        asm volatile(LOCK_PREFIX "bts %2,%1\n\t"
    0.00 :	    8b15:       f0 0f ba 29 02          lock btsl $0x2,(%rcx)
    0.00 :	    8b1a:       19 c0                   sbb    %eax,%eax
         :	        tx_ring->stats.bytes += total_bytes;
         :	        tx_ring->stats.packets += total_packets;
         :	        q_vector->tx.total_bytes += total_bytes;
         :	        q_vector->tx.total_packets += total_packets;
         :
         :	        if (check_for_tx_hang(tx_ring) && ixgbe_check_tx_hang(tx_ring)) {
    0.00 :	    8b1c:       85 c0                   test   %eax,%eax
    0.00 :	    8b1e:       74 a1                   je     8ac1 <ixgbe_clean_tx_irq+0x211>
         :	                        "  next_to_use          <%x>\n"
         :	                        "  next_to_clean        <%x>\n",
         :	                        tx_ring->queue_index,
         :	                        IXGBE_READ_REG(hw, IXGBE_TDH(tx_ring->reg_idx)),
         :	                        IXGBE_READ_REG(hw, IXGBE_TDT(tx_ring->reg_idx)),
         :	                        tx_ring->next_to_use, i);
    0.00 :	    8b20:       41 f6 87 a8 14 00 00    testb  $0x1,0x14a8(%r15)
    0.00 :	    8b27:       01 
    0.00 :	    8b28:       0f 85 34 01 00 00       jne    8c62 <ixgbe_clean_tx_irq+0x3b2>
         :
         :	static inline
         :	struct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,
         :	                                         unsigned int index)
         :	{
         :	        return &dev->_tx[index];
    0.00 :	    8b2e:       49 8b 46 10             mov    0x10(%r14),%rax
         :	                e_err(drv, "tx_buffer_info[next_to_clean]\n"
         :	                        "  time_stamp           <%lx>\n"
         :	                        "  jiffies              <%lx>\n",
         :	                        tx_ring->tx_buffer_info[i].time_stamp, jiffies);
         :
         :	                netif_stop_subqueue(netdev_ring(tx_ring),
    0.00 :	    8b32:       41 0f b6 5e 4e          movzbl 0x4e(%r14),%ebx
    0.00 :	    8b37:       48 8b a8 80 03 00 00    mov    0x380(%rax),%rbp
         :	 */
         :	static inline void netif_stop_subqueue(struct net_device *dev, u16 queue_index)
         :	{
         :	        struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
         :	#ifdef CONFIG_NETPOLL_TRAP
         :	        if (netpoll_trap())
    0.00 :	    8b3e:       e8 00 00 00 00          callq  8b43 <ixgbe_clean_tx_irq+0x293>
    0.00 :	    8b43:       85 c0                   test   %eax,%eax
    0.00 :	    8b45:       0f 84 01 01 00 00       je     8c4c <ixgbe_clean_tx_irq+0x39c>
         :	                                    ring_queue_index(tx_ring));
         :
         :	                e_info(probe,
    0.00 :	    8b4b:       41 f6 87 a8 14 00 00    testb  $0x2,0x14a8(%r15)
    0.00 :	    8b52:       02 
    0.00 :	    8b53:       0f 85 a0 01 00 00       jne    8cf9 <ixgbe_clean_tx_irq+0x449>
         :	        return oldbit;
         :	}
         :
         :	static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
         :	{
         :	        return ((1UL << (nr % BITS_PER_LONG)) &
    0.00 :	    8b59:       49 8b 87 10 02 00 00    mov    0x210(%r15),%rax
         :	 **/
         :	static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter)
         :	{
         :
         :	        /* Do the reset outside of interrupt context */
         :	        if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
    0.00 :	    8b60:       a8 04                   test   $0x4,%al
    0.00 :	    8b62:       0f 84 c7 00 00 00       je     8c2f <ixgbe_clean_tx_irq+0x37f>
         :	                        ++tx_ring->tx_stats.restart_queue;
         :	                }
         :	#endif
         :	        }
         :
         :	        return !!budget;
    0.00 :	    8b68:       b8 01 00 00 00          mov    $0x1,%eax
         :	}
    0.00 :	    8b6d:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	    8b71:       5b                      pop    %rbx
    0.00 :	    8b72:       5d                      pop    %rbp
    0.00 :	    8b73:       41 5c                   pop    %r12
    0.00 :	    8b75:       41 5d                   pop    %r13
    0.00 :	    8b77:       41 5e                   pop    %r14
    0.00 :	    8b79:       41 5f                   pop    %r15
    0.00 :	    8b7b:       c3                      retq   
         :	 *
         :	 * Check if carrier is present on device
         :	 */
         :	static inline int netif_carrier_ok(const struct net_device *dev)
         :	{
         :	        return !test_bit(__LINK_STATE_NOCARRIER, &dev->state);
    0.00 :	    8b7c:       49 8b 46 10             mov    0x10(%r14),%rax
    0.00 :	    8b80:       48 8b 40 78             mov    0x78(%rax),%rax
         :	                /* the adapter is about to reset, no point in enabling stuff */
         :	                return true;
         :	        }
         :
         :	#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)
         :	        if (unlikely(total_packets && netif_carrier_ok(netdev_ring(tx_ring)) &&
    0.00 :	    8b84:       a8 04                   test   $0x4,%al
    0.00 :	    8b86:       0f 85 41 ff ff ff       jne    8acd <ixgbe_clean_tx_irq+0x21d>
         :	}
         :
         :	/* ixgbe_desc_unused - calculate if we have unused descriptors */
         :	static inline u16 ixgbe_desc_unused(struct ixgbe_ring *ring)
         :	{
         :	        u16 ntc = ring->next_to_clean;
    0.00 :	    8b8c:       41 0f b7 46 52          movzwl 0x52(%r14),%eax
         :	        u16 ntu = ring->next_to_use;
    0.00 :	    8b91:       41 0f b7 4e 50          movzwl 0x50(%r14),%ecx
         :
         :	        return ((ntc > ntu) ? 0 : ring->count) + ntc - ntu - 1;
    0.00 :	    8b96:       31 d2                   xor    %edx,%edx
    0.00 :	    8b98:       66 39 c8                cmp    %cx,%ax
    0.00 :	    8b9b:       77 05                   ja     8ba2 <ixgbe_clean_tx_irq+0x2f2>
    0.00 :	    8b9d:       41 0f b7 56 4c          movzwl 0x4c(%r14),%edx
    0.00 :	    8ba2:       83 e8 01                sub    $0x1,%eax
    0.00 :	    8ba5:       66 29 c8                sub    %cx,%ax
    0.00 :	    8ba8:       01 d0                   add    %edx,%eax
    0.00 :	    8baa:       66 83 f8 2b             cmp    $0x2b,%ax
    0.00 :	    8bae:       0f 86 19 ff ff ff       jbe    8acd <ixgbe_clean_tx_irq+0x21d>
         :	                     (ixgbe_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {
         :	                /* Make sure that anybody stopping the queue after this
         :	                 * sees the new next_to_clean.
         :	                 */
         :	                smp_mb();
    0.00 :	    8bb4:       0f ae f0                mfence 
         :
         :	static inline
         :	struct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,
         :	                                         unsigned int index)
         :	{
         :	        return &dev->_tx[index];
    0.00 :	    8bb7:       41 0f b6 5e 4e          movzbl 0x4e(%r14),%ebx
    0.00 :	    8bbc:       49 8b 46 10             mov    0x10(%r14),%rax
    0.00 :	    8bc0:       48 c1 e3 08             shl    $0x8,%rbx
    0.00 :	    8bc4:       48 03 98 80 03 00 00    add    0x380(%rax),%rbx
    0.00 :	    8bcb:       48 8b 43 10             mov    0x10(%rbx),%rax
         :	        }
         :	}
         :
         :	static inline int netif_tx_queue_stopped(const struct netdev_queue *dev_queue)
         :	{
         :	        return test_bit(__QUEUE_STATE_XOFF, &dev_queue->state);
    0.00 :	    8bcf:       48 8d 6b 10             lea    0x10(%rbx),%rbp
         :	#ifdef HAVE_TX_MQ
         :	                if (__netif_subqueue_stopped(netdev_ring(tx_ring),
    0.00 :	    8bd3:       a8 01                   test   $0x1,%al
    0.00 :	    8bd5:       0f 84 f2 fe ff ff       je     8acd <ixgbe_clean_tx_irq+0x21d>
    0.00 :	    8bdb:       48 8b 54 24 10          mov    0x10(%rsp),%rdx
    0.00 :	    8be0:       48 8b 02                mov    (%rdx),%rax
    0.00 :	    8be3:       48 8b 80 10 02 00 00    mov    0x210(%rax),%rax
    0.00 :	    8bea:       a8 04                   test   $0x4,%al
    0.00 :	    8bec:       0f 85 db fe ff ff       jne    8acd <ixgbe_clean_tx_irq+0x21d>
         :	 */
         :	static inline void netif_wake_subqueue(struct net_device *dev, u16 queue_index)
         :	{
         :	        struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
         :	#ifdef CONFIG_NETPOLL_TRAP
         :	        if (netpoll_trap())
    0.00 :	    8bf2:       e8 00 00 00 00          callq  8bf7 <ixgbe_clean_tx_irq+0x347>
    0.00 :	    8bf7:       85 c0                   test   %eax,%eax
    0.00 :	    8bf9:       75 15                   jne    8c10 <ixgbe_clean_tx_irq+0x360>
         :	 */
         :	static inline int test_and_clear_bit(int nr, volatile unsigned long *addr)
         :	{
         :	        int oldbit;
         :
         :	        asm volatile(LOCK_PREFIX "btr %2,%1\n\t"
    0.00 :	    8bfb:       f0 0f ba 75 00 00       lock btrl $0x0,0x0(%rbp)
    0.00 :	    8c01:       19 c0                   sbb    %eax,%eax
         :	                return;
         :	#endif
         :	        if (test_and_clear_bit(__QUEUE_STATE_XOFF, &txq->state))
    0.00 :	    8c03:       85 c0                   test   %eax,%eax
    0.00 :	    8c05:       74 09                   je     8c10 <ixgbe_clean_tx_irq+0x360>
         :	                __netif_schedule(txq->qdisc);
    0.00 :	    8c07:       48 8b 7b 08             mov    0x8(%rbx),%rdi
    0.00 :	    8c0b:       e8 00 00 00 00          callq  8c10 <ixgbe_clean_tx_irq+0x360>
         :	                                             ring_queue_index(tx_ring))
         :	                    && !test_bit(__IXGBE_DOWN, &q_vector->adapter->state)) {
         :	                        netif_wake_subqueue(netdev_ring(tx_ring),
         :	                                            ring_queue_index(tx_ring));
         :	                        ++tx_ring->tx_stats.restart_queue;
    0.00 :	    8c10:       49 83 46 68 01          addq   $0x1,0x68(%r14)
    0.00 :	    8c15:       e9 b3 fe ff ff          jmpq   8acd <ixgbe_clean_tx_irq+0x21d>
         :	                /* move us one more past the eop_desc for start of next pkt */
         :	                tx_buffer++;
         :	                tx_desc++;
         :	                i++;
         :	                if (unlikely(!i)) {
         :	                        i -= tx_ring->count;
    0.00 :	    8c1a:       45 0f b7 66 4c          movzwl 0x4c(%r14),%r12d
         :	                        tx_buffer = tx_ring->tx_buffer_info;
    0.00 :	    8c1f:       49 8b 5e 28             mov    0x28(%r14),%rbx
         :	                        tx_desc = IXGBE_TX_DESC(tx_ring, 0);
    0.00 :	    8c23:       49 8b 6e 20             mov    0x20(%r14),%rbp
         :	                /* move us one more past the eop_desc for start of next pkt */
         :	                tx_buffer++;
         :	                tx_desc++;
         :	                i++;
         :	                if (unlikely(!i)) {
         :	                        i -= tx_ring->count;
    0.00 :	    8c27:       41 f7 dc                neg    %r12d
    0.00 :	    8c2a:       e9 e3 fd ff ff          jmpq   8a12 <ixgbe_clean_tx_irq+0x162>
         :	static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter)
         :	{
         :
         :	        /* Do the reset outside of interrupt context */
         :	        if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
         :	                adapter->flags2 |= IXGBE_FLAG2_RESET_REQUESTED;
    0.00 :	    8c2f:       41 81 8f 1c 02 00 00    orl    $0x80,0x21c(%r15)
    0.00 :	    8c36:       80 00 00 00 
         :	                ixgbe_service_event_schedule(adapter);
    0.00 :	    8c3a:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    8c3d:       e8 9e 85 ff ff          callq  11e0 <ixgbe_service_event_schedule>
    0.00 :	    8c42:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	    8c47:       e9 21 ff ff ff          jmpq   8b6d <ixgbe_clean_tx_irq+0x2bd>
         :	        struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
         :	#ifdef CONFIG_NETPOLL_TRAP
         :	        if (netpoll_trap())
         :	                return;
         :	#endif
         :	        netif_tx_stop_queue(txq);
    0.00 :	    8c4c:       0f b6 fb                movzbl %bl,%edi
    0.00 :	    8c4f:       48 c1 e7 08             shl    $0x8,%rdi
    0.00 :	    8c53:       48 8d 7c 3d 00          lea    0x0(%rbp,%rdi,1),%rdi
    0.00 :	    8c58:       e8 e3 a9 ff ff          callq  3640 <netif_tx_stop_queue>
    0.00 :	    8c5d:       e9 e9 fe ff ff          jmpq   8b4b <ixgbe_clean_tx_irq+0x29b>
    0.00 :	    8c62:       41 0f b6 46 4f          movzbl 0x4f(%r14),%eax
         :	                        "  next_to_use          <%x>\n"
         :	                        "  next_to_clean        <%x>\n",
         :	                        tx_ring->queue_index,
         :	                        IXGBE_READ_REG(hw, IXGBE_TDH(tx_ring->reg_idx)),
         :	                        IXGBE_READ_REG(hw, IXGBE_TDT(tx_ring->reg_idx)),
         :	                        tx_ring->next_to_use, i);
    0.00 :	    8c67:       45 0f b7 4e 50          movzwl 0x50(%r14),%r9d
    0.00 :	    8c6c:       c1 e0 06                shl    $0x6,%eax
    0.00 :	    8c6f:       48 98                   cltq   
    0.00 :	    8c71:       48 05 18 60 00 00       add    $0x6018,%rax
    0.00 :	    8c77:       49 03 87 80 0e 00 00    add    0xe80(%r15),%rax
    0.00 :	    8c7e:       44 8b 00                mov    (%rax),%r8d
    0.00 :	    8c81:       41 0f b6 46 4f          movzbl 0x4f(%r14),%eax
    0.00 :	    8c86:       c1 e0 06                shl    $0x6,%eax
    0.00 :	    8c89:       48 98                   cltq   
    0.00 :	    8c8b:       48 05 10 60 00 00       add    $0x6010,%rax
    0.00 :	    8c91:       49 03 87 80 0e 00 00    add    0xe80(%r15),%rax
    0.00 :	    8c98:       8b 08                   mov    (%rax),%ecx
    0.00 :	    8c9a:       41 0f b6 56 4e          movzbl 0x4e(%r14),%edx
    0.00 :	    8c9f:       49 8b bf 00 02 00 00    mov    0x200(%r15),%rdi
    0.00 :	    8ca6:       31 c0                   xor    %eax,%eax
    0.00 :	    8ca8:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    8caf:       89 1c 24                mov    %ebx,(%rsp)
    0.00 :	    8cb2:       e8 00 00 00 00          callq  8cb7 <ixgbe_clean_tx_irq+0x407>
         :	                e_err(drv, "tx_buffer_info[next_to_clean]\n"
         :	                        "  time_stamp           <%lx>\n"
         :	                        "  jiffies              <%lx>\n",
         :	                        tx_ring->tx_buffer_info[i].time_stamp, jiffies);
    0.00 :	    8cb7:       41 f6 87 a8 14 00 00    testb  $0x1,0x14a8(%r15)
    0.00 :	    8cbe:       01 
    0.00 :	    8cbf:       0f 84 69 fe ff ff       je     8b2e <ixgbe_clean_tx_irq+0x27e>
    0.00 :	    8cc5:       89 d8                   mov    %ebx,%eax
    0.00 :	    8cc7:       49 8b 56 28             mov    0x28(%r14),%rdx
    0.00 :	    8ccb:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 8cd2 <ixgbe_clean_tx_irq+0x422>
    0.00 :	    8cd2:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	    8cd6:       49 8b bf 00 02 00 00    mov    0x200(%r15),%rdi
    0.00 :	    8cdd:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    8ce4:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	    8ce8:       48 8b 54 02 08          mov    0x8(%rdx,%rax,1),%rdx
    0.00 :	    8ced:       31 c0                   xor    %eax,%eax
    0.00 :	    8cef:       e8 00 00 00 00          callq  8cf4 <ixgbe_clean_tx_irq+0x444>
    0.00 :	    8cf4:       e9 35 fe ff ff          jmpq   8b2e <ixgbe_clean_tx_irq+0x27e>
         :	                netif_stop_subqueue(netdev_ring(tx_ring),
         :	                                    ring_queue_index(tx_ring));
         :
         :	                e_info(probe,
         :	                       "tx hang %d detected on queue %d, resetting adapter\n",
         :	                       adapter->tx_timeout_count + 1, tx_ring->queue_index);
    0.00 :	    8cf9:       41 8b 97 d0 04 00 00    mov    0x4d0(%r15),%edx
    0.00 :	    8d00:       41 0f b6 4e 4e          movzbl 0x4e(%r14),%ecx
    0.00 :	    8d05:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    8d0c:       49 8b bf 00 02 00 00    mov    0x200(%r15),%rdi
    0.00 :	    8d13:       31 c0                   xor    %eax,%eax
    0.00 :	    8d15:       83 c2 01                add    $0x1,%edx
    0.00 :	    8d18:       e8 00 00 00 00          callq  8d1d <ixgbe_clean_tx_irq+0x46d>
    0.00 :	    8d1d:       e9 37 fe ff ff          jmpq   8b59 <ixgbe_clean_tx_irq+0x2a9>

Sorted summary for file /home/Computational/mark/andres/lib/libpq.so.5.8
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/lib/libpq.so.5.8
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000001c580 <pg_ascii_mblen>:
         :	        return cnt;
         :	}
         :
         :	static int
         :	pg_ascii_mblen(const unsigned char *s)
         :	{
    0.00 :	   1c580:       55                      push   %rbp
         :	        return 1;
         :	}
    0.00 :	   1c581:       b8 01 00 00 00          mov    $0x1,%eax
         :	        return cnt;
         :	}
         :
         :	static int
         :	pg_ascii_mblen(const unsigned char *s)
         :	{
    0.00 :	   1c586:       48 89 e5                mov    %rsp,%rbp
         :	        return 1;
         :	}
 ??:0
  100.00 :	   1c589:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .plt:
         :
         :	00000000004695c0 <gettimeofday@plt>:
 ??:0
  100.00 :	  4695c0:       ff 25 82 db 6f 00       jmpq   *0x6fdb82(%rip)        # b67148 <_GLOBAL_OFFSET_TABLE_+0x148>
    0.00 :	  4695c6:       68 26 00 00 00          pushq  $0x26
    0.00 :	  4695cb:       e9 80 fd ff ff          jmpq   469350 <_init+0x20>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1362
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046ee40 <slot_attisnull>:
         :	 *              Detect whether an attribute of the slot is null, without
         :	 *              actually fetching it.
         :	 */
         :	bool
         :	slot_attisnull(TupleTableSlot *slot, int attnum)
         :	{
    0.00 :	  46ee40:       55                      push   %rbp
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :
         :	        /*
         :	         * system attributes are handled by heap_attisnull
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46ee41:       85 f6                   test   %esi,%esi
         :	 *              actually fetching it.
         :	 */
         :	bool
         :	slot_attisnull(TupleTableSlot *slot, int attnum)
         :	{
         :	        HeapTuple       tuple = slot->tts_tuple;
    0.00 :	  46ee43:       48 8b 57 08             mov    0x8(%rdi),%rdx
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
    0.00 :	  46ee47:       48 8b 4f 10             mov    0x10(%rdi),%rcx
         :	 *              Detect whether an attribute of the slot is null, without
         :	 *              actually fetching it.
         :	 */
         :	bool
         :	slot_attisnull(TupleTableSlot *slot, int attnum)
         :	{
    0.00 :	  46ee4b:       48 89 e5                mov    %rsp,%rbp
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :
         :	        /*
         :	         * system attributes are handled by heap_attisnull
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46ee4e:       7e 30                   jle    46ee80 <slot_attisnull+0x40>
         :	        }
         :
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
  100.00 :	  46ee50:       3b 77 24                cmp    0x24(%rdi),%esi
    0.00 :	  46ee53:       7e 1b                   jle    46ee70 <slot_attisnull+0x30>
         :	                return slot->tts_isnull[attnum - 1];
         :
         :	        /*
         :	         * return NULL if attnum is out of range according to the tupdesc
         :	         */
         :	        if (attnum > tupleDesc->natts)
    0.00 :	  46ee55:       3b 31                   cmp    (%rcx),%esi
    0.00 :	  46ee57:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  46ee5c:       7f 1e                   jg     46ee7c <slot_attisnull+0x3c>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
    0.00 :	  46ee5e:       48 85 d2                test   %rdx,%rdx
    0.00 :	  46ee61:       74 7f                   je     46eee2 <slot_attisnull+0xa2>
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
         :
         :	        /* and let the tuple tell it */
         :	        return heap_attisnull(tuple, attnum);
         :	}
    0.00 :	  46ee63:       c9                      leaveq 
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
         :
         :	        /* and let the tuple tell it */
         :	        return heap_attisnull(tuple, attnum);
    0.00 :	  46ee64:       48 89 d7                mov    %rdx,%rdi
    0.00 :	  46ee67:       e9 34 ff ff ff          jmpq   46eda0 <heap_attisnull>
    0.00 :	  46ee6c:       0f 1f 40 00             nopl   0x0(%rax)
         :
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
         :	                return slot->tts_isnull[attnum - 1];
    0.00 :	  46ee70:       48 8b 47 30             mov    0x30(%rdi),%rax
    0.00 :	  46ee74:       48 63 d6                movslq %esi,%rdx
    0.00 :	  46ee77:       0f b6 44 10 ff          movzbl -0x1(%rax,%rdx,1),%eax
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
         :
         :	        /* and let the tuple tell it */
         :	        return heap_attisnull(tuple, attnum);
         :	}
    0.00 :	  46ee7c:       c9                      leaveq 
    0.00 :	  46ee7d:       c3                      retq   
    0.00 :	  46ee7e:       66 90                   xchg   %ax,%ax
         :	        /*
         :	         * system attributes are handled by heap_attisnull
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
    0.00 :	  46ee80:       48 85 d2                test   %rdx,%rdx
    0.00 :	  46ee83:       74 33                   je     46eeb8 <slot_attisnull+0x78>
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
    0.00 :	  46ee85:       48 8d 47 40             lea    0x40(%rdi),%rax
    0.00 :	  46ee89:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  46ee8c:       75 d5                   jne    46ee63 <slot_attisnull+0x23>
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
    0.00 :	  46ee8e:       ba a8 f6 7a 00          mov    $0x7af6a8,%edx
    0.00 :	  46ee93:       be 4b 05 00 00          mov    $0x54b,%esi
    0.00 :	  46ee98:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46ee9d:       e8 7e c5 30 00          callq  77b420 <elog_start>
    0.00 :	  46eea2:       be 78 f7 7a 00          mov    $0x7af778,%esi
    0.00 :	  46eea7:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46eeac:       31 c0                   xor    %eax,%eax
    0.00 :	  46eeae:       e8 7d c3 30 00          callq  77b230 <elog_finish>
    0.00 :	  46eeb3:       e8 18 a6 ff ff          callq  4694d0 <abort@plt>
         :	         * system attributes are handled by heap_attisnull
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
    0.00 :	  46eeb8:       ba a8 f6 7a 00          mov    $0x7af6a8,%edx
    0.00 :	  46eebd:       be 49 05 00 00          mov    $0x549,%esi
    0.00 :	  46eec2:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46eec7:       e8 54 c5 30 00          callq  77b420 <elog_start>
    0.00 :	  46eecc:       be 40 f7 7a 00          mov    $0x7af740,%esi
    0.00 :	  46eed1:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46eed6:       31 c0                   xor    %eax,%eax
    0.00 :	  46eed8:       e8 53 c3 30 00          callq  77b230 <elog_finish>
    0.00 :	  46eedd:       e8 ee a5 ff ff          callq  4694d0 <abort@plt>
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46eee2:       ba a8 f6 7a 00          mov    $0x7af6a8,%edx
    0.00 :	  46eee7:       be 60 05 00 00          mov    $0x560,%esi
    0.00 :	  46eeec:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46eef1:       e8 2a c5 30 00          callq  77b420 <elog_start>
    0.00 :	  46eef6:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46eefb:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46ef00:       31 c0                   xor    %eax,%eax
    0.00 :	  46ef02:       e8 29 c3 30 00          callq  77b230 <elog_finish>
    0.00 :	  46ef07:       e8 c4 a5 ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/tuptoaster.c:319
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a14a0 <toast_raw_datum_size>:
         :	 *      (including the VARHDRSZ header)
         :	 * ----------
         :	 */
         :	Size
         :	toast_raw_datum_size(Datum value)
         :	{
    0.00 :	  4a14a0:       55                      push   %rbp
    0.00 :	  4a14a1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a14a4:       48 83 ec 10             sub    $0x10,%rsp
         :	        struct varlena *attr = (struct varlena *) DatumGetPointer(value);
         :	        Size            result;
         :
         :	        if (VARATT_IS_EXTERNAL_ONDISK(attr))
    0.00 :	  4a14a8:       0f b6 17                movzbl (%rdi),%edx
    0.00 :	  4a14ab:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  4a14ae:       74 30                   je     4a14e0 <toast_raw_datum_size+0x40>
         :	                /* nested indirect Datums aren't allowed */
         :	                Assert(!VARATT_IS_EXTERNAL_INDIRECT(toast_pointer.pointer));
         :
         :	                return toast_raw_datum_size(PointerGetDatum(toast_pointer.pointer));
         :	        }
         :	        else if (VARATT_IS_COMPRESSED(attr))
    0.00 :	  4a14b0:       0f b6 ca                movzbl %dl,%ecx
    0.00 :	  4a14b3:       89 c8                   mov    %ecx,%eax
    0.00 :	  4a14b5:       83 e0 03                and    $0x3,%eax
    0.00 :	  4a14b8:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  4a14bb:       74 13                   je     4a14d0 <toast_raw_datum_size+0x30>
         :	        {
         :	                /* here, va_rawsize is just the payload size */
         :	                result = VARRAWSIZE_4B_C(attr) + VARHDRSZ;
         :	        }
         :	        else if (VARATT_IS_SHORT(attr))
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/tuptoaster.c:319
  100.00 :	  4a14bd:       83 e1 01                and    $0x1,%ecx
    0.00 :	  4a14c0:       75 2a                   jne    4a14ec <toast_raw_datum_size+0x4c>
         :	                result = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;
         :	        }
         :	        else
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
    0.00 :	  4a14c2:       8b 07                   mov    (%rdi),%eax
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14c4:       c9                      leaveq 
         :	                result = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;
         :	        }
         :	        else
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
    0.00 :	  4a14c5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  4a14c8:       89 c0                   mov    %eax,%eax
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14ca:       c3                      retq   
    0.00 :	  4a14cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                return toast_raw_datum_size(PointerGetDatum(toast_pointer.pointer));
         :	        }
         :	        else if (VARATT_IS_COMPRESSED(attr))
         :	        {
         :	                /* here, va_rawsize is just the payload size */
         :	                result = VARRAWSIZE_4B_C(attr) + VARHDRSZ;
    0.00 :	  4a14d0:       8b 47 04                mov    0x4(%rdi),%eax
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14d3:       c9                      leaveq 
         :	                return toast_raw_datum_size(PointerGetDatum(toast_pointer.pointer));
         :	        }
         :	        else if (VARATT_IS_COMPRESSED(attr))
         :	        {
         :	                /* here, va_rawsize is just the payload size */
         :	                result = VARRAWSIZE_4B_C(attr) + VARHDRSZ;
    0.00 :	  4a14d4:       83 c0 04                add    $0x4,%eax
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14d7:       c3                      retq   
    0.00 :	  4a14d8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4a14df:       00 
         :	toast_raw_datum_size(Datum value)
         :	{
         :	        struct varlena *attr = (struct varlena *) DatumGetPointer(value);
         :	        Size            result;
         :
         :	        if (VARATT_IS_EXTERNAL_ONDISK(attr))
    0.00 :	  4a14e0:       0f b6 47 01             movzbl 0x1(%rdi),%eax
    0.00 :	  4a14e4:       3c 12                   cmp    $0x12,%al
    0.00 :	  4a14e6:       74 18                   je     4a1500 <toast_raw_datum_size+0x60>
         :	                struct varatt_external toast_pointer;
         :
         :	                VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);
         :	                result = toast_pointer.va_rawsize;
         :	        }
         :	        else if (VARATT_IS_EXTERNAL_INDIRECT(attr))
    0.00 :	  4a14e8:       2c 01                   sub    $0x1,%al
    0.00 :	  4a14ea:       74 24                   je     4a1510 <toast_raw_datum_size+0x70>
         :	        {
         :	                /*
         :	                 * we have to normalize the header length to VARHDRSZ or else the
         :	                 * callers of this function will be confused.
         :	                 */
         :	                result = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;
    0.00 :	  4a14ec:       d0 ea                   shr    %dl
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14ee:       c9                      leaveq 
         :	        {
         :	                /*
         :	                 * we have to normalize the header length to VARHDRSZ or else the
         :	                 * callers of this function will be confused.
         :	                 */
         :	                result = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;
    0.00 :	  4a14ef:       0f b6 c2                movzbl %dl,%eax
    0.00 :	  4a14f2:       48 83 c0 03             add    $0x3,%rax
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a14f6:       c3                      retq   
    0.00 :	  4a14f7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4a14fe:       00 00 
         :	        if (VARATT_IS_EXTERNAL_ONDISK(attr))
         :	        {
         :	                /* va_rawsize is the size of the original datum -- including header */
         :	                struct varatt_external toast_pointer;
         :
         :	                VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);
    0.00 :	  4a1500:       48 8b 47 02             mov    0x2(%rdi),%rax
    0.00 :	  4a1504:       48 89 45 f0             mov    %rax,-0x10(%rbp)
         :	                result = toast_pointer.va_rawsize;
    0.00 :	  4a1508:       48 63 45 f0             movslq -0x10(%rbp),%rax
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a150c:       c9                      leaveq 
    0.00 :	  4a150d:       c3                      retq   
    0.00 :	  4a150e:       66 90                   xchg   %ax,%ax
         :	        }
         :	        else if (VARATT_IS_EXTERNAL_INDIRECT(attr))
         :	        {
         :	                struct varatt_indirect toast_pointer;
         :
         :	                VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);
    0.00 :	  4a1510:       48 8b 7f 02             mov    0x2(%rdi),%rdi
    0.00 :	  4a1514:       48 89 7d f0             mov    %rdi,-0x10(%rbp)
         :
         :	                /* nested indirect Datums aren't allowed */
         :	                Assert(!VARATT_IS_EXTERNAL_INDIRECT(toast_pointer.pointer));
         :
         :	                return toast_raw_datum_size(PointerGetDatum(toast_pointer.pointer));
    0.00 :	  4a1518:       e8 83 ff ff ff          callq  4a14a0 <toast_raw_datum_size>
         :	        {
         :	                /* plain untoasted datum */
         :	                result = VARSIZE(attr);
         :	        }
         :	        return result;
         :	}
    0.00 :	  4a151d:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:7339
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004cd4c0 <RecoveryInProgress>:
         :	        /*
         :	         * We check shared state each time only until we leave recovery mode. We
         :	         * can't re-enter recovery, so there's no need to keep checking after the
         :	         * shared variable has once been seen false.
         :	         */
         :	        if (!LocalRecoveryInProgress)
    0.00 :	  4cd4c0:       31 c0                   xor    %eax,%eax
    0.00 :	  4cd4c2:       80 3d 97 a9 69 00 00    cmpb   $0x0,0x69a997(%rip)        # b67e60 <LocalRecoveryInProgress>
         :	 * As a side-effect, we initialize the local TimeLineID and RedoRecPtr
         :	 * variables the first time we see that recovery is finished.
         :	 */
         :	bool
         :	RecoveryInProgress(void)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:7339
  100.00 :	  4cd4c9:       55                      push   %rbp
    0.00 :	  4cd4ca:       48 89 e5                mov    %rsp,%rbp
         :	        /*
         :	         * We check shared state each time only until we leave recovery mode. We
         :	         * can't re-enter recovery, so there's no need to keep checking after the
         :	         * shared variable has once been seen false.
         :	         */
         :	        if (!LocalRecoveryInProgress)
    0.00 :	  4cd4cd:       74 1f                   je     4cd4ee <RecoveryInProgress+0x2e>
         :	        {
         :	                /*
         :	                 * use volatile pointer to make sure we make a fresh read of the
         :	                 * shared variable.
         :	                 */
         :	                volatile XLogCtlData *xlogctl = XLogCtl;
    0.00 :	  4cd4cf:       48 8b 05 c2 bc 6a 00    mov    0x6abcc2(%rip),%rax        # b79198 <XLogCtl>
         :
         :	                LocalRecoveryInProgress = xlogctl->SharedRecoveryInProgress;
    0.00 :	  4cd4d6:       0f b6 80 5c 05 00 00    movzbl 0x55c(%rax),%eax
         :	                 * Initialize TimeLineID and RedoRecPtr when we discover that recovery
         :	                 * is finished. InitPostgres() relies upon this behaviour to ensure
         :	                 * that InitXLOGAccess() is called at backend startup.  (If you change
         :	                 * this, see also LocalSetXLogInsertAllowed.)
         :	                 */
         :	                if (!LocalRecoveryInProgress)
    0.00 :	  4cd4dd:       84 c0                   test   %al,%al
         :	                 * use volatile pointer to make sure we make a fresh read of the
         :	                 * shared variable.
         :	                 */
         :	                volatile XLogCtlData *xlogctl = XLogCtl;
         :
         :	                LocalRecoveryInProgress = xlogctl->SharedRecoveryInProgress;
    0.00 :	  4cd4df:       88 05 7b a9 69 00       mov    %al,0x69a97b(%rip)        # b67e60 <LocalRecoveryInProgress>
         :	                 * Initialize TimeLineID and RedoRecPtr when we discover that recovery
         :	                 * is finished. InitPostgres() relies upon this behaviour to ensure
         :	                 * that InitXLOGAccess() is called at backend startup.  (If you change
         :	                 * this, see also LocalSetXLogInsertAllowed.)
         :	                 */
         :	                if (!LocalRecoveryInProgress)
    0.00 :	  4cd4e5:       74 09                   je     4cd4f0 <RecoveryInProgress+0x30>
         :	                 * Note: We don't need a memory barrier when we're still in recovery.
         :	                 * We might exit recovery immediately after return, so the caller
         :	                 * can't rely on 'true' meaning that we're still in recovery anyway.
         :	                 */
         :
         :	                return LocalRecoveryInProgress;
    0.00 :	  4cd4e7:       0f b6 05 72 a9 69 00    movzbl 0x69a972(%rip),%eax        # b67e60 <LocalRecoveryInProgress>
         :	        }
         :	}
    0.00 :	  4cd4ee:       c9                      leaveq 
    0.00 :	  4cd4ef:       c3                      retq   
         :	                        /*
         :	                         * If we just exited recovery, make sure we read TimeLineID and
         :	                         * RedoRecPtr after SharedRecoveryInProgress (for machines with
         :	                         * weak memory ordering).
         :	                         */
         :	                        pg_memory_barrier();
    0.00 :	  4cd4f0:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	                        InitXLOGAccess();
    0.00 :	  4cd4f5:       e8 a6 ff ff ff          callq  4cd4a0 <InitXLOGAccess>
         :	                 * Note: We don't need a memory barrier when we're still in recovery.
         :	                 * We might exit recovery immediately after return, so the caller
         :	                 * can't rely on 'true' meaning that we're still in recovery anyway.
         :	                 */
         :
         :	                return LocalRecoveryInProgress;
    0.00 :	  4cd4fa:       0f b6 05 5f a9 69 00    movzbl 0x69a95f(%rip),%eax        # b67e60 <LocalRecoveryInProgress>
    0.00 :	  4cd501:       eb eb                   jmp    4cd4ee <RecoveryInProgress+0x2e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/catalog/catalog.c:126
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004e2db0 <IsCatalogClass>:
         :	 *
         :	 * Check IsCatalogRelation() for details.
         :	 */
         :	bool
         :	IsCatalogClass(Oid relid, Form_pg_class reltuple)
         :	{
    0.00 :	  4e2db0:       55                      push   %rbp
    0.00 :	  4e2db1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4e2db4:       53                      push   %rbx
    0.00 :	  4e2db5:       89 fb                   mov    %edi,%ebx
    0.00 :	  4e2db7:       48 83 ec 08             sub    $0x8,%rsp
         :	        Oid                     relnamespace = reltuple->relnamespace;
    0.00 :	  4e2dbb:       8b 7e 40                mov    0x40(%rsi),%edi
         :
         :	        /*
         :	         * Never consider relations outside pg_catalog/pg_toast to be catalog
         :	         * relations.
         :	         */
         :	        if (!IsSystemNamespace(relnamespace) && !IsToastNamespace(relnamespace))
    0.00 :	  4e2dbe:       83 ff 0b                cmp    $0xb,%edi
    0.00 :	  4e2dc1:       74 0b                   je     4e2dce <IsCatalogClass+0x1e>
    0.00 :	  4e2dc3:       e8 98 ff ff ff          callq  4e2d60 <IsToastNamespace>
    0.00 :	  4e2dc8:       31 d2                   xor    %edx,%edx
    0.00 :	  4e2dca:       84 c0                   test   %al,%al
    0.00 :	  4e2dcc:       74 09                   je     4e2dd7 <IsCatalogClass+0x27>
         :	         * property (c.f. GetNewObjectId()) and it has the advantage that it works
         :	         * correctly even if a user decides to create a relation in the pg_catalog
         :	         * namespace.
         :	         * ----
         :	         */
         :	        return relid < FirstNormalObjectId;
    0.00 :	  4e2dce:       81 fb ff 3f 00 00       cmp    $0x3fff,%ebx
    0.00 :	  4e2dd4:       0f 96 c2                setbe  %dl
         :	}
    0.00 :	  4e2dd7:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  4e2ddb:       89 d0                   mov    %edx,%eax
    0.00 :	  4e2ddd:       5b                      pop    %rbx
  100.00 :	  4e2dde:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/catalog/catalog.c:91
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004e2de0 <IsCatalogRelation>:
         :	 *              but this function returns true only for toast relations of system
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
    0.00 :	  4e2de0:       55                      push   %rbp
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
    0.00 :	  4e2de1:       48 8b 77 30             mov    0x30(%rdi),%rsi
  100.00 :	  4e2de5:       8b 7f 40                mov    0x40(%rdi),%edi
         :	 *              but this function returns true only for toast relations of system
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
    0.00 :	  4e2de8:       48 89 e5                mov    %rsp,%rbp
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
         :	}
    0.00 :	  4e2deb:       c9                      leaveq 
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
    0.00 :	  4e2dec:       e9 bf ff ff ff          jmpq   4e2db0 <IsCatalogClass>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1040
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbac0 <ExecHashGetBucketAndBatch>:
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
    0.00 :	  5bbac0:       55                      push   %rbp
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
    0.00 :	  5bbac1:       44 8b 47 40             mov    0x40(%rdi),%r8d
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
    0.00 :	  5bbac5:       49 89 c9                mov    %rcx,%r9
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
    0.00 :	  5bbac8:       8b 07                   mov    (%rdi),%eax
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
    0.00 :	  5bbaca:       48 89 e5                mov    %rsp,%rbp
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
    0.00 :	  5bbacd:       41 83 f8 01             cmp    $0x1,%r8d
    0.00 :	  5bbad1:       76 1d                   jbe    5bbaf0 <ExecHashGetBucketAndBatch+0x30>
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bbad3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bbad6:       21 f0                   and    %esi,%eax
    0.00 :	  5bbad8:       89 02                   mov    %eax,(%rdx)
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bbada:       8b 4f 04                mov    0x4(%rdi),%ecx
    0.00 :	  5bbadd:       41 8d 40 ff             lea    -0x1(%r8),%eax
    0.00 :	  5bbae1:       d3 ee                   shr    %cl,%esi
    0.00 :	  5bbae3:       21 f0                   and    %esi,%eax
    0.00 :	  5bbae5:       41 89 01                mov    %eax,(%r9)
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = 0;
         :	        }
         :	}
    0.00 :	  5bbae8:       c9                      leaveq 
    0.00 :	  5bbae9:       c3                      retq   
    0.00 :	  5bbaea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
         :	        }
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bbaf0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bbaf3:       21 f0                   and    %esi,%eax
    0.00 :	  5bbaf5:       89 02                   mov    %eax,(%rdx)
         :	                *batchno = 0;
    0.00 :	  5bbaf7:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1040
  100.00 :	  5bbafd:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006425d0 <pgstat_end_function_usage>:
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  6425d0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
  100.00 :	  6425d1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6425d4:       41 55                   push   %r13
    0.00 :	  6425d6:       41 89 f5                mov    %esi,%r13d
    0.00 :	  6425d9:       41 54                   push   %r12
    0.00 :	  6425db:       49 89 fc                mov    %rdi,%r12
    0.00 :	  6425de:       53                      push   %rbx
    0.00 :	  6425df:       48 83 ec 18             sub    $0x18,%rsp
         :	        PgStat_FunctionCounts *fs = fcu->fs;
    0.00 :	  6425e3:       48 8b 1f                mov    (%rdi),%rbx
         :	        instr_time      f_total;
         :	        instr_time      f_others;
         :	        instr_time      f_self;
         :
         :	        /* stats not wanted? */
         :	        if (fs == NULL)
    0.00 :	  6425e6:       48 85 db                test   %rbx,%rbx
    0.00 :	  6425e9:       0f 84 6f 01 00 00       je     64275e <pgstat_end_function_usage+0x18e>
         :	                return;
         :
         :	        /* total elapsed time in this function call */
         :	        INSTR_TIME_SET_CURRENT(f_total);
    0.00 :	  6425ef:       48 8d 7d d0             lea    -0x30(%rbp),%rdi
    0.00 :	  6425f3:       31 f6                   xor    %esi,%esi
    0.00 :	  6425f5:       e8 c6 6f e2 ff          callq  4695c0 <gettimeofday@plt>
         :	        INSTR_TIME_SUBTRACT(f_total, fcu->f_start);
    0.00 :	  6425fa:       48 8b 4d d8             mov    -0x28(%rbp),%rcx
    0.00 :	  6425fe:       49 2b 4c 24 30          sub    0x30(%r12),%rcx
    0.00 :	  642603:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  642607:       49 2b 44 24 28          sub    0x28(%r12),%rax
    0.00 :	  64260c:       48 85 c9                test   %rcx,%rcx
    0.00 :	  64260f:       48 89 4d d8             mov    %rcx,-0x28(%rbp)
    0.00 :	  642613:       49 89 c1                mov    %rax,%r9
    0.00 :	  642616:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  64261a:       79 1c                   jns    642638 <pgstat_end_function_usage+0x68>
    0.00 :	  64261c:       0f 1f 40 00             nopl   0x0(%rax)
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  642620:       48 83 e8 01             sub    $0x1,%rax
         :	        if (fs == NULL)
         :	                return;
         :
         :	        /* total elapsed time in this function call */
         :	        INSTR_TIME_SET_CURRENT(f_total);
         :	        INSTR_TIME_SUBTRACT(f_total, fcu->f_start);
    0.00 :	  642624:       48 81 c1 40 42 0f 00    add    $0xf4240,%rcx
    0.00 :	  64262b:       78 f3                   js     642620 <pgstat_end_function_usage+0x50>
    0.00 :	  64262d:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  642631:       48 89 4d d8             mov    %rcx,-0x28(%rbp)
    0.00 :	  642635:       49 89 c1                mov    %rax,%r9
         :
         :	        /* self usage: elapsed minus anything already charged to other calls */
         :	        f_others = total_func_time;
    0.00 :	  642638:       4c 8b 05 e9 98 53 00    mov    0x5398e9(%rip),%r8        # b7bf28 <total_func_time+0x8>
    0.00 :	  64263f:       4c 8b 15 da 98 53 00    mov    0x5398da(%rip),%r10        # b7bf20 <total_func_time>
         :	        INSTR_TIME_SUBTRACT(f_others, fcu->save_total);
    0.00 :	  642646:       4c 89 c0                mov    %r8,%rax
    0.00 :	  642649:       4c 89 d2                mov    %r10,%rdx
    0.00 :	  64264c:       49 2b 54 24 18          sub    0x18(%r12),%rdx
    0.00 :	  642651:       49 2b 44 24 20          sub    0x20(%r12),%rax
    0.00 :	  642656:       79 14                   jns    64266c <pgstat_end_function_usage+0x9c>
    0.00 :	  642658:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  64265f:       00 
    0.00 :	  642660:       48 83 ea 01             sub    $0x1,%rdx
    0.00 :	  642664:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  64266a:       78 f4                   js     642660 <pgstat_end_function_usage+0x90>
         :	        f_self = f_total;
         :	        INSTR_TIME_SUBTRACT(f_self, f_others);
    0.00 :	  64266c:       4c 89 cf                mov    %r9,%rdi
    0.00 :	  64266f:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  642672:       48 29 d7                sub    %rdx,%rdi
    0.00 :	  642675:       48 29 c6                sub    %rax,%rsi
    0.00 :	  642678:       79 13                   jns    64268d <pgstat_end_function_usage+0xbd>
    0.00 :	  64267a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  642680:       48 83 ef 01             sub    $0x1,%rdi
    0.00 :	  642684:       48 81 c6 40 42 0f 00    add    $0xf4240,%rsi
    0.00 :	  64268b:       78 f3                   js     642680 <pgstat_end_function_usage+0xb0>
         :
         :	        /* update backend-wide total time */
         :	        INSTR_TIME_ADD(total_func_time, f_self);
    0.00 :	  64268d:       4a 8d 04 06             lea    (%rsi,%r8,1),%rax
    0.00 :	  642691:       4a 8d 14 17             lea    (%rdi,%r10,1),%rdx
    0.00 :	  642695:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  64269b:       48 89 15 7e 98 53 00    mov    %rdx,0x53987e(%rip)        # b7bf20 <total_func_time>
    0.00 :	  6426a2:       48 89 05 7f 98 53 00    mov    %rax,0x53987f(%rip)        # b7bf28 <total_func_time+0x8>
    0.00 :	  6426a9:       7e 25                   jle    6426d0 <pgstat_end_function_usage+0x100>
    0.00 :	  6426ab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  6426b0:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  6426b6:       48 83 c2 01             add    $0x1,%rdx
         :	        INSTR_TIME_SUBTRACT(f_others, fcu->save_total);
         :	        f_self = f_total;
         :	        INSTR_TIME_SUBTRACT(f_self, f_others);
         :
         :	        /* update backend-wide total time */
         :	        INSTR_TIME_ADD(total_func_time, f_self);
    0.00 :	  6426ba:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6426c0:       7f ee                   jg     6426b0 <pgstat_end_function_usage+0xe0>
    0.00 :	  6426c2:       48 89 15 57 98 53 00    mov    %rdx,0x539857(%rip)        # b7bf20 <total_func_time>
    0.00 :	  6426c9:       48 89 05 58 98 53 00    mov    %rax,0x539858(%rip)        # b7bf28 <total_func_time+0x8>
         :	         * pre-call value of f_total_time.  This is necessary to avoid
         :	         * double-counting any time taken by recursive calls of myself.  (We do
         :	         * not need any similar kluge for self time, since that already excludes
         :	         * any recursive calls.)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
    0.00 :	  6426d0:       48 89 c8                mov    %rcx,%rax
    0.00 :	  6426d3:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	  6426d8:       4c 89 ca                mov    %r9,%rdx
    0.00 :	  6426db:       49 03 54 24 08          add    0x8(%r12),%rdx
    0.00 :	  6426e0:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6426e6:       48 89 45 d8             mov    %rax,-0x28(%rbp)
    0.00 :	  6426ea:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
    0.00 :	  6426ee:       7e 1a                   jle    64270a <pgstat_end_function_usage+0x13a>
    0.00 :	  6426f0:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  6426f6:       48 83 c2 01             add    $0x1,%rdx
         :	         * pre-call value of f_total_time.  This is necessary to avoid
         :	         * double-counting any time taken by recursive calls of myself.  (We do
         :	         * not need any similar kluge for self time, since that already excludes
         :	         * any recursive calls.)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
    0.00 :	  6426fa:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642700:       7f ee                   jg     6426f0 <pgstat_end_function_usage+0x120>
    0.00 :	  642702:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
    0.00 :	  642706:       48 89 45 d8             mov    %rax,-0x28(%rbp)
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
    0.00 :	  64270a:       45 84 ed                test   %r13b,%r13b
    0.00 :	  64270d:       75 61                   jne    642770 <pgstat_end_function_usage+0x1a0>
         :	                fs->f_numcalls++;
         :	        fs->f_total_time = f_total;
    0.00 :	  64270f:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  642713:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  642717:       48 8b 45 d8             mov    -0x28(%rbp),%rax
         :	        INSTR_TIME_ADD(fs->f_self_time, f_self);
    0.00 :	  64271b:       48 01 7b 18             add    %rdi,0x18(%rbx)
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
         :	                fs->f_numcalls++;
         :	        fs->f_total_time = f_total;
    0.00 :	  64271f:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	        INSTR_TIME_ADD(fs->f_self_time, f_self);
    0.00 :	  642723:       48 89 f0                mov    %rsi,%rax
    0.00 :	  642726:       48 03 43 20             add    0x20(%rbx),%rax
    0.00 :	  64272a:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642730:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  642734:       7e 21                   jle    642757 <pgstat_end_function_usage+0x187>
    0.00 :	  642736:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  64273d:       00 00 00 
    0.00 :	  642740:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  642746:       48 83 43 18 01          addq   $0x1,0x18(%rbx)
    0.00 :	  64274b:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642751:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  642755:       7f e9                   jg     642740 <pgstat_end_function_usage+0x170>
         :
         :	        /* indicate that we have something to send */
         :	        have_function_stats = true;
    0.00 :	  642757:       c6 05 4a 95 53 00 01    movb   $0x1,0x53954a(%rip)        # b7bca8 <have_function_stats>
         :	}
    0.00 :	  64275e:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  642762:       5b                      pop    %rbx
    0.00 :	  642763:       41 5c                   pop    %r12
    0.00 :	  642765:       41 5d                   pop    %r13
    0.00 :	  642767:       c9                      leaveq 
    0.00 :	  642768:       c3                      retq   
    0.00 :	  642769:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
         :	                fs->f_numcalls++;
    0.00 :	  642770:       48 83 03 01             addq   $0x1,(%rbx)
    0.00 :	  642774:       eb 99                   jmp    64270f <pgstat_end_function_usage+0x13f>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2812
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674b60 <IncrBufferRefCount>:
         :	 *              This function cannot be used on a buffer we do not have pinned,
         :	 *              because it doesn't change the shared buffer state.
         :	 */
         :	void
         :	IncrBufferRefCount(Buffer buffer)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2812
  100.00 :	  674b60:       55                      push   %rbp
    0.00 :	  674b61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674b64:       53                      push   %rbx
    0.00 :	  674b65:       89 fb                   mov    %edi,%ebx
    0.00 :	  674b67:       48 83 ec 08             sub    $0x8,%rsp
         :	        Assert(BufferIsPinned(buffer));
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  674b6b:       48 8b 3d 4e 5d 54 00    mov    0x545d4e(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674b72:       e8 f9 62 12 00          callq  79ae70 <ResourceOwnerEnlargeBuffers>
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);
    0.00 :	  674b77:       48 8b 3d 42 5d 54 00    mov    0x545d42(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674b7e:       89 de                   mov    %ebx,%esi
    0.00 :	  674b80:       e8 1b 56 12 00          callq  79a1a0 <ResourceOwnerRememberBuffer>
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674b85:       85 db                   test   %ebx,%ebx
    0.00 :	  674b87:       78 1f                   js     674ba8 <IncrBufferRefCount+0x48>
         :	                LocalRefCount[-buffer - 1]++;
         :	        else
         :	        {
         :	                PrivateRefCountEntry *ref;
         :	                ref = GetPrivateRefCountEntry(buffer, false, true);
    0.00 :	  674b89:       89 df                   mov    %ebx,%edi
    0.00 :	  674b8b:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  674b90:       31 f6                   xor    %esi,%esi
    0.00 :	  674b92:       e8 89 f9 ff ff          callq  674520 <GetPrivateRefCountEntry>
         :	                Assert(ref != NULL);
         :	                ref->refcount++;
    0.00 :	  674b97:       83 40 04 01             addl   $0x1,0x4(%rax)
         :	        }
         :	}
    0.00 :	  674b9b:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674b9f:       5b                      pop    %rbx
    0.00 :	  674ba0:       c9                      leaveq 
    0.00 :	  674ba1:       c3                      retq   
    0.00 :	  674ba2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	{
         :	        Assert(BufferIsPinned(buffer));
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);
         :	        if (BufferIsLocal(buffer))
         :	                LocalRefCount[-buffer - 1]++;
    0.00 :	  674ba8:       f7 d3                   not    %ebx
    0.00 :	  674baa:       48 63 c3                movslq %ebx,%rax
    0.00 :	  674bad:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  674bb1:       48 03 05 68 85 50 00    add    0x508568(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  674bb8:       83 00 01                addl   $0x1,(%rax)
         :	                PrivateRefCountEntry *ref;
         :	                ref = GetPrivateRefCountEntry(buffer, false, true);
         :	                Assert(ref != NULL);
         :	                ref->refcount++;
         :	        }
         :	}
    0.00 :	  674bbb:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674bbf:       5b                      pop    %rbx
    0.00 :	  674bc0:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000675260 <SyncOneBuffer>:
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675260:       55                      push   %rbp
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  675261:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  675266:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  675269:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  67526d:       48 63 df                movslq %edi,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675270:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  675274:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675278:       48 c1 e3 06             shl    $0x6,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  67527c:       48 83 ec 20             sub    $0x20,%rsp
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675280:       48 03 1d 79 a8 54 00    add    0x54a879(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675287:       41 89 f5                mov    %esi,%r13d
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
    0.00 :	  67528a:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  67528e:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
  100.00 :	  675291:       84 c0                   test   %al,%al
    0.00 :	  675293:       75 5b                   jne    6752f0 <SyncOneBuffer+0x90>
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  675295:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  675298:       85 c0                   test   %eax,%eax
    0.00 :	  67529a:       75 0f                   jne    6752ab <SyncOneBuffer+0x4b>
    0.00 :	  67529c:       0f b7 43 16             movzwl 0x16(%rbx),%eax
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752a0:       41 bc 02 00 00 00       mov    $0x2,%r12d
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  6752a6:       66 85 c0                test   %ax,%ax
    0.00 :	  6752a9:       74 08                   je     6752b3 <SyncOneBuffer+0x53>
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
    0.00 :	  6752ab:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752ae:       45 84 ed                test   %r13b,%r13b
    0.00 :	  6752b1:       75 2d                   jne    6752e0 <SyncOneBuffer+0x80>
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
         :	                return result;
         :	        }
         :
         :	        if (!(bufHdr->flags & BM_VALID) || !(bufHdr->flags & BM_DIRTY))
    0.00 :	  6752b3:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752b7:       a8 02                   test   $0x2,%al
    0.00 :	  6752b9:       74 08                   je     6752c3 <SyncOneBuffer+0x63>
    0.00 :	  6752bb:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752bf:       a8 01                   test   $0x1,%al
    0.00 :	  6752c1:       75 45                   jne    675308 <SyncOneBuffer+0xa8>
         :	        {
         :	                /* It's clean, so nothing to do */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752c3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  6752c7:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6752ca:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  6752ce:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6752d2:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  6752d6:       c9                      leaveq 
    0.00 :	  6752d7:       c3                      retq   
    0.00 :	  6752d8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  6752df:       00 
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752e0:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752e3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  6752e7:       eb de                   jmp    6752c7 <SyncOneBuffer+0x67>
    0.00 :	  6752e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
    0.00 :	  6752f0:       ba 4e 07 00 00          mov    $0x74e,%edx
    0.00 :	  6752f5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6752fa:       e8 41 ad 01 00          callq  690040 <s_lock>
    0.00 :	  6752ff:       eb 94                   jmp    675295 <SyncOneBuffer+0x35>
    0.00 :	  675301:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  675308:       48 89 df                mov    %rbx,%rdi
         :	        FlushBuffer(bufHdr, NULL);
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
    0.00 :	  67530b:       41 83 cc 01             or     $0x1,%r12d
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  67530f:       e8 bc f8 ff ff          callq  674bd0 <PinBuffer_Locked>
         :	        LWLockAcquire(bufHdr->content_lock, LW_SHARED);
    0.00 :	  675314:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675318:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67531d:       e8 ce a7 01 00          callq  68faf0 <LWLockAcquire>
         :
         :	        FlushBuffer(bufHdr, NULL);
    0.00 :	  675322:       31 f6                   xor    %esi,%esi
    0.00 :	  675324:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675327:       e8 24 fc ff ff          callq  674f50 <FlushBuffer>
         :
         :	        LWLockRelease(bufHdr->content_lock);
    0.00 :	  67532c:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675330:       e8 6b a0 01 00          callq  68f3a0 <LWLockRelease>
         :	        UnpinBuffer(bufHdr, true);
    0.00 :	  675335:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67533a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  67533d:       e8 ee f9 ff ff          callq  674d30 <UnpinBuffer>
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  675342:       eb 83                   jmp    6752c7 <SyncOneBuffer+0x67>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:509
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000676570 <ReadBufferExtended>:
         :	 * See buffer/README for details.
         :	 */
         :	Buffer
         :	ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,
         :	                                   ReadBufferMode mode, BufferAccessStrategy strategy)
         :	{
    0.00 :	  676570:       55                      push   %rbp
    0.00 :	  676571:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  676574:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  676578:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  67657c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  67657f:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  676583:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  676587:       41 89 cd                mov    %ecx,%r13d
    0.00 :	  67658a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  67658e:       48 83 ec 40             sub    $0x40,%rsp
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  676592:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
         :	 * See buffer/README for details.
         :	 */
         :	Buffer
         :	ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,
         :	                                   ReadBufferMode mode, BufferAccessStrategy strategy)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:509
  100.00 :	  676597:       41 89 f7                mov    %esi,%r15d
    0.00 :	  67659a:       41 89 d6                mov    %edx,%r14d
    0.00 :	  67659d:       4d 89 c4                mov    %r8,%r12
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  6765a0:       0f 84 aa 00 00 00       je     676650 <ReadBufferExtended+0xe0>
         :	        /*
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
    0.00 :	  6765a6:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  6765aa:       0f b6 50 6e             movzbl 0x6e(%rax),%edx
    0.00 :	  6765ae:       80 fa 74                cmp    $0x74,%dl
    0.00 :	  6765b1:       74 6d                   je     676620 <ReadBufferExtended+0xb0>
         :
         :	        /*
         :	         * Read the buffer, and update pgstat counters to reflect a cache hit or
         :	         * miss.
         :	         */
         :	        pgstat_count_buffer_read(reln);
    0.00 :	  6765b3:       48 8b 83 38 01 00 00    mov    0x138(%rbx),%rax
    0.00 :	  6765ba:       48 85 c0                test   %rax,%rax
    0.00 :	  6765bd:       74 0d                   je     6765cc <ReadBufferExtended+0x5c>
    0.00 :	  6765bf:       48 83 40 60 01          addq   $0x1,0x60(%rax)
    0.00 :	  6765c4:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  6765c8:       0f b6 50 6e             movzbl 0x6e(%rax),%edx
         :	        buf = ReadBuffer_common(reln->rd_smgr, reln->rd_rel->relpersistence,
    0.00 :	  6765cc:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	  6765d0:       48 8d 45 d7             lea    -0x29(%rbp),%rax
    0.00 :	  6765d4:       0f be f2                movsbl %dl,%esi
    0.00 :	  6765d7:       4d 89 e1                mov    %r12,%r9
    0.00 :	  6765da:       45 89 e8                mov    %r13d,%r8d
    0.00 :	  6765dd:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  6765e0:       44 89 fa                mov    %r15d,%edx
    0.00 :	  6765e3:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  6765e7:       e8 b4 f6 ff ff          callq  675ca0 <ReadBuffer_common>
         :	                                                        forkNum, blockNum, mode, strategy, &hit);
         :	        if (hit)
    0.00 :	  6765ec:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  6765f0:       74 11                   je     676603 <ReadBufferExtended+0x93>
         :	                pgstat_count_buffer_hit(reln);
    0.00 :	  6765f2:       48 8b 93 38 01 00 00    mov    0x138(%rbx),%rdx
    0.00 :	  6765f9:       48 85 d2                test   %rdx,%rdx
    0.00 :	  6765fc:       74 05                   je     676603 <ReadBufferExtended+0x93>
    0.00 :	  6765fe:       48 83 42 68 01          addq   $0x1,0x68(%rdx)
         :	        return buf;
         :	}
    0.00 :	  676603:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  676607:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  67660b:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  67660f:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  676613:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  676617:       c9                      leaveq 
    0.00 :	  676618:       c3                      retq   
    0.00 :	  676619:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
    0.00 :	  676620:       80 7b 20 00             cmpb   $0x0,0x20(%rbx)
    0.00 :	  676624:       75 8d                   jne    6765b3 <ReadBufferExtended+0x43>
         :	                ereport(ERROR,
    0.00 :	  676626:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  676629:       b9 c0 a0 8a 00          mov    $0x8aa0c0,%ecx
    0.00 :	  67662e:       ba 0c 02 00 00          mov    $0x20c,%edx
    0.00 :	  676633:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676638:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67663d:       e8 7e 44 10 00          callq  77aac0 <errstart>
    0.00 :	  676642:       84 c0                   test   %al,%al
    0.00 :	  676644:       75 29                   jne    67666f <ReadBufferExtended+0xff>
    0.00 :	  676646:       e8 85 2e df ff          callq  4694d0 <abort@plt>
    0.00 :	  67664b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	{
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  676650:       8b 57 1c                mov    0x1c(%rdi),%edx
    0.00 :	  676653:       8b 73 08                mov    0x8(%rbx),%esi
    0.00 :	  676656:       48 8b 3f                mov    (%rdi),%rdi
    0.00 :	  676659:       e8 d2 33 02 00          callq  699a30 <smgropen>
    0.00 :	  67665e:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  676662:       48 89 c6                mov    %rax,%rsi
    0.00 :	  676665:       e8 96 2c 02 00          callq  699300 <smgrsetowner>
    0.00 :	  67666a:       e9 37 ff ff ff          jmpq   6765a6 <ReadBufferExtended+0x36>
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
         :	                ereport(ERROR,
    0.00 :	  67666f:       bf 08 9f 8a 00          mov    $0x8a9f08,%edi
    0.00 :	  676674:       31 c0                   xor    %eax,%eax
    0.00 :	  676676:       e8 25 62 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67667b:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  676680:       89 c3                   mov    %eax,%ebx
    0.00 :	  676682:       e8 c9 66 10 00          callq  77cd50 <errcode>
    0.00 :	  676687:       89 de                   mov    %ebx,%esi
    0.00 :	  676689:       89 c7                   mov    %eax,%edi
    0.00 :	  67668b:       31 c0                   xor    %eax,%eax
    0.00 :	  67668d:       e8 4e 3f 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676692:       eb b2                   jmp    676646 <ReadBufferExtended+0xd6>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:410
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006767d0 <PrefetchBuffer>:
         :	 * block will not be delayed by the I/O.  Prefetching is optional.
         :	 * No-op if prefetching isn't compiled in.
         :	 */
         :	void
         :	PrefetchBuffer(Relation reln, ForkNumber forkNum, BlockNumber blockNum)
         :	{
    0.00 :	  6767d0:       55                      push   %rbp
    0.00 :	  6767d1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6767d4:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  6767d8:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  6767dc:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  6767df:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  6767e3:       48 83 ec 40             sub    $0x40,%rsp
         :	#ifdef USE_PREFETCH
         :	        Assert(RelationIsValid(reln));
         :	        Assert(BlockNumberIsValid(blockNum));
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  6767e7:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
         :	 * block will not be delayed by the I/O.  Prefetching is optional.
         :	 * No-op if prefetching isn't compiled in.
         :	 */
         :	void
         :	PrefetchBuffer(Relation reln, ForkNumber forkNum, BlockNumber blockNum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:410
  100.00 :	  6767ec:       41 89 f5                mov    %esi,%r13d
    0.00 :	  6767ef:       41 89 d4                mov    %edx,%r12d
         :	#ifdef USE_PREFETCH
         :	        Assert(RelationIsValid(reln));
         :	        Assert(BlockNumberIsValid(blockNum));
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  6767f2:       74 6c                   je     676860 <PrefetchBuffer+0x90>
         :
         :	        if (RelationUsesLocalBuffers(reln))
    0.00 :	  6767f4:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  6767f8:       80 78 6e 74             cmpb   $0x74,0x6e(%rax)
    0.00 :	  6767fc:       75 2a                   jne    676828 <PrefetchBuffer+0x58>
         :	        {
         :	                /* see comments in ReadBufferExtended */
         :	                if (RELATION_IS_OTHER_TEMP(reln))
    0.00 :	  6767fe:       80 7b 20 00             cmpb   $0x0,0x20(%rbx)
    0.00 :	  676802:       74 7b                   je     67687f <PrefetchBuffer+0xaf>
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
         :	                                errmsg("cannot access temporary tables of other sessions")));
         :
         :	                /* pass it off to localbuf.c */
         :	                LocalPrefetchBuffer(reln->rd_smgr, forkNum, blockNum);
    0.00 :	  676804:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	  676808:       44 89 e2                mov    %r12d,%edx
    0.00 :	  67680b:       44 89 ee                mov    %r13d,%esi
    0.00 :	  67680e:       e8 0d 1a 00 00          callq  678220 <LocalPrefetchBuffer>
         :	                 * real fix would involve some additional per-buffer state, and it's
         :	                 * not clear that there's enough of a problem to justify that.
         :	                 */
         :	        }
         :	#endif   /* USE_PREFETCH */
         :	}
    0.00 :	  676813:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  676817:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  67681b:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  67681f:       c9                      leaveq 
    0.00 :	  676820:       c3                      retq   
    0.00 :	  676821:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                BufferTag       newTag;         /* identity of requested block */
         :	                int                     buf_id;
         :
         :	                /* create a tag so we can lookup the buffer */
         :	                INIT_BUFFERTAG(newTag, reln->rd_smgr->smgr_rnode.node,
    0.00 :	  676828:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	                                           forkNum, blockNum);
         :
         :	                /* see if the block is in the buffer pool already */
         :	                buf_id = BufTableLookup(&newTag);
    0.00 :	  67682c:       48 8d 7d c0             lea    -0x40(%rbp),%rdi
         :	        {
         :	                BufferTag       newTag;         /* identity of requested block */
         :	                int                     buf_id;
         :
         :	                /* create a tag so we can lookup the buffer */
         :	                INIT_BUFFERTAG(newTag, reln->rd_smgr->smgr_rnode.node,
    0.00 :	  676830:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  676833:       48 89 45 c0             mov    %rax,-0x40(%rbp)
    0.00 :	  676837:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  67683a:       44 89 6d cc             mov    %r13d,-0x34(%rbp)
    0.00 :	  67683e:       44 89 65 d0             mov    %r12d,-0x30(%rbp)
    0.00 :	  676842:       89 45 c8                mov    %eax,-0x38(%rbp)
         :	                                           forkNum, blockNum);
         :
         :	                /* see if the block is in the buffer pool already */
         :	                buf_id = BufTableLookup(&newTag);
    0.00 :	  676845:       e8 96 d5 ff ff          callq  673de0 <BufTableLookup>
         :
         :	                /* If not in buffers, initiate prefetch */
         :	                if (buf_id < 0)
    0.00 :	  67684a:       85 c0                   test   %eax,%eax
    0.00 :	  67684c:       79 c5                   jns    676813 <PrefetchBuffer+0x43>
         :	                        smgrprefetch(reln->rd_smgr, forkNum, blockNum);
    0.00 :	  67684e:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	  676852:       44 89 e2                mov    %r12d,%edx
    0.00 :	  676855:       44 89 ee                mov    %r13d,%esi
    0.00 :	  676858:       e8 93 2b 02 00          callq  6993f0 <smgrprefetch>
    0.00 :	  67685d:       eb b4                   jmp    676813 <PrefetchBuffer+0x43>
    0.00 :	  67685f:       90                      nop
         :	#ifdef USE_PREFETCH
         :	        Assert(RelationIsValid(reln));
         :	        Assert(BlockNumberIsValid(blockNum));
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  676860:       8b 57 1c                mov    0x1c(%rdi),%edx
    0.00 :	  676863:       8b 73 08                mov    0x8(%rbx),%esi
    0.00 :	  676866:       48 8b 3f                mov    (%rdi),%rdi
    0.00 :	  676869:       e8 c2 31 02 00          callq  699a30 <smgropen>
    0.00 :	  67686e:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  676872:       48 89 c6                mov    %rax,%rsi
    0.00 :	  676875:       e8 86 2a 02 00          callq  699300 <smgrsetowner>
    0.00 :	  67687a:       e9 75 ff ff ff          jmpq   6767f4 <PrefetchBuffer+0x24>
         :
         :	        if (RelationUsesLocalBuffers(reln))
         :	        {
         :	                /* see comments in ReadBufferExtended */
         :	                if (RELATION_IS_OTHER_TEMP(reln))
         :	                        ereport(ERROR,
    0.00 :	  67687f:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  676882:       b9 d3 a0 8a 00          mov    $0x8aa0d3,%ecx
    0.00 :	  676887:       ba a8 01 00 00          mov    $0x1a8,%edx
    0.00 :	  67688c:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676891:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  676896:       e8 25 42 10 00          callq  77aac0 <errstart>
    0.00 :	  67689b:       84 c0                   test   %al,%al
    0.00 :	  67689d:       75 05                   jne    6768a4 <PrefetchBuffer+0xd4>
    0.00 :	  67689f:       e8 2c 2c df ff          callq  4694d0 <abort@plt>
    0.00 :	  6768a4:       bf 08 9f 8a 00          mov    $0x8a9f08,%edi
    0.00 :	  6768a9:       31 c0                   xor    %eax,%eax
    0.00 :	  6768ab:       e8 f0 5f 10 00          callq  77c8a0 <errmsg>
    0.00 :	  6768b0:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  6768b5:       89 c3                   mov    %eax,%ebx
    0.00 :	  6768b7:       e8 94 64 10 00          callq  77cd50 <errcode>
    0.00 :	  6768bc:       89 de                   mov    %ebx,%esi
    0.00 :	  6768be:       89 c7                   mov    %eax,%edi
    0.00 :	  6768c0:       31 c0                   xor    %eax,%eax
    0.00 :	  6768c2:       e8 19 3d 10 00          callq  77a5e0 <errfinish>
    0.00 :	  6768c7:       eb d6                   jmp    67689f <PrefetchBuffer+0xcf>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1448
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000679a90 <FileSeek>:
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679a90:       55                      push   %rbp
    0.00 :	  679a91:       89 f8                   mov    %edi,%eax
    0.00 :	  679a93:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  679a96:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679a9a:       4c 63 ef                movslq %edi,%r13
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679a9d:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679aa1:       49 c1 e5 06             shl    $0x6,%r13
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679aa5:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  679aa9:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679aad:       4d 89 ec                mov    %r13,%r12
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679ab0:       48 83 ec 20             sub    $0x20,%rsp
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679ab4:       4c 03 25 dd 36 50 00    add    0x5036dd(%rip),%r12        # b7d198 <VfdCache>
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679abb:       49 89 f6                mov    %rsi,%r14
    0.00 :	  679abe:       89 d3                   mov    %edx,%ebx
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679ac0:       41 8b 3c 24             mov    (%r12),%edi
 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1448
  100.00 :	  679ac4:       83 ff ff                cmp    $0xffffffff,%edi
    0.00 :	  679ac7:       74 6f                   je     679b38 <FileSeek+0xa8>
         :	                                break;
         :	                }
         :	        }
         :	        else
         :	        {
         :	                switch (whence)
    0.00 :	  679ac9:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  679acc:       0f 84 9e 00 00 00       je     679b70 <FileSeek+0xe0>
    0.00 :	  679ad2:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  679ad5:       0f 84 05 01 00 00       je     679be0 <FileSeek+0x150>
    0.00 :	  679adb:       85 db                   test   %ebx,%ebx
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679add:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679ae2:       be d7 05 00 00          mov    $0x5d7,%esi
         :	                                break;
         :	                }
         :	        }
         :	        else
         :	        {
         :	                switch (whence)
    0.00 :	  679ae7:       75 27                   jne    679b10 <FileSeek+0x80>
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679ae9:       4d 85 f6                test   %r14,%r14
    0.00 :	  679aec:       0f 88 28 01 00 00       js     679c1a <FileSeek+0x18a>
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                if (VfdCache[file].seekPos != offset)
    0.00 :	  679af2:       4d 39 74 24 20          cmp    %r14,0x20(%r12)
    0.00 :	  679af7:       0f 84 8b 00 00 00       je     679b88 <FileSeek+0xf8>
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679afd:       31 d2                   xor    %edx,%edx
    0.00 :	  679aff:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679b02:       e8 69 00 df ff          callq  469b70 <lseek@plt>
    0.00 :	  679b07:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679b0c:       eb 7a                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679b0e:       66 90                   xchg   %ax,%ax
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679b10:       bf f1 a2 8a 00          mov    $0x8aa2f1,%edi
    0.00 :	  679b15:       e8 06 19 10 00          callq  77b420 <elog_start>
    0.00 :	  679b1a:       89 da                   mov    %ebx,%edx
    0.00 :	  679b1c:       be 3a a3 8a 00          mov    $0x8aa33a,%esi
    0.00 :	  679b21:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  679b26:       31 c0                   xor    %eax,%eax
    0.00 :	  679b28:       e8 03 17 10 00          callq  77b230 <elog_finish>
    0.00 :	  679b2d:       e8 9e f9 de ff          callq  4694d0 <abort@plt>
    0.00 :	  679b32:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
    0.00 :	  679b38:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  679b3b:       0f 84 cf 00 00 00       je     679c10 <FileSeek+0x180>
    0.00 :	  679b41:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  679b44:       74 6a                   je     679bb0 <FileSeek+0x120>
    0.00 :	  679b46:       85 db                   test   %ebx,%ebx
         :	                                        return returnCode;
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679b48:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679b4d:       be bd 05 00 00          mov    $0x5bd,%esi
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
    0.00 :	  679b52:       75 bc                   jne    679b10 <FileSeek+0x80>
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679b54:       4d 85 f6                test   %r14,%r14
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
    0.00 :	  679b57:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679b5c:       be af 05 00 00          mov    $0x5af,%esi
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679b61:       0f 88 bd 00 00 00       js     679c24 <FileSeek+0x194>
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                VfdCache[file].seekPos = offset;
    0.00 :	  679b67:       4d 89 74 24 20          mov    %r14,0x20(%r12)
         :	                                break;
    0.00 :	  679b6c:       eb 1a                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679b6e:       66 90                   xchg   %ax,%ax
         :	                                if (VfdCache[file].seekPos != offset)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
    0.00 :	  679b70:       48 85 f6                test   %rsi,%rsi
    0.00 :	  679b73:       0f 85 7f 00 00 00       jne    679bf8 <FileSeek+0x168>
    0.00 :	  679b79:       49 83 7c 24 20 ff       cmpq   $0xffffffffffffffff,0x20(%r12)
    0.00 :	  679b7f:       90                      nop
    0.00 :	  679b80:       74 76                   je     679bf8 <FileSeek+0x168>
    0.00 :	  679b82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
         :	                                break;
         :	                }
         :	        }
         :	        return VfdCache[file].seekPos;
    0.00 :	  679b88:       48 8b 05 09 36 50 00    mov    0x503609(%rip),%rax        # b7d198 <VfdCache>
    0.00 :	  679b8f:       4a 8b 54 28 20          mov    0x20(%rax,%r13,1),%rdx
         :	}
    0.00 :	  679b94:       48 89 d0                mov    %rdx,%rax
    0.00 :	  679b97:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  679b9b:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  679ba0:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  679ba5:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  679baa:       c9                      leaveq 
    0.00 :	  679bab:       c3                      retq   
    0.00 :	  679bac:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
         :	                                break;
         :	                        case SEEK_END:
         :	                                returnCode = FileAccess(file);
    0.00 :	  679bb0:       89 c7                   mov    %eax,%edi
    0.00 :	  679bb2:       e8 69 fd ff ff          callq  679920 <FileAccess>
         :	                                if (returnCode < 0)
    0.00 :	  679bb7:       85 c0                   test   %eax,%eax
         :	                                        return returnCode;
    0.00 :	  679bb9:       48 63 d0                movslq %eax,%rdx
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
         :	                                break;
         :	                        case SEEK_END:
         :	                                returnCode = FileAccess(file);
         :	                                if (returnCode < 0)
    0.00 :	  679bbc:       78 d6                   js     679b94 <FileSeek+0x104>
         :	                                        return returnCode;
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679bbe:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  679bc1:       48 03 1d d0 35 50 00    add    0x5035d0(%rip),%rbx        # b7d198 <VfdCache>
    0.00 :	  679bc8:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  679bcd:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679bd0:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  679bd2:       e8 99 ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679bd7:       48 89 43 20             mov    %rax,0x20(%rbx)
         :	                                                                                           offset, whence);
         :	                                break;
    0.00 :	  679bdb:       eb ab                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679bdd:       0f 1f 00                nopl   (%rax)
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679be0:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  679be5:       e8 86 ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679bea:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679bef:       90                      nop
         :	                                                                                           offset, whence);
         :	                                break;
    0.00 :	  679bf0:       eb 96                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679bf2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679bf8:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  679bfd:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679c00:       e8 6b ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679c05:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679c0a:       e9 79 ff ff ff          jmpq   679b88 <FileSeek+0xf8>
    0.00 :	  679c0f:       90                      nop
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                VfdCache[file].seekPos = offset;
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
    0.00 :	  679c10:       49 01 74 24 20          add    %rsi,0x20(%r12)
         :	                                break;
    0.00 :	  679c15:       e9 6e ff ff ff          jmpq   679b88 <FileSeek+0xf8>
         :	        {
         :	                switch (whence)
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
    0.00 :	  679c1a:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679c1f:       be c8 05 00 00          mov    $0x5c8,%esi
    0.00 :	  679c24:       bf f1 a2 8a 00          mov    $0x8aa2f1,%edi
    0.00 :	  679c29:       e8 f2 17 10 00          callq  77b420 <elog_start>
    0.00 :	  679c2e:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  679c31:       be 21 a3 8a 00          mov    $0x8aa321,%esi
    0.00 :	  679c36:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  679c3b:       31 c0                   xor    %eax,%eax
    0.00 :	  679c3d:       e8 ee 15 10 00          callq  77b230 <elog_finish>
    0.00 :	  679c42:       e8 89 f8 de ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:976
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068faf0 <LWLockAcquire>:
         :	 *
         :	 * Side effect: cancel/die interrupts are held off until lock release.
         :	 */
         :	bool
         :	LWLockAcquire(LWLock *l, LWLockMode mode)
         :	{
    0.00 :	  68faf0:       55                      push   %rbp
    0.00 :	  68faf1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  68faf4:       41 57                   push   %r15
    0.00 :	  68faf6:       41 89 f7                mov    %esi,%r15d
    0.00 :	  68faf9:       41 56                   push   %r14
    0.00 :	  68fafb:       49 89 fe                mov    %rdi,%r14
    0.00 :	  68fafe:       41 55                   push   %r13
    0.00 :	  68fb00:       41 54                   push   %r12
    0.00 :	  68fb02:       53                      push   %rbx
    0.00 :	  68fb03:       48 83 ec 18             sub    $0x18,%rsp
         :	         * to catch unsafe coding practices.
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
    0.00 :	  68fb07:       81 3d f7 de 4e 00 c7    cmpl   $0xc7,0x4edef7(%rip)        # b7da08 <num_held_lwlocks>
    0.00 :	  68fb0e:       00 00 00 
         :
         :	/* internal function to implement LWLockAcquire and LWLockAcquireWithVar */
         :	static inline bool
         :	LWLockAcquireCommon(LWLock *lock, LWLockMode mode, uint64 *valptr, uint64 val)
         :	{
         :	        PGPROC     *proc = MyProc;
    0.00 :	  68fb11:       4c 8b 25 30 de 4e 00    mov    0x4ede30(%rip),%r12        # b7d948 <MyProc>
         :	         * to catch unsafe coding practices.
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
    0.00 :	  68fb18:       0f 8f 0c 01 00 00       jg     68fc2a <LWLockAcquire+0x13a>
         :	        /*
         :	         * Lock out cancel/die interrupts until we exit the code section protected
         :	         * by the LWLock.  This ensures that interrupts will not interfere with
         :	         * manipulations of data structures in shared memory.
         :	         */
         :	        HOLD_INTERRUPTS();
    0.00 :	  68fb1e:       8b 05 74 a5 52 00       mov    0x52a574(%rip),%eax        # bba098 <InterruptHoldoffCount>
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
         :
         :	                /* not waiting anymore */
         :	                pg_atomic_fetch_sub_u32(&lock->nwaiters, 1);
    0.00 :	  68fb24:       48 8d 57 08             lea    0x8(%rdi),%rdx
         :	                TRACE_POSTGRESQL_LWLOCK_WAIT_START(T_NAME(lock), T_ID(lock), mode);
         :
         :	                for (;;)
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fb28:       4d 8d 6c 24 10          lea    0x10(%r12),%r13
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
         :
         :	                /* not waiting anymore */
         :	                pg_atomic_fetch_sub_u32(&lock->nwaiters, 1);
    0.00 :	  68fb2d:       31 db                   xor    %ebx,%ebx
    0.00 :	  68fb2f:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
    0.00 :	  68fb33:       48 89 55 c8             mov    %rdx,-0x38(%rbp)
         :	        /*
         :	         * Lock out cancel/die interrupts until we exit the code section protected
         :	         * by the LWLock.  This ensures that interrupts will not interfere with
         :	         * manipulations of data structures in shared memory.
         :	         */
         :	        HOLD_INTERRUPTS();
    0.00 :	  68fb37:       83 c0 01                add    $0x1,%eax
    0.00 :	  68fb3a:       89 05 58 a5 52 00       mov    %eax,0x52a558(%rip)        # bba098 <InterruptHoldoffCount>
         :	                                break;
         :	                        extraWaits++;
         :	                }
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fb40:       48 8d 47 01             lea    0x1(%rdi),%rax
    0.00 :	  68fb44:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  68fb48:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  68fb4f:       00 
         :	                bool            mustwait;
         :
         :	                /*
         :	                 * try to grab the lock the first time, we're not in the waitqueue yet.
         :	                 */
         :	                mustwait = LWLockAttemptLock(lock, mode, NULL);
    0.00 :	  68fb50:       31 d2                   xor    %edx,%edx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:976
  100.00 :	  68fb52:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb55:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb58:       e8 63 f3 ff ff          callq  68eec0 <LWLockAttemptLock>
         :
         :	                if (!mustwait)
    0.00 :	  68fb5d:       84 c0                   test   %al,%al
    0.00 :	  68fb5f:       74 79                   je     68fbda <LWLockAcquire+0xea>
         :	                 * other lock will see our queue entries when releasing since they
         :	                 * existed before we checked for the lock.
         :	                 */
         :
         :	                /* add to the queue */
         :	                LWLockQueueSelf(lock, mode);
    0.00 :	  68fb61:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb64:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb67:       e8 14 f5 ff ff          callq  68f080 <LWLockQueueSelf>
         :
         :	                /* we're now guaranteed to be woken up if necessary */
         :	                mustwait = LWLockAttemptLock(lock, mode, NULL);
    0.00 :	  68fb6c:       31 d2                   xor    %edx,%edx
    0.00 :	  68fb6e:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb71:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb74:       e8 47 f3 ff ff          callq  68eec0 <LWLockAttemptLock>
         :
         :	                /* ok, grabbed the lock the second time round, need to undo queueing */
         :	                if (!mustwait)
    0.00 :	  68fb79:       84 c0                   test   %al,%al
    0.00 :	  68fb7b:       75 06                   jne    68fb83 <LWLockAcquire+0x93>
    0.00 :	  68fb7d:       eb 30                   jmp    68fbaf <LWLockAcquire+0xbf>
    0.00 :	  68fb7f:       90                      nop
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
         :	                        if (!proc->lwWaiting)
         :	                                break;
         :	                        extraWaits++;
    0.00 :	  68fb80:       83 c3 01                add    $0x1,%ebx
         :	                TRACE_POSTGRESQL_LWLOCK_WAIT_START(T_NAME(lock), T_ID(lock), mode);
         :
         :	                for (;;)
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fb83:       31 f6                   xor    %esi,%esi
    0.00 :	  68fb85:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fb88:       e8 93 85 fa ff          callq  638120 <PGSemaphoreLock>
         :	                        if (!proc->lwWaiting)
    0.00 :	  68fb8d:       41 80 7c 24 41 00       cmpb   $0x0,0x41(%r12)
    0.00 :	  68fb93:       75 eb                   jne    68fb80 <LWLockAcquire+0x90>
         :	                                break;
         :	                        extraWaits++;
         :	                }
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fb95:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  68fb99:       c6 00 01                movb   $0x1,(%rax)
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68fb9c:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68fba1:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  68fba5:       f0 0f c1 02             lock xadd %eax,(%rdx)
    0.00 :	  68fba9:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  68fbad:       eb a1                   jmp    68fb50 <LWLockAcquire+0x60>
         :	                        LOG_LWDEBUG("LWLockAcquire", lock, "acquired, undoing queue");
         :
         :	#ifdef LWLOCK_STATS
         :	                        lwstats->dequeue_self_count++;
         :	#endif
         :	                        if (!LWLockDequeueSelf(lock))
    0.00 :	  68fbaf:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fbb2:       e8 19 f6 ff ff          callq  68f1d0 <LWLockDequeueSelf>
    0.00 :	  68fbb7:       84 c0                   test   %al,%al
    0.00 :	  68fbb9:       75 1f                   jne    68fbda <LWLockAcquire+0xea>
    0.00 :	  68fbbb:       eb 06                   jmp    68fbc3 <LWLockAcquire+0xd3>
    0.00 :	  68fbbd:       0f 1f 00                nopl   (%rax)
         :	                                for (;;)
         :	                                {
         :	                                        PGSemaphoreLock(&proc->sem, false);
         :	                                        if (!proc->lwWaiting)
         :	                                                break;
         :	                                        extraWaits++;
    0.00 :	  68fbc0:       83 c3 01                add    $0x1,%ebx
         :	                                 * reset at some inconvenient point later, and releaseOk
         :	                                 * wouldn't be managed correctly.
         :	                                 */
         :	                                for (;;)
         :	                                {
         :	                                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fbc3:       31 f6                   xor    %esi,%esi
    0.00 :	  68fbc5:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fbc8:       e8 53 85 fa ff          callq  638120 <PGSemaphoreLock>
         :	                                        if (!proc->lwWaiting)
    0.00 :	  68fbcd:       41 80 7c 24 41 00       cmpb   $0x0,0x41(%r12)
    0.00 :	  68fbd3:       75 eb                   jne    68fbc0 <LWLockAcquire+0xd0>
         :	                                /*
         :	                                 * Reset releaseOk - if somebody woke us they'll have set it
         :	                                 * to false. No need for a barrier here - we got the lock and
         :	                                 * will perform wakeup if necessary.
         :	                                 */
         :	                                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fbd5:       41 c6 46 01 01          movb   $0x1,0x1(%r14)
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
    0.00 :	  68fbda:       8b 15 28 de 4e 00       mov    0x4ede28(%rip),%edx        # b7da08 <num_held_lwlocks>
    0.00 :	  68fbe0:       48 63 c2                movslq %edx,%rax
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbe3:       83 c2 01                add    $0x1,%edx
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
    0.00 :	  68fbe6:       48 c1 e0 04             shl    $0x4,%rax
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fbea:       85 db                   test   %ebx,%ebx
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbec:       89 15 16 de 4e 00       mov    %edx,0x4ede16(%rip)        # b7da08 <num_held_lwlocks>
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
    0.00 :	  68fbf2:       4c 89 b0 40 da b7 00    mov    %r14,0xb7da40(%rax)
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbf9:       44 89 b8 48 da b7 00    mov    %r15d,0xb7da48(%rax)
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fc00:       7e 15                   jle    68fc17 <LWLockAcquire+0x127>
    0.00 :	  68fc02:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                PGSemaphoreUnlock(&proc->sem);
    0.00 :	  68fc08:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fc0b:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  68fc0e:       e8 7d 84 fa ff          callq  638090 <PGSemaphoreUnlock>
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fc13:       85 db                   test   %ebx,%ebx
    0.00 :	  68fc15:       7f f1                   jg     68fc08 <LWLockAcquire+0x118>
         :	 */
         :	bool
         :	LWLockAcquire(LWLock *l, LWLockMode mode)
         :	{
         :	        return LWLockAcquireCommon(l, mode, NULL, 0);
         :	}
    0.00 :	  68fc17:       0f b6 45 c7             movzbl -0x39(%rbp),%eax
    0.00 :	  68fc1b:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  68fc1f:       5b                      pop    %rbx
    0.00 :	  68fc20:       41 5c                   pop    %r12
    0.00 :	  68fc22:       41 5d                   pop    %r13
    0.00 :	  68fc24:       41 5e                   pop    %r14
    0.00 :	  68fc26:       41 5f                   pop    %r15
    0.00 :	  68fc28:       c9                      leaveq 
    0.00 :	  68fc29:       c3                      retq   
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
         :	                elog(ERROR, "too many LWLocks taken");
    0.00 :	  68fc2a:       ba 70 d1 8a 00          mov    $0x8ad170,%edx
    0.00 :	  68fc2f:       be b0 03 00 00          mov    $0x3b0,%esi
    0.00 :	  68fc34:       bf 85 d0 8a 00          mov    $0x8ad085,%edi
    0.00 :	  68fc39:       e8 e2 b7 0e 00          callq  77b420 <elog_start>
    0.00 :	  68fc3e:       be 8e d0 8a 00          mov    $0x8ad08e,%esi
    0.00 :	  68fc43:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  68fc48:       31 c0                   xor    %eax,%eax
    0.00 :	  68fc4a:       e8 e1 b5 0e 00          callq  77b230 <elog_finish>
    0.00 :	  68fc4f:       e8 7c 98 dd ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:2518
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000694ba0 <PredicateLockTuple>:
         :	 * Skip if not in full serializable transaction isolation level.
         :	 * Skip if this is a temporary table.
         :	 */
         :	void
         :	PredicateLockTuple(Relation relation, HeapTuple tuple, Snapshot snapshot)
         :	{
    0.00 :	  694ba0:       55                      push   %rbp
    0.00 :	  694ba1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  694ba4:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  694ba8:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  694bac:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  694baf:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  694bb3:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  694bb7:       48 83 ec 30             sub    $0x30,%rsp
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694bbb:       48 8b 0d fe 9a 4e 00    mov    0x4e9afe(%rip),%rcx        # b7e6c0 <MySerializableXact>
         :	 * Skip if not in full serializable transaction isolation level.
         :	 * Skip if this is a temporary table.
         :	 */
         :	void
         :	PredicateLockTuple(Relation relation, HeapTuple tuple, Snapshot snapshot)
         :	{
    0.00 :	  694bc2:       49 89 f4                mov    %rsi,%r12
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694bc5:       48 85 c9                test   %rcx,%rcx
    0.00 :	  694bc8:       74 13                   je     694bdd <PredicateLockTuple+0x3d>
         :	         * This excludes things like CLUSTER and REINDEX. They use the wholesale
         :	         * functions TransferPredicateLocksToHeapRelation() and
         :	         * CheckTableForSerializableConflictIn() to participate serialization, but
         :	         * the scans involved don't need serialization.
         :	         */
         :	        if (!IsMVCCSnapshot(snapshot))
    0.00 :	  694bca:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  694bcd:       48 3d 50 57 7a 00       cmp    $0x7a5750,%rax
    0.00 :	  694bd3:       74 1b                   je     694bf0 <PredicateLockTuple+0x50>
    0.00 :	  694bd5:       48 3d 60 47 7a 00       cmp    $0x7a4760,%rax
    0.00 :	  694bdb:       74 13                   je     694bf0 <PredicateLockTuple+0x50>
         :	                                                                         relation->rd_node.dbNode,
         :	                                                                         relation->rd_id,
         :	                                                                         ItemPointerGetBlockNumber(tid),
         :	                                                                         ItemPointerGetOffsetNumber(tid));
         :	        PredicateLockAcquire(&tag);
         :	}
    0.00 :	  694bdd:       48 8b 5d e0             mov    -0x20(%rbp),%rbx
    0.00 :	  694be1:       4c 8b 65 e8             mov    -0x18(%rbp),%r12
    0.00 :	  694be5:       4c 8b 6d f0             mov    -0x10(%rbp),%r13
    0.00 :	  694be9:       4c 8b 75 f8             mov    -0x8(%rbp),%r14
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:2518
  100.00 :	  694bed:       c9                      leaveq 
    0.00 :	  694bee:       c3                      retq   
    0.00 :	  694bef:       90                      nop
         :	         *
         :	         * A transaction is flagged as RO_SAFE if all concurrent R/W transactions
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
    0.00 :	  694bf0:       80 79 7c 00             cmpb   $0x0,0x7c(%rcx)
    0.00 :	  694bf4:       0f 88 9e 00 00 00       js     694c98 <PredicateLockTuple+0xf8>
         :	 * relations are exempt, as are materialized views.
         :	 */
         :	static inline bool
         :	PredicateLockingNeededForRelation(Relation relation)
         :	{
         :	        return !(relation->rd_id < FirstBootstrapObjectId ||
    0.00 :	  694bfa:       8b 53 40                mov    0x40(%rbx),%edx
    0.00 :	  694bfd:       81 fa 0f 27 00 00       cmp    $0x270f,%edx
    0.00 :	  694c03:       76 d8                   jbe    694bdd <PredicateLockTuple+0x3d>
    0.00 :	  694c05:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  694c09:       80 78 6e 74             cmpb   $0x74,0x6e(%rax)
    0.00 :	  694c0d:       74 ce                   je     694bdd <PredicateLockTuple+0x3d>
    0.00 :	  694c0f:       80 78 6f 6d             cmpb   $0x6d,0x6f(%rax)
    0.00 :	  694c13:       74 c8                   je     694bdd <PredicateLockTuple+0x3d>
         :	                return;
         :
         :	        /*
         :	         * If it's a heap tuple, return if this xact wrote it.
         :	         */
         :	        if (relation->rd_index == NULL)
    0.00 :	  694c15:       48 83 bb a0 00 00 00    cmpq   $0x0,0xa0(%rbx)
    0.00 :	  694c1c:       00 
    0.00 :	  694c1d:       0f 84 85 00 00 00       je     694ca8 <PredicateLockTuple+0x108>
         :	         * Do quick-but-not-definitive test for a relation lock first.  This will
         :	         * never cause a return when the relation is *not* locked, but will
         :	         * occasionally let the check continue when there really *is* a relation
         :	         * level lock.
         :	         */
         :	        SET_PREDICATELOCKTARGETTAG_RELATION(tag,
    0.00 :	  694c23:       8b 43 04                mov    0x4(%rbx),%eax
         :	PredicateLockExists(const PREDICATELOCKTARGETTAG *targettag)
         :	{
         :	        LOCALPREDICATELOCK *lock;
         :
         :	        /* check local hash table */
         :	        lock = (LOCALPREDICATELOCK *) hash_search(LocalPredicateLockHash,
    0.00 :	  694c26:       4c 8d 6d d0             lea    -0x30(%rbp),%r13
    0.00 :	  694c2a:       48 8b 3d 9f 9a 4e 00    mov    0x4e9a9f(%rip),%rdi        # b7e6d0 <LocalPredicateLockHash>
         :	         * Do quick-but-not-definitive test for a relation lock first.  This will
         :	         * never cause a return when the relation is *not* locked, but will
         :	         * occasionally let the check continue when there really *is* a relation
         :	         * level lock.
         :	         */
         :	        SET_PREDICATELOCKTARGETTAG_RELATION(tag,
    0.00 :	  694c31:       89 55 d4                mov    %edx,-0x2c(%rbp)
         :	PredicateLockExists(const PREDICATELOCKTARGETTAG *targettag)
         :	{
         :	        LOCALPREDICATELOCK *lock;
         :
         :	        /* check local hash table */
         :	        lock = (LOCALPREDICATELOCK *) hash_search(LocalPredicateLockHash,
    0.00 :	  694c34:       31 c9                   xor    %ecx,%ecx
    0.00 :	  694c36:       31 d2                   xor    %edx,%edx
    0.00 :	  694c38:       4c 89 ee                mov    %r13,%rsi
         :	         * Do quick-but-not-definitive test for a relation lock first.  This will
         :	         * never cause a return when the relation is *not* locked, but will
         :	         * occasionally let the check continue when there really *is* a relation
         :	         * level lock.
         :	         */
         :	        SET_PREDICATELOCKTARGETTAG_RELATION(tag,
    0.00 :	  694c3b:       c7 45 d8 ff ff ff ff    movl   $0xffffffff,-0x28(%rbp)
    0.00 :	  694c42:       c7 45 dc 00 00 00 00    movl   $0x0,-0x24(%rbp)
    0.00 :	  694c49:       89 45 d0                mov    %eax,-0x30(%rbp)
         :	PredicateLockExists(const PREDICATELOCKTARGETTAG *targettag)
         :	{
         :	        LOCALPREDICATELOCK *lock;
         :
         :	        /* check local hash table */
         :	        lock = (LOCALPREDICATELOCK *) hash_search(LocalPredicateLockHash,
    0.00 :	  694c4c:       e8 4f fa 0e 00          callq  7846a0 <hash_search>
         :	                                                                                          targettag,
         :	                                                                                          HASH_FIND, NULL);
         :
         :	        if (!lock)
    0.00 :	  694c51:       48 85 c0                test   %rax,%rax
    0.00 :	  694c54:       74 06                   je     694c5c <PredicateLockTuple+0xbc>
         :	         * level lock.
         :	         */
         :	        SET_PREDICATELOCKTARGETTAG_RELATION(tag,
         :	                                                                                relation->rd_node.dbNode,
         :	                                                                                relation->rd_id);
         :	        if (PredicateLockExists(&tag))
    0.00 :	  694c56:       80 78 10 00             cmpb   $0x0,0x10(%rax)
    0.00 :	  694c5a:       75 81                   jne    694bdd <PredicateLockTuple+0x3d>
         :	                return;
         :
         :	        tid = &(tuple->t_self);
         :	        SET_PREDICATELOCKTARGETTAG_TUPLE(tag,
    0.00 :	  694c5c:       8b 43 04                mov    0x4(%rbx),%eax
    0.00 :	  694c5f:       41 0f b7 54 24 06       movzwl 0x6(%r12),%edx
         :	                                                                         relation->rd_node.dbNode,
         :	                                                                         relation->rd_id,
         :	                                                                         ItemPointerGetBlockNumber(tid),
         :	                                                                         ItemPointerGetOffsetNumber(tid));
         :	        PredicateLockAcquire(&tag);
    0.00 :	  694c65:       4c 89 ef                mov    %r13,%rdi
         :	                                                                                relation->rd_id);
         :	        if (PredicateLockExists(&tag))
         :	                return;
         :
         :	        tid = &(tuple->t_self);
         :	        SET_PREDICATELOCKTARGETTAG_TUPLE(tag,
    0.00 :	  694c68:       89 45 d0                mov    %eax,-0x30(%rbp)
    0.00 :	  694c6b:       8b 43 40                mov    0x40(%rbx),%eax
    0.00 :	  694c6e:       89 45 d4                mov    %eax,-0x2c(%rbp)
    0.00 :	  694c71:       41 0f b7 44 24 04       movzwl 0x4(%r12),%eax
    0.00 :	  694c77:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  694c7a:       09 d0                   or     %edx,%eax
    0.00 :	  694c7c:       89 45 d8                mov    %eax,-0x28(%rbp)
    0.00 :	  694c7f:       41 0f b7 44 24 08       movzwl 0x8(%r12),%eax
    0.00 :	  694c85:       89 45 dc                mov    %eax,-0x24(%rbp)
         :	                                                                         relation->rd_node.dbNode,
         :	                                                                         relation->rd_id,
         :	                                                                         ItemPointerGetBlockNumber(tid),
         :	                                                                         ItemPointerGetOffsetNumber(tid));
         :	        PredicateLockAcquire(&tag);
    0.00 :	  694c88:       e8 a3 d3 ff ff          callq  692030 <PredicateLockAcquire>
    0.00 :	  694c8d:       e9 4b ff ff ff          jmpq   694bdd <PredicateLockTuple+0x3d>
    0.00 :	  694c92:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
         :	        {
         :	                ReleasePredicateLocks(false);
    0.00 :	  694c98:       31 ff                   xor    %edi,%edi
    0.00 :	  694c9a:       e8 51 dc ff ff          callq  6928f0 <ReleasePredicateLocks>
    0.00 :	  694c9f:       90                      nop
    0.00 :	  694ca0:       e9 38 ff ff ff          jmpq   694bdd <PredicateLockTuple+0x3d>
    0.00 :	  694ca5:       0f 1f 00                nopl   (%rax)
         :	         */
         :	        if (relation->rd_index == NULL)
         :	        {
         :	                TransactionId myxid;
         :
         :	                targetxmin = HeapTupleHeaderGetXmin(tuple->t_data);
    0.00 :	  694ca8:       49 8b 54 24 10          mov    0x10(%r12),%rdx
    0.00 :	  694cad:       41 bd 02 00 00 00       mov    $0x2,%r13d
    0.00 :	  694cb3:       0f b7 42 14             movzwl 0x14(%rdx),%eax
    0.00 :	  694cb7:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  694cbc:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  694cc1:       74 03                   je     694cc6 <PredicateLockTuple+0x126>
    0.00 :	  694cc3:       44 8b 2a                mov    (%rdx),%r13d
         :
         :	                myxid = GetTopTransactionIdIfAny();
    0.00 :	  694cc6:       e8 b5 be e2 ff          callq  4c0b80 <GetTopTransactionIdIfAny>
         :	                if (TransactionIdIsValid(myxid))
    0.00 :	  694ccb:       85 c0                   test   %eax,%eax
         :	        {
         :	                TransactionId myxid;
         :
         :	                targetxmin = HeapTupleHeaderGetXmin(tuple->t_data);
         :
         :	                myxid = GetTopTransactionIdIfAny();
    0.00 :	  694ccd:       41 89 c6                mov    %eax,%r14d
         :	                if (TransactionIdIsValid(myxid))
    0.00 :	  694cd0:       75 0e                   jne    694ce0 <PredicateLockTuple+0x140>
         :	                                TransactionId xid = SubTransGetTopmostTransaction(targetxmin);
         :
         :	                                if (TransactionIdEquals(xid, myxid))
         :	                                {
         :	                                        /* We wrote it; we already have a write lock. */
         :	                                        return;
    0.00 :	  694cd2:       8b 53 40                mov    0x40(%rbx),%edx
    0.00 :	  694cd5:       e9 49 ff ff ff          jmpq   694c23 <PredicateLockTuple+0x83>
    0.00 :	  694cda:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                targetxmin = HeapTupleHeaderGetXmin(tuple->t_data);
         :
         :	                myxid = GetTopTransactionIdIfAny();
         :	                if (TransactionIdIsValid(myxid))
         :	                {
         :	                        if (TransactionIdFollowsOrEquals(targetxmin, TransactionXmin))
    0.00 :	  694ce0:       8b 35 72 da 4d 00       mov    0x4dda72(%rip),%esi        # b72758 <TransactionXmin>
    0.00 :	  694ce6:       44 89 ef                mov    %r13d,%edi
    0.00 :	  694ce9:       e8 82 b3 e2 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  694cee:       84 c0                   test   %al,%al
    0.00 :	  694cf0:       74 e0                   je     694cd2 <PredicateLockTuple+0x132>
         :	                        {
         :	                                TransactionId xid = SubTransGetTopmostTransaction(targetxmin);
    0.00 :	  694cf2:       44 89 ef                mov    %r13d,%edi
    0.00 :	  694cf5:       e8 f6 1b e3 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :
         :	                                if (TransactionIdEquals(xid, myxid))
    0.00 :	  694cfa:       41 39 c6                cmp    %eax,%r14d
    0.00 :	  694cfd:       75 d3                   jne    694cd2 <PredicateLockTuple+0x132>
    0.00 :	  694cff:       90                      nop
    0.00 :	  694d00:       e9 d8 fe ff ff          jmpq   694bdd <PredicateLockTuple+0x3d>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/arrayutils.c:90
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006c4350 <ArrayGetNItems>:
         :	 * arithmetic, but that is nearly all platforms these days, and doing check
         :	 * divides for those that don't seems way too expensive.
         :	 */
         :	int
         :	ArrayGetNItems(int ndim, const int *dims)
         :	{
    0.00 :	  6c4350:       55                      push   %rbp
    0.00 :	  6c4351:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6c4354:       53                      push   %rbx
    0.00 :	  6c4355:       48 83 ec 08             sub    $0x8,%rsp
         :	        int32           ret;
         :	        int                     i;
         :
         :	#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))
         :
         :	        if (ndim <= 0)
    0.00 :	  6c4359:       85 ff                   test   %edi,%edi
    0.00 :	  6c435b:       7e 43                   jle    6c43a0 <ArrayGetNItems+0x50>
    0.00 :	  6c435d:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  6c4363:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6c4365:       0f 1f 00                nopl   (%rax)
         :	        for (i = 0; i < ndim; i++)
         :	        {
         :	                int64           prod;
         :
         :	                /* A negative dimension implies that UB-LB overflowed ... */
         :	                if (dims[i] < 0)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/arrayutils.c:90
  100.00 :	  6c4368:       8b 16                   mov    (%rsi),%edx
    0.00 :	  6c436a:       85 d2                   test   %edx,%edx
    0.00 :	  6c436c:       78 3f                   js     6c43ad <ArrayGetNItems+0x5d>
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :
         :	                prod = (int64) ret *(int64) dims[i];
    0.00 :	  6c436e:       49 63 c0                movslq %r8d,%rax
    0.00 :	  6c4371:       48 63 d2                movslq %edx,%rdx
    0.00 :	  6c4374:       48 0f af c2             imul   %rdx,%rax
         :
         :	                ret = (int32) prod;
         :	                if ((int64) ret != prod)
    0.00 :	  6c4378:       48 63 d0                movslq %eax,%rdx
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :
         :	                prod = (int64) ret *(int64) dims[i];
         :
         :	                ret = (int32) prod;
    0.00 :	  6c437b:       41 89 c0                mov    %eax,%r8d
         :	                if ((int64) ret != prod)
    0.00 :	  6c437e:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  6c4381:       75 4f                   jne    6c43d2 <ArrayGetNItems+0x82>
         :	#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))
         :
         :	        if (ndim <= 0)
         :	                return 0;
         :	        ret = 1;
         :	        for (i = 0; i < ndim; i++)
    0.00 :	  6c4383:       83 c1 01                add    $0x1,%ecx
    0.00 :	  6c4386:       48 83 c6 04             add    $0x4,%rsi
    0.00 :	  6c438a:       39 cf                   cmp    %ecx,%edi
    0.00 :	  6c438c:       7f da                   jg     6c4368 <ArrayGetNItems+0x18>
         :	                                        (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :	        }
         :	        Assert(ret >= 0);
         :	        if ((Size) ret > MaxArraySize)
    0.00 :	  6c438e:       81 fa ff ff ff 07       cmp    $0x7ffffff,%edx
    0.00 :	  6c4394:       77 75                   ja     6c440b <ArrayGetNItems+0xbb>
         :	                ereport(ERROR,
         :	                                (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
         :	                                 errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                (int) MaxArraySize)));
         :	        return (int) ret;
         :	}
    0.00 :	  6c4396:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  6c439a:       44 89 c0                mov    %r8d,%eax
    0.00 :	  6c439d:       5b                      pop    %rbx
    0.00 :	  6c439e:       c9                      leaveq 
    0.00 :	  6c439f:       c3                      retq   
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :	        }
         :	        Assert(ret >= 0);
         :	        if ((Size) ret > MaxArraySize)
         :	                ereport(ERROR,
    0.00 :	  6c43a0:       45 31 c0                xor    %r8d,%r8d
         :	                                (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
         :	                                 errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                (int) MaxArraySize)));
         :	        return (int) ret;
         :	}
    0.00 :	  6c43a3:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  6c43a7:       44 89 c0                mov    %r8d,%eax
    0.00 :	  6c43aa:       5b                      pop    %rbx
    0.00 :	  6c43ab:       c9                      leaveq 
    0.00 :	  6c43ac:       c3                      retq   
         :	        {
         :	                int64           prod;
         :
         :	                /* A negative dimension implies that UB-LB overflowed ... */
         :	                if (dims[i] < 0)
         :	                        ereport(ERROR,
    0.00 :	  6c43ad:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6c43b0:       b9 b7 8d 8b 00          mov    $0x8b8db7,%ecx
    0.00 :	  6c43b5:       ba 5e 00 00 00          mov    $0x5e,%edx
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :	        }
         :	        Assert(ret >= 0);
         :	        if ((Size) ret > MaxArraySize)
         :	                ereport(ERROR,
    0.00 :	  6c43ba:       be 0c 8d 8b 00          mov    $0x8b8d0c,%esi
    0.00 :	  6c43bf:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  6c43c4:       e8 f7 66 0b 00          callq  77aac0 <errstart>
    0.00 :	  6c43c9:       84 c0                   test   %al,%al
    0.00 :	  6c43cb:       75 14                   jne    6c43e1 <ArrayGetNItems+0x91>
    0.00 :	  6c43cd:       e8 fe 50 da ff          callq  4694d0 <abort@plt>
         :
         :	                prod = (int64) ret *(int64) dims[i];
         :
         :	                ret = (int32) prod;
         :	                if ((int64) ret != prod)
         :	                        ereport(ERROR,
    0.00 :	  6c43d2:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6c43d5:       b9 b7 8d 8b 00          mov    $0x8b8db7,%ecx
    0.00 :	  6c43da:       ba 67 00 00 00          mov    $0x67,%edx
    0.00 :	  6c43df:       eb d9                   jmp    6c43ba <ArrayGetNItems+0x6a>
         :	                                         errmsg("array size exceeds the maximum allowed (%d)",
         :	                                                        (int) MaxArraySize)));
         :	        }
         :	        Assert(ret >= 0);
         :	        if ((Size) ret > MaxArraySize)
         :	                ereport(ERROR,
    0.00 :	  6c43e1:       be ff ff ff 07          mov    $0x7ffffff,%esi
    0.00 :	  6c43e6:       bf a0 82 8b 00          mov    $0x8b82a0,%edi
    0.00 :	  6c43eb:       31 c0                   xor    %eax,%eax
    0.00 :	  6c43ed:       e8 ae 84 0b 00          callq  77c8a0 <errmsg>
    0.00 :	  6c43f2:       bf 05 01 00 00          mov    $0x105,%edi
    0.00 :	  6c43f7:       89 c3                   mov    %eax,%ebx
    0.00 :	  6c43f9:       e8 52 89 0b 00          callq  77cd50 <errcode>
    0.00 :	  6c43fe:       89 de                   mov    %ebx,%esi
    0.00 :	  6c4400:       89 c7                   mov    %eax,%edi
    0.00 :	  6c4402:       31 c0                   xor    %eax,%eax
    0.00 :	  6c4404:       e8 d7 61 0b 00          callq  77a5e0 <errfinish>
    0.00 :	  6c4409:       eb c2                   jmp    6c43cd <ArrayGetNItems+0x7d>
    0.00 :	  6c440b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6c440e:       b9 b7 8d 8b 00          mov    $0x8b8db7,%ecx
    0.00 :	  6c4413:       ba 6e 00 00 00          mov    $0x6e,%edx
    0.00 :	  6c4418:       eb a0                   jmp    6c43ba <ArrayGetNItems+0x6a>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int8.c:776
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006ed200 <int8inc_any>:
         :	 * test would complain about mismatched entries for a built-in function.
         :	 */
         :
         :	Datum
         :	int8inc_any(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int8.c:776
  100.00 :	  6ed200:       55                      push   %rbp
    0.00 :	  6ed201:       48 89 e5                mov    %rsp,%rbp
         :	        return int8inc(fcinfo);
         :	}
    0.00 :	  6ed204:       c9                      leaveq 
         :	 */
         :
         :	Datum
         :	int8inc_any(PG_FUNCTION_ARGS)
         :	{
         :	        return int8inc(fcinfo);
    0.00 :	  6ed205:       e9 76 ff ff ff          jmpq   6ed180 <int8inc>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/like_match.c:96
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006fbc00 <SB_MatchText>:
         :	#endif
         :
         :	static int
         :	MatchText(char *t, int tlen, char *p, int plen,
         :	                  pg_locale_t locale, bool locale_is_c)
         :	{
    0.00 :	  6fbc00:       55                      push   %rbp
    0.00 :	  6fbc01:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6fbc04:       41 57                   push   %r15
    0.00 :	  6fbc06:       41 56                   push   %r14
    0.00 :	  6fbc08:       41 55                   push   %r13
    0.00 :	  6fbc0a:       41 54                   push   %r12
    0.00 :	  6fbc0c:       53                      push   %rbx
    0.00 :	  6fbc0d:       48 83 ec 18             sub    $0x18,%rsp
         :	        /* Fast path for match-everything pattern */
         :	        if (plen == 1 && *p == '%')
    0.00 :	  6fbc11:       83 f9 01                cmp    $0x1,%ecx
         :	#endif
         :
         :	static int
         :	MatchText(char *t, int tlen, char *p, int plen,
         :	                  pg_locale_t locale, bool locale_is_c)
         :	{
    0.00 :	  6fbc14:       4c 89 45 d0             mov    %r8,-0x30(%rbp)
         :	        /* Fast path for match-everything pattern */
         :	        if (plen == 1 && *p == '%')
    0.00 :	  6fbc18:       0f 84 82 00 00 00       je     6fbca0 <SB_MatchText+0xa0>
    0.00 :	  6fbc1e:       66 90                   xchg   %ax,%ax
         :	                 * on character boundaries.  And we know that no backend-legal
         :	                 * encoding allows ASCII characters such as '%' to appear as non-first
         :	                 * bytes of characters, so we won't mistakenly detect a new wildcard.
         :	                 */
         :	                NextByte(t, tlen);
         :	                NextByte(p, plen);
    0.00 :	  6fbc20:       48 83 c7 01             add    $0x1,%rdi
         :	         * occasions it is safe to advance by byte, as the text and pattern will
         :	         * be in lockstep. This allows us to perform all comparisons between the
         :	         * text and pattern on a byte by byte basis, even for multi-byte
         :	         * encodings.
         :	         */
         :	        while (tlen > 0 && plen > 0)
    0.00 :	  6fbc24:       85 f6                   test   %esi,%esi
         :	                 * on character boundaries.  And we know that no backend-legal
         :	                 * encoding allows ASCII characters such as '%' to appear as non-first
         :	                 * bytes of characters, so we won't mistakenly detect a new wildcard.
         :	                 */
         :	                NextByte(t, tlen);
         :	                NextByte(p, plen);
    0.00 :	  6fbc26:       89 f3                   mov    %esi,%ebx
    0.00 :	  6fbc28:       4c 8d 67 ff             lea    -0x1(%rdi),%r12
         :	         * occasions it is safe to advance by byte, as the text and pattern will
         :	         * be in lockstep. This allows us to perform all comparisons between the
         :	         * text and pattern on a byte by byte basis, even for multi-byte
         :	         * encodings.
         :	         */
         :	        while (tlen > 0 && plen > 0)
    0.00 :	  6fbc2c:       0f 9f c0                setg   %al
    0.00 :	  6fbc2f:       7f 1f                   jg     6fbc50 <SB_MatchText+0x50>
         :	                 */
         :	                NextByte(t, tlen);
         :	                NextByte(p, plen);
         :	        }
         :
         :	        if (tlen > 0)
    0.00 :	  6fbc31:       84 c0                   test   %al,%al
    0.00 :	  6fbc33:       0f 84 e3 00 00 00       je     6fbd1c <SB_MatchText+0x11c>
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbc39:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * End of text with no match, so no point in trying later places to start
         :	         * matching this pattern.
         :	         */
         :	        return LIKE_ABORT;
         :	}       /* MatchText() */
    0.00 :	  6fbc3b:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  6fbc3f:       5b                      pop    %rbx
    0.00 :	  6fbc40:       41 5c                   pop    %r12
    0.00 :	  6fbc42:       41 5d                   pop    %r13
    0.00 :	  6fbc44:       41 5e                   pop    %r14
    0.00 :	  6fbc46:       41 5f                   pop    %r15
    0.00 :	  6fbc48:       c9                      leaveq 
    0.00 :	  6fbc49:       c3                      retq   
    0.00 :	  6fbc4a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * occasions it is safe to advance by byte, as the text and pattern will
         :	         * be in lockstep. This allows us to perform all comparisons between the
         :	         * text and pattern on a byte by byte basis, even for multi-byte
         :	         * encodings.
         :	         */
         :	        while (tlen > 0 && plen > 0)
    0.00 :	  6fbc50:       85 c9                   test   %ecx,%ecx
    0.00 :	  6fbc52:       7e dd                   jle    6fbc31 <SB_MatchText+0x31>
         :	        {
         :	                if (*p == '\\')
    0.00 :	  6fbc54:       0f b6 02                movzbl (%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/like_match.c:96
  100.00 :	  6fbc57:       3c 5c                   cmp    $0x5c,%al
    0.00 :	  6fbc59:       74 25                   je     6fbc80 <SB_MatchText+0x80>
         :	                                                (errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),
         :	                                 errmsg("LIKE pattern must not end with escape character")));
         :	                        if (GETCHAR(*p) != GETCHAR(*t))
         :	                                return LIKE_FALSE;
         :	                }
         :	                else if (*p == '%')
    0.00 :	  6fbc5b:       3c 25                   cmp    $0x25,%al
    0.00 :	  6fbc5d:       0f 1f 00                nopl   (%rax)
    0.00 :	  6fbc60:       74 5e                   je     6fbcc0 <SB_MatchText+0xc0>
         :	                         * End of text with no match, so no point in trying later places
         :	                         * to start matching this pattern.
         :	                         */
         :	                        return LIKE_ABORT;
         :	                }
         :	                else if (*p == '_')
    0.00 :	  6fbc62:       3c 5f                   cmp    $0x5f,%al
    0.00 :	  6fbc64:       74 05                   je     6fbc6b <SB_MatchText+0x6b>
         :	                        /* _ matches any single character, and we know there is one */
         :	                        NextChar(t, tlen);
         :	                        NextByte(p, plen);
         :	                        continue;
         :	                }
         :	                else if (GETCHAR(*p) != GETCHAR(*t))
    0.00 :	  6fbc66:       3a 47 ff                cmp    -0x1(%rdi),%al
    0.00 :	  6fbc69:       75 ce                   jne    6fbc39 <SB_MatchText+0x39>
         :	                 * on character boundaries.  And we know that no backend-legal
         :	                 * encoding allows ASCII characters such as '%' to appear as non-first
         :	                 * bytes of characters, so we won't mistakenly detect a new wildcard.
         :	                 */
         :	                NextByte(t, tlen);
         :	                NextByte(p, plen);
    0.00 :	  6fbc6b:       48 83 c2 01             add    $0x1,%rdx
    0.00 :	  6fbc6f:       83 e9 01                sub    $0x1,%ecx
    0.00 :	  6fbc72:       83 ee 01                sub    $0x1,%esi
    0.00 :	  6fbc75:       eb a9                   jmp    6fbc20 <SB_MatchText+0x20>
    0.00 :	  6fbc77:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6fbc7e:       00 00 
         :	        while (tlen > 0 && plen > 0)
         :	        {
         :	                if (*p == '\\')
         :	                {
         :	                        /* Next pattern byte must match literally, whatever it is */
         :	                        NextByte(p, plen);
    0.00 :	  6fbc80:       83 e9 01                sub    $0x1,%ecx
         :	                        /* ... and there had better be one, per SQL standard */
         :	                        if (plen <= 0)
    0.00 :	  6fbc83:       85 c9                   test   %ecx,%ecx
    0.00 :	  6fbc85:       0f 8e 1f 01 00 00       jle    6fbdaa <SB_MatchText+0x1aa>
         :	        while (tlen > 0 && plen > 0)
         :	        {
         :	                if (*p == '\\')
         :	                {
         :	                        /* Next pattern byte must match literally, whatever it is */
         :	                        NextByte(p, plen);
    0.00 :	  6fbc8b:       48 83 c2 01             add    $0x1,%rdx
         :	                        /* ... and there had better be one, per SQL standard */
         :	                        if (plen <= 0)
         :	                                ereport(ERROR,
         :	                                                (errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),
         :	                                 errmsg("LIKE pattern must not end with escape character")));
         :	                        if (GETCHAR(*p) != GETCHAR(*t))
    0.00 :	  6fbc8f:       0f b6 02                movzbl (%rdx),%eax
    0.00 :	  6fbc92:       3a 47 ff                cmp    -0x1(%rdi),%al
    0.00 :	  6fbc95:       74 d4                   je     6fbc6b <SB_MatchText+0x6b>
    0.00 :	  6fbc97:       eb a0                   jmp    6fbc39 <SB_MatchText+0x39>
    0.00 :	  6fbc99:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	static int
         :	MatchText(char *t, int tlen, char *p, int plen,
         :	                  pg_locale_t locale, bool locale_is_c)
         :	{
         :	        /* Fast path for match-everything pattern */
         :	        if (plen == 1 && *p == '%')
    0.00 :	  6fbca0:       80 3a 25                cmpb   $0x25,(%rdx)
    0.00 :	  6fbca3:       0f 85 77 ff ff ff       jne    6fbc20 <SB_MatchText+0x20>
         :	        /*
         :	         * End of text with no match, so no point in trying later places to start
         :	         * matching this pattern.
         :	         */
         :	        return LIKE_ABORT;
         :	}       /* MatchText() */
    0.00 :	  6fbca9:       48 83 c4 18             add    $0x18,%rsp
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbcad:       b8 01 00 00 00          mov    $0x1,%eax
         :	        /*
         :	         * End of text with no match, so no point in trying later places to start
         :	         * matching this pattern.
         :	         */
         :	        return LIKE_ABORT;
         :	}       /* MatchText() */
    0.00 :	  6fbcb2:       5b                      pop    %rbx
    0.00 :	  6fbcb3:       41 5c                   pop    %r12
    0.00 :	  6fbcb5:       41 5d                   pop    %r13
    0.00 :	  6fbcb7:       41 5e                   pop    %r14
    0.00 :	  6fbcb9:       41 5f                   pop    %r15
    0.00 :	  6fbcbb:       c9                      leaveq 
    0.00 :	  6fbcbc:       c3                      retq   
    0.00 :	  6fbcbd:       0f 1f 00                nopl   (%rax)
         :	                         * fragment that begins with a literal character-to-match, thereby
         :	                         * not recursing more than we have to.
         :	                         */
         :	                        NextByte(p, plen);
         :
         :	                        while (plen > 0)
    0.00 :	  6fbcc0:       8d 41 ff                lea    -0x1(%rcx),%eax
    0.00 :	  6fbcc3:       85 c0                   test   %eax,%eax
    0.00 :	  6fbcc5:       7e e2                   jle    6fbca9 <SB_MatchText+0xa9>
    0.00 :	  6fbcc7:       8d 41 fe                lea    -0x2(%rcx),%eax
    0.00 :	  6fbcca:       48 83 c2 02             add    $0x2,%rdx
    0.00 :	  6fbcce:       66 90                   xchg   %ax,%ax
         :	                        {
         :	                                if (*p == '%')
    0.00 :	  6fbcd0:       44 0f b6 6a ff          movzbl -0x1(%rdx),%r13d
         :	                         * fragment that begins with a literal character-to-match, thereby
         :	                         * not recursing more than we have to.
         :	                         */
         :	                        NextByte(p, plen);
         :
         :	                        while (plen > 0)
    0.00 :	  6fbcd5:       4c 8d 7a ff             lea    -0x1(%rdx),%r15
    0.00 :	  6fbcd9:       44 8d 70 01             lea    0x1(%rax),%r14d
         :	                        {
         :	                                if (*p == '%')
    0.00 :	  6fbcdd:       89 c1                   mov    %eax,%ecx
    0.00 :	  6fbcdf:       41 80 fd 25             cmp    $0x25,%r13b
    0.00 :	  6fbce3:       74 13                   je     6fbcf8 <SB_MatchText+0xf8>
         :	                                        NextByte(p, plen);
         :	                                else if (*p == '_')
    0.00 :	  6fbce5:       41 80 fd 5f             cmp    $0x5f,%r13b
    0.00 :	  6fbce9:       75 5c                   jne    6fbd47 <SB_MatchText+0x147>
         :	                                {
         :	                                        /* If not enough text left to match the pattern, ABORT */
         :	                                        if (tlen <= 0)
    0.00 :	  6fbceb:       85 db                   test   %ebx,%ebx
    0.00 :	  6fbced:       7e 19                   jle    6fbd08 <SB_MatchText+0x108>
         :	                                                return LIKE_ABORT;
         :	                                        NextChar(t, tlen);
    0.00 :	  6fbcef:       49 83 c4 01             add    $0x1,%r12
    0.00 :	  6fbcf3:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  6fbcf6:       89 c1                   mov    %eax,%ecx
    0.00 :	  6fbcf8:       83 e8 01                sub    $0x1,%eax
    0.00 :	  6fbcfb:       48 83 c2 01             add    $0x1,%rdx
         :	                         * fragment that begins with a literal character-to-match, thereby
         :	                         * not recursing more than we have to.
         :	                         */
         :	                        NextByte(p, plen);
         :
         :	                        while (plen > 0)
    0.00 :	  6fbcff:       85 c9                   test   %ecx,%ecx
    0.00 :	  6fbd01:       7f cd                   jg     6fbcd0 <SB_MatchText+0xd0>
    0.00 :	  6fbd03:       eb a4                   jmp    6fbca9 <SB_MatchText+0xa9>
    0.00 :	  6fbd05:       0f 1f 00                nopl   (%rax)
         :	        /*
         :	         * End of text with no match, so no point in trying later places to start
         :	         * matching this pattern.
         :	         */
         :	        return LIKE_ABORT;
         :	}       /* MatchText() */
    0.00 :	  6fbd08:       48 83 c4 18             add    $0x18,%rsp
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbd0c:       b8 ff ff ff ff          mov    $0xffffffff,%eax
         :	        /*
         :	         * End of text with no match, so no point in trying later places to start
         :	         * matching this pattern.
         :	         */
         :	        return LIKE_ABORT;
         :	}       /* MatchText() */
    0.00 :	  6fbd11:       5b                      pop    %rbx
    0.00 :	  6fbd12:       41 5c                   pop    %r12
    0.00 :	  6fbd14:       41 5d                   pop    %r13
    0.00 :	  6fbd16:       41 5e                   pop    %r14
    0.00 :	  6fbd18:       41 5f                   pop    %r15
    0.00 :	  6fbd1a:       c9                      leaveq 
    0.00 :	  6fbd1b:       c3                      retq   
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbd1c:       85 c9                   test   %ecx,%ecx
    0.00 :	  6fbd1e:       7e 89                   jle    6fbca9 <SB_MatchText+0xa9>
    0.00 :	  6fbd20:       80 3a 25                cmpb   $0x25,(%rdx)
    0.00 :	  6fbd23:       74 14                   je     6fbd39 <SB_MatchText+0x139>
    0.00 :	  6fbd25:       0f 1f 00                nopl   (%rax)
    0.00 :	  6fbd28:       eb de                   jmp    6fbd08 <SB_MatchText+0x108>
    0.00 :	  6fbd2a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                NextByte(p, plen);
    0.00 :	  6fbd30:       48 83 c2 01             add    $0x1,%rdx
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbd34:       80 3a 25                cmpb   $0x25,(%rdx)
    0.00 :	  6fbd37:       75 cf                   jne    6fbd08 <SB_MatchText+0x108>
         :	                NextByte(p, plen);
    0.00 :	  6fbd39:       83 e9 01                sub    $0x1,%ecx
         :
         :	        /*
         :	         * End of text, but perhaps not of pattern.  Match iff the remaining
         :	         * pattern can match a zero-length string, ie, it's zero or more %'s.
         :	         */
         :	        while (plen > 0 && *p == '%')
    0.00 :	  6fbd3c:       85 c9                   test   %ecx,%ecx
    0.00 :	  6fbd3e:       66 90                   xchg   %ax,%ax
    0.00 :	  6fbd40:       7f ee                   jg     6fbd30 <SB_MatchText+0x130>
    0.00 :	  6fbd42:       e9 62 ff ff ff          jmpq   6fbca9 <SB_MatchText+0xa9>
         :	                         * the first pattern byte to each text byte to avoid recursing
         :	                         * more than we have to.  This fact also guarantees that we don't
         :	                         * have to consider a match to the zero-length substring at the
         :	                         * end of the text.
         :	                         */
         :	                        if (*p == '\\')
    0.00 :	  6fbd47:       41 80 fd 5c             cmp    $0x5c,%r13b
    0.00 :	  6fbd4b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  6fbd50:       75 11                   jne    6fbd63 <SB_MatchText+0x163>
         :	                        {
         :	                                if (plen < 2)
    0.00 :	  6fbd52:       41 83 fe 01             cmp    $0x1,%r14d
    0.00 :	  6fbd56:       66 90                   xchg   %ax,%ax
    0.00 :	  6fbd58:       0f 84 96 00 00 00       je     6fbdf4 <SB_MatchText+0x1f4>
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),
         :	                                                         errmsg("LIKE pattern must not end with escape character")));
         :	                                firstpat = GETCHAR(p[1]);
    0.00 :	  6fbd5e:       45 0f b6 6f 01          movzbl 0x1(%r15),%r13d
         :	                        }
         :	                        else
         :	                                firstpat = GETCHAR(*p);
         :
         :	                        while (tlen > 0)
    0.00 :	  6fbd63:       85 db                   test   %ebx,%ebx
    0.00 :	  6fbd65:       7e a1                   jle    6fbd08 <SB_MatchText+0x108>
         :	                        {
         :	                                if (GETCHAR(*t) == firstpat)
         :	                                {
         :	                                        int                     matched = MatchText(t, tlen, p, plen,
         :	                                                                                                        locale, locale_is_c);
    0.00 :	  6fbd67:       45 0f be c9             movsbl %r9b,%r9d
    0.00 :	  6fbd6b:       44 89 4d cc             mov    %r9d,-0x34(%rbp)
    0.00 :	  6fbd6f:       eb 12                   jmp    6fbd83 <SB_MatchText+0x183>
    0.00 :	  6fbd71:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                                        if (matched != LIKE_FALSE)
         :	                                                return matched; /* TRUE or ABORT */
         :	                                }
         :
         :	                                NextChar(t, tlen);
    0.00 :	  6fbd78:       83 eb 01                sub    $0x1,%ebx
         :	                                firstpat = GETCHAR(p[1]);
         :	                        }
         :	                        else
         :	                                firstpat = GETCHAR(*p);
         :
         :	                        while (tlen > 0)
    0.00 :	  6fbd7b:       85 db                   test   %ebx,%ebx
    0.00 :	  6fbd7d:       7e 89                   jle    6fbd08 <SB_MatchText+0x108>
         :
         :	                                        if (matched != LIKE_FALSE)
         :	                                                return matched; /* TRUE or ABORT */
         :	                                }
         :
         :	                                NextChar(t, tlen);
    0.00 :	  6fbd7f:       49 83 c4 01             add    $0x1,%r12
         :	                        else
         :	                                firstpat = GETCHAR(*p);
         :
         :	                        while (tlen > 0)
         :	                        {
         :	                                if (GETCHAR(*t) == firstpat)
    0.00 :	  6fbd83:       45 3a 2c 24             cmp    (%r12),%r13b
    0.00 :	  6fbd87:       75 ef                   jne    6fbd78 <SB_MatchText+0x178>
         :	                                {
         :	                                        int                     matched = MatchText(t, tlen, p, plen,
         :	                                                                                                        locale, locale_is_c);
    0.00 :	  6fbd89:       44 8b 4d cc             mov    -0x34(%rbp),%r9d
    0.00 :	  6fbd8d:       4c 8b 45 d0             mov    -0x30(%rbp),%r8
    0.00 :	  6fbd91:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  6fbd94:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  6fbd97:       89 de                   mov    %ebx,%esi
    0.00 :	  6fbd99:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6fbd9c:       e8 5f fe ff ff          callq  6fbc00 <SB_MatchText>
         :
         :	                                        if (matched != LIKE_FALSE)
    0.00 :	  6fbda1:       85 c0                   test   %eax,%eax
    0.00 :	  6fbda3:       74 d3                   je     6fbd78 <SB_MatchText+0x178>
    0.00 :	  6fbda5:       e9 91 fe ff ff          jmpq   6fbc3b <SB_MatchText+0x3b>
         :	                {
         :	                        /* Next pattern byte must match literally, whatever it is */
         :	                        NextByte(p, plen);
         :	                        /* ... and there had better be one, per SQL standard */
         :	                        if (plen <= 0)
         :	                                ereport(ERROR,
    0.00 :	  6fbdaa:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6fbdad:       b9 5f 2f 8c 00          mov    $0x8c2f5f,%ecx
    0.00 :	  6fbdb2:       ba 68 00 00 00          mov    $0x68,%edx
         :	                         * end of the text.
         :	                         */
         :	                        if (*p == '\\')
         :	                        {
         :	                                if (plen < 2)
         :	                                        ereport(ERROR,
    0.00 :	  6fbdb7:       be 12 2e 8c 00          mov    $0x8c2e12,%esi
    0.00 :	  6fbdbc:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  6fbdc1:       e8 fa ec 07 00          callq  77aac0 <errstart>
    0.00 :	  6fbdc6:       84 c0                   test   %al,%al
    0.00 :	  6fbdc8:       75 05                   jne    6fbdcf <SB_MatchText+0x1cf>
    0.00 :	  6fbdca:       e8 01 d7 d6 ff          callq  4694d0 <abort@plt>
    0.00 :	  6fbdcf:       bf 40 2e 8c 00          mov    $0x8c2e40,%edi
    0.00 :	  6fbdd4:       31 c0                   xor    %eax,%eax
    0.00 :	  6fbdd6:       e8 c5 0a 08 00          callq  77c8a0 <errmsg>
    0.00 :	  6fbddb:       bf 82 00 08 05          mov    $0x5080082,%edi
    0.00 :	  6fbde0:       89 c3                   mov    %eax,%ebx
    0.00 :	  6fbde2:       e8 69 0f 08 00          callq  77cd50 <errcode>
    0.00 :	  6fbde7:       89 de                   mov    %ebx,%esi
    0.00 :	  6fbde9:       89 c7                   mov    %eax,%edi
    0.00 :	  6fbdeb:       31 c0                   xor    %eax,%eax
    0.00 :	  6fbded:       e8 ee e7 07 00          callq  77a5e0 <errfinish>
    0.00 :	  6fbdf2:       eb d6                   jmp    6fbdca <SB_MatchText+0x1ca>
    0.00 :	  6fbdf4:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6fbdf7:       b9 5f 2f 8c 00          mov    $0x8c2f5f,%ecx
    0.00 :	  6fbdfc:       ba a4 00 00 00          mov    $0xa4,%edx
    0.00 :	  6fbe01:       eb b4                   jmp    6fbdb7 <SB_MatchText+0x1b7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/cache/catcache.c:1140
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000766190 <SearchCatCache>:
         :	SearchCatCache(CatCache *cache,
         :	                           Datum v1,
         :	                           Datum v2,
         :	                           Datum v3,
         :	                           Datum v4)
         :	{
    0.00 :	  766190:       55                      push   %rbp
    0.00 :	  766191:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  766194:       41 57                   push   %r15
    0.00 :	  766196:       41 56                   push   %r14
    0.00 :	  766198:       4d 89 c6                mov    %r8,%r14
    0.00 :	  76619b:       41 55                   push   %r13
    0.00 :	  76619d:       49 89 cd                mov    %rcx,%r13
    0.00 :	  7661a0:       41 54                   push   %r12
    0.00 :	  7661a2:       49 89 d4                mov    %rdx,%r12
    0.00 :	  7661a5:       53                      push   %rbx
    0.00 :	  7661a6:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  7661a9:       48 81 ec 68 01 00 00    sub    $0x168,%rsp
    0.00 :	  7661b0:       48 89 bd 88 fe ff ff    mov    %rdi,-0x178(%rbp)
         :	        Assert(IsTransactionState());
         :
         :	        /*
         :	         * one-time startup overhead for each cache
         :	         */
         :	        if (cache->cc_tupdesc == NULL)
    0.00 :	  7661b7:       48 83 7f 28 00          cmpq   $0x0,0x28(%rdi)
    0.00 :	  7661bc:       0f 84 af 04 00 00       je     766671 <SearchCatCache+0x4e1>
         :	#endif
         :
         :	        /*
         :	         * initialize the search key information
         :	         */
         :	        memcpy(cur_skey, cache->cc_skey, sizeof(cur_skey));
    0.00 :	  7661c2:       48 8b b5 88 fe ff ff    mov    -0x178(%rbp),%rsi
    0.00 :	  7661c9:       48 8d 85 a0 fe ff ff    lea    -0x160(%rbp),%rax
    0.00 :	  7661d0:       b9 24 00 00 00          mov    $0x24,%ecx
    0.00 :	  7661d5:       48 89 85 78 fe ff ff    mov    %rax,-0x188(%rbp)
    0.00 :	  7661dc:       48 89 c7                mov    %rax,%rdi
    0.00 :	  7661df:       48 83 c6 70             add    $0x70,%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/cache/catcache.c:1140
  100.00 :	  7661e3:       f3 48 a5                rep movsq %ds:(%rsi),%es:(%rdi)
         :	        cur_skey[0].sk_argument = v1;
         :	        cur_skey[1].sk_argument = v2;
         :	        cur_skey[2].sk_argument = v3;
    0.00 :	  7661e6:       4c 89 ad 70 ff ff ff    mov    %r13,-0x90(%rbp)
         :
         :	        /*
         :	         * initialize the search key information
         :	         */
         :	        memcpy(cur_skey, cache->cc_skey, sizeof(cur_skey));
         :	        cur_skey[0].sk_argument = v1;
    0.00 :	  7661ed:       48 89 9d e0 fe ff ff    mov    %rbx,-0x120(%rbp)
         :	        cur_skey[1].sk_argument = v2;
    0.00 :	  7661f4:       4c 89 a5 28 ff ff ff    mov    %r12,-0xd8(%rbp)
         :	        cur_skey[2].sk_argument = v3;
         :	        cur_skey[3].sk_argument = v4;
    0.00 :	  7661fb:       4c 89 75 b8             mov    %r14,-0x48(%rbp)
         :
         :	        /*
         :	         * find the hash bucket in which to look for the tuple
         :	         */
         :	        hashValue = CatalogCacheComputeHashValue(cache, cache->cc_nkeys, cur_skey);
    0.00 :	  7661ff:       48 8b 95 88 fe ff ff    mov    -0x178(%rbp),%rdx
    0.00 :	  766206:       48 8b bd 88 fe ff ff    mov    -0x178(%rbp),%rdi
    0.00 :	  76620d:       8b 72 38                mov    0x38(%rdx),%esi
    0.00 :	  766210:       48 89 c2                mov    %rax,%rdx
    0.00 :	  766213:       e8 d8 e6 ff ff          callq  7648f0 <CatalogCacheComputeHashValue>
         :	        hashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);
    0.00 :	  766218:       48 8b 8d 88 fe ff ff    mov    -0x178(%rbp),%rcx
         :	        cur_skey[3].sk_argument = v4;
         :
         :	        /*
         :	         * find the hash bucket in which to look for the tuple
         :	         */
         :	        hashValue = CatalogCacheComputeHashValue(cache, cache->cc_nkeys, cur_skey);
    0.00 :	  76621f:       89 85 98 fe ff ff       mov    %eax,-0x168(%rbp)
         :	        hashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);
    0.00 :	  766225:       8b 95 98 fe ff ff       mov    -0x168(%rbp),%edx
    0.00 :	  76622b:       8b 41 34                mov    0x34(%rcx),%eax
    0.00 :	  76622e:       83 e8 01                sub    $0x1,%eax
    0.00 :	  766231:       21 d0                   and    %edx,%eax
         :	         * scan the hash bucket until we find a match or exhaust our tuples
         :	         *
         :	         * Note: it's okay to use dlist_foreach here, even though we modify the
         :	         * dlist within the loop, because we don't continue the loop afterwards.
         :	         */
         :	        bucket = &cache->cc_bucket[hashIndex];
    0.00 :	  766233:       41 89 c7                mov    %eax,%r15d
         :
         :	        /*
         :	         * find the hash bucket in which to look for the tuple
         :	         */
         :	        hashValue = CatalogCacheComputeHashValue(cache, cache->cc_nkeys, cur_skey);
         :	        hashIndex = HASH_INDEX(hashValue, cache->cc_nbuckets);
    0.00 :	  766236:       89 85 9c fe ff ff       mov    %eax,-0x164(%rbp)
         :	         * scan the hash bucket until we find a match or exhaust our tuples
         :	         *
         :	         * Note: it's okay to use dlist_foreach here, even though we modify the
         :	         * dlist within the loop, because we don't continue the loop afterwards.
         :	         */
         :	        bucket = &cache->cc_bucket[hashIndex];
    0.00 :	  76623c:       49 c1 e7 04             shl    $0x4,%r15
    0.00 :	  766240:       4c 03 b9 a8 01 00 00    add    0x1a8(%rcx),%r15
         :	        dlist_foreach(iter, bucket)
    0.00 :	  766247:       4d 8b 6f 08             mov    0x8(%r15),%r13
    0.00 :	  76624b:       4d 85 ed                test   %r13,%r13
    0.00 :	  76624e:       75 0c                   jne    76625c <SearchCatCache+0xcc>
    0.00 :	  766250:       e9 db 01 00 00          jmpq   766430 <SearchCatCache+0x2a0>
    0.00 :	  766255:       0f 1f 00                nopl   (%rax)
    0.00 :	  766258:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  76625c:       4d 39 ef                cmp    %r13,%r15
    0.00 :	  76625f:       0f 84 cb 01 00 00       je     766430 <SearchCatCache+0x2a0>
         :	        {
         :	                bool            res;
         :
         :	                ct = dlist_container(CatCTup, cache_elem, iter.cur);
    0.00 :	  766265:       4d 8d 65 f0             lea    -0x10(%r13),%r12
         :
         :	                if (ct->dead)
    0.00 :	  766269:       41 80 7c 24 2c 00       cmpb   $0x0,0x2c(%r12)
    0.00 :	  76626f:       90                      nop
    0.00 :	  766270:       75 e6                   jne    766258 <SearchCatCache+0xc8>
         :	                        continue;                       /* ignore dead entries */
         :
         :	                if (ct->hash_value != hashValue)
    0.00 :	  766272:       8b 8d 98 fe ff ff       mov    -0x168(%rbp),%ecx
    0.00 :	  766278:       41 3b 4c 24 30          cmp    0x30(%r12),%ecx
    0.00 :	  76627d:       75 d9                   jne    766258 <SearchCatCache+0xc8>
         :	                        continue;                       /* quickly skip entry if wrong hash val */
         :
         :	                /*
         :	                 * see if the cached tuple matches our key.
         :	                 */
         :	                HeapKeyTest(&ct->tuple,
    0.00 :	  76627f:       48 8b 95 88 fe ff ff    mov    -0x178(%rbp),%rdx
    0.00 :	  766286:       8b 42 38                mov    0x38(%rdx),%eax
    0.00 :	  766289:       85 c0                   test   %eax,%eax
    0.00 :	  76628b:       0f 84 87 02 00 00       je     766518 <SearchCatCache+0x388>
    0.00 :	  766291:       f6 85 a0 fe ff ff 01    testb  $0x1,-0x160(%rbp)
    0.00 :	  766298:       75 be                   jne    766258 <SearchCatCache+0xc8>
    0.00 :	  76629a:       49 8d 4d 28             lea    0x28(%r13),%rcx
    0.00 :	  76629e:       44 8d 70 ff             lea    -0x1(%rax),%r14d
    0.00 :	  7662a2:       48 8d 9d a0 fe ff ff    lea    -0x160(%rbp),%rbx
    0.00 :	  7662a9:       48 89 8d 90 fe ff ff    mov    %rcx,-0x170(%rbp)
    0.00 :	  7662b0:       e9 ad 00 00 00          jmpq   766362 <SearchCatCache+0x1d2>
    0.00 :	  7662b5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7662b8:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
    0.00 :	  7662bc:       49 8b 7c 24 48          mov    0x48(%r12),%rdi
    0.00 :	  7662c1:       f6 47 14 01             testb  $0x1,0x14(%rdi)
    0.00 :	  7662c5:       0f 85 c5 00 00 00       jne    766390 <SearchCatCache+0x200>
    0.00 :	  7662cb:       48 8b 85 88 fe ff ff    mov    -0x178(%rbp),%rax
    0.00 :	  7662d2:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
    0.00 :	  7662d6:       4c 8b 40 28             mov    0x28(%rax),%r8
    0.00 :	  7662da:       48 0f bf d1             movswq %cx,%rdx
    0.00 :	  7662de:       49 8b 40 08             mov    0x8(%r8),%rax
    0.00 :	  7662e2:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    0.00 :	  7662e7:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  7662ea:       85 c0                   test   %eax,%eax
    0.00 :	  7662ec:       0f 88 26 01 00 00       js     766418 <SearchCatCache+0x288>
    0.00 :	  7662f2:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  7662f6:       0f 84 04 01 00 00       je     766400 <SearchCatCache+0x270>
    0.00 :	  7662fc:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  766300:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  766304:       0f 84 f6 01 00 00       je     766500 <SearchCatCache+0x370>
    0.00 :	  76630a:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  76630e:       66 90                   xchg   %ax,%ax
    0.00 :	  766310:       0f 84 5a 02 00 00       je     766570 <SearchCatCache+0x3e0>
    0.00 :	  766316:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  76631a:       0f 84 a8 02 00 00       je     7665c8 <SearchCatCache+0x438>
    0.00 :	  766320:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  766324:       48 98                   cltq   
    0.00 :	  766326:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  76632a:       0f b6 14 10             movzbl (%rax,%rdx,1),%edx
    0.00 :	  76632e:       66 90                   xchg   %ax,%ax
    0.00 :	  766330:       48 8b 4b 40             mov    0x40(%rbx),%rcx
    0.00 :	  766334:       8b 73 0c                mov    0xc(%rbx),%esi
    0.00 :	  766337:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  76633b:       e8 f0 7c 01 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  766340:       84 c0                   test   %al,%al
    0.00 :	  766342:       0f 84 10 ff ff ff       je     766258 <SearchCatCache+0xc8>
    0.00 :	  766348:       45 85 f6                test   %r14d,%r14d
    0.00 :	  76634b:       0f 84 c7 01 00 00       je     766518 <SearchCatCache+0x388>
    0.00 :	  766351:       48 83 c3 48             add    $0x48,%rbx
    0.00 :	  766355:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  766358:       0f 85 fa fe ff ff       jne    766258 <SearchCatCache+0xc8>
    0.00 :	  76635e:       41 83 ee 01             sub    $0x1,%r14d
    0.00 :	  766362:       0f b7 43 04             movzwl 0x4(%rbx),%eax
    0.00 :	  766366:       66 85 c0                test   %ax,%ax
    0.00 :	  766369:       7e 6d                   jle    7663d8 <SearchCatCache+0x248>
    0.00 :	  76636b:       0f bf d0                movswl %ax,%edx
    0.00 :	  76636e:       49 8b 44 24 48          mov    0x48(%r12),%rax
    0.00 :	  766373:       0f b7 40 12             movzwl 0x12(%rax),%eax
    0.00 :	  766377:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  76637c:       39 c2                   cmp    %eax,%edx
    0.00 :	  76637e:       0f 8e 34 ff ff ff       jle    7662b8 <SearchCatCache+0x128>
    0.00 :	  766384:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
    0.00 :	  766388:       e9 cb fe ff ff          jmpq   766258 <SearchCatCache+0xc8>
    0.00 :	  76638d:       0f 1f 00                nopl   (%rax)
    0.00 :	  766390:       0f bf 73 04             movswl 0x4(%rbx),%esi
    0.00 :	  766394:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  766397:       89 c8                   mov    %ecx,%eax
    0.00 :	  766399:       83 e1 07                and    $0x7,%ecx
    0.00 :	  76639c:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  76639f:       48 98                   cltq   
    0.00 :	  7663a1:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  7663a6:       d3 f8                   sar    %cl,%eax
    0.00 :	  7663a8:       a8 01                   test   $0x1,%al
    0.00 :	  7663aa:       74 d8                   je     766384 <SearchCatCache+0x1f4>
    0.00 :	  7663ac:       48 8b 8d 88 fe ff ff    mov    -0x178(%rbp),%rcx
    0.00 :	  7663b3:       48 8b bd 90 fe ff ff    mov    -0x170(%rbp),%rdi
    0.00 :	  7663ba:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  7663be:       e8 cd 95 d0 ff          callq  46f990 <nocachegetattr>
    0.00 :	  7663c3:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7663c6:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  7663ca:       0f 84 60 ff ff ff       je     766330 <SearchCatCache+0x1a0>
    0.00 :	  7663d0:       e9 83 fe ff ff          jmpq   766258 <SearchCatCache+0xc8>
    0.00 :	  7663d5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7663d8:       48 8b 8d 88 fe ff ff    mov    -0x178(%rbp),%rcx
    0.00 :	  7663df:       48 8b bd 90 fe ff ff    mov    -0x170(%rbp),%rdi
    0.00 :	  7663e6:       0f bf f0                movswl %ax,%esi
    0.00 :	  7663e9:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  7663ed:       48 8d 4d cf             lea    -0x31(%rbp),%rcx
    0.00 :	  7663f1:       e8 da 88 d0 ff          callq  46ecd0 <heap_getsysattr>
    0.00 :	  7663f6:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7663f9:       eb cb                   jmp    7663c6 <SearchCatCache+0x236>
    0.00 :	  7663fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  766400:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  766404:       48 98                   cltq   
    0.00 :	  766406:       48 01 d0                add    %rdx,%rax
    0.00 :	  766409:       48 8d 14 07             lea    (%rdi,%rax,1),%rdx
    0.00 :	  76640d:       e9 1e ff ff ff          jmpq   766330 <SearchCatCache+0x1a0>
    0.00 :	  766412:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  766418:       48 8b bd 90 fe ff ff    mov    -0x170(%rbp),%rdi
    0.00 :	  76641f:       4c 89 c2                mov    %r8,%rdx
    0.00 :	  766422:       0f bf f1                movswl %cx,%esi
    0.00 :	  766425:       e8 66 95 d0 ff          callq  46f990 <nocachegetattr>
    0.00 :	  76642a:       48 89 c2                mov    %rax,%rdx
    0.00 :	  76642d:       eb 97                   jmp    7663c6 <SearchCatCache+0x236>
    0.00 :	  76642f:       90                      nop
         :	         * into the cache.  The first copy will never be referenced again, and
         :	         * will eventually age out of the cache, so there's no functional problem.
         :	         * This case is rare enough that it's not worth expending extra cycles to
         :	         * detect.
         :	         */
         :	        relation = heap_open(cache->cc_reloid, AccessShareLock);
    0.00 :	  766430:       48 8b 85 88 fe ff ff    mov    -0x178(%rbp),%rax
    0.00 :	  766437:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  76643c:       8b 78 18                mov    0x18(%rax),%edi
    0.00 :	  76643f:       e8 1c 77 d3 ff          callq  49db60 <heap_open>
         :
         :	        scandesc = systable_beginscan(relation,
    0.00 :	  766444:       48 8b 95 88 fe ff ff    mov    -0x178(%rbp),%rdx
         :	         * into the cache.  The first copy will never be referenced again, and
         :	         * will eventually age out of the cache, so there's no functional problem.
         :	         * This case is rare enough that it's not worth expending extra cycles to
         :	         * detect.
         :	         */
         :	        relation = heap_open(cache->cc_reloid, AccessShareLock);
    0.00 :	  76644b:       49 89 c5                mov    %rax,%r13
         :	 *              we don't yet have relcache entries for those catalogs' indexes.
         :	 */
         :	static bool
         :	IndexScanOK(CatCache *cache, ScanKey cur_skey)
         :	{
         :	        switch (cache->id)
    0.00 :	  76644e:       83 3a 20                cmpl   $0x20,(%rdx)
         :	         * This case is rare enough that it's not worth expending extra cycles to
         :	         * detect.
         :	         */
         :	        relation = heap_open(cache->cc_reloid, AccessShareLock);
         :
         :	        scandesc = systable_beginscan(relation,
    0.00 :	  766451:       44 8b 42 38             mov    0x38(%rdx),%r8d
         :	 *              we don't yet have relcache entries for those catalogs' indexes.
         :	 */
         :	static bool
         :	IndexScanOK(CatCache *cache, ScanKey cur_skey)
         :	{
         :	        switch (cache->id)
    0.00 :	  766455:       0f 86 2d 01 00 00       jbe    766588 <SearchCatCache+0x3f8>
    0.00 :	  76645b:       ba 01 00 00 00          mov    $0x1,%edx
         :	         * This case is rare enough that it's not worth expending extra cycles to
         :	         * detect.
         :	         */
         :	        relation = heap_open(cache->cc_reloid, AccessShareLock);
         :
         :	        scandesc = systable_beginscan(relation,
    0.00 :	  766460:       48 8b 8d 88 fe ff ff    mov    -0x178(%rbp),%rcx
    0.00 :	  766467:       4c 8d 8d a0 fe ff ff    lea    -0x160(%rbp),%r9
    0.00 :	  76646e:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  766471:       8b 71 1c                mov    0x1c(%rcx),%esi
    0.00 :	  766474:       31 c9                   xor    %ecx,%ecx
    0.00 :	  766476:       e8 25 e8 d3 ff          callq  4a4ca0 <systable_beginscan>
         :	                                                                  cache->cc_nkeys,
         :	                                                                  cur_skey);
         :
         :	        ct = NULL;
         :
         :	        while (HeapTupleIsValid(ntp = systable_getnext(scandesc)))
    0.00 :	  76647b:       48 89 c7                mov    %rax,%rdi
         :	         * This case is rare enough that it's not worth expending extra cycles to
         :	         * detect.
         :	         */
         :	        relation = heap_open(cache->cc_reloid, AccessShareLock);
         :
         :	        scandesc = systable_beginscan(relation,
    0.00 :	  76647e:       49 89 c4                mov    %rax,%r12
         :	                                                                  cache->cc_nkeys,
         :	                                                                  cur_skey);
         :
         :	        ct = NULL;
         :
         :	        while (HeapTupleIsValid(ntp = systable_getnext(scandesc)))
    0.00 :	  766481:       e8 9a e7 d3 ff          callq  4a4c20 <systable_getnext>
    0.00 :	  766486:       48 85 c0                test   %rax,%rax
    0.00 :	  766489:       0f 84 4c 01 00 00       je     7665db <SearchCatCache+0x44b>
         :	        {
         :	                ct = CatalogCacheCreateEntry(cache, ntp,
    0.00 :	  76648f:       8b 8d 9c fe ff ff       mov    -0x164(%rbp),%ecx
    0.00 :	  766495:       8b 95 98 fe ff ff       mov    -0x168(%rbp),%edx
    0.00 :	  76649b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  76649e:       48 8b bd 88 fe ff ff    mov    -0x178(%rbp),%rdi
    0.00 :	  7664a5:       48 89 c6                mov    %rax,%rsi
    0.00 :	  7664a8:       e8 33 f0 ff ff          callq  7654e0 <CatalogCacheCreateEntry>
         :	                                                                         hashValue, hashIndex,
         :	                                                                         false);
         :	                /* immediately set the refcount to 1 */
         :	                ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);
    0.00 :	  7664ad:       48 8b 3d 0c 44 45 00    mov    0x45440c(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
         :
         :	        ct = NULL;
         :
         :	        while (HeapTupleIsValid(ntp = systable_getnext(scandesc)))
         :	        {
         :	                ct = CatalogCacheCreateEntry(cache, ntp,
    0.00 :	  7664b4:       48 89 c3                mov    %rax,%rbx
         :	                                                                         hashValue, hashIndex,
         :	                                                                         false);
         :	                /* immediately set the refcount to 1 */
         :	                ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);
    0.00 :	  7664b7:       e8 24 49 03 00          callq  79ade0 <ResourceOwnerEnlargeCatCacheRefs>
         :	                ct->refcount++;
    0.00 :	  7664bc:       83 43 28 01             addl   $0x1,0x28(%rbx)
         :	                ResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);
    0.00 :	  7664c0:       48 83 c3 38             add    $0x38,%rbx
    0.00 :	  7664c4:       48 8b 3d f5 43 45 00    mov    0x4543f5(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  7664cb:       48 89 de                mov    %rbx,%rsi
    0.00 :	  7664ce:       e8 1d 3d 03 00          callq  79a1f0 <ResourceOwnerRememberCatCacheRef>
         :	                break;                                  /* assume only one match */
         :	        }
         :
         :	        systable_endscan(scandesc);
    0.00 :	  7664d3:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7664d6:       e8 45 e6 d3 ff          callq  4a4b20 <systable_endscan>
         :
         :	        heap_close(relation, AccessShareLock);
    0.00 :	  7664db:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  7664e0:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7664e3:       e8 d8 74 d3 ff          callq  49d9c0 <relation_close>
         :	#ifdef CATCACHE_STATS
         :	        cache->cc_newloads++;
         :	#endif
         :
         :	        return &ct->tuple;
         :	}
    0.00 :	  7664e8:       48 81 c4 68 01 00 00    add    $0x168,%rsp
    0.00 :	  7664ef:       48 89 d8                mov    %rbx,%rax
    0.00 :	  7664f2:       5b                      pop    %rbx
    0.00 :	  7664f3:       41 5c                   pop    %r12
    0.00 :	  7664f5:       41 5d                   pop    %r13
    0.00 :	  7664f7:       41 5e                   pop    %r14
    0.00 :	  7664f9:       41 5f                   pop    %r15
    0.00 :	  7664fb:       c9                      leaveq 
    0.00 :	  7664fc:       c3                      retq   
    0.00 :	  7664fd:       0f 1f 00                nopl   (%rax)
         :	                        continue;                       /* quickly skip entry if wrong hash val */
         :
         :	                /*
         :	                 * see if the cached tuple matches our key.
         :	                 */
         :	                HeapKeyTest(&ct->tuple,
    0.00 :	  766500:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  766504:       48 98                   cltq   
    0.00 :	  766506:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  76650a:       48 8b 14 10             mov    (%rax,%rdx,1),%rdx
    0.00 :	  76650e:       e9 1d fe ff ff          jmpq   766330 <SearchCatCache+0x1a0>
    0.00 :	  766513:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * We found a match in the cache.  Move it to the front of the list
         :	                 * for its hashbucket, in order to speed subsequent searches.  (The
         :	                 * most frequently accessed elements in any hashbucket will tend to be
         :	                 * near the front of the hashbucket's list.)
         :	                 */
         :	                dlist_move_head(bucket, &ct->cache_elem);
    0.00 :	  766518:       49 8d 4c 24 10          lea    0x10(%r12),%rcx
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_move_head(dlist_head *head, dlist_node *node)
         :	{
         :	        /* fast path if it's already at the head */
         :	        if (head->head.next == node)
    0.00 :	  76651d:       49 3b 4f 08             cmp    0x8(%r15),%rcx
    0.00 :	  766521:       74 39                   je     76655c <SearchCatCache+0x3cc>
         :	 * Delete 'node' from its list (it must be in one).
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_delete(dlist_node *node)
         :	{
         :	        node->prev->next = node->next;
    0.00 :	  766523:       49 8b 54 24 10          mov    0x10(%r12),%rdx
    0.00 :	  766528:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  76652d:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	        node->next->prev = node->prev;
    0.00 :	  766531:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  766536:       49 8b 54 24 18          mov    0x18(%r12),%rdx
    0.00 :	  76653b:       48 89 02                mov    %rax,(%rdx)
         :	 * Insert a node at the beginning of the list.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_push_head(dlist_head *head, dlist_node *node)
         :	{
         :	        if (head->head.next == NULL)    /* convert NULL header to circular */
    0.00 :	  76653e:       49 8b 47 08             mov    0x8(%r15),%rax
    0.00 :	  766542:       48 85 c0                test   %rax,%rax
    0.00 :	  766545:       0f 84 65 01 00 00       je     7666b0 <SearchCatCache+0x520>
         :	                dlist_init(head);
         :
         :	        node->next = head->head.next;
    0.00 :	  76654b:       49 89 44 24 18          mov    %rax,0x18(%r12)
         :	        node->prev = &head->head;
    0.00 :	  766550:       4d 89 7c 24 10          mov    %r15,0x10(%r12)
         :	        node->next->prev = node;
    0.00 :	  766555:       48 89 08                mov    %rcx,(%rax)
         :	        head->head.next = node;
    0.00 :	  766558:       49 89 4f 08             mov    %rcx,0x8(%r15)
         :
         :	                /*
         :	                 * If it's a positive entry, bump its refcount and return it. If it's
         :	                 * negative, we can report failure to the caller.
         :	                 */
         :	                if (!ct->negative)
    0.00 :	  76655c:       41 80 7c 24 2d 00       cmpb   $0x0,0x2d(%r12)
    0.00 :	  766562:       0f 84 1d 01 00 00       je     766685 <SearchCatCache+0x4f5>
         :
         :	                ntp = build_dummy_tuple(cache, cache->cc_nkeys, cur_skey);
         :	                ct = CatalogCacheCreateEntry(cache, ntp,
         :	                                                                         hashValue, hashIndex,
         :	                                                                         true);
         :	                heap_freetuple(ntp);
    0.00 :	  766568:       31 db                   xor    %ebx,%ebx
    0.00 :	  76656a:       e9 79 ff ff ff          jmpq   7664e8 <SearchCatCache+0x358>
    0.00 :	  76656f:       90                      nop
         :	                        continue;                       /* quickly skip entry if wrong hash val */
         :
         :	                /*
         :	                 * see if the cached tuple matches our key.
         :	                 */
         :	                HeapKeyTest(&ct->tuple,
    0.00 :	  766570:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  766574:       48 98                   cltq   
    0.00 :	  766576:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  76657a:       8b 14 10                mov    (%rax,%rdx,1),%edx
    0.00 :	  76657d:       e9 ae fd ff ff          jmpq   766330 <SearchCatCache+0x1a0>
    0.00 :	  766582:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	 *              we don't yet have relcache entries for those catalogs' indexes.
         :	 */
         :	static bool
         :	IndexScanOK(CatCache *cache, ScanKey cur_skey)
         :	{
         :	        switch (cache->id)
    0.00 :	  766588:       48 63 0a                movslq (%rdx),%rcx
    0.00 :	  76658b:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  766590:       48 d3 e6                shl    %cl,%rsi
    0.00 :	  766593:       f7 c6 00 0d 00 00       test   $0xd00,%esi
    0.00 :	  766599:       0f 85 b1 00 00 00       jne    766650 <SearchCatCache+0x4c0>
    0.00 :	  76659f:       48 b8 00 00 00 00 01    movabs $0x100000000,%rax
    0.00 :	  7665a6:       00 00 00 
    0.00 :	  7665a9:       48 85 c6                test   %rax,%rsi
    0.00 :	  7665ac:       0f 84 af 00 00 00       je     766661 <SearchCatCache+0x4d1>
    0.00 :	  7665b2:       31 d2                   xor    %edx,%edx
    0.00 :	  7665b4:       80 3d 25 1f 45 00 00    cmpb   $0x0,0x451f25(%rip)        # bb84e0 <criticalRelcachesBuilt>
    0.00 :	  7665bb:       0f 95 c2                setne  %dl
    0.00 :	  7665be:       e9 9d fe ff ff          jmpq   766460 <SearchCatCache+0x2d0>
    0.00 :	  7665c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        continue;                       /* quickly skip entry if wrong hash val */
         :
         :	                /*
         :	                 * see if the cached tuple matches our key.
         :	                 */
         :	                HeapKeyTest(&ct->tuple,
    0.00 :	  7665c8:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  7665cc:       48 98                   cltq   
    0.00 :	  7665ce:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  7665d2:       0f b7 14 10             movzwl (%rax,%rdx,1),%edx
    0.00 :	  7665d6:       e9 55 fd ff ff          jmpq   766330 <SearchCatCache+0x1a0>
         :	                ct->refcount++;
         :	                ResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);
         :	                break;                                  /* assume only one match */
         :	        }
         :
         :	        systable_endscan(scandesc);
    0.00 :	  7665db:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7665de:       e8 3d e5 d3 ff          callq  4a4b20 <systable_endscan>
         :
         :	        heap_close(relation, AccessShareLock);
    0.00 :	  7665e3:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7665e6:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  7665eb:       e8 d0 73 d3 ff          callq  49d9c0 <relation_close>
         :	         * gets created later.  (Bootstrap doesn't do UPDATEs, so it doesn't need
         :	         * cache inval for that.)
         :	         */
         :	        if (ct == NULL)
         :	        {
         :	                if (IsBootstrapProcessingMode())
    0.00 :	  7665f0:       8b 3d 46 25 40 00       mov    0x402546(%rip),%edi        # b68b3c <Mode>
    0.00 :	  7665f6:       85 ff                   test   %edi,%edi
    0.00 :	  7665f8:       0f 84 6a ff ff ff       je     766568 <SearchCatCache+0x3d8>
         :	                        return NULL;
         :
         :	                ntp = build_dummy_tuple(cache, cache->cc_nkeys, cur_skey);
    0.00 :	  7665fe:       48 8b 85 88 fe ff ff    mov    -0x178(%rbp),%rax
    0.00 :	  766605:       48 8d 95 a0 fe ff ff    lea    -0x160(%rbp),%rdx
    0.00 :	  76660c:       8b 70 38                mov    0x38(%rax),%esi
    0.00 :	  76660f:       48 89 c7                mov    %rax,%rdi
    0.00 :	  766612:       e8 59 f1 ff ff          callq  765770 <build_dummy_tuple>
         :	                ct = CatalogCacheCreateEntry(cache, ntp,
    0.00 :	  766617:       8b 8d 9c fe ff ff       mov    -0x164(%rbp),%ecx
    0.00 :	  76661d:       8b 95 98 fe ff ff       mov    -0x168(%rbp),%edx
         :	        if (ct == NULL)
         :	        {
         :	                if (IsBootstrapProcessingMode())
         :	                        return NULL;
         :
         :	                ntp = build_dummy_tuple(cache, cache->cc_nkeys, cur_skey);
    0.00 :	  766623:       48 89 c3                mov    %rax,%rbx
         :	                ct = CatalogCacheCreateEntry(cache, ntp,
    0.00 :	  766626:       48 8b bd 88 fe ff ff    mov    -0x178(%rbp),%rdi
    0.00 :	  76662d:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  766633:       48 89 c6                mov    %rax,%rsi
    0.00 :	  766636:       e8 a5 ee ff ff          callq  7654e0 <CatalogCacheCreateEntry>
         :	                                                                         hashValue, hashIndex,
         :	                                                                         true);
         :	                heap_freetuple(ntp);
    0.00 :	  76663b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  76663e:       31 db                   xor    %ebx,%ebx
    0.00 :	  766640:       e8 7b 86 d0 ff          callq  46ecc0 <heap_freetuple>
         :	#ifdef CATCACHE_STATS
         :	        cache->cc_newloads++;
         :	#endif
         :
         :	        return &ct->tuple;
         :	}
    0.00 :	  766645:       e9 9e fe ff ff          jmpq   7664e8 <SearchCatCache+0x358>
    0.00 :	  76664a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	 *              we don't yet have relcache entries for those catalogs' indexes.
         :	 */
         :	static bool
         :	IndexScanOK(CatCache *cache, ScanKey cur_skey)
         :	{
         :	        switch (cache->id)
    0.00 :	  766650:       31 d2                   xor    %edx,%edx
    0.00 :	  766652:       80 3d 88 1e 45 00 00    cmpb   $0x0,0x451e88(%rip)        # bb84e1 <criticalSharedRelcachesBuilt>
    0.00 :	  766659:       0f 95 c2                setne  %dl
    0.00 :	  76665c:       e9 ff fd ff ff          jmpq   766460 <SearchCatCache+0x2d0>
    0.00 :	  766661:       31 d2                   xor    %edx,%edx
    0.00 :	  766663:       83 e6 06                and    $0x6,%esi
    0.00 :	  766666:       0f 85 f4 fd ff ff       jne    766460 <SearchCatCache+0x2d0>
    0.00 :	  76666c:       e9 ea fd ff ff          jmpq   76645b <SearchCatCache+0x2cb>
    0.00 :	  766671:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        /*
         :	         * one-time startup overhead for each cache
         :	         */
         :	        if (cache->cc_tupdesc == NULL)
         :	                CatalogCacheInitializeCache(cache);
    0.00 :	  766678:       e8 83 df ff ff          callq  764600 <CatalogCacheInitializeCache>
    0.00 :	  76667d:       0f 1f 00                nopl   (%rax)
    0.00 :	  766680:       e9 3d fb ff ff          jmpq   7661c2 <SearchCatCache+0x32>
         :	                 * If it's a positive entry, bump its refcount and return it. If it's
         :	                 * negative, we can report failure to the caller.
         :	                 */
         :	                if (!ct->negative)
         :	                {
         :	                        ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);
    0.00 :	  766685:       48 8b 3d 34 42 45 00    mov    0x454234(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
         :	                        ct->refcount++;
         :	                        ResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);
    0.00 :	  76668c:       49 8d 5c 24 38          lea    0x38(%r12),%rbx
         :	                 * If it's a positive entry, bump its refcount and return it. If it's
         :	                 * negative, we can report failure to the caller.
         :	                 */
         :	                if (!ct->negative)
         :	                {
         :	                        ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);
    0.00 :	  766691:       e8 4a 47 03 00          callq  79ade0 <ResourceOwnerEnlargeCatCacheRefs>
         :	                        ct->refcount++;
    0.00 :	  766696:       41 83 44 24 28 01       addl   $0x1,0x28(%r12)
         :	                        ResourceOwnerRememberCatCacheRef(CurrentResourceOwner, &ct->tuple);
    0.00 :	  76669c:       48 89 de                mov    %rbx,%rsi
    0.00 :	  76669f:       48 8b 3d 1a 42 45 00    mov    0x45421a(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  7666a6:       e8 45 3b 03 00          callq  79a1f0 <ResourceOwnerRememberCatCacheRef>
         :	#ifdef CATCACHE_STATS
         :	        cache->cc_newloads++;
         :	#endif
         :
         :	        return &ct->tuple;
         :	}
    0.00 :	  7666ab:       e9 38 fe ff ff          jmpq   7664e8 <SearchCatCache+0x358>
         :	 * Previous state will be thrown away without any cleanup.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_init(dlist_head *head)
         :	{
         :	        head->head.next = head->head.prev = &head->head;
    0.00 :	  7666b0:       4d 89 3f                mov    %r15,(%r15)
    0.00 :	  7666b3:       4d 89 7f 08             mov    %r15,0x8(%r15)
    0.00 :	  7666b7:       4c 89 f8                mov    %r15,%rax
    0.00 :	  7666ba:       e9 8c fe ff ff          jmpq   76654b <SearchCatCache+0x3bb>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1070
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782c50 <CHashAddToGarbage>:
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c50:       0f b6 4f 14             movzbl 0x14(%rdi),%ecx
         :	{
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c54:       89 d0                   mov    %edx,%eax
         :	 * failure to match an already-deleted item shouldn't cause any problems;
         :	 * this is why gcnext can share space with the hash value.
         :	 */
         :	static void
         :	CHashAddToGarbage(CHashTable table, uint32 bucket, CHashPtr c)
         :	{
    0.00 :	  782c56:       55                      push   %rbp
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c57:       d1 e8                   shr    %eax
    0.00 :	  782c59:       41 89 c0                mov    %eax,%r8d
         :	 * failure to match an already-deleted item shouldn't cause any problems;
         :	 * this is why gcnext can share space with the hash value.
         :	 */
         :	static void
         :	CHashAddToGarbage(CHashTable table, uint32 bucket, CHashPtr c)
         :	{
    0.00 :	  782c5c:       48 89 e5                mov    %rsp,%rbp
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c5f:       44 0f af 47 1c          imul   0x1c(%rdi),%r8d
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c64:       d3 ee                   shr    %cl,%esi
    0.00 :	  782c66:       0f b6 4f 15             movzbl 0x15(%rdi),%ecx
    0.00 :	  782c6a:       89 f0                   mov    %esi,%eax
         :	{
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c6c:       4c 03 47 30             add    0x30(%rdi),%r8
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c70:       d3 e8                   shr    %cl,%eax
    0.00 :	  782c72:       01 f0                   add    %esi,%eax
    0.00 :	  782c74:       48 8d 0c 85 00 00 00    lea    0x0(,%rax,4),%rcx
    0.00 :	  782c7b:       00 
    0.00 :	  782c7c:       48 03 4f 28             add    0x28(%rdi),%rcx
    0.00 :	  782c80:       eb 0e                   jmp    782c90 <CHashAddToGarbage+0x40>
    0.00 :	  782c82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        {
         :	                g = *garbage;
         :	                n->un.gcnext = g;
         :	                if (__sync_bool_compare_and_swap(garbage, g, c))
         :	                        break;
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Enqueue_Retry);
    0.00 :	  782c88:       48 83 87 a8 00 00 00    addq   $0x1,0xa8(%rdi)
    0.00 :	  782c8f:       01 
         :	        n = CHashTableGetNode(table, c);
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
         :
         :	        while (1)
         :	        {
         :	                g = *garbage;
    0.00 :	  782c90:       8b 01                   mov    (%rcx),%eax
         :	                n->un.gcnext = g;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1070
  100.00 :	  782c92:       41 89 40 04             mov    %eax,0x4(%r8)
         :	                if (__sync_bool_compare_and_swap(garbage, g, c))
    0.00 :	  782c96:       f0 0f b1 11             lock cmpxchg %edx,(%rcx)
    0.00 :	  782c9a:       75 ec                   jne    782c88 <CHashAddToGarbage+0x38>
         :	                        break;
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Enqueue_Retry);
         :	        }
         :	}
    0.00 :	  782c9c:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:645
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782de0 <CHashDelete>:
         :	 * Delete from a concurrent hash table.  entry need only contain the key field.
         :	 * Returns true if we find and delete a matching key and false otherwise.
         :	 */
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
    0.00 :	  782de0:       55                      push   %rbp
    0.00 :	  782de1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782de4:       41 57                   push   %r15
    0.00 :	  782de6:       41 56                   push   %r14
    0.00 :	  782de8:       49 89 f6                mov    %rsi,%r14
    0.00 :	  782deb:       41 55                   push   %r13
    0.00 :	  782ded:       41 54                   push   %r12
    0.00 :	  782def:       53                      push   %rbx
    0.00 :	  782df0:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  782df3:       48 83 ec 58             sub    $0x58,%rsp
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  782df7:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  782dfb:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  782dfe:       e8 4d d5 d0 ff          callq  490350 <hash_any>
    0.00 :	  782e03:       41 89 c5                mov    %eax,%r13d
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782e06:       8b 43 10                mov    0x10(%rbx),%eax
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e09:       0f b6 4b 14             movzbl 0x14(%rbx),%ecx
         :	 */
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782e0d:       44 21 e8                and    %r13d,%eax
    0.00 :	  782e10:       89 45 8c                mov    %eax,-0x74(%rbp)
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e13:       8b 55 8c                mov    -0x74(%rbp),%edx
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782e16:       89 c0                   mov    %eax,%eax
    0.00 :	  782e18:       4c 8d 24 85 00 00 00    lea    0x0(,%rax,4),%r12
    0.00 :	  782e1f:       00 
    0.00 :	  782e20:       4c 03 63 20             add    0x20(%rbx),%r12
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e24:       d3 ea                   shr    %cl,%edx
    0.00 :	  782e26:       0f b6 4b 15             movzbl 0x15(%rbx),%ecx
    0.00 :	  782e2a:       89 d0                   mov    %edx,%eax
    0.00 :	  782e2c:       d3 e8                   shr    %cl,%eax
    0.00 :	  782e2e:       01 d0                   add    %edx,%eax
    0.00 :	  782e30:       48 8b 15 11 ab 3f 00    mov    0x3fab11(%rip),%rdx        # b7d948 <MyProc>
    0.00 :	  782e37:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  782e3b:       48 03 43 28             add    0x28(%rbx),%rax
    0.00 :	  782e3f:       48 89 82 e8 02 00 00    mov    %rax,0x2e8(%rdx)
         :	        pg_memory_barrier();
    0.00 :	  782e46:       f0 83 04 24 00          lock addl $0x0,(%rsp)
    0.00 :	  782e4b:       4c 8d 7d b0             lea    -0x50(%rbp),%r15
    0.00 :	  782e4f:       eb 1e                   jmp    782e6f <CHashDelete+0x8f>
    0.00 :	  782e51:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        if (scan.found)
         :	        {
         :	                Assert(!CHashPtrIsMarked(scan.next));
         :
         :	                /* Attempt to apply delete-mark. */
         :	                if (!__sync_bool_compare_and_swap(&scan.target_node->next,
    0.00 :	  782e58:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  782e5b:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  782e5f:       89 c1                   mov    %eax,%ecx
    0.00 :	  782e61:       83 c9 01                or     $0x1,%ecx
    0.00 :	  782e64:       f0 0f b1 0a             lock cmpxchg %ecx,(%rdx)
    0.00 :	  782e68:       74 5e                   je     782ec8 <CHashDelete+0xe8>
         :	                                                                                  scan.next,
         :	                                                                                  CHashPtrMark(scan.next)))
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_Delete_Retry);
    0.00 :	  782e6a:       48 83 43 78 01          addq   $0x1,0x78(%rbx)
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
         :	        pg_memory_barrier();
         :
         :	        /* Scan bucket. */
         :	retry:
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
    0.00 :	  782e6f:       4d 89 f8                mov    %r15,%r8
    0.00 :	  782e72:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  782e75:       44 89 ea                mov    %r13d,%edx
    0.00 :	  782e78:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  782e7b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782e7e:       e8 1d fe ff ff          callq  782ca0 <CHashBucketScan>
         :
         :	        /* If we found it, try to delete it. */
         :	        if (scan.found)
    0.00 :	  782e83:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  782e87:       75 cf                   jne    782e58 <CHashDelete+0x78>
         :	                }
         :	        }
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  782e89:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
    0.00 :	  782e8e:       48 8b 05 b3 aa 3f 00    mov    0x3faab3(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  782e95:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  782e9c:       00 00 00 00 
         :
         :	        /* We're done. */
         :	        CHashTableIncrementStatistic(table, CHS_Delete);
         :	        if (!scan.found)
    0.00 :	  782ea0:       0f b6 45 c8             movzbl -0x38(%rbp),%eax
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
         :	        MyProc->hazard[0] = NULL;
         :
         :	        /* We're done. */
         :	        CHashTableIncrementStatistic(table, CHS_Delete);
    0.00 :	  782ea4:       48 83 43 68 01          addq   $0x1,0x68(%rbx)
         :	        if (!scan.found)
    0.00 :	  782ea9:       84 c0                   test   %al,%al
    0.00 :	  782eab:       75 05                   jne    782eb2 <CHashDelete+0xd2>
         :	                CHashTableIncrementStatistic(table, CHS_Delete_Failed);
    0.00 :	  782ead:       48 83 43 70 01          addq   $0x1,0x70(%rbx)
         :	        return scan.found;
         :	}
    0.00 :	  782eb2:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  782eb6:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:645
  100.00 :	  782eb7:       41 5c                   pop    %r12
    0.00 :	  782eb9:       41 5d                   pop    %r13
    0.00 :	  782ebb:       41 5e                   pop    %r14
    0.00 :	  782ebd:       41 5f                   pop    %r15
    0.00 :	  782ebf:       c9                      leaveq 
    0.00 :	  782ec0:       c3                      retq   
    0.00 :	  782ec1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        CHashTableIncrementStatistic(table, CHS_Delete_Retry);
         :	                        goto retry;
         :	                }
         :
         :	                /* Deletion is done; attempt to remove node from list. */
         :	                if (__sync_bool_compare_and_swap(scan.pointer_to_target,
    0.00 :	  782ec8:       8b 55 b0                mov    -0x50(%rbp),%edx
    0.00 :	  782ecb:       48 8b 75 b8             mov    -0x48(%rbp),%rsi
    0.00 :	  782ecf:       8b 4d b4                mov    -0x4c(%rbp),%ecx
    0.00 :	  782ed2:       89 d0                   mov    %edx,%eax
    0.00 :	  782ed4:       f0 0f b1 0e             lock cmpxchg %ecx,(%rsi)
    0.00 :	  782ed8:       75 16                   jne    782ef0 <CHashDelete+0x110>
         :	                                                                                 scan.target,
         :	                                                                                 scan.next))
         :	                        CHashAddToGarbage(table, bucket, scan.target);
    0.00 :	  782eda:       8b 55 b0                mov    -0x50(%rbp),%edx
    0.00 :	  782edd:       8b 75 8c                mov    -0x74(%rbp),%esi
    0.00 :	  782ee0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782ee3:       e8 68 fd ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  782ee8:       eb 9f                   jmp    782e89 <CHashDelete+0xa9>
    0.00 :	  782eea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * like a regular bucket scan, except that we don't care
         :	                         * about the results.  We're just doing it to achieve the
         :	                         * side-effect of removing delete-marked nodes from the
         :	                         * bucket chain.
         :	                         */
         :	                        CHashTableIncrementStatistic(table, CHS_Cleanup_Scan);
    0.00 :	  782ef0:       48 83 83 98 00 00 00    addq   $0x1,0x98(%rbx)
    0.00 :	  782ef7:       01 
         :	                        CHashBucketScan(table, b, hashcode, entry, &cleanup_scan);
    0.00 :	  782ef8:       4c 8d 45 90             lea    -0x70(%rbp),%r8
    0.00 :	  782efc:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  782eff:       44 89 ea                mov    %r13d,%edx
    0.00 :	  782f02:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  782f05:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782f08:       e8 93 fd ff ff          callq  782ca0 <CHashBucketScan>
    0.00 :	  782f0d:       e9 77 ff ff ff          jmpq   782e89 <CHashDelete+0xa9>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:736
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798110 <AllocSetAlloc>:
         :	 *              MAXALIGN_DOWN(SIZE_MAX) - ALLOC_BLOCKHDRSZ - ALLOC_CHUNKHDRSZ
         :	 * All callers use a much-lower limit.
         :	 */
         :	static void *
         :	AllocSetAlloc(MemoryContext context, Size size)
         :	{
    0.00 :	  798110:       55                      push   %rbp
    0.00 :	  798111:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  798114:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  798118:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  79811c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  79811f:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  798123:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  798127:       49 89 f6                mov    %rsi,%r14
    0.00 :	  79812a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  79812e:       48 83 ec 30             sub    $0x30,%rsp
         :
         :	        /*
         :	         * If requested size exceeds maximum for chunks, allocate an entire block
         :	         * for this request.
         :	         */
         :	        if (size > set->allocChunkLimit)
    0.00 :	  798132:       48 39 b7 b0 00 00 00    cmp    %rsi,0xb0(%rdi)
    0.00 :	  798139:       72 6d                   jb     7981a8 <AllocSetAlloc+0x98>
         :	{
         :	        int                     idx;
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
    0.00 :	  79813b:       31 f6                   xor    %esi,%esi
    0.00 :	  79813d:       49 83 fe 08             cmp    $0x8,%r14
    0.00 :	  798141:       77 3d                   ja     798180 <AllocSetAlloc+0x70>
         :	         * corresponding free list to see if there is a free chunk we could reuse.
         :	         * If one is found, remove it from the free list, make it again a member
         :	         * of the alloc set and return its data address.
         :	         */
         :	        fidx = AllocSetFreeIndex(size);
         :	        chunk = set->freelist[fidx];
    0.00 :	  798143:       48 63 c6                movslq %esi,%rax
    0.00 :	  798146:       48 8d 48 08             lea    0x8(%rax),%rcx
    0.00 :	  79814a:       49 8b 14 cc             mov    (%r12,%rcx,8),%rdx
         :	        if (chunk != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:736
  100.00 :	  79814e:       48 85 d2                test   %rdx,%rdx
    0.00 :	  798151:       0f 84 c9 00 00 00       je     798220 <AllocSetAlloc+0x110>
         :	        {
         :	                Assert(chunk->size >= size);
         :
         :	                set->freelist[fidx] = (AllocChunk) chunk->aset;
    0.00 :	  798157:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  79815a:       49 89 04 cc             mov    %rax,(%r12,%rcx,8)
         :	                /* fill the allocated space with junk */
         :	                randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	                AllocAllocInfo(set, chunk);
         :	                return AllocChunkGetPointer(chunk);
    0.00 :	  79815e:       48 8d 42 10             lea    0x10(%rdx),%rax
         :	        {
         :	                Assert(chunk->size >= size);
         :
         :	                set->freelist[fidx] = (AllocChunk) chunk->aset;
         :
         :	                chunk->aset = (void *) set;
    0.00 :	  798162:       4c 89 22                mov    %r12,(%rdx)
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  798165:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  798169:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  79816d:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  798171:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  798175:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  798179:       c9                      leaveq 
    0.00 :	  79817a:       c3                      retq   
    0.00 :	  79817b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
         :	        {
         :	                tsize = (size - 1) >> ALLOC_MINBITS;
    0.00 :	  798180:       49 8d 46 ff             lea    -0x1(%r14),%rax
    0.00 :	  798184:       48 89 c2                mov    %rax,%rdx
    0.00 :	  798187:       48 c1 ea 03             shr    $0x3,%rdx
         :	                 * justify micro-optimization effort.  The best approach seems to be
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
    0.00 :	  79818b:       89 d0                   mov    %edx,%eax
    0.00 :	  79818d:       c1 e8 08                shr    $0x8,%eax
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798190:       85 c0                   test   %eax,%eax
    0.00 :	  798192:       74 7c                   je     798210 <AllocSetAlloc+0x100>
    0.00 :	  798194:       89 c0                   mov    %eax,%eax
    0.00 :	  798196:       0f b6 80 80 1e 8e 00    movzbl 0x8e1e80(%rax),%eax
    0.00 :	  79819d:       8d 70 08                lea    0x8(%rax),%esi
    0.00 :	  7981a0:       eb a1                   jmp    798143 <AllocSetAlloc+0x33>
    0.00 :	  7981a2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * If requested size exceeds maximum for chunks, allocate an entire block
         :	         * for this request.
         :	         */
         :	        if (size > set->allocChunkLimit)
         :	        {
         :	                chunk_size = MAXALIGN(size);
    0.00 :	  7981a8:       48 8d 5e 07             lea    0x7(%rsi),%rbx
    0.00 :	  7981ac:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    0.00 :	  7981b0:       4c 8d 6b 30             lea    0x30(%rbx),%r13
         :	                block = (AllocBlock) malloc(blksize);
    0.00 :	  7981b4:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7981b7:       e8 74 14 cd ff          callq  469630 <malloc@plt>
         :	                if (block == NULL)
    0.00 :	  7981bc:       48 85 c0                test   %rax,%rax
         :	         */
         :	        if (size > set->allocChunkLimit)
         :	        {
         :	                chunk_size = MAXALIGN(size);
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                block = (AllocBlock) malloc(blksize);
    0.00 :	  7981bf:       48 89 c2                mov    %rax,%rdx
         :	                if (block == NULL)
    0.00 :	  7981c2:       0f 84 2e 02 00 00       je     7983f6 <AllocSetAlloc+0x2e6>
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
    0.00 :	  7981c8:       4c 89 20                mov    %r12,(%rax)
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
    0.00 :	  7981cb:       48 8d 72 20             lea    0x20(%rdx),%rsi
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
    0.00 :	  7981cf:       4a 8d 04 28             lea    (%rax,%r13,1),%rax
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
         :	                chunk->aset = set;
    0.00 :	  7981d3:       4c 89 62 20             mov    %r12,0x20(%rdx)
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
    0.00 :	  7981d7:       48 89 42 18             mov    %rax,0x18(%rdx)
    0.00 :	  7981db:       48 89 42 10             mov    %rax,0x10(%rdx)
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
         :	                chunk->aset = set;
         :	                chunk->size = chunk_size;
    0.00 :	  7981df:       48 89 5e 08             mov    %rbx,0x8(%rsi)
         :
         :	                /*
         :	                 * Stick the new block underneath the active allocation block, so that
         :	                 * we don't lose the use of the space remaining therein.
         :	                 */
         :	                if (set->blocks != NULL)
    0.00 :	  7981e3:       49 8b 4c 24 38          mov    0x38(%r12),%rcx
    0.00 :	  7981e8:       48 85 c9                test   %rcx,%rcx
    0.00 :	  7981eb:       0f 84 cf 01 00 00       je     7983c0 <AllocSetAlloc+0x2b0>
         :	                {
         :	                        block->next = set->blocks->next;
    0.00 :	  7981f1:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  7981f5:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                        set->blocks->next = block;
    0.00 :	  7981f9:       48 89 51 08             mov    %rdx,0x8(%rcx)
         :	                 * if any, NOACCESS.
         :	                 */
         :	                VALGRIND_MAKE_MEM_NOACCESS((char *) chunk + ALLOC_CHUNK_PUBLIC,
         :	                                                 chunk_size + ALLOC_CHUNKHDRSZ - ALLOC_CHUNK_PUBLIC);
         :
         :	                return AllocChunkGetPointer(chunk);
    0.00 :	  7981fd:       48 8d 46 10             lea    0x10(%rsi),%rax
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  798201:       e9 5f ff ff ff          jmpq   798165 <AllocSetAlloc+0x55>
    0.00 :	  798206:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  79820d:       00 00 00 
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798210:       89 d0                   mov    %edx,%eax
    0.00 :	  798212:       0f b6 b0 80 1e 8e 00    movzbl 0x8e1e80(%rax),%esi
    0.00 :	  798219:       e9 25 ff ff ff          jmpq   798143 <AllocSetAlloc+0x33>
    0.00 :	  79821e:       66 90                   xchg   %ax,%ax
         :
         :	        /*
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
    0.00 :	  798220:       4d 8b 4c 24 38          mov    0x38(%r12),%r9
         :	        }
         :
         :	        /*
         :	         * Choose the actual chunk size to allocate.
         :	         */
         :	        chunk_size = (1 << ALLOC_MINBITS) << fidx;
    0.00 :	  798225:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	  79822a:       89 f1                   mov    %esi,%ecx
    0.00 :	  79822c:       d3 e0                   shl    %cl,%eax
    0.00 :	  79822e:       4c 63 f8                movslq %eax,%r15
         :
         :	        /*
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
    0.00 :	  798231:       4d 85 c9                test   %r9,%r9
    0.00 :	  798234:       0f 84 ce 00 00 00       je     798308 <AllocSetAlloc+0x1f8>
         :	        {
         :	                Size            availspace = block->endptr - block->freeptr;
    0.00 :	  79823a:       49 8b 79 10             mov    0x10(%r9),%rdi
    0.00 :	  79823e:       4d 8b 41 18             mov    0x18(%r9),%r8
         :
         :	                if (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))
    0.00 :	  798242:       49 8d 47 10             lea    0x10(%r15),%rax
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
         :	        {
         :	                Size            availspace = block->endptr - block->freeptr;
    0.00 :	  798246:       49 29 f8                sub    %rdi,%r8
         :
         :	                if (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))
    0.00 :	  798249:       49 39 c0                cmp    %rax,%r8
    0.00 :	  79824c:       0f 83 52 01 00 00       jae    7983a4 <AllocSetAlloc+0x294>
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  798252:       49 83 f8 17             cmp    $0x17,%r8
    0.00 :	  798256:       0f 86 ac 00 00 00       jbe    798308 <AllocSetAlloc+0x1f8>
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  79825c:       41 ba 01 00 00 00       mov    $0x1,%r10d
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  798262:       49 c7 c3 f0 ff ff ff    mov    $0xfffffffffffffff0,%r11
    0.00 :	  798269:       eb 5d                   jmp    7982c8 <AllocSetAlloc+0x1b8>
    0.00 :	  79826b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798270:       89 c0                   mov    %eax,%eax
    0.00 :	  798272:       0f b6 88 80 1e 8e 00    movzbl 0x8e1e80(%rax),%ecx
    0.00 :	  798279:       4c 89 d0                mov    %r10,%rax
    0.00 :	  79827c:       8d 51 08                lea    0x8(%rcx),%edx
    0.00 :	  79827f:       83 c1 0b                add    $0xb,%ecx
    0.00 :	  798282:       48 d3 e0                shl    %cl,%rax
         :	                                /*
         :	                                 * In most cases, we'll get back the index of the next larger
         :	                                 * freelist than the one we need to put this chunk on.  The
         :	                                 * exception is when availchunk is exactly a power of 2.
         :	                                 */
         :	                                if (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))
    0.00 :	  798285:       48 39 c6                cmp    %rax,%rsi
    0.00 :	  798288:       74 0c                   je     798296 <AllocSetAlloc+0x186>
         :	                                {
         :	                                        a_fidx--;
    0.00 :	  79828a:       83 ea 01                sub    $0x1,%edx
         :	                                        Assert(a_fidx >= 0);
         :	                                        availchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));
    0.00 :	  79828d:       4c 89 d6                mov    %r10,%rsi
    0.00 :	  798290:       8d 4a 03                lea    0x3(%rdx),%ecx
    0.00 :	  798293:       48 d3 e6                shl    %cl,%rsi
         :	                                chunk = (AllocChunk) (block->freeptr);
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  798296:       48 8d 44 37 10          lea    0x10(%rdi,%rsi,1),%rax
    0.00 :	  79829b:       49 89 41 10             mov    %rax,0x10(%r9)
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  79829f:       4c 89 d8                mov    %r11,%rax
         :
         :	                                chunk->size = availchunk;
    0.00 :	  7982a2:       48 89 77 08             mov    %rsi,0x8(%rdi)
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  7982a6:       48 29 f0                sub    %rsi,%rax
    0.00 :	  7982a9:       49 01 c0                add    %rax,%r8
         :
         :	                                chunk->size = availchunk;
         :	#ifdef MEMORY_CONTEXT_CHECKING
         :	                                chunk->requested_size = 0;              /* mark it free */
         :	#endif
         :	                                chunk->aset = (void *) set->freelist[a_fidx];
    0.00 :	  7982ac:       48 63 c2                movslq %edx,%rax
    0.00 :	  7982af:       48 83 c0 08             add    $0x8,%rax
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  7982b3:       49 83 f8 17             cmp    $0x17,%r8
         :
         :	                                chunk->size = availchunk;
         :	#ifdef MEMORY_CONTEXT_CHECKING
         :	                                chunk->requested_size = 0;              /* mark it free */
         :	#endif
         :	                                chunk->aset = (void *) set->freelist[a_fidx];
    0.00 :	  7982b7:       49 8b 14 c4             mov    (%r12,%rax,8),%rdx
    0.00 :	  7982bb:       48 89 17                mov    %rdx,(%rdi)
         :	                                set->freelist[a_fidx] = chunk;
    0.00 :	  7982be:       49 89 3c c4             mov    %rdi,(%r12,%rax,8)
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  7982c2:       76 44                   jbe    798308 <AllocSetAlloc+0x1f8>
    0.00 :	  7982c4:       49 8b 79 10             mov    0x10(%r9),%rdi
         :	                        {
         :	                                Size            availchunk = availspace - ALLOC_CHUNKHDRSZ;
    0.00 :	  7982c8:       49 8d 70 f0             lea    -0x10(%r8),%rsi
         :	{
         :	        int                     idx;
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
    0.00 :	  7982cc:       31 d2                   xor    %edx,%edx
    0.00 :	  7982ce:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	  7982d3:       48 83 fe 08             cmp    $0x8,%rsi
    0.00 :	  7982d7:       76 ac                   jbe    798285 <AllocSetAlloc+0x175>
         :	        {
         :	                tsize = (size - 1) >> ALLOC_MINBITS;
    0.00 :	  7982d9:       49 8d 40 ef             lea    -0x11(%r8),%rax
    0.00 :	  7982dd:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7982e0:       48 c1 ea 03             shr    $0x3,%rdx
         :	                 * justify micro-optimization effort.  The best approach seems to be
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
    0.00 :	  7982e4:       89 d0                   mov    %edx,%eax
    0.00 :	  7982e6:       c1 e8 08                shr    $0x8,%eax
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  7982e9:       85 c0                   test   %eax,%eax
    0.00 :	  7982eb:       75 83                   jne    798270 <AllocSetAlloc+0x160>
    0.00 :	  7982ed:       89 d0                   mov    %edx,%eax
    0.00 :	  7982ef:       0f b6 90 80 1e 8e 00    movzbl 0x8e1e80(%rax),%edx
    0.00 :	  7982f6:       4c 89 d0                mov    %r10,%rax
    0.00 :	  7982f9:       8d 4a 03                lea    0x3(%rdx),%ecx
    0.00 :	  7982fc:       48 d3 e0                shl    %cl,%rax
    0.00 :	  7982ff:       eb 84                   jmp    798285 <AllocSetAlloc+0x175>
    0.00 :	  798301:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
    0.00 :	  798308:       49 8b 94 24 a8 00 00    mov    0xa8(%r12),%rdx
    0.00 :	  79830f:       00 
         :	                set->nextBlockSize <<= 1;
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  798310:       49 8b 8c 24 a0 00 00    mov    0xa0(%r12),%rcx
    0.00 :	  798317:       00 
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
         :	                set->nextBlockSize <<= 1;
    0.00 :	  798318:       48 8d 04 12             lea    (%rdx,%rdx,1),%rax
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  79831c:       48 39 c8                cmp    %rcx,%rax
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
         :	                set->nextBlockSize <<= 1;
    0.00 :	  79831f:       49 89 84 24 a8 00 00    mov    %rax,0xa8(%r12)
    0.00 :	  798326:       00 
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  798327:       76 08                   jbe    798331 <AllocSetAlloc+0x221>
         :	                        set->nextBlockSize = set->maxBlockSize;
    0.00 :	  798329:       49 89 8c 24 a8 00 00    mov    %rcx,0xa8(%r12)
    0.00 :	  798330:       00 
         :
         :	                /*
         :	                 * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more
         :	                 * space... but try to keep it a power of 2.
         :	                 */
         :	                required_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    0.00 :	  798331:       4d 8d 6f 30             lea    0x30(%r15),%r13
         :	                while (blksize < required_size)
    0.00 :	  798335:       4c 39 ea                cmp    %r13,%rdx
    0.00 :	  798338:       73 0e                   jae    798348 <AllocSetAlloc+0x238>
    0.00 :	  79833a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        blksize <<= 1;
    0.00 :	  798340:       48 01 d2                add    %rdx,%rdx
         :	                /*
         :	                 * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more
         :	                 * space... but try to keep it a power of 2.
         :	                 */
         :	                required_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                while (blksize < required_size)
    0.00 :	  798343:       49 39 d5                cmp    %rdx,%r13
    0.00 :	  798346:       77 f8                   ja     798340 <AllocSetAlloc+0x230>
    0.00 :	  798348:       48 89 d3                mov    %rdx,%rbx
    0.00 :	  79834b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                while (block == NULL && blksize > 1024 * 1024)
         :	                {
         :	                        blksize >>= 1;
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
    0.00 :	  798350:       48 89 df                mov    %rbx,%rdi
    0.00 :	  798353:       e8 d8 12 cd ff          callq  469630 <malloc@plt>
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  798358:       48 85 c0                test   %rax,%rax
         :	                {
         :	                        blksize >>= 1;
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
    0.00 :	  79835b:       48 89 c2                mov    %rax,%rdx
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  79835e:       74 78                   je     7983d8 <AllocSetAlloc+0x2c8>
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
    0.00 :	  798360:       48 85 d2                test   %rdx,%rdx
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  798363:       49 89 d1                mov    %rdx,%r9
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
    0.00 :	  798366:       0f 84 10 01 00 00       je     79847c <AllocSetAlloc+0x36c>
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :
         :	                block->aset = set;
         :	                block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    0.00 :	  79836c:       48 8d 42 20             lea    0x20(%rdx),%rax
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :
         :	                block->aset = set;
    0.00 :	  798370:       4c 89 22                mov    %r12,(%rdx)
         :	                block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    0.00 :	  798373:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	                block->endptr = ((char *) block) + blksize;
    0.00 :	  798377:       48 8d 04 1a             lea    (%rdx,%rbx,1),%rax
    0.00 :	  79837b:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	                 * cycling even for contexts created with minContextSize = 0; that way
         :	                 * we don't have to force space to be allocated in contexts that might
         :	                 * never need any space.  Don't mark an oversize block as a keeper,
         :	                 * however.
         :	                 */
         :	                if (set->keeper == NULL && blksize == set->initBlockSize)
    0.00 :	  79837f:       49 83 bc 24 b8 00 00    cmpq   $0x0,0xb8(%r12)
    0.00 :	  798386:       00 00 
    0.00 :	  798388:       0f 84 99 00 00 00       je     798427 <AllocSetAlloc+0x317>
         :
         :	                /* Mark unallocated space NOACCESS. */
         :	                VALGRIND_MAKE_MEM_NOACCESS(block->freeptr,
         :	                                                                   blksize - ALLOC_BLOCKHDRSZ);
         :
         :	                block->next = set->blocks;
    0.00 :	  79838e:       49 8b 44 24 38          mov    0x38(%r12),%rax
    0.00 :	  798393:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                set->blocks = block;
    0.00 :	  798397:       49 89 54 24 38          mov    %rdx,0x38(%r12)
    0.00 :	  79839c:       49 8d 47 10             lea    0x10(%r15),%rax
    0.00 :	  7983a0:       48 8b 7a 10             mov    0x10(%rdx),%rdi
         :	        chunk = (AllocChunk) (block->freeptr);
         :
         :	        /* Prepare to initialize the chunk header. */
         :	        VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	        block->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);
    0.00 :	  7983a4:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  7983a8:       49 89 41 10             mov    %rax,0x10(%r9)
         :	        Assert(block->freeptr <= block->endptr);
         :
         :	        chunk->aset = (void *) set;
    0.00 :	  7983ac:       4c 89 27                mov    %r12,(%rdi)
         :	        /* fill the allocated space with junk */
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
    0.00 :	  7983af:       48 8d 47 10             lea    0x10(%rdi),%rax
         :
         :	        block->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);
         :	        Assert(block->freeptr <= block->endptr);
         :
         :	        chunk->aset = (void *) set;
         :	        chunk->size = chunk_size;
    0.00 :	  7983b3:       4c 89 7f 08             mov    %r15,0x8(%rdi)
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  7983b7:       e9 a9 fd ff ff          jmpq   798165 <AllocSetAlloc+0x55>
    0.00 :	  7983bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        block->next = set->blocks->next;
         :	                        set->blocks->next = block;
         :	                }
         :	                else
         :	                {
         :	                        block->next = NULL;
    0.00 :	  7983c0:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)
    0.00 :	  7983c7:       00 
         :	                        set->blocks = block;
    0.00 :	  7983c8:       49 89 54 24 38          mov    %rdx,0x38(%r12)
    0.00 :	  7983cd:       e9 2b fe ff ff          jmpq   7981fd <AllocSetAlloc+0xed>
    0.00 :	  7983d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  7983d8:       48 81 fb 00 00 10 00    cmp    $0x100000,%rbx
    0.00 :	  7983df:       0f 86 7b ff ff ff       jbe    798360 <AllocSetAlloc+0x250>
         :	                {
         :	                        blksize >>= 1;
    0.00 :	  7983e5:       48 d1 eb                shr    %rbx
         :	                        if (blksize < required_size)
    0.00 :	  7983e8:       49 39 dd                cmp    %rbx,%r13
    0.00 :	  7983eb:       0f 86 5f ff ff ff       jbe    798350 <AllocSetAlloc+0x240>
    0.00 :	  7983f1:       e9 6a ff ff ff          jmpq   798360 <AllocSetAlloc+0x250>
         :	                chunk_size = MAXALIGN(size);
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                block = (AllocBlock) malloc(blksize);
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
    0.00 :	  7983f6:       48 8b 3d 6b 24 42 00    mov    0x42246b(%rip),%rdi        # bba868 <TopMemoryContext>
    0.00 :	  7983fd:       e8 3e 07 00 00          callq  798b40 <MemoryContextStats>
         :	                        ereport(ERROR,
    0.00 :	  798402:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  798405:       b9 80 1f 8e 00          mov    $0x8e1f80,%ecx
    0.00 :	  79840a:       ba a7 02 00 00          mov    $0x2a7,%edx
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
         :	                        ereport(ERROR,
    0.00 :	  79840f:       be 6d 1d 8e 00          mov    $0x8e1d6d,%esi
    0.00 :	  798414:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  798419:       e8 a2 26 fe ff          callq  77aac0 <errstart>
    0.00 :	  79841e:       84 c0                   test   %al,%al
    0.00 :	  798420:       75 20                   jne    798442 <AllocSetAlloc+0x332>
    0.00 :	  798422:       e8 a9 10 cd ff          callq  4694d0 <abort@plt>
         :	                 * cycling even for contexts created with minContextSize = 0; that way
         :	                 * we don't have to force space to be allocated in contexts that might
         :	                 * never need any space.  Don't mark an oversize block as a keeper,
         :	                 * however.
         :	                 */
         :	                if (set->keeper == NULL && blksize == set->initBlockSize)
    0.00 :	  798427:       49 39 9c 24 98 00 00    cmp    %rbx,0x98(%r12)
    0.00 :	  79842e:       00 
    0.00 :	  79842f:       0f 85 59 ff ff ff       jne    79838e <AllocSetAlloc+0x27e>
         :	                        set->keeper = block;
    0.00 :	  798435:       49 89 94 24 b8 00 00    mov    %rdx,0xb8(%r12)
    0.00 :	  79843c:       00 
    0.00 :	  79843d:       e9 4c ff ff ff          jmpq   79838e <AllocSetAlloc+0x27e>
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
         :	                        ereport(ERROR,
    0.00 :	  798442:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  798445:       bf a8 1d 8e 00          mov    $0x8e1da8,%edi
    0.00 :	  79844a:       31 c0                   xor    %eax,%eax
    0.00 :	  79844c:       e8 df 40 fe ff          callq  77c530 <errdetail>
    0.00 :	  798451:       bf 04 9c 7b 00          mov    $0x7b9c04,%edi
    0.00 :	  798456:       41 89 c4                mov    %eax,%r12d
    0.00 :	  798459:       31 c0                   xor    %eax,%eax
    0.00 :	  79845b:       e8 40 44 fe ff          callq  77c8a0 <errmsg>
    0.00 :	  798460:       bf c5 20 00 00          mov    $0x20c5,%edi
    0.00 :	  798465:       89 c3                   mov    %eax,%ebx
    0.00 :	  798467:       e8 e4 48 fe ff          callq  77cd50 <errcode>
    0.00 :	  79846c:       44 89 e2                mov    %r12d,%edx
    0.00 :	  79846f:       89 c7                   mov    %eax,%edi
    0.00 :	  798471:       89 de                   mov    %ebx,%esi
    0.00 :	  798473:       31 c0                   xor    %eax,%eax
    0.00 :	  798475:       e8 66 21 fe ff          callq  77a5e0 <errfinish>
    0.00 :	  79847a:       eb a6                   jmp    798422 <AllocSetAlloc+0x312>
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
    0.00 :	  79847c:       48 8b 3d e5 23 42 00    mov    0x4223e5(%rip),%rdi        # bba868 <TopMemoryContext>
    0.00 :	  798483:       e8 b8 06 00 00          callq  798b40 <MemoryContextStats>
         :	                        ereport(ERROR,
    0.00 :	  798488:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  79848b:       b9 80 1f 8e 00          mov    $0x8e1f80,%ecx
    0.00 :	  798490:       ba 69 03 00 00          mov    $0x369,%edx
    0.00 :	  798495:       e9 75 ff ff ff          jmpq   79840f <AllocSetAlloc+0x2ff>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:550
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007990c0 <MemoryContextCreate>:
         :	MemoryContext
         :	MemoryContextCreate(NodeTag tag, Size size,
         :	                                        MemoryContextMethods *methods,
         :	                                        MemoryContext parent,
         :	                                        const char *name)
         :	{
    0.00 :	  7990c0:       55                      push   %rbp
    0.00 :	  7990c1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7990c4:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  7990c8:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  7990cc:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7990cf:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  7990d3:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:550
  100.00 :	  7990d7:       49 89 cd                mov    %rcx,%r13
    0.00 :	  7990da:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  7990de:       48 83 ec 30             sub    $0x30,%rsp
    0.00 :	  7990e2:       89 7d d4                mov    %edi,-0x2c(%rbp)
         :	        MemoryContext node;
         :	        Size            needed = size + strlen(name) + 1;
    0.00 :	  7990e5:       4c 89 c7                mov    %r8,%rdi
         :	MemoryContext
         :	MemoryContextCreate(NodeTag tag, Size size,
         :	                                        MemoryContextMethods *methods,
         :	                                        MemoryContext parent,
         :	                                        const char *name)
         :	{
    0.00 :	  7990e8:       49 89 d7                mov    %rdx,%r15
    0.00 :	  7990eb:       4d 89 c6                mov    %r8,%r14
         :	        MemoryContext node;
         :	        Size            needed = size + strlen(name) + 1;
    0.00 :	  7990ee:       e8 5d 07 cd ff          callq  469850 <strlen@plt>
         :
         :	        /* creating new memory contexts is not allowed in a critical section */
         :	        Assert(CritSectionCount == 0);
         :
         :	        /* Get space for node and name */
         :	        if (TopMemoryContext != NULL)
    0.00 :	  7990f3:       48 8b 3d 6e 17 42 00    mov    0x42176e(%rip),%rdi        # bba868 <TopMemoryContext>
         :	                                        MemoryContextMethods *methods,
         :	                                        MemoryContext parent,
         :	                                        const char *name)
         :	{
         :	        MemoryContext node;
         :	        Size            needed = size + strlen(name) + 1;
    0.00 :	  7990fa:       49 8d 74 04 01          lea    0x1(%r12,%rax,1),%rsi
         :
         :	        /* creating new memory contexts is not allowed in a critical section */
         :	        Assert(CritSectionCount == 0);
         :
         :	        /* Get space for node and name */
         :	        if (TopMemoryContext != NULL)
    0.00 :	  7990ff:       48 85 ff                test   %rdi,%rdi
    0.00 :	  799102:       0f 84 c0 00 00 00       je     7991c8 <MemoryContextCreate+0x108>
         :	        {
         :	                /* Normal case: allocate the node in TopMemoryContext */
         :	                node = (MemoryContext) MemoryContextAlloc(TopMemoryContext,
    0.00 :	  799108:       e8 83 fd ff ff          callq  798e90 <MemoryContextAlloc>
    0.00 :	  79910d:       48 89 c3                mov    %rax,%rbx
         :	                node = (MemoryContext) malloc(needed);
         :	                Assert(node != NULL);
         :	        }
         :
         :	        /* Initialize the node as best we can */
         :	        MemSet(node, 0, size);
    0.00 :	  799110:       48 89 d8                mov    %rbx,%rax
    0.00 :	  799113:       4c 09 e0                or     %r12,%rax
    0.00 :	  799116:       a8 07                   test   $0x7,%al
    0.00 :	  799118:       75 09                   jne    799123 <MemoryContextCreate+0x63>
    0.00 :	  79911a:       49 81 fc 00 04 00 00    cmp    $0x400,%r12
    0.00 :	  799121:       76 7d                   jbe    7991a0 <MemoryContextCreate+0xe0>
    0.00 :	  799123:       48 89 df                mov    %rbx,%rdi
    0.00 :	  799126:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  799129:       31 f6                   xor    %esi,%esi
    0.00 :	  79912b:       e8 f0 02 cd ff          callq  469420 <memset@plt>
    0.00 :	  799130:       4a 8d 3c 23             lea    (%rbx,%r12,1),%rdi
         :	        node->type = tag;
    0.00 :	  799134:       8b 45 d4                mov    -0x2c(%rbp),%eax
         :	        node->parent = NULL;            /* for the moment */
         :	        node->firstchild = NULL;
         :	        node->nextchild = NULL;
         :	        node->isReset = true;
         :	        node->name = ((char *) node) + size;
         :	        strcpy(node->name, name);
    0.00 :	  799137:       4c 89 f6                mov    %r14,%rsi
         :	        node->methods = methods;
         :	        node->parent = NULL;            /* for the moment */
         :	        node->firstchild = NULL;
         :	        node->nextchild = NULL;
         :	        node->isReset = true;
         :	        node->name = ((char *) node) + size;
    0.00 :	  79913a:       48 89 7b 28             mov    %rdi,0x28(%rbx)
         :	        }
         :
         :	        /* Initialize the node as best we can */
         :	        MemSet(node, 0, size);
         :	        node->type = tag;
         :	        node->methods = methods;
    0.00 :	  79913e:       4c 89 7b 08             mov    %r15,0x8(%rbx)
         :	        node->parent = NULL;            /* for the moment */
    0.00 :	  799142:       48 c7 43 10 00 00 00    movq   $0x0,0x10(%rbx)
    0.00 :	  799149:       00 
         :	        node->firstchild = NULL;
    0.00 :	  79914a:       48 c7 43 18 00 00 00    movq   $0x0,0x18(%rbx)
    0.00 :	  799151:       00 
         :	        node->nextchild = NULL;
    0.00 :	  799152:       48 c7 43 20 00 00 00    movq   $0x0,0x20(%rbx)
    0.00 :	  799159:       00 
         :	                Assert(node != NULL);
         :	        }
         :
         :	        /* Initialize the node as best we can */
         :	        MemSet(node, 0, size);
         :	        node->type = tag;
    0.00 :	  79915a:       89 03                   mov    %eax,(%rbx)
         :	        node->methods = methods;
         :	        node->parent = NULL;            /* for the moment */
         :	        node->firstchild = NULL;
         :	        node->nextchild = NULL;
         :	        node->isReset = true;
    0.00 :	  79915c:       c6 43 30 01             movb   $0x1,0x30(%rbx)
         :	        node->name = ((char *) node) + size;
         :	        strcpy(node->name, name);
    0.00 :	  799160:       e8 1b 0c cd ff          callq  469d80 <strcpy@plt>
         :
         :	        /* Type-specific routine finishes any other essential initialization */
         :	        (*node->methods->init) (node);
    0.00 :	  799165:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  799169:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79916c:       ff 50 18                callq  *0x18(%rax)
         :
         :	        /* OK to link node to parent (if any) */
         :	        /* Could use MemoryContextSetParent here, but doesn't seem worthwhile */
         :	        if (parent)
    0.00 :	  79916f:       4d 85 ed                test   %r13,%r13
    0.00 :	  799172:       74 10                   je     799184 <MemoryContextCreate+0xc4>
         :	        {
         :	                node->parent = parent;
    0.00 :	  799174:       4c 89 6b 10             mov    %r13,0x10(%rbx)
         :	                node->nextchild = parent->firstchild;
    0.00 :	  799178:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  79917c:       48 89 43 20             mov    %rax,0x20(%rbx)
         :	                parent->firstchild = node;
    0.00 :	  799180:       49 89 5d 18             mov    %rbx,0x18(%r13)
         :
         :	        VALGRIND_CREATE_MEMPOOL(node, 0, false);
         :
         :	        /* Return to type-specific creation routine to finish up */
         :	        return node;
         :	}
    0.00 :	  799184:       48 89 d8                mov    %rbx,%rax
    0.00 :	  799187:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  79918b:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  79918f:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  799193:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  799197:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  79919b:       c9                      leaveq 
    0.00 :	  79919c:       c3                      retq   
    0.00 :	  79919d:       0f 1f 00                nopl   (%rax)
         :	                node = (MemoryContext) malloc(needed);
         :	                Assert(node != NULL);
         :	        }
         :
         :	        /* Initialize the node as best we can */
         :	        MemSet(node, 0, size);
    0.00 :	  7991a0:       4a 8d 3c 23             lea    (%rbx,%r12,1),%rdi
    0.00 :	  7991a4:       48 89 d8                mov    %rbx,%rax
    0.00 :	  7991a7:       48 39 fb                cmp    %rdi,%rbx
    0.00 :	  7991aa:       73 88                   jae    799134 <MemoryContextCreate+0x74>
    0.00 :	  7991ac:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  7991b0:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
    0.00 :	  7991b7:       48 83 c0 08             add    $0x8,%rax
    0.00 :	  7991bb:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  7991be:       77 f0                   ja     7991b0 <MemoryContextCreate+0xf0>
    0.00 :	  7991c0:       e9 6f ff ff ff          jmpq   799134 <MemoryContextCreate+0x74>
    0.00 :	  7991c5:       0f 1f 00                nopl   (%rax)
         :	                                                                                                  needed);
         :	        }
         :	        else
         :	        {
         :	                /* Special case for startup: use good ol' malloc */
         :	                node = (MemoryContext) malloc(needed);
    0.00 :	  7991c8:       48 89 f7                mov    %rsi,%rdi
    0.00 :	  7991cb:       e8 60 04 cd ff          callq  469630 <malloc@plt>
    0.00 :	  7991d0:       48 89 c3                mov    %rax,%rbx
    0.00 :	  7991d3:       e9 38 ff ff ff          jmpq   799110 <MemoryContextCreate+0x50>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:580
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079ae70 <ResourceOwnerEnlargeBuffers>:
         :	 * We allow the case owner == NULL because the bufmgr is sometimes invoked
         :	 * outside any transaction (for example, during WAL recovery).
         :	 */
         :	void
         :	ResourceOwnerEnlargeBuffers(ResourceOwner owner)
         :	{
    0.00 :	  79ae70:       55                      push   %rbp
    0.00 :	  79ae71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79ae74:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  79ae78:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  79ae7c:       48 83 ec 10             sub    $0x10,%rsp
         :	        int                     newmax;
         :
         :	        if (owner == NULL ||
    0.00 :	  79ae80:       48 85 ff                test   %rdi,%rdi
         :	 * We allow the case owner == NULL because the bufmgr is sometimes invoked
         :	 * outside any transaction (for example, during WAL recovery).
         :	 */
         :	void
         :	ResourceOwnerEnlargeBuffers(ResourceOwner owner)
         :	{
    0.00 :	  79ae83:       49 89 fc                mov    %rdi,%r12
         :	        int                     newmax;
         :
         :	        if (owner == NULL ||
    0.00 :	  79ae86:       74 2a                   je     79aeb2 <ResourceOwnerEnlargeBuffers+0x42>
    0.00 :	  79ae88:       8b 47 30                mov    0x30(%rdi),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:580
  100.00 :	  79ae8b:       39 47 20                cmp    %eax,0x20(%rdi)
    0.00 :	  79ae8e:       7c 22                   jl     79aeb2 <ResourceOwnerEnlargeBuffers+0x42>
         :	                owner->nbuffers < owner->maxbuffers)
         :	                return;                                 /* nothing to do */
         :
         :	        if (owner->buffers == NULL)
    0.00 :	  79ae90:       48 8b 7f 28             mov    0x28(%rdi),%rdi
    0.00 :	  79ae94:       48 85 ff                test   %rdi,%rdi
    0.00 :	  79ae97:       74 27                   je     79aec0 <ResourceOwnerEnlargeBuffers+0x50>
         :	                        MemoryContextAlloc(TopMemoryContext, newmax * sizeof(Buffer));
         :	                owner->maxbuffers = newmax;
         :	        }
         :	        else
         :	        {
         :	                newmax = owner->maxbuffers * 2;
    0.00 :	  79ae99:       8d 1c 00                lea    (%rax,%rax,1),%ebx
         :	                owner->buffers = (Buffer *)
    0.00 :	  79ae9c:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  79ae9f:       48 c1 e6 02             shl    $0x2,%rsi
    0.00 :	  79aea3:       e8 48 de ff ff          callq  798cf0 <repalloc>
         :	                        repalloc(owner->buffers, newmax * sizeof(Buffer));
         :	                owner->maxbuffers = newmax;
    0.00 :	  79aea8:       41 89 5c 24 30          mov    %ebx,0x30(%r12)
         :	                owner->maxbuffers = newmax;
         :	        }
         :	        else
         :	        {
         :	                newmax = owner->maxbuffers * 2;
         :	                owner->buffers = (Buffer *)
    0.00 :	  79aead:       49 89 44 24 28          mov    %rax,0x28(%r12)
         :	                        repalloc(owner->buffers, newmax * sizeof(Buffer));
         :	                owner->maxbuffers = newmax;
         :	        }
         :	}
    0.00 :	  79aeb2:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  79aeb6:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  79aebb:       c9                      leaveq 
    0.00 :	  79aebc:       c3                      retq   
    0.00 :	  79aebd:       0f 1f 00                nopl   (%rax)
         :	                return;                                 /* nothing to do */
         :
         :	        if (owner->buffers == NULL)
         :	        {
         :	                newmax = 16;
         :	                owner->buffers = (Buffer *)
    0.00 :	  79aec0:       48 8b 3d a1 f9 41 00    mov    0x41f9a1(%rip),%rdi        # bba868 <TopMemoryContext>
    0.00 :	  79aec7:       be 40 00 00 00          mov    $0x40,%esi
    0.00 :	  79aecc:       e8 bf df ff ff          callq  798e90 <MemoryContextAlloc>
         :	                        MemoryContextAlloc(TopMemoryContext, newmax * sizeof(Buffer));
         :	                owner->maxbuffers = newmax;
    0.00 :	  79aed1:       41 c7 44 24 30 10 00    movl   $0x10,0x30(%r12)
    0.00 :	  79aed8:       00 00 
         :	                return;                                 /* nothing to do */
         :
         :	        if (owner->buffers == NULL)
         :	        {
         :	                newmax = 16;
         :	                owner->buffers = (Buffer *)
    0.00 :	  79aeda:       49 89 44 24 28          mov    %rax,0x28(%r12)
    0.00 :	  79aedf:       eb d1                   jmp    79aeb2 <ResourceOwnerEnlargeBuffers+0x42>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1421
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079db40 <tuplesort_gettuple_common>:
         :	 * If *should_free is set, the caller must pfree stup.tuple when done with it.
         :	 */
         :	static bool
         :	tuplesort_gettuple_common(Tuplesortstate *state, bool forward,
         :	                                                  SortTuple *stup, bool *should_free)
         :	{
    0.00 :	  79db40:       55                      push   %rbp
    0.00 :	  79db41:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79db44:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  79db48:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1421
  100.00 :	  79db4c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  79db4f:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  79db53:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  79db57:       49 89 d4                mov    %rdx,%r12
    0.00 :	  79db5a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  79db5e:       48 83 ec 30             sub    $0x30,%rsp
         :	        unsigned int tuplen;
         :
         :	        switch (state->status)
    0.00 :	  79db62:       8b 07                   mov    (%rdi),%eax
    0.00 :	  79db64:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  79db67:       0f 84 93 01 00 00       je     79dd00 <tuplesort_gettuple_common+0x1c0>
    0.00 :	  79db6d:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  79db70:       0f 84 9a 00 00 00       je     79dc10 <tuplesort_gettuple_common+0xd0>
    0.00 :	  79db76:       83 f8 03                cmp    $0x3,%eax
    0.00 :	  79db79:       74 2d                   je     79dba8 <tuplesort_gettuple_common+0x68>
         :	                                return true;
         :	                        }
         :	                        return false;
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
    0.00 :	  79db7b:       ba 70 2e 8e 00          mov    $0x8e2e70,%edx
    0.00 :	  79db80:       be 49 06 00 00          mov    $0x649,%esi
    0.00 :	  79db85:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79db8a:       e8 91 d8 fd ff          callq  77b420 <elog_start>
    0.00 :	  79db8f:       be f0 29 8e 00          mov    $0x8e29f0,%esi
    0.00 :	  79db94:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79db99:       31 c0                   xor    %eax,%eax
    0.00 :	  79db9b:       e8 90 d6 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79dba0:       e8 2b b9 cc ff          callq  4694d0 <abort@plt>
    0.00 :	  79dba5:       0f 1f 00                nopl   (%rax)
         :	        switch (state->status)
         :	        {
         :	                case TSS_SORTEDINMEM:
         :	                        Assert(forward || state->randomAccess);
         :	                        *should_free = false;
         :	                        if (forward)
    0.00 :	  79dba8:       40 84 f6                test   %sil,%sil
         :
         :	        switch (state->status)
         :	        {
         :	                case TSS_SORTEDINMEM:
         :	                        Assert(forward || state->randomAccess);
         :	                        *should_free = false;
    0.00 :	  79dbab:       c6 01 00                movb   $0x0,(%rcx)
         :	                        if (forward)
    0.00 :	  79dbae:       0f 84 84 01 00 00       je     79dd38 <tuplesort_gettuple_common+0x1f8>
         :	                        {
         :	                                if (state->current < state->memtupcount)
    0.00 :	  79dbb4:       8b b7 d8 00 00 00       mov    0xd8(%rdi),%esi
    0.00 :	  79dbba:       3b 77 68                cmp    0x68(%rdi),%esi
    0.00 :	  79dbbd:       0f 8c dd 02 00 00       jl     79dea0 <tuplesort_gettuple_common+0x360>
         :	                                /*
         :	                                 * Complain if caller tries to retrieve more tuples than
         :	                                 * originally asked for in a bounded sort.  This is because
         :	                                 * returning EOF here might be the wrong thing.
         :	                                 */
         :	                                if (state->bounded && state->current >= state->bound)
    0.00 :	  79dbc3:       80 7f 09 00             cmpb   $0x0,0x9(%rdi)
         :	                                if (state->current < state->memtupcount)
         :	                                {
         :	                                        *stup = state->memtuples[state->current++];
         :	                                        return true;
         :	                                }
         :	                                state->eof_reached = true;
    0.00 :	  79dbc7:       c6 87 dc 00 00 00 01    movb   $0x1,0xdc(%rdi)
         :	                                /*
         :	                                 * Complain if caller tries to retrieve more tuples than
         :	                                 * originally asked for in a bounded sort.  This is because
         :	                                 * returning EOF here might be the wrong thing.
         :	                                 */
         :	                                if (state->bounded && state->current >= state->bound)
    0.00 :	  79dbce:       0f 84 45 01 00 00       je     79dd19 <tuplesort_gettuple_common+0x1d9>
    0.00 :	  79dbd4:       3b 77 0c                cmp    0xc(%rdi),%esi
    0.00 :	  79dbd7:       0f 8c 3c 01 00 00       jl     79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                                        elog(ERROR, "retrieved too many tuples in a bounded sort");
    0.00 :	  79dbdd:       ba 70 2e 8e 00          mov    $0x8e2e70,%edx
    0.00 :	  79dbe2:       be a4 05 00 00          mov    $0x5a4,%esi
    0.00 :	  79dbe7:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79dbec:       e8 2f d8 fd ff          callq  77b420 <elog_start>
    0.00 :	  79dbf1:       be d0 2a 8e 00          mov    $0x8e2ad0,%esi
    0.00 :	  79dbf6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79dbfb:       31 c0                   xor    %eax,%eax
    0.00 :	  79dbfd:       e8 2e d6 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79dc02:       e8 c9 b8 cc ff          callq  4694d0 <abort@plt>
    0.00 :	  79dc07:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  79dc0e:       00 00 
         :	                        READTUP(state, stup, state->result_tape, tuplen);
         :	                        return true;
         :
         :	                case TSS_FINALMERGE:
         :	                        Assert(forward);
         :	                        *should_free = true;
    0.00 :	  79dc10:       c6 01 01                movb   $0x1,(%rcx)
         :
         :	                        /*
         :	                         * This code should match the inner loop of mergeonerun().
         :	                         */
         :	                        if (state->memtupcount > 0)
    0.00 :	  79dc13:       44 8b 4f 68             mov    0x68(%rdi),%r9d
    0.00 :	  79dc17:       45 85 c9                test   %r9d,%r9d
    0.00 :	  79dc1a:       0f 8e f9 00 00 00       jle    79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                        {
         :	                                int                     srcTape = state->memtuples[0].tupindex;
    0.00 :	  79dc20:       48 8b 47 60             mov    0x60(%rdi),%rax
         :	                                Size            tuplen;
         :	                                int                     tupIndex;
         :	                                SortTuple  *newtup;
         :
         :	                                *stup = state->memtuples[0];
    0.00 :	  79dc24:       48 8b 38                mov    (%rax),%rdi
         :	                        /*
         :	                         * This code should match the inner loop of mergeonerun().
         :	                         */
         :	                        if (state->memtupcount > 0)
         :	                        {
         :	                                int                     srcTape = state->memtuples[0].tupindex;
    0.00 :	  79dc27:       44 8b 78 14             mov    0x14(%rax),%r15d
         :	                                Size            tuplen;
         :	                                int                     tupIndex;
         :	                                SortTuple  *newtup;
         :
         :	                                *stup = state->memtuples[0];
    0.00 :	  79dc2b:       49 89 3c 24             mov    %rdi,(%r12)
    0.00 :	  79dc2f:       48 8b 50 08             mov    0x8(%rax),%rdx
         :	                                /* returned tuple is no longer counted in our memory space */
         :	                                if (stup->tuple)
    0.00 :	  79dc33:       48 85 ff                test   %rdi,%rdi
         :	                                int                     srcTape = state->memtuples[0].tupindex;
         :	                                Size            tuplen;
         :	                                int                     tupIndex;
         :	                                SortTuple  *newtup;
         :
         :	                                *stup = state->memtuples[0];
    0.00 :	  79dc36:       49 89 54 24 08          mov    %rdx,0x8(%r12)
    0.00 :	  79dc3b:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  79dc3f:       49 89 44 24 10          mov    %rax,0x10(%r12)
         :	                                /* returned tuple is no longer counted in our memory space */
         :	                                if (stup->tuple)
    0.00 :	  79dc44:       4d 63 e7                movslq %r15d,%r12
    0.00 :	  79dc47:       74 1e                   je     79dc67 <tuplesort_gettuple_common+0x127>
         :	                                {
         :	                                        tuplen = GetMemoryChunkSpace(stup->tuple);
         :	                                        state->availMem += tuplen;
         :	                                        state->mergeavailmem[srcTape] += tuplen;
    0.00 :	  79dc49:       4d 63 e7                movslq %r15d,%r12
         :
         :	                                *stup = state->memtuples[0];
         :	                                /* returned tuple is no longer counted in our memory space */
         :	                                if (stup->tuple)
         :	                                {
         :	                                        tuplen = GetMemoryChunkSpace(stup->tuple);
    0.00 :	  79dc4c:       e8 3f ae ff ff          callq  798a90 <GetMemoryChunkSpace>
         :	                                        state->availMem += tuplen;
         :	                                        state->mergeavailmem[srcTape] += tuplen;
    0.00 :	  79dc51:       4a 8d 14 e5 00 00 00    lea    0x0(,%r12,8),%rdx
    0.00 :	  79dc58:       00 
    0.00 :	  79dc59:       48 03 93 98 00 00 00    add    0x98(%rbx),%rdx
         :	                                *stup = state->memtuples[0];
         :	                                /* returned tuple is no longer counted in our memory space */
         :	                                if (stup->tuple)
         :	                                {
         :	                                        tuplen = GetMemoryChunkSpace(stup->tuple);
         :	                                        state->availMem += tuplen;
    0.00 :	  79dc60:       48 01 43 10             add    %rax,0x10(%rbx)
         :	                                        state->mergeavailmem[srcTape] += tuplen;
    0.00 :	  79dc64:       48 01 02                add    %rax,(%rdx)
         :	                                }
         :	                                tuplesort_heap_siftup(state, false);
         :	                                if ((tupIndex = state->mergenext[srcTape]) == 0)
    0.00 :	  79dc67:       4e 8d 2c a5 00 00 00    lea    0x0(,%r12,4),%r13
    0.00 :	  79dc6e:       00 
         :	                                {
         :	                                        tuplen = GetMemoryChunkSpace(stup->tuple);
         :	                                        state->availMem += tuplen;
         :	                                        state->mergeavailmem[srcTape] += tuplen;
         :	                                }
         :	                                tuplesort_heap_siftup(state, false);
    0.00 :	  79dc6f:       31 f6                   xor    %esi,%esi
    0.00 :	  79dc71:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79dc74:       e8 67 f3 ff ff          callq  79cfe0 <tuplesort_heap_siftup>
         :	                                if ((tupIndex = state->mergenext[srcTape]) == 0)
    0.00 :	  79dc79:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  79dc7c:       48 03 93 80 00 00 00    add    0x80(%rbx),%rdx
    0.00 :	  79dc83:       44 8b 32                mov    (%rdx),%r14d
    0.00 :	  79dc86:       45 85 f6                test   %r14d,%r14d
    0.00 :	  79dc89:       0f 84 59 02 00 00       je     79dee8 <tuplesort_gettuple_common+0x3a8>
         :	                                         */
         :	                                        if ((tupIndex = state->mergenext[srcTape]) == 0)
         :	                                                return true;
         :	                                }
         :	                                /* pull next preread tuple from list, insert in heap */
         :	                                newtup = &state->memtuples[tupIndex];
    0.00 :	  79dc8f:       49 63 c6                movslq %r14d,%rax
    0.00 :	  79dc92:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79dc96:       4c 8d 24 c5 00 00 00    lea    0x0(,%rax,8),%r12
    0.00 :	  79dc9d:       00 
    0.00 :	  79dc9e:       4c 03 63 60             add    0x60(%rbx),%r12
         :	                                state->mergenext[srcTape] = newtup->tupindex;
    0.00 :	  79dca2:       41 8b 44 24 14          mov    0x14(%r12),%eax
    0.00 :	  79dca7:       89 02                   mov    %eax,(%rdx)
         :	                                if (state->mergenext[srcTape] == 0)
    0.00 :	  79dca9:       48 8b 83 80 00 00 00    mov    0x80(%rbx),%rax
    0.00 :	  79dcb0:       46 8b 04 28             mov    (%rax,%r13,1),%r8d
    0.00 :	  79dcb4:       45 85 c0                test   %r8d,%r8d
    0.00 :	  79dcb7:       75 0f                   jne    79dcc8 <tuplesort_gettuple_common+0x188>
         :	                                        state->mergelast[srcTape] = 0;
    0.00 :	  79dcb9:       48 8b 83 88 00 00 00    mov    0x88(%rbx),%rax
    0.00 :	  79dcc0:       42 c7 04 28 00 00 00    movl   $0x0,(%rax,%r13,1)
    0.00 :	  79dcc7:       00 
         :	                                tuplesort_heap_insert(state, newtup, srcTape, false);
    0.00 :	  79dcc8:       31 c9                   xor    %ecx,%ecx
    0.00 :	  79dcca:       44 89 fa                mov    %r15d,%edx
    0.00 :	  79dccd:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  79dcd0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79dcd3:       e8 f8 f4 ff ff          callq  79d1d0 <tuplesort_heap_insert>
         :	                                /* put the now-unused memtuples entry on the freelist */
         :	                                newtup->tupindex = state->mergefreelist;
    0.00 :	  79dcd8:       8b 83 a0 00 00 00       mov    0xa0(%rbx),%eax
    0.00 :	  79dcde:       41 89 44 24 14          mov    %eax,0x14(%r12)
         :	                                state->mergefreelist = tupIndex;
         :	                                state->mergeavailslots[srcTape]++;
    0.00 :	  79dce3:       4c 03 ab 90 00 00 00    add    0x90(%rbx),%r13
    0.00 :	  79dcea:       b8 01 00 00 00          mov    $0x1,%eax
         :	                                if (state->mergenext[srcTape] == 0)
         :	                                        state->mergelast[srcTape] = 0;
         :	                                tuplesort_heap_insert(state, newtup, srcTape, false);
         :	                                /* put the now-unused memtuples entry on the freelist */
         :	                                newtup->tupindex = state->mergefreelist;
         :	                                state->mergefreelist = tupIndex;
    0.00 :	  79dcef:       44 89 b3 a0 00 00 00    mov    %r14d,0xa0(%rbx)
         :	                                state->mergeavailslots[srcTape]++;
    0.00 :	  79dcf6:       41 83 45 00 01          addl   $0x1,0x0(%r13)
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79dcfb:       eb 1e                   jmp    79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79dcfd:       0f 1f 00                nopl   (%rax)
         :	                        break;
         :
         :	                case TSS_SORTEDONTAPE:
         :	                        Assert(forward || state->randomAccess);
         :	                        *should_free = true;
         :	                        if (forward)
    0.00 :	  79dd00:       40 84 f6                test   %sil,%sil
         :	                        }
         :	                        break;
         :
         :	                case TSS_SORTEDONTAPE:
         :	                        Assert(forward || state->randomAccess);
         :	                        *should_free = true;
    0.00 :	  79dd03:       c6 01 01                movb   $0x1,(%rcx)
         :	                        if (forward)
    0.00 :	  79dd06:       0f 84 8c 00 00 00       je     79dd98 <tuplesort_gettuple_common+0x258>
         :	                        {
         :	                                if (state->eof_reached)
    0.00 :	  79dd0c:       80 bf dc 00 00 00 00    cmpb   $0x0,0xdc(%rdi)
    0.00 :	  79dd13:       0f 84 0f 02 00 00       je     79df28 <tuplesort_gettuple_common+0x3e8>
         :	                                return true;
         :	                        }
         :	                        return false;
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
    0.00 :	  79dd19:       31 c0                   xor    %eax,%eax
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79dd1b:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  79dd1f:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  79dd23:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  79dd27:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  79dd2b:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  79dd2f:       c9                      leaveq 
    0.00 :	  79dd30:       c3                      retq   
    0.00 :	  79dd31:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                                return false;
         :	                        }
         :	                        else
         :	                        {
         :	                                if (state->current <= 0)
    0.00 :	  79dd38:       8b 87 d8 00 00 00       mov    0xd8(%rdi),%eax
    0.00 :	  79dd3e:       85 c0                   test   %eax,%eax
    0.00 :	  79dd40:       7e d7                   jle    79dd19 <tuplesort_gettuple_common+0x1d9>
         :
         :	                                /*
         :	                                 * if all tuples are fetched already then we return last
         :	                                 * tuple, else - tuple before last returned.
         :	                                 */
         :	                                if (state->eof_reached)
    0.00 :	  79dd42:       80 bf dc 00 00 00 00    cmpb   $0x0,0xdc(%rdi)
    0.00 :	  79dd49:       0f 85 c9 01 00 00       jne    79df18 <tuplesort_gettuple_common+0x3d8>
         :	                                        state->eof_reached = false;
         :	                                else
         :	                                {
         :	                                        state->current--;       /* last returned tuple */
    0.00 :	  79dd4f:       83 e8 01                sub    $0x1,%eax
         :	                                        if (state->current <= 0)
    0.00 :	  79dd52:       85 c0                   test   %eax,%eax
         :	                                 */
         :	                                if (state->eof_reached)
         :	                                        state->eof_reached = false;
         :	                                else
         :	                                {
         :	                                        state->current--;       /* last returned tuple */
    0.00 :	  79dd54:       89 87 d8 00 00 00       mov    %eax,0xd8(%rdi)
         :	                                        if (state->current <= 0)
    0.00 :	  79dd5a:       7e bd                   jle    79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                                                return false;
         :	                                }
         :	                                *stup = state->memtuples[state->current - 1];
    0.00 :	  79dd5c:       48 8b 53 60             mov    0x60(%rbx),%rdx
    0.00 :	  79dd60:       48 98                   cltq   
    0.00 :	  79dd62:       48 8d 44 40 fd          lea    -0x3(%rax,%rax,2),%rax
    0.00 :	  79dd67:       48 8d 0c c5 00 00 00    lea    0x0(,%rax,8),%rcx
    0.00 :	  79dd6e:       00 
    0.00 :	  79dd6f:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  79dd73:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	  79dd77:       48 8b 44 11 08          mov    0x8(%rcx,%rdx,1),%rax
    0.00 :	  79dd7c:       49 89 44 24 08          mov    %rax,0x8(%r12)
    0.00 :	  79dd81:       48 8b 44 11 10          mov    0x10(%rcx,%rdx,1),%rax
    0.00 :	  79dd86:       49 89 44 24 10          mov    %rax,0x10(%r12)
    0.00 :	  79dd8b:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79dd90:       eb 89                   jmp    79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79dd92:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * Backward.
         :	                         *
         :	                         * if all tuples are fetched already then we return last tuple,
         :	                         * else - tuple before last returned.
         :	                         */
         :	                        if (state->eof_reached)
    0.00 :	  79dd98:       80 bf dc 00 00 00 00    cmpb   $0x0,0xdc(%rdi)
    0.00 :	  79dd9f:       74 6f                   je     79de10 <tuplesort_gettuple_common+0x2d0>
         :	                                /*
         :	                                 * Seek position is pointing just past the zero tuplen at the
         :	                                 * end of file; back up to fetch last tuple's ending length
         :	                                 * word.  If seek fails we must have a completely empty file.
         :	                                 */
         :	                                if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79dda1:       8b b7 d4 00 00 00       mov    0xd4(%rdi),%esi
    0.00 :	  79dda7:       48 8b 7f 30             mov    0x30(%rdi),%rdi
    0.00 :	  79ddab:       ba 08 00 00 00          mov    $0x8,%edx
    0.00 :	  79ddb0:       e8 8b dd ff ff          callq  79bb40 <LogicalTapeBackspace>
    0.00 :	  79ddb5:       84 c0                   test   %al,%al
    0.00 :	  79ddb7:       0f 84 5c ff ff ff       je     79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                                                                                  state->result_tape,
         :	                                                                                  2 * sizeof(unsigned int)))
         :	                                        return false;
         :	                                state->eof_reached = false;
    0.00 :	  79ddbd:       c6 83 dc 00 00 00 00    movb   $0x0,0xdc(%rbx)
         :	                                                elog(ERROR, "bogus tuple length in backward scan");
         :	                                        return false;
         :	                                }
         :	                        }
         :
         :	                        tuplen = getlen(state, state->result_tape, false);
    0.00 :	  79ddc4:       8b b3 d4 00 00 00       mov    0xd4(%rbx),%esi
    0.00 :	  79ddca:       31 d2                   xor    %edx,%edx
    0.00 :	  79ddcc:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79ddcf:       e8 0c fb ff ff          callq  79d8e0 <getlen>
         :	                        /*
         :	                         * Now we have the length of the prior tuple, back up and read it.
         :	                         * Note: READTUP expects we are positioned after the initial
         :	                         * length word of the tuple, so back up to that point.
         :	                         */
         :	                        if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79ddd4:       8b b3 d4 00 00 00       mov    0xd4(%rbx),%esi
    0.00 :	  79ddda:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  79ddde:       89 c2                   mov    %eax,%edx
         :	                                                elog(ERROR, "bogus tuple length in backward scan");
         :	                                        return false;
         :	                                }
         :	                        }
         :
         :	                        tuplen = getlen(state, state->result_tape, false);
    0.00 :	  79dde0:       41 89 c5                mov    %eax,%r13d
         :	                        /*
         :	                         * Now we have the length of the prior tuple, back up and read it.
         :	                         * Note: READTUP expects we are positioned after the initial
         :	                         * length word of the tuple, so back up to that point.
         :	                         */
         :	                        if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79dde3:       e8 58 dd ff ff          callq  79bb40 <LogicalTapeBackspace>
    0.00 :	  79dde8:       84 c0                   test   %al,%al
    0.00 :	  79ddea:       0f 84 7b 01 00 00       je     79df6b <tuplesort_gettuple_common+0x42b>
         :	                                                                          state->result_tape,
         :	                                                                          tuplen))
         :	                                elog(ERROR, "bogus tuple length in backward scan");
         :	                        READTUP(state, stup, state->result_tape, tuplen);
    0.00 :	  79ddf0:       8b 93 d4 00 00 00       mov    0xd4(%rbx),%edx
    0.00 :	  79ddf6:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  79ddf9:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  79ddfc:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79ddff:       ff 53 50                callq  *0x50(%rbx)
    0.00 :	  79de02:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79de07:       e9 0f ff ff ff          jmpq   79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79de0c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        {
         :	                                /*
         :	                                 * Back up and fetch previously-returned tuple's ending length
         :	                                 * word.  If seek fails, assume we are at start of file.
         :	                                 */
         :	                                if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79de10:       8b b7 d4 00 00 00       mov    0xd4(%rdi),%esi
    0.00 :	  79de16:       48 8b 7f 30             mov    0x30(%rdi),%rdi
    0.00 :	  79de1a:       ba 04 00 00 00          mov    $0x4,%edx
    0.00 :	  79de1f:       e8 1c dd ff ff          callq  79bb40 <LogicalTapeBackspace>
    0.00 :	  79de24:       84 c0                   test   %al,%al
    0.00 :	  79de26:       0f 84 ed fe ff ff       je     79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                                                                                  state->result_tape,
         :	                                                                                  sizeof(unsigned int)))
         :	                                        return false;
         :	                                tuplen = getlen(state, state->result_tape, false);
    0.00 :	  79de2c:       8b b3 d4 00 00 00       mov    0xd4(%rbx),%esi
    0.00 :	  79de32:       31 d2                   xor    %edx,%edx
    0.00 :	  79de34:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79de37:       e8 a4 fa ff ff          callq  79d8e0 <getlen>
         :
         :	                                /*
         :	                                 * Back up to get ending length word of tuple before it.
         :	                                 */
         :	                                if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79de3c:       8b b3 d4 00 00 00       mov    0xd4(%rbx),%esi
    0.00 :	  79de42:       41 89 c5                mov    %eax,%r13d
    0.00 :	  79de45:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  79de49:       49 8d 55 08             lea    0x8(%r13),%rdx
    0.00 :	  79de4d:       e8 ee dc ff ff          callq  79bb40 <LogicalTapeBackspace>
    0.00 :	  79de52:       84 c0                   test   %al,%al
    0.00 :	  79de54:       0f 85 6a ff ff ff       jne    79ddc4 <tuplesort_gettuple_common+0x284>
         :	                                         * If that fails, presumably the prev tuple is the first
         :	                                         * in the file.  Back up so that it becomes next to read
         :	                                         * in forward direction (not obviously right, but that is
         :	                                         * what in-memory case does).
         :	                                         */
         :	                                        if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79de5a:       8b b3 d4 00 00 00       mov    0xd4(%rbx),%esi
    0.00 :	  79de60:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  79de64:       49 8d 55 04             lea    0x4(%r13),%rdx
    0.00 :	  79de68:       e8 d3 dc ff ff          callq  79bb40 <LogicalTapeBackspace>
    0.00 :	  79de6d:       84 c0                   test   %al,%al
         :	                                                                                          state->result_tape,
         :	                                                                                          tuplen + sizeof(unsigned int)))
         :	                                                elog(ERROR, "bogus tuple length in backward scan");
    0.00 :	  79de6f:       ba 70 2e 8e 00          mov    $0x8e2e70,%edx
    0.00 :	  79de74:       be 00 06 00 00          mov    $0x600,%esi
         :	                                         * If that fails, presumably the prev tuple is the first
         :	                                         * in the file.  Back up so that it becomes next to read
         :	                                         * in forward direction (not obviously right, but that is
         :	                                         * what in-memory case does).
         :	                                         */
         :	                                        if (!LogicalTapeBackspace(state->tapeset,
    0.00 :	  79de79:       0f 85 9a fe ff ff       jne    79dd19 <tuplesort_gettuple_common+0x1d9>
         :	                         * length word of the tuple, so back up to that point.
         :	                         */
         :	                        if (!LogicalTapeBackspace(state->tapeset,
         :	                                                                          state->result_tape,
         :	                                                                          tuplen))
         :	                                elog(ERROR, "bogus tuple length in backward scan");
    0.00 :	  79de7f:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79de84:       e8 97 d5 fd ff          callq  77b420 <elog_start>
    0.00 :	  79de89:       be 00 2b 8e 00          mov    $0x8e2b00,%esi
    0.00 :	  79de8e:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79de93:       31 c0                   xor    %eax,%eax
    0.00 :	  79de95:       e8 96 d3 fd ff          callq  77b230 <elog_finish>
    0.00 :	  79de9a:       e8 31 b6 cc ff          callq  4694d0 <abort@plt>
    0.00 :	  79de9f:       90                      nop
         :	                        *should_free = false;
         :	                        if (forward)
         :	                        {
         :	                                if (state->current < state->memtupcount)
         :	                                {
         :	                                        *stup = state->memtuples[state->current++];
    0.00 :	  79dea0:       48 8b 57 60             mov    0x60(%rdi),%rdx
    0.00 :	  79dea4:       48 63 c6                movslq %esi,%rax
    0.00 :	  79dea7:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  79deab:       48 8d 0c c5 00 00 00    lea    0x0(,%rax,8),%rcx
    0.00 :	  79deb2:       00 
    0.00 :	  79deb3:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  79deb7:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	  79debb:       48 8b 44 11 08          mov    0x8(%rcx,%rdx,1),%rax
    0.00 :	  79dec0:       49 89 44 24 08          mov    %rax,0x8(%r12)
    0.00 :	  79dec5:       48 8b 44 11 10          mov    0x10(%rcx,%rdx,1),%rax
    0.00 :	  79deca:       49 89 44 24 10          mov    %rax,0x10(%r12)
    0.00 :	  79decf:       8d 46 01                lea    0x1(%rsi),%eax
    0.00 :	  79ded2:       89 87 d8 00 00 00       mov    %eax,0xd8(%rdi)
    0.00 :	  79ded8:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79dedd:       e9 39 fe ff ff          jmpq   79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79dee2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                         * out of preloaded data on this tape, try to read more
         :	                                         *
         :	                                         * Unlike mergeonerun(), we only preload from the single
         :	                                         * tape that's run dry.  See mergepreread() comments.
         :	                                         */
         :	                                        mergeprereadone(state, srcTape);
    0.00 :	  79dee8:       44 89 fe                mov    %r15d,%esi
    0.00 :	  79deeb:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79deee:       e8 8d fa ff ff          callq  79d980 <mergeprereadone>
         :
         :	                                        /*
         :	                                         * if still no data, we've reached end of run on this tape
         :	                                         */
         :	                                        if ((tupIndex = state->mergenext[srcTape]) == 0)
    0.00 :	  79def3:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  79def6:       48 03 93 80 00 00 00    add    0x80(%rbx),%rdx
    0.00 :	  79defd:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  79df02:       44 8b 32                mov    (%rdx),%r14d
    0.00 :	  79df05:       45 85 f6                test   %r14d,%r14d
    0.00 :	  79df08:       0f 85 81 fd ff ff       jne    79dc8f <tuplesort_gettuple_common+0x14f>
    0.00 :	  79df0e:       e9 08 fe ff ff          jmpq   79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79df13:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                /*
         :	                                 * if all tuples are fetched already then we return last
         :	                                 * tuple, else - tuple before last returned.
         :	                                 */
         :	                                if (state->eof_reached)
         :	                                        state->eof_reached = false;
    0.00 :	  79df18:       c6 87 dc 00 00 00 00    movb   $0x0,0xdc(%rdi)
    0.00 :	  79df1f:       e9 38 fe ff ff          jmpq   79dd5c <tuplesort_gettuple_common+0x21c>
    0.00 :	  79df24:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        *should_free = true;
         :	                        if (forward)
         :	                        {
         :	                                if (state->eof_reached)
         :	                                        return false;
         :	                                if ((tuplen = getlen(state, state->result_tape, true)) != 0)
    0.00 :	  79df28:       8b b7 d4 00 00 00       mov    0xd4(%rdi),%esi
    0.00 :	  79df2e:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  79df33:       e8 a8 f9 ff ff          callq  79d8e0 <getlen>
    0.00 :	  79df38:       85 c0                   test   %eax,%eax
    0.00 :	  79df3a:       75 14                   jne    79df50 <tuplesort_gettuple_common+0x410>
         :	                                        READTUP(state, stup, state->result_tape, tuplen);
         :	                                        return true;
         :	                                }
         :	                                else
         :	                                {
         :	                                        state->eof_reached = true;
    0.00 :	  79df3c:       c6 83 dc 00 00 00 01    movb   $0x1,0xdc(%rbx)
    0.00 :	  79df43:       31 c0                   xor    %eax,%eax
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79df45:       e9 d1 fd ff ff          jmpq   79dd1b <tuplesort_gettuple_common+0x1db>
    0.00 :	  79df4a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        {
         :	                                if (state->eof_reached)
         :	                                        return false;
         :	                                if ((tuplen = getlen(state, state->result_tape, true)) != 0)
         :	                                {
         :	                                        READTUP(state, stup, state->result_tape, tuplen);
    0.00 :	  79df50:       89 c1                   mov    %eax,%ecx
    0.00 :	  79df52:       8b 93 d4 00 00 00       mov    0xd4(%rbx),%edx
    0.00 :	  79df58:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  79df5b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  79df5e:       ff 53 50                callq  *0x50(%rbx)
    0.00 :	  79df61:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	                default:
         :	                        elog(ERROR, "invalid tuplesort state");
         :	                        return false;           /* keep compiler quiet */
         :	        }
         :	}
    0.00 :	  79df66:       e9 b0 fd ff ff          jmpq   79dd1b <tuplesort_gettuple_common+0x1db>
         :	                         * length word of the tuple, so back up to that point.
         :	                         */
         :	                        if (!LogicalTapeBackspace(state->tapeset,
         :	                                                                          state->result_tape,
         :	                                                                          tuplen))
         :	                                elog(ERROR, "bogus tuple length in backward scan");
    0.00 :	  79df6b:       ba 70 2e 8e 00          mov    $0x8e2e70,%edx
    0.00 :	  79df70:       be 0f 06 00 00          mov    $0x60f,%esi
    0.00 :	  79df75:       e9 05 ff ff ff          jmpq   79de7f <tuplesort_gettuple_common+0x33f>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1698
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079e1c0 <tuplesort_getdatum>:
         :	 * and is now owned by the caller.
         :	 */
         :	bool
         :	tuplesort_getdatum(Tuplesortstate *state, bool forward,
         :	                                   Datum *val, bool *isNull)
         :	{
    0.00 :	  79e1c0:       55                      push   %rbp
         :	        MemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);
         :	        SortTuple       stup;
         :	        bool            should_free;
         :
         :	        if (!tuplesort_gettuple_common(state, forward, &stup, &should_free))
    0.00 :	  79e1c1:       40 0f be f6             movsbl %sil,%esi
         :	 * and is now owned by the caller.
         :	 */
         :	bool
         :	tuplesort_getdatum(Tuplesortstate *state, bool forward,
         :	                                   Datum *val, bool *isNull)
         :	{
    0.00 :	  79e1c5:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79e1c8:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  79e1cc:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  79e1d0:       49 89 d4                mov    %rdx,%r12
    0.00 :	  79e1d3:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  79e1d7:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  79e1db:       48 83 ec 40             sub    $0x40,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  79e1df:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  79e1e3:       49 89 ce                mov    %rcx,%r14
         :	        MemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);
         :	        SortTuple       stup;
         :	        bool            should_free;
         :
         :	        if (!tuplesort_gettuple_common(state, forward, &stup, &should_free))
    0.00 :	  79e1e6:       48 8d 55 c0             lea    -0x40(%rbp),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:1698
  100.00 :	  79e1ea:       48 8d 4d df             lea    -0x21(%rbp),%rcx
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  79e1ee:       4c 8b 2d 6b c6 41 00    mov    0x41c66b(%rip),%r13        # bba860 <CurrentMemoryContext>
         :	 * and is now owned by the caller.
         :	 */
         :	bool
         :	tuplesort_getdatum(Tuplesortstate *state, bool forward,
         :	                                   Datum *val, bool *isNull)
         :	{
    0.00 :	  79e1f5:       48 89 fb                mov    %rdi,%rbx
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  79e1f8:       48 89 05 61 c6 41 00    mov    %rax,0x41c661(%rip)        # bba860 <CurrentMemoryContext>
         :	        MemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);
         :	        SortTuple       stup;
         :	        bool            should_free;
         :
         :	        if (!tuplesort_gettuple_common(state, forward, &stup, &should_free))
    0.00 :	  79e1ff:       e8 3c f9 ff ff          callq  79db40 <tuplesort_gettuple_common>
    0.00 :	  79e204:       84 c0                   test   %al,%al
    0.00 :	  79e206:       74 58                   je     79e260 <tuplesort_getdatum+0xa0>
         :	        {
         :	                MemoryContextSwitchTo(oldcontext);
         :	                return false;
         :	        }
         :
         :	        if (stup.isnull1 || state->datumTypeByVal)
    0.00 :	  79e208:       80 7d d0 00             cmpb   $0x0,-0x30(%rbp)
    0.00 :	  79e20c:       74 32                   je     79e240 <tuplesort_getdatum+0x80>
         :	        {
         :	                *val = stup.datum1;
    0.00 :	  79e20e:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  79e212:       49 89 04 24             mov    %rax,(%r12)
         :	                *isNull = stup.isnull1;
    0.00 :	  79e216:       0f b6 45 d0             movzbl -0x30(%rbp),%eax
    0.00 :	  79e21a:       41 88 06                mov    %al,(%r14)
    0.00 :	  79e21d:       4c 89 2d 3c c6 41 00    mov    %r13,0x41c63c(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  79e224:       b8 01 00 00 00          mov    $0x1,%eax
         :	        }
         :
         :	        MemoryContextSwitchTo(oldcontext);
         :
         :	        return true;
         :	}
    0.00 :	  79e229:       48 8b 5d e0             mov    -0x20(%rbp),%rbx
    0.00 :	  79e22d:       4c 8b 65 e8             mov    -0x18(%rbp),%r12
    0.00 :	  79e231:       4c 8b 6d f0             mov    -0x10(%rbp),%r13
    0.00 :	  79e235:       4c 8b 75 f8             mov    -0x8(%rbp),%r14
    0.00 :	  79e239:       c9                      leaveq 
    0.00 :	  79e23a:       c3                      retq   
    0.00 :	  79e23b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                MemoryContextSwitchTo(oldcontext);
         :	                return false;
         :	        }
         :
         :	        if (stup.isnull1 || state->datumTypeByVal)
    0.00 :	  79e240:       80 bb 40 01 00 00 00    cmpb   $0x0,0x140(%rbx)
    0.00 :	  79e247:       75 c5                   jne    79e20e <tuplesort_getdatum+0x4e>
         :	                *val = stup.datum1;
         :	                *isNull = stup.isnull1;
         :	        }
         :	        else
         :	        {
         :	                if (should_free)
    0.00 :	  79e249:       80 7d df 00             cmpb   $0x0,-0x21(%rbp)
    0.00 :	  79e24d:       74 21                   je     79e270 <tuplesort_getdatum+0xb0>
         :	                        *val = stup.datum1;
    0.00 :	  79e24f:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  79e253:       49 89 04 24             mov    %rax,(%r12)
         :	                else
         :	                        *val = datumCopy(stup.datum1, false, state->datumTypeLen);
         :	                *isNull = false;
    0.00 :	  79e257:       41 c6 06 00             movb   $0x0,(%r14)
    0.00 :	  79e25b:       eb c0                   jmp    79e21d <tuplesort_getdatum+0x5d>
    0.00 :	  79e25d:       0f 1f 00                nopl   (%rax)
    0.00 :	  79e260:       4c 89 2d f9 c5 41 00    mov    %r13,0x41c5f9(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldcontext);
         :
         :	        return true;
         :	}
    0.00 :	  79e267:       eb c0                   jmp    79e229 <tuplesort_getdatum+0x69>
    0.00 :	  79e269:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        else
         :	        {
         :	                if (should_free)
         :	                        *val = stup.datum1;
         :	                else
         :	                        *val = datumCopy(stup.datum1, false, state->datumTypeLen);
    0.00 :	  79e270:       8b 93 3c 01 00 00       mov    0x13c(%rbx),%edx
    0.00 :	  79e276:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  79e27a:       31 f6                   xor    %esi,%esi
    0.00 :	  79e27c:       e8 ef 1c f3 ff          callq  6cff70 <datumCopy>
    0.00 :	  79e281:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	  79e285:       eb d0                   jmp    79e257 <tuplesort_getdatum+0x97>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:912
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079f1e0 <tuplesort_end>:
         :	 * pointing to garbage.  Be careful not to attempt to use or free such
         :	 * pointers afterwards!
         :	 */
         :	void
         :	tuplesort_end(Tuplesortstate *state)
         :	{
    0.00 :	  79f1e0:       55                      push   %rbp
    0.00 :	  79f1e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  79f1e4:       41 55                   push   %r13
    0.00 :	  79f1e6:       41 54                   push   %r12
    0.00 :	  79f1e8:       53                      push   %rbx
    0.00 :	  79f1e9:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  79f1ec:       48 83 ec 08             sub    $0x8,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  79f1f0:       48 8b 47 28             mov    0x28(%rdi),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  79f1f4:       4c 8b 2d 65 b6 41 00    mov    0x41b665(%rip),%r13        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  79f1fb:       48 89 05 5e b6 41 00    mov    %rax,0x41b65e(%rip)        # bba860 <CurrentMemoryContext>
         :	        MemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);
         :
         :	#ifdef TRACE_SORT
         :	        long            spaceUsed;
         :
         :	        if (state->tapeset)
    0.00 :	  79f202:       48 8b 7f 30             mov    0x30(%rdi),%rdi
    0.00 :	  79f206:       48 85 ff                test   %rdi,%rdi
    0.00 :	  79f209:       0f 84 b1 00 00 00       je     79f2c0 <tuplesort_end+0xe0>
         :	                spaceUsed = LogicalTapeSetBlocks(state->tapeset);
    0.00 :	  79f20f:       e8 4c c4 ff ff          callq  79b660 <LogicalTapeSetBlocks>
         :	         * Delete temporary "tape" files, if any.
         :	         *
         :	         * Note: want to include this in reported total cost of sort, hence need
         :	         * for two #ifdef TRACE_SORT sections.
         :	         */
         :	        if (state->tapeset)
    0.00 :	  79f214:       48 8b 7b 30             mov    0x30(%rbx),%rdi
         :
         :	#ifdef TRACE_SORT
         :	        long            spaceUsed;
         :
         :	        if (state->tapeset)
         :	                spaceUsed = LogicalTapeSetBlocks(state->tapeset);
    0.00 :	  79f218:       49 89 c4                mov    %rax,%r12
         :	         * Delete temporary "tape" files, if any.
         :	         *
         :	         * Note: want to include this in reported total cost of sort, hence need
         :	         * for two #ifdef TRACE_SORT sections.
         :	         */
         :	        if (state->tapeset)
    0.00 :	  79f21b:       48 85 ff                test   %rdi,%rdi
    0.00 :	  79f21e:       74 05                   je     79f225 <tuplesort_end+0x45>
         :	                LogicalTapeSetClose(state->tapeset);
    0.00 :	  79f220:       e8 8b d4 ff ff          callq  79c6b0 <LogicalTapeSetClose>
         :
         :	#ifdef TRACE_SORT
         :	        if (trace_sort)
    0.00 :	  79f225:       80 3d b4 b6 41 00 00    cmpb   $0x0,0x41b6b4(%rip)        # bba8e0 <trace_sort>
    0.00 :	  79f22c:       74 42                   je     79f270 <tuplesort_end+0x90>
         :	        {
         :	                if (state->tapeset)
    0.00 :	  79f22e:       48 83 7b 30 00          cmpq   $0x0,0x30(%rbx)
    0.00 :	  79f233:       0f 84 b7 00 00 00       je     79f2f0 <tuplesort_end+0x110>
         :	                        elog(LOG, "external sort ended, %ld disk blocks used: %s",
    0.00 :	  79f239:       ba f9 2e 8e 00          mov    $0x8e2ef9,%edx
    0.00 :	  79f23e:       be a1 03 00 00          mov    $0x3a1,%esi
    0.00 :	  79f243:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79f248:       e8 d3 c1 fd ff          callq  77b420 <elog_start>
    0.00 :	  79f24d:       48 8d bb 48 01 00 00    lea    0x148(%rbx),%rdi
    0.00 :	  79f254:       e8 37 68 ff ff          callq  795a90 <pg_rusage_show>
    0.00 :	  79f259:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  79f25c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  79f25f:       be e8 2b 8e 00          mov    $0x8e2be8,%esi
    0.00 :	  79f264:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  79f269:       31 c0                   xor    %eax,%eax
    0.00 :	  79f26b:       e8 c0 bf fd ff          callq  77b230 <elog_finish>
         :	         */
         :	        TRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, 0L);
         :	#endif
         :
         :	        /* Free any execution state created for CLUSTER case */
         :	        if (state->estate != NULL)
    0.00 :	  79f270:       48 8b bb 10 01 00 00    mov    0x110(%rbx),%rdi
    0.00 :	  79f277:       48 85 ff                test   %rdi,%rdi
    0.00 :	  79f27a:       74 25                   je     79f2a1 <tuplesort_end+0xc1>
         :	        {
         :	                ExprContext *econtext = GetPerTupleExprContext(state->estate);
    0.00 :	  79f27c:       48 8b 87 c8 00 00 00    mov    0xc8(%rdi),%rax
    0.00 :	  79f283:       48 85 c0                test   %rax,%rax
    0.00 :	  79f286:       0f 84 a4 00 00 00       je     79f330 <tuplesort_end+0x150>
         :
         :	                ExecDropSingleTupleTableSlot(econtext->ecxt_scantuple);
    0.00 :	  79f28c:       48 8b 78 08             mov    0x8(%rax),%rdi
    0.00 :	  79f290:       e8 cb 50 e1 ff          callq  5b4360 <ExecDropSingleTupleTableSlot>
         :	                FreeExecutorState(state->estate);
    0.00 :	  79f295:       48 8b bb 10 01 00 00    mov    0x110(%rbx),%rdi
    0.00 :	  79f29c:       e8 6f 5f e1 ff          callq  5b5210 <FreeExecutorState>
    0.00 :	  79f2a1:       4c 89 2d b8 b5 41 00    mov    %r13,0x41b5b8(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        /*
         :	         * Free the per-sort memory context, thereby releasing all working memory,
         :	         * including the Tuplesortstate struct itself.
         :	         */
         :	        MemoryContextDelete(state->sortcontext);
    0.00 :	  79f2a8:       48 8b 7b 28             mov    0x28(%rbx),%rdi
         :	}
    0.00 :	  79f2ac:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  79f2b0:       5b                      pop    %rbx
    0.00 :	  79f2b1:       41 5c                   pop    %r12
    0.00 :	  79f2b3:       41 5d                   pop    %r13
    0.00 :	  79f2b5:       c9                      leaveq 
         :
         :	        /*
         :	         * Free the per-sort memory context, thereby releasing all working memory,
         :	         * including the Tuplesortstate struct itself.
         :	         */
         :	        MemoryContextDelete(state->sortcontext);
    0.00 :	  79f2b6:       e9 e5 98 ff ff          jmpq   798ba0 <MemoryContextDelete>
    0.00 :	  79f2bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        long            spaceUsed;
         :
         :	        if (state->tapeset)
         :	                spaceUsed = LogicalTapeSetBlocks(state->tapeset);
         :	        else
         :	                spaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;
    0.00 :	  79f2c0:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  79f2c4:       48 05 ff 03 00 00       add    $0x3ff,%rax
    0.00 :	  79f2ca:       48 2b 43 10             sub    0x10(%rbx),%rax
    0.00 :	  79f2ce:       48 8d 90 ff 03 00 00    lea    0x3ff(%rax),%rdx
    0.00 :	  79f2d5:       48 85 c0                test   %rax,%rax
    0.00 :	  79f2d8:       49 89 c4                mov    %rax,%r12
 /home/Computational/mark/src/postgres-andres/src/backend/utils/sort/tuplesort.c:912
  100.00 :	  79f2db:       4c 0f 48 e2             cmovs  %rdx,%r12
    0.00 :	  79f2df:       49 c1 fc 0a             sar    $0xa,%r12
    0.00 :	  79f2e3:       e9 3d ff ff ff          jmpq   79f225 <tuplesort_end+0x45>
    0.00 :	  79f2e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  79f2ef:       00 
         :	        {
         :	                if (state->tapeset)
         :	                        elog(LOG, "external sort ended, %ld disk blocks used: %s",
         :	                                 spaceUsed, pg_rusage_show(&state->ru_start));
         :	                else
         :	                        elog(LOG, "internal sort ended, %ld KB used: %s",
    0.00 :	  79f2f0:       ba f9 2e 8e 00          mov    $0x8e2ef9,%edx
    0.00 :	  79f2f5:       be a4 03 00 00          mov    $0x3a4,%esi
    0.00 :	  79f2fa:       bf c8 29 8e 00          mov    $0x8e29c8,%edi
    0.00 :	  79f2ff:       e8 1c c1 fd ff          callq  77b420 <elog_start>
    0.00 :	  79f304:       48 8d bb 48 01 00 00    lea    0x148(%rbx),%rdi
    0.00 :	  79f30b:       e8 80 67 ff ff          callq  795a90 <pg_rusage_show>
    0.00 :	  79f310:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  79f313:       48 89 c1                mov    %rax,%rcx
    0.00 :	  79f316:       be 18 2c 8e 00          mov    $0x8e2c18,%esi
    0.00 :	  79f31b:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  79f320:       31 c0                   xor    %eax,%eax
    0.00 :	  79f322:       e8 09 bf fd ff          callq  77b230 <elog_finish>
    0.00 :	  79f327:       e9 44 ff ff ff          jmpq   79f270 <tuplesort_end+0x90>
    0.00 :	  79f32c:       0f 1f 40 00             nopl   0x0(%rax)
         :	#endif
         :
         :	        /* Free any execution state created for CLUSTER case */
         :	        if (state->estate != NULL)
         :	        {
         :	                ExprContext *econtext = GetPerTupleExprContext(state->estate);
    0.00 :	  79f330:       e8 7b 62 e1 ff          callq  5b55b0 <MakePerTupleExprContext>
    0.00 :	  79f335:       0f 1f 00                nopl   (%rax)
    0.00 :	  79f338:       e9 4f ff ff ff          jmpq   79f28c <tuplesort_end+0xac>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000077aa0 <_int_free>:
    0.00 :	   77aa0:       41 57                   push   %r15
 ??:0
  100.00 :	   77aa2:       41 56                   push   %r14
    0.00 :	   77aa4:       41 55                   push   %r13
    0.00 :	   77aa6:       49 89 fd                mov    %rdi,%r13
    0.00 :	   77aa9:       41 54                   push   %r12
    0.00 :	   77aab:       55                      push   %rbp
    0.00 :	   77aac:       53                      push   %rbx
    0.00 :	   77aad:       48 89 f3                mov    %rsi,%rbx
    0.00 :	   77ab0:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	   77ab4:       48 8b 56 08             mov    0x8(%rsi),%rdx
    0.00 :	   77ab8:       48 89 d5                mov    %rdx,%rbp
    0.00 :	   77abb:       48 83 e5 f8             and    $0xfffffffffffffff8,%rbp
    0.00 :	   77abf:       48 89 e8                mov    %rbp,%rax
    0.00 :	   77ac2:       48 f7 d8                neg    %rax
    0.00 :	   77ac5:       48 39 c6                cmp    %rax,%rsi
    0.00 :	   77ac8:       0f 87 02 08 00 00       ja     782d0 <_int_free+0x830>
    0.00 :	   77ace:       40 f6 c6 0f             test   $0xf,%sil
    0.00 :	   77ad2:       0f 85 f8 07 00 00       jne    782d0 <_int_free+0x830>
    0.00 :	   77ad8:       48 83 fd 1f             cmp    $0x1f,%rbp
    0.00 :	   77adc:       48 8d 35 03 41 0c 00    lea    0xc4103(%rip),%rsi        # 13bbe6 <__PRETTY_FUNCTION__.14063+0x17f>
    0.00 :	   77ae3:       0f 86 ff 05 00 00       jbe    780e8 <_int_free+0x648>
    0.00 :	   77ae9:       48 3b 2d 88 cc 2f 00    cmp    0x2fcc88(%rip),%rbp        # 374778 <global_max_fast>
    0.00 :	   77af0:       0f 86 1a 03 00 00       jbe    77e10 <_int_free+0x370>
    0.00 :	   77af6:       f6 c2 02                test   $0x2,%dl
    0.00 :	   77af9:       0f 85 f9 02 00 00       jne    77df8 <_int_free+0x358>
    0.00 :	   77aff:       48 8b 4f 58             mov    0x58(%rdi),%rcx
    0.00 :	   77b03:       48 8d 35 de 76 0c 00    lea    0xc76de(%rip),%rsi        # 13f1e8 <__PRETTY_FUNCTION__.11129+0x180f>
    0.00 :	   77b0a:       48 39 d9                cmp    %rbx,%rcx
    0.00 :	   77b0d:       0f 84 d5 05 00 00       je     780e8 <_int_free+0x648>
    0.00 :	   77b13:       f6 47 04 02             testb  $0x2,0x4(%rdi)
    0.00 :	   77b17:       4c 8d 24 2b             lea    (%rbx,%rbp,1),%r12
    0.00 :	   77b1b:       0f 84 e1 07 00 00       je     78302 <_int_free+0x862>
    0.00 :	   77b21:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	   77b26:       48 8d 35 fb 76 0c 00    lea    0xc76fb(%rip),%rsi        # 13f228 <__PRETTY_FUNCTION__.11129+0x184f>
    0.00 :	   77b2d:       a8 01                   test   $0x1,%al
    0.00 :	   77b2f:       0f 84 b3 05 00 00       je     780e8 <_int_free+0x648>
    0.00 :	   77b35:       48 83 f8 10             cmp    $0x10,%rax
    0.00 :	   77b39:       0f 86 9b 05 00 00       jbe    780da <_int_free+0x63a>
    0.00 :	   77b3f:       49 89 c0                mov    %rax,%r8
    0.00 :	   77b42:       49 83 e0 f8             and    $0xfffffffffffffff8,%r8
    0.00 :	   77b46:       4d 3b 85 70 08 00 00    cmp    0x870(%r13),%r8
    0.00 :	   77b4d:       0f 83 87 05 00 00       jae    780da <_int_free+0x63a>
    0.00 :	   77b53:       8b 05 27 cc 2f 00       mov    0x2fcc27(%rip),%eax        # 374780 <perturb_byte>
    0.00 :	   77b59:       85 c0                   test   %eax,%eax
    0.00 :	   77b5b:       0f 85 c7 07 00 00       jne    78328 <_int_free+0x888>
    0.00 :	   77b61:       83 e2 01                and    $0x1,%edx
    0.00 :	   77b64:       0f 84 2e 05 00 00       je     78098 <_int_free+0x5f8>
    0.00 :	   77b6a:       4d 39 65 58             cmp    %r12,0x58(%r13)
    0.00 :	   77b6e:       0f 84 a4 05 00 00       je     78118 <_int_free+0x678>
    0.00 :	   77b74:       43 f6 44 04 08 01       testb  $0x1,0x8(%r12,%r8,1)
    0.00 :	   77b7a:       0f 84 00 03 00 00       je     77e80 <_int_free+0x3e0>
    0.00 :	   77b80:       49 83 64 24 08 fe       andq   $0xfffffffffffffffe,0x8(%r12)
    0.00 :	   77b86:       49 8d 45 58             lea    0x58(%r13),%rax
    0.00 :	   77b8a:       48 8d 35 bf 76 0c 00    lea    0xc76bf(%rip),%rsi        # 13f250 <__PRETTY_FUNCTION__.11129+0x1877>
    0.00 :	   77b91:       48 8b 48 10             mov    0x10(%rax),%rcx
    0.00 :	   77b95:       48 8b 51 18             mov    0x18(%rcx),%rdx
    0.00 :	   77b99:       48 39 c2                cmp    %rax,%rdx
    0.00 :	   77b9c:       0f 85 46 05 00 00       jne    780e8 <_int_free+0x648>
    0.00 :	   77ba2:       48 81 fd ff 03 00 00    cmp    $0x3ff,%rbp
    0.00 :	   77ba9:       48 89 4b 10             mov    %rcx,0x10(%rbx)
    0.00 :	   77bad:       48 89 53 18             mov    %rdx,0x18(%rbx)
    0.00 :	   77bb1:       76 10                   jbe    77bc3 <_int_free+0x123>
    0.00 :	   77bb3:       48 c7 43 20 00 00 00    movq   $0x0,0x20(%rbx)
    0.00 :	   77bba:       00 
    0.00 :	   77bbb:       48 c7 43 28 00 00 00    movq   $0x0,0x28(%rbx)
    0.00 :	   77bc2:       00 
    0.00 :	   77bc3:       48 89 e8                mov    %rbp,%rax
    0.00 :	   77bc6:       48 89 5a 10             mov    %rbx,0x10(%rdx)
    0.00 :	   77bca:       48 89 59 18             mov    %rbx,0x18(%rcx)
    0.00 :	   77bce:       48 83 c8 01             or     $0x1,%rax
    0.00 :	   77bd2:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	   77bd6:       48 89 2c 2b             mov    %rbp,(%rbx,%rbp,1)
    0.00 :	   77bda:       48 81 fd ff ff 00 00    cmp    $0xffff,%rbp
    0.00 :	   77be1:       0f 86 82 02 00 00       jbe    77e69 <_int_free+0x3c9>
    0.00 :	   77be7:       41 f6 45 04 01          testb  $0x1,0x4(%r13)
    0.00 :	   77bec:       0f 84 16 05 00 00       je     78108 <_int_free+0x668>
    0.00 :	   77bf2:       48 8d 05 a7 c2 2f 00    lea    0x2fc2a7(%rip),%rax        # 373ea0 <main_arena>
    0.00 :	   77bf9:       49 39 c5                cmp    %rax,%r13
    0.00 :	   77bfc:       0f 84 6e 06 00 00       je     78270 <_int_free+0x7d0>
    0.00 :	   77c02:       4d 8b 65 58             mov    0x58(%r13),%r12
    0.00 :	   77c06:       49 81 e4 00 00 00 fc    and    $0xfffffffffc000000,%r12
    0.00 :	   77c0d:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	   77c11:       4c 39 e8                cmp    %r13,%rax
    0.00 :	   77c14:       48 89 44 24 20          mov    %rax,0x20(%rsp)
    0.00 :	   77c19:       74 28                   je     77c43 <_int_free+0x1a3>
    0.00 :	   77c1b:       48 8d 0d f1 41 0c 00    lea    0xc41f1(%rip),%rcx        # 13be13 <__func__.14301>
    0.00 :	   77c22:       48 8d 35 19 3f 0c 00    lea    0xc3f19(%rip),%rsi        # 13bb42 <__PRETTY_FUNCTION__.14063+0xdb>
    0.00 :	   77c29:       48 8d 3d cb 3f 0c 00    lea    0xc3fcb(%rip),%rdi        # 13bbfb <__PRETTY_FUNCTION__.14063+0x194>
    0.00 :	   77c30:       ba b6 13 00 00          mov    $0x13b6,%edx
    0.00 :	   77c35:       e8 86 eb ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77c3a:       49 8b 14 24             mov    (%r12),%rdx
    0.00 :	   77c3e:       48 89 54 24 20          mov    %rdx,0x20(%rsp)
    0.00 :	   77c43:       48 8b 05 de ca 2f 00    mov    0x2fcade(%rip),%rax        # 374728 <mp_+0x8>
    0.00 :	   77c4a:       8b 15 00 cb 2f 00       mov    0x2fcb00(%rip),%edx        # 374750 <mp_+0x30>
    0.00 :	   77c50:       48 89 44 24 28          mov    %rax,0x28(%rsp)
    0.00 :	   77c55:       48 8b 44 24 20          mov    0x20(%rsp),%rax
    0.00 :	   77c5a:       48 89 54 24 18          mov    %rdx,0x18(%rsp)
    0.00 :	   77c5f:       4c 8b 78 58             mov    0x58(%rax),%r15
    0.00 :	   77c63:       49 8d 44 24 20          lea    0x20(%r12),%rax
    0.00 :	   77c68:       49 39 c7                cmp    %rax,%r15
    0.00 :	   77c6b:       0f 85 72 03 00 00       jne    77fe3 <_int_free+0x543>
    0.00 :	   77c71:       48 8b 44 24 28          mov    0x28(%rsp),%rax
    0.00 :	   77c76:       4d 89 e6                mov    %r12,%r14
    0.00 :	   77c79:       48 8d 44 10 20          lea    0x20(%rax,%rdx,1),%rax
    0.00 :	   77c7e:       48 83 ea 01             sub    $0x1,%rdx
    0.00 :	   77c82:       48 89 54 24 10          mov    %rdx,0x10(%rsp)
    0.00 :	   77c87:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    0.00 :	   77c8c:       e9 e3 00 00 00          jmpq   77d74 <_int_free+0x2d4>
    0.00 :	   77c91:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   77c98:       83 e2 01                and    $0x1,%edx
    0.00 :	   77c9b:       4c 89 ed                mov    %r13,%rbp
    0.00 :	   77c9e:       75 06                   jne    77ca6 <_int_free+0x206>
    0.00 :	   77ca0:       4c 89 ed                mov    %r13,%rbp
    0.00 :	   77ca3:       48 03 2b                add    (%rbx),%rbp
    0.00 :	   77ca6:       48 8d 45 ff             lea    -0x1(%rbp),%rax
    0.00 :	   77caa:       48 3d fe ff ff 03       cmp    $0x3fffffe,%rax
    0.00 :	   77cb0:       0f 87 0a 02 00 00       ja     77ec0 <_int_free+0x420>
    0.00 :	   77cb6:       b8 00 00 00 04          mov    $0x4000000,%eax
    0.00 :	   77cbb:       49 2b 44 24 10          sub    0x10(%r12),%rax
    0.00 :	   77cc0:       48 01 e8                add    %rbp,%rax
    0.00 :	   77cc3:       48 3b 44 24 30          cmp    0x30(%rsp),%rax
    0.00 :	   77cc8:       0f 82 12 03 00 00       jb     77fe0 <_int_free+0x540>
    0.00 :	   77cce:       48 8b 54 24 20          mov    0x20(%rsp),%rdx
    0.00 :	   77cd3:       49 8b 46 10             mov    0x10(%r14),%rax
    0.00 :	   77cd7:       48 29 82 70 08 00 00    sub    %rax,0x870(%rdx)
    0.00 :	   77cde:       49 8b 46 10             mov    0x10(%r14),%rax
    0.00 :	   77ce2:       48 29 05 a7 ca 2f 00    sub    %rax,0x2fcaa7(%rip)        # 374790 <arena_mem>
    0.00 :	   77ce9:       49 8d 86 00 00 00 04    lea    0x4000000(%r14),%rax
    0.00 :	   77cf0:       48 39 05 01 cb 2f 00    cmp    %rax,0x2fcb01(%rip)        # 3747f8 <aligned_heap_area>
    0.00 :	   77cf7:       0f 84 d3 02 00 00       je     77fd0 <_int_free+0x530>
    0.00 :	   77cfd:       be 00 00 00 04          mov    $0x4000000,%esi
    0.00 :	   77d02:       4c 89 f7                mov    %r14,%rdi
    0.00 :	   77d05:       49 89 df                mov    %rbx,%r15
    0.00 :	   77d08:       e8 73 ff 05 00          callq  d7c80 <munmap>
    0.00 :	   77d0d:       f6 43 08 01             testb  $0x1,0x8(%rbx)
    0.00 :	   77d11:       0f 84 f9 01 00 00       je     77f10 <_int_free+0x470>
    0.00 :	   77d17:       49 8d 1c 2f             lea    (%r15,%rbp,1),%rbx
    0.00 :	   77d1b:       48 85 5c 24 10          test   %rbx,0x10(%rsp)
    0.00 :	   77d20:       0f 85 c2 01 00 00       jne    77ee8 <_int_free+0x448>
    0.00 :	   77d26:       4c 89 e0                mov    %r12,%rax
    0.00 :	   77d29:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	   77d2e:       48 39 c3                cmp    %rax,%rbx
    0.00 :	   77d31:       74 1f                   je     77d52 <_int_free+0x2b2>
    0.00 :	   77d33:       48 8d 0d e3 40 0c 00    lea    0xc40e3(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77d3a:       48 8d 35 cd 3e 0c 00    lea    0xc3ecd(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77d41:       48 8d 3d 60 76 0c 00    lea    0xc7660(%rip),%rdi        # 13f3a8 <__PRETTY_FUNCTION__.11129+0x19cf>
    0.00 :	   77d48:       ba 6a 03 00 00          mov    $0x36a,%edx
    0.00 :	   77d4d:       e8 6e ea ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77d52:       48 8b 44 24 20          mov    0x20(%rsp),%rax
    0.00 :	   77d57:       48 83 cd 01             or     $0x1,%rbp
    0.00 :	   77d5b:       4c 89 78 58             mov    %r15,0x58(%rax)
    0.00 :	   77d5f:       49 8d 44 24 20          lea    0x20(%r12),%rax
    0.00 :	   77d64:       49 89 6f 08             mov    %rbp,0x8(%r15)
    0.00 :	   77d68:       49 39 c7                cmp    %rax,%r15
    0.00 :	   77d6b:       0f 85 72 02 00 00       jne    77fe3 <_int_free+0x543>
    0.00 :	   77d71:       4d 89 e6                mov    %r12,%r14
    0.00 :	   77d74:       4d 8b 64 24 08          mov    0x8(%r12),%r12
    0.00 :	   77d79:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	   77d7e:       49 8d 5c 04 f0          lea    -0x10(%r12,%rax,1),%rbx
    0.00 :	   77d83:       48 83 7b 08 01          cmpq   $0x1,0x8(%rbx)
    0.00 :	   77d88:       74 1f                   je     77da9 <_int_free+0x309>
    0.00 :	   77d8a:       48 8d 0d 8c 40 0c 00    lea    0xc408c(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77d91:       48 8d 35 76 3e 0c 00    lea    0xc3e76(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77d98:       48 8d 3d 77 3e 0c 00    lea    0xc3e77(%rip),%rdi        # 13bc16 <__PRETTY_FUNCTION__.14063+0x1af>
    0.00 :	   77d9f:       ba 58 03 00 00          mov    $0x358,%edx
    0.00 :	   77da4:       e8 17 ea ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77da9:       48 2b 1b                sub    (%rbx),%rbx
    0.00 :	   77dac:       48 8b 53 08             mov    0x8(%rbx),%rdx
    0.00 :	   77db0:       48 89 d0                mov    %rdx,%rax
    0.00 :	   77db3:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	   77db7:       4c 8d 68 10             lea    0x10(%rax),%r13
    0.00 :	   77dbb:       48 83 c0 0f             add    $0xf,%rax
    0.00 :	   77dbf:       48 83 f8 3e             cmp    $0x3e,%rax
    0.00 :	   77dc3:       0f 86 cf fe ff ff       jbe    77c98 <_int_free+0x1f8>
    0.00 :	   77dc9:       48 8d 0d 4d 40 0c 00    lea    0xc404d(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77dd0:       48 8d 35 37 3e 0c 00    lea    0xc3e37(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77dd7:       48 8d 3d 9a 74 0c 00    lea    0xc749a(%rip),%rdi        # 13f278 <__PRETTY_FUNCTION__.11129+0x189f>
    0.00 :	   77dde:       ba 5b 03 00 00          mov    $0x35b,%edx
    0.00 :	   77de3:       e8 d8 e9 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77de8:       48 8b 53 08             mov    0x8(%rbx),%rdx
    0.00 :	   77dec:       e9 a7 fe ff ff          jmpq   77c98 <_int_free+0x1f8>
    0.00 :	   77df1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   77df8:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	   77dfc:       48 89 df                mov    %rbx,%rdi
    0.00 :	   77dff:       5b                      pop    %rbx
    0.00 :	   77e00:       5d                      pop    %rbp
    0.00 :	   77e01:       41 5c                   pop    %r12
    0.00 :	   77e03:       41 5d                   pop    %r13
    0.00 :	   77e05:       41 5e                   pop    %r14
    0.00 :	   77e07:       41 5f                   pop    %r15
    0.00 :	   77e09:       e9 c2 fb ff ff          jmpq   779d0 <munmap_chunk>
    0.00 :	   77e0e:       66 90                   xchg   %ax,%ax
    0.00 :	   77e10:       48 8b 44 2b 08          mov    0x8(%rbx,%rbp,1),%rax
    0.00 :	   77e15:       48 83 f8 10             cmp    $0x10,%rax
    0.00 :	   77e19:       0f 86 d7 04 00 00       jbe    782f6 <_int_free+0x856>
    0.00 :	   77e1f:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	   77e23:       48 3b 87 70 08 00 00    cmp    0x870(%rdi),%rax
    0.00 :	   77e2a:       0f 83 c6 04 00 00       jae    782f6 <_int_free+0x856>
    0.00 :	   77e30:       8b 05 4a c9 2f 00       mov    0x2fc94a(%rip),%eax        # 374780 <perturb_byte>
    0.00 :	   77e36:       85 c0                   test   %eax,%eax
    0.00 :	   77e38:       0f 85 0d 05 00 00       jne    7834b <_int_free+0x8ab>
    0.00 :	   77e3e:       89 e8                   mov    %ebp,%eax
    0.00 :	   77e40:       41 83 65 04 fe          andl   $0xfffffffe,0x4(%r13)
    0.00 :	   77e45:       48 8d 35 74 73 0c 00    lea    0xc7374(%rip),%rsi        # 13f1c0 <__PRETTY_FUNCTION__.11129+0x17e7>
    0.00 :	   77e4c:       c1 e8 04                shr    $0x4,%eax
    0.00 :	   77e4f:       83 e8 02                sub    $0x2,%eax
    0.00 :	   77e52:       49 8b 4c c5 08          mov    0x8(%r13,%rax,8),%rcx
    0.00 :	   77e57:       48 39 d9                cmp    %rbx,%rcx
    0.00 :	   77e5a:       0f 84 88 02 00 00       je     780e8 <_int_free+0x648>
    0.00 :	   77e60:       48 89 4b 10             mov    %rcx,0x10(%rbx)
    0.00 :	   77e64:       49 89 5c c5 08          mov    %rbx,0x8(%r13,%rax,8)
    0.00 :	   77e69:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	   77e6d:       5b                      pop    %rbx
    0.00 :	   77e6e:       5d                      pop    %rbp
    0.00 :	   77e6f:       41 5c                   pop    %r12
    0.00 :	   77e71:       41 5d                   pop    %r13
    0.00 :	   77e73:       41 5e                   pop    %r14
    0.00 :	   77e75:       41 5f                   pop    %r15
    0.00 :	   77e77:       c3                      retq   
    0.00 :	   77e78:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	   77e7f:       00 
    0.00 :	   77e80:       4d 8b 74 24 10          mov    0x10(%r12),%r14
    0.00 :	   77e85:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	   77e8a:       4d 8b 7e 18             mov    0x18(%r14),%r15
    0.00 :	   77e8e:       4d 39 e7                cmp    %r12,%r15
    0.00 :	   77e91:       0f 85 ed 04 00 00       jne    78384 <_int_free+0x8e4>
    0.00 :	   77e97:       4c 3b 60 10             cmp    0x10(%rax),%r12
    0.00 :	   77e9b:       0f 85 e3 04 00 00       jne    78384 <_int_free+0x8e4>
    0.00 :	   77ea1:       49 89 46 18             mov    %rax,0x18(%r14)
    0.00 :	   77ea5:       4c 89 70 10             mov    %r14,0x10(%rax)
    0.00 :	   77ea9:       49 81 7c 24 08 ff 03    cmpq   $0x3ff,0x8(%r12)
    0.00 :	   77eb0:       00 00 
    0.00 :	   77eb2:       0f 87 18 03 00 00       ja     781d0 <_int_free+0x730>
    0.00 :	   77eb8:       4c 01 c5                add    %r8,%rbp
    0.00 :	   77ebb:       e9 c6 fc ff ff          jmpq   77b86 <_int_free+0xe6>
    0.00 :	   77ec0:       48 8d 0d 56 3f 0c 00    lea    0xc3f56(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77ec7:       48 8d 35 40 3d 0c 00    lea    0xc3d40(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77ece:       48 8d 3d 53 74 0c 00    lea    0xc7453(%rip),%rdi        # 13f328 <__PRETTY_FUNCTION__.11129+0x194f>
    0.00 :	   77ed5:       ba 5e 03 00 00          mov    $0x35e,%edx
    0.00 :	   77eda:       e8 e1 e8 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77edf:       e9 d2 fd ff ff          jmpq   77cb6 <_int_free+0x216>
    0.00 :	   77ee4:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   77ee8:       48 8d 0d 2e 3f 0c 00    lea    0xc3f2e(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77eef:       48 8d 35 18 3d 0c 00    lea    0xc3d18(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77ef6:       48 8d 3d 6b 74 0c 00    lea    0xc746b(%rip),%rdi        # 13f368 <__PRETTY_FUNCTION__.11129+0x198f>
    0.00 :	   77efd:       ba 69 03 00 00          mov    $0x369,%edx
    0.00 :	   77f02:       e8 b9 e8 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77f07:       e9 1a fe ff ff          jmpq   77d26 <_int_free+0x286>
    0.00 :	   77f0c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   77f10:       49 89 df                mov    %rbx,%r15
    0.00 :	   77f13:       4c 2b 3b                sub    (%rbx),%r15
    0.00 :	   77f16:       49 8b 5f 10             mov    0x10(%r15),%rbx
    0.00 :	   77f1a:       49 8b 47 18             mov    0x18(%r15),%rax
    0.00 :	   77f1e:       4c 3b 7b 18             cmp    0x18(%rbx),%r15
    0.00 :	   77f22:       0f 85 b4 03 00 00       jne    782dc <_int_free+0x83c>
    0.00 :	   77f28:       4c 3b 78 10             cmp    0x10(%rax),%r15
    0.00 :	   77f2c:       0f 85 aa 03 00 00       jne    782dc <_int_free+0x83c>
    0.00 :	   77f32:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	   77f36:       48 89 58 10             mov    %rbx,0x10(%rax)
    0.00 :	   77f3a:       49 81 7f 08 ff 03 00    cmpq   $0x3ff,0x8(%r15)
    0.00 :	   77f41:       00 
    0.00 :	   77f42:       0f 86 cf fd ff ff       jbe    77d17 <_int_free+0x277>
    0.00 :	   77f48:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   77f4c:       48 85 c0                test   %rax,%rax
    0.00 :	   77f4f:       0f 84 c2 fd ff ff       je     77d17 <_int_free+0x277>
    0.00 :	   77f55:       4c 3b 78 28             cmp    0x28(%rax),%r15
    0.00 :	   77f59:       74 1f                   je     77f7a <_int_free+0x4da>
    0.00 :	   77f5b:       48 8d 0d bb 3e 0c 00    lea    0xc3ebb(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77f62:       48 8d 35 a5 3c 0c 00    lea    0xc3ca5(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77f69:       48 8d 3d 20 71 0c 00    lea    0xc7120(%rip),%rdi        # 13f090 <__PRETTY_FUNCTION__.11129+0x16b7>
    0.00 :	   77f70:       ba 67 03 00 00          mov    $0x367,%edx
    0.00 :	   77f75:       e8 46 e8 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77f7a:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   77f7e:       4c 3b 78 20             cmp    0x20(%rax),%r15
    0.00 :	   77f82:       74 1f                   je     77fa3 <_int_free+0x503>
    0.00 :	   77f84:       48 8d 0d 92 3e 0c 00    lea    0xc3e92(%rip),%rcx        # 13be1d <__func__.12681>
    0.00 :	   77f8b:       48 8d 35 7c 3c 0c 00    lea    0xc3c7c(%rip),%rsi        # 13bc0e <__PRETTY_FUNCTION__.14063+0x1a7>
    0.00 :	   77f92:       48 8d 3d 1f 71 0c 00    lea    0xc711f(%rip),%rdi        # 13f0b8 <__PRETTY_FUNCTION__.11129+0x16df>
    0.00 :	   77f99:       ba 67 03 00 00          mov    $0x367,%edx
    0.00 :	   77f9e:       e8 1d e8 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   77fa3:       48 83 7b 20 00          cmpq   $0x0,0x20(%rbx)
    0.00 :	   77fa8:       0f 84 fa 03 00 00       je     783a8 <_int_free+0x908>
    0.00 :	   77fae:       49 8b 57 20             mov    0x20(%r15),%rdx
    0.00 :	   77fb2:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   77fb6:       48 89 42 28             mov    %rax,0x28(%rdx)
    0.00 :	   77fba:       49 8b 57 28             mov    0x28(%r15),%rdx
    0.00 :	   77fbe:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   77fc2:       48 89 42 20             mov    %rax,0x20(%rdx)
    0.00 :	   77fc6:       e9 4c fd ff ff          jmpq   77d17 <_int_free+0x277>
    0.00 :	   77fcb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	   77fd0:       48 c7 05 1d c8 2f 00    movq   $0x0,0x2fc81d(%rip)        # 3747f8 <aligned_heap_area>
    0.00 :	   77fd7:       00 00 00 00 
    0.00 :	   77fdb:       e9 1d fd ff ff          jmpq   77cfd <_int_free+0x25d>
    0.00 :	   77fe0:       4d 89 f4                mov    %r14,%r12
    0.00 :	   77fe3:       4d 8b 6f 08             mov    0x8(%r15),%r13
    0.00 :	   77fe7:       48 8b 44 24 18          mov    0x18(%rsp),%rax
    0.00 :	   77fec:       31 d2                   xor    %edx,%edx
    0.00 :	   77fee:       48 2b 44 24 28          sub    0x28(%rsp),%rax
    0.00 :	   77ff3:       49 83 e5 f8             and    $0xfffffffffffffff8,%r13
    0.00 :	   77ff7:       49 8d 44 05 df          lea    -0x21(%r13,%rax,1),%rax
    0.00 :	   77ffc:       48 f7 74 24 18          divq   0x18(%rsp)
    0.00 :	   78001:       48 8d 58 ff             lea    -0x1(%rax),%rbx
    0.00 :	   78005:       48 0f af 5c 24 18       imul   0x18(%rsp),%rbx
    0.00 :	   7800b:       48 3b 5c 24 18          cmp    0x18(%rsp),%rbx
    0.00 :	   78010:       0f 8c 53 fe ff ff       jl     77e69 <_int_free+0x3c9>
    0.00 :	   78016:       49 8b 6c 24 10          mov    0x10(%r12),%rbp
    0.00 :	   7801b:       48 29 dd                sub    %rbx,%rbp
    0.00 :	   7801e:       48 83 fd 1f             cmp    $0x1f,%rbp
    0.00 :	   78022:       0f 8e 41 fe ff ff       jle    77e69 <_int_free+0x3c9>
    0.00 :	   78028:       48 8b 05 c1 9d 2f 00    mov    0x2f9dc1(%rip),%rax        # 371df0 <_DYNAMIC+0x290>
    0.00 :	   7802f:       44 8b 30                mov    (%rax),%r14d
    0.00 :	   78032:       45 85 f6                test   %r14d,%r14d
    0.00 :	   78035:       0f 84 75 02 00 00       je     782b0 <_int_free+0x810>
    0.00 :	   7803b:       49 8d 3c 2c             lea    (%r12,%rbp,1),%rdi
    0.00 :	   7803f:       45 31 c9                xor    %r9d,%r9d
    0.00 :	   78042:       31 d2                   xor    %edx,%edx
    0.00 :	   78044:       41 b8 ff ff ff ff       mov    $0xffffffff,%r8d
    0.00 :	   7804a:       b9 32 00 00 00          mov    $0x32,%ecx
    0.00 :	   7804f:       48 89 de                mov    %rbx,%rsi
    0.00 :	   78052:       e8 f9 fb 05 00          callq  d7c50 <mmap>
    0.00 :	   78057:       48 83 c0 01             add    $0x1,%rax
    0.00 :	   7805b:       0f 84 08 fe ff ff       je     77e69 <_int_free+0x3c9>
    0.00 :	   78061:       49 89 6c 24 18          mov    %rbp,0x18(%r12)
    0.00 :	   78066:       49 89 6c 24 10          mov    %rbp,0x10(%r12)
    0.00 :	   7806b:       48 8b 54 24 20          mov    0x20(%rsp),%rdx
    0.00 :	   78070:       4c 89 e8                mov    %r13,%rax
    0.00 :	   78073:       48 29 d8                sub    %rbx,%rax
    0.00 :	   78076:       48 83 c8 01             or     $0x1,%rax
    0.00 :	   7807a:       48 29 9a 70 08 00 00    sub    %rbx,0x870(%rdx)
    0.00 :	   78081:       48 29 1d 08 c7 2f 00    sub    %rbx,0x2fc708(%rip)        # 374790 <arena_mem>
    0.00 :	   78088:       49 89 47 08             mov    %rax,0x8(%r15)
    0.00 :	   7808c:       e9 d8 fd ff ff          jmpq   77e69 <_int_free+0x3c9>
    0.00 :	   78091:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   78098:       48 8b 03                mov    (%rbx),%rax
    0.00 :	   7809b:       48 29 c3                sub    %rax,%rbx
    0.00 :	   7809e:       48 01 c5                add    %rax,%rbp
    0.00 :	   780a1:       4c 8b 73 10             mov    0x10(%rbx),%r14
    0.00 :	   780a5:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	   780a9:       4d 8b 7e 18             mov    0x18(%r14),%r15
    0.00 :	   780ad:       49 39 df                cmp    %rbx,%r15
    0.00 :	   780b0:       0f 85 aa 02 00 00       jne    78360 <_int_free+0x8c0>
    0.00 :	   780b6:       48 3b 58 10             cmp    0x10(%rax),%rbx
    0.00 :	   780ba:       0f 85 a0 02 00 00       jne    78360 <_int_free+0x8c0>
    0.00 :	   780c0:       49 89 46 18             mov    %rax,0x18(%r14)
    0.00 :	   780c4:       4c 89 70 10             mov    %r14,0x10(%rax)
    0.00 :	   780c8:       48 81 7b 08 ff 03 00    cmpq   $0x3ff,0x8(%rbx)
    0.00 :	   780cf:       00 
    0.00 :	   780d0:       77 5e                   ja     78130 <_int_free+0x690>
    0.00 :	   780d2:       4c 89 fb                mov    %r15,%rbx
    0.00 :	   780d5:       e9 90 fa ff ff          jmpq   77b6a <_int_free+0xca>
    0.00 :	   780da:       48 8d 35 b7 70 0c 00    lea    0xc70b7(%rip),%rsi        # 13f198 <__PRETTY_FUNCTION__.11129+0x17bf>
    0.00 :	   780e1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   780e8:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	   780ec:       8b 3d 16 a0 2f 00       mov    0x2fa016(%rip),%edi        # 372108 <check_action>
    0.00 :	   780f2:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	   780f6:       5b                      pop    %rbx
    0.00 :	   780f7:       5d                      pop    %rbp
    0.00 :	   780f8:       41 5c                   pop    %r12
    0.00 :	   780fa:       41 5d                   pop    %r13
    0.00 :	   780fc:       41 5e                   pop    %r14
    0.00 :	   780fe:       41 5f                   pop    %r15
    0.00 :	   78100:       e9 5b e4 ff ff          jmpq   76560 <malloc_printerr>
    0.00 :	   78105:       0f 1f 00                nopl   (%rax)
    0.00 :	   78108:       4c 89 ef                mov    %r13,%rdi
    0.00 :	   7810b:       e8 30 e7 ff ff          callq  76840 <malloc_consolidate>
    0.00 :	   78110:       e9 dd fa ff ff          jmpq   77bf2 <_int_free+0x152>
    0.00 :	   78115:       0f 1f 00                nopl   (%rax)
    0.00 :	   78118:       4c 01 c5                add    %r8,%rbp
    0.00 :	   7811b:       48 89 e8                mov    %rbp,%rax
    0.00 :	   7811e:       48 83 c8 01             or     $0x1,%rax
    0.00 :	   78122:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	   78126:       49 89 5d 58             mov    %rbx,0x58(%r13)
    0.00 :	   7812a:       e9 ab fa ff ff          jmpq   77bda <_int_free+0x13a>
    0.00 :	   7812f:       90                      nop
    0.00 :	   78130:       48 8b 43 20             mov    0x20(%rbx),%rax
    0.00 :	   78134:       48 85 c0                test   %rax,%rax
    0.00 :	   78137:       74 99                   je     780d2 <_int_free+0x632>
    0.00 :	   78139:       48 3b 58 28             cmp    0x28(%rax),%rbx
    0.00 :	   7813d:       74 29                   je     78168 <_int_free+0x6c8>
    0.00 :	   7813f:       48 8d 0d cd 3c 0c 00    lea    0xc3ccd(%rip),%rcx        # 13be13 <__func__.14301>
    0.00 :	   78146:       48 8d 35 f5 39 0c 00    lea    0xc39f5(%rip),%rsi        # 13bb42 <__PRETTY_FUNCTION__.14063+0xdb>
    0.00 :	   7814d:       48 8d 3d 3c 6f 0c 00    lea    0xc6f3c(%rip),%rdi        # 13f090 <__PRETTY_FUNCTION__.11129+0x16b7>
    0.00 :	   78154:       ba 63 13 00 00          mov    $0x1363,%edx
    0.00 :	   78159:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   7815e:       e8 5d e6 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   78163:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   78168:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   7816c:       4c 3b 78 20             cmp    0x20(%rax),%r15
    0.00 :	   78170:       74 29                   je     7819b <_int_free+0x6fb>
    0.00 :	   78172:       48 8d 0d 9a 3c 0c 00    lea    0xc3c9a(%rip),%rcx        # 13be13 <__func__.14301>
    0.00 :	   78179:       48 8d 35 c2 39 0c 00    lea    0xc39c2(%rip),%rsi        # 13bb42 <__PRETTY_FUNCTION__.14063+0xdb>
    0.00 :	   78180:       48 8d 3d 31 6f 0c 00    lea    0xc6f31(%rip),%rdi        # 13f0b8 <__PRETTY_FUNCTION__.11129+0x16df>
    0.00 :	   78187:       ba 63 13 00 00          mov    $0x1363,%edx
    0.00 :	   7818c:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78191:       e8 2a e6 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   78196:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   7819b:       49 83 7e 20 00          cmpq   $0x0,0x20(%r14)
    0.00 :	   781a0:       0f 84 2c 02 00 00       je     783d2 <_int_free+0x932>
    0.00 :	   781a6:       49 8b 57 20             mov    0x20(%r15),%rdx
    0.00 :	   781aa:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   781ae:       4c 89 fb                mov    %r15,%rbx
    0.00 :	   781b1:       48 89 42 28             mov    %rax,0x28(%rdx)
    0.00 :	   781b5:       49 8b 57 28             mov    0x28(%r15),%rdx
    0.00 :	   781b9:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   781bd:       48 89 42 20             mov    %rax,0x20(%rdx)
    0.00 :	   781c1:       e9 a4 f9 ff ff          jmpq   77b6a <_int_free+0xca>
    0.00 :	   781c6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	   781cd:       00 00 00 
    0.00 :	   781d0:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	   781d5:       48 85 c0                test   %rax,%rax
    0.00 :	   781d8:       0f 84 da fc ff ff       je     77eb8 <_int_free+0x418>
    0.00 :	   781de:       4c 3b 60 28             cmp    0x28(%rax),%r12
    0.00 :	   781e2:       74 29                   je     7820d <_int_free+0x76d>
    0.00 :	   781e4:       48 8d 0d 28 3c 0c 00    lea    0xc3c28(%rip),%rcx        # 13be13 <__func__.14301>
    0.00 :	   781eb:       48 8d 35 50 39 0c 00    lea    0xc3950(%rip),%rsi        # 13bb42 <__PRETTY_FUNCTION__.14063+0xdb>
    0.00 :	   781f2:       48 8d 3d e7 6e 0c 00    lea    0xc6ee7(%rip),%rdi        # 13f0e0 <__PRETTY_FUNCTION__.11129+0x1707>
    0.00 :	   781f9:       ba 6c 13 00 00          mov    $0x136c,%edx
    0.00 :	   781fe:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78203:       e8 b8 e5 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   78208:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   7820d:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   78211:       4c 3b 78 20             cmp    0x20(%rax),%r15
    0.00 :	   78215:       74 29                   je     78240 <_int_free+0x7a0>
    0.00 :	   78217:       48 8d 0d f5 3b 0c 00    lea    0xc3bf5(%rip),%rcx        # 13be13 <__func__.14301>
    0.00 :	   7821e:       48 8d 35 1d 39 0c 00    lea    0xc391d(%rip),%rsi        # 13bb42 <__PRETTY_FUNCTION__.14063+0xdb>
    0.00 :	   78225:       48 8d 3d ec 6e 0c 00    lea    0xc6eec(%rip),%rdi        # 13f118 <__PRETTY_FUNCTION__.11129+0x173f>
    0.00 :	   7822c:       ba 6c 13 00 00          mov    $0x136c,%edx
    0.00 :	   78231:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78236:       e8 85 e5 ff ff          callq  767c0 <__malloc_assert>
    0.00 :	   7823b:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   78240:       49 83 7e 20 00          cmpq   $0x0,0x20(%r14)
    0.00 :	   78245:       0f 84 b4 01 00 00       je     783ff <_int_free+0x95f>
    0.00 :	   7824b:       49 8b 57 20             mov    0x20(%r15),%rdx
    0.00 :	   7824f:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   78253:       48 89 42 28             mov    %rax,0x28(%rdx)
    0.00 :	   78257:       49 8b 57 28             mov    0x28(%r15),%rdx
    0.00 :	   7825b:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   7825f:       48 89 42 20             mov    %rax,0x20(%rdx)
    0.00 :	   78263:       e9 50 fc ff ff          jmpq   77eb8 <_int_free+0x418>
    0.00 :	   78268:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	   7826f:       00 
    0.00 :	   78270:       48 8b 05 81 bc 2f 00    mov    0x2fbc81(%rip),%rax        # 373ef8 <main_arena+0x58>
    0.00 :	   78277:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	   7827b:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	   7827f:       48 3b 05 9a c4 2f 00    cmp    0x2fc49a(%rip),%rax        # 374720 <mp_>
    0.00 :	   78286:       0f 82 dd fb ff ff       jb     77e69 <_int_free+0x3c9>
    0.00 :	   7828c:       48 8b 3d 95 c4 2f 00    mov    0x2fc495(%rip),%rdi        # 374728 <mp_+0x8>
    0.00 :	   78293:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	   78297:       4c 89 ee                mov    %r13,%rsi
    0.00 :	   7829a:       5b                      pop    %rbx
    0.00 :	   7829b:       5d                      pop    %rbp
    0.00 :	   7829c:       41 5c                   pop    %r12
    0.00 :	   7829e:       41 5d                   pop    %r13
    0.00 :	   782a0:       41 5e                   pop    %r14
    0.00 :	   782a2:       41 5f                   pop    %r15
    0.00 :	   782a4:       e9 07 df ff ff          jmpq   761b0 <sYSTRIm>
    0.00 :	   782a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   782b0:       49 8d 3c 2c             lea    (%r12,%rbp,1),%rdi
    0.00 :	   782b4:       ba 04 00 00 00          mov    $0x4,%edx
    0.00 :	   782b9:       48 89 de                mov    %rbx,%rsi
    0.00 :	   782bc:       e8 7f fa 05 00          callq  d7d40 <madvise>
    0.00 :	   782c1:       e9 a0 fd ff ff          jmpq   78066 <_int_free+0x5c6>
    0.00 :	   782c6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	   782cd:       00 00 00 
    0.00 :	   782d0:       48 8d 35 f7 38 0c 00    lea    0xc38f7(%rip),%rsi        # 13bbce <__PRETTY_FUNCTION__.14063+0x167>
    0.00 :	   782d7:       e9 0c fe ff ff          jmpq   780e8 <_int_free+0x648>
    0.00 :	   782dc:       8b 3d 26 9e 2f 00       mov    0x2f9e26(%rip),%edi        # 372108 <check_action>
    0.00 :	   782e2:       48 8d 35 3c 38 0c 00    lea    0xc383c(%rip),%rsi        # 13bb25 <__PRETTY_FUNCTION__.14063+0xbe>
    0.00 :	   782e9:       4c 89 fa                mov    %r15,%rdx
    0.00 :	   782ec:       e8 6f e2 ff ff          callq  76560 <malloc_printerr>
    0.00 :	   782f1:       e9 21 fa ff ff          jmpq   77d17 <_int_free+0x277>
    0.00 :	   782f6:       48 8d 35 73 6e 0c 00    lea    0xc6e73(%rip),%rsi        # 13f170 <__PRETTY_FUNCTION__.11129+0x1797>
    0.00 :	   782fd:       e9 e6 fd ff ff          jmpq   780e8 <_int_free+0x648>
    0.00 :	   78302:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	   78306:       48 8d 35 fb 6e 0c 00    lea    0xc6efb(%rip),%rsi        # 13f208 <__PRETTY_FUNCTION__.11129+0x182f>
    0.00 :	   7830d:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	   78311:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
    0.00 :	   78315:       49 39 c4                cmp    %rax,%r12
    0.00 :	   78318:       0f 82 03 f8 ff ff       jb     77b21 <_int_free+0x81>
    0.00 :	   7831e:       e9 c5 fd ff ff          jmpq   780e8 <_int_free+0x648>
    0.00 :	   78323:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	   78328:       48 8d 55 f0             lea    -0x10(%rbp),%rdx
    0.00 :	   7832c:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	   78330:       0f b6 f0                movzbl %al,%esi
    0.00 :	   78333:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78338:       e8 33 b1 00 00          callq  83470 <__GI_memset>
    0.00 :	   7833d:       48 8b 53 08             mov    0x8(%rbx),%rdx
    0.00 :	   78341:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   78346:       e9 16 f8 ff ff          jmpq   77b61 <_int_free+0xc1>
    0.00 :	   7834b:       48 8d 55 f0             lea    -0x10(%rbp),%rdx
    0.00 :	   7834f:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	   78353:       0f b6 f0                movzbl %al,%esi
    0.00 :	   78356:       e8 15 b1 00 00          callq  83470 <__GI_memset>
    0.00 :	   7835b:       e9 de fa ff ff          jmpq   77e3e <_int_free+0x39e>
    0.00 :	   78360:       8b 3d a2 9d 2f 00       mov    0x2f9da2(%rip),%edi        # 372108 <check_action>
    0.00 :	   78366:       48 8d 35 b8 37 0c 00    lea    0xc37b8(%rip),%rsi        # 13bb25 <__PRETTY_FUNCTION__.14063+0xbe>
    0.00 :	   7836d:       48 89 da                mov    %rbx,%rdx
    0.00 :	   78370:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78375:       e8 e6 e1 ff ff          callq  76560 <malloc_printerr>
    0.00 :	   7837a:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   7837f:       e9 e6 f7 ff ff          jmpq   77b6a <_int_free+0xca>
    0.00 :	   78384:       8b 3d 7e 9d 2f 00       mov    0x2f9d7e(%rip),%edi        # 372108 <check_action>
    0.00 :	   7838a:       48 8d 35 94 37 0c 00    lea    0xc3794(%rip),%rsi        # 13bb25 <__PRETTY_FUNCTION__.14063+0xbe>
    0.00 :	   78391:       4c 89 e2                mov    %r12,%rdx
    0.00 :	   78394:       4c 89 44 24 08          mov    %r8,0x8(%rsp)
    0.00 :	   78399:       e8 c2 e1 ff ff          callq  76560 <malloc_printerr>
    0.00 :	   7839e:       4c 8b 44 24 08          mov    0x8(%rsp),%r8
    0.00 :	   783a3:       e9 10 fb ff ff          jmpq   77eb8 <_int_free+0x418>
    0.00 :	   783a8:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   783ac:       49 39 c7                cmp    %rax,%r15
    0.00 :	   783af:       74 78                   je     78429 <_int_free+0x989>
    0.00 :	   783b1:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	   783b5:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   783b9:       48 89 43 28             mov    %rax,0x28(%rbx)
    0.00 :	   783bd:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   783c1:       48 89 58 28             mov    %rbx,0x28(%rax)
    0.00 :	   783c5:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   783c9:       48 89 58 20             mov    %rbx,0x20(%rax)
    0.00 :	   783cd:       e9 45 f9 ff ff          jmpq   77d17 <_int_free+0x277>
    0.00 :	   783d2:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   783d6:       49 39 c7                cmp    %rax,%r15
    0.00 :	   783d9:       74 5b                   je     78436 <_int_free+0x996>
    0.00 :	   783db:       49 89 46 20             mov    %rax,0x20(%r14)
    0.00 :	   783df:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   783e3:       4c 89 fb                mov    %r15,%rbx
    0.00 :	   783e6:       49 89 46 28             mov    %rax,0x28(%r14)
    0.00 :	   783ea:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   783ee:       4c 89 70 28             mov    %r14,0x28(%rax)
    0.00 :	   783f2:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   783f6:       4c 89 70 20             mov    %r14,0x20(%rax)
    0.00 :	   783fa:       e9 6b f7 ff ff          jmpq   77b6a <_int_free+0xca>
    0.00 :	   783ff:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   78403:       49 39 c7                cmp    %rax,%r15
    0.00 :	   78406:       74 3e                   je     78446 <_int_free+0x9a6>
    0.00 :	   78408:       49 89 46 20             mov    %rax,0x20(%r14)
    0.00 :	   7840c:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   78410:       49 89 46 28             mov    %rax,0x28(%r14)
    0.00 :	   78414:       49 8b 47 20             mov    0x20(%r15),%rax
    0.00 :	   78418:       4c 89 70 28             mov    %r14,0x28(%rax)
    0.00 :	   7841c:       49 8b 47 28             mov    0x28(%r15),%rax
    0.00 :	   78420:       4c 89 70 20             mov    %r14,0x20(%rax)
    0.00 :	   78424:       e9 8f fa ff ff          jmpq   77eb8 <_int_free+0x418>
    0.00 :	   78429:       48 89 5b 28             mov    %rbx,0x28(%rbx)
    0.00 :	   7842d:       48 89 5b 20             mov    %rbx,0x20(%rbx)
    0.00 :	   78431:       e9 e1 f8 ff ff          jmpq   77d17 <_int_free+0x277>
    0.00 :	   78436:       4d 89 76 28             mov    %r14,0x28(%r14)
    0.00 :	   7843a:       4d 89 76 20             mov    %r14,0x20(%r14)
    0.00 :	   7843e:       4c 89 fb                mov    %r15,%rbx
    0.00 :	   78441:       e9 24 f7 ff ff          jmpq   77b6a <_int_free+0xca>
    0.00 :	   78446:       4d 89 76 28             mov    %r14,0x28(%r14)
    0.00 :	   7844a:       4d 89 76 20             mov    %r14,0x20(%r14)
    0.00 :	   7844e:       e9 65 fa ff ff          jmpq   77eb8 <_int_free+0x418>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000083470 <__GI_memset>:
    0.00 :	   83470:       48 83 fa 01             cmp    $0x1,%rdx
    0.00 :	   83474:       48 89 f8                mov    %rdi,%rax
    0.00 :	   83477:       75 04                   jne    8347d <__GI_memset+0xd>
    0.00 :	   83479:       40 88 37                mov    %sil,(%rdi)
    0.00 :	   8347c:       c3                      retq   
    0.00 :	   8347d:       49 b9 01 01 01 01 01    movabs $0x101010101010101,%r9
    0.00 :	   83484:       01 01 01 
    0.00 :	   83487:       49 89 d0                mov    %rdx,%r8
    0.00 :	   8348a:       48 0f b6 d6             movzbq %sil,%rdx
    0.00 :	   8348e:       49 0f af d1             imul   %r9,%rdx
    0.00 :	   83492:       49 81 f8 90 00 00 00    cmp    $0x90,%r8
    0.00 :	   83499:       0f 87 e1 02 00 00       ja     83780 <__GI_memset+0x310>
    0.00 :	   8349f:       4c 01 c7                add    %r8,%rdi
    0.00 :	   834a2:       4c 8d 1d 13 00 00 00    lea    0x13(%rip),%r11        # 834bc <__GI_memset+0x4c>
    0.00 :	   834a9:       48 8d 0d 60 2d 0b 00    lea    0xb2d60(%rip),%rcx        # 136210 <next_state.9261+0x8c>
    0.00 :	   834b0:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   834b5:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   834b9:       41 ff e3                jmpq   *%r11
    0.00 :	   834bc:       c3                      retq   
    0.00 :	   834bd:       0f 1f 00                nopl   (%rax)
    0.00 :	   834c0:       48 89 97 77 ff ff ff    mov    %rdx,-0x89(%rdi)
    0.00 :	   834c7:       48 89 97 7f ff ff ff    mov    %rdx,-0x81(%rdi)
    0.00 :	   834ce:       48 89 57 87             mov    %rdx,-0x79(%rdi)
    0.00 :	   834d2:       48 89 57 8f             mov    %rdx,-0x71(%rdi)
    0.00 :	   834d6:       48 89 57 97             mov    %rdx,-0x69(%rdi)
    0.00 :	   834da:       48 89 57 9f             mov    %rdx,-0x61(%rdi)
    0.00 :	   834de:       48 89 57 a7             mov    %rdx,-0x59(%rdi)
    0.00 :	   834e2:       48 89 57 af             mov    %rdx,-0x51(%rdi)
    0.00 :	   834e6:       48 89 57 b7             mov    %rdx,-0x49(%rdi)
    0.00 :	   834ea:       48 89 57 bf             mov    %rdx,-0x41(%rdi)
    0.00 :	   834ee:       48 89 57 c7             mov    %rdx,-0x39(%rdi)
    0.00 :	   834f2:       48 89 57 cf             mov    %rdx,-0x31(%rdi)
    0.00 :	   834f6:       48 89 57 d7             mov    %rdx,-0x29(%rdi)
    0.00 :	   834fa:       48 89 57 df             mov    %rdx,-0x21(%rdi)
    0.00 :	   834fe:       48 89 57 e7             mov    %rdx,-0x19(%rdi)
    0.00 :	   83502:       48 89 57 ef             mov    %rdx,-0x11(%rdi)
    0.00 :	   83506:       48 89 57 f7             mov    %rdx,-0x9(%rdi)
    0.00 :	   8350a:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   8350d:       c3                      retq   
    0.00 :	   8350e:       66 90                   xchg   %ax,%ax
    0.00 :	   83510:       48 89 97 70 ff ff ff    mov    %rdx,-0x90(%rdi)
    0.00 :	   83517:       48 89 97 78 ff ff ff    mov    %rdx,-0x88(%rdi)
    0.00 :	   8351e:       48 89 57 80             mov    %rdx,-0x80(%rdi)
    0.00 :	   83522:       48 89 57 88             mov    %rdx,-0x78(%rdi)
    0.00 :	   83526:       48 89 57 90             mov    %rdx,-0x70(%rdi)
    0.00 :	   8352a:       48 89 57 98             mov    %rdx,-0x68(%rdi)
    0.00 :	   8352e:       48 89 57 a0             mov    %rdx,-0x60(%rdi)
    0.00 :	   83532:       48 89 57 a8             mov    %rdx,-0x58(%rdi)
    0.00 :	   83536:       48 89 57 b0             mov    %rdx,-0x50(%rdi)
    0.00 :	   8353a:       48 89 57 b8             mov    %rdx,-0x48(%rdi)
    0.00 :	   8353e:       48 89 57 c0             mov    %rdx,-0x40(%rdi)
    0.00 :	   83542:       48 89 57 c8             mov    %rdx,-0x38(%rdi)
    0.00 :	   83546:       48 89 57 d0             mov    %rdx,-0x30(%rdi)
    0.00 :	   8354a:       48 89 57 d8             mov    %rdx,-0x28(%rdi)
    0.00 :	   8354e:       48 89 57 e0             mov    %rdx,-0x20(%rdi)
    0.00 :	   83552:       48 89 57 e8             mov    %rdx,-0x18(%rdi)
    0.00 :	   83556:       48 89 57 f0             mov    %rdx,-0x10(%rdi)
    0.00 :	   8355a:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   8355e:       c3                      retq   
    0.00 :	   8355f:       90                      nop
    0.00 :	   83560:       48 89 97 76 ff ff ff    mov    %rdx,-0x8a(%rdi)
    0.00 :	   83567:       48 89 97 7e ff ff ff    mov    %rdx,-0x82(%rdi)
    0.00 :	   8356e:       48 89 57 86             mov    %rdx,-0x7a(%rdi)
    0.00 :	   83572:       48 89 57 8e             mov    %rdx,-0x72(%rdi)
    0.00 :	   83576:       48 89 57 96             mov    %rdx,-0x6a(%rdi)
    0.00 :	   8357a:       48 89 57 9e             mov    %rdx,-0x62(%rdi)
    0.00 :	   8357e:       48 89 57 a6             mov    %rdx,-0x5a(%rdi)
    0.00 :	   83582:       48 89 57 ae             mov    %rdx,-0x52(%rdi)
    0.00 :	   83586:       48 89 57 b6             mov    %rdx,-0x4a(%rdi)
    0.00 :	   8358a:       48 89 57 be             mov    %rdx,-0x42(%rdi)
    0.00 :	   8358e:       48 89 57 c6             mov    %rdx,-0x3a(%rdi)
    0.00 :	   83592:       48 89 57 ce             mov    %rdx,-0x32(%rdi)
    0.00 :	   83596:       48 89 57 d6             mov    %rdx,-0x2a(%rdi)
    0.00 :	   8359a:       48 89 57 de             mov    %rdx,-0x22(%rdi)
    0.00 :	   8359e:       48 89 57 e6             mov    %rdx,-0x1a(%rdi)
    0.00 :	   835a2:       48 89 57 ee             mov    %rdx,-0x12(%rdi)
    0.00 :	   835a6:       48 89 57 f6             mov    %rdx,-0xa(%rdi)
    0.00 :	   835aa:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   835ae:       c3                      retq   
    0.00 :	   835af:       90                      nop
    0.00 :	   835b0:       48 89 97 75 ff ff ff    mov    %rdx,-0x8b(%rdi)
    0.00 :	   835b7:       48 89 97 7d ff ff ff    mov    %rdx,-0x83(%rdi)
    0.00 :	   835be:       48 89 57 85             mov    %rdx,-0x7b(%rdi)
    0.00 :	   835c2:       48 89 57 8d             mov    %rdx,-0x73(%rdi)
    0.00 :	   835c6:       48 89 57 95             mov    %rdx,-0x6b(%rdi)
    0.00 :	   835ca:       48 89 57 9d             mov    %rdx,-0x63(%rdi)
    0.00 :	   835ce:       48 89 57 a5             mov    %rdx,-0x5b(%rdi)
    0.00 :	   835d2:       48 89 57 ad             mov    %rdx,-0x53(%rdi)
    0.00 :	   835d6:       48 89 57 b5             mov    %rdx,-0x4b(%rdi)
    0.00 :	   835da:       48 89 57 bd             mov    %rdx,-0x43(%rdi)
    0.00 :	   835de:       48 89 57 c5             mov    %rdx,-0x3b(%rdi)
    0.00 :	   835e2:       48 89 57 cd             mov    %rdx,-0x33(%rdi)
    0.00 :	   835e6:       48 89 57 d5             mov    %rdx,-0x2b(%rdi)
    0.00 :	   835ea:       48 89 57 dd             mov    %rdx,-0x23(%rdi)
    0.00 :	   835ee:       48 89 57 e5             mov    %rdx,-0x1b(%rdi)
    0.00 :	   835f2:       48 89 57 ed             mov    %rdx,-0x13(%rdi)
    0.00 :	   835f6:       48 89 57 f5             mov    %rdx,-0xb(%rdi)
    0.00 :	   835fa:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   835fe:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83601:       c3                      retq   
    0.00 :	   83602:       66 66 66 66 66 2e 0f    data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   83609:       1f 84 00 00 00 00 00 
    0.00 :	   83610:       48 89 97 74 ff ff ff    mov    %rdx,-0x8c(%rdi)
    0.00 :	   83617:       48 89 97 7c ff ff ff    mov    %rdx,-0x84(%rdi)
    0.00 :	   8361e:       48 89 57 84             mov    %rdx,-0x7c(%rdi)
    0.00 :	   83622:       48 89 57 8c             mov    %rdx,-0x74(%rdi)
    0.00 :	   83626:       48 89 57 94             mov    %rdx,-0x6c(%rdi)
    0.00 :	   8362a:       48 89 57 9c             mov    %rdx,-0x64(%rdi)
    0.00 :	   8362e:       48 89 57 a4             mov    %rdx,-0x5c(%rdi)
    0.00 :	   83632:       48 89 57 ac             mov    %rdx,-0x54(%rdi)
    0.00 :	   83636:       48 89 57 b4             mov    %rdx,-0x4c(%rdi)
    0.00 :	   8363a:       48 89 57 bc             mov    %rdx,-0x44(%rdi)
    0.00 :	   8363e:       48 89 57 c4             mov    %rdx,-0x3c(%rdi)
    0.00 :	   83642:       48 89 57 cc             mov    %rdx,-0x34(%rdi)
 ??:0
  100.00 :	   83646:       48 89 57 d4             mov    %rdx,-0x2c(%rdi)
    0.00 :	   8364a:       48 89 57 dc             mov    %rdx,-0x24(%rdi)
    0.00 :	   8364e:       48 89 57 e4             mov    %rdx,-0x1c(%rdi)
    0.00 :	   83652:       48 89 57 ec             mov    %rdx,-0x14(%rdi)
    0.00 :	   83656:       48 89 57 f4             mov    %rdx,-0xc(%rdi)
    0.00 :	   8365a:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	   8365d:       c3                      retq   
    0.00 :	   8365e:       66 90                   xchg   %ax,%ax
    0.00 :	   83660:       48 89 97 73 ff ff ff    mov    %rdx,-0x8d(%rdi)
    0.00 :	   83667:       48 89 97 7b ff ff ff    mov    %rdx,-0x85(%rdi)
    0.00 :	   8366e:       48 89 57 83             mov    %rdx,-0x7d(%rdi)
    0.00 :	   83672:       48 89 57 8b             mov    %rdx,-0x75(%rdi)
    0.00 :	   83676:       48 89 57 93             mov    %rdx,-0x6d(%rdi)
    0.00 :	   8367a:       48 89 57 9b             mov    %rdx,-0x65(%rdi)
    0.00 :	   8367e:       48 89 57 a3             mov    %rdx,-0x5d(%rdi)
    0.00 :	   83682:       48 89 57 ab             mov    %rdx,-0x55(%rdi)
    0.00 :	   83686:       48 89 57 b3             mov    %rdx,-0x4d(%rdi)
    0.00 :	   8368a:       48 89 57 bb             mov    %rdx,-0x45(%rdi)
    0.00 :	   8368e:       48 89 57 c3             mov    %rdx,-0x3d(%rdi)
    0.00 :	   83692:       48 89 57 cb             mov    %rdx,-0x35(%rdi)
    0.00 :	   83696:       48 89 57 d3             mov    %rdx,-0x2d(%rdi)
    0.00 :	   8369a:       48 89 57 db             mov    %rdx,-0x25(%rdi)
    0.00 :	   8369e:       48 89 57 e3             mov    %rdx,-0x1d(%rdi)
    0.00 :	   836a2:       48 89 57 eb             mov    %rdx,-0x15(%rdi)
    0.00 :	   836a6:       48 89 57 f3             mov    %rdx,-0xd(%rdi)
    0.00 :	   836aa:       89 57 fb                mov    %edx,-0x5(%rdi)
    0.00 :	   836ad:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   836b0:       c3                      retq   
    0.00 :	   836b1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   836b8:       0f 1f 84 00 00 00 00 
    0.00 :	   836bf:       00 
    0.00 :	   836c0:       48 89 97 72 ff ff ff    mov    %rdx,-0x8e(%rdi)
    0.00 :	   836c7:       48 89 97 7a ff ff ff    mov    %rdx,-0x86(%rdi)
    0.00 :	   836ce:       48 89 57 82             mov    %rdx,-0x7e(%rdi)
    0.00 :	   836d2:       48 89 57 8a             mov    %rdx,-0x76(%rdi)
    0.00 :	   836d6:       48 89 57 92             mov    %rdx,-0x6e(%rdi)
    0.00 :	   836da:       48 89 57 9a             mov    %rdx,-0x66(%rdi)
    0.00 :	   836de:       48 89 57 a2             mov    %rdx,-0x5e(%rdi)
    0.00 :	   836e2:       48 89 57 aa             mov    %rdx,-0x56(%rdi)
    0.00 :	   836e6:       48 89 57 b2             mov    %rdx,-0x4e(%rdi)
    0.00 :	   836ea:       48 89 57 ba             mov    %rdx,-0x46(%rdi)
    0.00 :	   836ee:       48 89 57 c2             mov    %rdx,-0x3e(%rdi)
    0.00 :	   836f2:       48 89 57 ca             mov    %rdx,-0x36(%rdi)
    0.00 :	   836f6:       48 89 57 d2             mov    %rdx,-0x2e(%rdi)
    0.00 :	   836fa:       48 89 57 da             mov    %rdx,-0x26(%rdi)
    0.00 :	   836fe:       48 89 57 e2             mov    %rdx,-0x1e(%rdi)
    0.00 :	   83702:       48 89 57 ea             mov    %rdx,-0x16(%rdi)
    0.00 :	   83706:       48 89 57 f2             mov    %rdx,-0xe(%rdi)
    0.00 :	   8370a:       89 57 fa                mov    %edx,-0x6(%rdi)
    0.00 :	   8370d:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   83711:       c3                      retq   
    0.00 :	   83712:       66 66 66 66 66 2e 0f    data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   83719:       1f 84 00 00 00 00 00 
    0.00 :	   83720:       48 89 97 71 ff ff ff    mov    %rdx,-0x8f(%rdi)
    0.00 :	   83727:       48 89 97 79 ff ff ff    mov    %rdx,-0x87(%rdi)
    0.00 :	   8372e:       48 89 57 81             mov    %rdx,-0x7f(%rdi)
    0.00 :	   83732:       48 89 57 89             mov    %rdx,-0x77(%rdi)
    0.00 :	   83736:       48 89 57 91             mov    %rdx,-0x6f(%rdi)
    0.00 :	   8373a:       48 89 57 99             mov    %rdx,-0x67(%rdi)
    0.00 :	   8373e:       48 89 57 a1             mov    %rdx,-0x5f(%rdi)
    0.00 :	   83742:       48 89 57 a9             mov    %rdx,-0x57(%rdi)
    0.00 :	   83746:       48 89 57 b1             mov    %rdx,-0x4f(%rdi)
    0.00 :	   8374a:       48 89 57 b9             mov    %rdx,-0x47(%rdi)
    0.00 :	   8374e:       48 89 57 c1             mov    %rdx,-0x3f(%rdi)
    0.00 :	   83752:       48 89 57 c9             mov    %rdx,-0x37(%rdi)
    0.00 :	   83756:       48 89 57 d1             mov    %rdx,-0x2f(%rdi)
    0.00 :	   8375a:       48 89 57 d9             mov    %rdx,-0x27(%rdi)
    0.00 :	   8375e:       48 89 57 e1             mov    %rdx,-0x1f(%rdi)
    0.00 :	   83762:       48 89 57 e9             mov    %rdx,-0x17(%rdi)
    0.00 :	   83766:       48 89 57 f1             mov    %rdx,-0xf(%rdi)
    0.00 :	   8376a:       89 57 f9                mov    %edx,-0x7(%rdi)
    0.00 :	   8376d:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   83771:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83774:       c3                      retq   
    0.00 :	   83775:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   8377c:       00 00 00 00 
    0.00 :	   83780:       49 c7 c2 10 00 00 00    mov    $0x10,%r10
    0.00 :	   83787:       49 89 f9                mov    %rdi,%r9
    0.00 :	   8378a:       49 83 e1 0f             and    $0xf,%r9
    0.00 :	   8378e:       4d 29 ca                sub    %r9,%r10
    0.00 :	   83791:       49 83 e2 0f             and    $0xf,%r10
    0.00 :	   83795:       4c 01 d7                add    %r10,%rdi
    0.00 :	   83798:       4d 29 d0                sub    %r10,%r8
    0.00 :	   8379b:       4c 8d 1d 98 00 00 00    lea    0x98(%rip),%r11        # 8383a <__GI_memset+0x3ca>
    0.00 :	   837a2:       48 8d 0d 97 2b 0b 00    lea    0xb2b97(%rip),%rcx        # 136340 <next_state.9261+0x1bc>
    0.00 :	   837a9:       4a 0f bf 0c 51          movswq (%rcx,%r10,2),%rcx
    0.00 :	   837ae:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   837b2:       41 ff e3                jmpq   *%r11
    0.00 :	   837b5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   837bc:       00 00 00 00 
    0.00 :	   837c0:       88 57 f3                mov    %dl,-0xd(%rdi)
    0.00 :	   837c3:       89 57 f4                mov    %edx,-0xc(%rdi)
    0.00 :	   837c6:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   837ca:       eb 6e                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   837cc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   837d0:       88 57 f7                mov    %dl,-0x9(%rdi)
    0.00 :	   837d3:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   837d7:       eb 61                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   837d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   837e0:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   837e3:       eb 55                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   837e5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   837ec:       00 00 00 00 
    0.00 :	   837f0:       88 57 f5                mov    %dl,-0xb(%rdi)
    0.00 :	   837f3:       66 89 57 f6             mov    %dx,-0xa(%rdi)
    0.00 :	   837f7:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   837fb:       eb 3d                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   837fd:       0f 1f 00                nopl   (%rax)
    0.00 :	   83800:       88 57 fd                mov    %dl,-0x3(%rdi)
    0.00 :	   83803:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   83807:       eb 31                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   83809:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   83810:       88 57 fb                mov    %dl,-0x5(%rdi)
    0.00 :	   83813:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	   83816:       eb 22                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   83818:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	   8381f:       00 
    0.00 :	   83820:       88 57 f1                mov    %dl,-0xf(%rdi)
    0.00 :	   83823:       66 89 57 f2             mov    %dx,-0xe(%rdi)
    0.00 :	   83827:       89 57 f4                mov    %edx,-0xc(%rdi)
    0.00 :	   8382a:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   8382e:       eb 0a                   jmp    8383a <__GI_memset+0x3ca>
    0.00 :	   83830:       88 57 f9                mov    %dl,-0x7(%rdi)
    0.00 :	   83833:       66 89 57 fa             mov    %dx,-0x6(%rdi)
    0.00 :	   83837:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	   8383a:       66 48 0f 6e c2          movq   %rdx,%xmm0
    0.00 :	   8383f:       66 0f 6c c0             punpcklqdq %xmm0,%xmm0
    0.00 :	   83843:       49 81 f8 b0 00 00 00    cmp    $0xb0,%r8
    0.00 :	   8384a:       0f 83 d0 04 00 00       jae    83d20 <__GI_memset+0x8b0>
    0.00 :	   83850:       4c 01 c7                add    %r8,%rdi
    0.00 :	   83853:       4c 8d 0d 53 00 00 00    lea    0x53(%rip),%r9        # 838ad <__GI_memset+0x43d>
    0.00 :	   8385a:       48 8d 0d ff 2a 0b 00    lea    0xb2aff(%rip),%rcx        # 136360 <next_state.9261+0x1dc>
    0.00 :	   83861:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83866:       4e 8d 0c 09             lea    (%rcx,%r9,1),%r9
    0.00 :	   8386a:       41 ff e1                jmpq   *%r9
    0.00 :	   8386d:       66 0f 7f 87 50 ff ff    movdqa %xmm0,-0xb0(%rdi)
    0.00 :	   83874:       ff 
    0.00 :	   83875:       66 0f 7f 87 60 ff ff    movdqa %xmm0,-0xa0(%rdi)
    0.00 :	   8387c:       ff 
    0.00 :	   8387d:       66 0f 7f 87 70 ff ff    movdqa %xmm0,-0x90(%rdi)
    0.00 :	   83884:       ff 
    0.00 :	   83885:       66 0f 7f 47 80          movdqa %xmm0,-0x80(%rdi)
    0.00 :	   8388a:       66 0f 7f 47 90          movdqa %xmm0,-0x70(%rdi)
    0.00 :	   8388f:       66 0f 7f 47 a0          movdqa %xmm0,-0x60(%rdi)
    0.00 :	   83894:       66 0f 7f 47 b0          movdqa %xmm0,-0x50(%rdi)
    0.00 :	   83899:       66 0f 7f 47 c0          movdqa %xmm0,-0x40(%rdi)
    0.00 :	   8389e:       66 0f 7f 47 d0          movdqa %xmm0,-0x30(%rdi)
    0.00 :	   838a3:       66 0f 7f 47 e0          movdqa %xmm0,-0x20(%rdi)
    0.00 :	   838a8:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	   838ad:       c3                      retq   
    0.00 :	   838ae:       66 0f 7f 87 4f ff ff    movdqa %xmm0,-0xb1(%rdi)
    0.00 :	   838b5:       ff 
    0.00 :	   838b6:       66 0f 7f 87 5f ff ff    movdqa %xmm0,-0xa1(%rdi)
    0.00 :	   838bd:       ff 
    0.00 :	   838be:       66 0f 7f 87 6f ff ff    movdqa %xmm0,-0x91(%rdi)
    0.00 :	   838c5:       ff 
    0.00 :	   838c6:       66 0f 7f 87 7f ff ff    movdqa %xmm0,-0x81(%rdi)
    0.00 :	   838cd:       ff 
    0.00 :	   838ce:       66 0f 7f 47 8f          movdqa %xmm0,-0x71(%rdi)
    0.00 :	   838d3:       66 0f 7f 47 9f          movdqa %xmm0,-0x61(%rdi)
    0.00 :	   838d8:       66 0f 7f 47 af          movdqa %xmm0,-0x51(%rdi)
    0.00 :	   838dd:       66 0f 7f 47 bf          movdqa %xmm0,-0x41(%rdi)
    0.00 :	   838e2:       66 0f 7f 47 cf          movdqa %xmm0,-0x31(%rdi)
    0.00 :	   838e7:       66 0f 7f 47 df          movdqa %xmm0,-0x21(%rdi)
    0.00 :	   838ec:       66 0f 7f 47 ef          movdqa %xmm0,-0x11(%rdi)
    0.00 :	   838f1:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   838f4:       c3                      retq   
    0.00 :	   838f5:       66 0f 7f 87 4e ff ff    movdqa %xmm0,-0xb2(%rdi)
    0.00 :	   838fc:       ff 
    0.00 :	   838fd:       66 0f 7f 87 5e ff ff    movdqa %xmm0,-0xa2(%rdi)
    0.00 :	   83904:       ff 
    0.00 :	   83905:       66 0f 7f 87 6e ff ff    movdqa %xmm0,-0x92(%rdi)
    0.00 :	   8390c:       ff 
    0.00 :	   8390d:       66 0f 7f 87 7e ff ff    movdqa %xmm0,-0x82(%rdi)
    0.00 :	   83914:       ff 
    0.00 :	   83915:       66 0f 7f 47 8e          movdqa %xmm0,-0x72(%rdi)
    0.00 :	   8391a:       66 0f 7f 47 9e          movdqa %xmm0,-0x62(%rdi)
    0.00 :	   8391f:       66 0f 7f 47 ae          movdqa %xmm0,-0x52(%rdi)
    0.00 :	   83924:       66 0f 7f 47 be          movdqa %xmm0,-0x42(%rdi)
    0.00 :	   83929:       66 0f 7f 47 ce          movdqa %xmm0,-0x32(%rdi)
    0.00 :	   8392e:       66 0f 7f 47 de          movdqa %xmm0,-0x22(%rdi)
    0.00 :	   83933:       66 0f 7f 47 ee          movdqa %xmm0,-0x12(%rdi)
    0.00 :	   83938:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   8393c:       c3                      retq   
    0.00 :	   8393d:       66 0f 7f 87 4d ff ff    movdqa %xmm0,-0xb3(%rdi)
    0.00 :	   83944:       ff 
    0.00 :	   83945:       66 0f 7f 87 5d ff ff    movdqa %xmm0,-0xa3(%rdi)
    0.00 :	   8394c:       ff 
    0.00 :	   8394d:       66 0f 7f 87 6d ff ff    movdqa %xmm0,-0x93(%rdi)
    0.00 :	   83954:       ff 
    0.00 :	   83955:       66 0f 7f 87 7d ff ff    movdqa %xmm0,-0x83(%rdi)
    0.00 :	   8395c:       ff 
    0.00 :	   8395d:       66 0f 7f 47 8d          movdqa %xmm0,-0x73(%rdi)
    0.00 :	   83962:       66 0f 7f 47 9d          movdqa %xmm0,-0x63(%rdi)
    0.00 :	   83967:       66 0f 7f 47 ad          movdqa %xmm0,-0x53(%rdi)
    0.00 :	   8396c:       66 0f 7f 47 bd          movdqa %xmm0,-0x43(%rdi)
    0.00 :	   83971:       66 0f 7f 47 cd          movdqa %xmm0,-0x33(%rdi)
    0.00 :	   83976:       66 0f 7f 47 dd          movdqa %xmm0,-0x23(%rdi)
    0.00 :	   8397b:       66 0f 7f 47 ed          movdqa %xmm0,-0x13(%rdi)
    0.00 :	   83980:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   83984:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83987:       c3                      retq   
    0.00 :	   83988:       66 0f 7f 87 4c ff ff    movdqa %xmm0,-0xb4(%rdi)
    0.00 :	   8398f:       ff 
    0.00 :	   83990:       66 0f 7f 87 5c ff ff    movdqa %xmm0,-0xa4(%rdi)
    0.00 :	   83997:       ff 
    0.00 :	   83998:       66 0f 7f 87 6c ff ff    movdqa %xmm0,-0x94(%rdi)
    0.00 :	   8399f:       ff 
    0.00 :	   839a0:       66 0f 7f 87 7c ff ff    movdqa %xmm0,-0x84(%rdi)
    0.00 :	   839a7:       ff 
    0.00 :	   839a8:       66 0f 7f 47 8c          movdqa %xmm0,-0x74(%rdi)
    0.00 :	   839ad:       66 0f 7f 47 9c          movdqa %xmm0,-0x64(%rdi)
    0.00 :	   839b2:       66 0f 7f 47 ac          movdqa %xmm0,-0x54(%rdi)
    0.00 :	   839b7:       66 0f 7f 47 bc          movdqa %xmm0,-0x44(%rdi)
    0.00 :	   839bc:       66 0f 7f 47 cc          movdqa %xmm0,-0x34(%rdi)
    0.00 :	   839c1:       66 0f 7f 47 dc          movdqa %xmm0,-0x24(%rdi)
    0.00 :	   839c6:       66 0f 7f 47 ec          movdqa %xmm0,-0x14(%rdi)
    0.00 :	   839cb:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	   839ce:       c3                      retq   
    0.00 :	   839cf:       66 0f 7f 87 4b ff ff    movdqa %xmm0,-0xb5(%rdi)
    0.00 :	   839d6:       ff 
    0.00 :	   839d7:       66 0f 7f 87 5b ff ff    movdqa %xmm0,-0xa5(%rdi)
    0.00 :	   839de:       ff 
    0.00 :	   839df:       66 0f 7f 87 6b ff ff    movdqa %xmm0,-0x95(%rdi)
    0.00 :	   839e6:       ff 
    0.00 :	   839e7:       66 0f 7f 87 7b ff ff    movdqa %xmm0,-0x85(%rdi)
    0.00 :	   839ee:       ff 
    0.00 :	   839ef:       66 0f 7f 47 8b          movdqa %xmm0,-0x75(%rdi)
    0.00 :	   839f4:       66 0f 7f 47 9b          movdqa %xmm0,-0x65(%rdi)
    0.00 :	   839f9:       66 0f 7f 47 ab          movdqa %xmm0,-0x55(%rdi)
    0.00 :	   839fe:       66 0f 7f 47 bb          movdqa %xmm0,-0x45(%rdi)
    0.00 :	   83a03:       66 0f 7f 47 cb          movdqa %xmm0,-0x35(%rdi)
    0.00 :	   83a08:       66 0f 7f 47 db          movdqa %xmm0,-0x25(%rdi)
    0.00 :	   83a0d:       66 0f 7f 47 eb          movdqa %xmm0,-0x15(%rdi)
    0.00 :	   83a12:       89 57 fb                mov    %edx,-0x5(%rdi)
    0.00 :	   83a15:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83a18:       c3                      retq   
    0.00 :	   83a19:       66 0f 7f 87 4a ff ff    movdqa %xmm0,-0xb6(%rdi)
    0.00 :	   83a20:       ff 
    0.00 :	   83a21:       66 0f 7f 87 5a ff ff    movdqa %xmm0,-0xa6(%rdi)
    0.00 :	   83a28:       ff 
    0.00 :	   83a29:       66 0f 7f 87 6a ff ff    movdqa %xmm0,-0x96(%rdi)
    0.00 :	   83a30:       ff 
    0.00 :	   83a31:       66 0f 7f 87 7a ff ff    movdqa %xmm0,-0x86(%rdi)
    0.00 :	   83a38:       ff 
    0.00 :	   83a39:       66 0f 7f 47 8a          movdqa %xmm0,-0x76(%rdi)
    0.00 :	   83a3e:       66 0f 7f 47 9a          movdqa %xmm0,-0x66(%rdi)
    0.00 :	   83a43:       66 0f 7f 47 aa          movdqa %xmm0,-0x56(%rdi)
    0.00 :	   83a48:       66 0f 7f 47 ba          movdqa %xmm0,-0x46(%rdi)
    0.00 :	   83a4d:       66 0f 7f 47 ca          movdqa %xmm0,-0x36(%rdi)
    0.00 :	   83a52:       66 0f 7f 47 da          movdqa %xmm0,-0x26(%rdi)
    0.00 :	   83a57:       66 0f 7f 47 ea          movdqa %xmm0,-0x16(%rdi)
    0.00 :	   83a5c:       89 57 fa                mov    %edx,-0x6(%rdi)
    0.00 :	   83a5f:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   83a63:       c3                      retq   
    0.00 :	   83a64:       66 0f 7f 87 49 ff ff    movdqa %xmm0,-0xb7(%rdi)
    0.00 :	   83a6b:       ff 
    0.00 :	   83a6c:       66 0f 7f 87 59 ff ff    movdqa %xmm0,-0xa7(%rdi)
    0.00 :	   83a73:       ff 
    0.00 :	   83a74:       66 0f 7f 87 69 ff ff    movdqa %xmm0,-0x97(%rdi)
    0.00 :	   83a7b:       ff 
    0.00 :	   83a7c:       66 0f 7f 87 79 ff ff    movdqa %xmm0,-0x87(%rdi)
    0.00 :	   83a83:       ff 
    0.00 :	   83a84:       66 0f 7f 47 89          movdqa %xmm0,-0x77(%rdi)
    0.00 :	   83a89:       66 0f 7f 47 99          movdqa %xmm0,-0x67(%rdi)
    0.00 :	   83a8e:       66 0f 7f 47 a9          movdqa %xmm0,-0x57(%rdi)
    0.00 :	   83a93:       66 0f 7f 47 b9          movdqa %xmm0,-0x47(%rdi)
    0.00 :	   83a98:       66 0f 7f 47 c9          movdqa %xmm0,-0x37(%rdi)
    0.00 :	   83a9d:       66 0f 7f 47 d9          movdqa %xmm0,-0x27(%rdi)
    0.00 :	   83aa2:       66 0f 7f 47 e9          movdqa %xmm0,-0x17(%rdi)
    0.00 :	   83aa7:       89 57 f9                mov    %edx,-0x7(%rdi)
    0.00 :	   83aaa:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   83aae:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83ab1:       c3                      retq   
    0.00 :	   83ab2:       66 0f 7f 87 48 ff ff    movdqa %xmm0,-0xb8(%rdi)
    0.00 :	   83ab9:       ff 
    0.00 :	   83aba:       66 0f 7f 87 58 ff ff    movdqa %xmm0,-0xa8(%rdi)
    0.00 :	   83ac1:       ff 
    0.00 :	   83ac2:       66 0f 7f 87 68 ff ff    movdqa %xmm0,-0x98(%rdi)
    0.00 :	   83ac9:       ff 
    0.00 :	   83aca:       66 0f 7f 87 78 ff ff    movdqa %xmm0,-0x88(%rdi)
    0.00 :	   83ad1:       ff 
    0.00 :	   83ad2:       66 0f 7f 47 88          movdqa %xmm0,-0x78(%rdi)
    0.00 :	   83ad7:       66 0f 7f 47 98          movdqa %xmm0,-0x68(%rdi)
    0.00 :	   83adc:       66 0f 7f 47 a8          movdqa %xmm0,-0x58(%rdi)
    0.00 :	   83ae1:       66 0f 7f 47 b8          movdqa %xmm0,-0x48(%rdi)
    0.00 :	   83ae6:       66 0f 7f 47 c8          movdqa %xmm0,-0x38(%rdi)
    0.00 :	   83aeb:       66 0f 7f 47 d8          movdqa %xmm0,-0x28(%rdi)
    0.00 :	   83af0:       66 0f 7f 47 e8          movdqa %xmm0,-0x18(%rdi)
    0.00 :	   83af5:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	   83af9:       c3                      retq   
    0.00 :	   83afa:       66 0f 7f 87 47 ff ff    movdqa %xmm0,-0xb9(%rdi)
    0.00 :	   83b01:       ff 
    0.00 :	   83b02:       66 0f 7f 87 57 ff ff    movdqa %xmm0,-0xa9(%rdi)
    0.00 :	   83b09:       ff 
    0.00 :	   83b0a:       66 0f 7f 87 67 ff ff    movdqa %xmm0,-0x99(%rdi)
    0.00 :	   83b11:       ff 
    0.00 :	   83b12:       66 0f 7f 87 77 ff ff    movdqa %xmm0,-0x89(%rdi)
    0.00 :	   83b19:       ff 
    0.00 :	   83b1a:       66 0f 7f 47 87          movdqa %xmm0,-0x79(%rdi)
    0.00 :	   83b1f:       66 0f 7f 47 97          movdqa %xmm0,-0x69(%rdi)
    0.00 :	   83b24:       66 0f 7f 47 a7          movdqa %xmm0,-0x59(%rdi)
    0.00 :	   83b29:       66 0f 7f 47 b7          movdqa %xmm0,-0x49(%rdi)
    0.00 :	   83b2e:       66 0f 7f 47 c7          movdqa %xmm0,-0x39(%rdi)
    0.00 :	   83b33:       66 0f 7f 47 d7          movdqa %xmm0,-0x29(%rdi)
    0.00 :	   83b38:       66 0f 7f 47 e7          movdqa %xmm0,-0x19(%rdi)
    0.00 :	   83b3d:       48 89 57 f7             mov    %rdx,-0x9(%rdi)
    0.00 :	   83b41:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83b44:       c3                      retq   
    0.00 :	   83b45:       66 0f 7f 87 46 ff ff    movdqa %xmm0,-0xba(%rdi)
    0.00 :	   83b4c:       ff 
    0.00 :	   83b4d:       66 0f 7f 87 56 ff ff    movdqa %xmm0,-0xaa(%rdi)
    0.00 :	   83b54:       ff 
    0.00 :	   83b55:       66 0f 7f 87 66 ff ff    movdqa %xmm0,-0x9a(%rdi)
    0.00 :	   83b5c:       ff 
    0.00 :	   83b5d:       66 0f 7f 87 76 ff ff    movdqa %xmm0,-0x8a(%rdi)
    0.00 :	   83b64:       ff 
    0.00 :	   83b65:       66 0f 7f 47 86          movdqa %xmm0,-0x7a(%rdi)
    0.00 :	   83b6a:       66 0f 7f 47 96          movdqa %xmm0,-0x6a(%rdi)
    0.00 :	   83b6f:       66 0f 7f 47 a6          movdqa %xmm0,-0x5a(%rdi)
    0.00 :	   83b74:       66 0f 7f 47 b6          movdqa %xmm0,-0x4a(%rdi)
    0.00 :	   83b79:       66 0f 7f 47 c6          movdqa %xmm0,-0x3a(%rdi)
    0.00 :	   83b7e:       66 0f 7f 47 d6          movdqa %xmm0,-0x2a(%rdi)
    0.00 :	   83b83:       66 0f 7f 47 e6          movdqa %xmm0,-0x1a(%rdi)
    0.00 :	   83b88:       48 89 57 f6             mov    %rdx,-0xa(%rdi)
    0.00 :	   83b8c:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   83b90:       c3                      retq   
    0.00 :	   83b91:       66 0f 7f 87 45 ff ff    movdqa %xmm0,-0xbb(%rdi)
    0.00 :	   83b98:       ff 
    0.00 :	   83b99:       66 0f 7f 87 55 ff ff    movdqa %xmm0,-0xab(%rdi)
    0.00 :	   83ba0:       ff 
    0.00 :	   83ba1:       66 0f 7f 87 65 ff ff    movdqa %xmm0,-0x9b(%rdi)
    0.00 :	   83ba8:       ff 
    0.00 :	   83ba9:       66 0f 7f 87 75 ff ff    movdqa %xmm0,-0x8b(%rdi)
    0.00 :	   83bb0:       ff 
    0.00 :	   83bb1:       66 0f 7f 47 85          movdqa %xmm0,-0x7b(%rdi)
    0.00 :	   83bb6:       66 0f 7f 47 95          movdqa %xmm0,-0x6b(%rdi)
    0.00 :	   83bbb:       66 0f 7f 47 a5          movdqa %xmm0,-0x5b(%rdi)
    0.00 :	   83bc0:       66 0f 7f 47 b5          movdqa %xmm0,-0x4b(%rdi)
    0.00 :	   83bc5:       66 0f 7f 47 c5          movdqa %xmm0,-0x3b(%rdi)
    0.00 :	   83bca:       66 0f 7f 47 d5          movdqa %xmm0,-0x2b(%rdi)
    0.00 :	   83bcf:       66 0f 7f 47 e5          movdqa %xmm0,-0x1b(%rdi)
    0.00 :	   83bd4:       48 89 57 f5             mov    %rdx,-0xb(%rdi)
    0.00 :	   83bd8:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   83bdc:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83bdf:       c3                      retq   
    0.00 :	   83be0:       66 0f 7f 87 44 ff ff    movdqa %xmm0,-0xbc(%rdi)
    0.00 :	   83be7:       ff 
    0.00 :	   83be8:       66 0f 7f 87 54 ff ff    movdqa %xmm0,-0xac(%rdi)
    0.00 :	   83bef:       ff 
    0.00 :	   83bf0:       66 0f 7f 87 64 ff ff    movdqa %xmm0,-0x9c(%rdi)
    0.00 :	   83bf7:       ff 
    0.00 :	   83bf8:       66 0f 7f 87 74 ff ff    movdqa %xmm0,-0x8c(%rdi)
    0.00 :	   83bff:       ff 
    0.00 :	   83c00:       66 0f 7f 47 84          movdqa %xmm0,-0x7c(%rdi)
    0.00 :	   83c05:       66 0f 7f 47 94          movdqa %xmm0,-0x6c(%rdi)
    0.00 :	   83c0a:       66 0f 7f 47 a4          movdqa %xmm0,-0x5c(%rdi)
    0.00 :	   83c0f:       66 0f 7f 47 b4          movdqa %xmm0,-0x4c(%rdi)
    0.00 :	   83c14:       66 0f 7f 47 c4          movdqa %xmm0,-0x3c(%rdi)
    0.00 :	   83c19:       66 0f 7f 47 d4          movdqa %xmm0,-0x2c(%rdi)
    0.00 :	   83c1e:       66 0f 7f 47 e4          movdqa %xmm0,-0x1c(%rdi)
    0.00 :	   83c23:       48 89 57 f4             mov    %rdx,-0xc(%rdi)
    0.00 :	   83c27:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	   83c2a:       c3                      retq   
    0.00 :	   83c2b:       66 0f 7f 87 43 ff ff    movdqa %xmm0,-0xbd(%rdi)
    0.00 :	   83c32:       ff 
    0.00 :	   83c33:       66 0f 7f 87 53 ff ff    movdqa %xmm0,-0xad(%rdi)
    0.00 :	   83c3a:       ff 
    0.00 :	   83c3b:       66 0f 7f 87 63 ff ff    movdqa %xmm0,-0x9d(%rdi)
    0.00 :	   83c42:       ff 
    0.00 :	   83c43:       66 0f 7f 87 73 ff ff    movdqa %xmm0,-0x8d(%rdi)
    0.00 :	   83c4a:       ff 
    0.00 :	   83c4b:       66 0f 7f 47 83          movdqa %xmm0,-0x7d(%rdi)
    0.00 :	   83c50:       66 0f 7f 47 93          movdqa %xmm0,-0x6d(%rdi)
    0.00 :	   83c55:       66 0f 7f 47 a3          movdqa %xmm0,-0x5d(%rdi)
    0.00 :	   83c5a:       66 0f 7f 47 b3          movdqa %xmm0,-0x4d(%rdi)
    0.00 :	   83c5f:       66 0f 7f 47 c3          movdqa %xmm0,-0x3d(%rdi)
    0.00 :	   83c64:       66 0f 7f 47 d3          movdqa %xmm0,-0x2d(%rdi)
    0.00 :	   83c69:       66 0f 7f 47 e3          movdqa %xmm0,-0x1d(%rdi)
    0.00 :	   83c6e:       48 89 57 f3             mov    %rdx,-0xd(%rdi)
    0.00 :	   83c72:       89 57 fb                mov    %edx,-0x5(%rdi)
    0.00 :	   83c75:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83c78:       c3                      retq   
    0.00 :	   83c79:       66 0f 7f 87 42 ff ff    movdqa %xmm0,-0xbe(%rdi)
    0.00 :	   83c80:       ff 
    0.00 :	   83c81:       66 0f 7f 87 52 ff ff    movdqa %xmm0,-0xae(%rdi)
    0.00 :	   83c88:       ff 
    0.00 :	   83c89:       66 0f 7f 87 62 ff ff    movdqa %xmm0,-0x9e(%rdi)
    0.00 :	   83c90:       ff 
    0.00 :	   83c91:       66 0f 7f 87 72 ff ff    movdqa %xmm0,-0x8e(%rdi)
    0.00 :	   83c98:       ff 
    0.00 :	   83c99:       66 0f 7f 47 82          movdqa %xmm0,-0x7e(%rdi)
    0.00 :	   83c9e:       66 0f 7f 47 92          movdqa %xmm0,-0x6e(%rdi)
    0.00 :	   83ca3:       66 0f 7f 47 a2          movdqa %xmm0,-0x5e(%rdi)
    0.00 :	   83ca8:       66 0f 7f 47 b2          movdqa %xmm0,-0x4e(%rdi)
    0.00 :	   83cad:       66 0f 7f 47 c2          movdqa %xmm0,-0x3e(%rdi)
    0.00 :	   83cb2:       66 0f 7f 47 d2          movdqa %xmm0,-0x2e(%rdi)
    0.00 :	   83cb7:       66 0f 7f 47 e2          movdqa %xmm0,-0x1e(%rdi)
    0.00 :	   83cbc:       48 89 57 f2             mov    %rdx,-0xe(%rdi)
    0.00 :	   83cc0:       89 57 fa                mov    %edx,-0x6(%rdi)
    0.00 :	   83cc3:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	   83cc7:       c3                      retq   
    0.00 :	   83cc8:       66 0f 7f 87 41 ff ff    movdqa %xmm0,-0xbf(%rdi)
    0.00 :	   83ccf:       ff 
    0.00 :	   83cd0:       66 0f 7f 87 51 ff ff    movdqa %xmm0,-0xaf(%rdi)
    0.00 :	   83cd7:       ff 
    0.00 :	   83cd8:       66 0f 7f 87 61 ff ff    movdqa %xmm0,-0x9f(%rdi)
    0.00 :	   83cdf:       ff 
    0.00 :	   83ce0:       66 0f 7f 87 71 ff ff    movdqa %xmm0,-0x8f(%rdi)
    0.00 :	   83ce7:       ff 
    0.00 :	   83ce8:       66 0f 7f 47 81          movdqa %xmm0,-0x7f(%rdi)
    0.00 :	   83ced:       66 0f 7f 47 91          movdqa %xmm0,-0x6f(%rdi)
    0.00 :	   83cf2:       66 0f 7f 47 a1          movdqa %xmm0,-0x5f(%rdi)
    0.00 :	   83cf7:       66 0f 7f 47 b1          movdqa %xmm0,-0x4f(%rdi)
    0.00 :	   83cfc:       66 0f 7f 47 c1          movdqa %xmm0,-0x3f(%rdi)
    0.00 :	   83d01:       66 0f 7f 47 d1          movdqa %xmm0,-0x2f(%rdi)
    0.00 :	   83d06:       66 0f 7f 47 e1          movdqa %xmm0,-0x1f(%rdi)
    0.00 :	   83d0b:       48 89 57 f1             mov    %rdx,-0xf(%rdi)
    0.00 :	   83d0f:       89 57 f9                mov    %edx,-0x7(%rdi)
    0.00 :	   83d12:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	   83d16:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	   83d19:       c3                      retq   
    0.00 :	   83d1a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	   83d20:       44 8b 0d 11 e4 2e 00    mov    0x2ee411(%rip),%r9d        # 372138 <__x86_64_shared_cache_size>
    0.00 :	   83d27:       4d 39 c8                cmp    %r9,%r8
    0.00 :	   83d2a:       77 64                   ja     83d90 <__GI_memset+0x920>
    0.00 :	   83d2c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   83d30:       4d 8d 40 80             lea    -0x80(%r8),%r8
    0.00 :	   83d34:       49 81 f8 80 00 00 00    cmp    $0x80,%r8
    0.00 :	   83d3b:       66 0f 7f 07             movdqa %xmm0,(%rdi)
    0.00 :	   83d3f:       66 0f 7f 47 10          movdqa %xmm0,0x10(%rdi)
    0.00 :	   83d44:       66 0f 7f 47 20          movdqa %xmm0,0x20(%rdi)
    0.00 :	   83d49:       66 0f 7f 47 30          movdqa %xmm0,0x30(%rdi)
    0.00 :	   83d4e:       66 0f 7f 47 40          movdqa %xmm0,0x40(%rdi)
    0.00 :	   83d53:       66 0f 7f 47 50          movdqa %xmm0,0x50(%rdi)
    0.00 :	   83d58:       66 0f 7f 47 60          movdqa %xmm0,0x60(%rdi)
    0.00 :	   83d5d:       66 0f 7f 47 70          movdqa %xmm0,0x70(%rdi)
    0.00 :	   83d62:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   83d69:       73 c5                   jae    83d30 <__GI_memset+0x8c0>
    0.00 :	   83d6b:       4c 01 c7                add    %r8,%rdi
    0.00 :	   83d6e:       4c 8d 1d 38 fb ff ff    lea    -0x4c8(%rip),%r11        # 838ad <__GI_memset+0x43d>
    0.00 :	   83d75:       48 8d 0d e4 25 0b 00    lea    0xb25e4(%rip),%rcx        # 136360 <next_state.9261+0x1dc>
    0.00 :	   83d7c:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83d81:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   83d85:       41 ff e3                jmpq   *%r11
    0.00 :	   83d88:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	   83d8f:       00 
    0.00 :	   83d90:       49 83 f9 00             cmp    $0x0,%r9
    0.00 :	   83d94:       74 9a                   je     83d30 <__GI_memset+0x8c0>
    0.00 :	   83d96:       eb 08                   jmp    83da0 <__GI_memset+0x930>
    0.00 :	   83d98:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	   83d9f:       00 
    0.00 :	   83da0:       4d 8d 40 80             lea    -0x80(%r8),%r8
    0.00 :	   83da4:       49 81 f8 80 00 00 00    cmp    $0x80,%r8
    0.00 :	   83dab:       66 0f e7 07             movntdq %xmm0,(%rdi)
    0.00 :	   83daf:       66 0f e7 47 10          movntdq %xmm0,0x10(%rdi)
    0.00 :	   83db4:       66 0f e7 47 20          movntdq %xmm0,0x20(%rdi)
    0.00 :	   83db9:       66 0f e7 47 30          movntdq %xmm0,0x30(%rdi)
    0.00 :	   83dbe:       66 0f e7 47 40          movntdq %xmm0,0x40(%rdi)
    0.00 :	   83dc3:       66 0f e7 47 50          movntdq %xmm0,0x50(%rdi)
    0.00 :	   83dc8:       66 0f e7 47 60          movntdq %xmm0,0x60(%rdi)
    0.00 :	   83dcd:       66 0f e7 47 70          movntdq %xmm0,0x70(%rdi)
    0.00 :	   83dd2:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   83dd9:       73 c5                   jae    83da0 <__GI_memset+0x930>
    0.00 :	   83ddb:       0f ae f8                sfence 
    0.00 :	   83dde:       4c 01 c7                add    %r8,%rdi
    0.00 :	   83de1:       4c 8d 1d c5 fa ff ff    lea    -0x53b(%rip),%r11        # 838ad <__GI_memset+0x43d>
    0.00 :	   83de8:       48 8d 0d 71 25 0b 00    lea    0xb2571(%rip),%rcx        # 136360 <next_state.9261+0x1dc>
    0.00 :	   83def:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83df4:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   83df8:       41 ff e3                jmpq   *%r11
    0.00 :	   83dfb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	   83e00:       49 81 f8 00 20 00 00    cmp    $0x2000,%r8
    0.00 :	   83e07:       0f 83 83 00 00 00       jae    83e90 <__GI_memset+0xa20>
    0.00 :	   83e0d:       0f 1f 00                nopl   (%rax)
    0.00 :	   83e10:       4c 89 c1                mov    %r8,%rcx
    0.00 :	   83e13:       48 c1 e9 07             shr    $0x7,%rcx
    0.00 :	   83e17:       74 52                   je     83e6b <__GI_memset+0x9fb>
    0.00 :	   83e19:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   83e20:       48 ff c9                dec    %rcx
    0.00 :	   83e23:       48 89 17                mov    %rdx,(%rdi)
    0.00 :	   83e26:       48 89 57 08             mov    %rdx,0x8(%rdi)
    0.00 :	   83e2a:       48 89 57 10             mov    %rdx,0x10(%rdi)
    0.00 :	   83e2e:       48 89 57 18             mov    %rdx,0x18(%rdi)
    0.00 :	   83e32:       48 89 57 20             mov    %rdx,0x20(%rdi)
    0.00 :	   83e36:       48 89 57 28             mov    %rdx,0x28(%rdi)
    0.00 :	   83e3a:       48 89 57 30             mov    %rdx,0x30(%rdi)
    0.00 :	   83e3e:       48 89 57 38             mov    %rdx,0x38(%rdi)
    0.00 :	   83e42:       48 89 57 40             mov    %rdx,0x40(%rdi)
    0.00 :	   83e46:       48 89 57 48             mov    %rdx,0x48(%rdi)
    0.00 :	   83e4a:       48 89 57 50             mov    %rdx,0x50(%rdi)
    0.00 :	   83e4e:       48 89 57 58             mov    %rdx,0x58(%rdi)
    0.00 :	   83e52:       48 89 57 60             mov    %rdx,0x60(%rdi)
    0.00 :	   83e56:       48 89 57 68             mov    %rdx,0x68(%rdi)
    0.00 :	   83e5a:       48 89 57 70             mov    %rdx,0x70(%rdi)
    0.00 :	   83e5e:       48 89 57 78             mov    %rdx,0x78(%rdi)
    0.00 :	   83e62:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   83e69:       75 b5                   jne    83e20 <__GI_memset+0x9b0>
    0.00 :	   83e6b:       41 83 e0 7f             and    $0x7f,%r8d
    0.00 :	   83e6f:       4a 8d 3c 07             lea    (%rdi,%r8,1),%rdi
    0.00 :	   83e73:       4c 8d 1d 42 f6 ff ff    lea    -0x9be(%rip),%r11        # 834bc <__GI_memset+0x4c>
    0.00 :	   83e7a:       48 8d 0d 8f 23 0b 00    lea    0xb238f(%rip),%rcx        # 136210 <next_state.9261+0x8c>
    0.00 :	   83e81:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83e86:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   83e8a:       41 ff e3                jmpq   *%r11
    0.00 :	   83e8d:       0f 1f 00                nopl   (%rax)
    0.00 :	   83e90:       44 8b 0d a1 e2 2e 00    mov    0x2ee2a1(%rip),%r9d        # 372138 <__x86_64_shared_cache_size>
    0.00 :	   83e97:       4d 39 c1                cmp    %r8,%r9
    0.00 :	   83e9a:       4d 0f 47 c8             cmova  %r8,%r9
    0.00 :	   83e9e:       76 10                   jbe    83eb0 <__GI_memset+0xa40>
    0.00 :	   83ea0:       49 81 f8 00 00 01 00    cmp    $0x10000,%r8
    0.00 :	   83ea7:       0f 83 63 ff ff ff       jae    83e10 <__GI_memset+0x9a0>
    0.00 :	   83ead:       0f 1f 00                nopl   (%rax)
    0.00 :	   83eb0:       4c 89 c9                mov    %r9,%rcx
    0.00 :	   83eb3:       49 83 e1 f8             and    $0xfffffffffffffff8,%r9
    0.00 :	   83eb7:       48 c1 e9 03             shr    $0x3,%rcx
    0.00 :	   83ebb:       74 07                   je     83ec4 <__GI_memset+0xa54>
    0.00 :	   83ebd:       48 92                   xchg   %rax,%rdx
    0.00 :	   83ebf:       f3 48 ab                rep stos %rax,%es:(%rdi)
    0.00 :	   83ec2:       48 92                   xchg   %rax,%rdx
    0.00 :	   83ec4:       4d 29 c8                sub    %r9,%r8
    0.00 :	   83ec7:       77 27                   ja     83ef0 <__GI_memset+0xa80>
    0.00 :	   83ec9:       41 83 e0 07             and    $0x7,%r8d
    0.00 :	   83ecd:       4a 8d 3c 07             lea    (%rdi,%r8,1),%rdi
    0.00 :	   83ed1:       4c 8d 1d e4 f5 ff ff    lea    -0xa1c(%rip),%r11        # 834bc <__GI_memset+0x4c>
    0.00 :	   83ed8:       48 8d 0d 31 23 0b 00    lea    0xb2331(%rip),%rcx        # 136210 <next_state.9261+0x8c>
    0.00 :	   83edf:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83ee4:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   83ee8:       41 ff e3                jmpq   *%r11
    0.00 :	   83eeb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	   83ef0:       4c 89 c1                mov    %r8,%rcx
    0.00 :	   83ef3:       48 c1 e9 07             shr    $0x7,%rcx
    0.00 :	   83ef7:       74 65                   je     83f5e <__GI_memset+0xaee>
    0.00 :	   83ef9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   83f00:       48 ff c9                dec    %rcx
    0.00 :	   83f03:       48 0f c3 17             movnti %rdx,(%rdi)
    0.00 :	   83f07:       48 0f c3 57 08          movnti %rdx,0x8(%rdi)
    0.00 :	   83f0c:       48 0f c3 57 10          movnti %rdx,0x10(%rdi)
    0.00 :	   83f11:       48 0f c3 57 18          movnti %rdx,0x18(%rdi)
    0.00 :	   83f16:       48 0f c3 57 20          movnti %rdx,0x20(%rdi)
    0.00 :	   83f1b:       48 0f c3 57 28          movnti %rdx,0x28(%rdi)
    0.00 :	   83f20:       48 0f c3 57 30          movnti %rdx,0x30(%rdi)
    0.00 :	   83f25:       48 0f c3 57 38          movnti %rdx,0x38(%rdi)
    0.00 :	   83f2a:       48 0f c3 57 40          movnti %rdx,0x40(%rdi)
    0.00 :	   83f2f:       48 0f c3 57 48          movnti %rdx,0x48(%rdi)
    0.00 :	   83f34:       48 0f c3 57 50          movnti %rdx,0x50(%rdi)
    0.00 :	   83f39:       48 0f c3 57 58          movnti %rdx,0x58(%rdi)
    0.00 :	   83f3e:       48 0f c3 57 60          movnti %rdx,0x60(%rdi)
    0.00 :	   83f43:       48 0f c3 57 68          movnti %rdx,0x68(%rdi)
    0.00 :	   83f48:       48 0f c3 57 70          movnti %rdx,0x70(%rdi)
    0.00 :	   83f4d:       48 0f c3 57 78          movnti %rdx,0x78(%rdi)
    0.00 :	   83f52:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   83f59:       75 a5                   jne    83f00 <__GI_memset+0xa90>
    0.00 :	   83f5b:       0f ae f8                sfence 
    0.00 :	   83f5e:       41 83 e0 7f             and    $0x7f,%r8d
    0.00 :	   83f62:       4a 8d 3c 07             lea    (%rdi,%r8,1),%rdi
    0.00 :	   83f66:       4c 8d 1d 4f f5 ff ff    lea    -0xab1(%rip),%r11        # 834bc <__GI_memset+0x4c>
    0.00 :	   83f6d:       48 8d 0d 9c 22 0b 00    lea    0xb229c(%rip),%rcx        # 136210 <next_state.9261+0x8c>
    0.00 :	   83f74:       4a 0f bf 0c 41          movswq (%rcx,%r8,2),%rcx
    0.00 :	   83f79:       4e 8d 1c 19             lea    (%rcx,%r11,1),%r11
    0.00 :	   83f7d:       41 ff e3                jmpq   *%r11

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000cd5c0 <__read>:
    0.00 :	   cd5c0:       83 3d ed a0 2a 00 00    cmpl   $0x0,0x2aa0ed(%rip)        # 3776b4 <__libc_multiple_threads>
 ??:0
  100.00 :	   cd5c7:       75 10                   jne    cd5d9 <__read_nocancel+0x10>
         :
         :	00000000000cd5c9 <__read_nocancel>:
    0.00 :	   cd5c9:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5ce:       0f 05                   syscall 
    0.00 :	   cd5d0:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd5d6:       73 31                   jae    cd609 <__read_nocancel+0x40>
    0.00 :	   cd5d8:       c3                      retq   
    0.00 :	   cd5d9:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   cd5dd:       e8 4e ac 01 00          callq  e8230 <__libc_enable_asynccancel>
    0.00 :	   cd5e2:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	   cd5e6:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5eb:       0f 05                   syscall 
    0.00 :	   cd5ed:       48 8b 3c 24             mov    (%rsp),%rdi
    0.00 :	   cd5f1:       48 89 c2                mov    %rax,%rdx
    0.00 :	   cd5f4:       e8 97 ac 01 00          callq  e8290 <__libc_disable_asynccancel>
    0.00 :	   cd5f9:       48 89 d0                mov    %rdx,%rax
    0.00 :	   cd5fc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   cd600:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd606:       73 01                   jae    cd609 <__read_nocancel+0x40>
    0.00 :	   cd608:       c3                      retq   
    0.00 :	   cd609:       48 8b 0d 28 48 2a 00    mov    0x2a4828(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   cd610:       31 d2                   xor    %edx,%edx
    0.00 :	   cd612:       48 29 c2                sub    %rax,%rdx
    0.00 :	   cd615:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   cd618:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   cd61c:       eb ea                   jmp    cd608 <__read_nocancel+0x3f>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000d1e50 <posix_fadvise>:
    0.00 :	   d1e50:       4c 63 d1                movslq %ecx,%r10
    0.00 :	   d1e53:       48 63 ff                movslq %edi,%rdi
    0.00 :	   d1e56:       b8 dd 00 00 00          mov    $0xdd,%eax
    0.00 :	   d1e5b:       0f 05                   syscall 
 ??:0
  100.00 :	   d1e5d:       89 c1                   mov    %eax,%ecx
    0.00 :	   d1e5f:       89 c2                   mov    %eax,%edx
    0.00 :	   d1e61:       31 c0                   xor    %eax,%eax
    0.00 :	   d1e63:       f7 da                   neg    %edx
    0.00 :	   d1e65:       81 f9 00 f0 ff ff       cmp    $0xfffff000,%ecx
    0.00 :	   d1e6b:       0f 47 c2                cmova  %edx,%eax

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000005b60 <igb_watchdog_task>:
    0.00 :	    5b60:       41 57                   push   %r15
    0.00 :	    5b92:       41 56                   js     5bdc <dma_unmap_page+0x5bac>
    0.00 :	    5b94:       49 89 fe                lea    0x78(%rbx),%ebp
    0.00 :	    5b97:       41 55                   test   $0x4,%al
    0.00 :	    5b99:       41 54 4c 8d a7 e0       je     5ee2 <dma_unmap_page+0x5eb2>
    0.00 :	    5b9f:       fb ff ff 55 53 48 83    lea    0x4a8(%r12),%rbx
    0.00 :	    5ba6:       ec 
    0.00 :	    5ba7:       08 48 8b                mov    %rbx,%rdi
    0.00 :	    5baa:       9f e0 fd ff ff          callq  5baf <dma_unmap_page+0x5b7f>
    0.00 :	    5baf:       4c 89 e7 e8 00 00 00    lea    0x4b0(%r12),%rsi
    0.00 :	    5bb6:       00 
    0.00 :	    5bb7:       84 c0 0f                mov    %r12,%rdi
    0.00 :	    5bba:       85 f1 01 00 00          callq  5bbf <dma_unmap_page+0x5b8f>
    0.00 :	    5bbf:       48 8b 43 78 48 8d 6b    incw   0x4a8(%r12)
    0.00 :	    5bc6:       78 a8 
    0.00 :	    5bc8:       04 0f 84 43 03 00 00    mov    -0x1ec(%r14),%r13d
    0.00 :	    5bcf:       49 8d 9c                test   %r13d,%r13d
    0.00 :	    5bd2:       24 a8 04 00 00 48       jle    5c70 <dma_unmap_page+0x5c40>
    0.00 :	    5bd8:       89 df e8                mov    %r12,%r9
    0.00 :	    5bdb:       00 00 00                xor    %r8d,%r8d
    0.00 :	    5bde:       00 49                   jmp    5c11 <dma_unmap_page+0x5be1>
    0.00 :	    5be0:       8d b4 24                movzwl %ax,%eax
    0.00 :	    5be3:       b0 04 00 00             movzwl 0x44(%rdx),%edi
    0.00 :	    5be7:       4c 89 e7                lea    -0x1(%rax),%ecx
    0.00 :	    5bea:       e8 00 00                movzwl %si,%eax
    0.00 :	    5bed:       00 00                   sub    %eax,%ecx
    0.00 :	    5bef:       66 41 ff                lea    0x1(%rcx),%eax
    0.00 :	    5bf2:       84 24                   cmp    %edi,%eax
    0.00 :	    5bf4:       a8 04                   jl     5c44 <dma_unmap_page+0x5c14>
    0.00 :	    5bf6:       00 00 45 8b             lea    0x28(%rdx),%rax
    0.00 :	    5bfa:       ae 14 fe ff ff          lock orb $0x8,0x28(%rdx)
    0.00 :	    5bff:       45 85 ed 0f             add    $0x1,%r8d
    0.00 :	    5c03:       8e 98 00 00             add    $0x8,%r9
    0.00 :	    5c07:       00 4d 89 e1 45 31 c0    cmp    %r8d,0x234(%r12)
    0.00 :	    5c0e:       eb 
    0.00 :	    5c0f:       31 0f                   jle    5c70 <dma_unmap_page+0x5c40>
    0.00 :	    5c11:       b7 c0 0f b7             mov    0x0(%rbp),%rax
    0.00 :	    5c15:       7a 44 8d 48 ff 0f b7    mov    0x238(%r9),%rdx
    0.00 :	    5c1c:       c6 29                   test   $0x4,%al
    0.00 :	    5c1e:       c1 8d                   je     5bf6 <dma_unmap_page+0x5bc6>
    0.00 :	    5c20:       41 01 39 f8             movzwl 0x48(%rdx),%eax
    0.00 :	    5c24:       7c 4e 48 8d             movzwl 0x4a(%rdx),%esi
    0.00 :	    5c28:       42 28 f0                cmp    %si,%ax
    0.00 :	    5c2b:       80 4a                   ja     5be0 <dma_unmap_page+0x5bb0>
    0.00 :	    5c2d:       28 08 41 83             movzwl 0x44(%rdx),%edi
    0.00 :	    5c31:       c0 01 49                movzwl %ax,%eax
    0.00 :	    5c34:       83 c1 08 45             lea    -0x1(%rdi,%rax,1),%ecx
    0.00 :	    5c38:       39 84 24                movzwl %si,%eax
    0.00 :	    5c3b:       34 02                   sub    %eax,%ecx
    0.00 :	    5c3d:       00 00 7e                lea    0x1(%rcx),%eax
    0.00 :	    5c40:       5f 48                   cmp    %edi,%eax
    0.00 :	    5c42:       8b 45                   jge    5bf6 <dma_unmap_page+0x5bc6>
    0.00 :	    5c44:       00 49 8b 91 38 02 00    addl   $0x1,0x230(%r12)
    0.00 :	    5c4b:       00 a8 
    0.00 :	    5c4d:       04 74 d6 0f             add    $0x8,%rsp
    0.00 :	    5c51:       b7 42 48 0f b7 72 4a    lea    0x400(%r12),%rdi
    0.00 :	    5c58:       66 
    0.00 :	    5c59:       39                      pop    %rbx
    0.00 :	    5c5a:       f0                      pop    %rbp
    0.00 :	    5c5b:       77 b3                   pop    %r12
    0.00 :	    5c5d:       0f b7                   pop    %r13
    0.00 :	    5c5f:       7a 44                   pop    %r14
    0.00 :	    5c61:       0f b7                   pop    %r15
    0.00 :	    5c63:       c0 8d 4c 07 ff          jmpq   5c68 <dma_unmap_page+0x5c38>
    0.00 :	    5c68:       0f b7 c6 29 c1 8d 41    nopl   0x0(%rax,%rax,1)
    0.00 :	    5c6f:       01 
    0.00 :	    5c70:       39 f8 7d b2 41 83 84    cmpq   $0x0,-0x208(%r14)
    0.00 :	    5c77:       24 
    0.00 :	    5c78:       30 02 00 00 01 48       je     5ec8 <dma_unmap_page+0x5e98>
    0.00 :	    5c7e:       83 c4 08 49 8d bc 24    mov    -0x20c(%r14),%esi
    0.00 :	    5c85:       00 04                   xor    %ecx,%ecx
    0.00 :	    5c87:       00 00                   xor    %edx,%edx
    0.00 :	    5c89:       5b 5d                   test   %esi,%esi
    0.00 :	    5c8b:       41 5c                   je     5ca3 <dma_unmap_page+0x5c73>
    0.00 :	    5c8d:       41 5d 41                nopl   (%rax)
    0.00 :	    5c90:       5e 41 5f e9 00 00 00    mov    0xe88(%r12,%rdx,8),%rax
    0.00 :	    5c97:       00 
    0.00 :	    5c98:       0f 1f 84 00             add    $0x1,%rdx
    0.00 :	    5c9c:       00 00 00                or     0xc(%rax),%ecx
    0.00 :	    5c9f:       00 49                   cmp    %edx,%esi
    0.00 :	    5ca1:       83 be                   ja     5c90 <dma_unmap_page+0x5c60>
    0.00 :	    5ca3:       f8 fd ff ff 00 0f 84    mov    0x570(%r12),%rax
    0.00 :	    5caa:       4a 
    0.00 :	    5cab:       02 00 00 41 8b b6       add    $0x1520,%rax
    0.00 :	    5cb1:       f4 fd                   mov    %ecx,(%rax)
    0.00 :	    5cb3:       ff ff 31 c9 31 d2 85    mov    0xee8(%r12),%edx
    0.00 :	    5cba:       f6 
    0.00 :	    5cbb:       74 16                   test   %edx,%edx
    0.00 :	    5cbd:       0f 1f                   je     5d2b <dma_unmap_page+0x5cfb>
    0.00 :	    5cbf:       00 49 8b 84 d4 88 0e    mov    0xed4(%r12),%ebx
    0.00 :	    5cc6:       00 
    0.00 :	    5cc7:       00 48                   test   %ebx,%ebx
    0.00 :	    5cc9:       83 c2                   je     5d2b <dma_unmap_page+0x5cfb>
    0.00 :	    5ccb:       01 0b                   xor    %ebp,%ebp
    0.00 :	    5ccd:       48 0c 39 d6 77 ed       mov    $0x1,%r13d
    0.00 :	    5cd3:       49 8b                   jmp    5ce0 <dma_unmap_page+0x5cb0>
    0.00 :	    5cd5:       84 24 70                nopl   (%rax)
    0.00 :	    5cd8:       05 00 00 48 05 20 15    mov    0xee8(%r12),%edx
    0.00 :	    5cdf:       00 
    0.00 :	    5ce0:       00 89                   mov    %ebp,%ecx
    0.00 :	    5ce2:       08 41 8b                mov    %r13d,%eax
    0.00 :	    5ce5:       94 24 e8                mov    %r13d,%ebx
    0.00 :	    5ce8:       0e 00                   shl    %cl,%eax
    0.00 :	    5cea:       00 85 d2                lea    0x8(%rbp),%ecx
    0.00 :	    5ced:       74 6c                   shl    %cl,%ebx
    0.00 :	    5cef:       41 8b                   or     %eax,%ebx
    0.00 :	    5cf1:       9c 24                   test   %edx,%ebx
    0.00 :	    5cf3:       d4 0e                   je     5d1e <dma_unmap_page+0x5cee>
    0.00 :	    5cf5:       00 00 85 db 74 60 31    mov    0x4a0(%r12),%rdi
    0.00 :	    5cfc:       ed 
    0.00 :	    5cfd:       41 bd                   mov    %ebp,%edx
    0.00 :	    5cff:       01 00 00 00 eb 0b 0f    mov    $0x0,%rsi
    0.00 :	    5d06:       1f 00                   xor    %eax,%eax
    0.00 :	    5d08:       41 8b                   not    %ebx
    0.00 :	    5d0a:       94 24 e8 0e 00 00 89    add    $0x90,%rdi
    0.00 :	    5d11:       e9 44 89 e8 44          callq  5d16 <dma_unmap_page+0x5ce6>
    0.00 :	    5d16:       89 eb d3 e0 8d 4d 08    and    %ebx,0xee8(%r12)
    0.00 :	    5d1d:       d3 
    0.00 :	    5d1e:       e3 09 c3                add    $0x1,%ebp
    0.00 :	    5d21:       85 d3 74 29 49 8b bc    cmp    0xed4(%r12),%ebp
    0.00 :	    5d28:       24 
    0.00 :	    5d29:       a0 04                   jb     5cd8 <dma_unmap_page+0x5ca8>
    0.00 :	    5d2b:       00 00 89 ea 48 c7 c6    mov    -0x218(%r14),%rax
    0.00 :	    5d32:       00 00                   test   $0x4,%al
    0.00 :	    5d34:       00 00                   je     5d48 <dma_unmap_page+0x5d18>
    0.00 :	    5d36:       31 c0 f7 d3             add    $0x8,%rsp
    0.00 :	    5d3a:       48                      pop    %rbx
    0.00 :	    5d3b:       81                      pop    %rbp
    0.00 :	    5d3c:       c7 90                   pop    %r12
    0.00 :	    5d3e:       00 00                   pop    %r13
    0.00 :	    5d40:       00 e8                   pop    %r14
    0.00 :	    5d42:       00 00                   pop    %r15
    0.00 :	    5d44:       00                      retq   
    0.00 :	    5d45:       00 41 21                nopl   (%rax)
    0.00 :	    5d48:       9c 24 e8 0e 00 00 83    mov    0x0(%rip),%rdi        # 5d4f <dma_unmap_page+0x5d1f>
    0.00 :	    5d4f:       c5 01 41 3b ac 24 d4    add    $0x1f4,%rdi
    0.00 :	    5d56:       0e 00 00 72 ad          callq  5d5b <dma_unmap_page+0x5d2b>
    0.00 :	    5d5b:       49 8b 86 e8             add    $0x8,%rsp
    0.00 :	    5d5f:       fd ff ff a8 04 74 12    lea    0x348(%r12),%rdi
    0.00 :	    5d66:       48 
    0.00 :	    5d67:       83 c4 08                mov    %rax,%rsi
    0.00 :	    5d6a:       5b                      pop    %rbx
    0.00 :	    5d6b:       5d                      pop    %rbp
    0.00 :	    5d6c:       41 5c                   pop    %r12
    0.00 :	    5d6e:       41 5d                   pop    %r13
    0.00 :	    5d70:       41 5e                   pop    %r14
    0.00 :	    5d72:       41 5f                   pop    %r15
    0.00 :	    5d74:       c3 0f 1f 00 48          jmpq   5d79 <dma_unmap_page+0x5d49>
    0.00 :	    5d79:       8b 3d 00 00 00 00 48    nopl   0x0(%rax)
 ??:0
  100.00 :	    5d80:       81 c7 f4 01 00 00 e8    mov    0x478(%rbx),%rdi
    0.00 :	    5d87:       00 00                   xor    %esi,%esi
    0.00 :	    5d89:       00 00 48 83             lea    0x78(%rbx),%rbp
    0.00 :	    5d8d:       c4 08 49 8d bc          callq  5d92 <dma_unmap_page+0x5d62>
    0.00 :	    5d92:       24 48 03 00             mov    0x78(%rbx),%rax
    0.00 :	    5d96:       00 48                   test   $0x4,%al
    0.00 :	    5d98:       89 c6 5b 5d 41 5c       je     5b9f <dma_unmap_page+0x5b6f>
    0.00 :	    5d9e:       41 5d 41 5e 41 5f e9    lea    0x148(%r14),%rax
    0.00 :	    5da5:       00 00 00 00 0f 1f 80    lea    0x3fa(%r12),%rdx
    0.00 :	    5dac:       00 
    0.00 :	    5dad:       00 00 00 48 8b bb 78    lea    0x3f8(%r12),%rsi
    0.00 :	    5db4:       04 
    0.00 :	    5db5:       00 00 31 f6             mov    %rax,(%rsp)
    0.00 :	    5db9:       48 8d 6b                mov    %rax,%rdi
    0.00 :	    5dbc:       78 e8 00 00 00 00 48    callq  *0x5c0(%r12)
    0.00 :	    5dc3:       8b 
    0.00 :	    5dc4:       43 78 a8 04 0f 84 01    mov    0x570(%r12),%rax
    0.00 :	    5dcb:       fe 
    0.00 :	    5dcc:       ff ff                   mov    (%rax),%edx
    0.00 :	    5dce:       49 8d                   mov    %edx,%eax
    0.00 :	    5dd0:       86 48 01 00 00 49 8d    mov    $0x0,%r8
    0.00 :	    5dd7:       94 24 fa 03 00          and    $0x18000000,%eax
    0.00 :	    5ddc:       00 49 8d b4 24          cmp    $0x18000000,%eax
    0.00 :	    5de1:       f8 03                   je     5e0a <dma_unmap_page+0x5dda>
    0.00 :	    5de3:       00 00 48 89 04 24       test   $0x8000000,%edx
    0.00 :	    5de9:       48 89 c7 41 ff 94 24    mov    $0x0,%r8
    0.00 :	    5df0:       c0 05                   jne    5e0a <dma_unmap_page+0x5dda>
    0.00 :	    5df2:       00 00 49 8b 84 24 70    mov    $0x0,%r8
    0.00 :	    5df9:       05 00 00 8b 10 89       and    $0x10000000,%edx
    0.00 :	    5dff:       d0 49 c7 c0 00 00 00    mov    $0x0,%rax
    0.00 :	    5e06:       00 25 00 00             cmovne %rax,%r8
    0.00 :	    5e0a:       00 18 3d 00 00 00       cmpw   $0x2,-0x26(%r14)
    0.00 :	    5e10:       18 74 27 f7 c2          movzwl -0x28(%r14),%edx
    0.00 :	    5e15:       00 00 00 08 49 c7 c0    mov    $0x0,%rax
    0.00 :	    5e1c:       00 00 00 00 75 18 49    mov    $0x0,%rcx
    0.00 :	    5e23:       c7 c0 00                mov    %rbx,%rsi
    0.00 :	    5e26:       00 00 00 81 e2 00 00    mov    $0x0,%rdi
    0.00 :	    5e2d:       00 10 48 c7             cmove  %rax,%rcx
    0.00 :	    5e31:       c0 00                   xor    %eax,%eax
    0.00 :	    5e33:       00 00 00 4c 0f          callq  5e38 <dma_unmap_page+0x5e08>
    0.00 :	    5e38:       45 c0 66 41 83 7e da    cmpl   $0x4,0x5e4(%r12)
    0.00 :	    5e3f:       02 41 
    0.00 :	    5e41:       0f b7 56 d8 48 c7       je     5f41 <dma_unmap_page+0x5f11>
    0.00 :	    5e47:       c0 00 00 00 00 48 c7    movb   $0x1,0x441(%r12)
    0.00 :	    5e4e:       c1 00 
    0.00 :	    5e50:       00 00 00 48 89 de       cmpw   $0xa,-0x28(%r14)
    0.00 :	    5e56:       48 c7                   jne    5e61 <dma_unmap_page+0x5e31>
    0.00 :	    5e58:       c7 00 00 00 00 48 0f    movb   $0xe,0x441(%r12)
    0.00 :	    5e5f:       44 c8 
    0.00 :	    5e61:       31 c0 e8                mov    %rbx,%rdi
    0.00 :	    5e64:       00 00 00 00 41          callq  5e69 <dma_unmap_page+0x5e39>
    0.00 :	    5e69:       83 bc 24                mov    %r12,%rdi
    0.00 :	    5e6c:       e4 05 00 00 04          callq  2ed0 <dma_unmap_page+0x2ea0>
    0.00 :	    5e71:       0f 84 fa 00 00 00 41    mov    0xee0(%r12),%edx
    0.00 :	    5e78:       c6 
    0.00 :	    5e79:       84 24                   test   %edx,%edx
    0.00 :	    5e7b:       41 04                   je     5e8c <dma_unmap_page+0x5e5c>
    0.00 :	    5e7d:       00 00 01 66 41 83 7e    cmpl   $0x2,0x5e4(%r12)
    0.00 :	    5e84:       d8 0a 
    0.00 :	    5e86:       75 09 41 c6 84 24       je     6017 <dma_unmap_page+0x5fe7>
    0.00 :	    5e8c:       41 04 00 00 0e 48 89    mov    -0x218(%r14),%rax
    0.00 :	    5e93:       df e8                   test   $0x4,%al
    0.00 :	    5e95:       00 00 00 00 4c 89       jne    5b9f <dma_unmap_page+0x5b6f>
    0.00 :	    5e9b:       e7 e8 5f d0 ff ff 41    mov    0x0(%rip),%rdi        # 5ea2 <dma_unmap_page+0x5e72>
    0.00 :	    5ea2:       8b 94 24 e0 0e 00 00    add    $0x1f4,%rdi
    0.00 :	    5ea9:       85 d2 74 0f 41          callq  5eae <dma_unmap_page+0x5e7e>
    0.00 :	    5eae:       83 bc 24 e4 05 00 00    lea    0x398(%r12),%rdi
    0.00 :	    5eb5:       02 
    0.00 :	    5eb6:       0f 84 8b                mov    %rax,%rsi
    0.00 :	    5eb9:       01 00 00 49 8b          callq  5ebe <dma_unmap_page+0x5e8e>
    0.00 :	    5ebe:       86 e8 fd ff ff          jmpq   5b9f <dma_unmap_page+0x5b6f>
    0.00 :	    5ec3:       a8 04 0f 85 04          nopl   0x0(%rax,%rax,1)
    0.00 :	    5ec8:       fd ff ff 48 8b 3d 00    mov    0x570(%r12),%rax
    0.00 :	    5ecf:       00 
    0.00 :	    5ed0:       00 00 48 81 c7          mov    $0x10,%edx
    0.00 :	    5ed5:       f4 01 00 00 e8 00       add    $0xc8,%rax
    0.00 :	    5edb:       00 00                   mov    %edx,(%rax)
    0.00 :	    5edd:       00 49 8d bc 24          jmpq   5cb3 <dma_unmap_page+0x5c83>
    0.00 :	    5ee2:       98 03 00 00 48 89 c6    movw   $0x0,-0x28(%r14)
    0.00 :	    5ee9:       e8 00 00 00 00 e9 dc    movw   $0x0,-0x26(%r14)
    0.00 :	    5ef0:       fc ff ff 0f 1f 44 00    cmpl   $0x4,0x5e4(%r12)
    0.00 :	    5ef7:       00 49 
    0.00 :	    5ef9:       8b 84 24 70 05 00       je     5fc0 <dma_unmap_page+0x5f90>
    0.00 :	    5eff:       00 ba 10                mov    %rbx,%rsi
    0.00 :	    5f02:       00 00 00 48 05 c8 00    mov    $0x0,%rdi
    0.00 :	    5f09:       00 00                   xor    %eax,%eax
    0.00 :	    5f0b:       89 10 e9 d1 fd          callq  5f10 <dma_unmap_page+0x5ee0>
    0.00 :	    5f10:       ff ff 66                mov    %rbx,%rdi
    0.00 :	    5f13:       41 c7 46 d8 00          callq  5f18 <dma_unmap_page+0x5ee8>
    0.00 :	    5f18:       00 66 41                mov    %r12,%rdi
    0.00 :	    5f1b:       c7 46 da 00 00          callq  2ed0 <dma_unmap_page+0x2ea0>
    0.00 :	    5f20:       41 83 bc 24 e4 05 00    mov    -0x218(%r14),%rax
    0.00 :	    5f27:       00 04                   test   $0x4,%al
    0.00 :	    5f29:       0f 84                   je     5f98 <dma_unmap_page+0x5f68>
    0.00 :	    5f2b:       c1 00 00 00 48 89 de    mov    0x478(%rbx),%rdi
    0.00 :	    5f32:       48 c7 c7 00 00          mov    $0x1388,%esi
    0.00 :	    5f37:       00 00 31 c0 e8          callq  5f3c <dma_unmap_page+0x5f0c>
    0.00 :	    5f3c:       00 00 00 00 48          jmpq   5b9f <dma_unmap_page+0x5b6f>
    0.00 :	    5f41:       89 df e8 00 00 00 00    mov    0x570(%r12),%rax
    0.00 :	    5f48:       4c 
    0.00 :	    5f49:       89 e7 e8 b0 cf ff       add    $0x8110,%rax
    0.00 :	    5f4f:       ff 49                   mov    (%rax),%edx
    0.00 :	    5f51:       8b 86 e8 fd ff ff a8    mov    0x570(%r12),%rax
    0.00 :	    5f58:       04 
    0.00 :	    5f59:       74 6d 48 8b             add    $0x18,%rax
    0.00 :	    5f5d:       bb 78                   mov    (%rax),%eax
    0.00 :	    5f5f:       04 00 00 be 88 13 00    cmpl   $0x1,0x8bc(%r12)
    0.00 :	    5f66:       00 e8 
    0.00 :	    5f68:       00 00 00 00 e9 5e       jne    5e47 <dma_unmap_page+0x5e17>
    0.00 :	    5f6e:       fc ff ff 49 8b          test   $0x800000,%eax
    0.00 :	    5f73:       84 24 70 05 00 00       jne    5e47 <dma_unmap_page+0x5e17>
    0.00 :	    5f79:       48 05 10                and    $0x2,%edx
    0.00 :	    5f7c:       81 00 00 8b 10 49       je     5e47 <dma_unmap_page+0x5e17>
    0.00 :	    5f82:       8b 84 24 70 05 00 00    mov    $0x0,%rsi
    0.00 :	    5f89:       48 83 c0                mov    %rbx,%rdi
    0.00 :	    5f8c:       18 8b                   xor    %eax,%eax
    0.00 :	    5f8e:       00 41 83 bc 24          callq  5f93 <dma_unmap_page+0x5f63>
    0.00 :	    5f93:       bc 08 00 00 01          jmpq   5e47 <dma_unmap_page+0x5e17>
    0.00 :	    5f98:       0f 85 d9 fe ff ff a9    mov    0x0(%rip),%rdi        # 5f9f <dma_unmap_page+0x5f6f>
    0.00 :	    5f9f:       00 00 80 00 0f 85 ce    add    $0x1f4,%rdi
    0.00 :	    5fa6:       fe ff ff 83 e2          callq  5fab <dma_unmap_page+0x5f7b>
    0.00 :	    5fab:       02 0f 84 c5 fe ff ff    lea    0x398(%r12),%rdi
    0.00 :	    5fb2:       48 
    0.00 :	    5fb3:       c7 c6 00                mov    %rax,%rsi
    0.00 :	    5fb6:       00 00 00 48 89          callq  5fbb <dma_unmap_page+0x5f8b>
    0.00 :	    5fbb:       df 31 c0 e8 00          jmpq   5f2b <dma_unmap_page+0x5efb>
    0.00 :	    5fc0:       00 00 00 e9 af fe ff    mov    0x570(%r12),%rax
    0.00 :	    5fc7:       ff 
    0.00 :	    5fc8:       48 8b 3d 00 00 00       add    $0x8110,%rax
    0.00 :	    5fce:       00 48                   mov    (%rax),%edx
    0.00 :	    5fd0:       81 c7 f4 01 00 00 e8    mov    0x570(%r12),%rax
    0.00 :	    5fd7:       00 
    0.00 :	    5fd8:       00 00 00 49             add    $0x18,%rax
    0.00 :	    5fdc:       8d bc                   mov    (%rax),%eax
    0.00 :	    5fde:       24 98 03 00 00 48 89    cmpl   $0x1,0x8bc(%r12)
    0.00 :	    5fe5:       c6 e8 
    0.00 :	    5fe7:       00 00 00 00 e9 6b       jne    5eff <dma_unmap_page+0x5ecf>
    0.00 :	    5fed:       ff ff ff 49 8b          test   $0x800000,%eax
    0.00 :	    5ff2:       84 24 70 05 00 00       jne    5eff <dma_unmap_page+0x5ecf>
    0.00 :	    5ff8:       48 05 10                and    $0x1,%edx
    0.00 :	    5ffb:       81 00 00 8b 10 49       je     5eff <dma_unmap_page+0x5ecf>
    0.00 :	    6001:       8b 84 24 70 05 00 00    mov    $0x0,%rsi
    0.00 :	    6008:       48 83 c0                mov    %rbx,%rdi
    0.00 :	    600b:       18 8b                   xor    %eax,%eax
    0.00 :	    600d:       00 41 83 bc 24          callq  6012 <dma_unmap_page+0x5fe2>
    0.00 :	    6012:       bc 08 00 00 01          jmpq   5eff <dma_unmap_page+0x5ecf>
    0.00 :	    6017:       0f 85 12 ff ff          movzwl -0x28(%r14),%eax
    0.00 :	    601c:       ff a9 00 00             cmp    $0x64,%ax
    0.00 :	    6020:       80 00 0f 85 07 ff       je     60f2 <dma_unmap_page+0x60c2>
    0.00 :	    6026:       ff ff 83                xor    %r13d,%r13d
    0.00 :	    6029:       e2 01 0f 84             cmp    $0x3e8,%ax
    0.00 :	    602d:       fe fe ff                nopl   (%rax)
    0.00 :	    6030:       ff 48 c7 c6 00 00       je     60db <dma_unmap_page+0x60ab>
    0.00 :	    6036:       00 00 48 89 df 31 c0    mov    0x4a0(%r12),%rdi
    0.00 :	    603d:       e8 
    0.00 :	    603e:       00 00 00 00 e9 e8 fe    movl   $0x0,0xee0(%r12)
    0.00 :	    6045:       ff ff 41 0f b7 
    0.00 :	    604a:       46 d8 66 83 f8 64 0f    mov    $0x0,%rsi
    0.00 :	    6051:       84 cc                   xor    %eax,%eax
    0.00 :	    6053:       00 00 00 45 31 ed       mov    $0x1,%r15d
    0.00 :	    6059:       66 3d e8 03 0f 1f 00    add    $0x90,%rdi
    0.00 :	    6060:       0f 84 a5 00 00          callq  6065 <dma_unmap_page+0x6035>
    0.00 :	    6065:       00 49 8b bc 24 a0 04    mov    0xed4(%r12),%eax
    0.00 :	    606c:       00 
    0.00 :	    606d:       00 41                   test   %eax,%eax
    0.00 :	    606f:       c7 84 24 e0 0e 00       je     5e8c <dma_unmap_page+0x5e5c>
    0.00 :	    6075:       00 00                   xor    %ebx,%ebx
    0.00 :	    6077:       00 00                   jmp    60b7 <dma_unmap_page+0x6087>
    0.00 :	    6079:       00 48 c7 c6 00 00 00    nopl   0x0(%rax)
    0.00 :	    6080:       00 31 c0                movslq %ebx,%rax
    0.00 :	    6083:       41 bf 01 00             lea    (%rax,%rax,2),%rdx
    0.00 :	    6087:       00 00 48 81             shl    $0x5,%rdx
    0.00 :	    608b:       c7 90 00 00 00 e8 00    mov    0xed8(%r12),%rax
    0.00 :	    6092:       00 
    0.00 :	    6093:       00 00 41 8b             mov    (%rsp),%rdi
    0.00 :	    6097:       84 24                   mov    %ebx,%esi
    0.00 :	    6099:       d4 0e 00                mov    %r13d,%ecx
    0.00 :	    609c:       00 85 c0                add    $0x1,%ebx
    0.00 :	    609f:       0f 84 17 fe ff          movzwl 0x5c(%rax,%rdx,1),%edx
    0.00 :	    60a4:       ff 31 db eb 3e          callq  1680 <dma_unmap_page+0x1650>
    0.00 :	    60a9:       0f 1f 80 00 00 00 00    cmp    %ebx,0xed4(%r12)
    0.00 :	    60b0:       48 
    0.00 :	    60b1:       63 c3 48 8d 14 40       jbe    5e8c <dma_unmap_page+0x5e5c>
    0.00 :	    60b7:       48 c1 e2                test   %r15b,%r15b
    0.00 :	    60ba:       05 49                   je     6080 <dma_unmap_page+0x6050>
    0.00 :	    60bc:       8b 84 24                movslq %ebx,%rax
    0.00 :	    60bf:       d8 0e 00 00             lea    (%rax,%rax,2),%rax
    0.00 :	    60c3:       48 8b 3c 24             shl    $0x5,%rax
    0.00 :	    60c7:       89 de 44                mov    %rax,%rdx
    0.00 :	    60ca:       89 e9 83 c3 01 0f b7    mov    0xed8(%r12),%rax
    0.00 :	    60d1:       54 
    0.00 :	    60d2:       10 5c e8 d7 b5 ff ff    movw   $0x0,0x5c(%rax,%rdx,1)
    0.00 :	    60d9:       41 39                   jmp    608b <dma_unmap_page+0x605b>
    0.00 :	    60db:       9c 24 d4 0e 00 00       mov    $0x3e8,%r13d
    0.00 :	    60e1:       0f 86 d5                xor    %r15d,%r15d
    0.00 :	    60e4:       fd ff ff                cmp    %r13d,%edx
    0.00 :	    60e7:       45 84 ff 74 c4 48       je     6065 <dma_unmap_page+0x6035>
    0.00 :	    60ed:       63 c3 48 8d 04          jmpq   6036 <dma_unmap_page+0x6006>
    0.00 :	    60f2:       40 48 c1 e0 05 48       mov    $0x64,%r13d
    0.00 :	    60f8:       89 c2                   jmp    60e1 <dma_unmap_page+0x60b1>
         :	    60fa:       49 8b 84 24 d8 0e       nopw   0x0(%rax,%rax,1)
         :	    6100:       00 00 66 c7             sub    $0x58,%rsp
         :	    6104:       44 10 5c 00 00          mov    %r12,0x38(%rsp)
         :	    6109:       eb b0 41 bd e8          mov    %r13,0x40(%rsp)
         :	    610e:       03 00 00                mov    %rdi,%r12
         :	    6111:       45 31 ff 44 39          mov    %rbx,0x28(%rsp)
         :	    6116:       ea 0f 84 78 ff          mov    %rbp,0x30(%rsp)
         :	    611b:       ff ff e9 44 ff ff ff    lea    0x568(%rdi),%r13
         :	    6122:       41 bd 64 00 00          mov    %r14,0x48(%rsp)
         :	    6127:       00 eb e7 66 0f          mov    %r15,0x50(%rsp)

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------
