
Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   59.65 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1097
   27.37 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
    6.32 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1082
    1.05 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1056
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1077
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1075
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbda0 <ExecScanHashBucket>:
         :	 * for the latter.
         :	 */
         :	bool
         :	ExecScanHashBucket(HashJoinState *hjstate,
         :	                                   ExprContext *econtext)
         :	{
    0.00 :	  5bbda0:       55                      push   %rbp
    0.00 :	  5bbda1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bbda4:       41 57                   push   %r15
    0.35 :	  5bbda6:       41 56                   push   %r14
    0.35 :	  5bbda8:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5bbdab:       41 55                   push   %r13
    0.00 :	  5bbdad:       41 54                   push   %r12
    0.00 :	  5bbdaf:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5bbdb2:       53                      push   %rbx
    0.00 :	  5bbdb3:       48 83 ec 08             sub    $0x8,%rsp
         :	        List       *hjclauses = hjstate->hashclauses;
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
         :	        HashJoinTuple hashTuple = hjstate->hj_CurTuple;
    0.35 :	  5bbdb7:       48 8b 87 c0 00 00 00    mov    0xc0(%rdi),%rax
         :	 */
         :	bool
         :	ExecScanHashBucket(HashJoinState *hjstate,
         :	                                   ExprContext *econtext)
         :	{
         :	        List       *hjclauses = hjstate->hashclauses;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1056
    0.70 :	  5bbdbe:       4c 8b bf 88 00 00 00    mov    0x88(%rdi),%r15
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bbdc5:       48 8b 8f a8 00 00 00    mov    0xa8(%rdi),%rcx
         :	        HashJoinTuple hashTuple = hjstate->hj_CurTuple;
         :	        uint32          hashvalue = hjstate->hj_CurHashValue;
    0.00 :	  5bbdcc:       44 8b af b0 00 00 00    mov    0xb0(%rdi),%r13d
         :	         * bucket, or NULL if it's time to start scanning a new bucket.
         :	         *
         :	         * If the tuple hashed to a skew bucket then scan the skew bucket
         :	         * otherwise scan the standard hashtable bucket.
         :	         */
         :	        if (hashTuple != NULL)
    0.00 :	  5bbdd3:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbdd6:       74 79                   je     5bbe51 <ExecScanHashBucket+0xb1>
         :	                hashTuple = hashTuple->next;
    0.00 :	  5bbdd8:       48 8b 18                mov    (%rax),%rbx
    0.00 :	  5bbddb:       eb 06                   jmp    5bbde3 <ExecScanHashBucket+0x43>
    0.00 :	  5bbddd:       0f 1f 00                nopl   (%rax)
         :	                                hjstate->hj_CurTuple = hashTuple;
         :	                                return true;
         :	                        }
         :	                }
         :
         :	                hashTuple = hashTuple->next;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1097
   59.65 :	  5bbde0:       48 8b 1b                mov    (%rbx),%rbx
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
         :
         :	        while (hashTuple != NULL)
    0.35 :	  5bbde3:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbde6:       74 58                   je     5bbe40 <ExecScanHashBucket+0xa0>
         :	        {
         :	                if (hashTuple->hashvalue == hashvalue)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1077
    0.70 :	  5bbde8:       44 39 6b 08             cmp    %r13d,0x8(%rbx)
    0.00 :	  5bbdec:       75 f2                   jne    5bbde0 <ExecScanHashBucket+0x40>
         :	                {
         :	                        TupleTableSlot *inntuple;
         :
         :	                        /* insert hashtable's tuple into exec slot so ExecQual sees it */
         :	                        inntuple = ExecStoreMinimalTuple(HJTUPLE_MINTUPLE(hashTuple),
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1082
    6.32 :	  5bbdee:       49 8b b4 24 d0 00 00    mov    0xd0(%r12),%rsi
    0.00 :	  5bbdf5:       00 
    0.35 :	  5bbdf6:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  5bbdfa:       31 d2                   xor    %edx,%edx
    0.35 :	  5bbdfc:       e8 df 85 ff ff          callq  5b43e0 <ExecStoreMinimalTuple>
         :	                                                                                         hjstate->hj_HashTupleSlot,
         :	                                                                                         false);        /* do not pfree */
         :	                        econtext->ecxt_innertuple = inntuple;
         :
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
    0.00 :	  5bbe01:       49 8b 7e 28             mov    0x28(%r14),%rdi
         :
         :	                        /* insert hashtable's tuple into exec slot so ExecQual sees it */
         :	                        inntuple = ExecStoreMinimalTuple(HJTUPLE_MINTUPLE(hashTuple),
         :	                                                                                         hjstate->hj_HashTupleSlot,
         :	                                                                                         false);        /* do not pfree */
         :	                        econtext->ecxt_innertuple = inntuple;
    0.00 :	  5bbe05:       49 89 46 10             mov    %rax,0x10(%r14)
         :
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
    0.00 :	  5bbe09:       e8 a2 cb 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                        if (ExecQual(hjclauses, econtext, false))
    0.00 :	  5bbe0e:       31 d2                   xor    %edx,%edx
    0.00 :	  5bbe10:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5bbe13:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bbe16:       e8 f5 10 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5bbe1b:       84 c0                   test   %al,%al
    0.00 :	  5bbe1d:       74 c1                   je     5bbde0 <ExecScanHashBucket+0x40>
         :	                        {
         :	                                hjstate->hj_CurTuple = hashTuple;
    0.00 :	  5bbe1f:       49 89 9c 24 c0 00 00    mov    %rbx,0xc0(%r12)
    0.00 :	  5bbe26:       00 
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe27:       48 83 c4 08             add    $0x8,%rsp
         :	                        /* reset temp memory each time to avoid leaks from qual expr */
         :	                        ResetExprContext(econtext);
         :
         :	                        if (ExecQual(hjclauses, econtext, false))
         :	                        {
         :	                                hjstate->hj_CurTuple = hashTuple;
    0.00 :	  5bbe2b:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe30:       5b                      pop    %rbx
    0.00 :	  5bbe31:       41 5c                   pop    %r12
    0.00 :	  5bbe33:       41 5d                   pop    %r13
    0.00 :	  5bbe35:       41 5e                   pop    %r14
    0.00 :	  5bbe37:       41 5f                   pop    %r15
    0.00 :	  5bbe39:       c9                      leaveq 
    0.00 :	  5bbe3a:       c3                      retq   
    0.00 :	  5bbe3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    1.05 :	  5bbe40:       48 83 c4 08             add    $0x8,%rsp
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
         :
         :	        while (hashTuple != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1075
    0.70 :	  5bbe44:       31 c0                   xor    %eax,%eax
         :
         :	        /*
         :	         * no match
         :	         */
         :	        return false;
         :	}
    0.00 :	  5bbe46:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1104
    0.70 :	  5bbe47:       41 5c                   pop    %r12
    0.35 :	  5bbe49:       41 5d                   pop    %r13
    0.00 :	  5bbe4b:       41 5e                   pop    %r14
    0.00 :	  5bbe4d:       41 5f                   pop    %r15
    0.00 :	  5bbe4f:       c9                      leaveq 
    0.00 :	  5bbe50:       c3                      retq   
         :	         * If the tuple hashed to a skew bucket then scan the skew bucket
         :	         * otherwise scan the standard hashtable bucket.
         :	         */
         :	        if (hashTuple != NULL)
         :	                hashTuple = hashTuple->next;
         :	        else if (hjstate->hj_CurSkewBucketNo != INVALID_SKEW_BUCKET_NO)
    0.00 :	  5bbe51:       8b 87 b8 00 00 00       mov    0xb8(%rdi),%eax
    0.00 :	  5bbe57:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  5bbe5a:       74 13                   je     5bbe6f <ExecScanHashBucket+0xcf>
         :	                hashTuple = hashtable->skewBucket[hjstate->hj_CurSkewBucketNo]->tuples;
    0.00 :	  5bbe5c:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  5bbe60:       48 98                   cltq   
    0.00 :	  5bbe62:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  5bbe66:       48 8b 58 08             mov    0x8(%rax),%rbx
    0.00 :	  5bbe6a:       e9 74 ff ff ff          jmpq   5bbde3 <ExecScanHashBucket+0x43>
         :	        else
         :	                hashTuple = hashtable->buckets[hjstate->hj_CurBucketNo];
    0.35 :	  5bbe6f:       48 63 97 b4 00 00 00    movslq 0xb4(%rdi),%rdx
    0.00 :	  5bbe76:       48 8b 41 18             mov    0x18(%rcx),%rax
    0.00 :	  5bbe7a:       48 8b 1c d0             mov    (%rax,%rdx,8),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1073
   27.37 :	  5bbe7e:       e9 60 ff ff ff          jmpq   5bbde3 <ExecScanHashBucket+0x43>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   48.95 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:415
   17.48 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:401
    5.59 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:398
    2.10 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:468
    2.10 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:468
    2.10 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:389
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:468
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:450
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:450
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:450
    1.40 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:433
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:388
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:388
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:388
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:388
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:390
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:401
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:415
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:424
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:468
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:456
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:460
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004acc50 <_bt_compare>:
         :	_bt_compare(Relation rel,
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        Page page,
         :	                        OffsetNumber offnum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:388
    0.70 :	  4acc50:       55                      push   %rbp
    0.00 :	  4acc51:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4acc54:       41 57                   push   %r15
    0.70 :	  4acc56:       41 89 f7                mov    %esi,%r15d
    0.00 :	  4acc59:       41 56                   push   %r14
    0.00 :	  4acc5b:       41 55                   push   %r13
    0.70 :	  4acc5d:       41 54                   push   %r12
    0.00 :	  4acc5f:       53                      push   %rbx
    0.70 :	  4acc60:       48 89 d3                mov    %rdx,%rbx
    0.00 :	  4acc63:       48 83 ec 08             sub    $0x8,%rsp
         :	        TupleDesc       itupdesc = RelationGetDescr(rel);
         :	        BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4acc67:       0f b7 41 10             movzwl 0x10(%rcx),%eax
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        Page page,
         :	                        OffsetNumber offnum)
         :	{
         :	        TupleDesc       itupdesc = RelationGetDescr(rel);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:389
    1.40 :	  4acc6b:       4c 8b 77 38             mov    0x38(%rdi),%r14
         :	        BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:390
    0.70 :	  4acc6f:       48 8d 04 01             lea    (%rcx,%rax,1),%rax
         :
         :	        /*
         :	         * Force result ">" if target item is first data item on an internal page
         :	         * --- see NOTE above.
         :	         */
         :	        if (!P_ISLEAF(opaque) && offnum == P_FIRSTDATAKEY(opaque))
    0.00 :	  4acc73:       f6 40 0c 01             testb  $0x1,0xc(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:398
    5.59 :	  4acc77:       75 1a                   jne    4acc93 <_bt_compare+0x43>
    0.00 :	  4acc79:       83 78 04 01             cmpl   $0x1,0x4(%rax)
    0.00 :	  4acc7d:       41 0f b7 d0             movzwl %r8w,%edx
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
         :	                        return result;
         :
         :	                scankey++;
    0.00 :	  4acc81:       be 01 00 00 00          mov    $0x1,%esi
         :
         :	        /*
         :	         * Force result ">" if target item is first data item on an internal page
         :	         * --- see NOTE above.
         :	         */
         :	        if (!P_ISLEAF(opaque) && offnum == P_FIRSTDATAKEY(opaque))
    0.00 :	  4acc86:       19 c0                   sbb    %eax,%eax
    0.00 :	  4acc88:       83 c0 02                add    $0x2,%eax
    0.00 :	  4acc8b:       39 c2                   cmp    %eax,%edx
    0.00 :	  4acc8d:       0f 84 ab 00 00 00       je     4acd3e <_bt_compare+0xee>
         :	                return 1;
         :
         :	        itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:401
    0.70 :	  4acc93:       41 0f b7 c0             movzwl %r8w,%eax
    0.00 :	  4acc97:       0f b7 44 81 14          movzwl 0x14(%rcx,%rax,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:401
   17.48 :	  4acc9c:       25 ff 7f 00 00          and    $0x7fff,%eax
         :	         * We don't test for violation of this condition here, however.  The
         :	         * initial setup for the index scan had better have gotten it right (see
         :	         * _bt_first).
         :	         */
         :
         :	        for (i = 1; i <= keysz; i++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:415
    0.70 :	  4acca1:       45 85 ff                test   %r15d,%r15d
         :	         * --- see NOTE above.
         :	         */
         :	        if (!P_ISLEAF(opaque) && offnum == P_FIRSTDATAKEY(opaque))
         :	                return 1;
         :
         :	        itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));
    0.00 :	  4acca4:       4c 8d 24 01             lea    (%rcx,%rax,1),%r12
         :	         * We don't test for violation of this condition here, however.  The
         :	         * initial setup for the index scan had better have gotten it right (see
         :	         * _bt_first).
         :	         */
         :
         :	        for (i = 1; i <= keysz; i++)
    0.00 :	  4acca8:       0f 8e a2 01 00 00       jle    4ace50 <_bt_compare+0x200>
         :	        {
         :	                Datum           datum;
         :	                bool            isNull;
         :	                int32           result;
         :
         :	                datum = index_getattr(itup, scankey->sk_attno, itupdesc, &isNull);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 :	  4accae:       66 41 83 7c 24 06 00    cmpw   $0x0,0x6(%r12)
         :	         * We don't test for violation of this condition here, however.  The
         :	         * initial setup for the index scan had better have gotten it right (see
         :	         * _bt_first).
         :	         */
         :
         :	        for (i = 1; i <= keysz; i++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:415
   48.95 :	  4accb5:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	        {
         :	                Datum           datum;
         :	                bool            isNull;
         :	                int32           result;
         :
         :	                datum = index_getattr(itup, scankey->sk_attno, itupdesc, &isNull);
    0.00 :	  4accbb:       0f 88 d4 00 00 00       js     4acd95 <_bt_compare+0x145>
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 :	  4accc1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  4accc8:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
    0.00 :	  4acccc:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  4accd0:       48 0f bf d1             movswq %cx,%rdx
    0.70 :	  4accd4:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    0.00 :	  4accd9:       8b 42 54                mov    0x54(%rdx),%eax
    0.70 :	  4accdc:       85 c0                   test   %eax,%eax
    0.00 :	  4accde:       0f 88 2c 01 00 00       js     4ace10 <_bt_compare+0x1c0>
    0.00 :	  4acce4:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.70 :	  4acce8:       0f 84 0a 01 00 00       je     4acdf8 <_bt_compare+0x1a8>
    0.00 :	  4accee:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  4accf2:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  4accf6:       0f 84 1c 01 00 00       je     4ace18 <_bt_compare+0x1c8>
    0.70 :	  4accfc:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  4acd00:       0f 84 2a 01 00 00       je     4ace30 <_bt_compare+0x1e0>
    0.00 :	  4acd06:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  4acd0a:       0f 84 30 01 00 00       je     4ace40 <_bt_compare+0x1f0>
    0.00 :	  4acd10:       48 98                   cltq   
    0.00 :	  4acd12:       31 d2                   xor    %edx,%edx
    0.00 :	  4acd14:       45 0f b6 44 04 08       movzbl 0x8(%r12,%rax,1),%r8d
    0.00 :	  4acd1a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /* see comments about NULLs handling in btbuild */
         :	                if (scankey->sk_flags & SK_ISNULL)              /* key is NULL */
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:424
    0.70 :	  4acd20:       8b 03                   mov    (%rbx),%eax
    0.00 :	  4acd22:       a8 01                   test   $0x1,%al
    0.00 :	  4acd24:       0f 84 ae 00 00 00       je     4acdd8 <_bt_compare+0x188>
         :	                {
         :	                        if (isNull)
    0.00 :	  4acd2a:       84 d2                   test   %dl,%dl
    0.00 :	  4acd2c:       75 49                   jne    4acd77 <_bt_compare+0x127>
         :	                                result = 0;             /* NULL "=" NULL */
         :	                        else if (scankey->sk_flags & SK_BT_NULLS_FIRST)
    0.00 :	  4acd2e:       a9 00 00 00 02          test   $0x2000000,%eax
    0.00 :	  4acd33:       0f 84 b2 00 00 00       je     4acdeb <_bt_compare+0x19b>
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
         :	                        return result;
         :
         :	                scankey++;
    0.00 :	  4acd39:       be ff ff ff ff          mov    $0xffffffff,%esi
         :	        }
         :
         :	        /* if we get here, the keys are equal */
         :	        return 0;
         :	}
    0.00 :	  4acd3e:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  4acd42:       89 f0                   mov    %esi,%eax
    0.00 :	  4acd44:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:468
    2.10 :	  4acd45:       41 5c                   pop    %r12
    2.10 :	  4acd47:       41 5d                   pop    %r13
    0.00 :	  4acd49:       41 5e                   pop    %r14
    0.00 :	  4acd4b:       41 5f                   pop    %r15
    0.70 :	  4acd4d:       c9                      leaveq 
    1.40 :	  4acd4e:       c3                      retq   
    0.00 :	  4acd4f:       90                      nop
         :	                         * types).  Since it is convenient for callers to think of
         :	                         * _bt_compare as comparing the scankey to the index item, we have
         :	                         * to flip the sign of the comparison result.  (Unless it's a DESC
         :	                         * column, in which case we *don't* flip the sign.)
         :	                         */
         :	                        result = DatumGetInt32(FunctionCall2Coll(&scankey->sk_func,
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:450
    1.40 :	  4acd50:       8b 73 0c                mov    0xc(%rbx),%esi
    0.00 :	  4acd53:       48 8b 4b 40             mov    0x40(%rbx),%rcx
    0.00 :	  4acd57:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  4acd5b:       4c 89 c2                mov    %r8,%rdx
    1.40 :	  4acd5e:       e8 cd 12 2d 00          callq  77e030 <FunctionCall2Coll>
    1.40 :	  4acd63:       89 c6                   mov    %eax,%esi
         :	                                                                                                         scankey->sk_collation,
         :	                                                                                                         datum,
         :	                                                                                                         scankey->sk_argument));
         :
         :	                        if (!(scankey->sk_flags & SK_BT_DESC))
    0.00 :	  4acd65:       8b 03                   mov    (%rbx),%eax
         :	                                result = -result;
    0.00 :	  4acd67:       89 f2                   mov    %esi,%edx
    0.00 :	  4acd69:       f7 da                   neg    %edx
    0.00 :	  4acd6b:       a9 00 00 00 01          test   $0x1000000,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:456
    0.70 :	  4acd70:       0f 44 f2                cmove  %edx,%esi
         :	                }
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:460
    0.70 :	  4acd73:       85 f6                   test   %esi,%esi
    0.00 :	  4acd75:       75 c7                   jne    4acd3e <_bt_compare+0xee>
         :	         * We don't test for violation of this condition here, however.  The
         :	         * initial setup for the index scan had better have gotten it right (see
         :	         * _bt_first).
         :	         */
         :
         :	        for (i = 1; i <= keysz; i++)
    0.00 :	  4acd77:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  4acd7b:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  4acd7e:       0f 8c cc 00 00 00       jl     4ace50 <_bt_compare+0x200>
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
         :	                        return result;
         :
         :	                scankey++;
    0.00 :	  4acd84:       48 83 c3 48             add    $0x48,%rbx
         :	        {
         :	                Datum           datum;
         :	                bool            isNull;
         :	                int32           result;
         :
         :	                datum = index_getattr(itup, scankey->sk_attno, itupdesc, &isNull);
    0.00 :	  4acd88:       66 41 83 7c 24 06 00    cmpw   $0x0,0x6(%r12)
    0.00 :	  4acd8f:       0f 89 33 ff ff ff       jns    4accc8 <_bt_compare+0x78>
    0.00 :	  4acd95:       0f bf 73 04             movswl 0x4(%rbx),%esi
    0.00 :	  4acd99:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4acd9c:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4acda1:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  4acda4:       89 c8                   mov    %ecx,%eax
    0.00 :	  4acda6:       83 e1 07                and    $0x7,%ecx
    0.00 :	  4acda9:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4acdac:       48 98                   cltq   
    0.00 :	  4acdae:       41 0f be 44 04 08       movsbl 0x8(%r12,%rax,1),%eax
    0.00 :	  4acdb4:       d3 f8                   sar    %cl,%eax
    0.00 :	  4acdb6:       a8 01                   test   $0x1,%al
    0.00 :	  4acdb8:       0f 84 62 ff ff ff       je     4acd20 <_bt_compare+0xd0>
    0.00 :	  4acdbe:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  4acdc1:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4acdc4:       e8 97 3d fc ff          callq  470b60 <nocache_index_getattr>
    0.00 :	  4acdc9:       49 89 c0                mov    %rax,%r8
         :
         :	                /* see comments about NULLs handling in btbuild */
         :	                if (scankey->sk_flags & SK_ISNULL)              /* key is NULL */
    0.00 :	  4acdcc:       8b 03                   mov    (%rbx),%eax
         :	        {
         :	                Datum           datum;
         :	                bool            isNull;
         :	                int32           result;
         :
         :	                datum = index_getattr(itup, scankey->sk_attno, itupdesc, &isNull);
    0.00 :	  4acdce:       31 d2                   xor    %edx,%edx
         :
         :	                /* see comments about NULLs handling in btbuild */
         :	                if (scankey->sk_flags & SK_ISNULL)              /* key is NULL */
    0.00 :	  4acdd0:       a8 01                   test   $0x1,%al
    0.00 :	  4acdd2:       0f 85 52 ff ff ff       jne    4acd2a <_bt_compare+0xda>
         :	                        else if (scankey->sk_flags & SK_BT_NULLS_FIRST)
         :	                                result = -1;    /* NULL "<" NOT_NULL */
         :	                        else
         :	                                result = 1;             /* NULL ">" NOT_NULL */
         :	                }
         :	                else if (isNull)                /* key is NOT_NULL and item is NULL */
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:433
    1.40 :	  4acdd8:       84 d2                   test   %dl,%dl
    0.00 :	  4acdda:       0f 84 70 ff ff ff       je     4acd50 <_bt_compare+0x100>
         :	                {
         :	                        if (scankey->sk_flags & SK_BT_NULLS_FIRST)
    0.00 :	  4acde0:       a9 00 00 00 02          test   $0x2000000,%eax
    0.00 :	  4acde5:       0f 84 4e ff ff ff       je     4acd39 <_bt_compare+0xe9>
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
         :	                        return result;
         :
         :	                scankey++;
    0.00 :	  4acdeb:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4acdf0:       e9 49 ff ff ff          jmpq   4acd3e <_bt_compare+0xee>
    0.00 :	  4acdf5:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                Datum           datum;
         :	                bool            isNull;
         :	                int32           result;
         :
         :	                datum = index_getattr(itup, scankey->sk_attno, itupdesc, &isNull);
    0.00 :	  4acdf8:       48 98                   cltq   
    0.00 :	  4acdfa:       31 d2                   xor    %edx,%edx
    0.00 :	  4acdfc:       4d 8d 44 04 08          lea    0x8(%r12,%rax,1),%r8
    0.00 :	  4ace01:       e9 1a ff ff ff          jmpq   4acd20 <_bt_compare+0xd0>
    0.00 :	  4ace06:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ace0d:       00 00 00 
    0.00 :	  4ace10:       0f bf f1                movswl %cx,%esi
    0.00 :	  4ace13:       eb a9                   jmp    4acdbe <_bt_compare+0x16e>
    0.00 :	  4ace15:       0f 1f 00                nopl   (%rax)
    0.00 :	  4ace18:       48 98                   cltq   
    0.00 :	  4ace1a:       31 d2                   xor    %edx,%edx
    0.00 :	  4ace1c:       4d 8b 44 04 08          mov    0x8(%r12,%rax,1),%r8
    0.00 :	  4ace21:       e9 fa fe ff ff          jmpq   4acd20 <_bt_compare+0xd0>
    0.00 :	  4ace26:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ace2d:       00 00 00 
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:421
    0.70 :	  4ace30:       48 98                   cltq   
    0.70 :	  4ace32:       31 d2                   xor    %edx,%edx
    2.10 :	  4ace34:       45 8b 44 04 08          mov    0x8(%r12,%rax,1),%r8d
    0.00 :	  4ace39:       e9 e2 fe ff ff          jmpq   4acd20 <_bt_compare+0xd0>
    0.00 :	  4ace3e:       66 90                   xchg   %ax,%ax
    0.00 :	  4ace40:       48 98                   cltq   
    0.00 :	  4ace42:       31 d2                   xor    %edx,%edx
    0.00 :	  4ace44:       45 0f b7 44 04 08       movzwl 0x8(%r12,%rax,1),%r8d
    0.00 :	  4ace4a:       e9 d1 fe ff ff          jmpq   4acd20 <_bt_compare+0xd0>
    0.00 :	  4ace4f:       90                      nop
         :
         :	                /* if the keys are unequal, return the difference */
         :	                if (result != 0)
         :	                        return result;
         :
         :	                scankey++;
    0.00 :	  4ace50:       31 f6                   xor    %esi,%esi
    0.00 :	  4ace52:       e9 e7 fe ff ff          jmpq   4acd3e <_bt_compare+0xee>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.70 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
   20.93 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
   11.63 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    4.65 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    2.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:679
    2.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:710
    2.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:828
    2.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:800
    2.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:801
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:679
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:779
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:782
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:782
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:702
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:702
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:702
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:798
    1.16 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:826
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782ca0 <CHashBucketScan>:
         :	CHashBucketScan(CHashTable table,
         :	                                CHashPtr *start,
         :	                                uint32 hashcode,
         :	                                const void *key,
         :	                                CHashScanResult *res)
         :	{
    0.00 :	  782ca0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:679
    2.33 :	  782ca1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782ca4:       41 57                   push   %r15
    0.00 :	  782ca6:       41 89 d7                mov    %edx,%r15d
    0.00 :	  782ca9:       41 56                   push   %r14
    1.16 :	  782cab:       41 55                   push   %r13
    0.00 :	  782cad:       49 89 fd                mov    %rdi,%r13
    0.00 :	  782cb0:       41 54                   push   %r12
    0.00 :	  782cb2:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  782cb5:       53                      push   %rbx
    0.00 :	  782cb6:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  782cba:       48 89 75 d0             mov    %rsi,-0x30(%rbp)
    0.00 :	  782cbe:       48 89 4d c8             mov    %rcx,-0x38(%rbp)
    0.00 :	  782cc2:       4c 89 45 c0             mov    %r8,-0x40(%rbp)
         :	        CHashPtr   *pointer_to_target;
         :	        CHashNode  *target_node = NULL;
         :
         :	retry:
         :	        pointer_to_target = start;
         :	        target = *pointer_to_target;
    0.00 :	  782cc6:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  782cca:       44 8b 10                mov    (%rax),%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:697
   20.93 :	  782ccd:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cd1:       0f 87 ff 00 00 00       ja     782dd6 <CHashBucketScan+0x136>
         :	                {
         :	                        res->found = false;
         :	                        break;
    0.00 :	  782cd7:       4c 8b 75 d0             mov    -0x30(%rbp),%r14
    0.00 :	  782cdb:       eb 21                   jmp    782cfe <CHashBucketScan+0x5e>
    0.00 :	  782cdd:       0f 1f 00                nopl   (%rax)
         :	                /*
         :	                 * Bucket chains are kept in order, so that there is exactly one legal
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
    0.00 :	  782ce0:       41 8b 44 24 04          mov    0x4(%r12),%eax
         :	                if (h == hashcode)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:779
    1.16 :	  782ce5:       44 39 f8                cmp    %r15d,%eax
    0.00 :	  782ce8:       74 5e                   je     782d48 <CHashBucketScan+0xa8>
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
         :	                                                 table->desc.key_size);
         :	                else if (h > hashcode)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:782
    1.16 :	  782cea:       41 39 c7                cmp    %eax,%r15d
    1.16 :	  782ced:       0f 1f 00                nopl   (%rax)
    0.00 :	  782cf0:       72 7b                   jb     782d6d <CHashBucketScan+0xcd>
         :	                                break;
         :	                        }
         :	                }
         :
         :	                /* Continue scan from next node. */
         :	                pointer_to_target = &target_node->next;
    0.00 :	  782cf2:       4d 89 e6                mov    %r12,%r14
    0.00 :	  782cf5:       45 89 c2                mov    %r8d,%r10d
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782cf8:       41 83 fa fd             cmp    $0xfffffffd,%r10d
    0.00 :	  782cfc:       77 79                   ja     782d77 <CHashBucketScan+0xd7>
         :	                {
         :	                        res->found = false;
         :	                        break;
         :	                }
         :	                target_node = CHashTableGetNode(table, target);
    0.00 :	  782cfe:       44 89 d0                mov    %r10d,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:702
    1.16 :	  782d01:       d1 e8                   shr    %eax
    1.16 :	  782d03:       41 89 c4                mov    %eax,%r12d
    0.00 :	  782d06:       45 0f af 65 1c          imul   0x1c(%r13),%r12d
    1.16 :	  782d0b:       4d 03 65 30             add    0x30(%r13),%r12
         :	                 * target may have been fetched from an arena entry that could be
         :	                 * concurrently modified, so a dependency barrier is required before
         :	                 * dereferencing the derived pointer.
         :	                 */
         :	                pg_read_barrier_depends();
         :	                next = target_node->next;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:710
    2.33 :	  782d0f:       45 8b 04 24             mov    (%r12),%r8d
         :	                 * ensures that delete-marked elements are removed from bucket chains
         :	                 * as quickly as possible and reduces code duplication.  See
         :	                 * CHashDelete for further comments about why delete-marking is
         :	                 * necessary and how it allows safe deletion.
         :	                 */
         :	                if (CHashPtrIsMarked(next))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:720
   40.70 :	  782d13:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d17:       74 c7                   je     782ce0 <CHashBucketScan+0x40>
         :	                {
         :	zap:
         :	                        if (__sync_bool_compare_and_swap(pointer_to_target,
    0.00 :	  782d19:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  782d1c:       44 89 d0                mov    %r10d,%eax
    0.00 :	  782d1f:       83 e3 fe                and    $0xfffffffe,%ebx
    0.00 :	  782d22:       f0 41 0f b1 1e          lock cmpxchg %ebx,(%r14)
    0.00 :	  782d27:       74 77                   je     782da0 <CHashBucketScan+0x100>
         :	                                 * the node which precedes it before we advance to the next
         :	                                 * node.  That could certainly happen occasionally, but we'd
         :	                                 * have to be pretty unlucky to have it happen even twice in
         :	                                 * a row.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge_Fail);
    0.00 :	  782d29:       49 83 85 88 00 00 00    addq   $0x1,0x88(%r13)
    0.00 :	  782d30:       01 
         :	                                target = *pointer_to_target;
    0.00 :	  782d31:       45 8b 16                mov    (%r14),%r10d
         :	                                if (CHashPtrIsMarked(target))
    0.00 :	  782d34:       41 f6 c2 01             test   $0x1,%r10b
    0.00 :	  782d38:       74 be                   je     782cf8 <CHashBucketScan+0x58>
         :	                                {
         :	                                        CHashTableIncrementStatistic(table, CHS_Scan_Restart);
    0.00 :	  782d3a:       49 83 85 90 00 00 00    addq   $0x1,0x90(%r13)
    0.00 :	  782d41:       01 
         :	                                        goto retry;
    0.00 :	  782d42:       eb 82                   jmp    782cc6 <CHashBucketScan+0x26>
    0.00 :	  782d44:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * point at which any given key can be inserted.  The ordering is by
         :	                 * hashcode first, and then by memcmp ordering of the keys involved.
         :	                 */
         :	                h = target_node->un.hashcode;
         :	                if (h == hashcode)
         :	                        cmp = memcmp(CHashNodeGetItem(target_node), key,
    0.00 :	  782d48:       41 0f b7 4d 0e          movzwl 0xe(%r13),%ecx
    0.00 :	  782d4d:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  782d51:       49 8d 74 24 08          lea    0x8(%r12),%rsi
    0.00 :	  782d56:       48 39 c9                cmp    %rcx,%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
    4.65 :	  782d59:       f3 a6                   repz cmpsb %es:(%rdi),%ds:(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:780
   11.63 :	  782d5b:       0f 97 c0                seta   %al
    0.00 :	  782d5e:       0f 92 c2                setb   %dl
    0.00 :	  782d61:       28 d0                   sub    %dl,%al
    0.00 :	  782d63:       0f be c0                movsbl %al,%eax
         :	                 * the point where we expect to find the key OR someone delete-marked
         :	                 * the item and overwrote the hashcode with a gcnext pointer.  In the
         :	                 * latter case we must take care not to be fooled into stopping the
         :	                 * scan early.
         :	                 */
         :	                if (cmp >= 0)
    0.00 :	  782d66:       83 f8 00                cmp    $0x0,%eax
    0.00 :	  782d69:       7c 87                   jl     782cf2 <CHashBucketScan+0x52>
         :	                {
         :	                        if (cmp == 0)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:798
    1.16 :	  782d6b:       74 5b                   je     782dc8 <CHashBucketScan+0x128>
         :	                                /*
         :	                                 * pg_read_barrier() prevents the reread of the next pointer
         :	                                 * from being speculated ahead of the read of the hash value.
         :	                                 */
         :	                                pg_read_barrier();
         :	                                next = target_node->next;
    0.00 :	  782d6d:       45 8b 04 24             mov    (%r12),%r8d
         :	                                if (CHashPtrIsMarked(next))
    0.00 :	  782d71:       41 f6 c0 01             test   $0x1,%r8b
    0.00 :	  782d75:       75 a2                   jne    782d19 <CHashBucketScan+0x79>
         :	                                        goto zap;
         :	                                res->found = false;
    0.00 :	  782d77:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  782d7b:       c6 47 18 00             movb   $0x0,0x18(%rdi)
         :	                pointer_to_target = &target_node->next;
         :	                target = next;
         :	        }
         :
         :	        /* Send results back to caller. */
         :	        res->target = target;
    0.00 :	  782d7f:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  782d83:       44 89 10                mov    %r10d,(%rax)
         :	        res->pointer_to_target = pointer_to_target;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:826
    1.16 :	  782d86:       4c 89 70 08             mov    %r14,0x8(%rax)
         :	        res->target_node = target_node;
    0.00 :	  782d8a:       4c 89 60 10             mov    %r12,0x10(%rax)
         :	}
    0.00 :	  782d8e:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  782d92:       5b                      pop    %rbx
    0.00 :	  782d93:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:828
    2.33 :	  782d95:       41 5d                   pop    %r13
    0.00 :	  782d97:       41 5e                   pop    %r14
    0.00 :	  782d99:       41 5f                   pop    %r15
    0.00 :	  782d9b:       c9                      leaveq 
    0.00 :	  782d9c:       c3                      retq   
    0.00 :	  782d9d:       0f 1f 00                nopl   (%rax)
         :	                                 * delete-mark has been applied.  Thus, if we just keep
         :	                                 * following the next pointers, we're guaranteed to visit
         :	                                 * all non-deleted items (and possibly some deleted items)
         :	                                 * that were present at the time we began the scan.
         :	                                 */
         :	                                CHashTableIncrementStatistic(table, CHS_Scan_Expunge);
    0.00 :	  782da0:       49 83 85 80 00 00 00    addq   $0x1,0x80(%r13)
    0.00 :	  782da7:       01 
         :	                                CHashAddToGarbage(table, hashcode & table->bucket_mask,
    0.00 :	  782da8:       44 89 fe                mov    %r15d,%esi
    0.00 :	  782dab:       41 23 75 10             and    0x10(%r13),%esi
    0.00 :	  782daf:       44 89 d2                mov    %r10d,%edx
    0.00 :	  782db2:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  782db5:       e8 96 fe ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  782dba:       41 89 da                mov    %ebx,%r10d
    0.00 :	  782dbd:       e9 36 ff ff ff          jmpq   782cf8 <CHashBucketScan+0x58>
    0.00 :	  782dc2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 */
         :	                if (cmp >= 0)
         :	                {
         :	                        if (cmp == 0)
         :	                        {
         :	                                res->found = true;
    0.00 :	  782dc8:       48 8b 45 c0             mov    -0x40(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:800
    2.33 :	  782dcc:       c6 40 18 01             movb   $0x1,0x18(%rax)
         :	                                res->next = next;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:801
    2.33 :	  782dd0:       44 89 40 04             mov    %r8d,0x4(%rax)
         :	                                break;
    0.00 :	  782dd4:       eb a9                   jmp    782d7f <CHashBucketScan+0xdf>
         :
         :	                /*
         :	                 * If we've reached the end of the bucket chain, stop; otherwise,
         :	                 * figure out the actual address of the next item.
         :	                 */
         :	                if (CHashPtrIsInvalid(target))
    0.00 :	  782dd6:       49 89 c6                mov    %rax,%r14
    0.00 :	  782dd9:       eb 9c                   jmp    782d77 <CHashBucketScan+0xd7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   10.53 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1139
    3.95 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1099
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1095
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    2.63 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1055
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1055
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1068
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1085
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1085
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1098
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1123
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046ef10 <slot_deform_tuple>:
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1049
    1.32 :	  46ef10:       55                      push   %rbp
    1.32 :	  46ef11:       48 89 e5                mov    %rsp,%rbp
    2.63 :	  46ef14:       41 57                   push   %r15
    0.00 :	  46ef16:       41 89 f7                mov    %esi,%r15d
    0.00 :	  46ef19:       41 56                   push   %r14
    0.00 :	  46ef1b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  46ef1e:       41 55                   push   %r13
    0.00 :	  46ef20:       41 54                   push   %r12
    0.00 :	  46ef22:       53                      push   %rbx
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef23:       31 db                   xor    %ebx,%ebx
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    1.32 :	  46ef25:       48 83 ec 28             sub    $0x28,%rsp
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
    0.00 :	  46ef29:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  46ef2d:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46ef31:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
    0.00 :	  46ef35:       8b 77 24                mov    0x24(%rdi),%esi
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
         :	        HeapTuple       tuple = slot->tts_tuple;
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
    0.00 :	  46ef38:       4c 8b 5f 30             mov    0x30(%rdi),%r11
         :	        HeapTupleHeader tup = tuple->t_data;
    0.00 :	  46ef3c:       4c 8b 40 10             mov    0x10(%rax),%r8
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1055
    1.32 :	  46ef40:       41 0f b7 40 14          movzwl 0x14(%r8),%eax
    1.32 :	  46ef45:       83 e0 01                and    $0x1,%eax
    0.00 :	  46ef48:       41 89 c2                mov    %eax,%r10d
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef4b:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1068
    1.32 :	  46ef4f:       31 ff                   xor    %edi,%edi
    0.00 :	  46ef51:       85 f6                   test   %esi,%esi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
         :	        Datum      *values = slot->tts_values;
         :	        bool       *isnull = slot->tts_isnull;
         :	        HeapTupleHeader tup = tuple->t_data;
         :	        bool            hasnulls = HeapTupleHasNulls(tuple);
         :	        Form_pg_attribute *att = tupleDesc->attrs;
    0.00 :	  46ef53:       4c 8b 48 08             mov    0x8(%rax),%r9
         :	        /*
         :	         * Check whether the first call for this tuple, and initialize or restore
         :	         * loop state.
         :	         */
         :	        attnum = slot->tts_nvalid;
         :	        if (attnum == 0)
    0.00 :	  46ef57:       74 09                   je     46ef62 <slot_deform_tuple+0x52>
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
    0.00 :	  46ef59:       41 0f b6 7e 07          movzbl 0x7(%r14),%edi
         :	                slow = false;
         :	        }
         :	        else
         :	        {
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
    0.00 :	  46ef5e:       49 8b 5e 58             mov    0x58(%r14),%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef62:       41 0f b6 40 16          movzbl 0x16(%r8),%eax
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46ef67:       44 39 fe                cmp    %r15d,%esi
         :	                /* Restore state from previous execution */
         :	                off = slot->tts_off;
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
    0.00 :	  46ef6a:       4d 8d 2c 00             lea    (%r8,%rax,1),%r13
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46ef6e:       0f 8d c0 00 00 00       jge    46f034 <slot_deform_tuple+0x124>
    0.00 :	  46ef74:       41 89 f4                mov    %esi,%r12d
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    2.63 :	  46ef77:       eb 40                   jmp    46efb9 <slot_deform_tuple+0xa9>
    0.00 :	  46ef79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
    0.00 :	  46ef80:       44 89 e0                mov    %r12d,%eax
    0.00 :	  46ef83:       44 89 e1                mov    %r12d,%ecx
    0.00 :	  46ef86:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46ef89:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46ef8c:       48 98                   cltq   
    0.00 :	  46ef8e:       41 0f b6 44 00 17       movzbl 0x17(%r8,%rax,1),%eax
    0.00 :	  46ef94:       d3 f8                   sar    %cl,%eax
    0.00 :	  46ef96:       a8 01                   test   $0x1,%al
    0.00 :	  46ef98:       75 2b                   jne    46efc5 <slot_deform_tuple+0xb5>
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46ef9a:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
         :	                        isnull[attnum] = true;
    0.00 :	  46ef9e:       bf 01 00 00 00          mov    $0x1,%edi
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
         :	                {
         :	                        values[attnum] = (Datum) 0;
    0.00 :	  46efa3:       48 c7 04 f2 00 00 00    movq   $0x0,(%rdx,%rsi,8)
    0.00 :	  46efaa:       00 
         :	                        isnull[attnum] = true;
    0.00 :	  46efab:       41 c6 04 33 01          movb   $0x1,(%r11,%rsi,1)
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    1.32 :	  46efb0:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  46efb4:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46efb7:       7e 78                   jle    46f031 <slot_deform_tuple+0x121>
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1085
    1.32 :	  46efb9:       49 63 f4                movslq %r12d,%rsi
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    2.63 :	  46efbc:       45 84 d2                test   %r10b,%r10b
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
         :	        {
         :	                Form_pg_attribute thisatt = att[attnum];
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1085
    1.32 :	  46efbf:       49 8b 14 f1             mov    (%r9,%rsi,8),%rdx
         :
         :	                if (hasnulls && att_isnull(attnum, bp))
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1087
    1.32 :	  46efc3:       75 bb                   jne    46ef80 <slot_deform_tuple+0x70>
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
    0.00 :	  46efc5:       40 84 ff                test   %dil,%dil
         :	                        isnull[attnum] = true;
         :	                        slow = true;            /* can't use attcacheoff anymore */
         :	                        continue;
         :	                }
         :
         :	                isnull[attnum] = false;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1095
    2.63 :	  46efc8:       41 c6 04 33 00          movb   $0x0,(%r11,%rsi,1)
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    5.26 :	  46efcd:       0f 85 7d 00 00 00       jne    46f050 <slot_deform_tuple+0x140>
    0.00 :	  46efd3:       8b 42 54                mov    0x54(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1097
    3.95 :	  46efd6:       85 c0                   test   %eax,%eax
    0.00 :	  46efd8:       78 76                   js     46f050 <slot_deform_tuple+0x140>
         :	                        off = thisatt->attcacheoff;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1098
    1.32 :	  46efda:       48 63 d8                movslq %eax,%rbx
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    3.95 :	  46efdd:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    3.95 :	  46efe1:       49 8d 44 1d 00          lea    0x0(%r13,%rbx,1),%rax
    3.95 :	  46efe6:       74 28                   je     46f010 <slot_deform_tuple+0x100>
    1.32 :	  46efe8:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    1.32 :	  46efec:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  46eff0:       0f 84 3a 01 00 00       je     46f130 <slot_deform_tuple+0x220>
    1.32 :	  46eff6:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  46effa:       0f 84 90 01 00 00       je     46f190 <slot_deform_tuple+0x280>
    0.00 :	  46f000:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  46f004:       0f 84 a6 01 00 00       je     46f1b0 <slot_deform_tuple+0x2a0>
    0.00 :	  46f00a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
    2.63 :	  46f010:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
    1.32 :	  46f014:       48 89 04 f1             mov    %rax,(%rcx,%rsi,8)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    2.63 :	  46f018:       0f b7 42 4c             movzwl 0x4c(%rdx),%eax
    3.95 :	  46f01c:       66 85 c0                test   %ax,%ax
    0.00 :	  46f01f:       7e 6f                   jle    46f090 <slot_deform_tuple+0x180>
    0.00 :	  46f021:       48 0f bf c0             movswq %ax,%rax
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
    0.00 :	  46f025:       41 83 c4 01             add    $0x1,%r12d
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    2.63 :	  46f029:       48 01 c3                add    %rax,%rbx
         :	                slow = slot->tts_slow;
         :	        }
         :
         :	        tp = (char *) tup + tup->t_hoff;
         :
         :	        for (; attnum < natts; attnum++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1083
    1.32 :	  46f02c:       45 39 e7                cmp    %r12d,%r15d
    0.00 :	  46f02f:       7f 88                   jg     46efb9 <slot_deform_tuple+0xa9>
         :	 *              re-computing information about previously extracted attributes.
         :	 *              slot->tts_nvalid is the number of attributes already extracted.
         :	 */
         :	static void
         :	slot_deform_tuple(TupleTableSlot *slot, int natts)
         :	{
    0.00 :	  46f031:       44 89 fe                mov    %r15d,%esi
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
    0.00 :	  46f034:       49 89 5e 58             mov    %rbx,0x58(%r14)
         :	        }
         :
         :	        /*
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
    0.00 :	  46f038:       41 89 76 24             mov    %esi,0x24(%r14)
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1139
    3.95 :	  46f03c:       41 88 7e 07             mov    %dil,0x7(%r14)
         :	}
    0.00 :	  46f040:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  46f044:       5b                      pop    %rbx
    0.00 :	  46f045:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    1.32 :	  46f047:       41 5d                   pop    %r13
    0.00 :	  46f049:       41 5e                   pop    %r14
    0.00 :	  46f04b:       41 5f                   pop    %r15
    0.00 :	  46f04d:       c9                      leaveq 
    1.32 :	  46f04e:       c3                      retq   
    0.00 :	  46f04f:       90                      nop
         :
         :	                isnull[attnum] = false;
         :
         :	                if (!slow && thisatt->attcacheoff >= 0)
         :	                        off = thisatt->attcacheoff;
         :	                else if (thisatt->attlen == -1)
    0.00 :	  46f050:       66 83 7a 4c ff          cmpw   $0xffff,0x4c(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1099
    3.95 :	  46f055:       74 71                   je     46f0c8 <slot_deform_tuple+0x1b8>
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    2.63 :	  46f057:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f05b:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f05d:       0f 84 1d 01 00 00       je     46f180 <slot_deform_tuple+0x270>
    0.00 :	  46f063:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f065:       74 10                   je     46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f067:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f069:       0f 84 51 01 00 00       je     46f1c0 <slot_deform_tuple+0x2b0>
    0.00 :	  46f06f:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f073:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
         :
         :	                        if (!slow)
    0.00 :	  46f077:       40 84 ff                test   %dil,%dil
    0.00 :	  46f07a:       0f 85 5d ff ff ff       jne    46efdd <slot_deform_tuple+0xcd>
         :	                                thisatt->attcacheoff = off;
    0.00 :	  46f080:       89 5a 54                mov    %ebx,0x54(%rdx)
    0.00 :	  46f083:       e9 55 ff ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f088:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46f08f:       00 
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f090:       66 83 c0 01             add    $0x1,%ax
    0.00 :	  46f094:       0f 85 a6 00 00 00       jne    46f140 <slot_deform_tuple+0x230>
    0.00 :	  46f09a:       41 0f b6 44 1d 00       movzbl 0x0(%r13,%rbx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1128
    1.32 :	  46f0a0:       3c 01                   cmp    $0x1,%al
    0.00 :	  46f0a2:       0f 84 50 01 00 00       je     46f1f8 <slot_deform_tuple+0x2e8>
    1.32 :	  46f0a8:       a8 01                   test   $0x1,%al
    0.00 :	  46f0aa:       0f 85 20 01 00 00       jne    46f1d0 <slot_deform_tuple+0x2c0>
    0.00 :	  46f0b0:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
    0.00 :	  46f0b5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  46f0b8:       89 c0                   mov    %eax,%eax
    0.00 :	  46f0ba:       48 8d 1c 18             lea    (%rax,%rbx,1),%rbx
    0.00 :	  46f0be:       e9 ad 00 00 00          jmpq   46f170 <slot_deform_tuple+0x260>
    0.00 :	  46f0c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
    0.00 :	  46f0c8:       40 84 ff                test   %dil,%dil
    0.00 :	  46f0cb:       75 26                   jne    46f0f3 <slot_deform_tuple+0x1e3>
    0.00 :	  46f0cd:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f0d1:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f0d3:       0f 84 4f 01 00 00       je     46f228 <slot_deform_tuple+0x318>
    0.00 :	  46f0d9:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f0db:       74 a3                   je     46f080 <slot_deform_tuple+0x170>
    0.00 :	  46f0dd:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f0df:       90                      nop
    0.00 :	  46f0e0:       0f 84 52 01 00 00       je     46f238 <slot_deform_tuple+0x328>
    0.00 :	  46f0e6:       48 8d 43 01             lea    0x1(%rbx),%rax
    0.00 :	  46f0ea:       48 83 e0 fe             and    $0xfffffffffffffffe,%rax
    0.00 :	  46f0ee:       48 39 d8                cmp    %rbx,%rax
    0.00 :	  46f0f1:       74 8d                   je     46f080 <slot_deform_tuple+0x170>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f0f3:       41 80 7c 1d 00 00       cmpb   $0x0,0x0(%r13,%rbx,1)
    0.00 :	  46f0f9:       0f 85 a1 00 00 00       jne    46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f0ff:       0f b6 42 5e             movzbl 0x5e(%rdx),%eax
    0.00 :	  46f103:       3c 69                   cmp    $0x69,%al
    0.00 :	  46f105:       0f 84 d5 00 00 00       je     46f1e0 <slot_deform_tuple+0x2d0>
    0.00 :	  46f10b:       3c 63                   cmp    $0x63,%al
    0.00 :	  46f10d:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f110:       0f 84 8a 00 00 00       je     46f1a0 <slot_deform_tuple+0x290>
    0.00 :	  46f116:       3c 64                   cmp    $0x64,%al
    0.00 :	  46f118:       0f 84 27 01 00 00       je     46f245 <slot_deform_tuple+0x335>
    0.00 :	  46f11e:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  46f122:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f127:       48 83 e3 fe             and    $0xfffffffffffffffe,%rbx
    0.00 :	  46f12b:       e9 ad fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f130:       49 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%rax
    0.00 :	  46f135:       e9 d6 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f13a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f140:       49 8d 7c 1d 00          lea    0x0(%r13,%rbx,1),%rdi
    0.00 :	  46f145:       4c 89 45 c8             mov    %r8,-0x38(%rbp)
    0.00 :	  46f149:       4c 89 4d c0             mov    %r9,-0x40(%rbp)
    0.00 :	  46f14d:       44 88 55 b8             mov    %r10b,-0x48(%rbp)
    0.00 :	  46f151:       4c 89 5d b0             mov    %r11,-0x50(%rbp)
    0.00 :	  46f155:       e8 f6 a6 ff ff          callq  469850 <strlen@plt>
    0.00 :	  46f15a:       44 0f b6 55 b8          movzbl -0x48(%rbp),%r10d
    0.00 :	  46f15f:       4c 8b 45 c8             mov    -0x38(%rbp),%r8
    0.00 :	  46f163:       48 8d 5c 03 01          lea    0x1(%rbx,%rax,1),%rbx
    0.00 :	  46f168:       4c 8b 4d c0             mov    -0x40(%rbp),%r9
    0.00 :	  46f16c:       4c 8b 5d b0             mov    -0x50(%rbp),%r11
         :	         * Save state for next execution
         :	         */
         :	        slot->tts_nvalid = attnum;
         :	        slot->tts_off = off;
         :	        slot->tts_slow = slow;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1140
    5.26 :	  46f170:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f175:       e9 36 fe ff ff          jmpq   46efb0 <slot_deform_tuple+0xa0>
    0.00 :	  46f17a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f180:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f184:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1120
    1.32 :	  46f188:       e9 ea fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f18d:       0f 1f 00                nopl   (%rax)
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
    1.32 :	  46f190:       41 8b 44 1d 00          mov    0x0(%r13,%rbx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1126
   10.53 :	  46f195:       e9 76 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f19a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
         :
         :	                        if (!slow)
         :	                                thisatt->attcacheoff = off;
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1123
    1.32 :	  46f1a0:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1a5:       e9 33 fe ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
    0.00 :	  46f1b0:       41 0f b7 44 1d 00       movzwl 0x0(%r13,%rbx,1),%eax
    0.00 :	  46f1b6:       e9 55 fe ff ff          jmpq   46f010 <slot_deform_tuple+0x100>
    0.00 :	  46f1bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* not varlena, so safe to use att_align_nominal */
         :	                        off = att_align_nominal(off, thisatt->attalign);
    0.00 :	  46f1c0:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f1c4:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f1c8:       e9 aa fe ff ff          jmpq   46f077 <slot_deform_tuple+0x167>
    0.00 :	  46f1cd:       0f 1f 00                nopl   (%rax)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1d0:       d0 e8                   shr    %al
    0.00 :	  46f1d2:       0f b6 c0                movzbl %al,%eax
    0.00 :	  46f1d5:       e9 e0 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f1da:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (!slow &&
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f1e0:       48 83 c3 03             add    $0x3,%rbx
    0.00 :	  46f1e4:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f1e9:       48 83 e3 fc             and    $0xfffffffffffffffc,%rbx
    0.00 :	  46f1ed:       e9 eb fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>
    0.00 :	  46f1f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                thisatt->attcacheoff = off;
         :	                }
         :
         :	                values[attnum] = fetchatt(thisatt, tp + off);
         :
         :	                off = att_addlength_pointer(off, thisatt->attlen, tp + off);
    0.00 :	  46f1f8:       41 0f b6 54 1d 01       movzbl 0x1(%r13,%rbx,1),%edx
    0.00 :	  46f1fe:       b8 0a 00 00 00          mov    $0xa,%eax
    0.00 :	  46f203:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  46f206:       0f 84 ae fe ff ff       je     46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f20c:       80 fa 12                cmp    $0x12,%dl
    0.00 :	  46f20f:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	  46f214:       ba 12 00 00 00          mov    $0x12,%edx
    0.00 :	  46f219:       48 0f 44 c2             cmove  %rdx,%rax
    0.00 :	  46f21d:       e9 98 fe ff ff          jmpq   46f0ba <slot_deform_tuple+0x1aa>
    0.00 :	  46f222:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * We can only cache the offset for a varlena attribute if the
         :	                         * offset is already suitably aligned, so that there would be no
         :	                         * pad bytes in any case: then the offset will be valid for either
         :	                         * an aligned or unaligned value.
         :	                         */
         :	                        if (!slow &&
    0.00 :	  46f228:       48 8d 43 03             lea    0x3(%rbx),%rax
    0.00 :	  46f22c:       48 83 e0 fc             and    $0xfffffffffffffffc,%rax
    0.00 :	  46f230:       e9 b9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
    0.00 :	  46f235:       0f 1f 00                nopl   (%rax)
    0.00 :	  46f238:       48 8d 43 07             lea    0x7(%rbx),%rax
    0.00 :	  46f23c:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	  46f240:       e9 a9 fe ff ff          jmpq   46f0ee <slot_deform_tuple+0x1de>
         :	                                off == att_align_nominal(off, thisatt->attalign))
         :	                                thisatt->attcacheoff = off;
         :	                        else
         :	                        {
         :	                                off = att_align_pointer(off, thisatt->attalign, -1,
    0.00 :	  46f245:       48 83 c3 07             add    $0x7,%rbx
    0.00 :	  46f249:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  46f24e:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
    0.00 :	  46f252:       e9 86 fd ff ff          jmpq   46efdd <slot_deform_tuple+0xcd>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   51.06 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
    6.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    6.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
    6.38 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    4.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    4.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    4.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    4.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1103
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1035
    2.13 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1103
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5750 <HeapTupleSatisfiesMVCC>:
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    4.26 :	  7a5750:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    6.38 :	  7a5751:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:918
    4.26 :	  7a5754:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  7a5758:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  7a575c:       41 89 d6                mov    %edx,%r14d
    0.00 :	  7a575f:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    2.13 :	  7a5763:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    2.13 :	  7a5767:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tuple = htup->t_data;
    0.00 :	  7a576b:       48 8b 5f 10             mov    0x10(%rdi),%rbx
         :	 * can't see it.)
         :	 */
         :	bool
         :	HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,
         :	                                           Buffer buffer)
         :	{
    0.00 :	  7a576f:       49 89 f5                mov    %rsi,%r13
         :	        HeapTupleHeader tuple = htup->t_data;
         :
         :	        Assert(ItemPointerIsValid(&htup->t_self));
         :	        Assert(htup->t_tableOid != InvalidOid);
         :
         :	        if (!HeapTupleHeaderXminCommitted(tuple))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:924
    6.38 :	  7a5772:       0f b7 4b 14             movzwl 0x14(%rbx),%ecx
   51.06 :	  7a5776:       0f b7 d1                movzwl %cx,%edx
    0.00 :	  7a5779:       f6 c6 01                test   $0x1,%dh
    0.00 :	  7a577c:       75 72                   jne    7a57f0 <HeapTupleSatisfiesMVCC+0xa0>
         :	        {
         :	                if (HeapTupleHeaderXminInvalid(tuple))
    0.00 :	  7a577e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5780:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a5785:       3d 00 02 00 00          cmp    $0x200,%eax
    0.00 :	  7a578a:       0f 84 06 01 00 00       je     7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :
         :	                /* Used by pre-9.0 binary upgrades */
         :	                if (tuple->t_infomask & HEAP_MOVED_OFF)
    0.00 :	  7a5790:       f6 c6 40                test   $0x40,%dh
    0.00 :	  7a5793:       0f 84 27 01 00 00       je     7a58c0 <HeapTupleSatisfiesMVCC+0x170>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a5799:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a579c:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a57a1:       74 04                   je     7a57a7 <HeapTupleSatisfiesMVCC+0x57>
    0.00 :	  7a57a3:       44 8b 63 08             mov    0x8(%rbx),%r12d
         :
         :	                        if (TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a57a7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57aa:       e8 f1 ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a57af:       84 c0                   test   %al,%al
    0.00 :	  7a57b1:       0f 85 df 00 00 00       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;
         :	                        if (!TransactionIdIsInProgress(xvac))
    0.00 :	  7a57b7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ba:       e8 f1 c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a57bf:       84 c0                   test   %al,%al
    0.00 :	  7a57c1:       0f 85 1f 01 00 00       jne    7a58e6 <HeapTupleSatisfiesMVCC+0x196>
         :	                        {
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a57c7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a57ca:       e8 11 ab d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a57cf:       84 c0                   test   %al,%al
    0.00 :	  7a57d1:       0f 85 79 02 00 00       jne    7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
         :	                                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a57d7:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a57dc:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a57de:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a57e1:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a57e4:       e8 b7 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a57e9:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a57ed:       0f 1f 00                nopl   (%rax)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    2.13 :	  7a57f0:       89 d0                   mov    %edx,%eax
    2.13 :	  7a57f2:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a57f7:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a57fc:       0f 85 86 00 00 00       jne    7a5888 <HeapTupleSatisfiesMVCC+0x138>
         :	                return false;                   /* treat as still in progress */
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid or aborted */
         :	                return true;
         :
         :	        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1035
    2.13 :	  7a5802:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5808:       0f 85 a2 00 00 00       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a580e:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5810:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a5815:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5818:       0f 84 92 00 00 00       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                return true;
         :
         :	        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a581e:       f6 c6 10                test   $0x10,%dh
    0.00 :	  7a5821:       0f 85 b9 01 00 00       jne    7a59e0 <HeapTupleSatisfiesMVCC+0x290>
         :	                }
         :	                /* it must have aborted or crashed */
         :	                return true;
         :	        }
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
    0.00 :	  7a5827:       80 e6 04                and    $0x4,%dh
    0.00 :	  7a582a:       75 44                   jne    7a5870 <HeapTupleSatisfiesMVCC+0x120>
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a582c:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a582f:       90                      nop
    0.00 :	  7a5830:       e8 6b ec d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5835:       84 c0                   test   %al,%al
    0.00 :	  7a5837:       0f 85 43 01 00 00       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :
         :	                if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a583d:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5840:       e8 6b c4 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5845:       84 c0                   test   %al,%al
    0.00 :	  7a5847:       75 67                   jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5849:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a584c:       e8 8f aa d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5851:       84 c0                   test   %al,%al
    0.00 :	  7a5853:       0f 84 20 02 00 00       je     7a5a79 <HeapTupleSatisfiesMVCC+0x329>
         :	                                                InvalidTransactionId);
         :	                        return true;
         :	                }
         :
         :	                /* xmax transaction committed */
         :	                SetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,
    0.00 :	  7a5859:       8b 4b 04                mov    0x4(%rbx),%ecx
    0.00 :	  7a585c:       ba 00 04 00 00          mov    $0x400,%edx
    0.00 :	  7a5861:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5864:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5867:       e8 34 f2 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a586c:       0f 1f 40 00             nopl   0x0(%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5870:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5873:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5876:       e8 85 fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a587b:       84 c0                   test   %al,%al
    0.00 :	  7a587d:       0f 95 c0                setne  %al
    0.00 :	  7a5880:       eb 16                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5882:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    4.26 :	  7a5888:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a588a:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a588d:       e8 6e fd ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a5892:       84 c0                   test   %al,%al
    0.00 :	  7a5894:       74 6a                   je     7a5900 <HeapTupleSatisfiesMVCC+0x1b0>
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a5896:       31 c0                   xor    %eax,%eax
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5898:       48 8b 1c 24             mov    (%rsp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1103
    2.13 :	  7a589c:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  7a58a1:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  7a58a6:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  7a58ab:       c9                      leaveq 
    4.26 :	  7a58ac:       c3                      retq   
    0.00 :	  7a58ad:       0f 1f 00                nopl   (%rax)
         :	        }
         :
         :	        /*
         :	         * OK, the deleting transaction committed too ... but when?
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
    0.00 :	  7a58b0:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  7a58b5:       eb e1                   jmp    7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a58b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7a58be:       00 00 
         :	                                SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                        InvalidTransactionId);
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
    0.00 :	  7a58c0:       66 85 c9                test   %cx,%cx
    0.00 :	  7a58c3:       79 4b                   jns    7a5910 <HeapTupleSatisfiesMVCC+0x1c0>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a58c5:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  7a58c8:       66 f7 c2 00 c0          test   $0xc000,%dx
    0.00 :	  7a58cd:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a58d0:       0f 85 fa 00 00 00       jne    7a59d0 <HeapTupleSatisfiesMVCC+0x280>
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
    0.00 :	  7a58d6:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a58d9:       e8 c2 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a58de:       84 c0                   test   %al,%al
    0.00 :	  7a58e0:       0f 84 4a 01 00 00       je     7a5a30 <HeapTupleSatisfiesMVCC+0x2e0>
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a58e6:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :
         :	        /*
         :	         * By here, the inserting transaction has committed - have to check
         :	         * when...
         :	         */
         :	        if (!HeapTupleHeaderXminFrozen(tuple)
    0.00 :	  7a58ea:       89 d0                   mov    %edx,%eax
    0.00 :	  7a58ec:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  7a58f1:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  7a58f6:       0f 84 06 ff ff ff       je     7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a58fc:       eb 8a                   jmp    7a5888 <HeapTupleSatisfiesMVCC+0x138>
    0.00 :	  7a58fe:       66 90                   xchg   %ax,%ax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1028
    6.38 :	  7a5900:       0f b7 53 14             movzwl 0x14(%rbx),%edx
    0.00 :	  7a5904:       e9 f9 fe ff ff          jmpq   7a5802 <HeapTupleSatisfiesMVCC+0xb2>
    0.00 :	  7a5909:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                InvalidTransactionId);
         :	                                        return false;
         :	                                }
         :	                        }
         :	                }
         :	                else if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5910:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a5912:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5918:       e8 83 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a591d:       84 c0                   test   %al,%al
    0.00 :	  7a591f:       90                      nop
    0.00 :	  7a5920:       74 76                   je     7a5998 <HeapTupleSatisfiesMVCC+0x248>
         :	                {
         :	                        if (HeapTupleHeaderGetCmin(tuple) >= snapshot->curcid)
    0.00 :	  7a5922:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5925:       e8 96 eb ff ff          callq  7a44c0 <HeapTupleHeaderGetCmin>
    0.00 :	  7a592a:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a592e:       66 90                   xchg   %ax,%ax
    0.00 :	  7a5930:       0f 83 60 ff ff ff       jae    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                return false;   /* inserted after scan started */
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_INVALID)      /* xid invalid */
    0.00 :	  7a5936:       0f b7 53 14             movzwl 0x14(%rbx),%edx
         :	                                return true;
         :
         :	                        if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))        /* not deleter */
    0.00 :	  7a593a:       f7 c2 80 08 00 00       test   $0x880,%edx
    0.00 :	  7a5940:       0f 85 6a ff ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5946:       89 d0                   mov    %edx,%eax
    0.00 :	  7a5948:       25 50 10 00 00          and    $0x1050,%eax
    0.00 :	  7a594d:       83 f8 40                cmp    $0x40,%eax
    0.00 :	  7a5950:       0f 84 5a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                                return true;
         :
         :	                        if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)
    0.00 :	  7a5956:       80 e6 10                and    $0x10,%dh
    0.00 :	  7a5959:       0f 84 0a 01 00 00       je     7a5a69 <HeapTupleSatisfiesMVCC+0x319>
         :	                        {
         :	                                TransactionId xmax;
         :
         :	                                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a595f:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5962:       e8 b9 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  7a5967:       89 c7                   mov    %eax,%edi
         :
         :	                                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                                Assert(TransactionIdIsValid(xmax));
         :
         :	                                /* updating subtransaction must have aborted */
         :	                                if (!TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a5969:       e8 32 eb d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a596e:       84 c0                   test   %al,%al
    0.00 :	  7a5970:       0f 84 3a ff ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
    0.00 :	  7a5976:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  7a597d:       00 00 00 
         :
         :	        if (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))
         :	        {
         :	                if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
    0.00 :	  7a5980:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5983:       e8 58 eb ff ff          callq  7a44e0 <HeapTupleHeaderGetCmax>
    0.00 :	  7a5988:       41 3b 45 2c             cmp    0x2c(%r13),%eax
    0.00 :	  7a598c:       0f 93 c0                setae  %al
    0.00 :	  7a598f:       e9 04 ff ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
    0.00 :	  7a5994:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                else if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a5998:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a599a:       e8 11 c3 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a599f:       84 c0                   test   %al,%al
    0.00 :	  7a59a1:       0f 85 ef fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                        return false;
         :	                else if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))
    0.00 :	  7a59a7:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  7a59a9:       e8 32 a9 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a59ae:       84 c0                   test   %al,%al
    0.00 :	  7a59b0:       0f 84 9a 00 00 00       je     7a5a50 <HeapTupleSatisfiesMVCC+0x300>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
    0.00 :	  7a59b6:       8b 0b                   mov    (%rbx),%ecx
    0.00 :	  7a59b8:       ba 00 01 00 00          mov    $0x100,%edx
    0.00 :	  7a59bd:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a59c0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59c3:       e8 d8 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a59c8:       e9 19 ff ff ff          jmpq   7a58e6 <HeapTupleSatisfiesMVCC+0x196>
    0.00 :	  7a59cd:       0f 1f 00                nopl   (%rax)
         :	                        }
         :	                }
         :	                /* Used by pre-9.0 binary upgrades */
         :	                else if (tuple->t_infomask & HEAP_MOVED_IN)
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
    0.00 :	  7a59d0:       44 8b 63 08             mov    0x8(%rbx),%r12d
    0.00 :	  7a59d4:       e9 fd fe ff ff          jmpq   7a58d6 <HeapTupleSatisfiesMVCC+0x186>
    0.00 :	  7a59d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59e0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a59e3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a59e8:       e8 33 17 cf ff          callq  497120 <HeapTupleGetUpdateXid>
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59ed:       89 c7                   mov    %eax,%edi
         :	                TransactionId xmax;
         :
         :	                /* already checked above */
         :	                Assert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));
         :
         :	                xmax = HeapTupleGetUpdateXid(tuple);
    0.00 :	  7a59ef:       41 89 c4                mov    %eax,%r12d
         :
         :	                /* not LOCKED_ONLY, so it has to have an xmax */
         :	                Assert(TransactionIdIsValid(xmax));
         :
         :	                if (TransactionIdIsCurrentTransactionId(xmax))
    0.00 :	  7a59f2:       e8 a9 ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a59f7:       84 c0                   test   %al,%al
    0.00 :	  7a59f9:       75 85                   jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)
         :	                                return true;    /* deleted after scan started */
         :	                        else
         :	                                return false;   /* deleted before scan started */
         :	                }
         :	                if (TransactionIdIsInProgress(xmax))
    0.00 :	  7a59fb:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a59fe:       e8 ad c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a03:       84 c0                   test   %al,%al
    0.00 :	  7a5a05:       0f 85 a5 fe ff ff       jne    7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                        return true;
         :	                if (TransactionIdDidCommit(xmax))
    0.00 :	  7a5a0b:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a0e:       e8 cd a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a13:       84 c0                   test   %al,%al
    0.00 :	  7a5a15:       0f 84 95 fe ff ff       je     7a58b0 <HeapTupleSatisfiesMVCC+0x160>
         :	                {
         :	                        /* updating transaction committed, but when? */
         :	                        if (XidInMVCCSnapshot(xmax, snapshot))
    0.00 :	  7a5a1b:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  7a5a1e:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a21:       e8 da fb ff ff          callq  7a5600 <XidInMVCCSnapshot>
    0.00 :	  7a5a26:       84 c0                   test   %al,%al
    0.00 :	  7a5a28:       0f 95 c0                setne  %al
    0.00 :	  7a5a2b:       e9 68 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                {
         :	                        TransactionId xvac = HeapTupleHeaderGetXvac(tuple);
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(xvac))
         :	                        {
         :	                                if (TransactionIdIsInProgress(xvac))
    0.00 :	  7a5a30:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a33:       e8 78 c2 ed ff          callq  681cb0 <TransactionIdIsInProgress>
    0.00 :	  7a5a38:       84 c0                   test   %al,%al
    0.00 :	  7a5a3a:       0f 85 56 fe ff ff       jne    7a5896 <HeapTupleSatisfiesMVCC+0x146>
         :	                                        return false;
         :	                                if (TransactionIdDidCommit(xvac))
    0.00 :	  7a5a40:       44 89 e7                mov    %r12d,%edi
    0.00 :	  7a5a43:       e8 98 a8 d1 ff          callq  4c02e0 <TransactionIdDidCommit>
    0.00 :	  7a5a48:       84 c0                   test   %al,%al
    0.00 :	  7a5a4a:       0f 85 87 fd ff ff       jne    7a57d7 <HeapTupleSatisfiesMVCC+0x87>
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,
         :	                                                HeapTupleHeaderGetRawXmin(tuple));
         :	                else
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMIN_INVALID,
    0.00 :	  7a5a50:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a52:       ba 00 02 00 00          mov    $0x200,%edx
    0.00 :	  7a5a57:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a5a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a5d:       e8 3e f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a62:       31 c0                   xor    %eax,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a64:       e9 2f fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>
         :	                                        return true;    /* updated after scan started */
         :	                                else
         :	                                        return false;           /* updated before scan started */
         :	                        }
         :
         :	                        if (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))
    0.00 :	  7a5a69:       8b 7b 04                mov    0x4(%rbx),%edi
    0.00 :	  7a5a6c:       e8 2f ea d1 ff          callq  4c44a0 <TransactionIdIsCurrentTransactionId>
    0.00 :	  7a5a71:       84 c0                   test   %al,%al
    0.00 :	  7a5a73:       0f 85 07 ff ff ff       jne    7a5980 <HeapTupleSatisfiesMVCC+0x230>
         :	                        return true;
         :
         :	                if (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))
         :	                {
         :	                        /* it must have aborted or crashed */
         :	                        SetHintBits(tuple, buffer, HEAP_XMAX_INVALID,
    0.00 :	  7a5a79:       31 c9                   xor    %ecx,%ecx
    0.00 :	  7a5a7b:       ba 00 08 00 00          mov    $0x800,%edx
    0.00 :	  7a5a80:       44 89 f6                mov    %r14d,%esi
    0.00 :	  7a5a83:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7a5a86:       e8 15 f0 ff ff          callq  7a4aa0 <SetHintBits>
    0.00 :	  7a5a8b:       b8 01 00 00 00          mov    $0x1,%eax
         :	         */
         :	        if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))
         :	                return true;                    /* treat as still in progress */
         :
         :	        return false;
         :	}
    0.00 :	  7a5a90:       e9 03 fe ff ff          jmpq   7a5898 <HeapTupleSatisfiesMVCC+0x148>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   10.87 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
    6.52 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    6.52 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:82
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:94
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:140
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:141
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:89
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:97
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:97
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:99
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:99
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:99
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:137
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:138
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:139
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:142
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:144
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:145
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    2.17 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b7bd0 <InstrStopNode>:
         :	}
         :
         :	/* Exit from a plan node */
         :	void
         :	InstrStopNode(Instrumentation *instr, double nTuples)
         :	{
    0.00 :	  5b7bd0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    6.52 :	  5b7bd1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b7bd4:       53                      push   %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:70
    4.35 :	  5b7bd5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b7bd8:       48 83 ec 18             sub    $0x18,%rsp
         :
         :	        /* count the returned tuples */
         :	        instr->tuplecount += nTuples;
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
    0.00 :	  5b7bdc:       80 3f 00                cmpb   $0x0,(%rdi)
         :	InstrStopNode(Instrumentation *instr, double nTuples)
         :	{
         :	        instr_time      endtime;
         :
         :	        /* count the returned tuples */
         :	        instr->tuplecount += nTuples;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
    2.17 :	  5b7bdf:       f2 0f 58 47 30          addsd  0x30(%rdi),%xmm0
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:74
   10.87 :	  5b7be4:       f2 0f 11 47 30          movsd  %xmm0,0x30(%rdi)
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:77
    2.17 :	  5b7be9:       0f 84 90 00 00 00       je     5b7c7f <InstrStopNode+0xaf>
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
    0.00 :	  5b7bef:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
    0.00 :	  5b7bf4:       75 0b                   jne    5b7c01 <InstrStopNode+0x31>
    0.00 :	  5b7bf6:       48 83 7f 08 00          cmpq   $0x0,0x8(%rdi)
    0.00 :	  5b7bfb:       0f 84 d1 02 00 00       je     5b7ed2 <InstrStopNode+0x302>
         :	                        elog(ERROR, "InstrStopNode called without start");
         :
         :	                INSTR_TIME_SET_CURRENT(endtime);
    0.00 :	  5b7c01:       48 8d 7d e0             lea    -0x20(%rbp),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:82
    4.35 :	  5b7c05:       31 f6                   xor    %esi,%esi
    0.00 :	  5b7c07:       e8 b4 19 eb ff          callq  4695c0 <gettimeofday@plt>
         :	                INSTR_TIME_ACCUM_DIFF(instr->counter, endtime, instr->starttime);
    0.00 :	  5b7c0c:       48 8b 45 e0             mov    -0x20(%rbp),%rax
    0.00 :	  5b7c10:       48 03 43 18             add    0x18(%rbx),%rax
    0.00 :	  5b7c14:       48 2b 43 08             sub    0x8(%rbx),%rax
    0.00 :	  5b7c18:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	  5b7c1c:       48 8b 45 e8             mov    -0x18(%rbp),%rax
    0.00 :	  5b7c20:       48 03 43 20             add    0x20(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    4.35 :	  5b7c24:       48 2b 43 10             sub    0x10(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    6.52 :	  5b7c28:       48 85 c0                test   %rax,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:83
    2.17 :	  5b7c2b:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  5b7c2f:       79 36                   jns    5b7c67 <InstrStopNode+0x97>
    0.00 :	  5b7c31:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  5b7c38:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7c3e:       48 83 6b 18 01          subq   $0x1,0x18(%rbx)
    0.00 :	  5b7c43:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7c46:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  5b7c4a:       78 ec                   js     5b7c38 <InstrStopNode+0x68>
    0.00 :	  5b7c4c:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7c52:       7e 1b                   jle    5b7c6f <InstrStopNode+0x9f>
    0.00 :	  5b7c54:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5b7c58:       48 83 43 18 01          addq   $0x1,0x18(%rbx)
    0.00 :	  5b7c5d:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7c63:       48 89 43 20             mov    %rax,0x20(%rbx)
    2.17 :	  5b7c67:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7c6d:       7f e9                   jg     5b7c58 <InstrStopNode+0x88>
         :
         :	                INSTR_TIME_SET_ZERO(instr->starttime);
    0.00 :	  5b7c6f:       48 c7 43 08 00 00 00    movq   $0x0,0x8(%rbx)
    0.00 :	  5b7c76:       00 
    0.00 :	  5b7c77:       48 c7 43 10 00 00 00    movq   $0x0,0x10(%rbx)
    0.00 :	  5b7c7e:       00 
         :	        }
         :
         :	        /* Add delta of buffer usage since entry to node's totals */
         :	        if (instr->need_bufusage)
    0.00 :	  5b7c7f:       80 7b 01 00             cmpb   $0x0,0x1(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:89
    2.17 :	  5b7c83:       75 33                   jne    5b7cb8 <InstrStopNode+0xe8>
         :	                BufferUsageAccumDiff(&instr->bufusage,
         :	                                                         &pgBufferUsage, &instr->bufusage_start);
         :
         :	        /* Is this the first tuple of this cycle? */
         :	        if (!instr->running)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:94
    4.35 :	  5b7c85:       80 7b 02 00             cmpb   $0x0,0x2(%rbx)
    0.00 :	  5b7c89:       75 21                   jne    5b7cac <InstrStopNode+0xdc>
         :	        {
         :	                instr->running = true;
         :	                instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7c8b:       f2 48 0f 2a 43 20       cvtsi2sdq 0x20(%rbx),%xmm0
    0.00 :	  5b7c91:       f2 0f 5e 05 47 49 2c    divsd  0x2c4947(%rip),%xmm0        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  5b7c98:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:97
    2.17 :	  5b7c99:       f2 48 0f 2a 4b 18       cvtsi2sdq 0x18(%rbx),%xmm1
         :	                                                         &pgBufferUsage, &instr->bufusage_start);
         :
         :	        /* Is this the first tuple of this cycle? */
         :	        if (!instr->running)
         :	        {
         :	                instr->running = true;
    0.00 :	  5b7c9f:       c6 43 02 01             movb   $0x1,0x2(%rbx)
         :	                instr->firsttuple = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7ca3:       f2 0f 58 c8             addsd  %xmm0,%xmm1
    2.17 :	  5b7ca7:       f2 0f 11 4b 28          movsd  %xmm1,0x28(%rbx)
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:99
    2.17 :	  5b7cac:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  5b7cb0:       5b                      pop    %rbx
    2.17 :	  5b7cb1:       c9                      leaveq 
    2.17 :	  5b7cb2:       c3                      retq   
    0.00 :	  5b7cb3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	static void
         :	BufferUsageAccumDiff(BufferUsage *dst,
         :	                                         const BufferUsage *add,
         :	                                         const BufferUsage *sub)
         :	{
         :	        dst->shared_blks_hit += add->shared_blks_hit - sub->shared_blks_hit;
    0.00 :	  5b7cb8:       48 8b 05 a1 7a 60 00    mov    0x607aa1(%rip),%rax        # bbf760 <pgBufferUsage>
    0.00 :	  5b7cbf:       48 03 83 d8 00 00 00    add    0xd8(%rbx),%rax
    0.00 :	  5b7cc6:       48 2b 43 38             sub    0x38(%rbx),%rax
    0.00 :	  5b7cca:       48 89 83 d8 00 00 00    mov    %rax,0xd8(%rbx)
         :	        dst->shared_blks_read += add->shared_blks_read - sub->shared_blks_read;
    0.00 :	  5b7cd1:       48 8b 05 90 7a 60 00    mov    0x607a90(%rip),%rax        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  5b7cd8:       48 03 83 e0 00 00 00    add    0xe0(%rbx),%rax
    0.00 :	  5b7cdf:       48 2b 43 40             sub    0x40(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:137
    2.17 :	  5b7ce3:       48 89 83 e0 00 00 00    mov    %rax,0xe0(%rbx)
         :	        dst->shared_blks_dirtied += add->shared_blks_dirtied - sub->shared_blks_dirtied;
    0.00 :	  5b7cea:       48 8b 05 7f 7a 60 00    mov    0x607a7f(%rip),%rax        # bbf770 <pgBufferUsage+0x10>
    0.00 :	  5b7cf1:       48 03 83 e8 00 00 00    add    0xe8(%rbx),%rax
    0.00 :	  5b7cf8:       48 2b 43 48             sub    0x48(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:138
    2.17 :	  5b7cfc:       48 89 83 e8 00 00 00    mov    %rax,0xe8(%rbx)
         :	        dst->shared_blks_written += add->shared_blks_written - sub->shared_blks_written;
    0.00 :	  5b7d03:       48 8b 05 6e 7a 60 00    mov    0x607a6e(%rip),%rax        # bbf778 <pgBufferUsage+0x18>
    0.00 :	  5b7d0a:       48 03 83 f0 00 00 00    add    0xf0(%rbx),%rax
    0.00 :	  5b7d11:       48 2b 43 50             sub    0x50(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:139
    2.17 :	  5b7d15:       48 89 83 f0 00 00 00    mov    %rax,0xf0(%rbx)
         :	        dst->local_blks_hit += add->local_blks_hit - sub->local_blks_hit;
    0.00 :	  5b7d1c:       48 8b 05 5d 7a 60 00    mov    0x607a5d(%rip),%rax        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  5b7d23:       48 03 83 f8 00 00 00    add    0xf8(%rbx),%rax
    0.00 :	  5b7d2a:       48 2b 43 58             sub    0x58(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:140
    4.35 :	  5b7d2e:       48 89 83 f8 00 00 00    mov    %rax,0xf8(%rbx)
         :	        dst->local_blks_read += add->local_blks_read - sub->local_blks_read;
    0.00 :	  5b7d35:       48 8b 05 4c 7a 60 00    mov    0x607a4c(%rip),%rax        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  5b7d3c:       48 03 83 00 01 00 00    add    0x100(%rbx),%rax
    0.00 :	  5b7d43:       48 2b 43 60             sub    0x60(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:141
    4.35 :	  5b7d47:       48 89 83 00 01 00 00    mov    %rax,0x100(%rbx)
         :	        dst->local_blks_dirtied += add->local_blks_dirtied - sub->local_blks_dirtied;
    0.00 :	  5b7d4e:       48 8b 05 3b 7a 60 00    mov    0x607a3b(%rip),%rax        # bbf790 <pgBufferUsage+0x30>
    0.00 :	  5b7d55:       48 03 83 08 01 00 00    add    0x108(%rbx),%rax
    0.00 :	  5b7d5c:       48 2b 43 68             sub    0x68(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:142
    2.17 :	  5b7d60:       48 89 83 08 01 00 00    mov    %rax,0x108(%rbx)
         :	        dst->local_blks_written += add->local_blks_written - sub->local_blks_written;
    0.00 :	  5b7d67:       48 8b 05 2a 7a 60 00    mov    0x607a2a(%rip),%rax        # bbf798 <pgBufferUsage+0x38>
    0.00 :	  5b7d6e:       48 03 83 10 01 00 00    add    0x110(%rbx),%rax
    0.00 :	  5b7d75:       48 2b 43 70             sub    0x70(%rbx),%rax
    0.00 :	  5b7d79:       48 89 83 10 01 00 00    mov    %rax,0x110(%rbx)
         :	        dst->temp_blks_read += add->temp_blks_read - sub->temp_blks_read;
    0.00 :	  5b7d80:       48 8b 05 19 7a 60 00    mov    0x607a19(%rip),%rax        # bbf7a0 <pgBufferUsage+0x40>
    0.00 :	  5b7d87:       48 03 83 18 01 00 00    add    0x118(%rbx),%rax
    0.00 :	  5b7d8e:       48 2b 43 78             sub    0x78(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:144
    2.17 :	  5b7d92:       48 89 83 18 01 00 00    mov    %rax,0x118(%rbx)
         :	        dst->temp_blks_written += add->temp_blks_written - sub->temp_blks_written;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:145
    2.17 :	  5b7d99:       48 8b 05 08 7a 60 00    mov    0x607a08(%rip),%rax        # bbf7a8 <pgBufferUsage+0x48>
    0.00 :	  5b7da0:       48 03 83 20 01 00 00    add    0x120(%rbx),%rax
    0.00 :	  5b7da7:       48 2b 83 80 00 00 00    sub    0x80(%rbx),%rax
    0.00 :	  5b7dae:       48 89 83 20 01 00 00    mov    %rax,0x120(%rbx)
         :	        INSTR_TIME_ACCUM_DIFF(dst->blk_read_time,
    0.00 :	  5b7db5:       48 8b 05 f4 79 60 00    mov    0x6079f4(%rip),%rax        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  5b7dbc:       48 03 83 28 01 00 00    add    0x128(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:146
    2.17 :	  5b7dc3:       48 2b 83 88 00 00 00    sub    0x88(%rbx),%rax
    0.00 :	  5b7dca:       48 89 83 28 01 00 00    mov    %rax,0x128(%rbx)
    0.00 :	  5b7dd1:       48 8b 05 e0 79 60 00    mov    0x6079e0(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  5b7dd8:       48 03 83 30 01 00 00    add    0x130(%rbx),%rax
    0.00 :	  5b7ddf:       48 2b 83 90 00 00 00    sub    0x90(%rbx),%rax
    0.00 :	  5b7de6:       48 85 c0                test   %rax,%rax
    4.35 :	  5b7de9:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7df0:       79 43                   jns    5b7e35 <InstrStopNode+0x265>
    0.00 :	  5b7df2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7df8:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7dfe:       48 83 ab 28 01 00 00    subq   $0x1,0x128(%rbx)
    0.00 :	  5b7e05:       01 
    0.00 :	  5b7e06:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e09:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7e10:       78 e6                   js     5b7df8 <InstrStopNode+0x228>
    0.00 :	  5b7e12:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7e18:       7e 23                   jle    5b7e3d <InstrStopNode+0x26d>
    0.00 :	  5b7e1a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7e20:       48 83 83 28 01 00 00    addq   $0x1,0x128(%rbx)
    0.00 :	  5b7e27:       01 
    0.00 :	  5b7e28:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7e2e:       48 89 83 30 01 00 00    mov    %rax,0x130(%rbx)
    0.00 :	  5b7e35:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7e3b:       7f e3                   jg     5b7e20 <InstrStopNode+0x250>
         :	                                                  add->blk_read_time, sub->blk_read_time);
         :	        INSTR_TIME_ACCUM_DIFF(dst->blk_write_time,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:148
    2.17 :	  5b7e3d:       48 8b 05 7c 79 60 00    mov    0x60797c(%rip),%rax        # bbf7c0 <pgBufferUsage+0x60>
    0.00 :	  5b7e44:       48 03 83 38 01 00 00    add    0x138(%rbx),%rax
    0.00 :	  5b7e4b:       48 2b 83 98 00 00 00    sub    0x98(%rbx),%rax
    0.00 :	  5b7e52:       48 89 83 38 01 00 00    mov    %rax,0x138(%rbx)
    2.17 :	  5b7e59:       48 8b 05 68 79 60 00    mov    0x607968(%rip),%rax        # bbf7c8 <pgBufferUsage+0x68>
    0.00 :	  5b7e60:       48 03 83 40 01 00 00    add    0x140(%rbx),%rax
    0.00 :	  5b7e67:       48 2b 83 a0 00 00 00    sub    0xa0(%rbx),%rax
    0.00 :	  5b7e6e:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e71:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    0.00 :	  5b7e78:       79 4b                   jns    5b7ec5 <InstrStopNode+0x2f5>
    0.00 :	  5b7e7a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b7e80:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  5b7e86:       48 83 ab 38 01 00 00    subq   $0x1,0x138(%rbx)
    0.00 :	  5b7e8d:       01 
    0.00 :	  5b7e8e:       48 85 c0                test   %rax,%rax
    0.00 :	  5b7e91:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    0.00 :	  5b7e98:       78 e6                   js     5b7e80 <InstrStopNode+0x2b0>
    0.00 :	  5b7e9a:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7ea0:       0f 8e df fd ff ff       jle    5b7c85 <InstrStopNode+0xb5>
    0.00 :	  5b7ea6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b7ead:       00 00 00 
    0.00 :	  5b7eb0:       48 83 83 38 01 00 00    addq   $0x1,0x138(%rbx)
    0.00 :	  5b7eb7:       01 
    0.00 :	  5b7eb8:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  5b7ebe:       48 89 83 40 01 00 00    mov    %rax,0x140(%rbx)
    2.17 :	  5b7ec5:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  5b7ecb:       7f e3                   jg     5b7eb0 <InstrStopNode+0x2e0>
    2.17 :	  5b7ecd:       e9 b3 fd ff ff          jmpq   5b7c85 <InstrStopNode+0xb5>
         :
         :	        /* let's update the time only if the timer was requested */
         :	        if (instr->need_timer)
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
         :	                        elog(ERROR, "InstrStopNode called without start");
    0.00 :	  5b7ed2:       ba 8a b6 88 00          mov    $0x88b68a,%edx
    0.00 :	  5b7ed7:       be 50 00 00 00          mov    $0x50,%esi
    0.00 :	  5b7edc:       bf fa b5 88 00          mov    $0x88b5fa,%edi
    0.00 :	  5b7ee1:       e8 3a 35 1c 00          callq  77b420 <elog_start>
    0.00 :	  5b7ee6:       be 30 b6 88 00          mov    $0x88b630,%esi
    0.00 :	  5b7eeb:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b7ef0:       31 c0                   xor    %eax,%eax
    0.00 :	  5b7ef2:       e8 39 33 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5b7ef7:       e8 d4 15 eb ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   10.81 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:261
    8.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:113
    8.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:237
    8.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:281
    5.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
    5.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:234
    5.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:235
    5.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:277
    5.41 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:213
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:63
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:106
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:675
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:675
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:675
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:675
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:227
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:228
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:239
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:245
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:272
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:280
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:299
    2.70 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:302
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bdaa0 <ExecHashJoin>:
         :	 *                        the other one is "outer".
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *                                /* return: a tuple or NULL */
         :	ExecHashJoin(HashJoinState *node)
         :	{
    0.00 :	  5bdaa0:       55                      push   %rbp
    0.00 :	  5bdaa1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bdaa4:       41 57                   push   %r15
    0.00 :	  5bdaa6:       41 56                   push   %r14
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:63
    2.70 :	  5bdaa8:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5bdaab:       41 55                   push   %r13
    0.00 :	  5bdaad:       41 54                   push   %r12
    0.00 :	  5bdaaf:       53                      push   %rbx
    0.00 :	  5bdab0:       48 83 ec 58             sub    $0x58,%rsp
         :	        int                     batchno;
         :
         :	        /*
         :	         * get information from HashJoin node
         :	         */
         :	        joinqual = node->js.joinqual;
    0.00 :	  5bdab4:       48 8b 87 80 00 00 00    mov    0x80(%rdi),%rax
    0.00 :	  5bdabb:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	        otherqual = node->js.ps.qual;
    0.00 :	  5bdabf:       48 8b 57 28             mov    0x28(%rdi),%rdx
    0.00 :	  5bdac3:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	        hashNode = (HashState *) innerPlanState(node);
    0.00 :	  5bdac7:       48 8b 4f 38             mov    0x38(%rdi),%rcx
    0.00 :	  5bdacb:       48 89 4d 98             mov    %rcx,-0x68(%rbp)
         :	        outerNode = outerPlanState(node);
    0.00 :	  5bdacf:       48 8b 47 30             mov    0x30(%rdi),%rax
    0.00 :	  5bdad3:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	        hashtable = node->hj_HashTable;
    0.00 :	  5bdad7:       48 8b 97 a8 00 00 00    mov    0xa8(%rdi),%rdx
    0.00 :	  5bdade:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        econtext = node->js.ps.ps_ExprContext;
    0.00 :	  5bdae2:       48 8b 4f 60             mov    0x60(%rdi),%rcx
    0.00 :	  5bdae6:       48 89 4d b0             mov    %rcx,-0x50(%rbp)
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5bdaea:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
    0.00 :	  5bdaee:       74 1c                   je     5bdb0c <ExecHashJoin+0x6c>
         :	        {
         :	                TupleTableSlot *result;
         :
         :	                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5bdaf0:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5bdaf4:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5bdaf8:       e8 03 f5 fe ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5bdafd:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5bdb01:       0f 84 91 04 00 00       je     5bdf98 <ExecHashJoin+0x4f8>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->js.ps.ps_TupFromTlist = false;
    0.00 :	  5bdb07:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a join tuple.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5bdb0c:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5bdb10:       48 8b 78 28             mov    0x28(%rax),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:106
    2.70 :	  5bdb14:       e8 97 ae 1d 00          callq  7989b0 <MemoryContextReset>
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
    0.00 :	  5bdb19:       49 8d 96 b4 00 00 00    lea    0xb4(%r14),%rdx
    0.00 :	  5bdb20:       48 89 55 88             mov    %rdx,-0x78(%rbp)
    0.00 :	  5bdb24:       0f 1f 40 00             nopl   0x0(%rax)
         :	        /*
         :	         * run the hash join state machine
         :	         */
         :	        for (;;)
         :	        {
         :	                switch (node->hj_JoinState)
    0.00 :	  5bdb28:       41 83 be f0 00 00 00    cmpl   $0x6,0xf0(%r14)
    0.00 :	  5bdb2f:       06 
    0.00 :	  5bdb30:       76 36                   jbe    5bdb68 <ExecHashJoin+0xc8>
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :	                                break;
         :
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
    0.00 :	  5bdb32:       ba c1 ba 88 00          mov    $0x88bac1,%edx
    0.00 :	  5bdb37:       be a7 01 00 00          mov    $0x1a7,%esi
    0.00 :	  5bdb3c:       bf 58 b9 88 00          mov    $0x88b958,%edi
    0.00 :	  5bdb41:       e8 da d8 1b 00          callq  77b420 <elog_start>
    0.00 :	  5bdb46:       41 8b 96 f0 00 00 00    mov    0xf0(%r14),%edx
    0.00 :	  5bdb4d:       be 00 ba 88 00          mov    $0x88ba00,%esi
    0.00 :	  5bdb52:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5bdb57:       31 c0                   xor    %eax,%eax
    0.00 :	  5bdb59:       e8 d2 d6 1b 00          callq  77b230 <elog_finish>
    0.00 :	  5bdb5e:       e8 6d b9 ea ff          callq  4694d0 <abort@plt>
    0.00 :	  5bdb63:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /*
         :	         * run the hash join state machine
         :	         */
         :	        for (;;)
         :	        {
         :	                switch (node->hj_JoinState)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:113
    8.11 :	  5bdb68:       41 8b 86 f0 00 00 00    mov    0xf0(%r14),%eax
    0.00 :	  5bdb6f:       ff 24 c5 50 ba 88 00    jmpq   *0x88ba50(,%rax,8)
    0.00 :	  5bdb76:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bdb7d:       00 00 00 
         :	                                 *
         :	                                 * The only way to make the check is to try to fetch a tuple
         :	                                 * from the outer plan node.  If we succeed, we have to stash
         :	                                 * it away for later consumption by ExecHashJoinOuterGetTuple.
         :	                                 */
         :	                                if (HJ_FILL_INNER(node))
    0.00 :	  5bdb80:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdb87:       00 
    0.00 :	  5bdb88:       0f 84 da 05 00 00       je     5be168 <ExecHashJoin+0x6c8>
         :	                                        }
         :	                                        else
         :	                                                node->hj_OuterNotEmpty = true;
         :	                                }
         :	                                else
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
    0.00 :	  5bdb8e:       49 c7 86 e8 00 00 00    movq   $0x0,0xe8(%r14)
    0.00 :	  5bdb95:       00 00 00 00 
         :
         :	                                /*
         :	                                 * create the hash table
         :	                                 */
         :	                                hashtable = ExecHashTableCreate((Hash *) hashNode->ps.plan,
    0.00 :	  5bdb99:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5bdb9d:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdb9f:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdba6:       00 
    0.00 :	  5bdba7:       49 8b b6 a0 00 00 00    mov    0xa0(%r14),%rsi
    0.00 :	  5bdbae:       48 8b 78 08             mov    0x8(%rax),%rdi
    0.00 :	  5bdbb2:       0f 95 c2                setne  %dl
    0.00 :	  5bdbb5:       e8 e6 ec ff ff          callq  5bc8a0 <ExecHashTableCreate>
         :	                                node->hj_HashTable = hashtable;
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
    0.00 :	  5bdbba:       48 8b 55 98             mov    -0x68(%rbp),%rdx
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :
         :	                                /*
         :	                                 * create the hash table
         :	                                 */
         :	                                hashtable = ExecHashTableCreate((Hash *) hashNode->ps.plan,
    0.00 :	  5bdbbe:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :	                                                                                                node->hj_HashOperators,
         :	                                                                                                HJ_FILL_INNER(node));
         :	                                node->hj_HashTable = hashtable;
    0.00 :	  5bdbc2:       49 89 86 a8 00 00 00    mov    %rax,0xa8(%r14)
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
         :	                                (void) MultiExecProcNode((PlanState *) hashNode);
    0.00 :	  5bdbc9:       48 89 d7                mov    %rdx,%rdi
         :	                                node->hj_HashTable = hashtable;
         :
         :	                                /*
         :	                                 * execute the Hash node, to build the hash table
         :	                                 */
         :	                                hashNode->hashtable = hashtable;
    0.00 :	  5bdbcc:       48 89 42 78             mov    %rax,0x78(%rdx)
         :	                                (void) MultiExecProcNode((PlanState *) hashNode);
    0.00 :	  5bdbd0:       e8 fb e7 fe ff          callq  5ac3d0 <MultiExecProcNode>
         :	                                /*
         :	                                 * If the inner relation is completely empty, and we're not
         :	                                 * doing a left outer join, we can quit without scanning the
         :	                                 * outer relation.
         :	                                 */
         :	                                if (hashtable->totalTuples == 0 && !HJ_FILL_OUTER(node))
    0.00 :	  5bdbd5:       66 0f 57 c0             xorpd  %xmm0,%xmm0
    0.00 :	  5bdbd9:       48 8b 4d b8             mov    -0x48(%rbp),%rcx
    0.00 :	  5bdbdd:       66 0f 2e 41 58          ucomisd 0x58(%rcx),%xmm0
    0.00 :	  5bdbe2:       0f 84 6b 06 00 00       je     5be253 <ExecHashJoin+0x7b3>
         :
         :	                                /*
         :	                                 * need to remember whether nbatch has increased since we
         :	                                 * began scanning the outer relation
         :	                                 */
         :	                                hashtable->nbatch_outstart = hashtable->nbatch;
    0.00 :	  5bdbe8:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  5bdbec:       8b 42 40                mov    0x40(%rdx),%eax
    0.00 :	  5bdbef:       89 42 4c                mov    %eax,0x4c(%rdx)
         :	                                /*
         :	                                 * Reset OuterNotEmpty for scan.  (It's OK if we fetched a
         :	                                 * tuple above, because ExecHashJoinOuterGetTuple will
         :	                                 * immediately set it again.)
         :	                                 */
         :	                                node->hj_OuterNotEmpty = false;
    0.00 :	  5bdbf2:       41 c6 86 f5 00 00 00    movb   $0x0,0xf5(%r14)
    0.00 :	  5bdbf9:       00 
         :
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5bdbfa:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5bdc01:       02 00 00 00 
         :	static TupleTableSlot *
         :	ExecHashJoinOuterGetTuple(PlanState *outerNode,
         :	                                                  HashJoinState *hjstate,
         :	                                                  uint32 *hashvalue)
         :	{
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bdc05:       49 8b 9e a8 00 00 00    mov    0xa8(%r14),%rbx
         :	        int                     curbatch = hashtable->curbatch;
    0.00 :	  5bdc0c:       8b 43 44                mov    0x44(%rbx),%eax
         :	        TupleTableSlot *slot;
         :
         :	        if (curbatch == 0)                      /* if it is the first pass */
    0.00 :	  5bdc0f:       85 c0                   test   %eax,%eax
    0.00 :	  5bdc11:       0f 85 a9 00 00 00       jne    5bdcc0 <ExecHashJoin+0x220>
         :	        {
         :	                /*
         :	                 * Check to see if first outer tuple was already fetched by
         :	                 * ExecHashJoin() and not used yet.
         :	                 */
         :	                slot = hjstate->hj_FirstOuterTupleSlot;
    0.00 :	  5bdc17:       4d 8b a6 e8 00 00 00    mov    0xe8(%r14),%r12
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdc1e:       4d 85 e4                test   %r12,%r12
    0.00 :	  5bdc21:       74 5d                   je     5bdc80 <ExecHashJoin+0x1e0>
    0.00 :	  5bdc23:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
    0.00 :	  5bdc29:       75 55                   jne    5bdc80 <ExecHashJoin+0x1e0>
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
    0.00 :	  5bdc2b:       49 c7 86 e8 00 00 00    movq   $0x0,0xe8(%r14)
    0.00 :	  5bdc32:       00 00 00 00 
    0.00 :	  5bdc36:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bdc3d:       00 00 00 
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
    0.00 :	  5bdc40:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
    0.00 :	  5bdc46:       75 50                   jne    5bdc98 <ExecHashJoin+0x1f8>
         :	                {
         :	                        /*
         :	                         * We have to compute the tuple's hash value.
         :	                         */
         :	                        ExprContext *econtext = hjstate->js.ps.ps_ExprContext;
    0.00 :	  5bdc48:       49 8b 76 60             mov    0x60(%r14),%rsi
         :
         :	                        econtext->ecxt_outertuple = slot;
         :	                        if (ExecHashGetHashValue(hashtable, econtext,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:675
    2.70 :	  5bdc4c:       4c 8d 4d d0             lea    -0x30(%rbp),%r9
    2.70 :	  5bdc50:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  5bdc55:       48 89 df                mov    %rbx,%rdi
         :	                        /*
         :	                         * We have to compute the tuple's hash value.
         :	                         */
         :	                        ExprContext *econtext = hjstate->js.ps.ps_ExprContext;
         :
         :	                        econtext->ecxt_outertuple = slot;
    0.00 :	  5bdc58:       4c 89 66 18             mov    %r12,0x18(%rsi)
         :	                        if (ExecHashGetHashValue(hashtable, econtext,
    2.70 :	  5bdc5c:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5bdc63:       00 
    0.00 :	  5bdc64:       49 8b 96 90 00 00 00    mov    0x90(%r14),%rdx
    0.00 :	  5bdc6b:       41 0f 95 c0             setne  %r8b
    0.00 :	  5bdc6f:       41 83 e0 01             and    $0x1,%r8d
    0.00 :	  5bdc73:       e8 18 e2 ff ff          callq  5bbe90 <ExecHashGetHashValue>
    2.70 :	  5bdc78:       84 c0                   test   %al,%al
    0.00 :	  5bdc7a:       0f 85 90 04 00 00       jne    5be110 <ExecHashJoin+0x670>
         :
         :	                        /*
         :	                         * That tuple couldn't match because of a NULL, so discard it and
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
    0.00 :	  5bdc80:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  5bdc84:       e8 17 e8 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                if (!TupIsNull(slot))
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:667
    5.41 :	  5bdc89:       48 85 c0                test   %rax,%rax
         :
         :	                        /*
         :	                         * That tuple couldn't match because of a NULL, so discard it and
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
    0.00 :	  5bdc8c:       49 89 c4                mov    %rax,%r12
         :	                if (!TupIsNull(slot))
         :	                        hjstate->hj_FirstOuterTupleSlot = NULL;
         :	                else
         :	                        slot = ExecProcNode(outerNode);
         :
         :	                while (!TupIsNull(slot))
    0.00 :	  5bdc8f:       75 af                   jne    5bdc40 <ExecHashJoin+0x1a0>
    0.00 :	  5bdc91:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                                                                                                   node,
         :	                                                                                                                   &hashvalue);
         :	                                if (TupIsNull(outerTupleSlot))
         :	                                {
         :	                                        /* end of batch, or maybe whole join */
         :	                                        if (HJ_FILL_INNER(node))
    0.00 :	  5bdc98:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bdc9f:       00 
    0.00 :	  5bdca0:       0f 84 0a 03 00 00       je     5bdfb0 <ExecHashJoin+0x510>
         :	                                        {
         :	                                                /* set up to scan for unmatched inner tuples */
         :	                                                ExecPrepHashTableForUnmatched(node);
    0.00 :	  5bdca6:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdca9:       e8 52 de ff ff          callq  5bbb00 <ExecPrepHashTableForUnmatched>
         :	                                                node->hj_JoinState = HJ_FILL_INNER_TUPLES;
    0.00 :	  5bdcae:       41 c7 86 f0 00 00 00    movl   $0x5,0xf0(%r14)
    0.00 :	  5bdcb5:       05 00 00 00 
    0.00 :	  5bdcb9:       e9 6a fe ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdcbe:       66 90                   xchg   %ax,%ax
         :	                         * continue with the next one.
         :	                         */
         :	                        slot = ExecProcNode(outerNode);
         :	                }
         :	        }
         :	        else if (curbatch < hashtable->nbatch)
    0.00 :	  5bdcc0:       3b 43 40                cmp    0x40(%rbx),%eax
    0.00 :	  5bdcc3:       7d d3                   jge    5bdc98 <ExecHashJoin+0x1f8>
         :	        {
         :	                BufFile    *file = hashtable->outerBatchFile[curbatch];
    0.00 :	  5bdcc5:       48 63 d0                movslq %eax,%rdx
    0.00 :	  5bdcc8:       48 8b 43 70             mov    0x70(%rbx),%rax
    0.00 :	  5bdccc:       48 8b 34 d0             mov    (%rax,%rdx,8),%rsi
         :
         :	                /*
         :	                 * In outer-join cases, we could get here even though the batch file
         :	                 * is empty.
         :	                 */
         :	                if (file == NULL)
    0.00 :	  5bdcd0:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5bdcd3:       74 c3                   je     5bdc98 <ExecHashJoin+0x1f8>
         :	                        return NULL;
         :
         :	                slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5bdcd5:       49 8b 8e c8 00 00 00    mov    0xc8(%r14),%rcx
    0.00 :	  5bdcdc:       48 8d 55 d0             lea    -0x30(%rbp),%rdx
    0.00 :	  5bdce0:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdce3:       e8 c8 fc ff ff          callq  5bd9b0 <ExecHashJoinGetSavedTuple>
         :	                                                                                 file,
         :	                                                                                 hashvalue,
         :	                                                                                 hjstate->hj_OuterTupleSlot);
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdce8:       48 85 c0                test   %rax,%rax
         :	                 * is empty.
         :	                 */
         :	                if (file == NULL)
         :	                        return NULL;
         :
         :	                slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5bdceb:       49 89 c4                mov    %rax,%r12
         :	                                                                                 file,
         :	                                                                                 hashvalue,
         :	                                                                                 hjstate->hj_OuterTupleSlot);
         :	                if (!TupIsNull(slot))
    0.00 :	  5bdcee:       74 a8                   je     5bdc98 <ExecHashJoin+0x1f8>
    0.00 :	  5bdcf0:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5bdcf4:       75 a2                   jne    5bdc98 <ExecHashJoin+0x1f8>
         :	                                        else
         :	                                                node->hj_JoinState = HJ_NEED_NEW_BATCH;
         :	                                        continue;
         :	                                }
         :
         :	                                econtext->ecxt_outertuple = outerTupleSlot;
    0.00 :	  5bdcf6:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:227
    2.70 :	  5bdcfa:       4c 89 61 18             mov    %r12,0x18(%rcx)
         :
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:234
    5.41 :	  5bdcfe:       8b 75 d0                mov    -0x30(%rbp),%esi
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:235
    5.41 :	  5bdd01:       48 8d 4d cc             lea    -0x34(%rbp),%rcx
    0.00 :	  5bdd05:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  5bdd09:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
         :	                                                node->hj_JoinState = HJ_NEED_NEW_BATCH;
         :	                                        continue;
         :	                                }
         :
         :	                                econtext->ecxt_outertuple = outerTupleSlot;
         :	                                node->hj_MatchedOuter = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:228
    2.70 :	  5bdd0d:       41 c6 86 f4 00 00 00    movb   $0x0,0xf4(%r14)
    0.00 :	  5bdd14:       00 
         :
         :	                                /*
         :	                                 * Find the corresponding bucket for this tuple in the main
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
    0.00 :	  5bdd15:       41 89 b6 b0 00 00 00    mov    %esi,0xb0(%r14)
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
    0.00 :	  5bdd1c:       e8 9f dd ff ff          callq  5bbac0 <ExecHashGetBucketAndBatch>
         :	                                                                                  &node->hj_CurBucketNo, &batchno);
         :	                                node->hj_CurSkewBucketNo = ExecHashGetSkewBucket(hashtable,
    0.00 :	  5bdd21:       8b 75 d0                mov    -0x30(%rbp),%esi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:237
    8.11 :	  5bdd24:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
    0.00 :	  5bdd28:       e8 83 de ff ff          callq  5bbbb0 <ExecHashGetSkewBucket>
         :
         :	                                /*
         :	                                 * The tuple might not belong to the current batch (where
         :	                                 * "current batch" includes the skew buckets if any).
         :	                                 */
         :	                                if (batchno != hashtable->curbatch &&
    0.00 :	  5bdd2d:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
         :	                                 * hash table or skew hash table.
         :	                                 */
         :	                                node->hj_CurHashValue = hashvalue;
         :	                                ExecHashGetBucketAndBatch(hashtable, hashvalue,
         :	                                                                                  &node->hj_CurBucketNo, &batchno);
         :	                                node->hj_CurSkewBucketNo = ExecHashGetSkewBucket(hashtable,
    0.00 :	  5bdd31:       41 89 86 b8 00 00 00    mov    %eax,0xb8(%r14)
         :	                                                                                                                                 hashvalue);
         :	                                node->hj_CurTuple = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:239
    2.70 :	  5bdd38:       49 c7 86 c0 00 00 00    movq   $0x0,0xc0(%r14)
    0.00 :	  5bdd3f:       00 00 00 00 
         :
         :	                                /*
         :	                                 * The tuple might not belong to the current batch (where
         :	                                 * "current batch" includes the skew buckets if any).
         :	                                 */
         :	                                if (batchno != hashtable->curbatch &&
    0.00 :	  5bdd43:       8b 45 cc                mov    -0x34(%rbp),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:245
    2.70 :	  5bdd46:       39 42 44                cmp    %eax,0x44(%rdx)
    0.00 :	  5bdd49:       74 0e                   je     5bdd59 <ExecHashJoin+0x2b9>
    0.00 :	  5bdd4b:       41 83 be b8 00 00 00    cmpl   $0xffffffff,0xb8(%r14)
    0.00 :	  5bdd52:       ff 
    0.00 :	  5bdd53:       0f 84 4d 04 00 00       je     5be1a6 <ExecHashJoin+0x706>
         :	                                        /* Loop around, staying in HJ_NEED_NEW_OUTER state */
         :	                                        continue;
         :	                                }
         :
         :	                                /* OK, let's scan the bucket for matches */
         :	                                node->hj_JoinState = HJ_SCAN_BUCKET;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:261
   10.81 :	  5bdd59:       41 c7 86 f0 00 00 00    movl   $0x3,0xf0(%r14)
    0.00 :	  5bdd60:       03 00 00 00 
         :	                                /*
         :	                                 * We check for interrupts here because this corresponds to
         :	                                 * where we'd fetch a row from a child plan node in other join
         :	                                 * types.
         :	                                 */
         :	                                CHECK_FOR_INTERRUPTS();
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:272
    2.70 :	  5bdd64:       0f b6 05 25 c3 5f 00    movzbl 0x5fc325(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  5bdd6b:       84 c0                   test   %al,%al
    0.00 :	  5bdd6d:       0f 85 8d 03 00 00       jne    5be100 <ExecHashJoin+0x660>
         :
         :	                                /*
         :	                                 * Scan the selected hash bucket for matches to current outer
         :	                                 */
         :	                                if (!ExecScanHashBucket(node, econtext))
    0.00 :	  5bdd73:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:277
    5.41 :	  5bdd77:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdd7a:       e8 21 e0 ff ff          callq  5bbda0 <ExecScanHashBucket>
    0.00 :	  5bdd7f:       84 c0                   test   %al,%al
    0.00 :	  5bdd81:       0f 85 39 02 00 00       jne    5bdfc0 <ExecHashJoin+0x520>
         :	                                {
         :	                                        /* out of matches; check for possible outer-join fill */
         :	                                        node->hj_JoinState = HJ_FILL_OUTER_TUPLE;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:280
    2.70 :	  5bdd87:       41 c7 86 f0 00 00 00    movl   $0x4,0xf0(%r14)
    0.00 :	  5bdd8e:       04 00 00 00 
         :	                                        continue;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:281
    8.11 :	  5bdd92:       e9 91 fd ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdd97:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bdd9e:       00 00 
         :	 * Returns true if successful, false if there are no more batches.
         :	 */
         :	static bool
         :	ExecHashJoinNewBatch(HashJoinState *hjstate)
         :	{
         :	        HashJoinTable hashtable = hjstate->hj_HashTable;
    0.00 :	  5bdda0:       4d 8b a6 a8 00 00 00    mov    0xa8(%r14),%r12
         :	        BufFile    *innerFile;
         :	        TupleTableSlot *slot;
         :	        uint32          hashvalue;
         :
         :	        nbatch = hashtable->nbatch;
         :	        curbatch = hashtable->curbatch;
    0.00 :	  5bdda7:       41 8b 5c 24 44          mov    0x44(%r12),%ebx
         :	        int                     curbatch;
         :	        BufFile    *innerFile;
         :	        TupleTableSlot *slot;
         :	        uint32          hashvalue;
         :
         :	        nbatch = hashtable->nbatch;
    0.00 :	  5bddac:       45 8b 7c 24 40          mov    0x40(%r12),%r15d
         :	        curbatch = hashtable->curbatch;
         :
         :	        if (curbatch > 0)
    0.00 :	  5bddb1:       85 db                   test   %ebx,%ebx
    0.00 :	  5bddb3:       0f 8e 77 03 00 00       jle    5be130 <ExecHashJoin+0x690>
         :	        {
         :	                /*
         :	                 * We no longer need the previous outer batch file; close it right
         :	                 * away to free disk space.
         :	                 */
         :	                if (hashtable->outerBatchFile[curbatch])
    0.00 :	  5bddb9:       48 63 c3                movslq %ebx,%rax
    0.00 :	  5bddbc:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  5bddc3:       00 
    0.00 :	  5bddc4:       4c 89 e8                mov    %r13,%rax
    0.00 :	  5bddc7:       49 03 44 24 70          add    0x70(%r12),%rax
    0.00 :	  5bddcc:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5bddcf:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bddd2:       74 0d                   je     5bdde1 <ExecHashJoin+0x341>
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
    0.00 :	  5bddd4:       e8 d7 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bddd9:       4c 89 e8                mov    %r13,%rax
    0.00 :	  5bdddc:       49 03 44 24 70          add    0x70(%r12),%rax
         :	                hashtable->outerBatchFile[curbatch] = NULL;
    0.00 :	  5bdde1:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
         :	         *
         :	         * 3. Similarly, if we have increased nbatch since starting the outer
         :	         * scan, we have to rescan outer batches in case they contain tuples that
         :	         * need to be reassigned.
         :	         */
         :	        curbatch++;
    0.00 :	  5bdde8:       44 8d 6b 01             lea    0x1(%rbx),%r13d
         :	        while (curbatch < nbatch &&
    0.00 :	  5bddec:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  5bddef:       7f 73                   jg     5bde64 <ExecHashJoin+0x3c4>
    0.00 :	  5bddf1:       e9 7a 04 00 00          jmpq   5be270 <ExecHashJoin+0x7d0>
    0.00 :	  5bddf6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bddfd:       00 00 00 
    0.00 :	  5bde00:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bde05:       48 83 3c d8 00          cmpq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde0a:       0f 85 38 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                   (hashtable->outerBatchFile[curbatch] == NULL ||
         :	                        hashtable->innerBatchFile[curbatch] == NULL))
         :	        {
         :	                if (hashtable->outerBatchFile[curbatch] &&
    0.00 :	  5bde10:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5bde17:       00 
    0.00 :	  5bde18:       0f 85 2a 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        HJ_FILL_INNER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
         :	                        nbatch != hashtable->nbatch_original)
         :	                        break;                          /* must process due to rule 2 */
         :	                if (hashtable->outerBatchFile[curbatch] &&
    0.00 :	  5bde1e:       45 3b 7c 24 4c          cmp    0x4c(%r12),%r15d
    0.00 :	  5bde23:       0f 85 1f 02 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        break;                          /* must process due to rule 3 */
         :	                /* We can ignore this batch. */
         :	                /* Release associated temp files right away. */
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
         :	                hashtable->innerBatchFile[curbatch] = NULL;
    0.00 :	  5bde29:       48 c7 04 d8 00 00 00    movq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde30:       00 
         :	                if (hashtable->outerBatchFile[curbatch])
    0.00 :	  5bde31:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bde35:       49 03 44 24 70          add    0x70(%r12),%rax
    0.00 :	  5bde3a:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5bde3d:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bde40:       74 0e                   je     5bde50 <ExecHashJoin+0x3b0>
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
    0.00 :	  5bde42:       e8 69 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bde47:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bde4b:       49 03 44 24 70          add    0x70(%r12),%rax
         :	                hashtable->outerBatchFile[curbatch] = NULL;
         :	                curbatch++;
    0.00 :	  5bde50:       41 83 c5 01             add    $0x1,%r13d
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
         :	                hashtable->innerBatchFile[curbatch] = NULL;
         :	                if (hashtable->outerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->outerBatchFile[curbatch]);
         :	                hashtable->outerBatchFile[curbatch] = NULL;
    0.00 :	  5bde54:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
         :	         * 3. Similarly, if we have increased nbatch since starting the outer
         :	         * scan, we have to rescan outer batches in case they contain tuples that
         :	         * need to be reassigned.
         :	         */
         :	        curbatch++;
         :	        while (curbatch < nbatch &&
    0.00 :	  5bde5b:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  5bde5e:       0f 8e 0c 04 00 00       jle    5be270 <ExecHashJoin+0x7d0>
    0.00 :	  5bde64:       49 63 dd                movslq %r13d,%rbx
    0.00 :	  5bde67:       48 8d 0c dd 00 00 00    lea    0x0(,%rbx,8),%rcx
    0.00 :	  5bde6e:       00 
    0.00 :	  5bde6f:       48 89 4d c0             mov    %rcx,-0x40(%rbp)
    0.00 :	  5bde73:       49 8b 44 24 70          mov    0x70(%r12),%rax
    0.00 :	  5bde78:       48 83 3c d8 00          cmpq   $0x0,(%rax,%rbx,8)
    0.00 :	  5bde7d:       75 81                   jne    5bde00 <ExecHashJoin+0x360>
         :	                        hashtable->innerBatchFile[curbatch] == NULL))
         :	        {
         :	                if (hashtable->outerBatchFile[curbatch] &&
         :	                        HJ_FILL_OUTER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
    0.00 :	  5bde7f:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bde84:       48 8b 3c d8             mov    (%rax,%rbx,8),%rdi
    0.00 :	  5bde88:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5bde8b:       74 9c                   je     5bde29 <ExecHashJoin+0x389>
    0.00 :	  5bde8d:       49 83 be d8 00 00 00    cmpq   $0x0,0xd8(%r14)
    0.00 :	  5bde94:       00 
    0.00 :	  5bde95:       0f 85 ad 01 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        HJ_FILL_INNER(hjstate))
         :	                        break;                          /* must process due to rule 1 */
         :	                if (hashtable->innerBatchFile[curbatch] &&
    0.00 :	  5bde9b:       45 3b 7c 24 48          cmp    0x48(%r12),%r15d
    0.00 :	  5bdea0:       0f 85 a2 01 00 00       jne    5be048 <ExecHashJoin+0x5a8>
         :	                        nbatch != hashtable->nbatch_outstart)
         :	                        break;                          /* must process due to rule 3 */
         :	                /* We can ignore this batch. */
         :	                /* Release associated temp files right away. */
         :	                if (hashtable->innerBatchFile[curbatch])
         :	                        BufFileClose(hashtable->innerBatchFile[curbatch]);
    0.00 :	  5bdea6:       e8 05 d1 0b 00          callq  67afb0 <BufFileClose>
    0.00 :	  5bdeab:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5bdeb0:       e9 74 ff ff ff          jmpq   5bde29 <ExecHashJoin+0x389>
    0.00 :	  5bdeb5:       0f 1f 00                nopl   (%rax)
         :	                                /*
         :	                                 * We have finished a batch, but we are doing right/full join,
         :	                                 * so any unmatched inner tuples in the hashtable have to be
         :	                                 * emitted before we continue to the next batch.
         :	                                 */
         :	                                if (!ExecScanHashTableForUnmatched(node, econtext))
    0.00 :	  5bdeb8:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdebc:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5bdebf:       e8 ec dd ff ff          callq  5bbcb0 <ExecScanHashTableForUnmatched>
    0.00 :	  5bdec4:       84 c0                   test   %al,%al
    0.00 :	  5bdec6:       0f 84 e4 00 00 00       je     5bdfb0 <ExecHashJoin+0x510>
         :
         :	                                /*
         :	                                 * Generate a fake join tuple with nulls for the outer tuple,
         :	                                 * and return it if it passes the non-join quals.
         :	                                 */
         :	                                econtext->ecxt_outertuple = node->hj_NullOuterTupleSlot;
    0.00 :	  5bdecc:       49 8b 86 d8 00 00 00    mov    0xd8(%r14),%rax
    0.00 :	  5bded3:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5bded7:       48 89 42 18             mov    %rax,0x18(%rdx)
         :
         :	                                if (otherqual == NIL ||
    0.00 :	  5bdedb:       48 83 7d a8 00          cmpq   $0x0,-0x58(%rbp)
    0.00 :	  5bdee0:       0f 84 8c 00 00 00       je     5bdf72 <ExecHashJoin+0x4d2>
    0.00 :	  5bdee6:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdeea:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5bdeee:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdef0:       e8 1b f0 fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdef5:       84 c0                   test   %al,%al
    0.00 :	  5bdef7:       75 79                   jne    5bdf72 <ExecHashJoin+0x4d2>
         :	                                                        (isDone == ExprMultipleResult);
         :	                                                return result;
         :	                                        }
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered2(node, 1);
    0.00 :	  5bdef9:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5bdefd:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdf00:       0f 84 22 fc ff ff       je     5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf06:       f2 0f 10 05 4a 12 1f    movsd  0x1f124a(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bdf0d:       00 
    0.00 :	  5bdf0e:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5bdf15:       00 
    0.00 :	  5bdf16:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5bdf1d:       00 
    0.00 :	  5bdf1e:       e9 05 fc ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf23:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                 * whether to emit a dummy outer-join tuple.  Whether we emit
         :	                                 * one or not, the next state is NEED_NEW_OUTER.
         :	                                 */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :
         :	                                if (!node->hj_MatchedOuter &&
    0.00 :	  5bdf28:       41 80 be f4 00 00 00    cmpb   $0x0,0xf4(%r14)
    0.00 :	  5bdf2f:       00 
         :	                                /*
         :	                                 * The current outer tuple has run out of matches, so check
         :	                                 * whether to emit a dummy outer-join tuple.  Whether we emit
         :	                                 * one or not, the next state is NEED_NEW_OUTER.
         :	                                 */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5bdf30:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5bdf37:       02 00 00 00 
         :
         :	                                if (!node->hj_MatchedOuter &&
    0.00 :	  5bdf3b:       0f 85 e7 fb ff ff       jne    5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdf41:       49 8b 86 e0 00 00 00    mov    0xe0(%r14),%rax
    0.00 :	  5bdf48:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdf4b:       0f 84 d7 fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
         :	                                {
         :	                                        /*
         :	                                         * Generate a fake join tuple with nulls for the inner
         :	                                         * tuple, and return it if it passes the non-join quals.
         :	                                         */
         :	                                        econtext->ecxt_innertuple = node->hj_NullInnerTupleSlot;
    0.00 :	  5bdf51:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
    0.00 :	  5bdf55:       48 89 41 10             mov    %rax,0x10(%rcx)
         :
         :	                                        if (otherqual == NIL ||
    0.00 :	  5bdf59:       48 83 7d a8 00          cmpq   $0x0,-0x58(%rbp)
    0.00 :	  5bdf5e:       74 12                   je     5bdf72 <ExecHashJoin+0x4d2>
    0.00 :	  5bdf60:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5bdf64:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdf66:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  5bdf69:       e8 a2 ef fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdf6e:       84 c0                   test   %al,%al
    0.00 :	  5bdf70:       74 87                   je     5bdef9 <ExecHashJoin+0x459>
         :	                                if (otherqual == NIL ||
         :	                                        ExecQual(otherqual, econtext, false))
         :	                                {
         :	                                        TupleTableSlot *result;
         :
         :	                                        result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5bdf72:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5bdf76:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5bdf7a:       e8 81 f0 fe ff          callq  5ad000 <ExecProject>
         :
         :	                                        if (isDone != ExprEndResult)
    0.00 :	  5bdf7f:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5bdf82:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5bdf85:       0f 84 9d fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
         :	                                        {
         :	                                                node->js.ps.ps_TupFromTlist =
    0.00 :	  5bdf8b:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5bdf8e:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5bdf93:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
         :	                                         (int) node->hj_JoinState);
         :	                }
         :	        }
         :	}
    0.00 :	  5bdf98:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  5bdf9c:       5b                      pop    %rbx
    0.00 :	  5bdf9d:       41 5c                   pop    %r12
    0.00 :	  5bdf9f:       41 5d                   pop    %r13
    0.00 :	  5bdfa1:       41 5e                   pop    %r14
    0.00 :	  5bdfa3:       41 5f                   pop    %r15
    0.00 :	  5bdfa5:       c9                      leaveq 
    0.00 :	  5bdfa6:       c3                      retq   
    0.00 :	  5bdfa7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5bdfae:       00 00 
         :	                                 * emitted before we continue to the next batch.
         :	                                 */
         :	                                if (!ExecScanHashTableForUnmatched(node, econtext))
         :	                                {
         :	                                        /* no more unmatched tuples */
         :	                                        node->hj_JoinState = HJ_NEED_NEW_BATCH;
    0.00 :	  5bdfb0:       41 c7 86 f0 00 00 00    movl   $0x6,0xf0(%r14)
    0.00 :	  5bdfb7:       06 00 00 00 
         :	                                        continue;
    0.00 :	  5bdfbb:       e9 68 fb ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
         :	                                 * table, and return the slot.
         :	                                 *
         :	                                 * Only the joinquals determine tuple match status, but all
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
    0.00 :	  5bdfc0:       48 83 7d a0 00          cmpq   $0x0,-0x60(%rbp)
    0.00 :	  5bdfc5:       74 41                   je     5be008 <ExecHashJoin+0x568>
    0.00 :	  5bdfc7:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
    0.00 :	  5bdfcb:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5bdfcf:       31 d2                   xor    %edx,%edx
    0.00 :	  5bdfd1:       e8 3a ef fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bdfd6:       84 c0                   test   %al,%al
    0.00 :	  5bdfd8:       75 2e                   jne    5be008 <ExecHashJoin+0x568>
         :	                                        }
         :	                                        else
         :	                                                InstrCountFiltered2(node, 1);
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered1(node, 1);
    0.00 :	  5bdfda:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5bdfde:       48 85 c0                test   %rax,%rax
    0.00 :	  5bdfe1:       0f 84 41 fb ff ff       je     5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5bdfe7:       f2 0f 10 05 69 11 1f    movsd  0x1f1169(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bdfee:       00 
    0.00 :	  5bdfef:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5bdff6:       00 
    0.00 :	  5bdff7:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5bdffe:       00 
    0.00 :	  5bdfff:       e9 24 fb ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5be004:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
         :	                                {
         :	                                        node->hj_MatchedOuter = true;
         :	                                        HeapTupleHeaderSetMatch(HJTUPLE_MINTUPLE(node->hj_CurTuple));
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:299
    2.70 :	  5be008:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :	                                 * Only the joinquals determine tuple match status, but all
         :	                                 * quals must pass to actually return the tuple.
         :	                                 */
         :	                                if (joinqual == NIL || ExecQual(joinqual, econtext, false))
         :	                                {
         :	                                        node->hj_MatchedOuter = true;
    0.00 :	  5be00f:       41 c6 86 f4 00 00 00    movb   $0x1,0xf4(%r14)
    0.00 :	  5be016:       01 
         :	                                        HeapTupleHeaderSetMatch(HJTUPLE_MINTUPLE(node->hj_CurTuple));
    0.00 :	  5be017:       66 81 48 1a 00 80       orw    $0x8000,0x1a(%rax)
         :
         :	                                        /* In an antijoin, we never return a matched tuple */
         :	                                        if (node->js.jointype == JOIN_ANTI)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:302
    2.70 :	  5be01d:       41 8b 46 78             mov    0x78(%r14),%eax
    0.00 :	  5be021:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5be024:       0f 84 bd 00 00 00       je     5be0e7 <ExecHashJoin+0x647>
         :
         :	                                        /*
         :	                                         * In a semijoin, we'll consider returning the first
         :	                                         * match, but after that we're done with this outer tuple.
         :	                                         */
         :	                                        if (node->js.jointype == JOIN_SEMI)
    0.00 :	  5be02a:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  5be02d:       0f 85 a8 fe ff ff       jne    5bdedb <ExecHashJoin+0x43b>
         :	                                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5be033:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5be03a:       02 00 00 00 
    0.00 :	  5be03e:       e9 98 fe ff ff          jmpq   5bdedb <ExecHashJoin+0x43b>
    0.00 :	  5be043:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        }
         :
         :	        if (curbatch >= nbatch)
         :	                return false;                   /* no more batches */
         :
         :	        hashtable->curbatch = curbatch;
    0.00 :	  5be048:       45 89 6c 24 44          mov    %r13d,0x44(%r12)
         :
         :	        /*
         :	         * Reload the hash table with the new inner batch (which could be empty)
         :	         */
         :	        ExecHashTableReset(hashtable);
    0.00 :	  5be04d:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be050:       e8 db db ff ff          callq  5bbc30 <ExecHashTableReset>
         :
         :	        innerFile = hashtable->innerBatchFile[curbatch];
    0.00 :	  5be055:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5be05a:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5be05e:       48 8b 1c 10             mov    (%rax,%rdx,1),%rbx
         :
         :	        if (innerFile != NULL)
    0.00 :	  5be062:       48 85 db                test   %rbx,%rbx
    0.00 :	  5be065:       74 5b                   je     5be0c2 <ExecHashJoin+0x622>
         :	        {
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
    0.00 :	  5be067:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5be069:       31 d2                   xor    %edx,%edx
    0.00 :	  5be06b:       31 f6                   xor    %esi,%esi
    0.00 :	  5be06d:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5be070:       e8 8b ca 0b 00          callq  67ab00 <BufFileSeek>
    0.00 :	  5be075:       85 c0                   test   %eax,%eax
    0.00 :	  5be077:       74 15                   je     5be08e <ExecHashJoin+0x5ee>
    0.00 :	  5be079:       e9 08 02 00 00          jmpq   5be286 <ExecHashJoin+0x7e6>
    0.00 :	  5be07e:       66 90                   xchg   %ax,%ax
         :	                {
         :	                        /*
         :	                         * NOTE: some tuples may be sent to future batches.  Also, it is
         :	                         * possible for hashtable->nbatch to be increased here!
         :	                         */
         :	                        ExecHashTableInsert(hashtable, slot, hashvalue);
    0.00 :	  5be080:       8b 55 c8                mov    -0x38(%rbp),%edx
    0.00 :	  5be083:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5be086:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be089:       e8 82 e3 ff ff          callq  5bc410 <ExecHashTableInsert>
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
         :	                                        (errcode_for_file_access(),
         :	                                   errmsg("could not rewind hash-join temporary file: %m")));
         :
         :	                while ((slot = ExecHashJoinGetSavedTuple(hjstate,
    0.00 :	  5be08e:       49 8b 8e d0 00 00 00    mov    0xd0(%r14),%rcx
    0.00 :	  5be095:       48 8d 55 c8             lea    -0x38(%rbp),%rdx
    0.00 :	  5be099:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5be09c:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5be09f:       e8 0c f9 ff ff          callq  5bd9b0 <ExecHashJoinGetSavedTuple>
    0.00 :	  5be0a4:       48 85 c0                test   %rax,%rax
    0.00 :	  5be0a7:       75 d7                   jne    5be080 <ExecHashJoin+0x5e0>
         :
         :	                /*
         :	                 * after we build the hash table, the inner batch file is no longer
         :	                 * needed
         :	                 */
         :	                BufFileClose(innerFile);
    0.00 :	  5be0a9:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5be0ac:       e8 ff ce 0b 00          callq  67afb0 <BufFileClose>
         :	                hashtable->innerBatchFile[curbatch] = NULL;
    0.00 :	  5be0b1:       49 8b 44 24 68          mov    0x68(%r12),%rax
    0.00 :	  5be0b6:       48 8b 4d c0             mov    -0x40(%rbp),%rcx
    0.00 :	  5be0ba:       48 c7 04 08 00 00 00    movq   $0x0,(%rax,%rcx,1)
    0.00 :	  5be0c1:       00 
         :	        }
         :
         :	        /*
         :	         * Rewind outer batch file (if present), so that we can start reading it.
         :	         */
         :	        if (hashtable->outerBatchFile[curbatch] != NULL)
    0.00 :	  5be0c2:       49 8b 44 24 70          mov    0x70(%r12),%rax
    0.00 :	  5be0c7:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  5be0cb:       48 8b 3c 10             mov    (%rax,%rdx,1),%rdi
    0.00 :	  5be0cf:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5be0d2:       74 13                   je     5be0e7 <ExecHashJoin+0x647>
         :	        {
         :	                if (BufFileSeek(hashtable->outerBatchFile[curbatch], 0, 0L, SEEK_SET))
    0.00 :	  5be0d4:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5be0d6:       31 d2                   xor    %edx,%edx
    0.00 :	  5be0d8:       31 f6                   xor    %esi,%esi
    0.00 :	  5be0da:       e8 21 ca 0b 00          callq  67ab00 <BufFileSeek>
    0.00 :	  5be0df:       85 c0                   test   %eax,%eax
    0.00 :	  5be0e1:       0f 85 ea 00 00 00       jne    5be1d1 <ExecHashJoin+0x731>
         :	                                /*
         :	                                 * Try to advance to next batch.  Done if there are no more.
         :	                                 */
         :	                                if (!ExecHashJoinNewBatch(node))
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
    0.00 :	  5be0e7:       41 c7 86 f0 00 00 00    movl   $0x2,0xf0(%r14)
    0.00 :	  5be0ee:       02 00 00 00 
    0.00 :	  5be0f2:       e9 31 fa ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
    0.00 :	  5be0f7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5be0fe:       00 00 
         :	                                /*
         :	                                 * We check for interrupts here because this corresponds to
         :	                                 * where we'd fetch a row from a child plan node in other join
         :	                                 * types.
         :	                                 */
         :	                                CHECK_FOR_INTERRUPTS();
    0.00 :	  5be100:       e8 9b e1 0d 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5be105:       e9 69 fc ff ff          jmpq   5bdd73 <ExecHashJoin+0x2d3>
    0.00 :	  5be10a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                                                         true,          /* outer tuple */
         :	                                                                         HJ_FILL_OUTER(hjstate),
         :	                                                                         hashvalue))
         :	                        {
         :	                                /* remember outer relation is not empty for possible rescan */
         :	                                hjstate->hj_OuterNotEmpty = true;
    0.00 :	  5be110:       41 c6 86 f5 00 00 00    movb   $0x1,0xf5(%r14)
    0.00 :	  5be117:       01 
         :	                                 * We don't have an outer tuple, try to get the next one
         :	                                 */
         :	                                outerTupleSlot = ExecHashJoinOuterGetTuple(outerNode,
         :	                                                                                                                   node,
         :	                                                                                                                   &hashvalue);
         :	                                if (TupIsNull(outerTupleSlot))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHashjoin.c:213
    5.41 :	  5be118:       41 80 7c 24 04 00       cmpb   $0x0,0x4(%r12)
    0.00 :	  5be11e:       0f 85 74 fb ff ff       jne    5bdc98 <ExecHashJoin+0x1f8>
    0.00 :	  5be124:       e9 cd fb ff ff          jmpq   5bdcf6 <ExecHashJoin+0x256>
    0.00 :	  5be129:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                 * Reset some of the skew optimization state variables, since we no
         :	                 * longer need to consider skew tuples after the first batch. The
         :	                 * memory context reset we are about to do will release the skew
         :	                 * hashtable itself.
         :	                 */
         :	                hashtable->skewEnabled = false;
    0.00 :	  5be130:       41 c6 44 24 21 00       movb   $0x0,0x21(%r12)
         :	                hashtable->skewBucket = NULL;
    0.00 :	  5be136:       49 c7 44 24 28 00 00    movq   $0x0,0x28(%r12)
    0.00 :	  5be13d:       00 00 
         :	                hashtable->skewBucketNums = NULL;
    0.00 :	  5be13f:       49 c7 44 24 38 00 00    movq   $0x0,0x38(%r12)
    0.00 :	  5be146:       00 00 
         :	                hashtable->nSkewBuckets = 0;
    0.00 :	  5be148:       41 c7 44 24 34 00 00    movl   $0x0,0x34(%r12)
    0.00 :	  5be14f:       00 00 
         :	                hashtable->spaceUsedSkew = 0;
    0.00 :	  5be151:       49 c7 84 24 a8 00 00    movq   $0x0,0xa8(%r12)
    0.00 :	  5be158:       00 00 00 00 00 
    0.00 :	  5be15d:       e9 86 fc ff ff          jmpq   5bdde8 <ExecHashJoin+0x348>
    0.00 :	  5be162:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be168:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5be16f:       00 
    0.00 :	  5be170:       0f 84 aa 00 00 00       je     5be220 <ExecHashJoin+0x780>
         :	                                                 (outerNode->plan->startup_cost < hashNode->ps.plan->total_cost &&
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
    0.00 :	  5be176:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  5be17a:       e8 21 e3 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
    0.00 :	  5be17f:       48 85 c0                test   %rax,%rax
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
         :	                                                 (outerNode->plan->startup_cost < hashNode->ps.plan->total_cost &&
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
    0.00 :	  5be182:       49 89 86 e8 00 00 00    mov    %rax,0xe8(%r14)
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
    0.00 :	  5be189:       0f 84 e8 00 00 00       je     5be277 <ExecHashJoin+0x7d7>
    0.00 :	  5be18f:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5be193:       0f 85 de 00 00 00       jne    5be277 <ExecHashJoin+0x7d7>
         :	                                        {
         :	                                                node->hj_OuterNotEmpty = false;
         :	                                                return NULL;
         :	                                        }
         :	                                        else
         :	                                                node->hj_OuterNotEmpty = true;
    0.00 :	  5be199:       41 c6 86 f5 00 00 00    movb   $0x1,0xf5(%r14)
    0.00 :	  5be1a0:       01 
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be1a1:       e9 f3 f9 ff ff          jmpq   5bdb99 <ExecHashJoin+0xf9>
         :	                                        /*
         :	                                         * Need to postpone this outer tuple to a later batch.
         :	                                         * Save it in the corresponding outer-batch file.
         :	                                         */
         :	                                        Assert(batchno > hashtable->curbatch);
         :	                                        ExecHashJoinSaveTuple(ExecFetchSlotMinimalTuple(outerTupleSlot),
    0.00 :	  5be1a6:       48 98                   cltq   
    0.00 :	  5be1a8:       8b 5d d0                mov    -0x30(%rbp),%ebx
    0.00 :	  5be1ab:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5be1ae:       4c 8d 2c c5 00 00 00    lea    0x0(,%rax,8),%r13
    0.00 :	  5be1b5:       00 
    0.00 :	  5be1b6:       4c 03 6a 70             add    0x70(%rdx),%r13
    0.00 :	  5be1ba:       e8 91 5d ff ff          callq  5b3f50 <ExecFetchSlotMinimalTuple>
    0.00 :	  5be1bf:       89 de                   mov    %ebx,%esi
    0.00 :	  5be1c1:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5be1c4:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  5be1c7:       e8 94 f3 ff ff          callq  5bd560 <ExecHashJoinSaveTuple>
         :	                                                                                  hashvalue,
         :	                                                                                &hashtable->outerBatchFile[batchno]);
         :	                                        /* Loop around, staying in HJ_NEED_NEW_OUTER state */
         :	                                        continue;
    0.00 :	  5be1cc:       e9 57 f9 ff ff          jmpq   5bdb28 <ExecHashJoin+0x88>
         :	         * Rewind outer batch file (if present), so that we can start reading it.
         :	         */
         :	        if (hashtable->outerBatchFile[curbatch] != NULL)
         :	        {
         :	                if (BufFileSeek(hashtable->outerBatchFile[curbatch], 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
    0.00 :	  5be1d1:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5be1d4:       b9 f0 ba 88 00          mov    $0x88baf0,%ecx
    0.00 :	  5be1d9:       ba 55 03 00 00          mov    $0x355,%edx
    0.00 :	  5be1de:       be 58 b9 88 00          mov    $0x88b958,%esi
    0.00 :	  5be1e3:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5be1e8:       e8 d3 c8 1b 00          callq  77aac0 <errstart>
    0.00 :	  5be1ed:       84 c0                   test   %al,%al
    0.00 :	  5be1ef:       0f 84 69 f9 ff ff       je     5bdb5e <ExecHashJoin+0xbe>
    0.00 :	  5be1f5:       bf d0 b9 88 00          mov    $0x88b9d0,%edi
    0.00 :	  5be1fa:       31 c0                   xor    %eax,%eax
    0.00 :	  5be1fc:       e8 9f e6 1b 00          callq  77c8a0 <errmsg>
    0.00 :	  5be201:       89 c3                   mov    %eax,%ebx
    0.00 :	  5be203:       e8 e8 e8 1b 00          callq  77caf0 <errcode_for_file_access>
    0.00 :	  5be208:       89 de                   mov    %ebx,%esi
    0.00 :	  5be20a:       89 c7                   mov    %eax,%edi
    0.00 :	  5be20c:       31 c0                   xor    %eax,%eax
    0.00 :	  5be20e:       e8 cd c3 1b 00          callq  77a5e0 <errfinish>
    0.00 :	  5be213:       e9 46 f9 ff ff          jmpq   5bdb5e <ExecHashJoin+0xbe>
    0.00 :	  5be218:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5be21f:       00 
         :	                                if (HJ_FILL_INNER(node))
         :	                                {
         :	                                        /* no chance to not build the hash table */
         :	                                        node->hj_FirstOuterTupleSlot = NULL;
         :	                                }
         :	                                else if (HJ_FILL_OUTER(node) ||
    0.00 :	  5be220:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  5be224:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  5be228:       48 8b 4d 98             mov    -0x68(%rbp),%rcx
    0.00 :	  5be22c:       48 8b 51 08             mov    0x8(%rcx),%rdx
    0.00 :	  5be230:       f2 0f 10 42 10          movsd  0x10(%rdx),%xmm0
    0.00 :	  5be235:       66 0f 2e 40 08          ucomisd 0x8(%rax),%xmm0
    0.00 :	  5be23a:       0f 86 4e f9 ff ff       jbe    5bdb8e <ExecHashJoin+0xee>
    0.00 :	  5be240:       41 80 be f5 00 00 00    cmpb   $0x0,0xf5(%r14)
    0.00 :	  5be247:       00 
    0.00 :	  5be248:       0f 85 40 f9 ff ff       jne    5bdb8e <ExecHashJoin+0xee>
    0.00 :	  5be24e:       e9 23 ff ff ff          jmpq   5be176 <ExecHashJoin+0x6d6>
         :	                                /*
         :	                                 * If the inner relation is completely empty, and we're not
         :	                                 * doing a left outer join, we can quit without scanning the
         :	                                 * outer relation.
         :	                                 */
         :	                                if (hashtable->totalTuples == 0 && !HJ_FILL_OUTER(node))
    0.00 :	  5be253:       0f 8a 8f f9 ff ff       jp     5bdbe8 <ExecHashJoin+0x148>
    0.00 :	  5be259:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5be260:       00 
    0.00 :	  5be261:       0f 85 81 f9 ff ff       jne    5bdbe8 <ExecHashJoin+0x148>
    0.00 :	  5be267:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5be26e:       00 00 
         :	                                        return NULL;    /* end of join */
         :	                                node->hj_JoinState = HJ_NEED_NEW_OUTER;
         :	                                break;
         :
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
    0.00 :	  5be270:       31 c0                   xor    %eax,%eax
    0.00 :	  5be272:       e9 21 fd ff ff          jmpq   5bdf98 <ExecHashJoin+0x4f8>
         :	                                                  !node->hj_OuterNotEmpty))
         :	                                {
         :	                                        node->hj_FirstOuterTupleSlot = ExecProcNode(outerNode);
         :	                                        if (TupIsNull(node->hj_FirstOuterTupleSlot))
         :	                                        {
         :	                                                node->hj_OuterNotEmpty = false;
    0.00 :	  5be277:       41 c6 86 f5 00 00 00    movb   $0x0,0xf5(%r14)
    0.00 :	  5be27e:       00 
    0.00 :	  5be27f:       31 c0                   xor    %eax,%eax
         :	                        default:
         :	                                elog(ERROR, "unrecognized hashjoin state: %d",
         :	                                         (int) node->hj_JoinState);
         :	                }
         :	        }
         :	}
    0.00 :	  5be281:       e9 12 fd ff ff          jmpq   5bdf98 <ExecHashJoin+0x4f8>
         :	        innerFile = hashtable->innerBatchFile[curbatch];
         :
         :	        if (innerFile != NULL)
         :	        {
         :	                if (BufFileSeek(innerFile, 0, 0L, SEEK_SET))
         :	                        ereport(ERROR,
    0.00 :	  5be286:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5be289:       b9 f0 ba 88 00          mov    $0x88baf0,%ecx
    0.00 :	  5be28e:       ba 37 03 00 00          mov    $0x337,%edx
    0.00 :	  5be293:       e9 46 ff ff ff          jmpq   5be1de <ExecHashJoin+0x73e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   60.00 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
   11.43 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
    8.57 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1720
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1702
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1714
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1714
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1816
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1749
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1770
    2.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1774
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000049d220 <heap_hot_search_buffer>:
         :	 */
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
    0.00 :	  49d220:       55                      push   %rbp
    0.00 :	  49d221:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  49d224:       41 57                   push   %r15
    0.00 :	  49d226:       4d 89 cf                mov    %r9,%r15
    0.00 :	  49d229:       41 56                   push   %r14
    0.00 :	  49d22b:       4d 89 c6                mov    %r8,%r14
    0.00 :	  49d22e:       41 55                   push   %r13
    0.00 :	  49d230:       41 54                   push   %r12
    0.00 :	  49d232:       53                      push   %rbx
    0.00 :	  49d233:       48 83 ec 28             sub    $0x28,%rsp
         :	        Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  49d237:       85 d2                   test   %edx,%edx
         :	 */
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
    0.00 :	  49d239:       48 89 4d b8             mov    %rcx,-0x48(%rbp)
    0.00 :	  49d23d:       48 89 7d d0             mov    %rdi,-0x30(%rbp)
    0.00 :	  49d241:       48 89 75 c8             mov    %rsi,-0x38(%rbp)
    0.00 :	  49d245:       89 55 c4                mov    %edx,-0x3c(%rbp)
    0.00 :	  49d248:       0f b6 4d 10             movzbl 0x10(%rbp),%ecx
         :	        Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  49d24c:       0f 88 5e 02 00 00       js     49d4b0 <heap_hot_search_buffer+0x290>
    0.00 :	  49d252:       8b 45 c4                mov    -0x3c(%rbp),%eax
    0.00 :	  49d255:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49d258:       4c 63 e8                movslq %eax,%r13
    0.00 :	  49d25b:       49 c1 e5 0d             shl    $0xd,%r13
    0.00 :	  49d25f:       4c 03 2d 92 28 72 00    add    0x722892(%rip),%r13        # bbfaf8 <BufferBlocks>
         :	        bool            at_chain_start;
         :	        bool            valid;
         :	        bool            skip;
         :
         :	        /* If this is not the first call, previous call returned a (live!) tuple */
         :	        if (all_dead)
    0.00 :	  49d266:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d269:       74 03                   je     49d26e <heap_hot_search_buffer+0x4e>
         :	                *all_dead = first_call;
    0.00 :	  49d26b:       41 88 0f                mov    %cl,(%r15)
         :
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1702
    2.86 :	  49d26e:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  49d272:       44 0f b7 60 04          movzwl 0x4(%rax),%r12d
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
         :
         :	        heapTuple->t_self = *tid;
    0.00 :	  49d277:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49d27a:       8b 00                   mov    (%rax),%eax
    0.00 :	  49d27c:       41 89 46 04             mov    %eax,0x4(%r14)
    0.00 :	  49d280:       0f b7 42 04             movzwl 0x4(%rdx),%eax
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d284:       66 45 85 e4             test   %r12w,%r12w
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
         :
         :	        heapTuple->t_self = *tid;
    0.00 :	  49d288:       66 41 89 46 08          mov    %ax,0x8(%r14)
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d28d:       74 4e                   je     49d2dd <heap_hot_search_buffer+0xbd>
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
    0.00 :	  49d28f:       84 c9                   test   %cl,%cl
    0.00 :	  49d291:       89 ce                   mov    %ecx,%esi
    0.00 :	  49d293:       41 0f 94 c0             sete   %r8b
    0.00 :	  49d297:       31 ff                   xor    %edi,%edi
    0.00 :	  49d299:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1714
    2.86 :	  49d2a0:       41 0f b7 55 0c          movzwl 0xc(%r13),%edx
    0.00 :	  49d2a5:       31 c0                   xor    %eax,%eax
    0.00 :	  49d2a7:       41 0f b7 cc             movzwl %r12w,%ecx
    0.00 :	  49d2ab:       66 83 fa 18             cmp    $0x18,%dx
    0.00 :	  49d2af:       76 0b                   jbe    49d2bc <heap_hot_search_buffer+0x9c>
    0.00 :	  49d2b1:       0f b7 c2                movzwl %dx,%eax
    0.00 :	  49d2b4:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  49d2b8:       48 c1 e8 02             shr    $0x2,%rax
    2.86 :	  49d2bc:       48 39 c8                cmp    %rcx,%rax
    0.00 :	  49d2bf:       72 1c                   jb     49d2dd <heap_hot_search_buffer+0xbd>
         :	                        break;
         :
         :	                lp = PageGetItemId(dp, offnum);
         :
         :	                /* check for unused, dead, or redirected items */
         :	                if (!ItemIdIsNormal(lp))
    0.00 :	  49d2c1:       48 8d 51 03             lea    0x3(%rcx),%rdx
    0.00 :	  49d2c5:       41 8b 44 95 08          mov    0x8(%r13,%rdx,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1720
    8.57 :	  49d2ca:       25 00 80 01 00          and    $0x18000,%eax
    0.00 :	  49d2cf:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  49d2d4:       74 3a                   je     49d310 <heap_hot_search_buffer+0xf0>
         :	                {
         :	                        /* We should only see a redirect at start of chain */
         :	                        if (ItemIdIsRedirected(lp) && at_chain_start)
    0.00 :	  49d2d6:       3d 00 00 01 00          cmp    $0x10000,%eax
    0.00 :	  49d2db:       74 13                   je     49d2f0 <heap_hot_search_buffer+0xd0>
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d2dd:       31 c0                   xor    %eax,%eax
         :	                else
         :	                        break;                          /* end of chain */
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  49d2df:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  49d2e3:       5b                      pop    %rbx
    0.00 :	  49d2e4:       41 5c                   pop    %r12
    0.00 :	  49d2e6:       41 5d                   pop    %r13
    0.00 :	  49d2e8:       41 5e                   pop    %r14
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1816
    2.86 :	  49d2ea:       41 5f                   pop    %r15
    0.00 :	  49d2ec:       c9                      leaveq 
    0.00 :	  49d2ed:       c3                      retq   
    0.00 :	  49d2ee:       66 90                   xchg   %ax,%ax
         :
         :	                /* check for unused, dead, or redirected items */
         :	                if (!ItemIdIsNormal(lp))
         :	                {
         :	                        /* We should only see a redirect at start of chain */
         :	                        if (ItemIdIsRedirected(lp) && at_chain_start)
    0.00 :	  49d2f0:       40 84 f6                test   %sil,%sil
    0.00 :	  49d2f3:       74 e8                   je     49d2dd <heap_hot_search_buffer+0xbd>
         :	                        {
         :	                                /* Follow the redirect */
         :	                                offnum = ItemIdGetRedirect(lp);
    0.00 :	  49d2f5:       45 0f b7 64 95 08       movzwl 0x8(%r13,%rdx,4),%r12d
    0.00 :	  49d2fb:       66 41 81 e4 ff 7f       and    $0x7fff,%r12w
         :	        Assert(TransactionIdIsValid(RecentGlobalXmin));
         :
         :	        Assert(ItemPointerGetBlockNumber(tid) == BufferGetBlockNumber(buffer));
         :	        offnum = ItemPointerGetOffsetNumber(tid);
         :	        at_chain_start = first_call;
         :	        skip = !first_call;
    0.00 :	  49d301:       31 f6                   xor    %esi,%esi
         :	        for (;;)
         :	        {
         :	                ItemId          lp;
         :
         :	                /* check for bogus TID */
         :	                if (offnum < FirstOffsetNumber || offnum > PageGetMaxOffsetNumber(dp))
    0.00 :	  49d303:       66 45 85 e4             test   %r12w,%r12w
    0.00 :	  49d307:       75 97                   jne    49d2a0 <heap_hot_search_buffer+0x80>
    0.00 :	  49d309:       eb d2                   jmp    49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d30b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
    0.00 :	  49d310:       41 0f b7 44 95 08       movzwl 0x8(%r13,%rdx,4),%eax
    0.00 :	  49d316:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  49d31b:       49 8d 4c 05 00          lea    0x0(%r13,%rax,1),%rcx
    0.00 :	  49d320:       49 89 4e 10             mov    %rcx,0x10(%r14)
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d324:       41 0f b7 44 95 0a       movzwl 0xa(%r13,%rdx,4),%eax
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d32a:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d32e:       66 d1 e8                shr    %ax
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
         :
         :	                /*
         :	                 * Shouldn't see a HEAP_ONLY tuple at chain start.
         :	                 */
         :	                if (at_chain_start && HeapTupleIsHeapOnly(heapTuple))
    0.00 :	  49d331:       40 84 f6                test   %sil,%sil
         :	                        /* else must be end of chain */
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
    0.00 :	  49d334:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  49d337:       41 89 06                mov    %eax,(%r14)
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d33a:       8b 42 40                mov    0x40(%rdx),%eax
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
    0.00 :	  49d33d:       66 45 89 66 08          mov    %r12w,0x8(%r14)
         :	                        break;
         :	                }
         :
         :	                heapTuple->t_data = (HeapTupleHeader) PageGetItem(dp, lp);
         :	                heapTuple->t_len = ItemIdGetLength(lp);
         :	                heapTuple->t_tableOid = RelationGetRelid(relation);
    0.00 :	  49d342:       41 89 46 0c             mov    %eax,0xc(%r14)
         :	                ItemPointerSetOffsetNumber(&heapTuple->t_self, offnum);
         :
         :	                /*
         :	                 * Shouldn't see a HEAP_ONLY tuple at chain start.
         :	                 */
         :	                if (at_chain_start && HeapTupleIsHeapOnly(heapTuple))
    0.00 :	  49d346:       74 07                   je     49d34f <heap_hot_search_buffer+0x12f>
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1742
   11.43 :	  49d348:       66 83 79 12 00          cmpw   $0x0,0x12(%rcx)
   60.00 :	  49d34d:       78 8e                   js     49d2dd <heap_hot_search_buffer+0xbd>
         :
         :	                /*
         :	                 * The xmin should match the previous xmax value, else chain is
         :	                 * broken.
         :	                 */
         :	                if (TransactionIdIsValid(prev_xmax) &&
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1749
    2.86 :	  49d34f:       85 ff                   test   %edi,%edi
    0.00 :	  49d351:       74 23                   je     49d376 <heap_hot_search_buffer+0x156>
    0.00 :	  49d353:       49 8b 4e 10             mov    0x10(%r14),%rcx
    0.00 :	  49d357:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  49d35c:       0f b7 41 14             movzwl 0x14(%rcx),%eax
    0.00 :	  49d360:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  49d365:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  49d36a:       74 02                   je     49d36e <heap_hot_search_buffer+0x14e>
    0.00 :	  49d36c:       8b 11                   mov    (%rcx),%edx
    0.00 :	  49d36e:       39 fa                   cmp    %edi,%edx
    0.00 :	  49d370:       0f 85 67 ff ff ff       jne    49d2dd <heap_hot_search_buffer+0xbd>
         :	                 * return the first tuple we find.  But on later passes, heapTuple
         :	                 * will initially be pointing to the tuple we returned last time.
         :	                 * Returning it again would be incorrect (and would loop forever), so
         :	                 * we skip it and return the next match we find.
         :	                 */
         :	                if (!skip)
    0.00 :	  49d376:       45 84 c0                test   %r8b,%r8b
    0.00 :	  49d379:       74 65                   je     49d3e0 <heap_hot_search_buffer+0x1c0>
         :	                /*
         :	                 * If we can't see it, maybe no one else can either.  At caller
         :	                 * request, check whether all chain members are dead to all
         :	                 * transactions.
         :	                 */
         :	                if (all_dead && *all_dead &&
    0.00 :	  49d37b:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d37e:       66 90                   xchg   %ax,%ax
    0.00 :	  49d380:       74 0a                   je     49d38c <heap_hot_search_buffer+0x16c>
    0.00 :	  49d382:       41 80 3f 00             cmpb   $0x0,(%r15)
    0.00 :	  49d386:       0f 85 04 01 00 00       jne    49d490 <heap_hot_search_buffer+0x270>
         :
         :	                /*
         :	                 * Check to see if HOT chain continues past this tuple; if so fetch
         :	                 * the next offnum and loop around.
         :	                 */
         :	                if (HeapTupleIsHotUpdated(heapTuple))
    0.00 :	  49d38c:       49 8b 7e 10             mov    0x10(%r14),%rdi
    0.00 :	  49d390:       f6 47 13 40             testb  $0x40,0x13(%rdi)
    0.00 :	  49d394:       0f 84 43 ff ff ff       je     49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d39a:       0f b7 57 14             movzwl 0x14(%rdi),%edx
    0.00 :	  49d39e:       f6 c6 08                test   $0x8,%dh
    0.00 :	  49d3a1:       0f 85 36 ff ff ff       jne    49d2dd <heap_hot_search_buffer+0xbd>
    0.00 :	  49d3a7:       89 d0                   mov    %edx,%eax
    0.00 :	  49d3a9:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  49d3ae:       3d 00 02 00 00          cmp    $0x200,%eax
    0.00 :	  49d3b3:       0f 84 24 ff ff ff       je     49d2dd <heap_hot_search_buffer+0xbd>
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d3b9:       89 d0                   mov    %edx,%eax
         :	                 */
         :	                if (HeapTupleIsHotUpdated(heapTuple))
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
    0.00 :	  49d3bb:       44 0f b7 67 10          movzwl 0x10(%rdi),%r12d
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d3c0:       25 00 18 00 00          and    $0x1800,%eax
    0.00 :	  49d3c5:       3d 00 10 00 00          cmp    $0x1000,%eax
    0.00 :	  49d3ca:       0f 84 a8 00 00 00       je     49d478 <heap_hot_search_buffer+0x258>
    0.00 :	  49d3d0:       8b 7f 04                mov    0x4(%rdi),%edi
    0.00 :	  49d3d3:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  49d3d6:       e9 26 ff ff ff          jmpq   49d301 <heap_hot_search_buffer+0xe1>
    0.00 :	  49d3db:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         * element of the HOT chain we're currently investigating instead
         :	                         * of the root tuple of the HOT chain. This is important because
         :	                         * the *Satisfies routine for historical mvcc snapshots needs the
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
    0.00 :	  49d3e0:       8b 7d c4                mov    -0x3c(%rbp),%edi
    0.00 :	  49d3e3:       e8 48 6c 1d 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  49d3e8:       8b 7d c4                mov    -0x3c(%rbp),%edi
    0.00 :	  49d3eb:       c1 e8 10                shr    $0x10,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1770
    2.86 :	  49d3ee:       66 41 89 46 04          mov    %ax,0x4(%r14)
    0.00 :	  49d3f3:       e8 38 6c 1d 00          callq  674030 <BufferGetBlockNumber>
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d3f8:       48 8b 75 b8             mov    -0x48(%rbp),%rsi
    0.00 :	  49d3fc:       8b 55 c4                mov    -0x3c(%rbp),%edx
    0.00 :	  49d3ff:       4c 89 f7                mov    %r14,%rdi
         :	                         * element of the HOT chain we're currently investigating instead
         :	                         * of the root tuple of the HOT chain. This is important because
         :	                         * the *Satisfies routine for historical mvcc snapshots needs the
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
    0.00 :	  49d402:       66 41 89 46 06          mov    %ax,0x6(%r14)
    0.00 :	  49d407:       66 45 89 66 08          mov    %r12w,0x8(%r14)
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d40c:       ff 16                   callq  *(%rsi)
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1774
    2.86 :	  49d40e:       8b 4d c4                mov    -0x3c(%rbp),%ecx
    0.00 :	  49d411:       4c 8b 45 b8             mov    -0x48(%rbp),%r8
    0.00 :	  49d415:       0f be f8                movsbl %al,%edi
    0.00 :	  49d418:       48 8b 75 c8             mov    -0x38(%rbp),%rsi
    0.00 :	  49d41c:       4c 89 f2                mov    %r14,%rdx
         :	                         * correct tid to decide about the visibility in some cases.
         :	                         */
         :	                        ItemPointerSet(&(heapTuple->t_self), BufferGetBlockNumber(buffer), offnum);
         :
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
    0.00 :	  49d41f:       89 c3                   mov    %eax,%ebx
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
    0.00 :	  49d421:       e8 3a 72 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :	                        /* reset to original, non-redirected, tid */
         :	                        heapTuple->t_self = *tid;
    0.00 :	  49d426:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
         :
         :	                        if (valid)
    0.00 :	  49d42a:       84 db                   test   %bl,%bl
         :	                        /* If it's visible per the snapshot, we must return it */
         :	                        valid = HeapTupleSatisfiesVisibility(heapTuple, snapshot, buffer);
         :	                        CheckForSerializableConflictOut(valid, relation, heapTuple,
         :	                                                                                        buffer, snapshot);
         :	                        /* reset to original, non-redirected, tid */
         :	                        heapTuple->t_self = *tid;
    0.00 :	  49d42c:       8b 01                   mov    (%rcx),%eax
    0.00 :	  49d42e:       41 89 46 04             mov    %eax,0x4(%r14)
    0.00 :	  49d432:       0f b7 41 04             movzwl 0x4(%rcx),%eax
    0.00 :	  49d436:       66 41 89 46 08          mov    %ax,0x8(%r14)
         :
         :	                        if (valid)
    0.00 :	  49d43b:       0f 84 3a ff ff ff       je     49d37b <heap_hot_search_buffer+0x15b>
         :	                        {
         :	                                ItemPointerSetOffsetNumber(tid, offnum);
    0.00 :	  49d441:       66 44 89 61 04          mov    %r12w,0x4(%rcx)
         :	                                PredicateLockTuple(relation, heapTuple, snapshot);
    0.00 :	  49d446:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  49d44a:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  49d44d:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  49d451:       e8 4a 77 1f 00          callq  694ba0 <PredicateLockTuple>
         :	                                if (all_dead)
    0.00 :	  49d456:       4d 85 ff                test   %r15,%r15
    0.00 :	  49d459:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  49d45e:       0f 84 7b fe ff ff       je     49d2df <heap_hot_search_buffer+0xbf>
         :	                                        *all_dead = false;
    0.00 :	  49d464:       41 c6 07 00             movb   $0x0,(%r15)
    0.00 :	  49d468:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  49d46d:       e9 6d fe ff ff          jmpq   49d2df <heap_hot_search_buffer+0xbf>
    0.00 :	  49d472:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                {
         :	                        Assert(ItemPointerGetBlockNumber(&heapTuple->t_data->t_ctid) ==
         :	                                   ItemPointerGetBlockNumber(tid));
         :	                        offnum = ItemPointerGetOffsetNumber(&heapTuple->t_data->t_ctid);
         :	                        at_chain_start = false;
         :	                        prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple->t_data);
    0.00 :	  49d478:       84 d2                   test   %dl,%dl
    0.00 :	  49d47a:       0f 88 50 ff ff ff       js     49d3d0 <heap_hot_search_buffer+0x1b0>
    0.00 :	  49d480:       e8 9b 9c ff ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  49d485:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  49d488:       89 c7                   mov    %eax,%edi
    0.00 :	  49d48a:       e9 72 fe ff ff          jmpq   49d301 <heap_hot_search_buffer+0xe1>
    0.00 :	  49d48f:       90                      nop
         :	                /*
         :	                 * If we can't see it, maybe no one else can either.  At caller
         :	                 * request, check whether all chain members are dead to all
         :	                 * transactions.
         :	                 */
         :	                if (all_dead && *all_dead &&
    0.00 :	  49d490:       8b 35 6a d4 71 00       mov    0x71d46a(%rip),%esi        # bba900 <RecentGlobalXmin>
    0.00 :	  49d496:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49d499:       e8 62 72 30 00          callq  7a4700 <HeapTupleIsSurelyDead>
    0.00 :	  49d49e:       84 c0                   test   %al,%al
    0.00 :	  49d4a0:       0f 85 e6 fe ff ff       jne    49d38c <heap_hot_search_buffer+0x16c>
         :	                        !HeapTupleIsSurelyDead(heapTuple, RecentGlobalXmin))
         :	                        *all_dead = false;
    0.00 :	  49d4a6:       41 c6 07 00             movb   $0x0,(%r15)
    0.00 :	  49d4aa:       e9 dd fe ff ff          jmpq   49d38c <heap_hot_search_buffer+0x16c>
    0.00 :	  49d4af:       90                      nop
         :	bool
         :	heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer,
         :	                                           Snapshot snapshot, HeapTuple heapTuple,
         :	                                           bool *all_dead, bool first_call)
         :	{
         :	        Page            dp = (Page) BufferGetPage(buffer);
    0.00 :	  49d4b0:       89 d0                   mov    %edx,%eax
    0.00 :	  49d4b2:       48 8b 15 5f fc 6d 00    mov    0x6dfc5f(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49d4b9:       f7 d0                   not    %eax
    0.00 :	  49d4bb:       48 98                   cltq   
    0.00 :	  49d4bd:       4c 8b 2c c2             mov    (%rdx,%rax,8),%r13
    0.00 :	  49d4c1:       e9 a0 fd ff ff          jmpq   49d266 <heap_hot_search_buffer+0x46>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1206
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1240
   13.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1215
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1176
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1195
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1178
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1240
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f400 <slot_getattr>:
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    0.00 :	  46f400:       55                      push   %rbp
    0.00 :	  46f401:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46f404:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1156
    3.33 :	  46f408:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  46f40c:       48 89 fb                mov    %rdi,%rbx
    3.33 :	  46f40f:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  46f413:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  46f417:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f41b:       85 f6                   test   %esi,%esi
         :	 *              slot's tupdesc's last attribute will be considered NULL even
         :	 *              when the physical tuple is longer than the tupdesc.
         :	 */
         :	Datum
         :	slot_getattr(TupleTableSlot *slot, int attnum, bool *isnull)
         :	{
    3.33 :	  46f41d:       49 89 d4                mov    %rdx,%r12
         :	        HeapTuple       tuple = slot->tts_tuple;
    0.00 :	  46f420:       48 8b 7f 08             mov    0x8(%rdi),%rdi
         :	        TupleDesc       tupleDesc = slot->tts_tupleDescriptor;
    0.00 :	  46f424:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	        HeapTupleHeader tup;
         :
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
    0.00 :	  46f428:       0f 8e a2 00 00 00       jle    46f4d0 <slot_getattr+0xd0>
         :	        }
         :
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1176
    3.33 :	  46f42e:       3b 73 24                cmp    0x24(%rbx),%esi
    0.00 :	  46f431:       7e 65                   jle    46f498 <slot_getattr+0x98>
         :	        }
         :
         :	        /*
         :	         * return NULL if attnum is out of range according to the tupdesc
         :	         */
         :	        if (attnum > tupleDesc->natts)
    0.00 :	  46f433:       3b 32                   cmp    (%rdx),%esi
    0.00 :	  46f435:       7f 51                   jg     46f488 <slot_getattr+0x88>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1195
    3.33 :	  46f437:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f43a:       0f 84 34 01 00 00       je     46f574 <slot_getattr+0x174>
         :	         *
         :	         * (We have to check this separately because of various inheritance and
         :	         * table-alteration scenarios: the tuple could be either longer or shorter
         :	         * than the tupdesc.)
         :	         */
         :	        tup = tuple->t_data;
    0.00 :	  46f440:       48 8b 7f 10             mov    0x10(%rdi),%rdi
         :	        if (attnum > HeapTupleHeaderGetNatts(tup))
    0.00 :	  46f444:       0f b7 47 12             movzwl 0x12(%rdi),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1206
   20.00 :	  46f448:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  46f44d:       39 c6                   cmp    %eax,%esi
    0.00 :	  46f44f:       7f 37                   jg     46f488 <slot_getattr+0x88>
         :	        }
         :
         :	        /*
         :	         * check if target attribute is null: no point in groveling through tuple
         :	         */
         :	        if (HeapTupleHasNulls(tuple) && att_isnull(attnum - 1, tup->t_bits))
    0.00 :	  46f451:       f6 47 14 01             testb  $0x1,0x14(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1215
    6.67 :	  46f455:       74 18                   je     46f46f <slot_getattr+0x6f>
    0.00 :	  46f457:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  46f45a:       89 c8                   mov    %ecx,%eax
    0.00 :	  46f45c:       83 e1 07                and    $0x7,%ecx
    0.00 :	  46f45f:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  46f462:       48 98                   cltq   
    0.00 :	  46f464:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  46f469:       d3 f8                   sar    %cl,%eax
    0.00 :	  46f46b:       a8 01                   test   $0x1,%al
    0.00 :	  46f46d:       74 19                   je     46f488 <slot_getattr+0x88>
         :	        /*
         :	         * If the attribute's column has been dropped, we force a NULL result.
         :	         * This case should not happen in normal use, but it could happen if we
         :	         * are executing a plan cached before the column was dropped.
         :	         */
         :	        if (tupleDesc->attrs[attnum - 1]->attisdropped)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
    6.67 :	  46f46f:       4c 63 ee                movslq %esi,%r13
    0.00 :	  46f472:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  46f476:       4d 8d 75 ff             lea    -0x1(%r13),%r14
    0.00 :	  46f47a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
    3.33 :	  46f47e:       80 78 61 00             cmpb   $0x0,0x61(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1226
   13.33 :	  46f482:       74 7c                   je     46f500 <slot_getattr+0x100>
    0.00 :	  46f484:       0f 1f 40 00             nopl   0x0(%rax)
         :	        {
         :	                *isnull = true;
    0.00 :	  46f488:       41 c6 04 24 01          movb   $0x1,(%r12)
    0.00 :	  46f48d:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f48f:       eb 20                   jmp    46f4b1 <slot_getattr+0xb1>
    0.00 :	  46f491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * fast path if desired attribute already cached
         :	         */
         :	        if (attnum <= slot->tts_nvalid)
         :	        {
         :	                *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f498:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  46f49c:       48 63 d6                movslq %esi,%rdx
    0.00 :	  46f49f:       0f b6 44 10 ff          movzbl -0x1(%rax,%rdx,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1178
    3.33 :	  46f4a4:       41 88 04 24             mov    %al,(%r12)
         :	                return slot->tts_values[attnum - 1];
    0.00 :	  46f4a8:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f4ac:       48 8b 44 d0 f8          mov    -0x8(%rax,%rdx,8),%rax
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4b1:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  46f4b5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1242
    3.33 :	  46f4ba:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  46f4bf:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    3.33 :	  46f4c4:       c9                      leaveq 
    3.33 :	  46f4c5:       c3                      retq   
    0.00 :	  46f4c6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  46f4cd:       00 00 00 
         :	        /*
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
    0.00 :	  46f4d0:       48 85 ff                test   %rdi,%rdi
    0.00 :	  46f4d3:       74 4b                   je     46f520 <slot_getattr+0x120>
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
    0.00 :	  46f4d5:       48 8d 43 40             lea    0x40(%rbx),%rax
    0.00 :	  46f4d9:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  46f4dc:       74 6c                   je     46f54a <slot_getattr+0x14a>
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4de:       4c 89 e1                mov    %r12,%rcx
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
         :	        return slot->tts_values[attnum - 1];
         :	}
    0.00 :	  46f4e1:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  46f4e5:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  46f4ea:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  46f4ef:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  46f4f4:       c9                      leaveq 
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
         :	                return heap_getsysattr(tuple, attnum, tupleDesc, isnull);
    0.00 :	  46f4f5:       e9 d6 f7 ff ff          jmpq   46ecd0 <heap_getsysattr>
    0.00 :	  46f4fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        }
         :
         :	        /*
         :	         * Extract the attribute, along with any preceding attributes.
         :	         */
         :	        slot_deform_tuple(slot, attnum);
    0.00 :	  46f500:       48 89 df                mov    %rbx,%rdi
    0.00 :	  46f503:       e8 08 fa ff ff          callq  46ef10 <slot_deform_tuple>
         :
         :	        /*
         :	         * The result is acquired from tts_values array.
         :	         */
         :	        *isnull = slot->tts_isnull[attnum - 1];
    0.00 :	  46f508:       48 8b 43 30             mov    0x30(%rbx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1240
    3.33 :	  46f50c:       42 0f b6 44 28 ff       movzbl -0x1(%rax,%r13,1),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1240
   16.67 :	  46f512:       41 88 04 24             mov    %al,(%r12)
         :	        return slot->tts_values[attnum - 1];
    0.00 :	  46f516:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  46f51a:       4a 8b 04 f0             mov    (%rax,%r14,8),%rax
         :	}
    0.00 :	  46f51e:       eb 91                   jmp    46f4b1 <slot_getattr+0xb1>
         :	         * system attributes are handled by heap_getsysattr
         :	         */
         :	        if (attnum <= 0)
         :	        {
         :	                if (tuple == NULL)              /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from virtual tuple");
    0.00 :	  46f520:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f525:       be 8f 04 00 00          mov    $0x48f,%esi
    0.00 :	  46f52a:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f52f:       e8 ec be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f534:       be 40 f7 7a 00          mov    $0x7af740,%esi
    0.00 :	  46f539:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f53e:       31 c0                   xor    %eax,%eax
    0.00 :	  46f540:       e8 eb bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f545:       e8 86 9f ff ff          callq  4694d0 <abort@plt>
         :	                if (tuple == &(slot->tts_minhdr))               /* internal error */
         :	                        elog(ERROR, "cannot extract system attribute from minimal tuple");
    0.00 :	  46f54a:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f54f:       be 91 04 00 00          mov    $0x491,%esi
    0.00 :	  46f554:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f559:       e8 c2 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f55e:       be 78 f7 7a 00          mov    $0x7af778,%esi
    0.00 :	  46f563:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f568:       31 c0                   xor    %eax,%eax
    0.00 :	  46f56a:       e8 c1 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f56f:       e8 5c 9f ff ff          callq  4694d0 <abort@plt>
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46f574:       ba f1 f6 7a 00          mov    $0x7af6f1,%edx
    0.00 :	  46f579:       be ac 04 00 00          mov    $0x4ac,%esi
    0.00 :	  46f57e:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f583:       e8 98 be 30 00          callq  77b420 <elog_start>
    0.00 :	  46f588:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46f58d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f592:       31 c0                   xor    %eax,%eax
    0.00 :	  46f594:       e8 97 bc 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f599:       e8 32 9f ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   23.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:400
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:359
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:509
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:404
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:356
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:361
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:361
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:364
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:367
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:367
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:457
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:457
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:449
    3.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:400
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005ac4a0 <ExecProcNode>:
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac4a0:       0f b6 05 e9 db 60 00    movzbl 0x60dbe9(%rip),%eax        # bba090 <InterruptPending>
         :	 *              Execute the given node to return a(nother) tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
    0.00 :	  5ac4a7:       55                      push   %rbp
    0.00 :	  5ac4a8:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5ac4ab:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:356
    3.33 :	  5ac4ad:       49 89 fc                mov    %rdi,%r12
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac4b0:       84 c0                   test   %al,%al
         :	 *              Execute the given node to return a(nother) tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
    0.00 :	  5ac4b2:       53                      push   %rbx
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:359
    6.67 :	  5ac4b3:       75 6b                   jne    5ac520 <ExecProcNode+0x80>
         :
         :	        if (node->chgParam != NULL) /* something changed */
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:361
    3.33 :	  5ac4b5:       49 83 7c 24 50 00       cmpq   $0x0,0x50(%r12)
    3.33 :	  5ac4bb:       74 08                   je     5ac4c5 <ExecProcNode+0x25>
         :	                ExecReScan(node);               /* let ReScan handle this */
    0.00 :	  5ac4bd:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac4c0:       e8 db bf ff ff          callq  5a84a0 <ExecReScan>
         :
         :	        if (node->instrument)
    0.00 :	  5ac4c5:       49 8b 7c 24 18          mov    0x18(%r12),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:364
    3.33 :	  5ac4ca:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ac4cd:       74 05                   je     5ac4d4 <ExecProcNode+0x34>
         :	                InstrStartNode(node->instrument);
    0.00 :	  5ac4cf:       e8 2c ba 00 00          callq  5b7f00 <InstrStartNode>
         :
         :	        switch (nodeTag(node))
    0.00 :	  5ac4d4:       41 8b 04 24             mov    (%r12),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:367
    3.33 :	  5ac4d8:       2d c9 00 00 00          sub    $0xc9,%eax
    3.33 :	  5ac4dd:       83 f8 21                cmp    $0x21,%eax
    0.00 :	  5ac4e0:       76 2e                   jbe    5ac510 <ExecProcNode+0x70>
         :	                case T_LimitState:
         :	                        result = ExecLimit((LimitState *) node);
         :	                        break;
         :
         :	                default:
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
    0.00 :	  5ac4e2:       ba e2 a3 88 00          mov    $0x88a3e2,%edx
    0.00 :	  5ac4e7:       be f8 01 00 00          mov    $0x1f8,%esi
    0.00 :	  5ac4ec:       bf 75 a0 88 00          mov    $0x88a075,%edi
    0.00 :	  5ac4f1:       e8 2a ef 1c 00          callq  77b420 <elog_start>
    0.00 :	  5ac4f6:       41 8b 14 24             mov    (%r12),%edx
    0.00 :	  5ac4fa:       be 5c 17 87 00          mov    $0x87175c,%esi
    0.00 :	  5ac4ff:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5ac504:       31 c0                   xor    %eax,%eax
    0.00 :	  5ac506:       e8 25 ed 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5ac50b:       e8 c0 cf eb ff          callq  4694d0 <abort@plt>
         :	                ExecReScan(node);               /* let ReScan handle this */
         :
         :	        if (node->instrument)
         :	                InstrStartNode(node->instrument);
         :
         :	        switch (nodeTag(node))
    0.00 :	  5ac510:       89 c0                   mov    %eax,%eax
    0.00 :	  5ac512:       ff 24 c5 a0 a1 88 00    jmpq   *0x88a1a0(,%rax,8)
    0.00 :	  5ac519:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	TupleTableSlot *
         :	ExecProcNode(PlanState *node)
         :	{
         :	        TupleTableSlot *result;
         :
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  5ac520:       e8 7b fd 0e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5ac525:       eb 8e                   jmp    5ac4b5 <ExecProcNode+0x15>
    0.00 :	  5ac527:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5ac52e:       00 00 
         :	                case T_LockRowsState:
         :	                        result = ExecLockRows((LockRowsState *) node);
         :	                        break;
         :
         :	                case T_LimitState:
         :	                        result = ExecLimit((LimitState *) node);
    0.00 :	  5ac530:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac533:       e8 a8 3c 01 00          callq  5c01e0 <ExecLimit>
    0.00 :	  5ac538:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5ac53b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
         :	                        result = NULL;
         :	                        break;
         :	        }
         :
         :	        if (node->instrument)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:509
    6.67 :	  5ac540:       49 8b 7c 24 18          mov    0x18(%r12),%rdi
    0.00 :	  5ac545:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ac548:       74 20                   je     5ac56a <ExecProcNode+0xca>
         :	                InstrStopNode(node->instrument, TupIsNull(result) ? 0.0 : 1.0);
    0.00 :	  5ac54a:       48 85 db                test   %rbx,%rbx
    0.00 :	  5ac54d:       0f 84 ed 01 00 00       je     5ac740 <ExecProcNode+0x2a0>
    0.00 :	  5ac553:       80 7b 04 00             cmpb   $0x0,0x4(%rbx)
    0.00 :	  5ac557:       0f 85 e3 01 00 00       jne    5ac740 <ExecProcNode+0x2a0>
    0.00 :	  5ac55d:       f2 0f 10 05 f3 2b 20    movsd  0x202bf3(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5ac564:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
    3.33 :	  5ac565:       e8 66 b6 00 00          callq  5b7bd0 <InstrStopNode>
         :
         :	        return result;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
    3.33 :	  5ac56a:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5ac56d:       5b                      pop    %rbx
    0.00 :	  5ac56e:       41 5c                   pop    %r12
    0.00 :	  5ac570:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:513
   10.00 :	  5ac571:       c3                      retq   
    0.00 :	  5ac572:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                case T_SetOpState:
         :	                        result = ExecSetOp((SetOpState *) node);
         :	                        break;
         :
         :	                case T_LockRowsState:
         :	                        result = ExecLockRows((LockRowsState *) node);
    0.00 :	  5ac578:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac57b:       e8 a0 40 01 00          callq  5c0620 <ExecLockRows>
    0.00 :	  5ac580:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac583:       eb bb                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac585:       0f 1f 00                nopl   (%rax)
         :	                case T_HashState:
         :	                        result = ExecHash((HashState *) node);
         :	                        break;
         :
         :	                case T_SetOpState:
         :	                        result = ExecSetOp((SetOpState *) node);
    0.00 :	  5ac588:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac58b:       e8 60 98 01 00          callq  5c5df0 <ExecSetOp>
    0.00 :	  5ac590:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac593:       eb ab                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac595:       0f 1f 00                nopl   (%rax)
         :	                case T_UniqueState:
         :	                        result = ExecUnique((UniqueState *) node);
         :	                        break;
         :
         :	                case T_HashState:
         :	                        result = ExecHash((HashState *) node);
    0.00 :	  5ac598:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac59b:       e8 d0 02 01 00          callq  5bc870 <ExecHash>
    0.00 :	  5ac5a0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5a3:       eb 9b                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5a5:       0f 1f 00                nopl   (%rax)
         :	                case T_WindowAggState:
         :	                        result = ExecWindowAgg((WindowAggState *) node);
         :	                        break;
         :
         :	                case T_UniqueState:
         :	                        result = ExecUnique((UniqueState *) node);
    0.00 :	  5ac5a8:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5ab:       e8 20 a0 01 00          callq  5c65d0 <ExecUnique>
    0.00 :	  5ac5b0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5b3:       eb 8b                   jmp    5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5b5:       0f 1f 00                nopl   (%rax)
         :	                case T_AggState:
         :	                        result = ExecAgg((AggState *) node);
         :	                        break;
         :
         :	                case T_WindowAggState:
         :	                        result = ExecWindowAgg((WindowAggState *) node);
    0.00 :	  5ac5b8:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5bb:       e8 90 00 02 00          callq  5cc650 <ExecWindowAgg>
    0.00 :	  5ac5c0:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5c3:       e9 78 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
    0.00 :	  5ac5c8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ac5cf:       00 
         :	                case T_GroupState:
         :	                        result = ExecGroup((GroupState *) node);
         :	                        break;
         :
         :	                case T_AggState:
         :	                        result = ExecAgg((AggState *) node);
    0.00 :	  5ac5d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5d3:       e8 a8 d7 00 00          callq  5b9d80 <ExecAgg>
    0.00 :	  5ac5d8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5db:       e9 60 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SortState:
         :	                        result = ExecSort((SortState *) node);
         :	                        break;
         :
         :	                case T_GroupState:
         :	                        result = ExecGroup((GroupState *) node);
    0.00 :	  5ac5e0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5e3:       e8 88 ab 01 00          callq  5c7170 <ExecGroup>
    0.00 :	  5ac5e8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5eb:       e9 50 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MaterialState:
         :	                        result = ExecMaterial((MaterialState *) node);
         :	                        break;
         :
         :	                case T_SortState:
         :	                        result = ExecSort((SortState *) node);
    0.00 :	  5ac5f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac5f3:       e8 48 9d 01 00          callq  5c6340 <ExecSort>
    0.00 :	  5ac5f8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac5fb:       e9 40 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * materialization nodes
         :	                         */
         :	                case T_MaterialState:
         :	                        result = ExecMaterial((MaterialState *) node);
    0.00 :	  5ac600:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac603:       e8 38 47 01 00          callq  5c0d40 <ExecMaterial>
    0.00 :	  5ac608:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac60b:       e9 30 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MergeJoinState:
         :	                        result = ExecMergeJoin((MergeJoinState *) node);
         :	                        break;
         :
         :	                case T_HashJoinState:
         :	                        result = ExecHashJoin((HashJoinState *) node);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:457
    3.33 :	  5ac610:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac613:       e8 88 14 01 00          callq  5bdaa0 <ExecHashJoin>
    3.33 :	  5ac618:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac61b:       e9 20 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_NestLoopState:
         :	                        result = ExecNestLoop((NestLoopState *) node);
         :	                        break;
         :
         :	                case T_MergeJoinState:
         :	                        result = ExecMergeJoin((MergeJoinState *) node);
    0.00 :	  5ac620:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac623:       e8 08 5a 01 00          callq  5c2030 <ExecMergeJoin>
    0.00 :	  5ac628:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac62b:       e9 10 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * join nodes
         :	                         */
         :	                case T_NestLoopState:
         :	                        result = ExecNestLoop((NestLoopState *) node);
    0.00 :	  5ac630:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac633:       e8 08 7c 01 00          callq  5c4240 <ExecNestLoop>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:449
    3.33 :	  5ac638:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac63b:       e9 00 ff ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_WorkTableScanState:
         :	                        result = ExecWorkTableScan((WorkTableScanState *) node);
         :	                        break;
         :
         :	                case T_ForeignScanState:
         :	                        result = ExecForeignScan((ForeignScanState *) node);
    0.00 :	  5ac640:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac643:       e8 f8 d2 01 00          callq  5c9940 <ExecForeignScan>
    0.00 :	  5ac648:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac64b:       e9 f0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_CteScanState:
         :	                        result = ExecCteScan((CteScanState *) node);
         :	                        break;
         :
         :	                case T_WorkTableScanState:
         :	                        result = ExecWorkTableScan((WorkTableScanState *) node);
    0.00 :	  5ac650:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac653:       e8 f8 a8 01 00          callq  5c6f50 <ExecWorkTableScan>
    0.00 :	  5ac658:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac65b:       e9 e0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ValuesScanState:
         :	                        result = ExecValuesScan((ValuesScanState *) node);
         :	                        break;
         :
         :	                case T_CteScanState:
         :	                        result = ExecCteScan((CteScanState *) node);
    0.00 :	  5ac660:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac663:       e8 28 a6 01 00          callq  5c6c90 <ExecCteScan>
    0.00 :	  5ac668:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac66b:       e9 d0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_FunctionScanState:
         :	                        result = ExecFunctionScan((FunctionScanState *) node);
         :	                        break;
         :
         :	                case T_ValuesScanState:
         :	                        result = ExecValuesScan((ValuesScanState *) node);
    0.00 :	  5ac670:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac673:       e8 18 a2 01 00          callq  5c6890 <ExecValuesScan>
    0.00 :	  5ac678:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac67b:       e9 c0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SubqueryScanState:
         :	                        result = ExecSubqueryScan((SubqueryScanState *) node);
         :	                        break;
         :
         :	                case T_FunctionScanState:
         :	                        result = ExecFunctionScan((FunctionScanState *) node);
    0.00 :	  5ac680:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac683:       e8 28 86 01 00          callq  5c4cb0 <ExecFunctionScan>
    0.00 :	  5ac688:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac68b:       e9 b0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_TidScanState:
         :	                        result = ExecTidScan((TidScanState *) node);
         :	                        break;
         :
         :	                case T_SubqueryScanState:
         :	                        result = ExecSubqueryScan((SubqueryScanState *) node);
    0.00 :	  5ac690:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac693:       e8 d8 c7 01 00          callq  5c8e70 <ExecSubqueryScan>
    0.00 :	  5ac698:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac69b:       e9 a0 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_BitmapHeapScanState:
         :	                        result = ExecBitmapHeapScan((BitmapHeapScanState *) node);
         :	                        break;
         :
         :	                case T_TidScanState:
         :	                        result = ExecTidScan((TidScanState *) node);
    0.00 :	  5ac6a0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6a3:       e8 58 ca 01 00          callq  5c9100 <ExecTidScan>
    0.00 :	  5ac6a8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6ab:       e9 90 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                        break;
         :
         :	                        /* BitmapIndexScanState does not yield tuples */
         :
         :	                case T_BitmapHeapScanState:
         :	                        result = ExecBitmapHeapScan((BitmapHeapScanState *) node);
    0.00 :	  5ac6b0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6b3:       e8 68 e8 00 00          callq  5baf20 <ExecBitmapHeapScan>
    0.00 :	  5ac6b8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6bb:       e9 80 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_IndexScanState:
         :	                        result = ExecIndexScan((IndexScanState *) node);
         :	                        break;
         :
         :	                case T_IndexOnlyScanState:
         :	                        result = ExecIndexOnlyScan((IndexOnlyScanState *) node);
    0.00 :	  5ac6c0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6c3:       e8 b8 33 01 00          callq  5bfa80 <ExecIndexOnlyScan>
    0.00 :	  5ac6c8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6cb:       e9 70 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_SeqScanState:
         :	                        result = ExecSeqScan((SeqScanState *) node);
         :	                        break;
         :
         :	                case T_IndexScanState:
         :	                        result = ExecIndexScan((IndexScanState *) node);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:404
    6.67 :	  5ac6d0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6d3:       e8 08 2e 01 00          callq  5bf4e0 <ExecIndexScan>
    0.00 :	  5ac6d8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6db:       e9 60 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :
         :	                        /*
         :	                         * scan nodes
         :	                         */
         :	                case T_SeqScanState:
         :	                        result = ExecSeqScan((SeqScanState *) node);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:400
    3.33 :	  5ac6e0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6e3:       e8 28 92 01 00          callq  5c5910 <ExecSeqScan>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:400
   23.33 :	  5ac6e8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6eb:       e9 50 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_MergeAppendState:
         :	                        result = ExecMergeAppend((MergeAppendState *) node);
         :	                        break;
         :
         :	                case T_RecursiveUnionState:
         :	                        result = ExecRecursiveUnion((RecursiveUnionState *) node);
    0.00 :	  5ac6f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac6f3:       e8 d8 8b 01 00          callq  5c52d0 <ExecRecursiveUnion>
    0.00 :	  5ac6f8:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac6fb:       e9 40 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_AppendState:
         :	                        result = ExecAppend((AppendState *) node);
         :	                        break;
         :
         :	                case T_MergeAppendState:
         :	                        result = ExecMergeAppend((MergeAppendState *) node);
    0.00 :	  5ac700:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac703:       e8 c8 48 01 00          callq  5c0fd0 <ExecMergeAppend>
    0.00 :	  5ac708:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac70b:       e9 30 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ModifyTableState:
         :	                        result = ExecModifyTable((ModifyTableState *) node);
         :	                        break;
         :
         :	                case T_AppendState:
         :	                        result = ExecAppend((AppendState *) node);
    0.00 :	  5ac710:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac713:       e8 68 ba 00 00          callq  5b8180 <ExecAppend>
    0.00 :	  5ac718:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac71b:       e9 20 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                case T_ResultState:
         :	                        result = ExecResult((ResultState *) node);
         :	                        break;
         :
         :	                case T_ModifyTableState:
         :	                        result = ExecModifyTable((ModifyTableState *) node);
    0.00 :	  5ac720:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac723:       e8 d8 6a 01 00          callq  5c3200 <ExecModifyTable>
    0.00 :	  5ac728:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac72b:       e9 10 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	        {
         :	                        /*
         :	                         * control nodes
         :	                         */
         :	                case T_ResultState:
         :	                        result = ExecResult((ResultState *) node);
    0.00 :	  5ac730:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ac733:       e8 08 8f 01 00          callq  5c5640 <ExecResult>
    0.00 :	  5ac738:       48 89 c3                mov    %rax,%rbx
         :	                        break;
    0.00 :	  5ac73b:       e9 00 fe ff ff          jmpq   5ac540 <ExecProcNode+0xa0>
         :	                        result = NULL;
         :	                        break;
         :	        }
         :
         :	        if (node->instrument)
         :	                InstrStopNode(node->instrument, TupIsNull(result) ? 0.0 : 1.0);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execProcnode.c:510
    6.67 :	  5ac740:       66 0f 57 c0             xorpd  %xmm0,%xmm0
    0.00 :	  5ac744:       e9 1c fe ff ff          jmpq   5ac565 <ExecProcNode+0xc5>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   17.86 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:888
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:993
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:551
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:940
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:489
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:491
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:504
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:540
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:516
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:931
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:944
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:944
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:971
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:971
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    3.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:977
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782f20 <CHashInsert>:
         :	 * degrading performance; or CHashAllocate may enter a tight loop until such
         :	 * time as an element is deleted).
         :	 */
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
    0.00 :	  782f20:       55                      push   %rbp
    0.00 :	  782f21:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782f24:       41 57                   push   %r15
    0.00 :	  782f26:       41 56                   push   %r14
    0.00 :	  782f28:       41 55                   push   %r13
    0.00 :	  782f2a:       41 54                   push   %r12
    0.00 :	  782f2c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  782f2f:       53                      push   %rbx
    0.00 :	  782f30:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  782f34:       48 89 75 a0             mov    %rsi,-0x60(%rbp)
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  782f38:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  782f3c:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:489
    3.57 :	  782f40:       e8 0b d4 d0 ff          callq  490350 <hash_any>
    0.00 :	  782f45:       89 45 a8                mov    %eax,-0x58(%rbp)
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782f48:       41 23 44 24 10          and    0x10(%r12),%eax
         :	{
         :	        uint32          f_current;
         :	        CHashPtr        new;
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  782f4d:       8b 35 b5 5b 3e 00       mov    0x3e5bb5(%rip),%esi        # b68b08 <MyBackendId>
    0.00 :	  782f53:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
         :	 */
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782f59:       89 45 ac                mov    %eax,-0x54(%rbp)
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782f5c:       89 c0                   mov    %eax,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:491
    3.57 :	  782f5e:       4c 8d 3c 85 00 00 00    lea    0x0(,%rax,4),%r15
    0.00 :	  782f65:       00 
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
    0.00 :	  782f66:       8b 05 78 cd 43 00       mov    0x43cd78(%rip),%eax        # bbfce4 <MyProcPid>
         :	bool
         :	CHashInsert(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782f6c:       4d 03 7c 24 20          add    0x20(%r12),%r15
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
    0.00 :	  782f71:       41 39 44 24 38          cmp    %eax,0x38(%r12)
    0.00 :	  782f76:       74 26                   je     782f9e <CHashInsert+0x7e>
         :	        {
         :	                table->gc_pid = MyProcPid;
         :	                table->gc_next = ((uint32) MyProcPid) % CHashTableNGarbage(table);
    0.00 :	  782f78:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
    0.00 :	  782f7e:       41 8b 54 24 10          mov    0x10(%r12),%edx
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :
         :	        /* If this process hasn't initialized gc_next yet, do that now. */
         :	        if (table->gc_pid != MyProcPid)
         :	        {
         :	                table->gc_pid = MyProcPid;
    0.00 :	  782f83:       41 89 44 24 38          mov    %eax,0x38(%r12)
         :	                table->gc_next = ((uint32) MyProcPid) % CHashTableNGarbage(table);
    0.00 :	  782f88:       8b 05 56 cd 43 00       mov    0x43cd56(%rip),%eax        # bbfce4 <MyProcPid>
    0.00 :	  782f8e:       83 c2 01                add    $0x1,%edx
    0.00 :	  782f91:       d3 ea                   shr    %cl,%edx
    0.00 :	  782f93:       89 d1                   mov    %edx,%ecx
    0.00 :	  782f95:       31 d2                   xor    %edx,%edx
    0.00 :	  782f97:       f7 f1                   div    %ecx
    0.00 :	  782f99:       41 89 54 24 3c          mov    %edx,0x3c(%r12)
         :	{
         :	        uint32          f_current;
         :	        CHashPtr        new;
         :
         :	        /* Pick a starting freelist base on our backend ID. */
         :	        f_current = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  782f9e:       0f b7 cf                movzwl %di,%ecx
    0.00 :	  782fa1:       89 f0                   mov    %esi,%eax
    0.00 :	  782fa3:       31 d2                   xor    %edx,%edx
    0.00 :	  782fa5:       f7 f1                   div    %ecx
    0.00 :	  782fa7:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  782fad:       49 8b 74 24 28          mov    0x28(%r12),%rsi
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
         :	                return InvalidCHashPtr;
         :
         :	        /* If we're unable to empty the list via compare-and-swap, fail. */
         :	        if (!__sync_bool_compare_and_swap(b, garbage, InvalidCHashPtr))
    0.00 :	  782fb2:       41 bb fe ff ff ff       mov    $0xfffffffe,%r11d
         :	                 * If we attempt to pop the free-list and fail, we retry immediately
         :	                 * with the same free-list.  This reduces the frequency with which
         :	                 * we're obliged to update our hazard pointers, which is a material
         :	                 * savings due to the associated memory barrier.
         :	                 */
         :	                b = CHashTableGetFreeList(table, f_current);
    0.00 :	  782fb8:       44 8d 42 01             lea    0x1(%rdx),%r8d
    0.00 :	  782fbc:       44 89 c0                mov    %r8d,%eax
    0.00 :	  782fbf:       d3 e0                   shl    %cl,%eax
    0.00 :	  782fc1:       01 d0                   add    %edx,%eax
    0.00 :	  782fc3:       48 8d 0c 86             lea    (%rsi,%rax,4),%rcx
         :	                MyProc->hazard[0] = b;
    0.00 :	  782fc7:       48 8b 05 7a a9 3f 00    mov    0x3fa97a(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  782fce:       48 89 88 e8 02 00 00    mov    %rcx,0x2e8(%rax)
         :	                pg_memory_barrier();
    0.00 :	  782fd5:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	                new = *b;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:888
   17.86 :	  782fda:       8b 19                   mov    (%rcx),%ebx
         :	                while (!CHashPtrIsInvalid(new))
    0.00 :	  782fdc:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  782fdf:       76 23                   jbe    783004 <CHashInsert+0xe4>
    0.00 :	  782fe1:       e9 52 01 00 00          jmpq   783138 <CHashInsert+0x218>
    0.00 :	  782fe6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  782fed:       00 00 00 
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
         :	                                return new;
         :	                        CHashTableIncrementStatistic(table, CHS_Allocate_Fail);
    0.00 :	  782ff0:       49 83 84 24 a0 00 00    addq   $0x1,0xa0(%r12)
    0.00 :	  782ff7:       00 01 
         :	                        new = *b;
    0.00 :	  782ff9:       8b 19                   mov    (%rcx),%ebx
         :	                 */
         :	                b = CHashTableGetFreeList(table, f_current);
         :	                MyProc->hazard[0] = b;
         :	                pg_memory_barrier();
         :	                new = *b;
         :	                while (!CHashPtrIsInvalid(new))
    0.00 :	  782ffb:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  782ffe:       0f 87 34 01 00 00       ja     783138 <CHashInsert+0x218>
         :	                {
         :	                        CHashNode  *n = CHashTableGetNode(table, new);
    0.00 :	  783004:       89 de                   mov    %ebx,%esi
         :	                         * n is computed from table->freelist[f_current], which could
         :	                         * be modified by concurrent activity, so we need a dependency
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
    0.00 :	  783006:       49 8b 44 24 30          mov    0x30(%r12),%rax
         :	                MyProc->hazard[0] = b;
         :	                pg_memory_barrier();
         :	                new = *b;
         :	                while (!CHashPtrIsInvalid(new))
         :	                {
         :	                        CHashNode  *n = CHashTableGetNode(table, new);
    0.00 :	  78300b:       d1 ee                   shr    %esi
         :	                         * n is computed from table->freelist[f_current], which could
         :	                         * be modified by concurrent activity, so we need a dependency
         :	                         * barrier here.
         :	                         */
         :	                        pg_read_barrier_depends();
         :	                        if (__sync_bool_compare_and_swap(b, new, n->un.gcnext))
    0.00 :	  78300d:       89 f2                   mov    %esi,%edx
    0.00 :	  78300f:       41 0f af 54 24 1c       imul   0x1c(%r12),%edx
    0.00 :	  783015:       8b 54 10 04             mov    0x4(%rax,%rdx,1),%edx
    0.00 :	  783019:       89 d8                   mov    %ebx,%eax
    0.00 :	  78301b:       f0 0f b1 11             lock cmpxchg %edx,(%rcx)
    0.00 :	  78301f:       75 cf                   jne    782ff0 <CHashInsert+0xd0>
         :	         * Allocate and initialize a new entry, on the assumption that the insert
         :	         * will succeed.  If it ends up failing, we must be sure to put this back
         :	         * on some free list, lest it be permanently leaked.
         :	         */
         :	        new = CHashAllocate(table);
         :	        nnew = CHashTableGetNode(table, new);
    0.00 :	  783021:       41 89 f5                mov    %esi,%r13d
         :	        nnew->un.hashcode = hashcode;
    0.00 :	  783024:       8b 4d a8                mov    -0x58(%rbp),%ecx
         :	         * Allocate and initialize a new entry, on the assumption that the insert
         :	         * will succeed.  If it ends up failing, we must be sure to put this back
         :	         * on some free list, lest it be permanently leaked.
         :	         */
         :	        new = CHashAllocate(table);
         :	        nnew = CHashTableGetNode(table, new);
    0.00 :	  783027:       45 0f af 6c 24 1c       imul   0x1c(%r12),%r13d
    0.00 :	  78302d:       4d 03 6c 24 30          add    0x30(%r12),%r13
         :	        nnew->un.hashcode = hashcode;
    0.00 :	  783032:       41 89 4d 04             mov    %ecx,0x4(%r13)
         :	        memcpy(CHashNodeGetItem(nnew), entry, table->desc.element_size);
    0.00 :	  783036:       41 0f b7 54 24 0c       movzwl 0xc(%r12),%edx
    0.00 :	  78303c:       49 8d 7d 08             lea    0x8(%r13),%rdi
    0.00 :	  783040:       48 8b 75 a0             mov    -0x60(%rbp),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:504
    3.57 :	  783044:       e8 a7 6b ce ff          callq  469bf0 <memcpy@plt>
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783049:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
    0.00 :	  78304f:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  783052:       d3 ea                   shr    %cl,%edx
    0.00 :	  783054:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  78305a:       89 d0                   mov    %edx,%eax
    0.00 :	  78305c:       d3 e8                   shr    %cl,%eax
    0.00 :	  78305e:       01 d0                   add    %edx,%eax
    0.00 :	  783060:       48 8b 15 e1 a8 3f 00    mov    0x3fa8e1(%rip),%rdx        # b7d948 <MyProc>
    0.00 :	  783067:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  78306b:       49 03 44 24 28          add    0x28(%r12),%rax
    0.00 :	  783070:       48 89 82 e8 02 00 00    mov    %rax,0x2e8(%rdx)
         :	        pg_memory_barrier();
    0.00 :	  783077:       f0 83 04 24 00          lock addl $0x0,(%rsp)
    0.00 :	  78307c:       4c 8d 75 b0             lea    -0x50(%rbp),%r14
    0.00 :	  783080:       eb 20                   jmp    7830a2 <CHashInsert+0x182>
    0.00 :	  783082:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * where N is the number of buckets and M is the number of elements
         :	                 * in the table.  Even for a quite modestly size table this is likely
         :	                 * to exceed the number of CPU cores.
         :	                 */
         :	                Assert(!CHashPtrIsMarked(scan.target));
         :	                nnew->next = scan.target;
    0.00 :	  783088:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  78308b:       41 89 45 00             mov    %eax,0x0(%r13)
         :	                if (!__sync_bool_compare_and_swap(scan.pointer_to_target,
    0.00 :	  78308f:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  783093:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  783096:       f0 0f b1 1a             lock cmpxchg %ebx,(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:540
    3.57 :	  78309a:       74 49                   je     7830e5 <CHashInsert+0x1c5>
         :	                                                                                  scan.target, new))
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_Insert_Retry);
    0.00 :	  78309c:       49 83 44 24 60 01       addq   $0x1,0x60(%r12)
         :	         * Scan the bucket.  If we don't find a match, use compare-and-swap to
         :	         * insert the new node at the insert position.  If we do find a match,
         :	         * return the data to the caller.
         :	         */
         :	retry:
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
    0.00 :	  7830a2:       48 8b 4d a0             mov    -0x60(%rbp),%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:516
    3.57 :	  7830a6:       8b 55 a8                mov    -0x58(%rbp),%edx
    0.00 :	  7830a9:       4d 89 f0                mov    %r14,%r8
    0.00 :	  7830ac:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  7830af:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  7830b2:       e8 e9 fb ff ff          callq  782ca0 <CHashBucketScan>
         :	        if (scan.found)
    0.00 :	  7830b7:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  7830bb:       74 cb                   je     783088 <CHashInsert+0x168>
         :	                memcpy(((char *) entry) + table->desc.key_size,
    0.00 :	  7830bd:       41 0f b7 44 24 0e       movzwl 0xe(%r12),%eax
    0.00 :	  7830c3:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  7830c7:       41 0f b7 54 24 0c       movzwl 0xc(%r12),%edx
    0.00 :	  7830cd:       0f b7 f0                movzwl %ax,%esi
    0.00 :	  7830d0:       48 01 f7                add    %rsi,%rdi
    0.00 :	  7830d3:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	  7830d7:       48 03 75 c0             add    -0x40(%rbp),%rsi
    0.00 :	  7830db:       29 c2                   sub    %eax,%edx
    0.00 :	  7830dd:       48 63 d2                movslq %edx,%rdx
    0.00 :	  7830e0:       e8 0b 6b ce ff          callq  469bf0 <memcpy@plt>
         :	                }
         :	        }
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  7830e5:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:551
    7.14 :	  7830ea:       48 8b 05 57 a8 3f 00    mov    0x3fa857(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  7830f1:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  7830f8:       00 00 00 00 
         :	         * guarantees that any allocation still in progress at the time this
         :	         * element makes it back to the freelist is trying to allocate some
         :	         * other node.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_Insert);
         :	        if (scan.found)
    0.00 :	  7830fc:       31 c0                   xor    %eax,%eax
         :	         * progress at the time we popped the freelist has completed.  This
         :	         * guarantees that any allocation still in progress at the time this
         :	         * element makes it back to the freelist is trying to allocate some
         :	         * other node.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_Insert);
    0.00 :	  7830fe:       49 83 44 24 50 01       addq   $0x1,0x50(%r12)
         :	        if (scan.found)
    0.00 :	  783104:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  783108:       74 17                   je     783121 <CHashInsert+0x201>
         :	        {
         :	                CHashTableIncrementStatistic(table, CHS_Insert_Failed);
    0.00 :	  78310a:       49 83 44 24 58 01       addq   $0x1,0x58(%r12)
         :	                CHashAddToGarbage(table, bucket, new);
    0.00 :	  783110:       8b 75 ac                mov    -0x54(%rbp),%esi
    0.00 :	  783113:       89 da                   mov    %ebx,%edx
    0.00 :	  783115:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  783118:       e8 33 fb ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  78311d:       0f b6 45 c8             movzbl -0x38(%rbp),%eax
    0.00 :	  783121:       84 c0                   test   %al,%al
    0.00 :	  783123:       0f 94 c0                sete   %al
         :	        }
         :
         :	        /* The insert succeeded if and only if no duplicate was found. */
         :	        return !scan.found;
         :	}
    0.00 :	  783126:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  78312a:       5b                      pop    %rbx
    0.00 :	  78312b:       41 5c                   pop    %r12
    0.00 :	  78312d:       41 5d                   pop    %r13
    0.00 :	  78312f:       41 5e                   pop    %r14
    0.00 :	  783131:       41 5f                   pop    %r15
    0.00 :	  783133:       c9                      leaveq 
    0.00 :	  783134:       c3                      retq   
    0.00 :	  783135:       0f 1f 00                nopl   (%rax)
         :	        CHashPtr        new;
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
    0.00 :	  783138:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
    0.00 :	  78313e:       8b 05 c4 59 3e 00       mov    0x3e59c4(%rip),%eax        # b68b08 <MyBackendId>
    0.00 :	  783144:       31 d2                   xor    %edx,%edx
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  783146:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  78314c:       4d 8b 4c 24 28          mov    0x28(%r12),%r9
         :	        CHashPtr        new;
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:931
    3.57 :	  783151:       f7 f7                   div    %edi
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  783153:       8d 42 01                lea    0x1(%rdx),%eax
    0.00 :	  783156:       d3 e0                   shl    %cl,%eax
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783158:       41 0f b6 4c 24 14       movzbl 0x14(%r12),%ecx
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  78315e:       01 d0                   add    %edx,%eax
    0.00 :	  783160:       4c 8d 14 85 00 00 00    lea    0x0(,%rax,4),%r10
    0.00 :	  783167:       00 
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783168:       41 8b 44 24 3c          mov    0x3c(%r12),%eax
    0.00 :	  78316d:       8d 50 01                lea    0x1(%rax),%edx
    0.00 :	  783170:       41 8b 44 24 10          mov    0x10(%r12),%eax
    0.00 :	  783175:       8d 70 01                lea    0x1(%rax),%esi
    0.00 :	  783178:       89 d0                   mov    %edx,%eax
    0.00 :	  78317a:       31 d2                   xor    %edx,%edx
    0.00 :	  78317c:       d3 ee                   shr    %cl,%esi
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  78317e:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  783184:       f7 f6                   div    %esi
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  783186:       4c 89 ce                mov    %r9,%rsi
    0.00 :	  783189:       89 d0                   mov    %edx,%eax
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
         :
         :	        /* Select target garbage list. */
         :	        table->gc_next = (table->gc_next + 1) % CHashTableNGarbage(table);
    0.00 :	  78318b:       41 89 54 24 3c          mov    %edx,0x3c(%r12)
         :	        b = CHashTableGetGarbageList(table, table->gc_next);
    0.00 :	  783190:       d3 e8                   shr    %cl,%eax
    0.00 :	  783192:       01 d0                   add    %edx,%eax
    0.00 :	  783194:       49 8d 14 81             lea    (%r9,%rax,4),%rdx
         :	        garbage = *b;
    0.00 :	  783198:       8b 1a                   mov    (%rdx),%ebx
         :
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:940
    7.14 :	  78319a:       83 fb fd                cmp    $0xfffffffd,%ebx
    0.00 :	  78319d:       76 11                   jbe    7831b0 <CHashInsert+0x290>
         :	                new = CHashAllocateViaGC(table);
         :	                if (!CHashPtrIsInvalid(new))
         :	                        return new;
         :
         :	                /* Advance to next freelist. */
         :	                f_current = (f_current + 1) % CHashTableNFreeLists(table);
    0.00 :	  78319f:       44 89 c0                mov    %r8d,%eax
    0.00 :	  7831a2:       31 d2                   xor    %edx,%edx
    0.00 :	  7831a4:       f7 f7                   div    %edi
    0.00 :	  7831a6:       e9 0d fe ff ff          jmpq   782fb8 <CHashInsert+0x98>
    0.00 :	  7831ab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        /* If list is empty, fail. */
         :	        if (CHashPtrIsInvalid(garbage))
         :	                return InvalidCHashPtr;
         :
         :	        /* If we're unable to empty the list via compare-and-swap, fail. */
         :	        if (!__sync_bool_compare_and_swap(b, garbage, InvalidCHashPtr))
    0.00 :	  7831b0:       89 d8                   mov    %ebx,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:944
    3.57 :	  7831b2:       f0 44 0f b1 1a          lock cmpxchg %r11d,(%rdx)
    3.57 :	  7831b7:       74 1c                   je     7831d5 <CHashInsert+0x2b5>
         :	        {
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Dequeue_Fail);
    0.00 :	  7831b9:       49 83 84 24 b0 00 00    addq   $0x1,0xb0(%r12)
    0.00 :	  7831c0:       00 01 
    0.00 :	  7831c2:       49 8b 74 24 28          mov    0x28(%r12),%rsi
    0.00 :	  7831c7:       41 0f b6 4c 24 15       movzbl 0x15(%r12),%ecx
    0.00 :	  7831cd:       41 0f b7 7c 24 16       movzwl 0x16(%r12),%edi
    0.00 :	  7831d3:       eb ca                   jmp    78319f <CHashInsert+0x27f>
         :	         * requeues the garbage if it's not immediately recycleable, but
         :	         * it's not clear that we need such a thing.  On the flip side we
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
    0.00 :	  7831d5:       49 83 84 24 b8 00 00    addq   $0x1,0xb8(%r12)
    0.00 :	  7831dc:       00 01 
         :	        CHashNode  *n;
         :	        uint32          i;
         :
         :	        /* Pick a target freelist based on our backend ID. */
         :	        f_home = ((uint32) MyBackendId) % CHashTableNFreeLists(table);
         :	        fh = CHashTableGetFreeList(table, f_home);
    0.00 :	  7831de:       4f 8d 04 11             lea    (%r9,%r10,1),%r8
         :	         * it's not clear that we need such a thing.  On the flip side we
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
    0.00 :	  7831e2:       48 8b 05 5f a7 3f 00    mov    0x3fa75f(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  7831e9:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  7831f0:       00 00 00 00 
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
    0.00 :	  7831f4:       48 8b 35 5d a7 3f 00    mov    0x3fa75d(%rip),%rsi        # b7d958 <ProcGlobal>
    0.00 :	  7831fb:       8b 46 10                mov    0x10(%rsi),%eax
    0.00 :	  7831fe:       85 c0                   test   %eax,%eax
    0.00 :	  783200:       74 5f                   je     783261 <CHashInsert+0x341>
    0.00 :	  783202:       31 ff                   xor    %edi,%edi
    0.00 :	  783204:       eb 1a                   jmp    783220 <CHashInsert+0x300>
    0.00 :	  783206:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  78320d:       00 00 00 
         :	        {
         :	                volatile PGPROC *proc = &ProcGlobal->allProcs[i];
         :	                void       *hazard;
         :
         :	                hazard = proc->hazard[0];
         :	                if (hazard == b || hazard == fh)
    0.00 :	  783210:       49 39 c8                cmp    %rcx,%r8
    0.00 :	  783213:       74 23                   je     783238 <CHashInsert+0x318>
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:971
    3.57 :	  783215:       83 c7 01                add    $0x1,%edi
    0.00 :	  783218:       3b 7e 10                cmp    0x10(%rsi),%edi
    0.00 :	  78321b:       73 44                   jae    783261 <CHashInsert+0x341>
    3.57 :	  78321d:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                volatile PGPROC *proc = &ProcGlobal->allProcs[i];
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    3.57 :	  783220:       89 f8                   mov    %edi,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    7.14 :	  783222:       48 69 c0 f0 02 00 00    imul   $0x2f0,%rax,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:973
    3.57 :	  783229:       48 03 06                add    (%rsi),%rax
         :	                void       *hazard;
         :
         :	                hazard = proc->hazard[0];
    0.00 :	  78322c:       48 8b 88 e8 02 00 00    mov    0x2e8(%rax),%rcx
         :	                if (hazard == b || hazard == fh)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:977
    3.57 :	  783233:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  783236:       75 d8                   jne    783210 <CHashInsert+0x2f0>
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_GC_Spin);
    0.00 :	  783238:       49 83 84 24 c0 00 00    addq   $0x1,0xc0(%r12)
    0.00 :	  78323f:       00 01 
         :	                        do
         :	                        {
         :	                                hazard = proc->hazard[0];
    0.00 :	  783241:       48 8b 88 e8 02 00 00    mov    0x2e8(%rax),%rcx
         :	                        } while (hazard == b || hazard == fh);
    0.00 :	  783248:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  78324b:       74 f4                   je     783241 <CHashInsert+0x321>
    0.00 :	  78324d:       49 39 c8                cmp    %rcx,%r8
    0.00 :	  783250:       74 ef                   je     783241 <CHashInsert+0x321>
    0.00 :	  783252:       48 8b 35 ff a6 3f 00    mov    0x3fa6ff(%rip),%rsi        # b7d958 <ProcGlobal>
         :	         * might want to eventually enter a longer sleep here, or PANIC,
         :	         * but it's not clear exactly how to calibrate that.
         :	         */
         :	        CHashTableIncrementStatistic(table, CHS_GC);
         :	        MyProc->hazard[0] = NULL;
         :	        for (i = 0; i < ProcGlobal->allProcCount; i++)
    0.00 :	  783259:       83 c7 01                add    $0x1,%edi
    0.00 :	  78325c:       3b 7e 10                cmp    0x10(%rsi),%edi
    0.00 :	  78325f:       72 bf                   jb     783220 <CHashInsert+0x300>
         :	                }
         :	        }
         :
         :	        /* Remove one item from list to satisfy current allocation. */
         :	        new = garbage;
         :	        n = CHashTableGetNode(table, new);
    0.00 :	  783261:       89 de                   mov    %ebx,%esi
         :	        pg_read_barrier_depends();
         :	        fhead = n->un.gcnext;
    0.00 :	  783263:       49 8b 44 24 30          mov    0x30(%r12),%rax
         :	                }
         :	        }
         :
         :	        /* Remove one item from list to satisfy current allocation. */
         :	        new = garbage;
         :	        n = CHashTableGetNode(table, new);
    0.00 :	  783268:       d1 ee                   shr    %esi
         :	        pg_read_barrier_depends();
         :	        fhead = n->un.gcnext;
    0.00 :	  78326a:       89 f2                   mov    %esi,%edx
    0.00 :	  78326c:       41 0f af 54 24 1c       imul   0x1c(%r12),%edx
    0.00 :	  783272:       8b 54 10 04             mov    0x4(%rax,%rdx,1),%edx
         :
         :	        if (CHashPtrIsInvalid(fhead))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:993
   14.29 :	  783276:       83 fa fd                cmp    $0xfffffffd,%edx
    0.00 :	  783279:       76 13                   jbe    78328e <CHashInsert+0x36e>
         :	                 * before we overwrite n->un.gcnext with a new hashcode.
         :	                 * (This is only needed when we reclaim exactly one node,
         :	                 * because in any other case we'll do a compare-and-swap
         :	                 * before returning, which implies a full barrier.)
         :	                 */
         :	                pg_memory_barrier();
    0.00 :	  78327b:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Skipped);
    0.00 :	  783280:       49 83 84 24 c8 00 00    addq   $0x1,0xc8(%r12)
    0.00 :	  783287:       00 01 
    0.00 :	  783289:       e9 93 fd ff ff          jmpq   783021 <CHashInsert+0x101>
         :	        }
         :	        else if (__sync_bool_compare_and_swap(fh, InvalidCHashPtr, fhead))
    0.00 :	  78328e:       b8 fe ff ff ff          mov    $0xfffffffe,%eax
    0.00 :	  783293:       f0 41 0f b1 10          lock cmpxchg %edx,(%r8)
    0.00 :	  783298:       74 41                   je     7832db <CHashInsert+0x3bb>
         :	        {
         :	                /*
         :	                 * Our free list is empty, and we've succesfully pushed the
         :	                 * reclaimed nodes onto it.  So we're done.
         :	                 */
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Fast);
    0.00 :	  78329a:       4d 8b 4c 24 30          mov    0x30(%r12),%r9
    0.00 :	  78329f:       41 8b 7c 24 1c          mov    0x1c(%r12),%edi
    0.00 :	  7832a4:       89 d0                   mov    %edx,%eax
         :
         :	                /* Walk list of reclaimed elements to end. */
         :	                fcurrent = fhead;
         :	                for (;;)
         :	                {
         :	                        n = CHashTableGetNode(table, fcurrent);
    0.00 :	  7832a6:       d1 e8                   shr    %eax
    0.00 :	  7832a8:       0f af c7                imul   %edi,%eax
    0.00 :	  7832ab:       49 8d 0c 01             lea    (%r9,%rax,1),%rcx
         :	                        fnext = n->un.gcnext;
    0.00 :	  7832af:       8b 41 04                mov    0x4(%rcx),%eax
         :	                        if (CHashPtrIsInvalid(fnext))
    0.00 :	  7832b2:       83 f8 fd                cmp    $0xfffffffd,%eax
    0.00 :	  7832b5:       76 ef                   jbe    7832a6 <CHashInsert+0x386>
    0.00 :	  7832b7:       eb 10                   jmp    7832c9 <CHashInsert+0x3a9>
    0.00 :	  7832b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                {
         :	                        oldhead = *fh;
         :	                        n->un.gcnext = oldhead;
         :	                        if (__sync_bool_compare_and_swap(fh, oldhead, fhead))
         :	                                break;
         :	                        CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Retry);
    0.00 :	  7832c0:       49 83 84 24 d8 00 00    addq   $0x1,0xd8(%r12)
    0.00 :	  7832c7:       00 01 
         :	                }
         :
         :	                /* Push reclaimed elements onto home free list. */
         :	                for (;;)
         :	                {
         :	                        oldhead = *fh;
    0.00 :	  7832c9:       41 8b 00                mov    (%r8),%eax
         :	                        n->un.gcnext = oldhead;
    0.00 :	  7832cc:       89 41 04                mov    %eax,0x4(%rcx)
         :	                        if (__sync_bool_compare_and_swap(fh, oldhead, fhead))
    0.00 :	  7832cf:       f0 41 0f b1 10          lock cmpxchg %edx,(%r8)
    0.00 :	  7832d4:       75 ea                   jne    7832c0 <CHashInsert+0x3a0>
    0.00 :	  7832d6:       e9 46 fd ff ff          jmpq   783021 <CHashInsert+0x101>
         :	        {
         :	                /*
         :	                 * Our free list is empty, and we've succesfully pushed the
         :	                 * reclaimed nodes onto it.  So we're done.
         :	                 */
         :	                CHashTableIncrementStatistic(table, CHS_GC_Reclaim_Fast);
    0.00 :	  7832db:       49 83 84 24 d0 00 00    addq   $0x1,0xd0(%r12)
    0.00 :	  7832e2:       00 01 
    0.00 :	  7832e4:       e9 38 fd ff ff          jmpq   783021 <CHashInsert+0x101>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   18.52 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:864
    7.41 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    7.41 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:774
    7.41 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:774
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:731
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:732
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:881
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:871
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:747
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:774
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:965
    3.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:965
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004960f0 <heapgettup_pagemode>:
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    3.70 :	  4960f0:       55                      push   %rbp
         :	        HeapTuple       tuple = &(scan->rs_ctup);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:731
    3.70 :	  4960f1:       48 8d 47 48             lea    0x48(%rdi),%rax
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  4960f5:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4960f8:       41 57                   push   %r15
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:730
    3.70 :	  4960fa:       41 56                   push   %r14
    0.00 :	  4960fc:       41 55                   push   %r13
    0.00 :	  4960fe:       49 89 fd                mov    %rdi,%r13
    0.00 :	  496101:       41 54                   push   %r12
    0.00 :	  496103:       53                      push   %rbx
    0.00 :	  496104:       48 83 ec 48             sub    $0x48,%rsp
         :	        HeapTuple       tuple = &(scan->rs_ctup);
         :	        bool            backward = ScanDirectionIsBackward(dir);
    0.00 :	  496108:       83 fe ff                cmp    $0xffffffff,%esi
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  49610b:       89 55 ac                mov    %edx,-0x54(%rbp)
         :	        HeapTuple       tuple = &(scan->rs_ctup);
         :	        bool            backward = ScanDirectionIsBackward(dir);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:732
    3.70 :	  49610e:       0f 94 45 bf             sete   -0x41(%rbp)
         :	        ItemId          lpp;
         :
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  496112:       83 ee 01                sub    $0x1,%esi
         :	static void
         :	heapgettup_pagemode(HeapScanDesc scan,
         :	                                        ScanDirection dir,
         :	                                        int nkeys,
         :	                                        ScanKey key)
         :	{
    0.00 :	  496115:       48 89 4d a0             mov    %rcx,-0x60(%rbp)
         :	        HeapTuple       tuple = &(scan->rs_ctup);
    0.00 :	  496119:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	        ItemId          lpp;
         :
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  49611d:       0f 84 fd 02 00 00       je     496420 <heapgettup_pagemode+0x330>
         :	                lines = scan->rs_ntuples;
         :	                /* page and lineindex now reference the next visible tid */
         :
         :	                linesleft = lines - lineindex;
         :	        }
         :	        else if (backward)
    0.00 :	  496123:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  496127:       0f 84 67 02 00 00       je     496394 <heapgettup_pagemode+0x2a4>
         :	        {
         :	                if (!scan->rs_inited)
    0.00 :	  49612d:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
    0.00 :	  496131:       0f 84 2a 03 00 00       je     496461 <heapgettup_pagemode+0x371>
         :	                        heapgetpage(scan, page);
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
    0.00 :	  496137:       44 8b 7f 60             mov    0x60(%rdi),%r15d
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  49613b:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  49613f:       85 c0                   test   %eax,%eax
    0.00 :	  496141:       0f 88 24 05 00 00       js     49666b <heapgettup_pagemode+0x57b>
    0.00 :	  496147:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49614a:       4c 63 f0                movslq %eax,%r14
    0.00 :	  49614d:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  496151:       4c 03 35 a0 99 72 00    add    0x7299a0(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :
         :	                if (!scan->rs_inited)
    0.00 :	  496158:       41 80 7d 41 00          cmpb   $0x0,0x41(%r13)
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lines = scan->rs_ntuples;
    0.00 :	  49615d:       41 8b 45 78             mov    0x78(%r13),%eax
         :
         :	                if (!scan->rs_inited)
    0.00 :	  496161:       0f 85 c6 04 00 00       jne    49662d <heapgettup_pagemode+0x53d>
         :	                {
         :	                        lineindex = lines - 1;
    0.00 :	  496167:       83 e8 01                sub    $0x1,%eax
    0.00 :	  49616a:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	                        scan->rs_inited = true;
    0.00 :	  49616d:       41 c6 45 41 01          movb   $0x1,0x41(%r13)
         :	                {
         :	                        lineindex = scan->rs_cindex - 1;
         :	                }
         :	                /* page and lineindex now reference the previous visible tid */
         :
         :	                linesleft = lineindex + 1;
    0.00 :	  496172:       8b 55 c0                mov    -0x40(%rbp),%edx
    0.00 :	  496175:       83 c2 01                add    $0x1,%edx
    0.00 :	  496178:       89 55 c4                mov    %edx,-0x3c(%rbp)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  49617b:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  49617e:       83 ea 01                sub    $0x1,%edx
    0.00 :	  496181:       89 55 9c                mov    %edx,-0x64(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:881
    3.70 :	  496184:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  496188:       44 8b 45 c4             mov    -0x3c(%rbp),%r8d
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:864
   18.52 :	  49618c:       45 85 c0                test   %r8d,%r8d
    0.00 :	  49618f:       0f 8e 6b 01 00 00       jle    496300 <heapgettup_pagemode+0x210>
         :	                {
         :	                        lineoff = scan->rs_vistuples[lineindex];
    0.00 :	  496195:       48 63 45 c0             movslq -0x40(%rbp),%rax
    0.00 :	  496199:       41 0f b7 4c 45 7c       movzwl 0x7c(%r13,%rax,2),%ecx
         :	                        lpp = PageGetItemId(dp, lineoff);
    0.00 :	  49619f:       0f b7 d1                movzwl %cx,%edx
         :	                        Assert(ItemIdIsNormal(lpp));
         :
         :	                        tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 :	  4961a2:       48 83 c2 03             add    $0x3,%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    7.41 :	  4961a6:       41 0f b7 44 96 08       movzwl 0x8(%r14,%rdx,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:870
    3.70 :	  4961ac:       25 ff 7f 00 00          and    $0x7fff,%eax
    3.70 :	  4961b1:       49 8d 04 06             lea    (%r14,%rax,1),%rax
    3.70 :	  4961b5:       49 89 45 58             mov    %rax,0x58(%r13)
         :	                        tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4961b9:       41 0f b7 44 96 0a       movzwl 0xa(%r14,%rdx,4),%eax
         :	                        ItemPointerSet(&(tuple->t_self), page, lineoff);
    0.00 :	  4961bf:       66 45 89 7d 4e          mov    %r15w,0x4e(%r13)
    0.00 :	  4961c4:       66 41 89 4d 50          mov    %cx,0x50(%r13)
         :	                        lineoff = scan->rs_vistuples[lineindex];
         :	                        lpp = PageGetItemId(dp, lineoff);
         :	                        Assert(ItemIdIsNormal(lpp));
         :
         :	                        tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4961c9:       66 d1 e8                shr    %ax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:871
    3.70 :	  4961cc:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4961cf:       41 89 45 48             mov    %eax,0x48(%r13)
         :	                        ItemPointerSet(&(tuple->t_self), page, lineoff);
    0.00 :	  4961d3:       44 89 f8                mov    %r15d,%eax
    0.00 :	  4961d6:       c1 e8 10                shr    $0x10,%eax
    0.00 :	  4961d9:       66 41 89 45 4c          mov    %ax,0x4c(%r13)
         :
         :	                        /*
         :	                         * if current tuple qualifies, return it.
         :	                         */
         :	                        if (key != NULL)
    0.00 :	  4961de:       48 83 7d a0 00          cmpq   $0x0,-0x60(%rbp)
    0.00 :	  4961e3:       0f 84 87 03 00 00       je     496570 <heapgettup_pagemode+0x480>
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4961e9:       44 8b 4d ac             mov    -0x54(%rbp),%r9d
    0.00 :	  4961ed:       45 85 c9                test   %r9d,%r9d
    0.00 :	  4961f0:       0f 84 7a 03 00 00       je     496570 <heapgettup_pagemode+0x480>
    0.00 :	  4961f6:       48 8b 5d a0             mov    -0x60(%rbp),%rbx
    0.00 :	  4961fa:       44 8b 65 9c             mov    -0x64(%rbp),%r12d
    0.00 :	  4961fe:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  496201:       0f 84 a3 00 00 00       je     4962aa <heapgettup_pagemode+0x1ba>
    0.00 :	  496207:       e9 c7 00 00 00          jmpq   4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  49620c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  496210:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
    0.00 :	  496214:       f6 47 14 01             testb  $0x1,0x14(%rdi)
    0.00 :	  496218:       0f 85 9a 02 00 00       jne    4964b8 <heapgettup_pagemode+0x3c8>
    0.00 :	  49621e:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  496222:       48 0f bf d1             movswq %cx,%rdx
    0.00 :	  496226:       4c 8b 40 38             mov    0x38(%rax),%r8
    0.00 :	  49622a:       49 8b 40 08             mov    0x8(%r8),%rax
    0.00 :	  49622e:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    0.00 :	  496233:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  496236:       85 c0                   test   %eax,%eax
    0.00 :	  496238:       0f 88 02 03 00 00       js     496540 <heapgettup_pagemode+0x450>
    0.00 :	  49623e:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  496242:       0f 84 d8 02 00 00       je     496520 <heapgettup_pagemode+0x430>
    0.00 :	  496248:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  49624c:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  496250:       0f 84 02 03 00 00       je     496558 <heapgettup_pagemode+0x468>
    0.00 :	  496256:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  49625a:       0f 84 88 03 00 00       je     4965e8 <heapgettup_pagemode+0x4f8>
    0.00 :	  496260:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  496264:       0f 84 96 03 00 00       je     496600 <heapgettup_pagemode+0x510>
    0.00 :	  49626a:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  49626e:       48 98                   cltq   
    0.00 :	  496270:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  496274:       0f b6 14 10             movzbl (%rax,%rdx,1),%edx
    0.00 :	  496278:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49627f:       00 
    0.00 :	  496280:       48 8b 4b 40             mov    0x40(%rbx),%rcx
    0.00 :	  496284:       8b 73 0c                mov    0xc(%rbx),%esi
    0.00 :	  496287:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  49628b:       e8 a0 7d 2e 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  496290:       84 c0                   test   %al,%al
    0.00 :	  496292:       74 3f                   je     4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  496294:       45 85 e4                test   %r12d,%r12d
    0.00 :	  496297:       0f 84 d3 02 00 00       je     496570 <heapgettup_pagemode+0x480>
    0.00 :	  49629d:       48 83 c3 48             add    $0x48,%rbx
    0.00 :	  4962a1:       f6 03 01                testb  $0x1,(%rbx)
    0.00 :	  4962a4:       75 2d                   jne    4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  4962a6:       41 83 ec 01             sub    $0x1,%r12d
    0.00 :	  4962aa:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
    0.00 :	  4962ae:       66 85 c9                test   %cx,%cx
    0.00 :	  4962b1:       0f 8e 49 02 00 00       jle    496500 <heapgettup_pagemode+0x410>
    0.00 :	  4962b7:       49 8b 7d 58             mov    0x58(%r13),%rdi
    0.00 :	  4962bb:       0f bf f1                movswl %cx,%esi
    0.00 :	  4962be:       0f b7 47 12             movzwl 0x12(%rdi),%eax
    0.00 :	  4962c2:       25 ff 07 00 00          and    $0x7ff,%eax
    0.00 :	  4962c7:       39 c6                   cmp    %eax,%esi
    0.00 :	  4962c9:       0f 8e 41 ff ff ff       jle    496210 <heapgettup_pagemode+0x120>
    0.00 :	  4962cf:       c6 45 d7 01             movb   $0x1,-0x29(%rbp)
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962d3:       8b 55 c0                mov    -0x40(%rbp),%edx
    0.00 :	  4962d6:       8b 45 c0                mov    -0x40(%rbp),%eax
         :	                        }
         :
         :	                        /*
         :	                         * otherwise move to the next item on the page
         :	                         */
         :	                        --linesleft;
    0.00 :	  4962d9:       83 6d c4 01             subl   $0x1,-0x3c(%rbp)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962dd:       44 8b 45 c4             mov    -0x3c(%rbp),%r8d
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962e1:       83 c2 01                add    $0x1,%edx
    0.00 :	  4962e4:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4962e7:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  4962eb:       0f 45 d0                cmovne %eax,%edx
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962ee:       45 85 c0                test   %r8d,%r8d
         :	                         */
         :	                        --linesleft;
         :	                        if (backward)
         :	                                --lineindex;
         :	                        else
         :	                                ++lineindex;
    0.00 :	  4962f1:       89 55 c0                mov    %edx,-0x40(%rbp)
         :	         * advance the scan until we find a qualifying tuple or run out of stuff
         :	         * to scan
         :	         */
         :	        for (;;)
         :	        {
         :	                while (linesleft > 0)
    0.00 :	  4962f4:       0f 8f 9b fe ff ff       jg     496195 <heapgettup_pagemode+0xa5>
    0.00 :	  4962fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /*
         :	                 * if we get here, it means we've exhausted the items on this page and
         :	                 * it's time to move to the next.
         :	                 */
         :	                if (backward)
    0.00 :	  496300:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
    0.00 :	  496304:       0f 84 86 02 00 00       je     496590 <heapgettup_pagemode+0x4a0>
         :	                {
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  49630a:       45 39 7d 2c             cmp    %r15d,0x2c(%r13)
    0.00 :	  49630e:       74 1c                   je     49632c <heapgettup_pagemode+0x23c>
    0.00 :	  496310:       41 8b 45 34             mov    0x34(%r13),%eax
    0.00 :	  496314:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  496317:       0f 84 15 02 00 00       je     496532 <heapgettup_pagemode+0x442>
    0.00 :	  49631d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496320:       85 c0                   test   %eax,%eax
    0.00 :	  496322:       41 89 45 34             mov    %eax,0x34(%r13)
    0.00 :	  496326:       0f 85 06 02 00 00       jne    496532 <heapgettup_pagemode+0x442>
    0.00 :	  49632c:       bb 01 00 00 00          mov    $0x1,%ebx
         :	                                (scan->rs_numblocks != InvalidBlockNumber ? --scan->rs_numblocks <= 0 : false);
         :	                        if (page == 0)
    0.00 :	  496331:       45 85 ff                test   %r15d,%r15d
    0.00 :	  496334:       75 04                   jne    49633a <heapgettup_pagemode+0x24a>
         :	                                page = scan->rs_nblocks;
    0.00 :	  496336:       45 8b 7d 28             mov    0x28(%r13),%r15d
         :	                        page--;
    0.00 :	  49633a:       41 83 ef 01             sub    $0x1,%r15d
         :	                }
         :
         :	                /*
         :	                 * return NULL if we've exhausted all the pages
         :	                 */
         :	                if (finished)
    0.00 :	  49633e:       84 db                   test   %bl,%bl
    0.00 :	  496340:       0f 85 f6 02 00 00       jne    49663c <heapgettup_pagemode+0x54c>
         :	                        tuple->t_data = NULL;
         :	                        scan->rs_inited = false;
         :	                        return;
         :	                }
         :
         :	                heapgetpage(scan, page);
    0.00 :	  496346:       44 89 fe                mov    %r15d,%esi
    0.00 :	  496349:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  49634c:       e8 0f fb ff ff          callq  495e60 <heapgetpage>
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496351:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  496355:       85 c0                   test   %eax,%eax
    0.00 :	  496357:       0f 88 bb 02 00 00       js     496618 <heapgettup_pagemode+0x528>
    0.00 :	  49635d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496360:       4c 63 f0                movslq %eax,%r14
    0.00 :	  496363:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  496367:       4c 03 35 8a 97 72 00    add    0x72978a(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :	                linesleft = lines;
         :	                if (backward)
    0.00 :	  49636e:       80 7d bf 00             cmpb   $0x0,-0x41(%rbp)
         :	                }
         :
         :	                heapgetpage(scan, page);
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
         :	                lines = scan->rs_ntuples;
    0.00 :	  496372:       41 8b 45 78             mov    0x78(%r13),%eax
         :	                linesleft = lines;
         :	                if (backward)
    0.00 :	  496376:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
    0.00 :	  49637d:       89 45 c4                mov    %eax,-0x3c(%rbp)
    0.00 :	  496380:       0f 84 02 fe ff ff       je     496188 <heapgettup_pagemode+0x98>
         :	                        lineindex = lines - 1;
    0.00 :	  496386:       8d 50 ff                lea    -0x1(%rax),%edx
    0.00 :	  496389:       89 45 c4                mov    %eax,-0x3c(%rbp)
    0.00 :	  49638c:       89 55 c0                mov    %edx,-0x40(%rbp)
    0.00 :	  49638f:       e9 f4 fd ff ff          jmpq   496188 <heapgettup_pagemode+0x98>
         :	        else
         :	        {
         :	                /*
         :	                 * ``no movement'' scan direction: refetch prior tuple
         :	                 */
         :	                if (!scan->rs_inited)
    0.00 :	  496394:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
    0.00 :	  496398:       74 6e                   je     496408 <heapgettup_pagemode+0x318>
         :	                        Assert(!BufferIsValid(scan->rs_cbuf));
         :	                        tuple->t_data = NULL;
         :	                        return;
         :	                }
         :
         :	                page = ItemPointerGetBlockNumber(&(tuple->t_self));
    0.00 :	  49639a:       0f b7 77 4c             movzwl 0x4c(%rdi),%esi
    0.00 :	  49639e:       0f b7 47 4e             movzwl 0x4e(%rdi),%eax
    0.00 :	  4963a2:       c1 e6 10                shl    $0x10,%esi
    0.00 :	  4963a5:       09 c6                   or     %eax,%esi
         :	                if (page != scan->rs_cblock)
    0.00 :	  4963a7:       39 77 60                cmp    %esi,0x60(%rdi)
    0.00 :	  4963aa:       74 05                   je     4963b1 <heapgettup_pagemode+0x2c1>
         :	                        heapgetpage(scan, page);
    0.00 :	  4963ac:       e8 af fa ff ff          callq  495e60 <heapgetpage>
         :
         :	                /* Since the tuple was previously fetched, needn't lock page here */
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  4963b1:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  4963b5:       85 c0                   test   %eax,%eax
    0.00 :	  4963b7:       0f 88 d8 02 00 00       js     496695 <heapgettup_pagemode+0x5a5>
    0.00 :	  4963bd:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4963c0:       48 63 c8                movslq %eax,%rcx
    0.00 :	  4963c3:       48 c1 e1 0d             shl    $0xd,%rcx
    0.00 :	  4963c7:       48 03 0d 2a 97 72 00    add    0x72972a(%rip),%rcx        # bbfaf8 <BufferBlocks>
         :	                lineoff = ItemPointerGetOffsetNumber(&(tuple->t_self));
         :	                lpp = PageGetItemId(dp, lineoff);
    0.00 :	  4963ce:       41 0f b7 45 50          movzwl 0x50(%r13),%eax
         :	                Assert(ItemIdIsNormal(lpp));
         :
         :	                tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
    0.00 :	  4963d3:       48 83 c0 03             add    $0x3,%rax
    0.00 :	  4963d7:       0f b7 54 81 08          movzwl 0x8(%rcx,%rax,4),%edx
    0.00 :	  4963dc:       81 e2 ff 7f 00 00       and    $0x7fff,%edx
    0.00 :	  4963e2:       48 8d 14 11             lea    (%rcx,%rdx,1),%rdx
    0.00 :	  4963e6:       49 89 55 58             mov    %rdx,0x58(%r13)
         :	                tuple->t_len = ItemIdGetLength(lpp);
    0.00 :	  4963ea:       0f b7 44 81 0a          movzwl 0xa(%rcx,%rax,4),%eax
    0.00 :	  4963ef:       66 d1 e8                shr    %ax
    0.00 :	  4963f2:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4963f5:       41 89 45 48             mov    %eax,0x48(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  4963f9:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  4963fd:       5b                      pop    %rbx
    0.00 :	  4963fe:       41 5c                   pop    %r12
    0.00 :	  496400:       41 5d                   pop    %r13
    0.00 :	  496402:       41 5e                   pop    %r14
    0.00 :	  496404:       41 5f                   pop    %r15
    0.00 :	  496406:       c9                      leaveq 
    0.00 :	  496407:       c3                      retq   
         :	                 * ``no movement'' scan direction: refetch prior tuple
         :	                 */
         :	                if (!scan->rs_inited)
         :	                {
         :	                        Assert(!BufferIsValid(scan->rs_cbuf));
         :	                        tuple->t_data = NULL;
    0.00 :	  496408:       49 c7 45 58 00 00 00    movq   $0x0,0x58(%r13)
    0.00 :	  49640f:       00 
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496410:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  496414:       5b                      pop    %rbx
    0.00 :	  496415:       41 5c                   pop    %r12
    0.00 :	  496417:       41 5d                   pop    %r13
    0.00 :	  496419:       41 5e                   pop    %r14
    0.00 :	  49641b:       41 5f                   pop    %r15
    0.00 :	  49641d:       c9                      leaveq 
    0.00 :	  49641e:       c3                      retq   
    0.00 :	  49641f:       90                      nop
         :	        /*
         :	         * calculate next starting lineindex, given scan direction
         :	         */
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                if (!scan->rs_inited)
    0.00 :	  496420:       80 7f 41 00             cmpb   $0x0,0x41(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:747
    3.70 :	  496424:       74 66                   je     49648c <heapgettup_pagemode+0x39c>
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                        lineindex = scan->rs_cindex + 1;
    0.00 :	  496426:       8b 47 70                mov    0x70(%rdi),%eax
         :	                        scan->rs_inited = true;
         :	                }
         :	                else
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
    0.00 :	  496429:       44 8b 7f 60             mov    0x60(%rdi),%r15d
         :	                        lineindex = scan->rs_cindex + 1;
    0.00 :	  49642d:       83 c0 01                add    $0x1,%eax
    0.00 :	  496430:       89 45 c0                mov    %eax,-0x40(%rbp)
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496433:       41 8b 45 64             mov    0x64(%r13),%eax
    0.00 :	  496437:       85 c0                   test   %eax,%eax
    0.00 :	  496439:       0f 88 41 02 00 00       js     496680 <heapgettup_pagemode+0x590>
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:770
    3.70 :	  49643f:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496442:       4c 63 f0                movslq %eax,%r14
    0.00 :	  496445:       49 c1 e6 0d             shl    $0xd,%r14
    3.70 :	  496449:       4c 03 35 a8 96 72 00    add    0x7296a8(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	                lines = scan->rs_ntuples;
         :	                /* page and lineindex now reference the next visible tid */
         :
         :	                linesleft = lines - lineindex;
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:774
    3.70 :	  496450:       41 8b 55 78             mov    0x78(%r13),%edx
    0.00 :	  496454:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  496457:       29 c2                   sub    %eax,%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:774
    7.41 :	  496459:       89 55 c4                mov    %edx,-0x3c(%rbp)
    7.41 :	  49645c:       e9 1a fd ff ff          jmpq   49617b <heapgettup_pagemode+0x8b>
         :	                if (!scan->rs_inited)
         :	                {
         :	                        /*
         :	                         * return null immediately if relation is empty
         :	                         */
         :	                        if (scan->rs_nblocks == 0)
    0.00 :	  496461:       44 8b 57 28             mov    0x28(%rdi),%r10d
    0.00 :	  496465:       45 85 d2                test   %r10d,%r10d
    0.00 :	  496468:       74 9e                   je     496408 <heapgettup_pagemode+0x318>
         :	                         * time, and much more likely that we'll just bollix things for
         :	                         * forward scanners.
         :	                         */
         :	                        scan->rs_syncscan = false;
         :	                        /* start from last page of the scan */
         :	                        if (scan->rs_startblock > 0)
    0.00 :	  49646a:       8b 47 2c                mov    0x2c(%rdi),%eax
         :	                         * Disable reporting to syncscan logic in a backwards scan; it's
         :	                         * not very likely anyone else is doing the same thing at the same
         :	                         * time, and much more likely that we'll just bollix things for
         :	                         * forward scanners.
         :	                         */
         :	                        scan->rs_syncscan = false;
    0.00 :	  49646d:       c6 47 40 00             movb   $0x0,0x40(%rdi)
         :	                        /* start from last page of the scan */
         :	                        if (scan->rs_startblock > 0)
    0.00 :	  496471:       85 c0                   test   %eax,%eax
    0.00 :	  496473:       75 03                   jne    496478 <heapgettup_pagemode+0x388>
         :	                                page = scan->rs_startblock - 1;
         :	                        else
         :	                                page = scan->rs_nblocks - 1;
    0.00 :	  496475:       8b 47 28                mov    0x28(%rdi),%eax
    0.00 :	  496478:       44 8d 78 ff             lea    -0x1(%rax),%r15d
         :	                        heapgetpage(scan, page);
    0.00 :	  49647c:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  49647f:       44 89 fe                mov    %r15d,%esi
    0.00 :	  496482:       e8 d9 f9 ff ff          callq  495e60 <heapgetpage>
    0.00 :	  496487:       e9 af fc ff ff          jmpq   49613b <heapgettup_pagemode+0x4b>
         :	                if (!scan->rs_inited)
         :	                {
         :	                        /*
         :	                         * return null immediately if relation is empty
         :	                         */
         :	                        if (scan->rs_nblocks == 0)
    0.00 :	  49648c:       44 8b 5f 28             mov    0x28(%rdi),%r11d
    0.00 :	  496490:       45 85 db                test   %r11d,%r11d
    0.00 :	  496493:       0f 84 6f ff ff ff       je     496408 <heapgettup_pagemode+0x318>
         :	                        {
         :	                                Assert(!BufferIsValid(scan->rs_cbuf));
         :	                                tuple->t_data = NULL;
         :	                                return;
         :	                        }
         :	                        page = scan->rs_startblock; /* first page */
    0.00 :	  496499:       44 8b 7f 2c             mov    0x2c(%rdi),%r15d
         :	                        heapgetpage(scan, page);
    0.00 :	  49649d:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4964a0:       e8 bb f9 ff ff          callq  495e60 <heapgetpage>
         :	                        lineindex = 0;
         :	                        scan->rs_inited = true;
    0.00 :	  4964a5:       41 c6 45 41 01          movb   $0x1,0x41(%r13)
    0.00 :	  4964aa:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
    0.00 :	  4964b1:       eb 80                   jmp    496433 <heapgettup_pagemode+0x343>
    0.00 :	  4964b3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4964b8:       0f bf 73 04             movswl 0x4(%rbx),%esi
    0.00 :	  4964bc:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  4964bf:       89 c8                   mov    %ecx,%eax
    0.00 :	  4964c1:       83 e1 07                and    $0x7,%ecx
    0.00 :	  4964c4:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4964c7:       48 98                   cltq   
    0.00 :	  4964c9:       0f b6 44 07 17          movzbl 0x17(%rdi,%rax,1),%eax
    0.00 :	  4964ce:       d3 f8                   sar    %cl,%eax
    0.00 :	  4964d0:       a8 01                   test   $0x1,%al
    0.00 :	  4964d2:       0f 84 f7 fd ff ff       je     4962cf <heapgettup_pagemode+0x1df>
    0.00 :	  4964d8:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  4964dc:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  4964e0:       48 8b 50 38             mov    0x38(%rax),%rdx
    0.00 :	  4964e4:       e8 a7 94 fd ff          callq  46f990 <nocachegetattr>
    0.00 :	  4964e9:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4964ec:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  4964f0:       0f 84 8a fd ff ff       je     496280 <heapgettup_pagemode+0x190>
    0.00 :	  4964f6:       e9 d8 fd ff ff          jmpq   4962d3 <heapgettup_pagemode+0x1e3>
    0.00 :	  4964fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  496500:       49 8b 45 00             mov    0x0(%r13),%rax
    0.00 :	  496504:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  496508:       0f bf f1                movswl %cx,%esi
    0.00 :	  49650b:       48 8d 4d d7             lea    -0x29(%rbp),%rcx
    0.00 :	  49650f:       48 8b 50 38             mov    0x38(%rax),%rdx
    0.00 :	  496513:       e8 b8 87 fd ff          callq  46ecd0 <heap_getsysattr>
    0.00 :	  496518:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49651b:       eb cf                   jmp    4964ec <heapgettup_pagemode+0x3fc>
    0.00 :	  49651d:       0f 1f 00                nopl   (%rax)
    0.00 :	  496520:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  496524:       48 98                   cltq   
    0.00 :	  496526:       48 01 d0                add    %rdx,%rax
    0.00 :	  496529:       48 8d 14 07             lea    (%rdi,%rax,1),%rdx
    0.00 :	  49652d:       e9 4e fd ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
         :	                 * if we get here, it means we've exhausted the items on this page and
         :	                 * it's time to move to the next.
         :	                 */
         :	                if (backward)
         :	                {
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  496532:       31 db                   xor    %ebx,%ebx
    0.00 :	  496534:       e9 f8 fd ff ff          jmpq   496331 <heapgettup_pagemode+0x241>
    0.00 :	  496539:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  496540:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  496544:       4c 89 c2                mov    %r8,%rdx
    0.00 :	  496547:       e8 44 94 fd ff          callq  46f990 <nocachegetattr>
    0.00 :	  49654c:       48 89 c2                mov    %rax,%rdx
    0.00 :	  49654f:       eb 9b                   jmp    4964ec <heapgettup_pagemode+0x3fc>
    0.00 :	  496551:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  496558:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  49655c:       48 98                   cltq   
    0.00 :	  49655e:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  496562:       48 8b 14 10             mov    (%rax,%rdx,1),%rdx
    0.00 :	  496566:       e9 15 fd ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  49656b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                                        nkeys, key, valid);
         :	                                if (valid)
         :	                                {
         :	                                        scan->rs_cindex = lineindex;
    0.00 :	  496570:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  496573:       41 89 45 70             mov    %eax,0x70(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496577:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  49657b:       5b                      pop    %rbx
    0.00 :	  49657c:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:965
    3.70 :	  49657e:       41 5d                   pop    %r13
    0.00 :	  496580:       41 5e                   pop    %r14
    3.70 :	  496582:       41 5f                   pop    %r15
    0.00 :	  496584:       c9                      leaveq 
    0.00 :	  496585:       c3                      retq   
    0.00 :	  496586:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  49658d:       00 00 00 
         :	                                page = scan->rs_nblocks;
         :	                        page--;
         :	                }
         :	                else
         :	                {
         :	                        page++;
    0.00 :	  496590:       41 83 c7 01             add    $0x1,%r15d
         :	                        if (page >= scan->rs_nblocks)
    0.00 :	  496594:       45 3b 7d 28             cmp    0x28(%r13),%r15d
    0.00 :	  496598:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  49659d:       44 0f 43 f8             cmovae %eax,%r15d
         :	                                page = 0;
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  4965a1:       45 39 7d 2c             cmp    %r15d,0x2c(%r13)
    0.00 :	  4965a5:       74 14                   je     4965bb <heapgettup_pagemode+0x4cb>
    0.00 :	  4965a7:       41 8b 45 34             mov    0x34(%r13),%eax
    0.00 :	  4965ab:       83 f8 ff                cmp    $0xffffffff,%eax
    0.00 :	  4965ae:       74 2c                   je     4965dc <heapgettup_pagemode+0x4ec>
    0.00 :	  4965b0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4965b3:       85 c0                   test   %eax,%eax
    0.00 :	  4965b5:       41 89 45 34             mov    %eax,0x34(%r13)
    0.00 :	  4965b9:       75 21                   jne    4965dc <heapgettup_pagemode+0x4ec>
    0.00 :	  4965bb:       bb 01 00 00 00          mov    $0x1,%ebx
         :	                         * rel.  That's not strictly necessary, but otherwise when you run
         :	                         * the same query multiple times the starting position would shift
         :	                         * a little bit backwards on every invocation, which is confusing.
         :	                         * We don't guarantee any specific ordering in general, though.
         :	                         */
         :	                        if (scan->rs_syncscan)
    0.00 :	  4965c0:       41 80 7d 40 00          cmpb   $0x0,0x40(%r13)
    0.00 :	  4965c5:       0f 84 73 fd ff ff       je     49633e <heapgettup_pagemode+0x24e>
         :	                                ss_report_location(scan->rs_rd, page);
    0.00 :	  4965cb:       49 8b 7d 00             mov    0x0(%r13),%rdi
    0.00 :	  4965cf:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4965d2:       e8 49 a8 00 00          callq  4a0e20 <ss_report_location>
    0.00 :	  4965d7:       e9 62 fd ff ff          jmpq   49633e <heapgettup_pagemode+0x24e>
         :	                else
         :	                {
         :	                        page++;
         :	                        if (page >= scan->rs_nblocks)
         :	                                page = 0;
         :	                        finished = (page == scan->rs_startblock) ||
    0.00 :	  4965dc:       31 db                   xor    %ebx,%ebx
    0.00 :	  4965de:       66 90                   xchg   %ax,%ax
    0.00 :	  4965e0:       eb de                   jmp    4965c0 <heapgettup_pagemode+0x4d0>
    0.00 :	  4965e2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         */
         :	                        if (key != NULL)
         :	                        {
         :	                                bool            valid;
         :
         :	                                HeapKeyTest(tuple, RelationGetDescr(scan->rs_rd),
    0.00 :	  4965e8:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  4965ec:       48 98                   cltq   
    0.00 :	  4965ee:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  4965f2:       8b 14 10                mov    (%rax,%rdx,1),%edx
    0.00 :	  4965f5:       e9 86 fc ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  4965fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  496600:       0f b6 57 16             movzbl 0x16(%rdi),%edx
    0.00 :	  496604:       48 98                   cltq   
    0.00 :	  496606:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  49660a:       0f b7 14 10             movzwl (%rax,%rdx,1),%edx
    0.00 :	  49660e:       e9 6d fc ff ff          jmpq   496280 <heapgettup_pagemode+0x190>
    0.00 :	  496613:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        return;
         :	                }
         :
         :	                heapgetpage(scan, page);
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496618:       f7 d0                   not    %eax
    0.00 :	  49661a:       48 63 d0                movslq %eax,%rdx
    0.00 :	  49661d:       48 8b 05 f4 6a 6e 00    mov    0x6e6af4(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  496624:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  496628:       e9 41 fd ff ff          jmpq   49636e <heapgettup_pagemode+0x27e>
         :	                        lineindex = lines - 1;
         :	                        scan->rs_inited = true;
         :	                }
         :	                else
         :	                {
         :	                        lineindex = scan->rs_cindex - 1;
    0.00 :	  49662d:       41 8b 45 70             mov    0x70(%r13),%eax
    0.00 :	  496631:       83 e8 01                sub    $0x1,%eax
    0.00 :	  496634:       89 45 c0                mov    %eax,-0x40(%rbp)
    0.00 :	  496637:       e9 36 fb ff ff          jmpq   496172 <heapgettup_pagemode+0x82>
         :	                /*
         :	                 * return NULL if we've exhausted all the pages
         :	                 */
         :	                if (finished)
         :	                {
         :	                        if (BufferIsValid(scan->rs_cbuf))
    0.00 :	  49663c:       41 8b 7d 64             mov    0x64(%r13),%edi
    0.00 :	  496640:       85 ff                   test   %edi,%edi
    0.00 :	  496642:       74 05                   je     496649 <heapgettup_pagemode+0x559>
         :	                                ReleaseBuffer(scan->rs_cbuf);
    0.00 :	  496644:       e8 17 e8 1d 00          callq  674e60 <ReleaseBuffer>
         :	                        scan->rs_cbuf = InvalidBuffer;
    0.00 :	  496649:       41 c7 45 64 00 00 00    movl   $0x0,0x64(%r13)
    0.00 :	  496650:       00 
         :	                        scan->rs_cblock = InvalidBlockNumber;
    0.00 :	  496651:       41 c7 45 60 ff ff ff    movl   $0xffffffff,0x60(%r13)
    0.00 :	  496658:       ff 
         :	                        tuple->t_data = NULL;
    0.00 :	  496659:       49 c7 45 58 00 00 00    movq   $0x0,0x58(%r13)
    0.00 :	  496660:       00 
         :	                        scan->rs_inited = false;
    0.00 :	  496661:       41 c6 45 41 00          movb   $0x0,0x41(%r13)
         :	                if (backward)
         :	                        lineindex = lines - 1;
         :	                else
         :	                        lineindex = 0;
         :	        }
         :	}
    0.00 :	  496666:       e9 a5 fd ff ff          jmpq   496410 <heapgettup_pagemode+0x320>
         :	                {
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  49666b:       f7 d0                   not    %eax
    0.00 :	  49666d:       48 63 d0                movslq %eax,%rdx
    0.00 :	  496670:       48 8b 05 a1 6a 6e 00    mov    0x6e6aa1(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  496677:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  49667b:       e9 d8 fa ff ff          jmpq   496158 <heapgettup_pagemode+0x68>
         :	                        /* continue from previously returned page/tuple */
         :	                        page = scan->rs_cblock;         /* current page */
         :	                        lineindex = scan->rs_cindex + 1;
         :	                }
         :
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496680:       f7 d0                   not    %eax
    0.00 :	  496682:       48 63 d0                movslq %eax,%rdx
    0.00 :	  496685:       48 8b 05 8c 6a 6e 00    mov    0x6e6a8c(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49668c:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  496690:       e9 bb fd ff ff          jmpq   496450 <heapgettup_pagemode+0x360>
         :	                page = ItemPointerGetBlockNumber(&(tuple->t_self));
         :	                if (page != scan->rs_cblock)
         :	                        heapgetpage(scan, page);
         :
         :	                /* Since the tuple was previously fetched, needn't lock page here */
         :	                dp = (Page) BufferGetPage(scan->rs_cbuf);
    0.00 :	  496695:       f7 d0                   not    %eax
    0.00 :	  496697:       48 63 d0                movslq %eax,%rdx
    0.00 :	  49669a:       48 8b 05 77 6a 6e 00    mov    0x6e6a77(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4966a1:       48 8b 0c d0             mov    (%rax,%rdx,8),%rcx
    0.00 :	  4966a5:       e9 24 fd ff ff          jmpq   4963ce <heapgettup_pagemode+0x2de>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   30.43 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:109
   30.43 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:109
    8.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:75
    8.70 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:85
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:75
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:85
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:152
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:95
    4.35 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:95
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000049f650 <heap_page_prune_opt>:
         :	 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD
         :	 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
         :	 */
         :	void
         :	heap_page_prune_opt(Relation relation, Buffer buffer)
         :	{
    0.00 :	  49f650:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:75
    8.70 :	  49f651:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  49f654:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:75
    4.35 :	  49f658:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  49f65c:       41 89 f4                mov    %esi,%r12d
    0.00 :	  49f65f:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  49f663:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  49f667:       49 89 fe                mov    %rdi,%r14
    0.00 :	  49f66a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  49f66e:       48 83 ec 40             sub    $0x40,%rsp
         :	        Page            page = BufferGetPage(buffer);
    0.00 :	  49f672:       85 f6                   test   %esi,%esi
    0.00 :	  49f674:       0f 88 fe 00 00 00       js     49f778 <heap_page_prune_opt+0x128>
    0.00 :	  49f67a:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  49f67f:       48 63 d8                movslq %eax,%rbx
    0.00 :	  49f682:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  49f686:       48 03 1d 6b 04 72 00    add    0x72046b(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        /*
         :	         * We can't write WAL in recovery mode, so there's no point trying to
         :	         * clean the page. The master will likely issue a cleaning WAL record soon
         :	         * anyway, so this is no particular loss.
         :	         */
         :	        if (RecoveryInProgress())
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:85
    4.35 :	  49f68d:       e8 2e de 02 00          callq  4cd4c0 <RecoveryInProgress>
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:85
    8.70 :	  49f692:       84 c0                   test   %al,%al
    0.00 :	  49f694:       74 1a                   je     49f6b0 <heap_page_prune_opt+0x60>
         :	                }
         :
         :	                /* And release buffer lock */
         :	                LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
         :	        }
         :	}
    0.00 :	  49f696:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  49f69a:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  49f69e:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  49f6a2:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  49f6a6:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  49f6aa:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:152
    4.35 :	  49f6ab:       c3                      retq   
    0.00 :	  49f6ac:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f6b0:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49f6b3:       e8 28 37 04 00          callq  4e2de0 <IsCatalogRelation>
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:95
    4.35 :	  49f6b8:       84 c0                   test   %al,%al
    0.00 :	  49f6ba:       0f 84 d0 00 00 00       je     49f790 <heap_page_prune_opt+0x140>
         :	                RelationIsAccessibleInLogicalDecoding(relation))
         :	                OldestXmin = RecentGlobalXmin;
    0.00 :	  49f6c0:       44 8b 3d 39 b2 71 00    mov    0x71b239(%rip),%r15d        # bba900 <RecentGlobalXmin>
         :	         * Let's see if we really need pruning.
         :	         *
         :	         * Forget it if page is not hinted to contain something prunable that's
         :	         * older than OldestXmin.
         :	         */
         :	        if (!PageIsPrunable(page, OldestXmin))
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:109
   30.43 :	  49f6c7:       8b 7b 14                mov    0x14(%rbx),%edi
   30.43 :	  49f6ca:       85 ff                   test   %edi,%edi
    0.00 :	  49f6cc:       74 c8                   je     49f696 <heap_page_prune_opt+0x46>
    0.00 :	  49f6ce:       44 89 fe                mov    %r15d,%esi
    0.00 :	  49f6d1:       e8 0a 09 02 00          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  49f6d6:       84 c0                   test   %al,%al
    0.00 :	  49f6d8:       74 bc                   je     49f696 <heap_page_prune_opt+0x46>
         :	         * unlikely to be *seriously* wrong, though, since reading either pd_lower
         :	         * or pd_upper is probably atomic.  Avoiding taking a lock seems more
         :	         * important than sometimes getting a wrong answer in what is after all
         :	         * just a heuristic estimate.
         :	         */
         :	        minfree = RelationGetTargetPageFreeSpace(relation,
    0.00 :	  49f6da:       49 8b 96 98 00 00 00    mov    0x98(%r14),%rdx
    0.00 :	  49f6e1:       41 bd 33 03 00 00       mov    $0x333,%r13d
    0.00 :	  49f6e7:       48 85 d2                test   %rdx,%rdx
    0.00 :	  49f6ea:       74 2f                   je     49f71b <heap_page_prune_opt+0xcb>
    0.00 :	  49f6ec:       b9 64 00 00 00          mov    $0x64,%ecx
    0.00 :	  49f6f1:       2b 4a 04                sub    0x4(%rdx),%ecx
    0.00 :	  49f6f4:       ba 1f 85 eb 51          mov    $0x51eb851f,%edx
    0.00 :	  49f6f9:       c1 e1 0d                shl    $0xd,%ecx
    0.00 :	  49f6fc:       89 c8                   mov    %ecx,%eax
    0.00 :	  49f6fe:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  49f701:       f7 ea                   imul   %edx
    0.00 :	  49f703:       b8 33 03 00 00          mov    $0x333,%eax
    0.00 :	  49f708:       c1 fa 05                sar    $0x5,%edx
    0.00 :	  49f70b:       29 ca                   sub    %ecx,%edx
    0.00 :	  49f70d:       4c 63 ea                movslq %edx,%r13
    0.00 :	  49f710:       49 81 fd 33 03 00 00    cmp    $0x333,%r13
    0.00 :	  49f717:       4c 0f 42 e8             cmovb  %rax,%r13
         :	                                                                                         HEAP_DEFAULT_FILLFACTOR);
         :	        minfree = Max(minfree, BLCKSZ / 10);
         :
         :	        if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f71b:       f6 43 0a 02             testb  $0x2,0xa(%rbx)
    0.00 :	  49f71f:       75 11                   jne    49f732 <heap_page_prune_opt+0xe2>
    0.00 :	  49f721:       48 89 df                mov    %rbx,%rdi
    0.00 :	  49f724:       e8 37 56 1f 00          callq  694d60 <PageGetHeapFreeSpace>
    0.00 :	  49f729:       4c 39 e8                cmp    %r13,%rax
    0.00 :	  49f72c:       0f 83 64 ff ff ff       jae    49f696 <heap_page_prune_opt+0x46>
         :	        {
         :	                /* OK, try to get exclusive buffer lock */
         :	                if (!ConditionalLockBufferForCleanup(buffer))
    0.00 :	  49f732:       44 89 e7                mov    %r12d,%edi
    0.00 :	  49f735:       e8 26 78 1d 00          callq  676f60 <ConditionalLockBufferForCleanup>
    0.00 :	  49f73a:       84 c0                   test   %al,%al
    0.00 :	  49f73c:       0f 84 54 ff ff ff       je     49f696 <heap_page_prune_opt+0x46>
         :	                 * Now that we have buffer lock, get accurate information about the
         :	                 * page's free space, and recheck the heuristic about whether to
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f742:       f6 43 0a 02             testb  $0x2,0xa(%rbx)
    0.00 :	  49f746:       74 68                   je     49f7b0 <heap_page_prune_opt+0x160>
         :	                {
         :	                        TransactionId ignore = InvalidTransactionId;            /* return value not
         :	                                                                                                                                 * needed */
         :
         :	                        /* OK to prune */
         :	                        (void) heap_page_prune(relation, buffer, OldestXmin, true, &ignore);
    0.00 :	  49f748:       4c 8d 45 d4             lea    -0x2c(%rbp),%r8
    0.00 :	  49f74c:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  49f751:       44 89 fa                mov    %r15d,%edx
    0.00 :	  49f754:       44 89 e6                mov    %r12d,%esi
    0.00 :	  49f757:       4c 89 f7                mov    %r14,%rdi
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
         :	                {
         :	                        TransactionId ignore = InvalidTransactionId;            /* return value not
    0.00 :	  49f75a:       c7 45 d4 00 00 00 00    movl   $0x0,-0x2c(%rbp)
         :	                                                                                                                                 * needed */
         :
         :	                        /* OK to prune */
         :	                        (void) heap_page_prune(relation, buffer, OldestXmin, true, &ignore);
    0.00 :	  49f761:       e8 5a f4 ff ff          callq  49ebc0 <heap_page_prune>
         :	                }
         :
         :	                /* And release buffer lock */
         :	                LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  49f766:       31 f6                   xor    %esi,%esi
    0.00 :	  49f768:       44 89 e7                mov    %r12d,%edi
    0.00 :	  49f76b:       e8 a0 4f 1d 00          callq  674710 <LockBuffer>
    0.00 :	  49f770:       e9 21 ff ff ff          jmpq   49f696 <heap_page_prune_opt+0x46>
    0.00 :	  49f775:       0f 1f 00                nopl   (%rax)
         :	 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
         :	 */
         :	void
         :	heap_page_prune_opt(Relation relation, Buffer buffer)
         :	{
         :	        Page            page = BufferGetPage(buffer);
    0.00 :	  49f778:       89 f0                   mov    %esi,%eax
    0.00 :	  49f77a:       48 8b 15 97 d9 6d 00    mov    0x6dd997(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  49f781:       f7 d0                   not    %eax
    0.00 :	  49f783:       48 98                   cltq   
    0.00 :	  49f785:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  49f789:       e9 ff fe ff ff          jmpq   49f68d <heap_page_prune_opt+0x3d>
    0.00 :	  49f78e:       66 90                   xchg   %ax,%ax
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f790:       83 3d c5 99 6d 00 02    cmpl   $0x2,0x6d99c5(%rip)        # b7915c <wal_level>
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/pruneheap.c:95
    4.35 :	  49f797:       7e 0a                   jle    49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f799:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  49f79d:       80 78 6e 70             cmpb   $0x70,0x6e(%rax)
    0.00 :	  49f7a1:       74 25                   je     49f7c8 <heap_page_prune_opt+0x178>
         :	                RelationIsAccessibleInLogicalDecoding(relation))
         :	                OldestXmin = RecentGlobalXmin;
         :	        else
         :	                OldestXmin = RecentGlobalDataXmin;
    0.00 :	  49f7a3:       44 8b 3d 5a b1 71 00    mov    0x71b15a(%rip),%r15d        # bba904 <RecentGlobalDataXmin>
    0.00 :	  49f7aa:       e9 18 ff ff ff          jmpq   49f6c7 <heap_page_prune_opt+0x77>
    0.00 :	  49f7af:       90                      nop
         :	                 * Now that we have buffer lock, get accurate information about the
         :	                 * page's free space, and recheck the heuristic about whether to
         :	                 * prune. (We needn't recheck PageIsPrunable, since no one else could
         :	                 * have pruned while we hold pin.)
         :	                 */
         :	                if (PageIsFull(page) || PageGetHeapFreeSpace(page) < minfree)
    0.00 :	  49f7b0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  49f7b3:       e8 a8 55 1f 00          callq  694d60 <PageGetHeapFreeSpace>
    0.00 :	  49f7b8:       4c 39 e8                cmp    %r13,%rax
    0.00 :	  49f7bb:       73 a9                   jae    49f766 <heap_page_prune_opt+0x116>
    0.00 :	  49f7bd:       0f 1f 00                nopl   (%rax)
    0.00 :	  49f7c0:       eb 86                   jmp    49f748 <heap_page_prune_opt+0xf8>
    0.00 :	  49f7c2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * catalog relation or a user defined, additional, catalog relation, we
         :	         * need to use the horizon that includes slots, otherwise the data-only
         :	         * horizon can be used. Note that the toast relation of user defined
         :	         * relations are *not* considered catalog relations.
         :	         */
         :	        if (IsCatalogRelation(relation) ||
    0.00 :	  49f7c8:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  49f7cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  49f7d0:       e8 0b 36 04 00          callq  4e2de0 <IsCatalogRelation>
    0.00 :	  49f7d5:       84 c0                   test   %al,%al
    0.00 :	  49f7d7:       0f 85 e3 fe ff ff       jne    49f6c0 <heap_page_prune_opt+0x70>
    0.00 :	  49f7dd:       49 8b 86 98 00 00 00    mov    0x98(%r14),%rax
    0.00 :	  49f7e4:       48 85 c0                test   %rax,%rax
    0.00 :	  49f7e7:       74 ba                   je     49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f7e9:       80 78 48 00             cmpb   $0x0,0x48(%rax)
    0.00 :	  49f7ed:       74 b4                   je     49f7a3 <heap_page_prune_opt+0x153>
    0.00 :	  49f7ef:       90                      nop
    0.00 :	  49f7f0:       e9 cb fe ff ff          jmpq   49f6c0 <heap_page_prune_opt+0x70>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:223
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:230
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:175
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:121
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:121
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:122
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:43
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:223
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:230
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:43
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b3750 <ExecScan>:
         :	 */
         :	TupleTableSlot *
         :	ExecScan(ScanState *node,
         :	                 ExecScanAccessMtd accessMtd,   /* function returning a tuple */
         :	                 ExecScanRecheckMtd recheckMtd)
         :	{
    0.00 :	  5b3750:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
    9.09 :	  5b3751:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b3754:       41 57                   push   %r15
    9.09 :	  5b3756:       41 56                   push   %r14
    0.00 :	  5b3758:       41 55                   push   %r13
    0.00 :	  5b375a:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:111
    4.55 :	  5b375c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5b375f:       53                      push   %rbx
    0.00 :	  5b3760:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	  5b3764:       48 89 75 b8             mov    %rsi,-0x48(%rbp)
    0.00 :	  5b3768:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        TupleTableSlot *resultSlot;
         :
         :	        /*
         :	         * Fetch data from node
         :	         */
         :	        qual = node->ps.qual;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:121
    4.55 :	  5b376c:       48 8b 47 28             mov    0x28(%rdi),%rax
         :
         :	        /*
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
    0.00 :	  5b3770:       48 85 c0                test   %rax,%rax
         :	        TupleTableSlot *resultSlot;
         :
         :	        /*
         :	         * Fetch data from node
         :	         */
         :	        qual = node->ps.qual;
    4.55 :	  5b3773:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        projInfo = node->ps.ps_ProjInfo;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:122
    4.55 :	  5b3777:       4c 8b 77 68             mov    0x68(%rdi),%r14
         :	        econtext = node->ps.ps_ExprContext;
    0.00 :	  5b377b:       4c 8b 6f 60             mov    0x60(%rdi),%r13
         :
         :	        /*
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
    0.00 :	  5b377f:       41 0f 94 c7             sete   %r15b
    0.00 :	  5b3783:       75 09                   jne    5b378e <ExecScan+0x3e>
    0.00 :	  5b3785:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b3788:       0f 84 d6 01 00 00       je     5b3964 <ExecScan+0x214>
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous scan
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
    0.00 :	  5b378e:       41 80 7c 24 70 00       cmpb   $0x0,0x70(%r12)
    0.00 :	  5b3794:       0f 85 a6 01 00 00       jne    5b3940 <ExecScan+0x1f0>
    0.00 :	  5b379a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a scan tuple.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5b37a0:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b37a4:       e8 07 52 1e 00          callq  7989b0 <MemoryContextReset>
         :	         */
         :	        for (;;)
         :	        {
         :	                TupleTableSlot *slot;
         :
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  5b37a9:       0f b6 05 e0 68 60 00    movzbl 0x6068e0(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  5b37b0:       84 c0                   test   %al,%al
    0.00 :	  5b37b2:       0f 85 50 01 00 00       jne    5b3908 <ExecScan+0x1b8>
         :	static inline TupleTableSlot *
         :	ExecScanFetch(ScanState *node,
         :	                          ExecScanAccessMtd accessMtd,
         :	                          ExecScanRecheckMtd recheckMtd)
         :	{
         :	        EState     *estate = node->ps.state;
    0.00 :	  5b37b8:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :
         :	        if (estate->es_epqTuple != NULL)
    0.00 :	  5b37bd:       48 83 ba d0 00 00 00    cmpq   $0x0,0xd0(%rdx)
    0.00 :	  5b37c4:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:43
    4.55 :	  5b37c5:       0f 84 0d 01 00 00       je     5b38d8 <ExecScan+0x188>
         :	                 * conditions.
         :	                 */
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
    0.00 :	  5b37cb:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  5b37d0:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5b37d3:       8d 48 ff                lea    -0x1(%rax),%ecx
    0.00 :	  5b37d6:       48 8b 82 d8 00 00 00    mov    0xd8(%rdx),%rax
    0.00 :	  5b37dd:       80 3c 08 00             cmpb   $0x0,(%rax,%rcx,1)
    0.00 :	  5b37e1:       0f 84 f1 00 00 00       je     5b38d8 <ExecScan+0x188>
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b37e7:       48 89 c8                mov    %rcx,%rax
    0.00 :	  5b37ea:       48 03 82 e0 00 00 00    add    0xe0(%rdx),%rax
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
    0.00 :	  5b37f1:       49 8b 9c 24 88 00 00    mov    0x88(%r12),%rbx
    0.00 :	  5b37f8:       00 
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b37f9:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  5b37fc:       0f 85 16 01 00 00       jne    5b3918 <ExecScan+0x1c8>
         :	                                return ExecClearTuple(slot);
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
    0.00 :	  5b3802:       c6 00 01                movb   $0x1,(%rax)
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
    0.00 :	  5b3805:       48 8b 82 d0 00 00 00    mov    0xd0(%rdx),%rax
    0.00 :	  5b380c:       48 8b 3c c8             mov    (%rax,%rcx,8),%rdi
    0.00 :	  5b3810:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b3813:       0f 84 ff 00 00 00       je     5b3918 <ExecScan+0x1c8>
         :	                                return ExecClearTuple(slot);
         :
         :	                        /* Store test tuple in the plan node's scan slot */
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
    0.00 :	  5b3819:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b381b:       31 d2                   xor    %edx,%edx
    0.00 :	  5b381d:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b3820:       e8 5b 0c 00 00          callq  5b4480 <ExecStoreTuple>
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
    0.00 :	  5b3825:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b3828:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b382b:       ff 55 b0                callq  *-0x50(%rbp)
    0.00 :	  5b382e:       84 c0                   test   %al,%al
    0.00 :	  5b3830:       0f 84 fa 00 00 00       je     5b3930 <ExecScan+0x1e0>
         :	                 * if the slot returned by the accessMtd contains NULL, then it means
         :	                 * there is nothing more to scan so we just return an empty slot,
         :	                 * being careful to use the projection result slot so it has correct
         :	                 * tupleDesc.
         :	                 */
         :	                if (TupIsNull(slot))
    0.00 :	  5b3836:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b3839:       0f 84 ab 00 00 00       je     5b38ea <ExecScan+0x19a>
    0.00 :	  5b383f:       80 7b 04 00             cmpb   $0x0,0x4(%rbx)
    0.00 :	  5b3843:       0f 85 a1 00 00 00       jne    5b38ea <ExecScan+0x19a>
         :	                 *
         :	                 * check for non-nil qual here to avoid a function call to ExecQual()
         :	                 * when the qual is nil ... saves only a few cycles, but they add up
         :	                 * ...
         :	                 */
         :	                if (!qual || ExecQual(qual, econtext, false))
    0.00 :	  5b3849:       45 84 ff                test   %r15b,%r15b
         :	                }
         :
         :	                /*
         :	                 * place the current tuple into the expr context
         :	                 */
         :	                econtext->ecxt_scantuple = slot;
    0.00 :	  5b384c:       49 89 5d 08             mov    %rbx,0x8(%r13)
         :	                 *
         :	                 * check for non-nil qual here to avoid a function call to ExecQual()
         :	                 * when the qual is nil ... saves only a few cycles, but they add up
         :	                 * ...
         :	                 */
         :	                if (!qual || ExecQual(qual, econtext, false))
    0.00 :	  5b3850:       75 3e                   jne    5b3890 <ExecScan+0x140>
    0.00 :	  5b3852:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5b3856:       31 d2                   xor    %edx,%edx
    0.00 :	  5b3858:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  5b385b:       e8 b0 96 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b3860:       84 c0                   test   %al,%al
    0.00 :	  5b3862:       75 2c                   jne    5b3890 <ExecScan+0x140>
         :	                                 */
         :	                                return slot;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(node, 1);
    0.00 :	  5b3864:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  5b3869:       48 85 c0                test   %rax,%rax
    0.00 :	  5b386c:       0f 84 2e ff ff ff       je     5b37a0 <ExecScan+0x50>
    0.00 :	  5b3872:       f2 0f 10 05 de b8 1f    movsd  0x1fb8de(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b3879:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:223
    4.55 :	  5b387a:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b3881:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:223
    9.09 :	  5b3882:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b3889:       00 
    0.00 :	  5b388a:       e9 11 ff ff ff          jmpq   5b37a0 <ExecScan+0x50>
    0.00 :	  5b388f:       90                      nop
         :	                if (!qual || ExecQual(qual, econtext, false))
         :	                {
         :	                        /*
         :	                         * Found a satisfactory scan tuple.
         :	                         */
         :	                        if (projInfo)
    0.00 :	  5b3890:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b3893:       74 2b                   je     5b38c0 <ExecScan+0x170>
         :	                                /*
         :	                                 * Form a projection tuple, store it in the result tuple slot
         :	                                 * and return it --- unless we find we can project no tuples
         :	                                 * from this scan tuple, in which case continue scan.
         :	                                 */
         :	                                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3895:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b3899:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b389c:       e8 5f 97 ff ff          callq  5ad000 <ExecProject>
    0.00 :	  5b38a1:       48 89 c3                mov    %rax,%rbx
         :	                                if (isDone != ExprEndResult)
    0.00 :	  5b38a4:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  5b38a7:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5b38aa:       0f 84 f0 fe ff ff       je     5b37a0 <ExecScan+0x50>
         :	                                {
         :	                                        node->ps.ps_TupFromTlist = (isDone == ExprMultipleResult);
    0.00 :	  5b38b0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5b38b3:       41 0f 94 44 24 70       sete   0x70(%r12)
    0.00 :	  5b38b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:230
    4.55 :	  5b38c0:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  5b38c4:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b38c7:       5b                      pop    %rbx
    0.00 :	  5b38c8:       41 5c                   pop    %r12
    0.00 :	  5b38ca:       41 5d                   pop    %r13
    0.00 :	  5b38cc:       41 5e                   pop    %r14
    0.00 :	  5b38ce:       41 5f                   pop    %r15
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:230
    9.09 :	  5b38d0:       c9                      leaveq 
    0.00 :	  5b38d1:       c3                      retq   
    0.00 :	  5b38d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        }
         :
         :	        /*
         :	         * Run the node-type-specific access method function to get the next tuple
         :	         */
         :	        return (*accessMtd) (node);
    0.00 :	  5b38d8:       4c 89 e7                mov    %r12,%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
    4.55 :	  5b38db:       ff 55 b8                callq  *-0x48(%rbp)
    0.00 :	  5b38de:       48 89 c3                mov    %rax,%rbx
         :	                 * if the slot returned by the accessMtd contains NULL, then it means
         :	                 * there is nothing more to scan so we just return an empty slot,
         :	                 * being careful to use the projection result slot so it has correct
         :	                 * tupleDesc.
         :	                 */
         :	                if (TupIsNull(slot))
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:175
    9.09 :	  5b38e1:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b38e4:       0f 85 55 ff ff ff       jne    5b383f <ExecScan+0xef>
         :	                {
         :	                        if (projInfo)
    0.00 :	  5b38ea:       4d 85 f6                test   %r14,%r14
    0.00 :	  5b38ed:       0f 1f 00                nopl   (%rax)
    0.00 :	  5b38f0:       74 ce                   je     5b38c0 <ExecScan+0x170>
         :	                                return ExecClearTuple(projInfo->pi_slot);
    0.00 :	  5b38f2:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	  5b38f6:       e8 15 08 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b38fb:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b38fe:       66 90                   xchg   %ax,%ax
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
         :	        }
         :	}
    0.00 :	  5b3900:       eb be                   jmp    5b38c0 <ExecScan+0x170>
    0.00 :	  5b3902:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         */
         :	        for (;;)
         :	        {
         :	                TupleTableSlot *slot;
         :
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  5b3908:       e8 93 89 0e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  5b390d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5b3910:       e9 a3 fe ff ff          jmpq   5b37b8 <ExecScan+0x68>
    0.00 :	  5b3915:       0f 1f 00                nopl   (%rax)
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
         :	                                return ExecClearTuple(slot);
    0.00 :	  5b3918:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b391b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5b3920:       e8 eb 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3925:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b3928:       e9 09 ff ff ff          jmpq   5b3836 <ExecScan+0xe6>
    0.00 :	  5b392d:       0f 1f 00                nopl   (%rax)
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
         :	                                ExecClearTuple(slot);   /* would not be returned by scan */
    0.00 :	  5b3930:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b3933:       e8 d8 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3938:       e9 f9 fe ff ff          jmpq   5b3836 <ExecScan+0xe6>
    0.00 :	  5b393d:       0f 1f 00                nopl   (%rax)
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
         :	        {
         :	                Assert(projInfo);               /* can't get here if not projecting */
         :	                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3940:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b3944:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b3947:       e8 b4 96 ff ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b394c:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ps.ps_TupFromTlist)
         :	        {
         :	                Assert(projInfo);               /* can't get here if not projecting */
         :	                resultSlot = ExecProject(projInfo, &isDone);
    0.00 :	  5b3950:       48 89 c3                mov    %rax,%rbx
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b3953:       0f 84 67 ff ff ff       je     5b38c0 <ExecScan+0x170>
         :	                        return resultSlot;
         :	                /* Done with that source tuple... */
         :	                node->ps.ps_TupFromTlist = false;
    0.00 :	  5b3959:       41 c6 44 24 70 00       movb   $0x0,0x70(%r12)
    0.00 :	  5b395f:       e9 3c fe ff ff          jmpq   5b37a0 <ExecScan+0x50>
         :	         * If we have neither a qual to check nor a projection to do, just skip
         :	         * all the overhead and return the raw scan tuple.
         :	         */
         :	        if (!qual && !projInfo)
         :	        {
         :	                ResetExprContext(econtext);
    0.00 :	  5b3964:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b3968:       e8 43 50 1e 00          callq  7989b0 <MemoryContextReset>
         :	static inline TupleTableSlot *
         :	ExecScanFetch(ScanState *node,
         :	                          ExecScanAccessMtd accessMtd,
         :	                          ExecScanRecheckMtd recheckMtd)
         :	{
         :	        EState     *estate = node->ps.state;
    0.00 :	  5b396d:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :
         :	        if (estate->es_epqTuple != NULL)
    0.00 :	  5b3972:       48 83 ba d0 00 00 00    cmpq   $0x0,0xd0(%rdx)
    0.00 :	  5b3979:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:43
    4.55 :	  5b397a:       74 74                   je     5b39f0 <ExecScan+0x2a0>
         :	                 * conditions.
         :	                 */
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
    0.00 :	  5b397c:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  5b3981:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5b3984:       8d 48 ff                lea    -0x1(%rax),%ecx
    0.00 :	  5b3987:       48 8b 82 d8 00 00 00    mov    0xd8(%rdx),%rax
    0.00 :	  5b398e:       80 3c 08 00             cmpb   $0x0,(%rax,%rcx,1)
    0.00 :	  5b3992:       74 5c                   je     5b39f0 <ExecScan+0x2a0>
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b3994:       48 89 c8                mov    %rcx,%rax
    0.00 :	  5b3997:       48 03 82 e0 00 00 00    add    0xe0(%rdx),%rax
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :	                if (estate->es_epqTupleSet[scanrelid - 1])
         :	                {
         :	                        TupleTableSlot *slot = node->ss_ScanTupleSlot;
    0.00 :	  5b399e:       49 8b 9c 24 88 00 00    mov    0x88(%r12),%rbx
    0.00 :	  5b39a5:       00 
         :
         :	                        /* Return empty slot if we already returned a tuple */
         :	                        if (estate->es_epqScanDone[scanrelid - 1])
    0.00 :	  5b39a6:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  5b39a9:       75 5a                   jne    5b3a05 <ExecScan+0x2b5>
         :	                                return ExecClearTuple(slot);
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
    0.00 :	  5b39ab:       c6 00 01                movb   $0x1,(%rax)
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
    0.00 :	  5b39ae:       48 8b 82 d0 00 00 00    mov    0xd0(%rdx),%rax
    0.00 :	  5b39b5:       48 8b 3c c8             mov    (%rax,%rcx,8),%rdi
    0.00 :	  5b39b9:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b39bc:       74 47                   je     5b3a05 <ExecScan+0x2b5>
         :	                                return ExecClearTuple(slot);
         :
         :	                        /* Store test tuple in the plan node's scan slot */
         :	                        ExecStoreTuple(estate->es_epqTuple[scanrelid - 1],
    0.00 :	  5b39be:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b39c0:       31 d2                   xor    %edx,%edx
    0.00 :	  5b39c2:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b39c5:       e8 b6 0a 00 00          callq  5b4480 <ExecStoreTuple>
         :	                                                   slot, InvalidBuffer, false);
         :
         :	                        /* Check if it meets the access-method conditions */
         :	                        if (!(*recheckMtd) (node, slot))
    0.00 :	  5b39ca:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5b39cd:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b39d0:       ff 55 b0                callq  *-0x50(%rbp)
    0.00 :	  5b39d3:       84 c0                   test   %al,%al
    0.00 :	  5b39d5:       0f 85 e5 fe ff ff       jne    5b38c0 <ExecScan+0x170>
         :	                                ExecClearTuple(slot);   /* would not be returned by scan */
    0.00 :	  5b39db:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b39de:       e8 2d 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b39e3:       e9 d8 fe ff ff          jmpq   5b38c0 <ExecScan+0x170>
    0.00 :	  5b39e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b39ef:       00 
         :	        }
         :
         :	        /*
         :	         * Run the node-type-specific access method function to get the next tuple
         :	         */
         :	        return (*accessMtd) (node);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
    9.09 :	  5b39f0:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5b39f3:       ff 55 b8                callq  *-0x48(%rbp)
    0.00 :	  5b39f6:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b39f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:82
    4.55 :	  5b3a00:       e9 bb fe ff ff          jmpq   5b38c0 <ExecScan+0x170>
         :	                        /* Else mark to remember that we shouldn't return more */
         :	                        estate->es_epqScanDone[scanrelid - 1] = true;
         :
         :	                        /* Return empty slot if we haven't got a test tuple */
         :	                        if (estate->es_epqTuple[scanrelid - 1] == NULL)
         :	                                return ExecClearTuple(slot);
    0.00 :	  5b3a05:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b3a08:       e8 03 07 00 00          callq  5b4110 <ExecClearTuple>
    0.00 :	  5b3a0d:       48 89 c3                mov    %rax,%rbx
    0.00 :	  5b3a10:       e9 ab fe ff ff          jmpq   5b38c0 <ExecScan+0x170>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   63.64 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:121
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:224
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/../../../../src/include/port/atomics/arch-x86.h:202
    4.55 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000677560 <StrategyGetBuffer>:
         :	 *      To ensure that no one else can pin the buffer before we do, we must
         :	 *      return the buffer with the buffer header spinlock still held.
         :	 */
         :	volatile BufferDesc *
         :	StrategyGetBuffer(BufferAccessStrategy strategy)
         :	{
    0.00 :	  677560:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:121
    4.55 :	  677561:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  677564:       41 57                   push   %r15
    0.00 :	  677566:       41 56                   push   %r14
    0.00 :	  677568:       41 55                   push   %r13
    0.00 :	  67756a:       49 89 fd                mov    %rdi,%r13
    0.00 :	  67756d:       41 54                   push   %r12
    0.00 :	  67756f:       53                      push   %rbx
    0.00 :	  677570:       48 83 ec 08             sub    $0x8,%rsp
         :
         :	        /*
         :	         * If given a strategy object, see whether it can select a buffer. We
         :	         * assume strategy objects don't need buffer_strategy_lock.
         :	         */
         :	        if (strategy != NULL)
    0.00 :	  677574:       48 85 ff                test   %rdi,%rdi
    0.00 :	  677577:       74 65                   je     6775de <StrategyGetBuffer+0x7e>
         :	{
         :	        volatile BufferDesc *buf;
         :	        Buffer          bufnum;
         :
         :	        /* Advance to next ring slot */
         :	        if (++strategy->current >= strategy->ring_size)
    0.00 :	  677579:       8b 47 08                mov    0x8(%rdi),%eax
    0.00 :	  67757c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67757f:       3b 47 04                cmp    0x4(%rdi),%eax
    0.00 :	  677582:       89 47 08                mov    %eax,0x8(%rdi)
    0.00 :	  677585:       7c 09                   jl     677590 <StrategyGetBuffer+0x30>
         :	                strategy->current = 0;
    0.00 :	  677587:       c7 47 08 00 00 00 00    movl   $0x0,0x8(%rdi)
    0.00 :	  67758e:       31 c0                   xor    %eax,%eax
         :	        /*
         :	         * If the slot hasn't been filled yet, tell the caller to allocate a new
         :	         * buffer with the normal allocation strategy.  He will then fill this
         :	         * slot by calling AddBufferToRing with the new buffer.
         :	         */
         :	        bufnum = strategy->buffers[strategy->current];
    0.00 :	  677590:       48 98                   cltq   
    0.00 :	  677592:       41 8b 44 85 10          mov    0x10(%r13,%rax,4),%eax
         :	        if (bufnum == InvalidBuffer)
    0.00 :	  677597:       85 c0                   test   %eax,%eax
    0.00 :	  677599:       74 3e                   je     6775d9 <StrategyGetBuffer+0x79>
         :	         * since our own previous usage of the ring element would have left it
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
    0.00 :	  67759b:       48 98                   cltq   
    0.00 :	  67759d:       48 8d 58 ff             lea    -0x1(%rax),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  6775a1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  6775a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6775aa:       48 03 1d 4f 85 54 00    add    0x54854f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	        LockBufHdr(buf);
    0.00 :	  6775b1:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6775b5:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  6775b8:       84 c0                   test   %al,%al
    0.00 :	  6775ba:       0f 85 b8 02 00 00       jne    677878 <StrategyGetBuffer+0x318>
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
    0.00 :	  6775c0:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6775c3:       85 c0                   test   %eax,%eax
    0.00 :	  6775c5:       75 0e                   jne    6775d5 <StrategyGetBuffer+0x75>
    0.00 :	  6775c7:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  6775cb:       66 83 f8 01             cmp    $0x1,%ax
    0.00 :	  6775cf:       0f 86 92 02 00 00       jbe    677867 <StrategyGetBuffer+0x307>
         :	        {
         :	                strategy->current_was_in_ring = true;
         :	                return buf;
         :	        }
         :	        UnlockBufHdr(buf);
    0.00 :	  6775d5:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Tell caller to allocate a new buffer with the normal allocation
         :	         * strategy.  He'll then replace this ring element via AddBufferToRing.
         :	         */
         :	        strategy->current_was_in_ring = false;
    0.00 :	  6775d9:       41 c6 45 0c 00          movb   $0x0,0xc(%r13)
         :	        /*
         :	         * We count buffer allocation requests so that the bgwriter can estimate
         :	         * the rate of buffer consumption.  Note that buffers recycled by a
         :	         * strategy object are intentionally not counted here.
         :	         */
         :	        pg_atomic_fetch_add_u32(&StrategyControl->numBufferAllocs, 1);
    0.00 :	  6775de:       48 8b 05 1b 5b 50 00    mov    0x505b1b(%rip),%rax        # b7d100 <StrategyControl>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  6775e5:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  6775ea:       48 83 c0 14             add    $0x14,%rax
    0.00 :	  6775ee:       f0 0f c1 10             lock xadd %edx,(%rax)
         :	         * Since we're not guaranteed atomic 8 byte reads we need to acquire the
         :	         * spinlock if not null to be sure we get a correct pointer. Because we
         :	         * don't want to set the latch while holding the buffer_strategy_lock we
         :	         * just grab the lock to read and reset the pointer.
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  6775f2:       48 8b 15 07 5b 50 00    mov    0x505b07(%rip),%rdx        # b7d100 <StrategyControl>
         :	        if (bgwriterLatch)
    0.00 :	  6775f9:       48 83 7a 18 00          cmpq   $0x0,0x18(%rdx)
    0.00 :	  6775fe:       74 3e                   je     67763e <StrategyGetBuffer+0xde>
    0.00 :	  677600:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  677605:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677608:       84 c0                   test   %al,%al
    0.00 :	  67760a:       0f 85 21 02 00 00       jne    677831 <StrategyGetBuffer+0x2d1>
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
    0.00 :	  677610:       48 8b 05 e9 5a 50 00    mov    0x505ae9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677617:       48 8b 78 18             mov    0x18(%rax),%rdi
         :	                StrategyControl->bgwriterLatch = NULL;
    0.00 :	  67761b:       48 c7 40 18 00 00 00    movq   $0x0,0x18(%rax)
    0.00 :	  677622:       00 
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677623:       48 8b 05 d6 5a 50 00    mov    0x505ad6(%rip),%rax        # b7d100 <StrategyControl>
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  67762a:       48 85 ff                test   %rdi,%rdi
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	                StrategyControl->bgwriterLatch = NULL;
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67762d:       c6 00 00                movb   $0x0,(%rax)
         :
         :	                /* recheck */
         :	                if (bgwriterLatch)
    0.00 :	  677630:       74 05                   je     677637 <StrategyGetBuffer+0xd7>
         :	                        SetLatch(bgwriterLatch);
    0.00 :	  677632:       e8 89 1a fc ff          callq  6390c0 <SetLatch>
    0.00 :	  677637:       48 8b 15 c2 5a 50 00    mov    0x505ac2(%rip),%rdx        # b7d100 <StrategyControl>
         :	         *
         :	         * Note that the freeNext fields are considered to be protected by
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
    0.00 :	  67763e:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  677641:       85 c0                   test   %eax,%eax
    0.00 :	  677643:       0f 88 08 01 00 00       js     677751 <StrategyGetBuffer+0x1f1>
    0.00 :	  677649:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  67764e:       f0 86 02                lock xchg %al,(%rdx)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677651:       84 c0                   test   %al,%al
    0.00 :	  677653:       0f 85 f3 01 00 00       jne    67784c <StrategyGetBuffer+0x2ec>
    0.00 :	  677659:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  67765f:       eb 30                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677661:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
         :	                        if (buf->refcount == 0 && buf->usage_count == 0)
    0.00 :	  677668:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  67766b:       85 c0                   test   %eax,%eax
    0.00 :	  67766d:       75 0d                   jne    67767c <StrategyGetBuffer+0x11c>
    0.00 :	  67766f:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677673:       66 85 c0                test   %ax,%ax
    0.00 :	  677676:       0f 84 94 00 00 00       je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
    0.00 :	  67767c:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  677680:       44 89 e0                mov    %r12d,%eax
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677683:       48 8b 15 76 5a 50 00    mov    0x505a76(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  67768a:       f0 86 02                lock xchg %al,(%rdx)
    0.00 :	  67768d:       84 c0                   test   %al,%al
    0.00 :	  67768f:       75 5f                   jne    6776f0 <StrategyGetBuffer+0x190>
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :
         :	                while (StrategyControl->firstFreeBuffer >= 0)
    0.00 :	  677691:       48 8b 15 68 5a 50 00    mov    0x505a68(%rip),%rdx        # b7d100 <StrategyControl>
    0.00 :	  677698:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  67769b:       85 c0                   test   %eax,%eax
    0.00 :	  67769d:       0f 88 9d 00 00 00       js     677740 <StrategyGetBuffer+0x1e0>
         :	                {
         :	                        buf = &BufferDescriptors[StrategyControl->firstFreeBuffer];
    0.00 :	  6776a3:       48 63 d8                movslq %eax,%rbx
    0.00 :	  6776a6:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6776aa:       48 03 1d 4f 84 54 00    add    0x54844f(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	                        Assert(buf->freeNext != FREENEXT_NOT_IN_LIST);
         :
         :	                        /* Unconditionally remove buffer from freelist */
         :	                        StrategyControl->firstFreeBuffer = buf->freeNext;
    0.00 :	  6776b1:       8b 43 28                mov    0x28(%rbx),%eax
    0.00 :	  6776b4:       89 42 08                mov    %eax,0x8(%rdx)
         :	                        buf->freeNext = FREENEXT_NOT_IN_LIST;
    0.00 :	  6776b7:       c7 43 28 fe ff ff ff    movl   $0xfffffffe,0x28(%rbx)
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776be:       48 8b 05 3b 5a 50 00    mov    0x505a3b(%rip),%rax        # b7d100 <StrategyControl>
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776c5:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :
         :	                        /*
         :	                         * Release the lock so someone else can access the freelist (or run
         :	                         * the clocksweep) while we check out this buffer.
         :	                         */
         :	                        SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776c9:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  6776cc:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6776cf:       f0 86 07                lock xchg %al,(%rdi)
         :	                         * it; discard it and retry.  (This can only happen if VACUUM put a
         :	                         * valid buffer in the freelist and then someone else used it before
         :	                         * we got to it.  It's probably impossible altogether as of 8.3, but
         :	                         * we'd better check anyway.)
         :	                         */
         :	                        LockBufHdr(buf);
    0.00 :	  6776d2:       84 c0                   test   %al,%al
    0.00 :	  6776d4:       74 92                   je     677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776d6:       ba d0 00 00 00          mov    $0xd0,%edx
    0.00 :	  6776db:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  6776e0:       e8 5b 89 01 00          callq  690040 <s_lock>
    0.00 :	  6776e5:       eb 81                   jmp    677668 <StrategyGetBuffer+0x108>
    0.00 :	  6776e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6776ee:       00 00 
         :	                                return buf;
         :	                        }
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  6776f0:       48 8b 3d 09 5a 50 00    mov    0x505a09(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  6776f7:       ba da 00 00 00          mov    $0xda,%edx
    0.00 :	  6776fc:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677701:       e8 3a 89 01 00          callq  690040 <s_lock>
    0.00 :	  677706:       eb 89                   jmp    677691 <StrategyGetBuffer+0x131>
    0.00 :	  677708:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  67770f:       00 
         :	                                trycounter = NBuffers;
         :	                        }
         :	                        else
         :	                        {
         :	                                /* Found a usable buffer */
         :	                                if (strategy != NULL)
    0.00 :	  677710:       4d 85 ed                test   %r13,%r13
    0.00 :	  677713:       74 0f                   je     677724 <StrategyGetBuffer+0x1c4>
         :	 * is called with the spinlock held, it had better be quite cheap.
         :	 */
         :	static void
         :	AddBufferToRing(BufferAccessStrategy strategy, volatile BufferDesc *buf)
         :	{
         :	        strategy->buffers[strategy->current] = BufferDescriptorGetBuffer(buf);
    0.00 :	  677715:       8b 43 24                mov    0x24(%rbx),%eax
    0.00 :	  677718:       49 63 55 08             movslq 0x8(%r13),%rdx
    0.00 :	  67771c:       83 c0 01                add    $0x1,%eax
    0.00 :	  67771f:       41 89 44 95 10          mov    %eax,0x10(%r13,%rdx,4)
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
         :	        }
         :	}
    0.00 :	  677724:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  677728:       48 89 d8                mov    %rbx,%rax
    0.00 :	  67772b:       5b                      pop    %rbx
    0.00 :	  67772c:       41 5c                   pop    %r12
    0.00 :	  67772e:       41 5d                   pop    %r13
    0.00 :	  677730:       41 5e                   pop    %r14
    0.00 :	  677732:       41 5f                   pop    %r15
    0.00 :	  677734:       c9                      leaveq 
    0.00 :	  677735:       c3                      retq   
    0.00 :	  677736:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67773d:       00 00 00 
         :	                        UnlockBufHdr(buf);
         :
         :	                        /* Reacquire the lock and go around for another pass. */
         :	                        SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
         :	                }
         :	                SpinLockRelease(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677740:       48 8b 05 b9 59 50 00    mov    0x5059b9(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  677747:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  67774a:       48 8b 15 af 59 50 00    mov    0x5059af(%rip),%rdx        # b7d100 <StrategyControl>
         :	        }
         :
         :	        /* Nothing on the freelist, so run the "clock sweep" algorithm */
         :	        trycounter = NBuffers;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:224
    4.55 :	  677751:       44 8b 25 c8 13 4f 00    mov    0x4f13c8(%rip),%r12d        # b68b20 <NBuffers>
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/../../../../src/include/port/atomics/arch-x86.h:202
    4.55 :	  677758:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  67775e:       41 bf 01 00 00 00       mov    $0x1,%r15d
    0.00 :	  677764:       eb 30                   jmp    677796 <StrategyGetBuffer+0x236>
    0.00 :	  677766:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67776d:       00 00 00 
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
         :	                if (buf->refcount == 0)
         :	                {
         :	                        if (buf->usage_count > 0)
    0.00 :	  677770:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  677774:       66 85 c0                test   %ax,%ax
    0.00 :	  677777:       74 97                   je     677710 <StrategyGetBuffer+0x1b0>
         :	                        {
         :	                                buf->usage_count--;
    0.00 :	  677779:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  67777d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  677780:       66 89 43 16             mov    %ax,0x16(%rbx)
         :	                                trycounter = NBuffers;
    0.00 :	  677784:       44 8b 25 95 13 4f 00    mov    0x4f1395(%rip),%r12d        # b68b20 <NBuffers>
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
         :	                }
         :	                UnlockBufHdr(buf);
    0.00 :	  67778b:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  67778f:       48 8b 15 6a 59 50 00    mov    0x50596a(%rip),%rdx        # b7d100 <StrategyControl>
         :	        trycounter = NBuffers;
         :	        for (;;)
         :	        {
         :	                int victim;
         :
         :	                victim = pg_atomic_fetch_add_u32(&StrategyControl->nextVictimBuffer, 1);
    0.00 :	  677796:       48 8d 42 04             lea    0x4(%rdx),%rax
    0.00 :	  67779a:       44 89 f2                mov    %r14d,%edx
    0.00 :	  67779d:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                buf = &BufferDescriptors[victim % NBuffers];
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
   18.18 :	  6777a1:       89 d0                   mov    %edx,%eax
    0.00 :	  6777a3:       c1 fa 1f                sar    $0x1f,%edx
    0.00 :	  6777a6:       f7 3d 74 13 4f 00       idivl  0x4f1374(%rip)        # b68b20 <NBuffers>
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:231
    4.55 :	  6777ac:       48 63 da                movslq %edx,%rbx
    0.00 :	  6777af:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  6777b3:       48 03 1d 46 83 54 00    add    0x548346(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :
         :	                if (victim % NBuffers == 0)
    0.00 :	  6777ba:       85 d2                   test   %edx,%edx
    0.00 :	  6777bc:       75 12                   jne    6777d0 <StrategyGetBuffer+0x270>
         :	                {
         :	                        pg_atomic_add_fetch_u32(&StrategyControl->completePasses, 1);
    0.00 :	  6777be:       48 8b 05 3b 59 50 00    mov    0x50593b(%rip),%rax        # b7d100 <StrategyControl>
    0.00 :	  6777c5:       44 89 f2                mov    %r14d,%edx
    0.00 :	  6777c8:       48 83 c0 10             add    $0x10,%rax
    0.00 :	  6777cc:       f0 0f c1 10             lock xadd %edx,(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  6777d0:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  6777d4:       44 89 f8                mov    %r15d,%eax
    0.00 :	  6777d7:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/freelist.c:242
   63.64 :	  6777da:       84 c0                   test   %al,%al
    0.00 :	  6777dc:       75 42                   jne    677820 <StrategyGetBuffer+0x2c0>
         :	                if (buf->refcount == 0)
    0.00 :	  6777de:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  6777e1:       85 c0                   test   %eax,%eax
    0.00 :	  6777e3:       74 8b                   je     677770 <StrategyGetBuffer+0x210>
         :	                                if (strategy != NULL)
         :	                                        AddBufferToRing(strategy, buf);
         :	                                return buf;
         :	                        }
         :	                }
         :	                else if (--trycounter == 0)
    0.00 :	  6777e5:       41 83 ec 01             sub    $0x1,%r12d
    0.00 :	  6777e9:       75 a0                   jne    67778b <StrategyGetBuffer+0x22b>
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777eb:       ba 80 a1 8a 00          mov    $0x8aa180,%edx
    0.00 :	  6777f0:       be 0c 01 00 00          mov    $0x10c,%esi
    0.00 :	  6777f5:       bf ec a0 8a 00          mov    $0x8aa0ec,%edi
         :	                         * so all the buffers are pinned (or were when we looked at them).
         :	                         * We could hope that someone will free one eventually, but it's
         :	                         * probably better to fail than to risk getting stuck in an
         :	                         * infinite loop.
         :	                         */
         :	                        UnlockBufHdr(buf);
    0.00 :	  6777fa:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                        elog(ERROR, "no unpinned buffers available");
    0.00 :	  6777fe:       e8 1d 3c 10 00          callq  77b420 <elog_start>
    0.00 :	  677803:       be 0e a1 8a 00          mov    $0x8aa10e,%esi
    0.00 :	  677808:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67780d:       31 c0                   xor    %eax,%eax
    0.00 :	  67780f:       e8 1c 3a 10 00          callq  77b230 <elog_finish>
    0.00 :	  677814:       e8 b7 1c df ff          callq  4694d0 <abort@plt>
    0.00 :	  677819:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * If the buffer is pinned or has a nonzero usage_count, we cannot use
         :	                 * it; decrement the usage_count (unless pinned) and keep scanning.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  677820:       ba f2 00 00 00          mov    $0xf2,%edx
    0.00 :	  677825:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67782a:       e8 11 88 01 00          callq  690040 <s_lock>
    0.00 :	  67782f:       eb ad                   jmp    6777de <StrategyGetBuffer+0x27e>
         :	         */
         :	        bgwriterLatch = LATCHPTR_ACCESS_ONCE(StrategyControl->bgwriterLatch);
         :	        if (bgwriterLatch)
         :	        {
         :	                /* we don't have guaranteed atomic 64bit reads */
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  677831:       48 8b 3d c8 58 50 00    mov    0x5058c8(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677838:       ba 9f 00 00 00          mov    $0x9f,%edx
    0.00 :	  67783d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677842:       e8 f9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677847:       e9 c4 fd ff ff          jmpq   677610 <StrategyGetBuffer+0xb0>
         :	         * the buffer_strategy_lock not the individual buffer spinlocks, so it's
         :	         * OK to manipulate them without holding the spinlock.
         :	         */
         :	        if (INT_ACCESS_ONCE(StrategyControl->firstFreeBuffer) >= 0)
         :	        {
         :	                SpinLockAcquire(&StrategyControl->buffer_strategy_lock);
    0.00 :	  67784c:       48 8b 3d ad 58 50 00    mov    0x5058ad(%rip),%rdi        # b7d100 <StrategyControl>
    0.00 :	  677853:       ba b8 00 00 00          mov    $0xb8,%edx
    0.00 :	  677858:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  67785d:       e8 de 87 01 00          callq  690040 <s_lock>
    0.00 :	  677862:       e9 f2 fd ff ff          jmpq   677659 <StrategyGetBuffer+0xf9>
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
         :	        if (buf->refcount == 0 && buf->usage_count <= 1)
         :	        {
         :	                strategy->current_was_in_ring = true;
    0.00 :	  677867:       41 c6 45 0c 01          movb   $0x1,0xc(%r13)
    0.00 :	  67786c:       e9 b3 fe ff ff          jmpq   677724 <StrategyGetBuffer+0x1c4>
    0.00 :	  677871:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * there, but it might've been decremented by clock sweep since then). A
         :	         * higher usage_count indicates someone else has touched the buffer, so we
         :	         * shouldn't re-use it.
         :	         */
         :	        buf = &BufferDescriptors[bufnum - 1];
         :	        LockBufHdr(buf);
    0.00 :	  677878:       ba 20 02 00 00          mov    $0x220,%edx
    0.00 :	  67787d:       be ec a0 8a 00          mov    $0x8aa0ec,%esi
    0.00 :	  677882:       e8 b9 87 01 00          callq  690040 <s_lock>
    0.00 :	  677887:       e9 34 fd ff ff          jmpq   6775c0 <StrategyGetBuffer+0x60>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   95.24 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:666
    4.76 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:602
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068eec0 <LWLockAttemptLock>:
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:602
    4.76 :	  68eec0:       55                      push   %rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec1:       48 85 d2                test   %rdx,%rdx
         :	 * for 'potentially_spurious'. Its value will be set to true if we possibly
         :	 * did so. The caller then has to handle that scenario.
         :	 */
         :	static bool
         :	LWLockAttemptLock(LWLock* lock, LWLockMode mode, bool *potentially_spurious)
         :	{
    0.00 :	  68eec4:       48 89 e5                mov    %rsp,%rbp
         :	        lwstats = get_lwlock_stats_entry(lock);
         :	#endif
         :
         :	        AssertArg(mode == LW_EXCLUSIVE || mode == LW_SHARED);
         :
         :	        if (potentially_spurious != NULL)
    0.00 :	  68eec7:       74 03                   je     68eecc <LWLockAttemptLock+0xc>
         :	                *potentially_spurious = false;
    0.00 :	  68eec9:       c6 02 00                movb   $0x0,(%rdx)
         :
         :	        if (mode == LW_EXCLUSIVE)
    0.00 :	  68eecc:       85 f6                   test   %esi,%esi
    0.00 :	  68eece:       75 28                   jne    68eef8 <LWLockAttemptLock+0x38>
         :	#ifndef PG_HAVE_ATOMIC_READ_U32
         :	#define PG_HAVE_ATOMIC_READ_U32
         :	static inline uint32
         :	pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
         :	{
         :	        return *(&ptr->value);
    0.00 :	  68eed0:       8b 47 04                mov    0x4(%rdi),%eax
         :	                 * First check whether the variable is free without a atomic
         :	                 * operation; it's often quite a bit cheaper for contended
         :	                 * locks. Doing so can cause a superflous shared-exclusive cacheline
         :	                 * transition, but benchmarks show that it's still worth doing so.
         :	                 */
         :	                expected = pg_atomic_read_u32(&lock->lockcount);
    0.00 :	  68eed3:       48 8d 57 04             lea    0x4(%rdi),%rdx
         :
         :	                if (expected != 0)
    0.00 :	  68eed7:       85 c0                   test   %eax,%eax
    0.00 :	  68eed9:       75 65                   jne    68ef40 <LWLockAttemptLock+0x80>
         :
         :	        /*
         :	         * Perform cmpxchg and use the zero flag which it implicitly sets when
         :	         * equal to measure the success.
         :	         */
         :	        __asm__ __volatile__(
    0.00 :	  68eedb:       b9 00 00 00 40          mov    $0x40000000,%ecx
    0.00 :	  68eee0:       89 f0                   mov    %esi,%eax
    0.00 :	  68eee2:       f0 0f b1 0a             lock cmpxchg %ecx,(%rdx)
    0.00 :	  68eee6:       40 0f 94 c6             sete   %sil
    0.00 :	  68eeea:       40 84 f6                test   %sil,%sil
    0.00 :	  68eeed:       0f 94 c1                sete   %cl
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68eef0:       89 c8                   mov    %ecx,%eax
    0.00 :	  68eef2:       c9                      leaveq 
    0.00 :	  68eef3:       c3                      retq   
    0.00 :	  68eef4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                /*
         :	                 * If the caller is interested in spurious locks, do an unlocked check
         :	                 * first.  This is useful if potentially spurious results have a
         :	                 * noticeable cost.
         :	                 */
         :	                if (potentially_spurious != NULL &&
    0.00 :	  68eef8:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68eefb:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68eeff:       74 0e                   je     68ef0f <LWLockAttemptLock+0x4f>
    0.00 :	  68ef01:       8b 47 04                mov    0x4(%rdi),%eax
    0.00 :	  68ef04:       48 8d 77 04             lea    0x4(%rdi),%rsi
    0.00 :	  68ef08:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef0d:       77 31                   ja     68ef40 <LWLockAttemptLock+0x80>
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68ef0f:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  68ef14:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                 * might have to back out again if it turns out somebody else has an
         :	                 * exclusive lock.
         :	                 */
         :	                oldstate = pg_atomic_fetch_add_u32(&lock->lockcount, 1);
         :
         :	                if (oldstate >= EXCLUSIVE_LOCK)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:666
   95.24 :	  68ef18:       31 c9                   xor    %ecx,%ecx
    0.00 :	  68ef1a:       3d ff ff ff 3f          cmp    $0x3fffffff,%eax
    0.00 :	  68ef1f:       76 cf                   jbe    68eef0 <LWLockAttemptLock+0x30>
    0.00 :	  68ef21:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68ef26:       f0 0f c1 06             lock xadd %eax,(%rsi)
         :	                         * problems exist.
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
    0.00 :	  68ef2a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68ef2d:       74 11                   je     68ef40 <LWLockAttemptLock+0x80>
         :	                                *potentially_spurious = true;
    0.00 :	  68ef2f:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  68ef34:       c6 02 01                movb   $0x1,(%rdx)
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef37:       89 c8                   mov    %ecx,%eax
    0.00 :	  68ef39:       c9                      leaveq 
    0.00 :	  68ef3a:       c3                      retq   
    0.00 :	  68ef3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                         */
         :	                        pg_atomic_fetch_sub_u32(&lock->lockcount, 1);
         :
         :
         :	                        if (potentially_spurious != NULL)
         :	                                *potentially_spurious = true;
    0.00 :	  68ef40:       b9 01 00 00 00          mov    $0x1,%ecx
         :	                        return false;
         :	                }
         :	        }
         :
         :	        pg_unreachable();
         :	}
    0.00 :	  68ef45:       c9                      leaveq 
    0.00 :	  68ef46:       89 c8                   mov    %ecx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   15.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:323
   15.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:323
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:291
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:292
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:321
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:329
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:325
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:325
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:325
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:329
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:332
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:344
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:344
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ace60 <_bt_binsrch>:
         :	_bt_binsrch(Relation rel,
         :	                        Buffer buf,
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        bool nextkey)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:283
    5.00 :	  4ace60:       55                      push   %rbp
    5.00 :	  4ace61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ace64:       41 57                   push   %r15
    0.00 :	  4ace66:       41 56                   push   %r14
    5.00 :	  4ace68:       41 55                   push   %r13
    0.00 :	  4ace6a:       41 54                   push   %r12
    0.00 :	  4ace6c:       53                      push   %rbx
    0.00 :	  4ace6d:       48 83 ec 28             sub    $0x28,%rsp
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:291
    5.00 :	  4ace71:       85 f6                   test   %esi,%esi
         :	_bt_binsrch(Relation rel,
         :	                        Buffer buf,
         :	                        int keysz,
         :	                        ScanKey scankey,
         :	                        bool nextkey)
         :	{
    0.00 :	  4ace73:       48 89 4d b0             mov    %rcx,-0x50(%rbp)
    0.00 :	  4ace77:       48 89 7d c0             mov    %rdi,-0x40(%rbp)
    0.00 :	  4ace7b:       89 55 bc                mov    %edx,-0x44(%rbp)
    0.00 :	  4ace7e:       44 89 c1                mov    %r8d,%ecx
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4ace81:       0f 88 c9 00 00 00       js     4acf50 <_bt_binsrch+0xf0>
    0.00 :	  4ace87:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ace8a:       4c 63 f0                movslq %eax,%r14
    0.00 :	  4ace8d:       49 c1 e6 0d             shl    $0xd,%r14
    0.00 :	  4ace91:       4c 03 35 60 2c 71 00    add    0x712c60(%rip),%r14        # bbfaf8 <BufferBlocks>
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ace98:       41 0f b7 46 10          movzwl 0x10(%r14),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:292
    5.00 :	  4ace9d:       49 8d 04 06             lea    (%r14,%rax,1),%rax
    0.00 :	  4acea1:       48 89 45 c8             mov    %rax,-0x38(%rbp)
         :
         :	        low = P_FIRSTDATAKEY(opaque);
    0.00 :	  4acea5:       83 78 04 01             cmpl   $0x1,0x4(%rax)
         :	        high = PageGetMaxOffsetNumber(page);
    0.00 :	  4acea9:       41 0f b7 46 0c          movzwl 0xc(%r14),%eax
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :
         :	        low = P_FIRSTDATAKEY(opaque);
    0.00 :	  4aceae:       45 19 ed                sbb    %r13d,%r13d
    0.00 :	  4aceb1:       41 83 c5 02             add    $0x2,%r13d
         :	        high = PageGetMaxOffsetNumber(page);
    0.00 :	  4aceb5:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4aceb9:       0f 86 7f 00 00 00       jbe    4acf3e <_bt_binsrch+0xde>
    0.00 :	  4acebf:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4acec2:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4acec6:       48 c1 e8 02             shr    $0x2,%rax
         :	         * this covers two cases: the page is really empty (no keys), or it
         :	         * contains only a high key.  The latter case is possible after vacuuming.
         :	         * This can never happen on an internal page, however, since they are
         :	         * never empty (an internal page must have children).
         :	         */
         :	        if (high < low)
    0.00 :	  4aceca:       66 41 39 c5             cmp    %ax,%r13w
    0.00 :	  4acece:       77 6e                   ja     4acf3e <_bt_binsrch+0xde>
         :	         * For nextkey=true (cmpval=0), the loop invariant is: all slots before
         :	         * 'low' are <= scan key, all slots at or after 'high' are > scan key.
         :	         *
         :	         * We can fall out when high == low.
         :	         */
         :	        high++;                                         /* establish the loop invariant for high */
    0.00 :	  4aced0:       44 8d 60 01             lea    0x1(%rax),%r12d
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:321
    5.00 :	  4aced4:       31 c0                   xor    %eax,%eax
    0.00 :	  4aced6:       84 c9                   test   %cl,%cl
    0.00 :	  4aced8:       0f 94 c0                sete   %al
    0.00 :	  4acedb:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :
         :	        while (high > low)
    0.00 :	  4acede:       66 45 39 e5             cmp    %r12w,%r13w
    0.00 :	  4acee2:       73 4c                   jae    4acf30 <_bt_binsrch+0xd0>
    0.00 :	  4acee4:       45 0f b7 fd             movzwl %r13w,%r15d
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:323
   15.00 :	  4acee8:       eb 0f                   jmp    4acef9 <_bt_binsrch+0x99>
    0.00 :	  4aceea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
   15.00 :	  4acef0:       66 44 39 eb             cmp    %r13w,%bx
    0.00 :	  4acef4:       41 89 dc                mov    %ebx,%r12d
    0.00 :	  4acef7:       76 37                   jbe    4acf30 <_bt_binsrch+0xd0>
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
    0.00 :	  4acef9:       41 0f b7 c4             movzwl %r12w,%eax
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:329
    5.00 :	  4acefd:       8b 75 bc                mov    -0x44(%rbp),%esi
    0.00 :	  4acf00:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
         :
         :	        while (high > low)
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:325
    5.00 :	  4acf04:       44 29 f8                sub    %r15d,%eax
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
    0.00 :	  4acf07:       4c 89 f1                mov    %r14,%rcx
         :
         :	        cmpval = nextkey ? 0 : 1;       /* select comparison value */
         :
         :	        while (high > low)
         :	        {
         :	                OffsetNumber mid = low + ((high - low) / 2);
    5.00 :	  4acf0a:       89 c2                   mov    %eax,%edx
    0.00 :	  4acf0c:       c1 ea 1f                shr    $0x1f,%edx
    5.00 :	  4acf0f:       01 c2                   add    %eax,%edx
    0.00 :	  4acf11:       d1 fa                   sar    %edx
    0.00 :	  4acf13:       41 8d 5c 15 00          lea    0x0(%r13,%rdx,1),%ebx
         :
         :	                /* We have low <= mid < high, so mid points at a real slot */
         :
         :	                result = _bt_compare(rel, keysz, scankey, page, mid);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:329
    5.00 :	  4acf18:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  4acf1c:       44 0f b7 c3             movzwl %bx,%r8d
    0.00 :	  4acf20:       e8 2b fd ff ff          callq  4acc50 <_bt_compare>
         :
         :	                if (result >= cmpval)
    0.00 :	  4acf25:       39 45 d4                cmp    %eax,-0x2c(%rbp)
    0.00 :	  4acf28:       7f c6                   jg     4acef0 <_bt_binsrch+0x90>
         :	                        low = mid + 1;
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:332
    5.00 :	  4acf2a:       44 8d 6b 01             lea    0x1(%rbx),%r13d
    0.00 :	  4acf2e:       eb ae                   jmp    4acede <_bt_binsrch+0x7e>
         :	         * past the last slot on the page.
         :	         *
         :	         * On a leaf page, we always return the first key >= scan key (resp. >
         :	         * scan key), which could be the last slot + 1.
         :	         */
         :	        if (P_ISLEAF(opaque))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:344
    5.00 :	  4acf30:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    5.00 :	  4acf34:       f6 40 0c 01             testb  $0x1,0xc(%rax)
    0.00 :	  4acf38:       75 04                   jne    4acf3e <_bt_binsrch+0xde>
         :	         * On a non-leaf page, return the last key < scan key (resp. <= scan key).
         :	         * There must be one if _bt_compare() is playing by the rules.
         :	         */
         :	        Assert(low > P_FIRSTDATAKEY(opaque));
         :
         :	        return OffsetNumberPrev(low);
    0.00 :	  4acf3a:       41 83 ed 01             sub    $0x1,%r13d
         :	}
    0.00 :	  4acf3e:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  4acf42:       44 89 e8                mov    %r13d,%eax
    0.00 :	  4acf45:       5b                      pop    %rbx
    0.00 :	  4acf46:       41 5c                   pop    %r12
    0.00 :	  4acf48:       41 5d                   pop    %r13
    0.00 :	  4acf4a:       41 5e                   pop    %r14
    0.00 :	  4acf4c:       41 5f                   pop    %r15
    0.00 :	  4acf4e:       c9                      leaveq 
    0.00 :	  4acf4f:       c3                      retq   
         :	        OffsetNumber low,
         :	                                high;
         :	        int32           result,
         :	                                cmpval;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4acf50:       48 8b 05 c1 01 6d 00    mov    0x6d01c1(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4acf57:       f7 d6                   not    %esi
    0.00 :	  4acf59:       48 63 d6                movslq %esi,%rdx
    0.00 :	  4acf5c:       4c 8b 34 d0             mov    (%rax,%rdx,8),%r14
    0.00 :	  4acf60:       e9 33 ff ff ff          jmpq   4ace98 <_bt_binsrch+0x38>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1395
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1554
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1395
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1420
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1426
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1519
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1522
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1534
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1549
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ae420 <_bt_checkkeys>:
         :	 */
         :	IndexTuple
         :	_bt_checkkeys(IndexScanDesc scan,
         :	                          Page page, OffsetNumber offnum,
         :	                          ScanDirection dir, bool *continuescan)
         :	{
    0.00 :	  4ae420:       55                      push   %rbp
    0.00 :	  4ae421:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ae424:       41 57                   push   %r15
    0.00 :	  4ae426:       41 56                   push   %r14
    0.00 :	  4ae428:       41 55                   push   %r13
    0.00 :	  4ae42a:       41 54                   push   %r12
    0.00 :	  4ae42c:       53                      push   %rbx
    0.00 :	  4ae42d:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  4ae431:       4c 89 45 c0             mov    %r8,-0x40(%rbp)
         :	        BTScanOpaque so;
         :	        int                     keysz;
         :	        int                     ikey;
         :	        ScanKey         key;
         :
         :	        *continuescan = true;           /* default assumption */
    0.00 :	  4ae435:       48 8b 45 c0             mov    -0x40(%rbp),%rax
         :	 */
         :	IndexTuple
         :	_bt_checkkeys(IndexScanDesc scan,
         :	                          Page page, OffsetNumber offnum,
         :	                          ScanDirection dir, bool *continuescan)
         :	{
    0.00 :	  4ae439:       89 4d cc                mov    %ecx,-0x34(%rbp)
         :	        ItemId          iid = PageGetItemId(page, offnum);
    0.00 :	  4ae43c:       0f b7 ca                movzwl %dx,%ecx
    0.00 :	  4ae43f:       4c 8d 41 ff             lea    -0x1(%rcx),%r8
         :	        BTScanOpaque so;
         :	        int                     keysz;
         :	        int                     ikey;
         :	        ScanKey         key;
         :
         :	        *continuescan = true;           /* default assumption */
    0.00 :	  4ae443:       c6 00 01                movb   $0x1,(%rax)
         :	         * not bother examining the tuple's index keys, but just return
         :	         * immediately with continuescan = true to proceed to the next tuple.
         :	         * However, if this is the last tuple on the page, we should check the
         :	         * index keys to prevent uselessly advancing to the next page.
         :	         */
         :	        if (scan->ignore_killed_tuples && ItemIdIsDead(iid))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1395
   10.00 :	  4ae446:       80 7f 32 00             cmpb   $0x0,0x32(%rdi)
    0.00 :	  4ae44a:       74 14                   je     4ae460 <_bt_checkkeys+0x40>
    0.00 :	  4ae44c:       8b 44 8e 14             mov    0x14(%rsi,%rcx,4),%eax
    0.00 :	  4ae450:       25 00 80 01 00          and    $0x18000,%eax
    5.00 :	  4ae455:       3d 00 80 01 00          cmp    $0x18000,%eax
    0.00 :	  4ae45a:       0f 84 85 03 00 00       je     4ae7e5 <_bt_checkkeys+0x3c5>
         :	                }
         :	                else
         :	                {
         :	                        BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :
         :	                        if (offnum > P_FIRSTDATAKEY(opaque))
    0.00 :	  4ae460:       c6 45 d3 01             movb   $0x1,-0x2d(%rbp)
         :	                tuple_alive = false;
         :	        }
         :	        else
         :	                tuple_alive = true;
         :
         :	        tuple = (IndexTuple) PageGetItem(page, iid);
    0.00 :	  4ae464:       42 0f b7 44 86 18       movzwl 0x18(%rsi,%r8,4),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1420
    5.00 :	  4ae46a:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  4ae46f:       4c 8d 2c 06             lea    (%rsi,%rax,1),%r13
         :
         :	        tupdesc = RelationGetDescr(scan->indexRelation);
    0.00 :	  4ae473:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  4ae477:       4c 8b 78 38             mov    0x38(%rax),%r15
         :	        so = (BTScanOpaque) scan->opaque;
    0.00 :	  4ae47b:       48 8b 47 38             mov    0x38(%rdi),%rax
         :	        keysz = so->numberOfKeys;
    0.00 :	  4ae47f:       8b 50 04                mov    0x4(%rax),%edx
         :
         :	        for (key = so->keyData, ikey = 0; ikey < keysz; key++, ikey++)
    0.00 :	  4ae482:       85 d2                   test   %edx,%edx
         :
         :	        tuple = (IndexTuple) PageGetItem(page, iid);
         :
         :	        tupdesc = RelationGetDescr(scan->indexRelation);
         :	        so = (BTScanOpaque) scan->opaque;
         :	        keysz = so->numberOfKeys;
    0.00 :	  4ae484:       89 55 d4                mov    %edx,-0x2c(%rbp)
         :
         :	        for (key = so->keyData, ikey = 0; ikey < keysz; key++, ikey++)
    0.00 :	  4ae487:       48 8b 58 08             mov    0x8(%rax),%rbx
    0.00 :	  4ae48b:       0f 8e df 01 00 00       jle    4ae670 <_bt_checkkeys+0x250>
    0.00 :	  4ae491:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  4ae494:       eb 34                   jmp    4ae4ca <_bt_checkkeys+0xaa>
    0.00 :	  4ae496:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ae49d:       00 00 00 
         :	                                                          &isNull);
         :
         :	                if (key->sk_flags & SK_ISNULL)
         :	                {
         :	                        /* Handle IS NULL/NOT NULL tests */
         :	                        if (key->sk_flags & SK_SEARCHNULL)
    0.00 :	  4ae4a0:       40 f6 c7 40             test   $0x40,%dil
    0.00 :	  4ae4a4:       0f 84 56 01 00 00       je     4ae600 <_bt_checkkeys+0x1e0>
         :	                        {
         :	                                if (isNull)
    0.00 :	  4ae4aa:       84 c9                   test   %cl,%cl
    0.00 :	  4ae4ac:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  4ae4b0:       0f 84 52 01 00 00       je     4ae608 <_bt_checkkeys+0x1e8>
         :
         :	        tupdesc = RelationGetDescr(scan->indexRelation);
         :	        so = (BTScanOpaque) scan->opaque;
         :	        keysz = so->numberOfKeys;
         :
         :	        for (key = so->keyData, ikey = 0; ikey < keysz; key++, ikey++)
    0.00 :	  4ae4b6:       41 83 c6 01             add    $0x1,%r14d
    0.00 :	  4ae4ba:       44 39 75 d4             cmp    %r14d,-0x2c(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1426
    5.00 :	  4ae4be:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae4c0:       0f 8e aa 01 00 00       jle    4ae670 <_bt_checkkeys+0x250>
    0.00 :	  4ae4c6:       48 83 c3 48             add    $0x48,%rbx
         :	                Datum           datum;
         :	                bool            isNull;
         :	                Datum           test;
         :
         :	                /* row-comparison keys need special processing */
         :	                if (key->sk_flags & SK_ROW_HEADER)
    0.00 :	  4ae4ca:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  4ae4cc:       40 f6 c7 04             test   $0x4,%dil
    0.00 :	  4ae4d0:       0f 85 aa 01 00 00       jne    4ae680 <_bt_checkkeys+0x260>
         :	                        if (_bt_check_rowcompare(key, tuple, tupdesc, dir, continuescan))
         :	                                continue;
         :	                        return NULL;
         :	                }
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae4d6:       66 41 83 7d 06 00       cmpw   $0x0,0x6(%r13)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
   25.00 :	  4ae4dc:       0f 88 c6 00 00 00       js     4ae5a8 <_bt_checkkeys+0x188>
    0.00 :	  4ae4e2:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
    0.00 :	  4ae4e6:       49 8b 47 08             mov    0x8(%r15),%rax
    0.00 :	  4ae4ea:       48 0f bf d1             movswq %cx,%rdx
    0.00 :	  4ae4ee:       48 8b 54 d0 f8          mov    -0x8(%rax,%rdx,8),%rdx
    5.00 :	  4ae4f3:       8b 42 54                mov    0x54(%rdx),%eax
    0.00 :	  4ae4f6:       85 c0                   test   %eax,%eax
    0.00 :	  4ae4f8:       0f 88 32 01 00 00       js     4ae630 <_bt_checkkeys+0x210>
    0.00 :	  4ae4fe:       80 7a 5c 00             cmpb   $0x0,0x5c(%rdx)
    0.00 :	  4ae502:       0f 84 e8 00 00 00       je     4ae5f0 <_bt_checkkeys+0x1d0>
    5.00 :	  4ae508:       0f b7 52 4c             movzwl 0x4c(%rdx),%edx
    0.00 :	  4ae50c:       66 83 fa 08             cmp    $0x8,%dx
    0.00 :	  4ae510:       0f 84 2a 01 00 00       je     4ae640 <_bt_checkkeys+0x220>
    0.00 :	  4ae516:       66 83 fa 04             cmp    $0x4,%dx
    0.00 :	  4ae51a:       0f 84 30 01 00 00       je     4ae650 <_bt_checkkeys+0x230>
    0.00 :	  4ae520:       66 83 fa 02             cmp    $0x2,%dx
    0.00 :	  4ae524:       0f 84 36 01 00 00       je     4ae660 <_bt_checkkeys+0x240>
    0.00 :	  4ae52a:       48 98                   cltq   
    0.00 :	  4ae52c:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae52e:       41 0f b6 54 05 08       movzbl 0x8(%r13,%rax,1),%edx
    0.00 :	  4ae534:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                                          key->sk_attno,
         :	                                                          tupdesc,
         :	                                                          &isNull);
         :
         :	                if (key->sk_flags & SK_ISNULL)
    0.00 :	  4ae538:       40 f6 c7 01             test   $0x1,%dil
    0.00 :	  4ae53c:       0f 85 5e ff ff ff       jne    4ae4a0 <_bt_checkkeys+0x80>
         :	                         * In any case, this indextuple doesn't match the qual.
         :	                         */
         :	                        return NULL;
         :	                }
         :
         :	                if (isNull)
    0.00 :	  4ae542:       84 c9                   test   %cl,%cl
    0.00 :	  4ae544:       0f 85 ec 02 00 00       jne    4ae836 <_bt_checkkeys+0x416>
         :	                         * In any case, this indextuple doesn't match the qual.
         :	                         */
         :	                        return NULL;
         :	                }
         :
         :	                test = FunctionCall2Coll(&key->sk_func, key->sk_collation,
    0.00 :	  4ae54a:       48 8b 4b 40             mov    0x40(%rbx),%rcx
    0.00 :	  4ae54e:       8b 73 0c                mov    0xc(%rbx),%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1519
    5.00 :	  4ae551:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  4ae555:       e8 d6 fa 2c 00          callq  77e030 <FunctionCall2Coll>
         :	                                                                 datum, key->sk_argument);
         :
         :	                if (!DatumGetBool(test))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1522
    5.00 :	  4ae55a:       84 c0                   test   %al,%al
    0.00 :	  4ae55c:       0f 85 54 ff ff ff       jne    4ae4b6 <_bt_checkkeys+0x96>
         :	                         * Note: because we stop the scan as soon as any required equality
         :	                         * qual fails, it is critical that equality quals be used for the
         :	                         * initial positioning in _bt_first() when they are available. See
         :	                         * comments in _bt_first().
         :	                         */
         :	                        if ((key->sk_flags & SK_BT_REQFWD) &&
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1534
    5.00 :	  4ae562:       8b 03                   mov    (%rbx),%eax
    0.00 :	  4ae564:       a9 00 00 01 00          test   $0x10000,%eax
    0.00 :	  4ae569:       74 0b                   je     4ae576 <_bt_checkkeys+0x156>
    0.00 :	  4ae56b:       83 7d cc 01             cmpl   $0x1,-0x34(%rbp)
    0.00 :	  4ae56f:       90                      nop
    0.00 :	  4ae570:       0f 84 e0 01 00 00       je     4ae756 <_bt_checkkeys+0x336>
         :	                                ScanDirectionIsForward(dir))
         :	                                *continuescan = false;
         :	                        else if ((key->sk_flags & SK_BT_REQBKWD) &&
    0.00 :	  4ae576:       a9 00 00 02 00          test   $0x20000,%eax
    0.00 :	  4ae57b:       74 13                   je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae57d:       83 7d cc ff             cmpl   $0xffffffff,-0x34(%rbp)
    0.00 :	  4ae581:       0f 84 a0 02 00 00       je     4ae827 <_bt_checkkeys+0x407>
    0.00 :	  4ae587:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae58e:       00 00 
         :	                        return NULL;
         :	                }
         :	        }
         :
         :	        /* Check for failure due to it being a killed tuple. */
         :	        if (!tuple_alive)
    0.00 :	  4ae590:       45 31 ed                xor    %r13d,%r13d
         :	                return NULL;
         :
         :	        /* If we get here, the tuple passes all index quals. */
         :	        return tuple;
         :	}
    0.00 :	  4ae593:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  4ae597:       4c 89 e8                mov    %r13,%rax
    0.00 :	  4ae59a:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1554
   10.00 :	  4ae59b:       41 5c                   pop    %r12
    0.00 :	  4ae59d:       41 5d                   pop    %r13
    0.00 :	  4ae59f:       41 5e                   pop    %r14
    0.00 :	  4ae5a1:       41 5f                   pop    %r15
    0.00 :	  4ae5a3:       c9                      leaveq 
    0.00 :	  4ae5a4:       c3                      retq   
    0.00 :	  4ae5a5:       0f 1f 00                nopl   (%rax)
         :	                        if (_bt_check_rowcompare(key, tuple, tupdesc, dir, continuescan))
         :	                                continue;
         :	                        return NULL;
         :	                }
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae5a8:       0f bf 73 04             movswl 0x4(%rbx),%esi
    0.00 :	  4ae5ac:       31 d2                   xor    %edx,%edx
    0.00 :	  4ae5ae:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  4ae5b1:       89 c8                   mov    %ecx,%eax
    0.00 :	  4ae5b3:       83 e1 07                and    $0x7,%ecx
    0.00 :	  4ae5b6:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4ae5b9:       48 98                   cltq   
    0.00 :	  4ae5bb:       41 0f be 44 05 08       movsbl 0x8(%r13,%rax,1),%eax
    0.00 :	  4ae5c1:       d3 f8                   sar    %cl,%eax
    0.00 :	  4ae5c3:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ae5c8:       a8 01                   test   $0x1,%al
    0.00 :	  4ae5ca:       0f 84 68 ff ff ff       je     4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae5d0:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  4ae5d3:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ae5d6:       e8 85 25 fc ff          callq  470b60 <nocache_index_getattr>
    0.00 :	  4ae5db:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  4ae5dd:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4ae5e0:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae5e2:       e9 51 ff ff ff          jmpq   4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae5e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae5ee:       00 00 
    0.00 :	  4ae5f0:       48 98                   cltq   
    0.00 :	  4ae5f2:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae5f4:       49 8d 54 05 08          lea    0x8(%r13,%rax,1),%rdx
    0.00 :	  4ae5f9:       e9 3a ff ff ff          jmpq   4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae5fe:       66 90                   xchg   %ax,%ax
         :	                                        continue;       /* tuple satisfies this qual */
         :	                        }
         :	                        else
         :	                        {
         :	                                Assert(key->sk_flags & SK_SEARCHNOTNULL);
         :	                                if (!isNull)
    0.00 :	  4ae600:       84 c9                   test   %cl,%cl
    0.00 :	  4ae602:       0f 84 ae fe ff ff       je     4ae4b6 <_bt_checkkeys+0x96>
         :	                        /*
         :	                         * Tuple fails this qual.  If it's a required qual for the current
         :	                         * scan direction, then we can conclude no further tuples will
         :	                         * pass, either.
         :	                         */
         :	                        if ((key->sk_flags & SK_BT_REQFWD) &&
    0.00 :	  4ae608:       f7 c7 00 00 01 00       test   $0x10000,%edi
    0.00 :	  4ae60e:       74 0a                   je     4ae61a <_bt_checkkeys+0x1fa>
    0.00 :	  4ae610:       83 7d cc 01             cmpl   $0x1,-0x34(%rbp)
    0.00 :	  4ae614:       0f 84 3c 01 00 00       je     4ae756 <_bt_checkkeys+0x336>
         :	                                ScanDirectionIsForward(dir))
         :	                                *continuescan = false;
         :	                        else if ((key->sk_flags & SK_BT_REQBKWD) &&
    0.00 :	  4ae61a:       81 e7 00 00 02 00       and    $0x20000,%edi
    0.00 :	  4ae620:       0f 84 6a ff ff ff       je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae626:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae628:       e9 50 ff ff ff          jmpq   4ae57d <_bt_checkkeys+0x15d>
    0.00 :	  4ae62d:       0f 1f 00                nopl   (%rax)
         :	                        if (_bt_check_rowcompare(key, tuple, tupdesc, dir, continuescan))
         :	                                continue;
         :	                        return NULL;
         :	                }
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae630:       0f bf f1                movswl %cx,%esi
    0.00 :	  4ae633:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae638:       eb 96                   jmp    4ae5d0 <_bt_checkkeys+0x1b0>
    0.00 :	  4ae63a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae640:       48 98                   cltq   
    0.00 :	  4ae642:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae644:       49 8b 54 05 08          mov    0x8(%r13,%rax,1),%rdx
    0.00 :	  4ae649:       e9 ea fe ff ff          jmpq   4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae64e:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae650:       48 98                   cltq   
    0.00 :	  4ae652:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae654:       41 8b 54 05 08          mov    0x8(%r13,%rax,1),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1440
   10.00 :	  4ae659:       e9 da fe ff ff          jmpq   4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae65e:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae660:       48 98                   cltq   
    0.00 :	  4ae662:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ae664:       41 0f b7 54 05 08       movzwl 0x8(%r13,%rax,1),%edx
    0.00 :	  4ae66a:       e9 c9 fe ff ff          jmpq   4ae538 <_bt_checkkeys+0x118>
    0.00 :	  4ae66f:       90                      nop
         :	                        return NULL;
         :	                }
         :	        }
         :
         :	        /* Check for failure due to it being a killed tuple. */
         :	        if (!tuple_alive)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1549
    5.00 :	  4ae670:       80 7d d3 00             cmpb   $0x0,-0x2d(%rbp)
    0.00 :	  4ae674:       0f 85 19 ff ff ff       jne    4ae593 <_bt_checkkeys+0x173>
    0.00 :	  4ae67a:       e9 11 ff ff ff          jmpq   4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae67f:       90                      nop
         :	 */
         :	static bool
         :	_bt_check_rowcompare(ScanKey skey, IndexTuple tuple, TupleDesc tupdesc,
         :	                                         ScanDirection dir, bool *continuescan)
         :	{
         :	        ScanKey         subkey = (ScanKey) DatumGetPointer(skey->sk_argument);
    0.00 :	  4ae680:       4c 8b 63 40             mov    0x40(%rbx),%r12
    0.00 :	  4ae684:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  4ae688:       eb 7b                   jmp    4ae705 <_bt_checkkeys+0x2e5>
    0.00 :	  4ae68a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                Datum           datum;
         :	                bool            isNull;
         :
         :	                Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae690:       41 0f b7 74 24 04       movzwl 0x4(%r12),%esi
    0.00 :	  4ae696:       49 8b 47 08             mov    0x8(%r15),%rax
    0.00 :	  4ae69a:       48 0f bf d6             movswq %si,%rdx
    0.00 :	  4ae69e:       48 8b 4c d0 f8          mov    -0x8(%rax,%rdx,8),%rcx
    0.00 :	  4ae6a3:       8b 79 54                mov    0x54(%rcx),%edi
    0.00 :	  4ae6a6:       85 ff                   test   %edi,%edi
    0.00 :	  4ae6a8:       0f 88 e2 00 00 00       js     4ae790 <_bt_checkkeys+0x370>
    0.00 :	  4ae6ae:       80 79 5c 00             cmpb   $0x0,0x5c(%rcx)
    0.00 :	  4ae6b2:       48 63 c7                movslq %edi,%rax
    0.00 :	  4ae6b5:       49 8d 54 05 08          lea    0x8(%r13,%rax,1),%rdx
    0.00 :	  4ae6ba:       0f 85 a8 00 00 00       jne    4ae768 <_bt_checkkeys+0x348>
         :	                         * In any case, this indextuple doesn't match the qual.
         :	                         */
         :	                        return false;
         :	                }
         :
         :	                if (subkey->sk_flags & SK_ISNULL)
    0.00 :	  4ae6c0:       41 f6 04 24 01          testb  $0x1,(%r12)
    0.00 :	  4ae6c5:       0f 85 e2 01 00 00       jne    4ae8ad <_bt_checkkeys+0x48d>
         :	                                *continuescan = false;
         :	                        return false;
         :	                }
         :
         :	                /* Perform the test --- three-way comparison not bool operator */
         :	                cmpresult = DatumGetInt32(FunctionCall2Coll(&subkey->sk_func,
    0.00 :	  4ae6cb:       49 8b 4c 24 40          mov    0x40(%r12),%rcx
    0.00 :	  4ae6d0:       41 8b 74 24 0c          mov    0xc(%r12),%esi
    0.00 :	  4ae6d5:       49 8d 7c 24 10          lea    0x10(%r12),%rdi
    0.00 :	  4ae6da:       e8 51 f9 2c 00          callq  77e030 <FunctionCall2Coll>
         :	                                                                                                        subkey->sk_collation,
         :	                                                                                                        datum,
         :	                                                                                                        subkey->sk_argument));
         :
         :	                if (subkey->sk_flags & SK_BT_DESC)
    0.00 :	  4ae6df:       41 8b 0c 24             mov    (%r12),%ecx
         :	                                *continuescan = false;
         :	                        return false;
         :	                }
         :
         :	                /* Perform the test --- three-way comparison not bool operator */
         :	                cmpresult = DatumGetInt32(FunctionCall2Coll(&subkey->sk_func,
    0.00 :	  4ae6e3:       89 c2                   mov    %eax,%edx
         :	                                                                                                        subkey->sk_collation,
         :	                                                                                                        datum,
         :	                                                                                                        subkey->sk_argument));
         :
         :	                if (subkey->sk_flags & SK_BT_DESC)
         :	                        cmpresult = -cmpresult;
    0.00 :	  4ae6e5:       f7 d8                   neg    %eax
    0.00 :	  4ae6e7:       f7 c1 00 00 00 01       test   $0x1000000,%ecx
    0.00 :	  4ae6ed:       0f 45 d0                cmovne %eax,%edx
         :
         :	                /* Done comparing if unequal, else advance to next column */
         :	                if (cmpresult != 0)
    0.00 :	  4ae6f0:       85 d2                   test   %edx,%edx
    0.00 :	  4ae6f2:       0f 85 6d 01 00 00       jne    4ae865 <_bt_checkkeys+0x445>
         :	                        break;
         :
         :	                if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ae6f8:       f6 c1 10                test   $0x10,%cl
    0.00 :	  4ae6fb:       0f 85 64 01 00 00       jne    4ae865 <_bt_checkkeys+0x445>
         :	                        break;
         :	                subkey++;
    0.00 :	  4ae701:       49 83 c4 48             add    $0x48,%r12
         :	                Datum           datum;
         :	                bool            isNull;
         :
         :	                Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae705:       66 41 83 7d 06 00       cmpw   $0x0,0x6(%r13)
    0.00 :	  4ae70b:       79 83                   jns    4ae690 <_bt_checkkeys+0x270>
    0.00 :	  4ae70d:       41 0f bf 74 24 04       movswl 0x4(%r12),%esi
    0.00 :	  4ae713:       8d 4e ff                lea    -0x1(%rsi),%ecx
    0.00 :	  4ae716:       89 c8                   mov    %ecx,%eax
    0.00 :	  4ae718:       83 e1 07                and    $0x7,%ecx
    0.00 :	  4ae71b:       c1 f8 03                sar    $0x3,%eax
    0.00 :	  4ae71e:       48 98                   cltq   
    0.00 :	  4ae720:       41 0f be 44 05 08       movsbl 0x8(%r13,%rax,1),%eax
    0.00 :	  4ae726:       d3 f8                   sar    %cl,%eax
    0.00 :	  4ae728:       a8 01                   test   $0x1,%al
    0.00 :	  4ae72a:       0f 85 80 00 00 00       jne    4ae7b0 <_bt_checkkeys+0x390>
         :	                                                          tupdesc,
         :	                                                          &isNull);
         :
         :	                if (isNull)
         :	                {
         :	                        if (subkey->sk_flags & SK_BT_NULLS_FIRST)
    0.00 :	  4ae730:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  4ae734:       a9 00 00 00 02          test   $0x2000000,%eax
    0.00 :	  4ae739:       0f 84 11 02 00 00       je     4ae950 <_bt_checkkeys+0x530>
         :	                                 * of whether the qual is > or <, so long as it's required,
         :	                                 * because it's not possible for any future tuples to pass. On
         :	                                 * a forward scan, however, we must keep going, because we may
         :	                                 * have initially positioned to the start of the index.
         :	                                 */
         :	                                if ((subkey->sk_flags & (SK_BT_REQFWD | SK_BT_REQBKWD)) &&
    0.00 :	  4ae73f:       a9 00 00 03 00          test   $0x30000,%eax
    0.00 :	  4ae744:       0f 84 46 fe ff ff       je     4ae590 <_bt_checkkeys+0x170>
         :	                                 * of whether the qual is > or <, so long as it's required,
         :	                                 * because it's not possible for any future tuples to pass. On
         :	                                 * a forward scan, however, we must keep going, because we may
         :	                                 * have initially positioned to the start of the index.
         :	                                 */
         :	                                if ((key->sk_flags & (SK_BT_REQFWD | SK_BT_REQBKWD)) &&
    0.00 :	  4ae74a:       83 7d cc ff             cmpl   $0xffffffff,-0x34(%rbp)
    0.00 :	  4ae74e:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae750:       0f 85 3a fe ff ff       jne    4ae590 <_bt_checkkeys+0x170>
         :	                         * initial positioning in _bt_first() when they are available. See
         :	                         * comments in _bt_first().
         :	                         */
         :	                        if ((key->sk_flags & SK_BT_REQFWD) &&
         :	                                ScanDirectionIsForward(dir))
         :	                                *continuescan = false;
    0.00 :	  4ae756:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  4ae75a:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ae75d:       c6 00 00                movb   $0x0,(%rax)
    0.00 :	  4ae760:       e9 2e fe ff ff          jmpq   4ae593 <_bt_checkkeys+0x173>
    0.00 :	  4ae765:       0f 1f 00                nopl   (%rax)
         :	                Datum           datum;
         :	                bool            isNull;
         :
         :	                Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae768:       0f b7 41 4c             movzwl 0x4c(%rcx),%eax
    0.00 :	  4ae76c:       66 83 f8 08             cmp    $0x8,%ax
    0.00 :	  4ae770:       74 56                   je     4ae7c8 <_bt_checkkeys+0x3a8>
    0.00 :	  4ae772:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  4ae776:       74 60                   je     4ae7d8 <_bt_checkkeys+0x3b8>
    0.00 :	  4ae778:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  4ae77c:       0f 84 d3 00 00 00       je     4ae855 <_bt_checkkeys+0x435>
    0.00 :	  4ae782:       48 63 c7                movslq %edi,%rax
    0.00 :	  4ae785:       41 0f b6 54 05 08       movzbl 0x8(%r13,%rax,1),%edx
    0.00 :	  4ae78b:       e9 30 ff ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
    0.00 :	  4ae790:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  4ae793:       0f bf f6                movswl %si,%esi
    0.00 :	  4ae796:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ae799:       e8 c2 23 fc ff          callq  470b60 <nocache_index_getattr>
    0.00 :	  4ae79e:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4ae7a1:       e9 1a ff ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
    0.00 :	  4ae7a6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ae7ad:       00 00 00 
    0.00 :	  4ae7b0:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  4ae7b3:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ae7b6:       e8 a5 23 fc ff          callq  470b60 <nocache_index_getattr>
    0.00 :	  4ae7bb:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4ae7be:       e9 fd fe ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
    0.00 :	  4ae7c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae7c8:       48 63 c7                movslq %edi,%rax
    0.00 :	  4ae7cb:       49 8b 54 05 08          mov    0x8(%r13,%rax,1),%rdx
    0.00 :	  4ae7d0:       e9 eb fe ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
    0.00 :	  4ae7d5:       0f 1f 00                nopl   (%rax)
    0.00 :	  4ae7d8:       48 63 c7                movslq %edi,%rax
    0.00 :	  4ae7db:       41 8b 54 05 08          mov    0x8(%r13,%rax,1),%edx
    0.00 :	  4ae7e0:       e9 db fe ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
         :	         * index keys to prevent uselessly advancing to the next page.
         :	         */
         :	        if (scan->ignore_killed_tuples && ItemIdIsDead(iid))
         :	        {
         :	                /* return immediately if there are more tuples on the page */
         :	                if (ScanDirectionIsForward(dir))
    0.00 :	  4ae7e5:       83 7d cc 01             cmpl   $0x1,-0x34(%rbp)
    0.00 :	  4ae7e9:       0f 84 36 01 00 00       je     4ae925 <_bt_checkkeys+0x505>
         :	                }
         :	                else
         :	                {
         :	                        BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :
         :	                        if (offnum > P_FIRSTDATAKEY(opaque))
    0.00 :	  4ae7ef:       0f b7 46 10             movzwl 0x10(%rsi),%eax
    0.00 :	  4ae7f3:       0f b7 d2                movzwl %dx,%edx
    0.00 :	  4ae7f6:       83 7c 06 04 01          cmpl   $0x1,0x4(%rsi,%rax,1)
    0.00 :	  4ae7fb:       19 c0                   sbb    %eax,%eax
    0.00 :	  4ae7fd:       83 c0 02                add    $0x2,%eax
    0.00 :	  4ae800:       39 d0                   cmp    %edx,%eax
    0.00 :	  4ae802:       0f 8c 88 fd ff ff       jl     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae808:       c6 45 d3 00             movb   $0x0,-0x2d(%rbp)
    0.00 :	  4ae80c:       e9 53 fc ff ff          jmpq   4ae464 <_bt_checkkeys+0x44>
         :	                                 * whether the qual is > or <, so long as it's required,
         :	                                 * because it's not possible for any future tuples to pass. On
         :	                                 * a backward scan, however, we must keep going, because we
         :	                                 * may have initially positioned to the end of the index.
         :	                                 */
         :	                                if ((key->sk_flags & (SK_BT_REQFWD | SK_BT_REQBKWD)) &&
    0.00 :	  4ae811:       81 e7 00 00 03 00       and    $0x30000,%edi
    0.00 :	  4ae817:       0f 84 73 fd ff ff       je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae81d:       83 7d cc 01             cmpl   $0x1,-0x34(%rbp)
    0.00 :	  4ae821:       0f 85 69 fd ff ff       jne    4ae590 <_bt_checkkeys+0x170>
         :	                        if ((key->sk_flags & SK_BT_REQFWD) &&
         :	                                ScanDirectionIsForward(dir))
         :	                                *continuescan = false;
         :	                        else if ((key->sk_flags & SK_BT_REQBKWD) &&
         :	                                         ScanDirectionIsBackward(dir))
         :	                                *continuescan = false;
    0.00 :	  4ae827:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  4ae82b:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ae82e:       c6 02 00                movb   $0x0,(%rdx)
    0.00 :	  4ae831:       e9 5d fd ff ff          jmpq   4ae593 <_bt_checkkeys+0x173>
         :	                        return NULL;
         :	                }
         :
         :	                if (isNull)
         :	                {
         :	                        if (key->sk_flags & SK_BT_NULLS_FIRST)
    0.00 :	  4ae836:       f7 c7 00 00 00 02       test   $0x2000000,%edi
    0.00 :	  4ae83c:       74 d3                   je     4ae811 <_bt_checkkeys+0x3f1>
         :	                                 * of whether the qual is > or <, so long as it's required,
         :	                                 * because it's not possible for any future tuples to pass. On
         :	                                 * a forward scan, however, we must keep going, because we may
         :	                                 * have initially positioned to the start of the index.
         :	                                 */
         :	                                if ((key->sk_flags & (SK_BT_REQFWD | SK_BT_REQBKWD)) &&
    0.00 :	  4ae83e:       81 e7 00 00 03 00       and    $0x30000,%edi
    0.00 :	  4ae844:       0f 84 46 fd ff ff       je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae84a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae850:       e9 f5 fe ff ff          jmpq   4ae74a <_bt_checkkeys+0x32a>
         :	                Datum           datum;
         :	                bool            isNull;
         :
         :	                Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :
         :	                datum = index_getattr(tuple,
    0.00 :	  4ae855:       48 63 c7                movslq %edi,%rax
    0.00 :	  4ae858:       41 0f b7 54 05 08       movzwl 0x8(%r13,%rax,1),%edx
    0.00 :	  4ae85e:       66 90                   xchg   %ax,%ax
    0.00 :	  4ae860:       e9 5b fe ff ff          jmpq   4ae6c0 <_bt_checkkeys+0x2a0>
         :	        /*
         :	         * At this point cmpresult indicates the overall result of the row
         :	         * comparison, and subkey points to the deciding column (or the last
         :	         * column if the result is "=").
         :	         */
         :	        switch (subkey->sk_strategy)
    0.00 :	  4ae865:       41 0f b7 44 24 06       movzwl 0x6(%r12),%eax
    0.00 :	  4ae86b:       66 83 f8 02             cmp    $0x2,%ax
    0.00 :	  4ae86f:       90                      nop
    0.00 :	  4ae870:       0f 84 ef 00 00 00       je     4ae965 <_bt_checkkeys+0x545>
    0.00 :	  4ae876:       77 56                   ja     4ae8ce <_bt_checkkeys+0x4ae>
    0.00 :	  4ae878:       66 83 e8 01             sub    $0x1,%ax
    0.00 :	  4ae87c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  4ae880:       75 5c                   jne    4ae8de <_bt_checkkeys+0x4be>
         :	                        break;
         :	                case BTLessEqualStrategyNumber:
         :	                        result = (cmpresult <= 0);
         :	                        break;
         :	                case BTGreaterEqualStrategyNumber:
         :	                        result = (cmpresult >= 0);
    0.00 :	  4ae882:       89 d0                   mov    %edx,%eax
    0.00 :	  4ae884:       c1 e8 1f                shr    $0x1f,%eax
         :	                                 (int) subkey->sk_strategy);
         :	                        result = 0;                     /* keep compiler quiet */
         :	                        break;
         :	        }
         :
         :	        if (!result)
    0.00 :	  4ae887:       84 c0                   test   %al,%al
    0.00 :	  4ae889:       0f 85 27 fc ff ff       jne    4ae4b6 <_bt_checkkeys+0x96>
         :	                 * Tuple fails this qual.  If it's a required qual for the current
         :	                 * scan direction, then we can conclude no further tuples will pass,
         :	                 * either.  Note we have to look at the deciding column, not
         :	                 * necessarily the first or last column of the row condition.
         :	                 */
         :	                if ((subkey->sk_flags & SK_BT_REQFWD) &&
    0.00 :	  4ae88f:       f7 c1 00 00 01 00       test   $0x10000,%ecx
    0.00 :	  4ae895:       75 77                   jne    4ae90e <_bt_checkkeys+0x4ee>
         :	                        ScanDirectionIsForward(dir))
         :	                        *continuescan = false;
         :	                else if ((subkey->sk_flags & SK_BT_REQBKWD) &&
    0.00 :	  4ae897:       81 e1 00 00 02 00       and    $0x20000,%ecx
    0.00 :	  4ae89d:       0f 84 ed fc ff ff       je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae8a3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae8a8:       e9 d0 fc ff ff          jmpq   4ae57d <_bt_checkkeys+0x15d>
         :	                         * But it can never match.  If all the earlier row comparison
         :	                         * columns are required for the scan direction, we can stop the
         :	                         * scan, because there can't be another tuple that will succeed.
         :	                         */
         :	                        if (subkey != (ScanKey) DatumGetPointer(skey->sk_argument))
         :	                                subkey--;
    0.00 :	  4ae8ad:       4c 3b 63 40             cmp    0x40(%rbx),%r12
    0.00 :	  4ae8b1:       49 8d 44 24 b8          lea    -0x48(%r12),%rax
    0.00 :	  4ae8b6:       4c 0f 45 e0             cmovne %rax,%r12
         :	                        if ((subkey->sk_flags & SK_BT_REQFWD) &&
    0.00 :	  4ae8ba:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  4ae8be:       a9 00 00 01 00          test   $0x10000,%eax
    0.00 :	  4ae8c3:       0f 84 ad fc ff ff       je     4ae576 <_bt_checkkeys+0x156>
    0.00 :	  4ae8c9:       e9 9d fc ff ff          jmpq   4ae56b <_bt_checkkeys+0x14b>
         :	        /*
         :	         * At this point cmpresult indicates the overall result of the row
         :	         * comparison, and subkey points to the deciding column (or the last
         :	         * column if the result is "=").
         :	         */
         :	        switch (subkey->sk_strategy)
    0.00 :	  4ae8ce:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  4ae8d2:       74 45                   je     4ae919 <_bt_checkkeys+0x4f9>
    0.00 :	  4ae8d4:       66 83 f8 05             cmp    $0x5,%ax
    0.00 :	  4ae8d8:       0f 84 91 00 00 00       je     4ae96f <_bt_checkkeys+0x54f>
         :	                        break;
         :	                case BTGreaterStrategyNumber:
         :	                        result = (cmpresult > 0);
         :	                        break;
         :	                default:
         :	                        elog(ERROR, "unrecognized RowCompareType: %d",
    0.00 :	  4ae8de:       ba 20 4b 7b 00          mov    $0x7b4b20,%edx
    0.00 :	  4ae8e3:       be 99 06 00 00          mov    $0x699,%esi
    0.00 :	  4ae8e8:       bf 17 49 7b 00          mov    $0x7b4917,%edi
    0.00 :	  4ae8ed:       e8 2e cb 2c 00          callq  77b420 <elog_start>
    0.00 :	  4ae8f2:       41 0f b7 54 24 06       movzwl 0x6(%r12),%edx
    0.00 :	  4ae8f8:       be 98 49 7b 00          mov    $0x7b4998,%esi
    0.00 :	  4ae8fd:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ae902:       31 c0                   xor    %eax,%eax
    0.00 :	  4ae904:       e8 27 c9 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4ae909:       e8 c2 ab fb ff          callq  4694d0 <abort@plt>
         :	                 * Tuple fails this qual.  If it's a required qual for the current
         :	                 * scan direction, then we can conclude no further tuples will pass,
         :	                 * either.  Note we have to look at the deciding column, not
         :	                 * necessarily the first or last column of the row condition.
         :	                 */
         :	                if ((subkey->sk_flags & SK_BT_REQFWD) &&
    0.00 :	  4ae90e:       83 7d cc 01             cmpl   $0x1,-0x34(%rbp)
    0.00 :	  4ae912:       75 83                   jne    4ae897 <_bt_checkkeys+0x477>
    0.00 :	  4ae914:       e9 3d fe ff ff          jmpq   4ae756 <_bt_checkkeys+0x336>
         :	                        break;
         :	                case BTLessEqualStrategyNumber:
         :	                        result = (cmpresult <= 0);
         :	                        break;
         :	                case BTGreaterEqualStrategyNumber:
         :	                        result = (cmpresult >= 0);
    0.00 :	  4ae919:       f7 d2                   not    %edx
    0.00 :	  4ae91b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae920:       e9 5d ff ff ff          jmpq   4ae882 <_bt_checkkeys+0x462>
         :	        if (scan->ignore_killed_tuples && ItemIdIsDead(iid))
         :	        {
         :	                /* return immediately if there are more tuples on the page */
         :	                if (ScanDirectionIsForward(dir))
         :	                {
         :	                        if (offnum < PageGetMaxOffsetNumber(page))
    0.00 :	  4ae925:       0f b7 46 0c             movzwl 0xc(%rsi),%eax
    0.00 :	  4ae929:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4ae92d:       0f 1f 00                nopl   (%rax)
    0.00 :	  4ae930:       0f 86 d2 fe ff ff       jbe    4ae808 <_bt_checkkeys+0x3e8>
    0.00 :	  4ae936:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4ae939:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4ae93d:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4ae941:       48 39 c1                cmp    %rax,%rcx
    0.00 :	  4ae944:       0f 82 46 fc ff ff       jb     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae94a:       e9 b9 fe ff ff          jmpq   4ae808 <_bt_checkkeys+0x3e8>
    0.00 :	  4ae94f:       90                      nop
         :	                                 * whether the qual is > or <, so long as it's required,
         :	                                 * because it's not possible for any future tuples to pass. On
         :	                                 * a backward scan, however, we must keep going, because we
         :	                                 * may have initially positioned to the end of the index.
         :	                                 */
         :	                                if ((subkey->sk_flags & (SK_BT_REQFWD | SK_BT_REQBKWD)) &&
    0.00 :	  4ae950:       a9 00 00 03 00          test   $0x30000,%eax
    0.00 :	  4ae955:       0f 84 35 fc ff ff       je     4ae590 <_bt_checkkeys+0x170>
    0.00 :	  4ae95b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae960:       e9 b8 fe ff ff          jmpq   4ae81d <_bt_checkkeys+0x3fd>
         :	                        /* EQ and NE cases aren't allowed here */
         :	                case BTLessStrategyNumber:
         :	                        result = (cmpresult < 0);
         :	                        break;
         :	                case BTLessEqualStrategyNumber:
         :	                        result = (cmpresult <= 0);
    0.00 :	  4ae965:       85 d2                   test   %edx,%edx
    0.00 :	  4ae967:       0f 9e c0                setle  %al
    0.00 :	  4ae96a:       e9 18 ff ff ff          jmpq   4ae887 <_bt_checkkeys+0x467>
         :	                        break;
         :	                case BTGreaterEqualStrategyNumber:
         :	                        result = (cmpresult >= 0);
         :	                        break;
         :	                case BTGreaterStrategyNumber:
         :	                        result = (cmpresult > 0);
    0.00 :	  4ae96f:       85 d2                   test   %edx,%edx
    0.00 :	  4ae971:       0f 9f c0                setg   %al
    0.00 :	  4ae974:       e9 0e ff ff ff          jmpq   4ae887 <_bt_checkkeys+0x467>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:939
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:955
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:970
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:923
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:923
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/utils/palloc.h:95
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:939
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/nodes/pg_list.h:87
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:955
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:955
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:984
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:984
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbe90 <ExecHashGetHashValue>:
         :	                                         ExprContext *econtext,
         :	                                         List *hashkeys,
         :	                                         bool outer_tuple,
         :	                                         bool keep_nulls,
         :	                                         uint32 *hashvalue)
         :	{
    0.00 :	  5bbe90:       55                      push   %rbp
    0.00 :	  5bbe91:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bbe94:       41 57                   push   %r15
    0.00 :	  5bbe96:       49 89 ff                mov    %rdi,%r15
    0.00 :	  5bbe99:       41 56                   push   %r14
    0.00 :	  5bbe9b:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5bbe9e:       41 55                   push   %r13
    0.00 :	  5bbea0:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:923
    5.00 :	  5bbea2:       49 89 d4                mov    %rdx,%r12
    0.00 :	  5bbea5:       53                      push   %rbx
    0.00 :	  5bbea6:       89 cb                   mov    %ecx,%ebx
    0.00 :	  5bbea8:       48 83 ec 38             sub    $0x38,%rsp
    0.00 :	  5bbeac:       4c 89 4d a8             mov    %r9,-0x58(%rbp)
    5.00 :	  5bbeb0:       44 88 45 b7             mov    %r8b,-0x49(%rbp)
         :
         :	        /*
         :	         * We reset the eval context each time to reclaim any memory leaked in the
         :	         * hashkey expressions.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5bbeb4:       48 8b 7e 28             mov    0x28(%rsi),%rdi
    0.00 :	  5bbeb8:       e8 f3 ca 1d 00          callq  7989b0 <MemoryContextReset>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5bbebd:       48 8b 05 9c e9 5f 00    mov    0x5fe99c(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        if (outer_tuple)
    0.00 :	  5bbec4:       84 db                   test   %bl,%bl
    0.00 :	  5bbec6:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :
         :	        CurrentMemoryContext = context;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/utils/palloc.h:95
    5.00 :	  5bbeca:       49 8b 46 28             mov    0x28(%r14),%rax
    0.00 :	  5bbece:       48 89 05 8b e9 5f 00    mov    %rax,0x5fe98b(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5bbed5:       0f 84 d5 00 00 00       je     5bbfb0 <ExecHashGetHashValue+0x120>
         :	                hashfunctions = hashtable->outer_hashfunctions;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:939
    5.00 :	  5bbedb:       49 8b 47 78             mov    0x78(%r15),%rax
   10.00 :	  5bbedf:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/../../../src/include/nodes/pg_list.h:87
    5.00 :	  5bbee3:       4d 85 e4                test   %r12,%r12
    0.00 :	  5bbee6:       0f 84 94 00 00 00       je     5bbf80 <ExecHashGetHashValue+0xf0>
    0.00 :	  5bbeec:       49 8b 5c 24 08          mov    0x8(%r12),%rbx
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
         :
         :	        foreach(hk, hashkeys)
    0.00 :	  5bbef1:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbef4:       0f 84 86 00 00 00       je     5bbf80 <ExecHashGetHashValue+0xf0>
    0.00 :	  5bbefa:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5bbefd:       45 31 e4                xor    %r12d,%r12d
         :	        {
         :	                ExprState  *keyexpr = (ExprState *) lfirst(hk);
    0.00 :	  5bbf00:       48 8b 03                mov    (%rbx),%rax
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
         :
         :	                /*
         :	                 * Get the join attribute value of the tuple
         :	                 */
         :	                keyval = ExecEvalExpr(keyexpr, econtext, &isNull, NULL);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:955
    5.00 :	  5bbf03:       31 c9                   xor    %ecx,%ecx
         :	                ExprState  *keyexpr = (ExprState *) lfirst(hk);
         :	                Datum           keyval;
         :	                bool            isNull;
         :
         :	                /* rotate hashkey left 1 bit at each step */
         :	                hashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);
    0.00 :	  5bbf05:       41 d1 c5                rol    %r13d
         :
         :	                /*
         :	                 * Get the join attribute value of the tuple
         :	                 */
         :	                keyval = ExecEvalExpr(keyexpr, econtext, &isNull, NULL);
    0.00 :	  5bbf08:       48 8d 55 d7             lea    -0x29(%rbp),%rdx
    0.00 :	  5bbf0c:       4c 89 f6                mov    %r14,%rsi
   10.00 :	  5bbf0f:       48 89 c7                mov    %rax,%rdi
    5.00 :	  5bbf12:       ff 50 10                callq  *0x10(%rax)
         :	                 *
         :	                 * Note: currently, all hashjoinable operators must be strict since
         :	                 * the hash index AM assumes that.  However, it takes so little extra
         :	                 * code here to allow non-strict that we may as well do it.
         :	                 */
         :	                if (isNull)
    0.00 :	  5bbf15:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:970
   10.00 :	  5bbf19:       74 35                   je     5bbf50 <ExecHashGetHashValue+0xc0>
         :	                {
         :	                        if (hashtable->hashStrict[i] && !keep_nulls)
    0.00 :	  5bbf1b:       49 8b 87 88 00 00 00    mov    0x88(%r15),%rax
    0.00 :	  5bbf22:       49 63 d4                movslq %r12d,%rdx
    0.00 :	  5bbf25:       80 3c 10 00             cmpb   $0x0,(%rax,%rdx,1)
    0.00 :	  5bbf29:       74 41                   je     5bbf6c <ExecHashGetHashValue+0xdc>
    0.00 :	  5bbf2b:       80 7d b7 00             cmpb   $0x0,-0x49(%rbp)
    0.00 :	  5bbf2f:       75 3b                   jne    5bbf6c <ExecHashGetHashValue+0xdc>
    0.00 :	  5bbf31:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bbf35:       48 89 05 24 e9 5f 00    mov    %rax,0x5fe924(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
         :	        return true;
         :	}
    0.00 :	  5bbf3c:       48 83 c4 38             add    $0x38,%rsp
    0.00 :	  5bbf40:       31 c0                   xor    %eax,%eax
    0.00 :	  5bbf42:       5b                      pop    %rbx
    0.00 :	  5bbf43:       41 5c                   pop    %r12
    0.00 :	  5bbf45:       41 5d                   pop    %r13
    0.00 :	  5bbf47:       41 5e                   pop    %r14
    0.00 :	  5bbf49:       41 5f                   pop    %r15
    0.00 :	  5bbf4b:       c9                      leaveq 
    0.00 :	  5bbf4c:       c3                      retq   
    0.00 :	  5bbf4d:       0f 1f 00                nopl   (%rax)
         :	                else
         :	                {
         :	                        /* Compute the hash function */
         :	                        uint32          hkey;
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i], keyval));
    0.00 :	  5bbf50:       49 63 fc                movslq %r12d,%rdi
    0.00 :	  5bbf53:       48 89 c2                mov    %rax,%rdx
    0.00 :	  5bbf56:       31 f6                   xor    %esi,%esi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:984
    5.00 :	  5bbf58:       48 8d 3c 7f             lea    (%rdi,%rdi,2),%rdi
    5.00 :	  5bbf5c:       48 c1 e7 04             shl    $0x4,%rdi
    0.00 :	  5bbf60:       48 03 7d b8             add    -0x48(%rbp),%rdi
    0.00 :	  5bbf64:       e8 67 21 1c 00          callq  77e0d0 <FunctionCall1Coll>
         :	                        hashkey ^= hkey;
    0.00 :	  5bbf69:       41 31 c5                xor    %eax,%r13d
         :	        if (outer_tuple)
         :	                hashfunctions = hashtable->outer_hashfunctions;
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
         :
         :	        foreach(hk, hashkeys)
    0.00 :	  5bbf6c:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5bbf70:       48 85 db                test   %rbx,%rbx
    0.00 :	  5bbf73:       74 13                   je     5bbf88 <ExecHashGetHashValue+0xf8>
         :
         :	                        hkey = DatumGetUInt32(FunctionCall1(&hashfunctions[i], keyval));
         :	                        hashkey ^= hkey;
         :	                }
         :
         :	                i++;
    0.00 :	  5bbf75:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  5bbf79:       eb 85                   jmp    5bbf00 <ExecHashGetHashValue+0x70>
    0.00 :	  5bbf7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbf80:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5bbf83:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbf88:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  5bbf8c:       48 89 05 cd e8 5f 00    mov    %rax,0x5fe8cd(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
    0.00 :	  5bbf93:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  5bbf97:       44 89 28                mov    %r13d,(%rax)
         :	        return true;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:995
   10.00 :	  5bbf9a:       48 83 c4 38             add    $0x38,%rsp
         :	                i++;
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        *hashvalue = hashkey;
    0.00 :	  5bbf9e:       b8 01 00 00 00          mov    $0x1,%eax
         :	        return true;
         :	}
    0.00 :	  5bbfa3:       5b                      pop    %rbx
   10.00 :	  5bbfa4:       41 5c                   pop    %r12
    0.00 :	  5bbfa6:       41 5d                   pop    %r13
    0.00 :	  5bbfa8:       41 5e                   pop    %r14
    0.00 :	  5bbfaa:       41 5f                   pop    %r15
    5.00 :	  5bbfac:       c9                      leaveq 
    0.00 :	  5bbfad:       c3                      retq   
    0.00 :	  5bbfae:       66 90                   xchg   %ax,%ax
         :	        oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        if (outer_tuple)
         :	                hashfunctions = hashtable->outer_hashfunctions;
         :	        else
         :	                hashfunctions = hashtable->inner_hashfunctions;
    0.00 :	  5bbfb0:       49 8b 87 80 00 00 00    mov    0x80(%r15),%rax
    0.00 :	  5bbfb7:       48 89 45 b8             mov    %rax,-0x48(%rbp)
    0.00 :	  5bbfbb:       e9 23 ff ff ff          jmpq   5bbee3 <ExecHashGetHashValue+0x53>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   60.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1578
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1578
    5.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1645
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068f3a0 <LWLockRelease>:
         :	/*
         :	 * LWLockRelease - release a previously acquired lock
         :	 */
         :	void
         :	LWLockRelease(LWLock *lock)
         :	{
    0.00 :	  68f3a0:       55                      push   %rbp
    0.00 :	  68f3a1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  68f3a4:       41 55                   push   %r13
    0.00 :	  68f3a6:       41 54                   push   %r12
    0.00 :	  68f3a8:       49 89 fc                mov    %rdi,%r12
    0.00 :	  68f3ab:       53                      push   %rbx
    0.00 :	  68f3ac:       48 83 ec 18             sub    $0x18,%rsp
         :
         :	        /*
         :	         * Remove lock from list of locks held.  Usually, but not always, it will
         :	         * be the latest-acquired lock; so search array backwards.
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
    0.00 :	  68f3b0:       8b 35 52 e6 4e 00       mov    0x4ee652(%rip),%esi        # b7da08 <num_held_lwlocks>
    0.00 :	  68f3b6:       89 f0                   mov    %esi,%eax
    0.00 :	  68f3b8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  68f3bf:       00 
    0.00 :	  68f3c0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  68f3c3:       0f 88 1f 02 00 00       js     68f5e8 <LWLockRelease+0x248>
         :	        {
         :	                if (lock == held_lwlocks[i].lock)
    0.00 :	  68f3c9:       48 63 d0                movslq %eax,%rdx
    0.00 :	  68f3cc:       41 b9 40 da b7 00       mov    $0xb7da40,%r9d
    0.00 :	  68f3d2:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  68f3d5:       48 c1 e1 04             shl    $0x4,%rcx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1578
    5.00 :	  68f3d9:       48 8b 99 40 da b7 00    mov    0xb7da40(%rcx),%rbx
   20.00 :	  68f3e0:       4c 39 e3                cmp    %r12,%rbx
    0.00 :	  68f3e3:       75 db                   jne    68f3c0 <LWLockRelease+0x20>
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
    0.00 :	  68f3e5:       44 8d 46 ff             lea    -0x1(%rsi),%r8d
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
         :	        {
         :	                if (lock == held_lwlocks[i].lock)
         :	                {
         :	                        mode = held_lwlocks[i].mode;
    0.00 :	  68f3e9:       44 8b 91 48 da b7 00    mov    0xb7da48(%rcx),%r10d
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f3f0:       41 39 c0                cmp    %eax,%r8d
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
    0.00 :	  68f3f3:       44 89 05 0e e6 4e 00    mov    %r8d,0x4ee60e(%rip)        # b7da08 <num_held_lwlocks>
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f3fa:       7f 09                   jg     68f405 <LWLockRelease+0x65>
    0.00 :	  68f3fc:       eb 3a                   jmp    68f438 <LWLockRelease+0x98>
    0.00 :	  68f3fe:       66 90                   xchg   %ax,%ax
         :
         :	        /*
         :	         * Remove lock from list of locks held.  Usually, but not always, it will
         :	         * be the latest-acquired lock; so search array backwards.
         :	         */
         :	        for (i = num_held_lwlocks; --i >= 0;)
    0.00 :	  68f400:       89 f0                   mov    %esi,%eax
    0.00 :	  68f402:       48 89 fa                mov    %rdi,%rdx
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
         :	                held_lwlocks[i] = held_lwlocks[i + 1];
    0.00 :	  68f405:       8d 70 01                lea    0x1(%rax),%esi
    0.00 :	  68f408:       48 89 d1                mov    %rdx,%rcx
    0.00 :	  68f40b:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	  68f40f:       48 63 fe                movslq %esi,%rdi
    0.00 :	  68f412:       48 89 fa                mov    %rdi,%rdx
    0.00 :	  68f415:       48 c1 e2 04             shl    $0x4,%rdx
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f419:       41 39 f0                cmp    %esi,%r8d
         :	                held_lwlocks[i] = held_lwlocks[i + 1];
    0.00 :	  68f41c:       48 8b 82 40 da b7 00    mov    0xb7da40(%rdx),%rax
    0.00 :	  68f423:       48 89 81 40 da b7 00    mov    %rax,0xb7da40(%rcx)
    0.00 :	  68f42a:       48 8b 82 48 da b7 00    mov    0xb7da48(%rdx),%rax
    0.00 :	  68f431:       49 89 44 09 08          mov    %rax,0x8(%r9,%rcx,1)
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
         :	        num_held_lwlocks--;
         :	        for (; i < num_held_lwlocks; i++)
    0.00 :	  68f436:       7f c8                   jg     68f400 <LWLockRelease+0x60>
         :
         :	        /*
         :	         * Release my hold on lock, after that it can immediately be acquired by
         :	         * others, even if we still have to wakeup other waiters.
         :	         */
         :	        if (mode == LW_EXCLUSIVE)
    0.00 :	  68f438:       45 85 d2                test   %r10d,%r10d
    0.00 :	  68f43b:       0f 84 77 01 00 00       je     68f5b8 <LWLockRelease+0x218>
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, EXCLUSIVE_LOCK);
         :	        else
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, 1);
    0.00 :	  68f441:       49 8d 54 24 04          lea    0x4(%r12),%rdx
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68f446:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68f44b:       f0 0f c1 02             lock xadd %eax,(%rdx)
         :	#if !defined(PG_HAVE_ATOMIC_SUB_FETCH_U32) && defined(PG_HAVE_ATOMIC_FETCH_SUB_U32)
         :	#define PG_HAVE_ATOMIC_SUB_FETCH_U32
         :	static inline uint32
         :	pg_atomic_sub_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
         :	{
         :	        return pg_atomic_fetch_sub_u32_impl(ptr, sub_) - sub_;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
   60.00 :	  68f44f:       8d 50 ff                lea    -0x1(%rax),%edx
         :	#ifndef PG_HAVE_ATOMIC_READ_U32
         :	#define PG_HAVE_ATOMIC_READ_U32
         :	static inline uint32
         :	pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
         :	{
         :	        return *(&ptr->value);
    0.00 :	  68f452:       8b 43 08                mov    0x8(%rbx),%eax
         :	        /*
         :	         * Anybody we need to wakeup needs to have started queueing before we
         :	         * removed ourselves from the queue and the atomic operations above are
         :	         * full barriers. So we can just do plain read.
         :	         */
         :	        if (pg_atomic_read_u32(&lock->nwaiters) > 0)
    0.00 :	  68f455:       85 c0                   test   %eax,%eax
    0.00 :	  68f457:       0f 84 3a 01 00 00       je     68f597 <LWLockRelease+0x1f7>
         :	        /*
         :	         * If we just released an exclusive lock always wakeup waiters, even if
         :	         * lockcount is still > 0. A shared acquisition temporarily (and
         :	         * spuriously) might have increased the value.
         :	         */
         :	        if (mode == LW_EXCLUSIVE && have_waiters)
    0.00 :	  68f45d:       45 85 d2                test   %r10d,%r10d
    0.00 :	  68f460:       0f 85 fc 01 00 00       jne    68f662 <LWLockRelease+0x2c2>
         :	 * Previous state will be thrown away without any cleanup.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_init(dlist_head *head)
         :	{
         :	        head->head.next = head->head.prev = &head->head;
    0.00 :	  68f466:       4c 8d 6d d0             lea    -0x30(%rbp),%r13
    0.00 :	  68f46a:       4c 89 6d d0             mov    %r13,-0x30(%rbp)
    0.00 :	  68f46e:       4c 89 6d d8             mov    %r13,-0x28(%rbp)
         :	        /*
         :	         * We're still waiting for backends to get scheduled, don't wake them up
         :	         * again.
         :	         */
         :	        pg_read_barrier(); /* pairs with nwaiters-- */
         :	        if (!BOOL_ACCESS_ONCE(lock->releaseOK))
    0.00 :	  68f472:       0f b6 43 01             movzbl 0x1(%rbx),%eax
    0.00 :	  68f476:       84 c0                   test   %al,%al
    0.00 :	  68f478:       0f 84 19 01 00 00       je     68f597 <LWLockRelease+0x1f7>
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  68f47e:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  68f483:       f0 86 03                lock xchg %al,(%rbx)
         :
         :	        /* Acquire mutex.  Time spent holding mutex should be short! */
         :	#ifdef LWLOCK_STATS
         :	        lwstats->spin_delay_count += SpinLockAcquire(&lock->mutex);
         :	#else
         :	        SpinLockAcquire(&lock->mutex);
    0.00 :	  68f486:       84 c0                   test   %al,%al
    0.00 :	  68f488:       0f 85 b2 01 00 00       jne    68f640 <LWLockRelease+0x2a0>
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f48e:       48 8b 53 18             mov    0x18(%rbx),%rdx
    0.00 :	  68f492:       48 85 d2                test   %rdx,%rdx
    0.00 :	  68f495:       0f 84 bc 01 00 00       je     68f657 <LWLockRelease+0x2b7>
    0.00 :	  68f49b:       4d 8d 4c 24 10          lea    0x10(%r12),%r9
    0.00 :	  68f4a0:       48 8b 72 08             mov    0x8(%rdx),%rsi
    0.00 :	  68f4a4:       49 39 d1                cmp    %rdx,%r9
    0.00 :	  68f4a7:       0f 84 aa 01 00 00       je     68f657 <LWLockRelease+0x2b7>
    0.00 :	  68f4ad:       31 ff                   xor    %edi,%edi
    0.00 :	  68f4af:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  68f4b5:       eb 23                   jmp    68f4da <LWLockRelease+0x13a>
    0.00 :	  68f4b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  68f4be:       00 00 
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4c0:       80 7a fa 00             cmpb   $0x0,-0x6(%rdx)
    0.00 :	  68f4c4:       75 1d                   jne    68f4e3 <LWLockRelease+0x143>
    0.00 :	  68f4c6:       bf 01 00 00 00          mov    $0x1,%edi
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f4cb:       49 39 f1                cmp    %rsi,%r9
    0.00 :	  68f4ce:       48 8b 46 08             mov    0x8(%rsi),%rax
    0.00 :	  68f4d2:       74 6a                   je     68f53e <LWLockRelease+0x19e>
    0.00 :	  68f4d4:       48 89 f2                mov    %rsi,%rdx
    0.00 :	  68f4d7:       48 89 c6                mov    %rax,%rsi
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4da:       40 84 ff                test   %dil,%dil
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
    0.00 :	  68f4dd:       48 8d 4a b8             lea    -0x48(%rdx),%rcx
         :
         :	                if (wokeup_somebody && waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f4e1:       75 dd                   jne    68f4c0 <LWLockRelease+0x120>
         :	 * Delete 'node' from its list (it must be in one).
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_delete(dlist_node *node)
         :	{
         :	        node->prev->next = node->next;
    0.00 :	  68f4e3:       48 8b 51 48             mov    0x48(%rcx),%rdx
    0.00 :	  68f4e7:       48 8b 41 50             mov    0x50(%rcx),%rax
    0.00 :	  68f4eb:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	        node->next->prev = node->prev;
    0.00 :	  68f4ef:       48 8b 51 50             mov    0x50(%rcx),%rdx
    0.00 :	  68f4f3:       48 8b 41 48             mov    0x48(%rcx),%rax
    0.00 :	  68f4f7:       48 89 02                mov    %rax,(%rdx)
         :	 * Insert a node at the end of the list.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_push_tail(dlist_head *head, dlist_node *node)
         :	{
         :	        if (head->head.next == NULL)    /* convert NULL header to circular */
    0.00 :	  68f4fa:       48 83 7d d8 00          cmpq   $0x0,-0x28(%rbp)
         :	                        continue;
         :
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                dlist_push_tail(&wakeup, &waiter->lwWaitLink);
    0.00 :	  68f4ff:       48 8d 51 48             lea    0x48(%rcx),%rdx
    0.00 :	  68f503:       0f 84 cf 00 00 00       je     68f5d8 <LWLockRelease+0x238>
         :	                dlist_init(head);
         :
         :	        node->next = &head->head;
    0.00 :	  68f509:       4c 89 69 50             mov    %r13,0x50(%rcx)
         :	        node->prev = head->head.prev;
    0.00 :	  68f50d:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  68f511:       48 89 41 48             mov    %rax,0x48(%rcx)
         :	        node->prev->next = node;
    0.00 :	  68f515:       48 89 50 08             mov    %rdx,0x8(%rax)
         :	        head->head.prev = node;
    0.00 :	  68f519:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
         :
         :	                if (waiter->lwWaitMode != LW_WAIT_UNTIL_FREE)
    0.00 :	  68f51d:       0f b6 41 42             movzbl 0x42(%rcx),%eax
    0.00 :	  68f521:       3c 02                   cmp    $0x2,%al
    0.00 :	  68f523:       74 a6                   je     68f4cb <LWLockRelease+0x12b>
         :
         :	                /*
         :	                 * Once we've woken up an exclusive lock, there's no point in waking
         :	                 * up anybody else.
         :	                 */
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f525:       84 c0                   test   %al,%al
    0.00 :	  68f527:       0f 84 0b 01 00 00       je     68f638 <LWLockRelease+0x298>
    0.00 :	  68f52d:       45 31 c0                xor    %r8d,%r8d
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f530:       49 39 f1                cmp    %rsi,%r9
         :
         :	                /*
         :	                 * Once we've woken up an exclusive lock, there's no point in waking
         :	                 * up anybody else.
         :	                 */
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
    0.00 :	  68f533:       bf 01 00 00 00          mov    $0x1,%edi
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f538:       48 8b 46 08             mov    0x8(%rsi),%rax
    0.00 :	  68f53c:       75 96                   jne    68f4d4 <LWLockRelease+0x134>
         :	                if(waiter->lwWaitMode == LW_EXCLUSIVE)
         :	                        break;
         :	        }
         :
         :	        /* The SpinLockRelease() below provides barrier semantics */
         :	        BOOL_ACCESS_ONCE(lock->releaseOK) = releaseOK;
    0.00 :	  68f53e:       44 88 43 01             mov    %r8b,0x1(%rbx)
         :	        SpinLockRelease(&lock->mutex);
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f542:       48 8b 4d d8             mov    -0x28(%rbp),%rcx
         :
         :	        /* The SpinLockRelease() below provides barrier semantics */
         :	        BOOL_ACCESS_ONCE(lock->releaseOK) = releaseOK;
         :
         :	        /* We are done updating shared state of the lock queue. */
         :	        SpinLockRelease(&lock->mutex);
    0.00 :	  68f546:       41 c6 04 24 00          movb   $0x0,(%r12)
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f54b:       48 85 c9                test   %rcx,%rcx
    0.00 :	  68f54e:       74 47                   je     68f597 <LWLockRelease+0x1f7>
    0.00 :	  68f550:       4c 39 e9                cmp    %r13,%rcx
    0.00 :	  68f553:       48 8b 59 08             mov    0x8(%rcx),%rbx
    0.00 :	  68f557:       75 0d                   jne    68f566 <LWLockRelease+0x1c6>
    0.00 :	  68f559:       eb 3c                   jmp    68f597 <LWLockRelease+0x1f7>
    0.00 :	  68f55b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  68f560:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  68f563:       48 89 c3                mov    %rax,%rbx
         :	        {
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
    0.00 :	  68f566:       48 8d 79 b8             lea    -0x48(%rcx),%rdi
         :	 * Delete 'node' from its list (it must be in one).
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_delete(dlist_node *node)
         :	{
         :	        node->prev->next = node->next;
    0.00 :	  68f56a:       48 8b 57 48             mov    0x48(%rdi),%rdx
    0.00 :	  68f56e:       48 8b 47 50             mov    0x50(%rdi),%rax
    0.00 :	  68f572:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	        node->next->prev = node->prev;
    0.00 :	  68f576:       48 8b 57 50             mov    0x50(%rdi),%rdx
    0.00 :	  68f57a:       48 8b 47 48             mov    0x48(%rdi),%rax
    0.00 :	  68f57e:       48 89 02                mov    %rax,(%rdx)
         :
         :	                LOG_LWDEBUG("LWLockRelease", lock, "release waiter");
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                pg_write_barrier();
         :	                waiter->lwWaiting = false;
         :	                PGSemaphoreUnlock(&waiter->sem);
    0.00 :	  68f581:       48 83 c7 10             add    $0x10,%rdi
         :	                PGPROC *waiter = dlist_container(PGPROC, lwWaitLink, iter.cur);
         :
         :	                LOG_LWDEBUG("LWLockRelease", lock, "release waiter");
         :	                dlist_delete(&waiter->lwWaitLink);
         :	                pg_write_barrier();
         :	                waiter->lwWaiting = false;
    0.00 :	  68f585:       c6 41 f9 00             movb   $0x0,-0x7(%rcx)
         :	                PGSemaphoreUnlock(&waiter->sem);
    0.00 :	  68f589:       e8 02 8b fa ff          callq  638090 <PGSemaphoreUnlock>
         :	        SpinLockRelease(&lock->mutex);
         :
         :	        /*
         :	         * Awaken any waiters I removed from the queue.
         :	         */
         :	        dlist_foreach_modify(iter, &wakeup)
    0.00 :	  68f58e:       4c 39 eb                cmp    %r13,%rbx
    0.00 :	  68f591:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  68f595:       75 c9                   jne    68f560 <LWLockRelease+0x1c0>
         :	        TRACE_POSTGRESQL_LWLOCK_RELEASE(T_NAME(lock), T_ID(lock));
         :
         :	        /*
         :	         * Now okay to allow cancel/die interrupts.
         :	         */
         :	        RESUME_INTERRUPTS();
    0.00 :	  68f597:       8b 05 fb aa 52 00       mov    0x52aafb(%rip),%eax        # bba098 <InterruptHoldoffCount>
    0.00 :	  68f59d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  68f5a0:       89 05 f2 aa 52 00       mov    %eax,0x52aaf2(%rip)        # bba098 <InterruptHoldoffCount>
         :	}
    0.00 :	  68f5a6:       48 83 c4 18             add    $0x18,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1645
    5.00 :	  68f5aa:       5b                      pop    %rbx
    0.00 :	  68f5ab:       41 5c                   pop    %r12
    0.00 :	  68f5ad:       41 5d                   pop    %r13
    0.00 :	  68f5af:       c9                      leaveq 
    0.00 :	  68f5b0:       c3                      retq   
    0.00 :	  68f5b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * Release my hold on lock, after that it can immediately be acquired by
         :	         * others, even if we still have to wakeup other waiters.
         :	         */
         :	        if (mode == LW_EXCLUSIVE)
         :	                lockcount = pg_atomic_sub_fetch_u32(&lock->lockcount, EXCLUSIVE_LOCK);
    0.00 :	  68f5b8:       49 8d 54 24 04          lea    0x4(%r12),%rdx
    0.00 :	  68f5bd:       b8 00 00 00 c0          mov    $0xc0000000,%eax
    0.00 :	  68f5c2:       f0 0f c1 02             lock xadd %eax,(%rdx)
         :	#if !defined(PG_HAVE_ATOMIC_SUB_FETCH_U32) && defined(PG_HAVE_ATOMIC_FETCH_SUB_U32)
         :	#define PG_HAVE_ATOMIC_SUB_FETCH_U32
         :	static inline uint32
         :	pg_atomic_sub_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
         :	{
         :	        return pg_atomic_fetch_sub_u32_impl(ptr, sub_) - sub_;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/../../../../src/include/port/atomics/generic.h:247
   10.00 :	  68f5c6:       8d 90 00 00 00 c0       lea    -0x40000000(%rax),%edx
    0.00 :	  68f5cc:       e9 81 fe ff ff          jmpq   68f452 <LWLockRelease+0xb2>
    0.00 :	  68f5d1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	 * Previous state will be thrown away without any cleanup.
         :	 */
         :	STATIC_IF_INLINE void
         :	dlist_init(dlist_head *head)
         :	{
         :	        head->head.next = head->head.prev = &head->head;
    0.00 :	  68f5d8:       4c 89 6d d0             mov    %r13,-0x30(%rbp)
    0.00 :	  68f5dc:       4c 89 6d d8             mov    %r13,-0x28(%rbp)
    0.00 :	  68f5e0:       e9 24 ff ff ff          jmpq   68f509 <LWLockRelease+0x169>
    0.00 :	  68f5e5:       0f 1f 00                nopl   (%rax)
         :	                        mode = held_lwlocks[i].mode;
         :	                        break;
         :	                }
         :	        }
         :	        if (i < 0)
         :	                elog(ERROR, "lock %s %d is not held", T_NAME(lock), T_ID(lock));
    0.00 :	  68f5e8:       ba 10 d1 8a 00          mov    $0x8ad110,%edx
    0.00 :	  68f5ed:       be 31 06 00 00          mov    $0x631,%esi
    0.00 :	  68f5f2:       bf 85 d0 8a 00          mov    $0x8ad085,%edi
    0.00 :	  68f5f7:       e8 24 be 0e 00          callq  77b420 <elog_start>
    0.00 :	  68f5fc:       49 63 54 24 0c          movslq 0xc(%r12),%rdx
    0.00 :	  68f601:       48 8b 05 08 e4 4e 00    mov    0x4ee408(%rip),%rax        # b7da10 <LWLockTrancheArray>
    0.00 :	  68f608:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  68f60d:       48 8b 34 d0             mov    (%rax,%rdx,8),%rsi
    0.00 :	  68f611:       31 d2                   xor    %edx,%edx
    0.00 :	  68f613:       4c 2b 66 08             sub    0x8(%rsi),%r12
    0.00 :	  68f617:       4c 89 e0                mov    %r12,%rax
    0.00 :	  68f61a:       48 f7 76 10             divq   0x10(%rsi)
    0.00 :	  68f61e:       48 8b 16                mov    (%rsi),%rdx
    0.00 :	  68f621:       be bf d0 8a 00          mov    $0x8ad0bf,%esi
    0.00 :	  68f626:       89 c1                   mov    %eax,%ecx
    0.00 :	  68f628:       31 c0                   xor    %eax,%eax
    0.00 :	  68f62a:       e8 01 bc 0e 00          callq  77b230 <elog_finish>
    0.00 :	  68f62f:       e8 9c 9e dd ff          callq  4694d0 <abort@plt>
    0.00 :	  68f634:       0f 1f 40 00             nopl   0x0(%rax)
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f638:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  68f63b:       e9 fe fe ff ff          jmpq   68f53e <LWLockRelease+0x19e>
         :
         :	        /* Acquire mutex.  Time spent holding mutex should be short! */
         :	#ifdef LWLOCK_STATS
         :	        lwstats->spin_delay_count += SpinLockAcquire(&lock->mutex);
         :	#else
         :	        SpinLockAcquire(&lock->mutex);
    0.00 :	  68f640:       ba e1 02 00 00          mov    $0x2e1,%edx
    0.00 :	  68f645:       be 85 d0 8a 00          mov    $0x8ad085,%esi
    0.00 :	  68f64a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  68f64d:       e8 ee 09 00 00          callq  690040 <s_lock>
    0.00 :	  68f652:       e9 37 fe ff ff          jmpq   68f48e <LWLockRelease+0xee>
         :	#endif
         :
         :	        /* remove the to-be-awakened PGPROCs from the queue */
         :	        releaseOK = true;
         :
         :	        dlist_foreach_modify(iter, &lock->waiters)
    0.00 :	  68f657:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  68f65d:       e9 dc fe ff ff          jmpq   68f53e <LWLockRelease+0x19e>
         :	        if (mode == LW_EXCLUSIVE && have_waiters)
         :	                check_waiters = true;
         :	        /*
         :	         * nobody has this locked anymore, potential exclusive lockers get a chance
         :	         */
         :	        else if (lockcount == 0 && have_waiters)
    0.00 :	  68f662:       85 d2                   test   %edx,%edx
    0.00 :	  68f664:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  68f668:       0f 84 f8 fd ff ff       je     68f466 <LWLockRelease+0xc6>
    0.00 :	  68f66e:       66 90                   xchg   %ax,%ax
    0.00 :	  68f670:       e9 22 ff ff ff          jmpq   68f597 <LWLockRelease+0x1f7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   21.05 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   15.79 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:147
   15.79 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
   10.53 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   10.53 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:151
   10.53 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:147
    5.26 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007989b0 <MemoryContextReset>:
         :	 * The type-specific reset routine handles the context itself, but we
         :	 * have to do the recursion for the children.
         :	 */
         :	void
         :	MemoryContextReset(MemoryContext context)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:143
   21.05 :	  7989b0:       55                      push   %rbp
    5.26 :	  7989b1:       48 89 e5                mov    %rsp,%rbp
   10.53 :	  7989b4:       53                      push   %rbx
    0.00 :	  7989b5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7989b8:       48 83 ec 08             sub    $0x8,%rsp
         :	        AssertArg(MemoryContextIsValid(context));
         :
         :	        /* save a function call in common case where there are no children */
         :	        if (context->firstchild != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:147
    5.26 :	  7989bc:       48 83 7f 18 00          cmpq   $0x0,0x18(%rdi)
   15.79 :	  7989c1:       74 05                   je     7989c8 <MemoryContextReset+0x18>
         :	                MemoryContextResetChildren(context);
    0.00 :	  7989c3:       e8 b8 ff ff ff          callq  798980 <MemoryContextResetChildren>
         :
         :	        /* Nothing to do if no pallocs since startup or last reset */
         :	        if (!context->isReset)
    0.00 :	  7989c8:       80 7b 30 00             cmpb   $0x0,0x30(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:151
   10.53 :	  7989cc:       75 0e                   jne    7989dc <MemoryContextReset+0x2c>
         :	        {
         :	                (*context->methods->reset) (context);
    0.00 :	  7989ce:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7989d2:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7989d5:       ff 50 20                callq  *0x20(%rax)
         :	                context->isReset = true;
    0.00 :	  7989d8:       c6 43 30 01             movb   $0x1,0x30(%rbx)
         :	                VALGRIND_DESTROY_MEMPOOL(context);
         :	                VALGRIND_CREATE_MEMPOOL(context, 0, false);
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:158
    5.26 :	  7989dc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  7989e0:       5b                      pop    %rbx
   26.32 :	  7989e1:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   44.44 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1284
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1292
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1305
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1315
    5.56 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1318
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674c30 <PinBuffer>:
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
    0.00 :	  674c30:       55                      push   %rbp
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c31:       ba 01 00 00 00          mov    $0x1,%edx
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
    0.00 :	  674c36:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674c39:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
   11.11 :	  674c3d:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  674c41:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  674c44:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  674c48:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  674c4c:       48 83 ec 20             sub    $0x20,%rsp
         :	        int                     b = buf->buf_id;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1284
   11.11 :	  674c50:       8b 7f 24                mov    0x24(%rdi),%edi
         :	 * Returns TRUE if buffer is BM_VALID, else FALSE.  This provision allows
         :	 * some callers to avoid an extra spinlock cycle.
         :	 */
         :	static bool
         :	PinBuffer(volatile BufferDesc *buf, BufferAccessStrategy strategy)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1283
   44.44 :	  674c53:       49 89 f6                mov    %rsi,%r14
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c56:       be 01 00 00 00          mov    $0x1,%esi
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674c5b:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	{
         :	        int                     b = buf->buf_id;
         :	        bool            result;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674c61:       83 c7 01                add    $0x1,%edi
    0.00 :	  674c64:       e8 b7 f8 ff ff          callq  674520 <GetPrivateRefCountEntry>
    0.00 :	  674c69:       49 89 c4                mov    %rax,%r12
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674c6c:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  674c6f:       85 c0                   test   %eax,%eax
    0.00 :	  674c71:       75 43                   jne    674cb6 <PinBuffer+0x86>
         :	        {
         :	                LockBufHdr(buf);
    0.00 :	  674c73:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  674c77:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  674c7c:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1292
   11.11 :	  674c7f:       84 c0                   test   %al,%al
    0.00 :	  674c81:       75 6d                   jne    674cf0 <PinBuffer+0xc0>
         :	                buf->refcount++;
    0.00 :	  674c83:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674c86:       83 c0 01                add    $0x1,%eax
         :	                if (strategy == NULL)
    0.00 :	  674c89:       4d 85 f6                test   %r14,%r14
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
         :	                buf->refcount++;
    0.00 :	  674c8c:       89 43 18                mov    %eax,0x18(%rbx)
         :	                if (strategy == NULL)
    0.00 :	  674c8f:       74 7c                   je     674d0d <PinBuffer+0xdd>
         :	                        if (buf->usage_count < BM_MAX_USAGE_COUNT)
         :	                                buf->usage_count++;
         :	                }
         :	                else
         :	                {
         :	                        if (buf->usage_count == 0)
    0.00 :	  674c91:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674c95:       66 85 c0                test   %ax,%ax
    0.00 :	  674c98:       75 06                   jne    674ca0 <PinBuffer+0x70>
         :	                                buf->usage_count = 1;
    0.00 :	  674c9a:       66 c7 43 16 01 00       movw   $0x1,0x16(%rbx)
         :	                }
         :	                result = (buf->flags & BM_VALID) != 0;
    0.00 :	  674ca0:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674ca4:       d1 e8                   shr    %eax
    0.00 :	  674ca6:       41 89 c5                mov    %eax,%r13d
    0.00 :	  674ca9:       41 83 e5 01             and    $0x1,%r13d
         :	                UnlockBufHdr(buf);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1305
   11.11 :	  674cad:       c6 43 20 00             movb   $0x0,0x20(%rbx)
    0.00 :	  674cb1:       41 8b 44 24 04          mov    0x4(%r12),%eax
         :	        {
         :	                /* If we previously pinned the buffer, it must surely be valid */
         :	                result = true;
         :	        }
         :
         :	        ref->refcount++;
    0.00 :	  674cb6:       83 c0 01                add    $0x1,%eax
    0.00 :	  674cb9:       41 89 44 24 04          mov    %eax,0x4(%r12)
         :	        Assert(ref->refcount > 0);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner,
    0.00 :	  674cbe:       8b 73 24                mov    0x24(%rbx),%esi
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1315
    5.56 :	  674cc1:       48 8b 3d f8 5b 54 00    mov    0x545bf8(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674cc8:       83 c6 01                add    $0x1,%esi
    0.00 :	  674ccb:       e8 d0 54 12 00          callq  79a1a0 <ResourceOwnerRememberBuffer>
         :	                                                                BufferDescriptorGetBuffer(buf));
         :	        return result;
         :	}
    0.00 :	  674cd0:       44 89 e8                mov    %r13d,%eax
    0.00 :	  674cd3:       48 8b 1c 24             mov    (%rsp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1318
    5.56 :	  674cd7:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674cdc:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  674ce1:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  674ce6:       c9                      leaveq 
    0.00 :	  674ce7:       c3                      retq   
    0.00 :	  674ce8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  674cef:       00 
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
    0.00 :	  674cf0:       ba 0c 05 00 00          mov    $0x50c,%edx
    0.00 :	  674cf5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  674cfa:       e8 41 b3 01 00          callq  690040 <s_lock>
         :	                buf->refcount++;
    0.00 :	  674cff:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674d02:       83 c0 01                add    $0x1,%eax
         :	                if (strategy == NULL)
    0.00 :	  674d05:       4d 85 f6                test   %r14,%r14
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
         :
         :	        if (ref->refcount == 0)
         :	        {
         :	                LockBufHdr(buf);
         :	                buf->refcount++;
    0.00 :	  674d08:       89 43 18                mov    %eax,0x18(%rbx)
         :	                if (strategy == NULL)
    0.00 :	  674d0b:       75 84                   jne    674c91 <PinBuffer+0x61>
         :	                {
         :	                        if (buf->usage_count < BM_MAX_USAGE_COUNT)
    0.00 :	  674d0d:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674d11:       66 83 f8 04             cmp    $0x4,%ax
    0.00 :	  674d15:       77 89                   ja     674ca0 <PinBuffer+0x70>
         :	                                buf->usage_count++;
    0.00 :	  674d17:       0f b7 43 16             movzwl 0x16(%rbx),%eax
    0.00 :	  674d1b:       83 c0 01                add    $0x1,%eax
    0.00 :	  674d1e:       66 89 43 16             mov    %ax,0x16(%rbx)
    0.00 :	  674d22:       e9 79 ff ff ff          jmpq   674ca0 <PinBuffer+0x70>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   13.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:164
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:164
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:164
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:160
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:183
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
    6.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:198
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674520 <GetPrivateRefCountEntry>:
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  674520:       55                      push   %rbp
    0.00 :	  674521:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
    6.67 :	  674524:       41 57                   push   %r15
    0.00 :	  674526:       41 89 f7                mov    %esi,%r15d
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  674529:       89 fe                   mov    %edi,%esi
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  67452b:       41 56                   push   %r14
   13.33 :	  67452d:       41 55                   push   %r13
    0.00 :	  67452f:       41 54                   push   %r12
    0.00 :	  674531:       41 89 d4                mov    %edx,%r12d
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:164
    6.67 :	  674534:       ba c0 d0 b7 00          mov    $0xb7d0c0,%edx
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  674539:       53                      push   %rbx
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
    0.00 :	  67453a:       31 db                   xor    %ebx,%ebx
         :	 *
         :	 * Only works for shared buffers.
         :	 */
         :	static PrivateRefCountEntry*
         :	GetPrivateRefCountEntry(Buffer buffer, bool create, bool do_move)
         :	{
    0.00 :	  67453c:       48 83 ec 18             sub    $0x18,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:146
    6.67 :	  674540:       89 7d c4                mov    %edi,-0x3c(%rbp)
         :	        PrivateRefCountEntry *res;
         :	        PrivateRefCountEntry *free = NULL;
         :	        bool            found = false;
    0.00 :	  674543:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
    0.00 :	  674547:       eb 14                   jmp    67455d <GetPrivateRefCountEntry+0x3d>
    0.00 :	  674549:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                if (res->buffer == buffer)
         :	                        return res;
         :
         :	                /* Remember where to put a new refcount, should it become necessary. */
         :	                if (free == NULL && res->buffer == InvalidBuffer)
    0.00 :	  674550:       48 83 c2 08             add    $0x8,%rdx
         :
         :	        /*
         :	         * First search for references in the array, that'll be sufficient in the
         :	         * majority of cases.
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
    0.00 :	  674554:       48 81 fa 00 d1 b7 00    cmp    $0xb7d100,%rdx
    0.00 :	  67455b:       74 2b                   je     674588 <GetPrivateRefCountEntry+0x68>
         :	        {
         :	                res = &PrivateRefCountArray[i];
         :
         :	                if (res->buffer == buffer)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:164
    6.67 :	  67455d:       8b 0a                   mov    (%rdx),%ecx
    6.67 :	  67455f:       48 89 d0                mov    %rdx,%rax
    0.00 :	  674562:       39 f1                   cmp    %esi,%ecx
    0.00 :	  674564:       0f 84 c8 00 00 00       je     674632 <GetPrivateRefCountEntry+0x112>
         :	                        return res;
         :
         :	                /* Remember where to put a new refcount, should it become necessary. */
         :	                if (free == NULL && res->buffer == InvalidBuffer)
    0.00 :	  67456a:       48 85 db                test   %rbx,%rbx
    0.00 :	  67456d:       75 e1                   jne    674550 <GetPrivateRefCountEntry+0x30>
    0.00 :	  67456f:       85 c9                   test   %ecx,%ecx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:168
    6.67 :	  674571:       48 0f 44 da             cmove  %rdx,%rbx
    6.67 :	  674575:       48 83 c2 08             add    $0x8,%rdx
         :
         :	        /*
         :	         * First search for references in the array, that'll be sufficient in the
         :	         * majority of cases.
         :	         */
         :	        for (i = 0; i < REFCOUNT_ARRAY_ENTRIES; i++)
    0.00 :	  674579:       48 81 fa 00 d1 b7 00    cmp    $0xb7d100,%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:160
    6.67 :	  674580:       75 db                   jne    67455d <GetPrivateRefCountEntry+0x3d>
    0.00 :	  674582:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:183
    6.67 :	  674588:       8b 05 e2 8a 50 00       mov    0x508ae2(%rip),%eax        # b7d070 <PrivateRefCountOverflowed>
         :	        /*
         :	         * By here we know that the buffer, if already pinned, isn't residing in
         :	         * the array.
         :	         */
         :	        res = NULL;
         :	        found = false;
    0.00 :	  67458e:       c6 45 d7 00             movb   $0x0,-0x29(%rbp)
         :
         :	        /*
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
    0.00 :	  674592:       85 c0                   test   %eax,%eax
    0.00 :	  674594:       0f 8e ee 00 00 00       jle    674688 <GetPrivateRefCountEntry+0x168>
         :	        {
         :	                res = hash_search(PrivateRefCountHash,
    0.00 :	  67459a:       4c 8d 75 d7             lea    -0x29(%rbp),%r14
    0.00 :	  67459e:       48 8b 3d d3 8a 50 00    mov    0x508ad3(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6745a5:       48 8d 75 c4             lea    -0x3c(%rbp),%rsi
    0.00 :	  6745a9:       31 d2                   xor    %edx,%edx
    0.00 :	  6745ab:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  6745ae:       e8 ed 00 11 00          callq  7846a0 <hash_search>
         :	                                                  (void *) &buffer,
         :	                                                  HASH_FIND,
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
    0.00 :	  6745b3:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
         :	         * Look up the buffer in the hashtable if we've previously overflowed into
         :	         * it.
         :	         */
         :	        if (PrivateRefCountOverflowed > 0)
         :	        {
         :	                res = hash_search(PrivateRefCountHash,
    0.00 :	  6745b7:       49 89 c5                mov    %rax,%r13
         :	                                                  (void *) &buffer,
         :	                                                  HASH_FIND,
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
    0.00 :	  6745ba:       0f 84 c8 00 00 00       je     674688 <GetPrivateRefCountEntry+0x168>
         :
         :	                }
         :	        }
         :	        else
         :	        {
         :	                if (!do_move)
    0.00 :	  6745c0:       45 84 e4                test   %r12b,%r12b
    0.00 :	  6745c3:       74 6d                   je     674632 <GetPrivateRefCountEntry+0x112>
         :	                {
         :	                        return res;
         :	                }
         :	                else if (found && free != NULL)
    0.00 :	  6745c5:       48 85 db                test   %rbx,%rbx
    0.00 :	  6745c8:       75 7e                   jne    674648 <GetPrivateRefCountEntry+0x128>
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6745ca:       8b 05 b0 8a 50 00       mov    0x508ab0(%rip),%eax        # b7d080 <PrivateRefCountClock>
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim entry into the hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6745d0:       48 8b 3d a1 8a 50 00    mov    0x508aa1(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6745d7:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  6745da:       ba 01 00 00 00          mov    $0x1,%edx
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6745df:       49 89 c4                mov    %rax,%r12
    0.00 :	  6745e2:       83 c0 01                add    $0x1,%eax
    0.00 :	  6745e5:       41 83 e4 07             and    $0x7,%r12d
    0.00 :	  6745e9:       89 05 91 8a 50 00       mov    %eax,0x508a91(%rip)        # b7d080 <PrivateRefCountClock>
    0.00 :	  6745ef:       4a 8d 1c e5 c0 d0 b7    lea    0xb7d0c0(,%r12,8),%rbx
    0.00 :	  6745f6:       00 
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim entry into the hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6745f7:       48 89 de                mov    %rbx,%rsi
    0.00 :	  6745fa:       e8 a1 00 11 00          callq  7846a0 <hash_search>
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  6745ff:       8b 53 04                mov    0x4(%rbx),%edx
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
         :	                        arrayent->refcount = res->refcount;
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674602:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  674605:       48 89 de                mov    %rbx,%rsi
         :	                        hashent = hash_search(PrivateRefCountHash,
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  674608:       89 50 04                mov    %edx,0x4(%rax)
         :
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
    0.00 :	  67460b:       41 8b 45 00             mov    0x0(%r13),%eax
         :	                        arrayent->refcount = res->refcount;
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  67460f:       ba 02 00 00 00          mov    $0x2,%edx
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
         :
         :	                        /* fill now free array entry with previously searched entry */
         :	                        arrayent->buffer = res->buffer;
    0.00 :	  674614:       42 89 04 e5 c0 d0 b7    mov    %eax,0xb7d0c0(,%r12,8)
    0.00 :	  67461b:       00 
         :	                        arrayent->refcount = res->refcount;
    0.00 :	  67461c:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  674620:       89 43 04                mov    %eax,0x4(%rbx)
         :
         :	                        /* and remove the old entry */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674623:       48 8b 3d 4e 8a 50 00    mov    0x508a4e(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  67462a:       e8 71 00 11 00          callq  7846a0 <hash_search>
    0.00 :	  67462f:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:304
    6.67 :	  674632:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  674636:       5b                      pop    %rbx
    6.67 :	  674637:       41 5c                   pop    %r12
    0.00 :	  674639:       41 5d                   pop    %r13
    6.67 :	  67463b:       41 5e                   pop    %r14
    0.00 :	  67463d:       41 5f                   pop    %r15
    0.00 :	  67463f:       c9                      leaveq 
    0.00 :	  674640:       c3                      retq   
    0.00 :	  674641:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                else if (found && free != NULL)
         :	                {
         :	                        /* move buffer from hashtable into the free array slot */
         :
         :	                        /* fill array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674648:       8b 45 c4                mov    -0x3c(%rbp),%eax
         :	                        free->refcount = res->refcount;
         :
         :	                        /* delete from hashtable */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  67464b:       48 8d 75 c4             lea    -0x3c(%rbp),%rsi
    0.00 :	  67464f:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  674652:       ba 02 00 00 00          mov    $0x2,%edx
         :	                else if (found && free != NULL)
         :	                {
         :	                        /* move buffer from hashtable into the free array slot */
         :
         :	                        /* fill array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674657:       89 03                   mov    %eax,(%rbx)
         :	                        free->refcount = res->refcount;
    0.00 :	  674659:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  67465d:       89 43 04                mov    %eax,0x4(%rbx)
         :
         :	                        /* delete from hashtable */
         :	                        hash_search(PrivateRefCountHash,
    0.00 :	  674660:       48 8b 3d 11 8a 50 00    mov    0x508a11(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  674667:       e8 34 00 11 00          callq  7846a0 <hash_search>
         :	                                                (void *) &buffer,
         :	                                                HASH_REMOVE,
         :	                                                &found);
         :	                        Assert(found);
         :	                        Assert(PrivateRefCountOverflowed > 0);
         :	                        PrivateRefCountOverflowed--;
    0.00 :	  67466c:       83 2d fd 89 50 00 01    subl   $0x1,0x5089fd(%rip)        # b7d070 <PrivateRefCountOverflowed>
    0.00 :	  674673:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  674676:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  67467a:       5b                      pop    %rbx
    0.00 :	  67467b:       41 5c                   pop    %r12
    0.00 :	  67467d:       41 5d                   pop    %r13
    0.00 :	  67467f:       41 5e                   pop    %r14
    0.00 :	  674681:       41 5f                   pop    %r15
    0.00 :	  674683:       c9                      leaveq 
    0.00 :	  674684:       c3                      retq   
    0.00 :	  674685:       0f 1f 00                nopl   (%rax)
         :	                                                  &found);
         :	        }
         :
         :	        if (!found)
         :	        {
         :	                if (!create)
    0.00 :	  674688:       31 c0                   xor    %eax,%eax
    0.00 :	  67468a:       45 84 ff                test   %r15b,%r15b
    0.00 :	  67468d:       74 a3                   je     674632 <GetPrivateRefCountEntry+0x112>
         :	                {
         :	                        /* Neither array nor hash have an entry and no new entry is needed */
         :	                        return NULL;
         :	                }
         :	                else if (free != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:198
    6.67 :	  67468f:       48 85 db                test   %rbx,%rbx
    0.00 :	  674692:       74 11                   je     6746a5 <GetPrivateRefCountEntry+0x185>
         :	                {
         :	                        /* add entry into the free array slot */
         :	                        free->buffer = buffer;
    0.00 :	  674694:       8b 45 c4                mov    -0x3c(%rbp),%eax
         :	                        free->refcount = 0;
    0.00 :	  674697:       c7 43 04 00 00 00 00    movl   $0x0,0x4(%rbx)
         :	                        return NULL;
         :	                }
         :	                else if (free != NULL)
         :	                {
         :	                        /* add entry into the free array slot */
         :	                        free->buffer = buffer;
    0.00 :	  67469e:       89 03                   mov    %eax,(%rbx)
         :	                        free->refcount = 0;
    0.00 :	  6746a0:       48 89 d8                mov    %rbx,%rax
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  6746a3:       eb 8d                   jmp    674632 <GetPrivateRefCountEntry+0x112>
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6746a5:       8b 05 d5 89 50 00       mov    0x5089d5(%rip),%eax        # b7d080 <PrivateRefCountClock>
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim array entry into hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6746ab:       48 8b 3d c6 89 50 00    mov    0x5089c6(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  6746b2:       48 8d 4d d7             lea    -0x29(%rbp),%rcx
    0.00 :	  6746b6:       ba 01 00 00 00          mov    $0x1,%edx
         :	                         */
         :	                        PrivateRefCountEntry *arrayent;
         :	                        PrivateRefCountEntry *hashent;
         :
         :	                        /* select victim slot */
         :	                        arrayent = &PrivateRefCountArray[
    0.00 :	  6746bb:       49 89 c4                mov    %rax,%r12
    0.00 :	  6746be:       83 c0 01                add    $0x1,%eax
    0.00 :	  6746c1:       41 83 e4 07             and    $0x7,%r12d
    0.00 :	  6746c5:       89 05 b5 89 50 00       mov    %eax,0x5089b5(%rip)        # b7d080 <PrivateRefCountClock>
    0.00 :	  6746cb:       4a 8d 1c e5 c0 d0 b7    lea    0xb7d0c0(,%r12,8),%rbx
    0.00 :	  6746d2:       00 
         :	                                PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];
         :	                        Assert(arrayent->buffer != InvalidBuffer);
         :
         :	                        /* enter victim array entry into hashtable */
         :	                        hashent = hash_search(PrivateRefCountHash,
    0.00 :	  6746d3:       48 89 de                mov    %rbx,%rsi
    0.00 :	  6746d6:       e8 c5 ff 10 00          callq  7846a0 <hash_search>
         :	                                                                  (void *) &arrayent->buffer,
         :	                                                                  HASH_ENTER,
         :	                                                                  &found);
         :	                        Assert(!found);
         :	                        hashent->refcount = arrayent->refcount;
    0.00 :	  6746db:       8b 53 04                mov    0x4(%rbx),%edx
    0.00 :	  6746de:       89 50 04                mov    %edx,0x4(%rax)
         :
         :	                        /* fill the now free array slot */
         :	                        arrayent->buffer = buffer;
    0.00 :	  6746e1:       8b 45 c4                mov    -0x3c(%rbp),%eax
    0.00 :	  6746e4:       42 89 04 e5 c0 d0 b7    mov    %eax,0xb7d0c0(,%r12,8)
    0.00 :	  6746eb:       00 
         :	                        arrayent->refcount = 0;
    0.00 :	  6746ec:       c7 43 04 00 00 00 00    movl   $0x0,0x4(%rbx)
         :
         :	                        PrivateRefCountOverflowed++;
    0.00 :	  6746f3:       48 89 d8                mov    %rbx,%rax
    0.00 :	  6746f6:       83 05 73 89 50 00 01    addl   $0x1,0x508973(%rip)        # b7d070 <PrivateRefCountOverflowed>
         :	                }
         :	        }
         :
         :	        Assert(false); /* unreachable */
         :	        return NULL;
         :	}
    0.00 :	  6746fd:       e9 30 ff ff ff          jmpq   674632 <GetPrivateRefCountEntry+0x112>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:306
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:306
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:323
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:496
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:496
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:389
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000490350 <hash_any>:
         :	 * by using the final values of both b and c.  b is perhaps a little less
         :	 * well mixed than c, however.
         :	 */
         :	Datum
         :	hash_any(register const unsigned char *k, register int keylen)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:306
    7.14 :	  490350:       55                      push   %rbp
    0.00 :	  490351:       41 89 f2                mov    %esi,%r10d
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
         :
         :	        /* If the source pointer is word-aligned, we use word-wide fetches */
         :	        if (((uintptr_t) k & UINT32_ALIGN_MASK) == 0)
    0.00 :	  490354:       40 f6 c7 03             test   $0x3,%dil
         :	                                c,
         :	                                len;
         :
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
    0.00 :	  490358:       45 8d 82 50 56 73 9e    lea    -0x618ca9b0(%r10),%r8d
         :	 * by using the final values of both b and c.  b is perhaps a little less
         :	 * well mixed than c, however.
         :	 */
         :	Datum
         :	hash_any(register const unsigned char *k, register int keylen)
         :	{
    0.00 :	  49035f:       48 89 e5                mov    %rsp,%rbp
    7.14 :	  490362:       53                      push   %rbx
         :	        /* Set up the internal state */
         :	        len = keylen;
         :	        a = b = c = 0x9e3779b9 + len + 3923095;
         :
         :	        /* If the source pointer is word-aligned, we use word-wide fetches */
         :	        if (((uintptr_t) k & UINT32_ALIGN_MASK) == 0)
    0.00 :	  490363:       0f 84 f7 00 00 00       je     490460 <hash_any+0x110>
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490369:       83 fe 0b                cmp    $0xb,%esi
         :	                                /* fall through */
         :	                        case 2:
         :	                                a += ((uint32) k[1] << 8);
         :	                                /* fall through */
         :	                        case 1:
         :	                                a += k[0];
    0.00 :	  49036c:       45 89 c1                mov    %r8d,%r9d
    0.00 :	  49036f:       44 89 c2                mov    %r8d,%edx
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490372:       0f 86 7e 02 00 00       jbe    4905f6 <hash_any+0x2a6>
    0.00 :	  490378:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49037f:       00 
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  490380:       0f b6 4f 05             movzbl 0x5(%rdi),%ecx
    0.00 :	  490384:       0f b6 47 06             movzbl 0x6(%rdi),%eax
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  490388:       0f b6 77 09             movzbl 0x9(%rdi),%esi
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  49038c:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49038f:       c1 e1 08                shl    $0x8,%ecx
    0.00 :	  490392:       01 c1                   add    %eax,%ecx
    0.00 :	  490394:       0f b6 47 04             movzbl 0x4(%rdi),%eax
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  490398:       c1 e6 08                shl    $0x8,%esi
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  49039b:       01 c1                   add    %eax,%ecx
    0.00 :	  49039d:       0f b6 47 07             movzbl 0x7(%rdi),%eax
    0.00 :	  4903a1:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903a4:       01 c1                   add    %eax,%ecx
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903a6:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
    0.00 :	  4903aa:       01 d1                   add    %edx,%ecx
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903ac:       0f b6 57 01             movzbl 0x1(%rdi),%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903b0:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4903b3:       01 c6                   add    %eax,%esi
    0.00 :	  4903b5:       0f b6 47 08             movzbl 0x8(%rdi),%eax
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903b9:       c1 e2 08                shl    $0x8,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903bc:       01 c6                   add    %eax,%esi
    0.00 :	  4903be:       0f b6 47 0b             movzbl 0xb(%rdi),%eax
    0.00 :	  4903c2:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903c5:       01 c6                   add    %eax,%esi
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903c7:       0f b6 47 02             movzbl 0x2(%rdi),%eax
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
    0.00 :	  4903cb:       44 01 c6                add    %r8d,%esi
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903ce:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4903d1:       01 c2                   add    %eax,%edx
    0.00 :	  4903d3:       0f b6 07                movzbl (%rdi),%eax
    0.00 :	  4903d6:       01 c2                   add    %eax,%edx
    0.00 :	  4903d8:       0f b6 47 03             movzbl 0x3(%rdi),%eax
    0.00 :	  4903dc:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4903df:       01 c2                   add    %eax,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  4903e1:       89 f0                   mov    %esi,%eax
         :	#ifdef WORDS_BIGENDIAN
         :	                        a += (k[3] + ((uint32) k[2] << 8) + ((uint32) k[1] << 16) + ((uint32) k[0] << 24));
         :	                        b += (k[7] + ((uint32) k[6] << 8) + ((uint32) k[5] << 16) + ((uint32) k[4] << 24));
         :	                        c += (k[11] + ((uint32) k[10] << 8) + ((uint32) k[9] << 16) + ((uint32) k[8] << 24));
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
    0.00 :	  4903e3:       44 01 ca                add    %r9d,%edx
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  4903e6:       c1 c8 1c                ror    $0x1c,%eax
    0.00 :	  4903e9:       29 f2                   sub    %esi,%edx
    0.00 :	  4903eb:       01 ce                   add    %ecx,%esi
    0.00 :	  4903ed:       31 c2                   xor    %eax,%edx
    0.00 :	  4903ef:       89 d0                   mov    %edx,%eax
    0.00 :	  4903f1:       29 d1                   sub    %edx,%ecx
    0.00 :	  4903f3:       01 f2                   add    %esi,%edx
    0.00 :	  4903f5:       c1 c8 1a                ror    $0x1a,%eax
    0.00 :	  4903f8:       31 c8                   xor    %ecx,%eax
    0.00 :	  4903fa:       89 c1                   mov    %eax,%ecx
    0.00 :	  4903fc:       29 c6                   sub    %eax,%esi
    0.00 :	  4903fe:       01 d0                   add    %edx,%eax
    0.00 :	  490400:       c1 c9 18                ror    $0x18,%ecx
    0.00 :	  490403:       31 f1                   xor    %esi,%ecx
    0.00 :	  490405:       89 ce                   mov    %ecx,%esi
    0.00 :	  490407:       29 ca                   sub    %ecx,%edx
    0.00 :	  490409:       01 c1                   add    %eax,%ecx
    0.00 :	  49040b:       c1 ce 10                ror    $0x10,%esi
         :	                        k += 12;
         :	                        len -= 12;
    0.00 :	  49040e:       41 83 ea 0c             sub    $0xc,%r10d
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
         :	                        k += 12;
    0.00 :	  490412:       48 83 c7 0c             add    $0xc,%rdi
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                        a += (k[0] + ((uint32) k[1] << 8) + ((uint32) k[2] << 16) + ((uint32) k[3] << 24));
         :	                        b += (k[4] + ((uint32) k[5] << 8) + ((uint32) k[6] << 16) + ((uint32) k[7] << 24));
         :	                        c += (k[8] + ((uint32) k[9] << 8) + ((uint32) k[10] << 16) + ((uint32) k[11] << 24));
         :	#endif   /* WORDS_BIGENDIAN */
         :	                        mix(a, b, c);
    0.00 :	  490416:       31 d6                   xor    %edx,%esi
    0.00 :	  490418:       89 f2                   mov    %esi,%edx
    0.00 :	  49041a:       29 f0                   sub    %esi,%eax
    0.00 :	  49041c:       44 8d 0c 0e             lea    (%rsi,%rcx,1),%r9d
    0.00 :	  490420:       c1 ca 0d                ror    $0xd,%edx
    0.00 :	  490423:       31 c2                   xor    %eax,%edx
    0.00 :	  490425:       41 89 d0                mov    %edx,%r8d
    0.00 :	  490428:       29 d1                   sub    %edx,%ecx
    0.00 :	  49042a:       44 01 ca                add    %r9d,%edx
    0.00 :	  49042d:       41 c1 c8 1c             ror    $0x1c,%r8d
    0.00 :	  490431:       41 31 c8                xor    %ecx,%r8d
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490434:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  490438:       0f 87 42 ff ff ff       ja     490380 <hash_any+0x30>
    0.00 :	  49043e:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  490441:       89 d6                   mov    %edx,%esi
    0.00 :	  490443:       44 89 c3                mov    %r8d,%ebx
         :	                        case 1:
         :	                                a += ((uint32) k[0] << 24);
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)                    /* all the case statements fall through */
    0.00 :	  490446:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  49044a:       0f 87 01 01 00 00       ja     490551 <hash_any+0x201>
    0.00 :	  490450:       44 89 d0                mov    %r10d,%eax
    0.00 :	  490453:       ff 24 c5 18 22 7b 00    jmpq   *0x7b2218(,%rax,8)
    0.00 :	  49045a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  490460:       83 fe 0b                cmp    $0xb,%esi
    0.00 :	  490463:       45 89 c1                mov    %r8d,%r9d
    0.00 :	  490466:       44 89 c1                mov    %r8d,%ecx
    0.00 :	  490469:       0f 86 79 01 00 00       jbe    4905e8 <hash_any+0x298>
    0.00 :	  49046f:       90                      nop
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
    0.00 :	  490470:       44 89 c6                mov    %r8d,%esi
    0.00 :	  490473:       03 77 08                add    0x8(%rdi),%esi
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
         :	                {
         :	                        a += ka[0];
    0.00 :	  490476:       44 89 c8                mov    %r9d,%eax
    0.00 :	  490479:       03 07                   add    (%rdi),%eax
         :	                        b += ka[1];
    0.00 :	  49047b:       03 4f 04                add    0x4(%rdi),%ecx
         :	                        c += ka[2];
         :	                        mix(a, b, c);
         :	                        ka += 3;
         :	                        len -= 12;
    0.00 :	  49047e:       41 83 ea 0c             sub    $0xc,%r10d
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
         :	                        ka += 3;
    0.00 :	  490482:       48 83 c7 0c             add    $0xc,%rdi
         :	                while (len >= 12)
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
    0.00 :	  490486:       89 f2                   mov    %esi,%edx
    0.00 :	  490488:       29 f0                   sub    %esi,%eax
    0.00 :	  49048a:       c1 ca 1c                ror    $0x1c,%edx
    0.00 :	  49048d:       01 ce                   add    %ecx,%esi
    0.00 :	  49048f:       31 d0                   xor    %edx,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:328
    7.14 :	  490491:       89 c2                   mov    %eax,%edx
    0.00 :	  490493:       29 c1                   sub    %eax,%ecx
    0.00 :	  490495:       01 f0                   add    %esi,%eax
    0.00 :	  490497:       c1 ca 1a                ror    $0x1a,%edx
    0.00 :	  49049a:       31 ca                   xor    %ecx,%edx
    0.00 :	  49049c:       89 d1                   mov    %edx,%ecx
   14.29 :	  49049e:       29 d6                   sub    %edx,%esi
    0.00 :	  4904a0:       01 c2                   add    %eax,%edx
    7.14 :	  4904a2:       c1 c9 18                ror    $0x18,%ecx
    0.00 :	  4904a5:       31 f1                   xor    %esi,%ecx
    0.00 :	  4904a7:       89 ce                   mov    %ecx,%esi
    7.14 :	  4904a9:       29 c8                   sub    %ecx,%eax
    0.00 :	  4904ab:       01 d1                   add    %edx,%ecx
    0.00 :	  4904ad:       c1 ce 10                ror    $0x10,%esi
    7.14 :	  4904b0:       31 c6                   xor    %eax,%esi
    0.00 :	  4904b2:       89 f0                   mov    %esi,%eax
    0.00 :	  4904b4:       29 f2                   sub    %esi,%edx
    0.00 :	  4904b6:       44 8d 0c 0e             lea    (%rsi,%rcx,1),%r9d
    0.00 :	  4904ba:       c1 c8 0d                ror    $0xd,%eax
    7.14 :	  4904bd:       31 d0                   xor    %edx,%eax
    0.00 :	  4904bf:       41 89 c0                mov    %eax,%r8d
    0.00 :	  4904c2:       29 c1                   sub    %eax,%ecx
    0.00 :	  4904c4:       41 c1 c8 1c             ror    $0x1c,%r8d
    7.14 :	  4904c8:       41 31 c8                xor    %ecx,%r8d
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4904cb:       41 83 fa 0b             cmp    $0xb,%r10d
         :	                {
         :	                        a += ka[0];
         :	                        b += ka[1];
         :	                        c += ka[2];
         :	                        mix(a, b, c);
    0.00 :	  4904cf:       42 8d 0c 08             lea    (%rax,%r9,1),%ecx
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4904d3:       77 9b                   ja     490470 <hash_any+0x120>
    0.00 :	  4904d5:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  4904d8:       89 ce                   mov    %ecx,%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:323
    7.14 :	  4904da:       44 89 c3                mov    %r8d,%ebx
         :	                        case 1:
         :	                                a += ((uint32) k[0] << 24);
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)
    0.00 :	  4904dd:       41 83 fa 0b             cmp    $0xb,%r10d
    0.00 :	  4904e1:       77 6e                   ja     490551 <hash_any+0x201>
    0.00 :	  4904e3:       44 89 d0                mov    %r10d,%eax
    0.00 :	  4904e6:       ff 24 c5 78 22 7b 00    jmpq   *0x7b2278(,%rax,8)
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)                    /* all the case statements fall through */
         :	                {
         :	                        case 11:
         :	                                c += ((uint32) k[10] << 24);
    0.00 :	  4904ed:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
    0.00 :	  4904f1:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4904f4:       42 8d 1c 00             lea    (%rax,%r8,1),%ebx
         :	                        case 10:
         :	                                c += ((uint32) k[9] << 16);
    0.00 :	  4904f8:       0f b6 47 09             movzbl 0x9(%rdi),%eax
    0.00 :	  4904fc:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4904ff:       01 c3                   add    %eax,%ebx
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
    0.00 :	  490501:       0f b6 47 08             movzbl 0x8(%rdi),%eax
    0.00 :	  490505:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490508:       01 c3                   add    %eax,%ebx
         :	                                /* the lowest byte of c is reserved for the length */
         :	                        case 8:
         :	                                b += ((uint32) k[7] << 24);
    0.00 :	  49050a:       0f b6 47 07             movzbl 0x7(%rdi),%eax
    0.00 :	  49050e:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  490511:       8d 34 10                lea    (%rax,%rdx,1),%esi
         :	                        case 7:
         :	                                b += ((uint32) k[6] << 16);
    0.00 :	  490514:       0f b6 47 06             movzbl 0x6(%rdi),%eax
    0.00 :	  490518:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49051b:       01 c6                   add    %eax,%esi
         :	                        case 6:
         :	                                b += ((uint32) k[5] << 8);
    0.00 :	  49051d:       0f b6 47 05             movzbl 0x5(%rdi),%eax
    0.00 :	  490521:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490524:       01 c6                   add    %eax,%esi
         :	                        case 5:
         :	                                b += k[4];
    0.00 :	  490526:       0f b6 47 04             movzbl 0x4(%rdi),%eax
    0.00 :	  49052a:       01 c6                   add    %eax,%esi
         :	                        case 4:
         :	                                a += ((uint32) k[3] << 24);
    0.00 :	  49052c:       0f b6 47 03             movzbl 0x3(%rdi),%eax
    0.00 :	  490530:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  490533:       46 8d 1c 08             lea    (%rax,%r9,1),%r11d
         :	                        case 3:
         :	                                a += ((uint32) k[2] << 16);
    0.00 :	  490537:       0f b6 47 02             movzbl 0x2(%rdi),%eax
    0.00 :	  49053b:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49053e:       41 01 c3                add    %eax,%r11d
         :	                        case 2:
         :	                                a += ((uint32) k[1] << 8);
    0.00 :	  490541:       0f b6 47 01             movzbl 0x1(%rdi),%eax
    0.00 :	  490545:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  490548:       41 01 c3                add    %eax,%r11d
         :	                        case 1:
         :	                                a += k[0];
    0.00 :	  49054b:       0f b6 07                movzbl (%rdi),%eax
    0.00 :	  49054e:       41 01 c3                add    %eax,%r11d
         :	                                /* case 0: nothing left to add */
         :	                }
         :	#endif   /* WORDS_BIGENDIAN */
         :	        }
         :
         :	        final(a, b, c);
    0.00 :	  490551:       89 da                   mov    %ebx,%edx
    0.00 :	  490553:       89 f0                   mov    %esi,%eax
    0.00 :	  490555:       31 f2                   xor    %esi,%edx
    0.00 :	  490557:       c1 c8 12                ror    $0x12,%eax
    0.00 :	  49055a:       29 c2                   sub    %eax,%edx
    0.00 :	  49055c:       89 d1                   mov    %edx,%ecx
    0.00 :	  49055e:       89 d0                   mov    %edx,%eax
    0.00 :	  490560:       c1 c8 15                ror    $0x15,%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:496
    7.14 :	  490563:       44 31 d9                xor    %r11d,%ecx
    0.00 :	  490566:       29 c1                   sub    %eax,%ecx
    0.00 :	  490568:       89 c8                   mov    %ecx,%eax
    0.00 :	  49056a:       31 ce                   xor    %ecx,%esi
    0.00 :	  49056c:       c1 c8 07                ror    $0x7,%eax
    7.14 :	  49056f:       29 c6                   sub    %eax,%esi
    0.00 :	  490571:       89 f0                   mov    %esi,%eax
    0.00 :	  490573:       31 d0                   xor    %edx,%eax
    0.00 :	  490575:       89 f2                   mov    %esi,%edx
    0.00 :	  490577:       c1 ca 10                ror    $0x10,%edx
    0.00 :	  49057a:       29 d0                   sub    %edx,%eax
    0.00 :	  49057c:       89 c2                   mov    %eax,%edx
    0.00 :	  49057e:       31 ca                   xor    %ecx,%edx
    0.00 :	  490580:       89 c1                   mov    %eax,%ecx
    0.00 :	  490582:       c1 c9 1c                ror    $0x1c,%ecx
    0.00 :	  490585:       29 ca                   sub    %ecx,%edx
    0.00 :	  490587:       89 d1                   mov    %edx,%ecx
    0.00 :	  490589:       c1 ca 12                ror    $0x12,%edx
    0.00 :	  49058c:       31 f1                   xor    %esi,%ecx
    0.00 :	  49058e:       29 d1                   sub    %edx,%ecx
    0.00 :	  490590:       31 c8                   xor    %ecx,%eax
    0.00 :	  490592:       c1 c9 08                ror    $0x8,%ecx
    0.00 :	  490595:       29 c8                   sub    %ecx,%eax
         :
         :	        /* report the result */
         :	        return UInt32GetDatum(c);
         :	}
    0.00 :	  490597:       5b                      pop    %rbx
    0.00 :	  490598:       c9                      leaveq 
    0.00 :	  490599:       c3                      retq   
         :	                        case 8:
         :	                                b += ka[1];
         :	                                a += ka[0];
         :	                                break;
         :	                        case 7:
         :	                                b += ((uint32) k[6] << 16);
    0.00 :	  49059a:       0f b6 47 06             movzbl 0x6(%rdi),%eax
    0.00 :	  49059e:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4905a1:       8d 34 08                lea    (%rax,%rcx,1),%esi
         :	                                /* fall through */
         :	                        case 6:
         :	                                b += ((uint32) k[5] << 8);
    0.00 :	  4905a4:       0f b6 47 05             movzbl 0x5(%rdi),%eax
    0.00 :	  4905a8:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  4905ab:       01 c6                   add    %eax,%esi
         :	                                /* fall through */
         :	                        case 5:
         :	                                b += k[4];
    0.00 :	  4905ad:       0f b6 47 04             movzbl 0x4(%rdi),%eax
    0.00 :	  4905b1:       01 c6                   add    %eax,%esi
         :	                                /* fall through */
         :	                        case 4:
         :	                                a += ka[0];
    0.00 :	  4905b3:       45 89 cb                mov    %r9d,%r11d
    0.00 :	  4905b6:       44 03 1f                add    (%rdi),%r11d
         :	                                break;
    0.00 :	  4905b9:       eb 96                   jmp    490551 <hash_any+0x201>
         :	                }
         :	#else                                                   /* !WORDS_BIGENDIAN */
         :	                switch (len)
         :	                {
         :	                        case 11:
         :	                                c += ((uint32) k[10] << 24);
    0.00 :	  4905bb:       0f b6 47 0a             movzbl 0xa(%rdi),%eax
    0.00 :	  4905bf:       c1 e0 18                shl    $0x18,%eax
    0.00 :	  4905c2:       42 8d 1c 00             lea    (%rax,%r8,1),%ebx
         :	                                /* fall through */
         :	                        case 10:
         :	                                c += ((uint32) k[9] << 16);
    0.00 :	  4905c6:       0f b6 47 09             movzbl 0x9(%rdi),%eax
    0.00 :	  4905ca:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  4905cd:       01 c3                   add    %eax,%ebx
         :	                                /* fall through */
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
    0.00 :	  4905cf:       0f b6 47 08             movzbl 0x8(%rdi),%eax
    0.00 :	  4905d3:       c1 e0 08                shl    $0x8,%eax
    0.00 :	  4905d6:       01 c3                   add    %eax,%ebx
         :	                                /* the lowest byte of c is reserved for the length */
         :	                                /* fall through */
         :	                        case 8:
         :	                                b += ka[1];
    0.00 :	  4905d8:       89 ce                   mov    %ecx,%esi
         :	                                a += ka[0];
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:389
    7.14 :	  4905da:       45 89 cb                mov    %r9d,%r11d
         :	                        case 9:
         :	                                c += ((uint32) k[8] << 8);
         :	                                /* the lowest byte of c is reserved for the length */
         :	                                /* fall through */
         :	                        case 8:
         :	                                b += ka[1];
    0.00 :	  4905dd:       03 77 04                add    0x4(%rdi),%esi
         :	                                a += ka[0];
    0.00 :	  4905e0:       44 03 1f                add    (%rdi),%r11d
         :	                                break;
    0.00 :	  4905e3:       e9 69 ff ff ff          jmpq   490551 <hash_any+0x201>
         :	        {
         :	                /* Code path for aligned source data */
         :	                register const uint32 *ka = (const uint32 *) k;
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4905e8:       45 89 c3                mov    %r8d,%r11d
    0.00 :	  4905eb:       44 89 c6                mov    %r8d,%esi
    0.00 :	  4905ee:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  4905f1:       e9 e7 fe ff ff          jmpq   4904dd <hash_any+0x18d>
         :	        else
         :	        {
         :	                /* Code path for non-aligned source data */
         :
         :	                /* handle most of the key */
         :	                while (len >= 12)
    0.00 :	  4905f6:       45 89 c3                mov    %r8d,%r11d
    0.00 :	  4905f9:       44 89 c6                mov    %r8d,%esi
    0.00 :	  4905fc:       44 89 c3                mov    %r8d,%ebx
    0.00 :	  4905ff:       e9 42 fe ff ff          jmpq   490446 <hash_any+0xf6>
         :	                                /* fall through */
         :	                        case 4:
         :	                                a += ka[0];
         :	                                break;
         :	                        case 3:
         :	                                a += ((uint32) k[2] << 16);
    0.00 :	  490604:       0f b6 47 02             movzbl 0x2(%rdi),%eax
    0.00 :	  490608:       c1 e0 10                shl    $0x10,%eax
    0.00 :	  49060b:       46 8d 1c 08             lea    (%rax,%r9,1),%r11d
    0.00 :	  49060f:       e9 2d ff ff ff          jmpq   490541 <hash_any+0x1f1>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1022
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:687
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:492
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:492
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:515
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:702
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:718
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:858
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:940
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:958
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:973
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:932
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ad290 <_bt_first>:
         :	 * Within this routine, we build a temporary insertion-type scankey to use
         :	 * in locating the scan start position.
         :	 */
         :	bool
         :	_bt_first(IndexScanDesc scan, ScanDirection dir)
         :	{
    0.00 :	  4ad290:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:492
    7.14 :	  4ad291:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ad294:       41 57                   push   %r15
    0.00 :	  4ad296:       41 56                   push   %r14
    7.14 :	  4ad298:       41 55                   push   %r13
    0.00 :	  4ad29a:       41 54                   push   %r12
    0.00 :	  4ad29c:       53                      push   %rbx
    0.00 :	  4ad29d:       48 81 ec 68 13 00 00    sub    $0x1368,%rsp
    0.00 :	  4ad2a4:       48 89 bd a0 ec ff ff    mov    %rdi,-0x1360(%rbp)
    0.00 :	  4ad2ab:       89 b5 9c ec ff ff       mov    %esi,-0x1364(%rbp)
         :	        Relation        rel = scan->indexRelation;
    0.00 :	  4ad2b1:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  4ad2b5:       48 89 85 a8 ec ff ff    mov    %rax,-0x1358(%rbp)
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4ad2bc:       48 8b 57 38             mov    0x38(%rdi),%rdx
    0.00 :	  4ad2c0:       48 89 95 b0 ec ff ff    mov    %rdx,-0x1350(%rbp)
         :	        int                     keysCount = 0;
         :	        int                     i;
         :	        StrategyNumber strat_total;
         :	        BTScanPosItem *currItem;
         :
         :	        pgstat_count_index_scan(rel);
    0.00 :	  4ad2c7:       48 8b 80 38 01 00 00    mov    0x138(%rax),%rax
    0.00 :	  4ad2ce:       48 85 c0                test   %rax,%rax
    0.00 :	  4ad2d1:       74 05                   je     4ad2d8 <_bt_first+0x48>
    0.00 :	  4ad2d3:       48 83 40 10 01          addq   $0x1,0x10(%rax)
         :
         :	        /*
         :	         * Examine the scan keys and eliminate any redundant keys; also mark the
         :	         * keys that must be matched to continue the scan.
         :	         */
         :	        _bt_preprocess_keys(scan);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:515
    7.14 :	  4ad2d8:       48 8b bd a0 ec ff ff    mov    -0x1360(%rbp),%rdi
    0.00 :	  4ad2df:       e8 ec 18 00 00          callq  4aebd0 <_bt_preprocess_keys>
         :
         :	        /*
         :	         * Quit now if _bt_preprocess_keys() discovered that the scan keys can
         :	         * never be satisfied (eg, x == 1 AND x > 2).
         :	         */
         :	        if (!so->qual_ok)
    0.00 :	  4ad2e4:       48 8b 85 b0 ec ff ff    mov    -0x1350(%rbp),%rax
    0.00 :	  4ad2eb:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  4ad2ee:       0f 84 cc 00 00 00       je     4ad3c0 <_bt_first+0x130>
         :	         * The selected scan keys (at most one per index column) are remembered by
         :	         * storing their addresses into the local startKeys[] array.
         :	         *----------
         :	         */
         :	        strat_total = BTEqualStrategyNumber;
         :	        if (so->numberOfKeys > 0)
    0.00 :	  4ad2f4:       8b 50 04                mov    0x4(%rax),%edx
    0.00 :	  4ad2f7:       85 d2                   test   %edx,%edx
    0.00 :	  4ad2f9:       0f 8e 31 04 00 00       jle    4ad730 <_bt_first+0x4a0>
         :	                /*
         :	                 * Loop iterates from 0 to numberOfKeys inclusive; we use the last
         :	                 * pass to handle after-last-key processing.  Actual exit from the
         :	                 * loop is at one of the "break" statements below.
         :	                 */
         :	                for (cur = so->keyData, i = 0;; cur++, i++)
    0.00 :	  4ad2ff:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  4ad303:       45 31 ff                xor    %r15d,%r15d
    0.00 :	  4ad306:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ad309:       66 c7 85 be ec ff ff    movw   $0x3,-0x1342(%rbp)
    0.00 :	  4ad310:       03 00 
    0.00 :	  4ad312:       41 be 01 00 00 00       mov    $0x1,%r14d
    0.00 :	  4ad318:       31 db                   xor    %ebx,%ebx
    0.00 :	  4ad31a:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad31c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                {
         :	                        if (i >= so->numberOfKeys || cur->sk_attno != curattr)
    0.00 :	  4ad320:       41 39 d5                cmp    %edx,%r13d
    0.00 :	  4ad323:       7d 0c                   jge    4ad331 <_bt_first+0xa1>
    0.00 :	  4ad325:       41 0f b7 4c 24 04       movzwl 0x4(%r12),%ecx
    0.00 :	  4ad32b:       66 44 39 f1             cmp    %r14w,%cx
    0.00 :	  4ad32f:       74 74                   je     4ad3a5 <_bt_first+0x115>
         :	                        {
         :	                                /*
         :	                                 * Done looking at keys for curattr.  If we didn't find a
         :	                                 * usable boundary key, see if we can deduce a NOT NULL key.
         :	                                 */
         :	                                if (chosen == NULL && impliesNN != NULL &&
    0.00 :	  4ad331:       48 85 db                test   %rbx,%rbx
    0.00 :	  4ad334:       0f 84 fe 00 00 00       je     4ad438 <_bt_first+0x1a8>
         :	                                 * If we still didn't find a usable boundary key, quit; else
         :	                                 * save the boundary key pointer in startKeys.
         :	                                 */
         :	                                if (chosen == NULL)
         :	                                        break;
         :	                                startKeys[keysCount++] = chosen;
    0.00 :	  4ad33a:       49 63 c7                movslq %r15d,%rax
    0.00 :	  4ad33d:       41 83 c7 01             add    $0x1,%r15d
    0.00 :	  4ad341:       48 89 9c c5 c0 fe ff    mov    %rbx,-0x140(%rbp,%rax,8)
    0.00 :	  4ad348:       ff 
         :
         :	                                /*
         :	                                 * Adjust strat_total, and quit if we have stored a > or <
         :	                                 * key.
         :	                                 */
         :	                                strat = chosen->sk_strategy;
    0.00 :	  4ad349:       0f b7 43 06             movzwl 0x6(%rbx),%eax
         :	                                if (strat != BTEqualStrategyNumber)
    0.00 :	  4ad34d:       66 83 f8 03             cmp    $0x3,%ax
    0.00 :	  4ad351:       74 1b                   je     4ad36e <_bt_first+0xde>
         :	                                {
         :	                                        strat_total = strat;
         :	                                        if (strat == BTGreaterStrategyNumber ||
    0.00 :	  4ad353:       66 83 f8 05             cmp    $0x5,%ax
    0.00 :	  4ad357:       0f 84 33 05 00 00       je     4ad890 <_bt_first+0x600>
    0.00 :	  4ad35d:       66 83 f8 01             cmp    $0x1,%ax
    0.00 :	  4ad361:       0f 84 29 05 00 00       je     4ad890 <_bt_first+0x600>
         :	                                                strat == BTLessStrategyNumber)
         :	                                                break;
    0.00 :	  4ad367:       66 89 85 be ec ff ff    mov    %ax,-0x1342(%rbp)
         :	                                /*
         :	                                 * Done if that was the last attribute, or if next key is not
         :	                                 * in sequence (implying no boundary key is available for the
         :	                                 * next attribute).
         :	                                 */
         :	                                if (i >= so->numberOfKeys ||
    0.00 :	  4ad36e:       48 8b 95 b0 ec ff ff    mov    -0x1350(%rbp),%rdx
    0.00 :	  4ad375:       44 3b 6a 04             cmp    0x4(%rdx),%r13d
    0.00 :	  4ad379:       0f 8d e0 00 00 00       jge    4ad45f <_bt_first+0x1cf>
    0.00 :	  4ad37f:       41 0f b7 4c 24 04       movzwl 0x4(%r12),%ecx
    0.00 :	  4ad385:       41 0f bf c6             movswl %r14w,%eax
    0.00 :	  4ad389:       83 c0 01                add    $0x1,%eax
    0.00 :	  4ad38c:       0f bf d1                movswl %cx,%edx
    0.00 :	  4ad38f:       39 c2                   cmp    %eax,%edx
    0.00 :	  4ad391:       0f 85 c8 00 00 00       jne    4ad45f <_bt_first+0x1cf>
    0.00 :	  4ad397:       48 8b 85 b0 ec ff ff    mov    -0x1350(%rbp),%rax
    0.00 :	  4ad39e:       31 db                   xor    %ebx,%ebx
    0.00 :	  4ad3a0:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad3a2:       8b 50 04                mov    0x4(%rax),%edx
         :	                         *
         :	                         * If not, does it imply a NOT NULL constraint?  (Because
         :	                         * SK_SEARCHNULL keys are always assigned BTEqualStrategyNumber,
         :	                         * *any* inequality key works for that; we need not test.)
         :	                         */
         :	                        switch (cur->sk_strategy)
    0.00 :	  4ad3a5:       66 41 83 7c 24 06 05    cmpw   $0x5,0x6(%r12)
    0.00 :	  4ad3ac:       77 4a                   ja     4ad3f8 <_bt_first+0x168>
    0.00 :	  4ad3ae:       41 0f b7 44 24 06       movzwl 0x6(%r12),%eax
    0.00 :	  4ad3b4:       ff 24 c5 60 48 7b 00    jmpq   *0x7b4860(,%rax,8)
    0.00 :	  4ad3bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ad3c0:       31 d2                   xor    %edx,%edx
         :
         :	        return true;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1022
   14.29 :	  4ad3c2:       48 81 c4 68 13 00 00    add    $0x1368,%rsp
    0.00 :	  4ad3c9:       89 d0                   mov    %edx,%eax
    0.00 :	  4ad3cb:       5b                      pop    %rbx
    0.00 :	  4ad3cc:       41 5c                   pop    %r12
    0.00 :	  4ad3ce:       41 5d                   pop    %r13
    0.00 :	  4ad3d0:       41 5e                   pop    %r14
    0.00 :	  4ad3d2:       41 5f                   pop    %r15
    0.00 :	  4ad3d4:       c9                      leaveq 
    0.00 :	  4ad3d5:       c3                      retq   
    0.00 :	  4ad3d6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ad3dd:       00 00 00 
         :	                                        /* override any non-equality choice */
         :	                                        chosen = cur;
         :	                                        break;
         :	                                case BTGreaterEqualStrategyNumber:
         :	                                case BTGreaterStrategyNumber:
         :	                                        if (chosen == NULL)
    0.00 :	  4ad3e0:       48 85 db                test   %rbx,%rbx
    0.00 :	  4ad3e3:       75 13                   jne    4ad3f8 <_bt_first+0x168>
         :	                                        {
         :	                                                if (ScanDirectionIsForward(dir))
    0.00 :	  4ad3e5:       83 bd 9c ec ff ff 01    cmpl   $0x1,-0x1364(%rbp)
    0.00 :	  4ad3ec:       74 32                   je     4ad420 <_bt_first+0x190>
    0.00 :	  4ad3ee:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  4ad3f1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Loop iterates from 0 to numberOfKeys inclusive; we use the last
         :	                 * pass to handle after-last-key processing.  Actual exit from the
         :	                 * loop is at one of the "break" statements below.
         :	                 */
         :	                for (cur = so->keyData, i = 0;; cur++, i++)
    0.00 :	  4ad3f8:       49 83 c4 48             add    $0x48,%r12
    0.00 :	  4ad3fc:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  4ad400:       41 89 ce                mov    %ecx,%r14d
         :	                                                else
         :	                                                        impliesNN = cur;
         :	                                        }
         :	                                        break;
         :	                        }
         :	                }
    0.00 :	  4ad403:       e9 18 ff ff ff          jmpq   4ad320 <_bt_first+0x90>
    0.00 :	  4ad408:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4ad40f:       00 
         :	                         */
         :	                        switch (cur->sk_strategy)
         :	                        {
         :	                                case BTLessStrategyNumber:
         :	                                case BTLessEqualStrategyNumber:
         :	                                        if (chosen == NULL)
    0.00 :	  4ad410:       48 85 db                test   %rbx,%rbx
    0.00 :	  4ad413:       75 e3                   jne    4ad3f8 <_bt_first+0x168>
         :	                                        {
         :	                                                if (ScanDirectionIsBackward(dir))
    0.00 :	  4ad415:       83 bd 9c ec ff ff ff    cmpl   $0xffffffff,-0x1364(%rbp)
    0.00 :	  4ad41c:       75 d0                   jne    4ad3ee <_bt_first+0x15e>
    0.00 :	  4ad41e:       66 90                   xchg   %ax,%ax
         :	                                        break;
         :	                                case BTGreaterEqualStrategyNumber:
         :	                                case BTGreaterStrategyNumber:
         :	                                        if (chosen == NULL)
         :	                                        {
         :	                                                if (ScanDirectionIsForward(dir))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:687
   14.29 :	  4ad420:       4c 89 e3                mov    %r12,%rbx
         :	                /*
         :	                 * Loop iterates from 0 to numberOfKeys inclusive; we use the last
         :	                 * pass to handle after-last-key processing.  Actual exit from the
         :	                 * loop is at one of the "break" statements below.
         :	                 */
         :	                for (cur = so->keyData, i = 0;; cur++, i++)
    0.00 :	  4ad423:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  4ad427:       49 83 c4 48             add    $0x48,%r12
    0.00 :	  4ad42b:       41 89 ce                mov    %ecx,%r14d
    0.00 :	  4ad42e:       e9 ed fe ff ff          jmpq   4ad320 <_bt_first+0x90>
    0.00 :	  4ad433:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        {
         :	                                /*
         :	                                 * Done looking at keys for curattr.  If we didn't find a
         :	                                 * usable boundary key, see if we can deduce a NOT NULL key.
         :	                                 */
         :	                                if (chosen == NULL && impliesNN != NULL &&
    0.00 :	  4ad438:       48 85 f6                test   %rsi,%rsi
    0.00 :	  4ad43b:       74 22                   je     4ad45f <_bt_first+0x1cf>
    0.00 :	  4ad43d:       8b 36                   mov    (%rsi),%esi
    0.00 :	  4ad43f:       89 f2                   mov    %esi,%edx
    0.00 :	  4ad441:       81 e2 00 00 00 02       and    $0x2000000,%edx
    0.00 :	  4ad447:       0f 84 73 02 00 00       je     4ad6c0 <_bt_first+0x430>
    0.00 :	  4ad44d:       83 bd 9c ec ff ff 01    cmpl   $0x1,-0x1364(%rbp)
    0.00 :	  4ad454:       0f 94 c0                sete   %al
    0.00 :	  4ad457:       84 c0                   test   %al,%al
    0.00 :	  4ad459:       0f 85 09 02 00 00       jne    4ad668 <_bt_first+0x3d8>
         :	        /*
         :	         * If we found no usable boundary keys, we have to start from one end of
         :	         * the tree.  Walk down that edge to the first or last key, and scan from
         :	         * there.
         :	         */
         :	        if (keysCount == 0)
    0.00 :	  4ad45f:       41 83 ff 00             cmp    $0x0,%r15d
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:702
    7.14 :	  4ad463:       0f 84 c7 02 00 00       je     4ad730 <_bt_first+0x4a0>
         :	         * insertion scankey we can use to search for the boundary point we
         :	         * identified above.  The insertion scankey is built in the local
         :	         * scankeys[] array, using the keys identified by startKeys[].
         :	         */
         :	        Assert(keysCount <= INDEX_MAX_KEYS);
         :	        for (i = 0; i < keysCount; i++)
    0.00 :	  4ad469:       0f 8e b5 01 00 00       jle    4ad624 <_bt_first+0x394>
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ad46f:       48 8d 8d c0 f5 ff ff    lea    -0xa40(%rbp),%rcx
         :	                         * scheme.  But, by the same token, if we aren't able to use all
         :	                         * the row members, then the part of the row comparison that we
         :	                         * did use has to be treated as just a ">=" or "<=" condition, and
         :	                         * so we'd better adjust strat_total accordingly.
         :	                         */
         :	                        if (i == keysCount - 1)
    0.00 :	  4ad476:       41 8d 47 ff             lea    -0x1(%r15),%eax
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ad47a:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ad47d:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  4ad480:       48 89 8d 90 ec ff ff    mov    %rcx,-0x1370(%rbp)
    0.00 :	  4ad487:       48 89 cb                mov    %rcx,%rbx
         :	                         * scheme.  But, by the same token, if we aren't able to use all
         :	                         * the row members, then the part of the row comparison that we
         :	                         * did use has to be treated as just a ">=" or "<=" condition, and
         :	                         * so we'd better adjust strat_total accordingly.
         :	                         */
         :	                        if (i == keysCount - 1)
    0.00 :	  4ad48a:       89 85 8c ec ff ff       mov    %eax,-0x1374(%rbp)
    0.00 :	  4ad490:       eb 7c                   jmp    4ad50e <_bt_first+0x27e>
    0.00 :	  4ad492:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * have sk_func = 3-way-comparison function), but we have to watch
         :	                         * out for nulls, which _bt_preprocess_keys didn't check. A null
         :	                         * in the first row member makes the condition unmatchable, just
         :	                         * like qual_ok = false.
         :	                         */
         :	                        ScanKey         subkey = (ScanKey) DatumGetPointer(cur->sk_argument);
    0.00 :	  4ad498:       49 8b 4c 24 40          mov    0x40(%r12),%rcx
         :
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        if (subkey->sk_flags & SK_ISNULL)
    0.00 :	  4ad49d:       f6 01 01                testb  $0x1,(%rcx)
    0.00 :	  4ad4a0:       0f 85 1a ff ff ff       jne    4ad3c0 <_bt_first+0x130>
         :	                                return false;
         :	                        memcpy(scankeys + i, subkey, sizeof(ScanKeyData));
    0.00 :	  4ad4a6:       48 8b 01                mov    (%rcx),%rax
    0.00 :	  4ad4a9:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  4ad4ac:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  4ad4b0:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  4ad4b4:       48 8b 41 10             mov    0x10(%rcx),%rax
    0.00 :	  4ad4b8:       48 89 43 10             mov    %rax,0x10(%rbx)
    0.00 :	  4ad4bc:       48 8b 41 18             mov    0x18(%rcx),%rax
    0.00 :	  4ad4c0:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	  4ad4c4:       48 8b 41 20             mov    0x20(%rcx),%rax
    0.00 :	  4ad4c8:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  4ad4cc:       48 8b 41 28             mov    0x28(%rcx),%rax
    0.00 :	  4ad4d0:       48 89 43 28             mov    %rax,0x28(%rbx)
    0.00 :	  4ad4d4:       48 8b 41 30             mov    0x30(%rcx),%rax
    0.00 :	  4ad4d8:       48 89 43 30             mov    %rax,0x30(%rbx)
    0.00 :	  4ad4dc:       48 8b 41 38             mov    0x38(%rcx),%rax
    0.00 :	  4ad4e0:       48 89 43 38             mov    %rax,0x38(%rbx)
    0.00 :	  4ad4e4:       48 8b 41 40             mov    0x40(%rcx),%rax
    0.00 :	  4ad4e8:       48 89 43 40             mov    %rax,0x40(%rbx)
         :	                         * scheme.  But, by the same token, if we aren't able to use all
         :	                         * the row members, then the part of the row comparison that we
         :	                         * did use has to be treated as just a ">=" or "<=" condition, and
         :	                         * so we'd better adjust strat_total accordingly.
         :	                         */
         :	                        if (i == keysCount - 1)
    0.00 :	  4ad4ec:       44 39 ad 8c ec ff ff    cmp    %r13d,-0x1374(%rbp)
    0.00 :	  4ad4f3:       0f 84 9a 00 00 00       je     4ad593 <_bt_first+0x303>
         :	         * insertion scankey we can use to search for the boundary point we
         :	         * identified above.  The insertion scankey is built in the local
         :	         * scankeys[] array, using the keys identified by startKeys[].
         :	         */
         :	        Assert(keysCount <= INDEX_MAX_KEYS);
         :	        for (i = 0; i < keysCount; i++)
    0.00 :	  4ad4f9:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  4ad4fd:       48 83 c3 48             add    $0x48,%rbx
    0.00 :	  4ad501:       49 83 c6 04             add    $0x4,%r14
    0.00 :	  4ad505:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  4ad508:       0f 8e 16 01 00 00       jle    4ad624 <_bt_first+0x394>
         :	        {
         :	                ScanKey         cur = startKeys[i];
    0.00 :	  4ad50e:       4e 8b a4 75 c0 fe ff    mov    -0x140(%rbp,%r14,2),%r12
    0.00 :	  4ad515:       ff 
         :
         :	                Assert(cur->sk_attno == i + 1);
         :
         :	                if (cur->sk_flags & SK_ROW_HEADER)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:718
    7.14 :	  4ad516:       41 f6 04 24 04          testb  $0x4,(%r12)
    0.00 :	  4ad51b:       0f 85 77 ff ff ff       jne    4ad498 <_bt_first+0x208>
         :	                         *
         :	                         * We support the convention that sk_subtype == InvalidOid means
         :	                         * the opclass input type; this is a hack to simplify life for
         :	                         * ScanKeyInit().
         :	                         */
         :	                        if (cur->sk_subtype == rel->rd_opcintype[i] ||
    0.00 :	  4ad521:       48 8b 8d a8 ec ff ff    mov    -0x1358(%rbp),%rcx
    0.00 :	  4ad528:       41 8b 54 24 08          mov    0x8(%r12),%edx
    0.00 :	  4ad52d:       48 8b 81 d0 00 00 00    mov    0xd0(%rcx),%rax
    0.00 :	  4ad534:       42 8b 34 30             mov    (%rax,%r14,1),%esi
    0.00 :	  4ad538:       39 f2                   cmp    %esi,%edx
    0.00 :	  4ad53a:       74 08                   je     4ad544 <_bt_first+0x2b4>
    0.00 :	  4ad53c:       85 d2                   test   %edx,%edx
    0.00 :	  4ad53e:       0f 85 8c 01 00 00       jne    4ad6d0 <_bt_first+0x440>
         :	                                cur->sk_subtype == InvalidOid)
         :	                        {
         :	                                FmgrInfo   *procinfo;
         :
         :	                                procinfo = index_getprocinfo(rel, cur->sk_attno, BTORDER_PROC);
    0.00 :	  4ad544:       41 0f bf 74 24 04       movswl 0x4(%r12),%esi
    0.00 :	  4ad54a:       48 8b bd a8 ec ff ff    mov    -0x1358(%rbp),%rdi
    0.00 :	  4ad551:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ad556:       e8 65 7b ff ff          callq  4a50c0 <index_getprocinfo>
         :	                                ScanKeyEntryInitializeWithInfo(scankeys + i,
    0.00 :	  4ad55b:       49 8b 4c 24 40          mov    0x40(%r12),%rcx
    0.00 :	  4ad560:       41 0f bf 54 24 04       movswl 0x4(%r12),%edx
    0.00 :	  4ad566:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4ad569:       45 8b 4c 24 0c          mov    0xc(%r12),%r9d
    0.00 :	  4ad56e:       45 8b 44 24 08          mov    0x8(%r12),%r8d
    0.00 :	  4ad573:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  4ad577:       48 89 4c 24 08          mov    %rcx,0x8(%rsp)
    0.00 :	  4ad57c:       41 8b 34 24             mov    (%r12),%esi
    0.00 :	  4ad580:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ad582:       e8 b9 65 fc ff          callq  473b40 <ScanKeyEntryInitializeWithInfo>
         :	                         *
         :	                         * We support the convention that sk_subtype == InvalidOid means
         :	                         * the opclass input type; this is a hack to simplify life for
         :	                         * ScanKeyInit().
         :	                         */
         :	                        if (cur->sk_subtype == rel->rd_opcintype[i] ||
    0.00 :	  4ad587:       e9 6d ff ff ff          jmpq   4ad4f9 <_bt_first+0x269>
    0.00 :	  4ad58c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                        if (subkey->sk_flags & SK_ISNULL)
         :	                                                break;  /* can't use null keys */
         :	                                        Assert(keysCount < INDEX_MAX_KEYS);
         :	                                        memcpy(scankeys + keysCount, subkey, sizeof(ScanKeyData));
         :	                                        keysCount++;
         :	                                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ad590:       41 89 f7                mov    %esi,%r15d
         :	                                bool            used_all_subkeys = false;
         :
         :	                                Assert(!(subkey->sk_flags & SK_ROW_END));
         :	                                for (;;)
         :	                                {
         :	                                        subkey++;
    0.00 :	  4ad593:       48 83 c1 48             add    $0x48,%rcx
         :	                                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                                        if (subkey->sk_attno != keysCount + 1)
    0.00 :	  4ad597:       41 8d 47 01             lea    0x1(%r15),%eax
    0.00 :	  4ad59b:       0f bf 71 04             movswl 0x4(%rcx),%esi
    0.00 :	  4ad59f:       39 c6                   cmp    %eax,%esi
    0.00 :	  4ad5a1:       0f 85 f1 05 00 00       jne    4adb98 <_bt_first+0x908>
         :	                                                break;  /* out-of-sequence, can't use it */
         :	                                        if (subkey->sk_strategy != cur->sk_strategy)
    0.00 :	  4ad5a7:       0f b7 41 06             movzwl 0x6(%rcx),%eax
    0.00 :	  4ad5ab:       66 41 3b 44 24 06       cmp    0x6(%r12),%ax
    0.00 :	  4ad5b1:       0f 85 e1 05 00 00       jne    4adb98 <_bt_first+0x908>
         :	                                                break;  /* wrong direction, can't use it */
         :	                                        if (subkey->sk_flags & SK_ISNULL)
    0.00 :	  4ad5b7:       f6 01 01                testb  $0x1,(%rcx)
    0.00 :	  4ad5ba:       0f 85 d8 05 00 00       jne    4adb98 <_bt_first+0x908>
         :	                                                break;  /* can't use null keys */
         :	                                        Assert(keysCount < INDEX_MAX_KEYS);
         :	                                        memcpy(scankeys + keysCount, subkey, sizeof(ScanKeyData));
    0.00 :	  4ad5c0:       48 8b 95 90 ec ff ff    mov    -0x1370(%rbp),%rdx
    0.00 :	  4ad5c7:       49 63 c7                movslq %r15d,%rax
    0.00 :	  4ad5ca:       48 8d 04 c0             lea    (%rax,%rax,8),%rax
    0.00 :	  4ad5ce:       48 8d 04 c2             lea    (%rdx,%rax,8),%rax
    0.00 :	  4ad5d2:       48 8b 11                mov    (%rcx),%rdx
    0.00 :	  4ad5d5:       48 89 10                mov    %rdx,(%rax)
    0.00 :	  4ad5d8:       48 8b 51 08             mov    0x8(%rcx),%rdx
    0.00 :	  4ad5dc:       48 89 50 08             mov    %rdx,0x8(%rax)
    0.00 :	  4ad5e0:       48 8b 51 10             mov    0x10(%rcx),%rdx
    0.00 :	  4ad5e4:       48 89 50 10             mov    %rdx,0x10(%rax)
    0.00 :	  4ad5e8:       48 8b 51 18             mov    0x18(%rcx),%rdx
    0.00 :	  4ad5ec:       48 89 50 18             mov    %rdx,0x18(%rax)
    0.00 :	  4ad5f0:       48 8b 51 20             mov    0x20(%rcx),%rdx
    0.00 :	  4ad5f4:       48 89 50 20             mov    %rdx,0x20(%rax)
    0.00 :	  4ad5f8:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  4ad5fc:       48 89 50 28             mov    %rdx,0x28(%rax)
    0.00 :	  4ad600:       48 8b 51 30             mov    0x30(%rcx),%rdx
    0.00 :	  4ad604:       48 89 50 30             mov    %rdx,0x30(%rax)
    0.00 :	  4ad608:       48 8b 51 38             mov    0x38(%rcx),%rdx
    0.00 :	  4ad60c:       48 89 50 38             mov    %rdx,0x38(%rax)
    0.00 :	  4ad610:       48 8b 51 40             mov    0x40(%rcx),%rdx
    0.00 :	  4ad614:       48 89 50 40             mov    %rdx,0x40(%rax)
         :	                                        keysCount++;
         :	                                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ad618:       f6 01 10                testb  $0x10,(%rcx)
    0.00 :	  4ad61b:       0f 84 6f ff ff ff       je     4ad590 <_bt_first+0x300>
    0.00 :	  4ad621:       41 89 f7                mov    %esi,%r15d
         :	         *
         :	         * If goback = true, we will then step back one item, while if
         :	         * goback = false, we will start the scan on the located item.
         :	         *----------
         :	         */
         :	        switch (strat_total)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:858
    7.14 :	  4ad624:       66 83 bd be ec ff ff    cmpw   $0x5,-0x1342(%rbp)
    0.00 :	  4ad62b:       05 
    0.00 :	  4ad62c:       0f 86 4e 02 00 00       jbe    4ad880 <_bt_first+0x5f0>
         :	                        goback = false;
         :	                        break;
         :
         :	                default:
         :	                        /* can't get here, but keep compiler quiet */
         :	                        elog(ERROR, "unrecognized strat_total: %d", (int) strat_total);
    0.00 :	  4ad632:       ba df 48 7b 00          mov    $0x7b48df,%edx
    0.00 :	  4ad637:       be a4 03 00 00          mov    $0x3a4,%esi
    0.00 :	  4ad63c:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4ad641:       e8 da dd 2c 00          callq  77b420 <elog_start>
    0.00 :	  4ad646:       0f b7 95 be ec ff ff    movzwl -0x1342(%rbp),%edx
    0.00 :	  4ad64d:       be 97 47 7b 00          mov    $0x7b4797,%esi
    0.00 :	  4ad652:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ad657:       31 c0                   xor    %eax,%eax
    0.00 :	  4ad659:       e8 d2 db 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4ad65e:       e8 6d be fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4ad663:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                        ((impliesNN->sk_flags & SK_BT_NULLS_FIRST) ?
         :	                                         ScanDirectionIsForward(dir) :
         :	                                         ScanDirectionIsBackward(dir)))
         :	                                {
         :	                                        /* Yes, so build the key in notnullkeys[keysCount] */
         :	                                        chosen = &notnullkeys[keysCount];
    0.00 :	  4ad668:       49 63 c7                movslq %r15d,%rax
         :	                                        ScanKeyEntryInitialize(chosen,
    0.00 :	  4ad66b:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  4ad66e:       41 0f bf d6             movswl %r14w,%edx
         :	                                        ((impliesNN->sk_flags & SK_BT_NULLS_FIRST) ?
         :	                                         ScanDirectionIsForward(dir) :
         :	                                         ScanDirectionIsBackward(dir)))
         :	                                {
         :	                                        /* Yes, so build the key in notnullkeys[keysCount] */
         :	                                        chosen = &notnullkeys[keysCount];
    0.00 :	  4ad672:       48 8d 04 c0             lea    (%rax,%rax,8),%rax
         :	                                        ScanKeyEntryInitialize(chosen,
    0.00 :	  4ad676:       19 c9                   sbb    %ecx,%ecx
    0.00 :	  4ad678:       81 e6 00 00 00 03       and    $0x3000000,%esi
    0.00 :	  4ad67e:       83 e1 fc                and    $0xfffffffc,%ecx
    0.00 :	  4ad681:       40 80 ce 81             or     $0x81,%sil
    0.00 :	  4ad685:       45 31 c9                xor    %r9d,%r9d
         :	                                        ((impliesNN->sk_flags & SK_BT_NULLS_FIRST) ?
         :	                                         ScanDirectionIsForward(dir) :
         :	                                         ScanDirectionIsBackward(dir)))
         :	                                {
         :	                                        /* Yes, so build the key in notnullkeys[keysCount] */
         :	                                        chosen = &notnullkeys[keysCount];
    0.00 :	  4ad688:       48 8d 9c c5 c0 ec ff    lea    -0x1340(%rbp,%rax,8),%rbx
    0.00 :	  4ad68f:       ff 
         :	                                        ScanKeyEntryInitialize(chosen,
    0.00 :	  4ad690:       83 c1 05                add    $0x5,%ecx
    0.00 :	  4ad693:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4ad696:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
    0.00 :	  4ad69d:       00 00 
    0.00 :	  4ad69f:       c7 04 24 00 00 00 00    movl   $0x0,(%rsp)
    0.00 :	  4ad6a6:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4ad6a9:       e8 02 65 fc ff          callq  473bb0 <ScanKeyEntryInitialize>
         :
         :	                                /*
         :	                                 * If we still didn't find a usable boundary key, quit; else
         :	                                 * save the boundary key pointer in startKeys.
         :	                                 */
         :	                                if (chosen == NULL)
    0.00 :	  4ad6ae:       48 85 db                test   %rbx,%rbx
    0.00 :	  4ad6b1:       0f 85 83 fc ff ff       jne    4ad33a <_bt_first+0xaa>
    0.00 :	  4ad6b7:       e9 a3 fd ff ff          jmpq   4ad45f <_bt_first+0x1cf>
    0.00 :	  4ad6bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        {
         :	                                /*
         :	                                 * Done looking at keys for curattr.  If we didn't find a
         :	                                 * usable boundary key, see if we can deduce a NOT NULL key.
         :	                                 */
         :	                                if (chosen == NULL && impliesNN != NULL &&
    0.00 :	  4ad6c0:       83 bd 9c ec ff ff ff    cmpl   $0xffffffff,-0x1364(%rbp)
    0.00 :	  4ad6c7:       0f 94 c0                sete   %al
    0.00 :	  4ad6ca:       e9 88 fd ff ff          jmpq   4ad457 <_bt_first+0x1c7>
    0.00 :	  4ad6cf:       90                      nop
         :	                        }
         :	                        else
         :	                        {
         :	                                RegProcedure cmp_proc;
         :
         :	                                cmp_proc = get_opfamily_proc(rel->rd_opfamily[i],
    0.00 :	  4ad6d0:       48 8b 8d a8 ec ff ff    mov    -0x1358(%rbp),%rcx
    0.00 :	  4ad6d7:       48 8b 81 c8 00 00 00    mov    0xc8(%rcx),%rax
    0.00 :	  4ad6de:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ad6e3:       42 8b 3c 30             mov    (%rax,%r14,1),%edi
    0.00 :	  4ad6e7:       e8 c4 51 2c 00          callq  7728b0 <get_opfamily_proc>
         :	                                                                                         rel->rd_opcintype[i],
         :	                                                                                         cur->sk_subtype,
         :	                                                                                         BTORDER_PROC);
         :	                                if (!RegProcedureIsValid(cmp_proc))
    0.00 :	  4ad6ec:       85 c0                   test   %eax,%eax
         :	                        }
         :	                        else
         :	                        {
         :	                                RegProcedure cmp_proc;
         :
         :	                                cmp_proc = get_opfamily_proc(rel->rd_opfamily[i],
    0.00 :	  4ad6ee:       89 c1                   mov    %eax,%ecx
         :	                                                                                         rel->rd_opcintype[i],
         :	                                                                                         cur->sk_subtype,
         :	                                                                                         BTORDER_PROC);
         :	                                if (!RegProcedureIsValid(cmp_proc))
    0.00 :	  4ad6f0:       0f 84 4e 04 00 00       je     4adb44 <_bt_first+0x8b4>
         :	                                        elog(ERROR, "missing support function %d(%u,%u) for attribute %d of index \"%s\"",
         :	                                                 BTORDER_PROC, rel->rd_opcintype[i], cur->sk_subtype,
         :	                                                 cur->sk_attno, RelationGetRelationName(rel));
         :	                                ScanKeyEntryInitialize(scankeys + i,
    0.00 :	  4ad6f6:       49 8b 44 24 40          mov    0x40(%r12),%rax
    0.00 :	  4ad6fb:       41 0f bf 54 24 04       movswl 0x4(%r12),%edx
    0.00 :	  4ad701:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4ad704:       45 8b 4c 24 0c          mov    0xc(%r12),%r9d
    0.00 :	  4ad709:       45 8b 44 24 08          mov    0x8(%r12),%r8d
    0.00 :	  4ad70e:       89 0c 24                mov    %ecx,(%rsp)
    0.00 :	  4ad711:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4ad713:       48 89 44 24 08          mov    %rax,0x8(%rsp)
    0.00 :	  4ad718:       41 8b 34 24             mov    (%r12),%esi
    0.00 :	  4ad71c:       e8 8f 64 fc ff          callq  473bb0 <ScanKeyEntryInitialize>
    0.00 :	  4ad721:       e9 d3 fd ff ff          jmpq   4ad4f9 <_bt_first+0x269>
    0.00 :	  4ad726:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ad72d:       00 00 00 
         :	 * same as for _bt_first().
         :	 */
         :	static bool
         :	_bt_endpoint(IndexScanDesc scan, ScanDirection dir)
         :	{
         :	        Relation        rel = scan->indexRelation;
    0.00 :	  4ad730:       48 8b 95 a0 ec ff ff    mov    -0x1360(%rbp),%rdx
    0.00 :	  4ad737:       4c 8b 6a 08             mov    0x8(%rdx),%r13
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4ad73b:       4c 8b 72 38             mov    0x38(%rdx),%r14
         :	        /*
         :	         * Scan down to the leftmost or rightmost leaf page.  This is a simplified
         :	         * version of _bt_search().  We don't maintain a stack since we know we
         :	         * won't need it.
         :	         */
         :	        buf = _bt_get_endpoint(rel, 0, ScanDirectionIsBackward(dir));
    0.00 :	  4ad73f:       31 d2                   xor    %edx,%edx
    0.00 :	  4ad741:       83 bd 9c ec ff ff ff    cmpl   $0xffffffff,-0x1364(%rbp)
    0.00 :	  4ad748:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad74b:       0f 94 c2                sete   %dl
    0.00 :	  4ad74e:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad750:       e8 eb ea ff ff          callq  4ac240 <_bt_get_endpoint>
         :
         :	        if (!BufferIsValid(buf))
    0.00 :	  4ad755:       85 c0                   test   %eax,%eax
         :	        /*
         :	         * Scan down to the leftmost or rightmost leaf page.  This is a simplified
         :	         * version of _bt_search().  We don't maintain a stack since we know we
         :	         * won't need it.
         :	         */
         :	        buf = _bt_get_endpoint(rel, 0, ScanDirectionIsBackward(dir));
    0.00 :	  4ad757:       41 89 c4                mov    %eax,%r12d
         :
         :	        if (!BufferIsValid(buf))
    0.00 :	  4ad75a:       0f 84 3c 01 00 00       je     4ad89c <_bt_first+0x60c>
         :	                PredicateLockRelation(rel, scan->xs_snapshot);
         :	                so->currPos.buf = InvalidBuffer;
         :	                return false;
         :	        }
         :
         :	        PredicateLockPage(rel, BufferGetBlockNumber(buf), scan->xs_snapshot);
    0.00 :	  4ad760:       48 8b 85 a0 ec ff ff    mov    -0x1360(%rbp),%rax
    0.00 :	  4ad767:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4ad76a:       48 8b 58 10             mov    0x10(%rax),%rbx
    0.00 :	  4ad76e:       e8 bd 68 1c 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  4ad773:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad776:       89 c6                   mov    %eax,%esi
    0.00 :	  4ad778:       48 89 da                mov    %rbx,%rdx
    0.00 :	  4ad77b:       e8 e0 5a 1e 00          callq  693260 <PredicateLockPage>
         :	        page = BufferGetPage(buf);
    0.00 :	  4ad780:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4ad783:       0f 88 91 03 00 00       js     4adb1a <_bt_first+0x88a>
    0.00 :	  4ad789:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4ad78e:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ad791:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ad795:       48 03 15 5c 23 71 00    add    0x71235c(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	        Assert(P_ISLEAF(opaque));
         :
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ad79c:       83 bd 9c ec ff ff 01    cmpl   $0x1,-0x1364(%rbp)
         :	                return false;
         :	        }
         :
         :	        PredicateLockPage(rel, BufferGetBlockNumber(buf), scan->xs_snapshot);
         :	        page = BufferGetPage(buf);
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ad7a3:       0f b7 42 10             movzwl 0x10(%rdx),%eax
         :	        Assert(P_ISLEAF(opaque));
         :
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ad7a7:       0f 84 4d 03 00 00       je     4adafa <_bt_first+0x86a>
         :	                /* There could be dead pages to the left, so not this: */
         :	                /* Assert(P_LEFTMOST(opaque)); */
         :
         :	                start = P_FIRSTDATAKEY(opaque);
         :	        }
         :	        else if (ScanDirectionIsBackward(dir))
    0.00 :	  4ad7ad:       83 bd 9c ec ff ff ff    cmpl   $0xffffffff,-0x1364(%rbp)
    0.00 :	  4ad7b4:       0f 85 ff 03 00 00       jne    4adbb9 <_bt_first+0x929>
         :	        {
         :	                Assert(P_RIGHTMOST(opaque));
         :
         :	                start = PageGetMaxOffsetNumber(page);
    0.00 :	  4ad7ba:       0f b7 42 0c             movzwl 0xc(%rdx),%eax
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ad7be:       31 d2                   xor    %edx,%edx
         :	        }
         :	        else if (ScanDirectionIsBackward(dir))
         :	        {
         :	                Assert(P_RIGHTMOST(opaque));
         :
         :	                start = PageGetMaxOffsetNumber(page);
    0.00 :	  4ad7c0:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4ad7c4:       0f 87 f4 00 00 00       ja     4ad8be <_bt_first+0x62e>
         :	                elog(ERROR, "invalid scan direction: %d", (int) dir);
         :	                start = 0;                              /* keep compiler quiet */
         :	        }
         :
         :	        /* remember which buffer we have pinned */
         :	        so->currPos.buf = buf;
    0.00 :	  4ad7ca:       45 89 66 54             mov    %r12d,0x54(%r14)
         :	                so->currPos.moreLeft = false;
         :	                so->currPos.moreRight = true;
         :	        }
         :	        else
         :	        {
         :	                so->currPos.moreLeft = true;
    0.00 :	  4ad7ce:       41 c6 46 5c 01          movb   $0x1,0x5c(%r14)
         :	                so->currPos.moreRight = false;
    0.00 :	  4ad7d3:       41 c6 46 5d 00          movb   $0x0,0x5d(%r14)
         :	        }
         :	        so->numKilled = 0;                      /* just paranoia */
    0.00 :	  4ad7d8:       41 c7 46 38 00 00 00    movl   $0x0,0x38(%r14)
    0.00 :	  4ad7df:       00 
         :	        so->markItemIndex = -1;         /* ditto */
    0.00 :	  4ad7e0:       41 c7 46 50 ff ff ff    movl   $0xffffffff,0x50(%r14)
    0.00 :	  4ad7e7:       ff 
         :
         :	        /*
         :	         * Now load data from the first page of the scan.
         :	         */
         :	        if (!_bt_readpage(scan, dir, start))
    0.00 :	  4ad7e8:       8b b5 9c ec ff ff       mov    -0x1364(%rbp),%esi
    0.00 :	  4ad7ee:       48 8b bd a0 ec ff ff    mov    -0x1360(%rbp),%rdi
    0.00 :	  4ad7f5:       e8 e6 eb ff ff          callq  4ac3e0 <_bt_readpage>
    0.00 :	  4ad7fa:       84 c0                   test   %al,%al
    0.00 :	  4ad7fc:       75 1c                   jne    4ad81a <_bt_first+0x58a>
         :	        {
         :	                /*
         :	                 * There's no actually-matching data on this page.  Try to advance to
         :	                 * the next page.  Return false if there's no matching data at all.
         :	                 */
         :	                if (!_bt_steppage(scan, dir))
    0.00 :	  4ad7fe:       8b b5 9c ec ff ff       mov    -0x1364(%rbp),%esi
    0.00 :	  4ad804:       48 8b bd a0 ec ff ff    mov    -0x1360(%rbp),%rdi
    0.00 :	  4ad80b:       e8 70 ee ff ff          callq  4ac680 <_bt_steppage>
    0.00 :	  4ad810:       31 d2                   xor    %edx,%edx
    0.00 :	  4ad812:       84 c0                   test   %al,%al
    0.00 :	  4ad814:       0f 84 a8 fb ff ff       je     4ad3c2 <_bt_first+0x132>
         :	                        return false;
         :	        }
         :
         :	        /* Drop the lock, but not pin, on the current page */
         :	        LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4ad81a:       41 8b 7e 54             mov    0x54(%r14),%edi
    0.00 :	  4ad81e:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad820:       e8 eb 6e 1c 00          callq  674710 <LockBuffer>
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
    0.00 :	  4ad825:       49 63 46 6c             movslq 0x6c(%r14),%rax
         :	        scan->xs_ctup.t_self = currItem->heapTid;
    0.00 :	  4ad829:       48 8b 95 a0 ec ff ff    mov    -0x1360(%rbp),%rdx
    0.00 :	  4ad830:       48 8d 04 80             lea    (%rax,%rax,4),%rax
    0.00 :	  4ad834:       49 8d 4c 46 60          lea    0x60(%r14,%rax,2),%rcx
    0.00 :	  4ad839:       8b 41 10                mov    0x10(%rcx),%eax
    0.00 :	  4ad83c:       89 42 54                mov    %eax,0x54(%rdx)
    0.00 :	  4ad83f:       0f b7 41 14             movzwl 0x14(%rcx),%eax
    0.00 :	  4ad843:       66 89 42 58             mov    %ax,0x58(%rdx)
         :	        if (scan->xs_want_itup)
    0.00 :	  4ad847:       48 8b 85 a0 ec ff ff    mov    -0x1360(%rbp),%rax
    0.00 :	  4ad84e:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ad853:       80 78 30 00             cmpb   $0x0,0x30(%rax)
    0.00 :	  4ad857:       0f 84 65 fb ff ff       je     4ad3c2 <_bt_first+0x132>
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ad85d:       0f b7 41 18             movzwl 0x18(%rcx),%eax
    0.00 :	  4ad861:       48 8b 95 a0 ec ff ff    mov    -0x1360(%rbp),%rdx
    0.00 :	  4ad868:       49 03 46 40             add    0x40(%r14),%rax
    0.00 :	  4ad86c:       48 89 42 40             mov    %rax,0x40(%rdx)
    0.00 :	  4ad870:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ad875:       e9 48 fb ff ff          jmpq   4ad3c2 <_bt_first+0x132>
    0.00 :	  4ad87a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         *
         :	         * If goback = true, we will then step back one item, while if
         :	         * goback = false, we will start the scan on the located item.
         :	         *----------
         :	         */
         :	        switch (strat_total)
    0.00 :	  4ad880:       0f b7 85 be ec ff ff    movzwl -0x1342(%rbp),%eax
    0.00 :	  4ad887:       ff 24 c5 90 48 7b 00    jmpq   *0x7b4890(,%rax,8)
    0.00 :	  4ad88e:       66 90                   xchg   %ax,%ax
         :	                                                else
         :	                                                        impliesNN = cur;
         :	                                        }
         :	                                        break;
         :	                        }
         :	                }
    0.00 :	  4ad890:       66 89 85 be ec ff ff    mov    %ax,-0x1342(%rbp)
    0.00 :	  4ad897:       e9 c3 fb ff ff          jmpq   4ad45f <_bt_first+0x1cf>
         :	        {
         :	                /*
         :	                 * Empty index. Lock the whole relation, as nothing finer to lock
         :	                 * exists.
         :	                 */
         :	                PredicateLockRelation(rel, scan->xs_snapshot);
    0.00 :	  4ad89c:       48 8b 8d a0 ec ff ff    mov    -0x1360(%rbp),%rcx
    0.00 :	  4ad8a3:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad8a6:       48 8b 71 10             mov    0x10(%rcx),%rsi
    0.00 :	  4ad8aa:       e8 21 6d 1e 00          callq  6945d0 <PredicateLockRelation>
         :	                so->currPos.buf = InvalidBuffer;
    0.00 :	  4ad8af:       41 c7 46 54 00 00 00    movl   $0x0,0x54(%r14)
    0.00 :	  4ad8b6:       00 
    0.00 :	  4ad8b7:       31 d2                   xor    %edx,%edx
    0.00 :	  4ad8b9:       e9 04 fb ff ff          jmpq   4ad3c2 <_bt_first+0x132>
         :	        }
         :	        else if (ScanDirectionIsBackward(dir))
         :	        {
         :	                Assert(P_RIGHTMOST(opaque));
         :
         :	                start = PageGetMaxOffsetNumber(page);
    0.00 :	  4ad8be:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4ad8c1:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4ad8c5:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4ad8c9:       0f b7 d0                movzwl %ax,%edx
    0.00 :	  4ad8cc:       e9 f9 fe ff ff          jmpq   4ad7ca <_bt_first+0x53a>
    0.00 :	  4ad8d1:       48 8d 95 c0 f5 ff ff    lea    -0xa40(%rbp),%rdx
         :	         *
         :	         * If goback = true, we will then step back one item, while if
         :	         * goback = false, we will start the scan on the located item.
         :	         *----------
         :	         */
         :	        switch (strat_total)
    0.00 :	  4ad8d8:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ad8db:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  4ad8e1:       48 89 95 90 ec ff ff    mov    %rdx,-0x1370(%rbp)
    0.00 :	  4ad8e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4ad8ef:       00 
         :
         :	        /*
         :	         * Use the manufactured insertion scan key to descend the tree and
         :	         * position ourselves on the target leaf page.
         :	         */
         :	        stack = _bt_search(rel, keysCount, scankeys, nextkey, &buf, BT_READ);
    0.00 :	  4ad8f0:       48 8b 95 90 ec ff ff    mov    -0x1370(%rbp),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:940
    7.14 :	  4ad8f7:       48 8b bd a8 ec ff ff    mov    -0x1358(%rbp),%rdi
    0.00 :	  4ad8fe:       4c 8d 45 cc             lea    -0x34(%rbp),%r8
    0.00 :	  4ad902:       44 89 e1                mov    %r12d,%ecx
    0.00 :	  4ad905:       41 b9 01 00 00 00       mov    $0x1,%r9d
    0.00 :	  4ad90b:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4ad90e:       e8 ed f7 ff ff          callq  4ad100 <_bt_search>
    0.00 :	  4ad913:       48 89 c7                mov    %rax,%rdi
         :
         :	        /* don't need to keep the stack around... */
         :	        _bt_freestack(stack);
    0.00 :	  4ad916:       e8 55 1f 00 00          callq  4af870 <_bt_freestack>
         :
         :	        /* remember which buffer we have pinned, if any */
         :	        so->currPos.buf = buf;
    0.00 :	  4ad91b:       8b 45 cc                mov    -0x34(%rbp),%eax
    0.00 :	  4ad91e:       48 8b 8d b0 ec ff ff    mov    -0x1350(%rbp),%rcx
    0.00 :	  4ad925:       89 41 54                mov    %eax,0x54(%rcx)
         :
         :	        if (!BufferIsValid(buf))
    0.00 :	  4ad928:       8b 7d cc                mov    -0x34(%rbp),%edi
    0.00 :	  4ad92b:       85 ff                   test   %edi,%edi
    0.00 :	  4ad92d:       0f 84 95 01 00 00       je     4adac8 <_bt_first+0x838>
         :	                 */
         :	                PredicateLockRelation(rel, scan->xs_snapshot);
         :	                return false;
         :	        }
         :	        else
         :	                PredicateLockPage(rel, BufferGetBlockNumber(buf),
    0.00 :	  4ad933:       48 8b 95 a0 ec ff ff    mov    -0x1360(%rbp),%rdx
    0.00 :	  4ad93a:       48 8b 5a 10             mov    0x10(%rdx),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:958
    7.14 :	  4ad93e:       e8 ed 66 1c 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  4ad943:       48 8b bd a8 ec ff ff    mov    -0x1358(%rbp),%rdi
    0.00 :	  4ad94a:       89 c6                   mov    %eax,%esi
    0.00 :	  4ad94c:       48 89 da                mov    %rbx,%rdx
    0.00 :	  4ad94f:       e8 0c 59 1e 00          callq  693260 <PredicateLockPage>
         :	                                                  scan->xs_snapshot);
         :
         :	        /* initialize moreLeft/moreRight appropriately for scan direction */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ad954:       83 bd 9c ec ff ff 01    cmpl   $0x1,-0x1364(%rbp)
    0.00 :	  4ad95b:       0f 84 85 01 00 00       je     4adae6 <_bt_first+0x856>
         :	                so->currPos.moreLeft = false;
         :	                so->currPos.moreRight = true;
         :	        }
         :	        else
         :	        {
         :	                so->currPos.moreLeft = true;
    0.00 :	  4ad961:       48 8b 85 b0 ec ff ff    mov    -0x1350(%rbp),%rax
    0.00 :	  4ad968:       c6 40 5c 01             movb   $0x1,0x5c(%rax)
         :	                so->currPos.moreRight = false;
    0.00 :	  4ad96c:       c6 40 5d 00             movb   $0x0,0x5d(%rax)
         :	        }
         :	        so->numKilled = 0;                      /* just paranoia */
    0.00 :	  4ad970:       48 8b 95 b0 ec ff ff    mov    -0x1350(%rbp),%rdx
         :	        so->markItemIndex = -1;         /* ditto */
         :
         :	        /* position to the precise item on the page */
         :	        offnum = _bt_binsrch(rel, buf, keysCount, scankeys, nextkey);
    0.00 :	  4ad977:       45 89 e0                mov    %r12d,%r8d
         :	        else
         :	        {
         :	                so->currPos.moreLeft = true;
         :	                so->currPos.moreRight = false;
         :	        }
         :	        so->numKilled = 0;                      /* just paranoia */
    0.00 :	  4ad97a:       c7 42 38 00 00 00 00    movl   $0x0,0x38(%rdx)
         :	        so->markItemIndex = -1;         /* ditto */
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:973
    7.14 :	  4ad981:       c7 42 50 ff ff ff ff    movl   $0xffffffff,0x50(%rdx)
         :
         :	        /* position to the precise item on the page */
         :	        offnum = _bt_binsrch(rel, buf, keysCount, scankeys, nextkey);
    0.00 :	  4ad988:       44 89 fa                mov    %r15d,%edx
    0.00 :	  4ad98b:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  4ad98e:       48 8b 8d 90 ec ff ff    mov    -0x1370(%rbp),%rcx
    0.00 :	  4ad995:       48 8b bd a8 ec ff ff    mov    -0x1358(%rbp),%rdi
    0.00 :	  4ad99c:       e8 bf f4 ff ff          callq  4ace60 <_bt_binsrch>
         :	         * this results in an offset before the first item or after the last one,
         :	         * _bt_readpage will report no items found, and then we'll step to the
         :	         * next page as needed.)
         :	         */
         :	        if (goback)
         :	                offnum = OffsetNumberPrev(offnum);
    0.00 :	  4ad9a1:       41 80 fd 01             cmp    $0x1,%r13b
         :
         :	        /*
         :	         * Now load data from the first page of the scan.
         :	         */
         :	        if (!_bt_readpage(scan, dir, offnum))
    0.00 :	  4ad9a5:       8b b5 9c ec ff ff       mov    -0x1364(%rbp),%esi
    0.00 :	  4ad9ab:       48 8b bd a0 ec ff ff    mov    -0x1360(%rbp),%rdi
         :	         * this results in an offset before the first item or after the last one,
         :	         * _bt_readpage will report no items found, and then we'll step to the
         :	         * next page as needed.)
         :	         */
         :	        if (goback)
         :	                offnum = OffsetNumberPrev(offnum);
    0.00 :	  4ad9b2:       66 83 d0 ff             adc    $0xffff,%ax
         :
         :	        /*
         :	         * Now load data from the first page of the scan.
         :	         */
         :	        if (!_bt_readpage(scan, dir, offnum))
    0.00 :	  4ad9b6:       0f b7 d0                movzwl %ax,%edx
    0.00 :	  4ad9b9:       e8 22 ea ff ff          callq  4ac3e0 <_bt_readpage>
    0.00 :	  4ad9be:       84 c0                   test   %al,%al
    0.00 :	  4ad9c0:       75 1a                   jne    4ad9dc <_bt_first+0x74c>
         :	        {
         :	                /*
         :	                 * There's no actually-matching data on this page.  Try to advance to
         :	                 * the next page.  Return false if there's no matching data at all.
         :	                 */
         :	                if (!_bt_steppage(scan, dir))
    0.00 :	  4ad9c2:       8b b5 9c ec ff ff       mov    -0x1364(%rbp),%esi
    0.00 :	  4ad9c8:       48 8b bd a0 ec ff ff    mov    -0x1360(%rbp),%rdi
    0.00 :	  4ad9cf:       e8 ac ec ff ff          callq  4ac680 <_bt_steppage>
    0.00 :	  4ad9d4:       84 c0                   test   %al,%al
    0.00 :	  4ad9d6:       0f 84 e4 f9 ff ff       je     4ad3c0 <_bt_first+0x130>
         :	                        return false;
         :	        }
         :
         :	        /* Drop the lock, but not pin, on the current page */
         :	        LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4ad9dc:       48 8b 8d b0 ec ff ff    mov    -0x1350(%rbp),%rcx
    0.00 :	  4ad9e3:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad9e5:       8b 79 54                mov    0x54(%rcx),%edi
    0.00 :	  4ad9e8:       e8 23 6d 1c 00          callq  674710 <LockBuffer>
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
    0.00 :	  4ad9ed:       48 8b 95 b0 ec ff ff    mov    -0x1350(%rbp),%rdx
    0.00 :	  4ad9f4:       48 63 42 6c             movslq 0x6c(%rdx),%rax
         :	        scan->xs_ctup.t_self = currItem->heapTid;
    0.00 :	  4ad9f8:       48 8d 04 80             lea    (%rax,%rax,4),%rax
    0.00 :	  4ad9fc:       48 8d 4c 42 60          lea    0x60(%rdx,%rax,2),%rcx
    0.00 :	  4ada01:       48 8b 95 a0 ec ff ff    mov    -0x1360(%rbp),%rdx
    0.00 :	  4ada08:       8b 41 10                mov    0x10(%rcx),%eax
    0.00 :	  4ada0b:       89 42 54                mov    %eax,0x54(%rdx)
    0.00 :	  4ada0e:       0f b7 41 14             movzwl 0x14(%rcx),%eax
    0.00 :	  4ada12:       66 89 42 58             mov    %ax,0x58(%rdx)
         :	        if (scan->xs_want_itup)
    0.00 :	  4ada16:       48 8b 85 a0 ec ff ff    mov    -0x1360(%rbp),%rax
    0.00 :	  4ada1d:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ada22:       80 78 30 00             cmpb   $0x0,0x30(%rax)
    0.00 :	  4ada26:       0f 84 96 f9 ff ff       je     4ad3c2 <_bt_first+0x132>
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4ada2c:       48 8b 95 b0 ec ff ff    mov    -0x1350(%rbp),%rdx
    0.00 :	  4ada33:       0f b7 41 18             movzwl 0x18(%rcx),%eax
    0.00 :	  4ada37:       48 8b 8d a0 ec ff ff    mov    -0x1360(%rbp),%rcx
    0.00 :	  4ada3e:       48 03 42 40             add    0x40(%rdx),%rax
    0.00 :	  4ada42:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ada47:       48 89 41 40             mov    %rax,0x40(%rcx)
    0.00 :	  4ada4b:       e9 72 f9 ff ff          jmpq   4ad3c2 <_bt_first+0x132>
         :
         :	                        /*
         :	                         * If a backward scan was specified, need to start with last equal
         :	                         * item not first one.
         :	                         */
         :	                        if (ScanDirectionIsBackward(dir))
    0.00 :	  4ada50:       83 bd 9c ec ff ff ff    cmpl   $0xffffffff,-0x1364(%rbp)
    0.00 :	  4ada57:       48 8d 85 c0 f5 ff ff    lea    -0xa40(%rbp),%rax
    0.00 :	  4ada5e:       48 89 85 90 ec ff ff    mov    %rax,-0x1370(%rbp)
    0.00 :	  4ada65:       0f 84 c6 00 00 00       je     4adb31 <_bt_first+0x8a1>
         :	                        goback = false;
         :	                        break;
         :
         :	                default:
         :	                        /* can't get here, but keep compiler quiet */
         :	                        elog(ERROR, "unrecognized strat_total: %d", (int) strat_total);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:932
    7.14 :	  4ada6b:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4ada6e:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  4ada71:       e9 7a fe ff ff          jmpq   4ad8f0 <_bt_first+0x660>
    0.00 :	  4ada76:       48 8d 8d c0 f5 ff ff    lea    -0xa40(%rbp),%rcx
         :	         *
         :	         * If goback = true, we will then step back one item, while if
         :	         * goback = false, we will start the scan on the located item.
         :	         *----------
         :	         */
         :	        switch (strat_total)
    0.00 :	  4ada7d:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  4ada83:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  4ada86:       48 89 8d 90 ec ff ff    mov    %rcx,-0x1370(%rbp)
    0.00 :	  4ada8d:       e9 5e fe ff ff          jmpq   4ad8f0 <_bt_first+0x660>
    0.00 :	  4ada92:       48 8d 8d c0 f5 ff ff    lea    -0xa40(%rbp),%rcx
    0.00 :	  4ada99:       48 89 8d 90 ec ff ff    mov    %rcx,-0x1370(%rbp)
    0.00 :	  4adaa0:       eb c9                   jmp    4ada6b <_bt_first+0x7db>
    0.00 :	  4adaa2:       48 8d 85 c0 f5 ff ff    lea    -0xa40(%rbp),%rax
    0.00 :	  4adaa9:       48 89 85 90 ec ff ff    mov    %rax,-0x1370(%rbp)
         :	                        goback = false;
         :	                        break;
         :
         :	                default:
         :	                        /* can't get here, but keep compiler quiet */
         :	                        elog(ERROR, "unrecognized strat_total: %d", (int) strat_total);
    0.00 :	  4adab0:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  4adab6:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  4adabc:       e9 2f fe ff ff          jmpq   4ad8f0 <_bt_first+0x660>
    0.00 :	  4adac1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                /*
         :	                 * We only get here if the index is completely empty. Lock relation
         :	                 * because nothing finer to lock exists.
         :	                 */
         :	                PredicateLockRelation(rel, scan->xs_snapshot);
    0.00 :	  4adac8:       48 8b 85 a0 ec ff ff    mov    -0x1360(%rbp),%rax
    0.00 :	  4adacf:       48 8b bd a8 ec ff ff    mov    -0x1358(%rbp),%rdi
    0.00 :	  4adad6:       48 8b 70 10             mov    0x10(%rax),%rsi
    0.00 :	  4adada:       e8 f1 6a 1e 00          callq  6945d0 <PredicateLockRelation>
    0.00 :	  4adadf:       31 d2                   xor    %edx,%edx
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
         :
         :	        return true;
         :	}
    0.00 :	  4adae1:       e9 dc f8 ff ff          jmpq   4ad3c2 <_bt_first+0x132>
         :	                                                  scan->xs_snapshot);
         :
         :	        /* initialize moreLeft/moreRight appropriately for scan direction */
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                so->currPos.moreLeft = false;
    0.00 :	  4adae6:       48 8b 8d b0 ec ff ff    mov    -0x1350(%rbp),%rcx
    0.00 :	  4adaed:       c6 41 5c 00             movb   $0x0,0x5c(%rcx)
         :	                so->currPos.moreRight = true;
    0.00 :	  4adaf1:       c6 41 5d 01             movb   $0x1,0x5d(%rcx)
    0.00 :	  4adaf5:       e9 76 fe ff ff          jmpq   4ad970 <_bt_first+0x6e0>
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                /* There could be dead pages to the left, so not this: */
         :	                /* Assert(P_LEFTMOST(opaque)); */
         :
         :	                start = P_FIRSTDATAKEY(opaque);
    0.00 :	  4adafa:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4adafd:       83 7c 02 04 01          cmpl   $0x1,0x4(%rdx,%rax,1)
         :	                elog(ERROR, "invalid scan direction: %d", (int) dir);
         :	                start = 0;                              /* keep compiler quiet */
         :	        }
         :
         :	        /* remember which buffer we have pinned */
         :	        so->currPos.buf = buf;
    0.00 :	  4adb02:       45 89 66 54             mov    %r12d,0x54(%r14)
         :
         :	        /* initialize moreLeft/moreRight appropriately for scan direction */
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                so->currPos.moreLeft = false;
    0.00 :	  4adb06:       41 c6 46 5c 00          movb   $0x0,0x5c(%r14)
         :	                so->currPos.moreRight = true;
    0.00 :	  4adb0b:       41 c6 46 5d 01          movb   $0x1,0x5d(%r14)
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                /* There could be dead pages to the left, so not this: */
         :	                /* Assert(P_LEFTMOST(opaque)); */
         :
         :	                start = P_FIRSTDATAKEY(opaque);
    0.00 :	  4adb10:       19 d2                   sbb    %edx,%edx
    0.00 :	  4adb12:       83 c2 02                add    $0x2,%edx
    0.00 :	  4adb15:       e9 be fc ff ff          jmpq   4ad7d8 <_bt_first+0x548>
         :	                so->currPos.buf = InvalidBuffer;
         :	                return false;
         :	        }
         :
         :	        PredicateLockPage(rel, BufferGetBlockNumber(buf), scan->xs_snapshot);
         :	        page = BufferGetPage(buf);
    0.00 :	  4adb1a:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4adb1d:       48 8b 15 f4 f5 6c 00    mov    0x6cf5f4(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4adb24:       f7 d0                   not    %eax
    0.00 :	  4adb26:       48 98                   cltq   
    0.00 :	  4adb28:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4adb2c:       e9 6b fc ff ff          jmpq   4ad79c <_bt_first+0x50c>
    0.00 :	  4adb31:       48 8d 95 c0 f5 ff ff    lea    -0xa40(%rbp),%rdx
    0.00 :	  4adb38:       48 89 95 90 ec ff ff    mov    %rdx,-0x1370(%rbp)
    0.00 :	  4adb3f:       e9 6c ff ff ff          jmpq   4adab0 <_bt_first+0x820>
         :	                                cmp_proc = get_opfamily_proc(rel->rd_opfamily[i],
         :	                                                                                         rel->rd_opcintype[i],
         :	                                                                                         cur->sk_subtype,
         :	                                                                                         BTORDER_PROC);
         :	                                if (!RegProcedureIsValid(cmp_proc))
         :	                                        elog(ERROR, "missing support function %d(%u,%u) for attribute %d of index \"%s\"",
    0.00 :	  4adb44:       ba df 48 7b 00          mov    $0x7b48df,%edx
    0.00 :	  4adb49:       be 40 03 00 00          mov    $0x340,%esi
    0.00 :	  4adb4e:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4adb53:       e8 c8 d8 2c 00          callq  77b420 <elog_start>
    0.00 :	  4adb58:       48 8b 95 a8 ec ff ff    mov    -0x1358(%rbp),%rdx
    0.00 :	  4adb5f:       45 0f bf 4c 24 04       movswl 0x4(%r12),%r9d
    0.00 :	  4adb65:       be 18 48 7b 00          mov    $0x7b4818,%esi
    0.00 :	  4adb6a:       45 8b 44 24 08          mov    0x8(%r12),%r8d
    0.00 :	  4adb6f:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4adb74:       48 8b 82 d0 00 00 00    mov    0xd0(%rdx),%rax
    0.00 :	  4adb7b:       42 8b 0c 30             mov    (%rax,%r14,1),%ecx
    0.00 :	  4adb7f:       48 8b 42 30             mov    0x30(%rdx),%rax
    0.00 :	  4adb83:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4adb88:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  4adb8c:       31 c0                   xor    %eax,%eax
    0.00 :	  4adb8e:       e8 9d d6 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4adb93:       e8 38 b9 fb ff          callq  4694d0 <abort@plt>
         :	                                                break;
         :	                                        }
         :	                                }
         :	                                if (!used_all_subkeys)
         :	                                {
         :	                                        switch (strat_total)
    0.00 :	  4adb98:       66 83 bd be ec ff ff    cmpw   $0x1,-0x1342(%rbp)
    0.00 :	  4adb9f:       01 
    0.00 :	  4adba0:       0f 84 0a ff ff ff       je     4adab0 <_bt_first+0x820>
    0.00 :	  4adba6:       66 83 bd be ec ff ff    cmpw   $0x5,-0x1342(%rbp)
    0.00 :	  4adbad:       05 
    0.00 :	  4adbae:       0f 85 70 fa ff ff       jne    4ad624 <_bt_first+0x394>
    0.00 :	  4adbb4:       e9 b2 fe ff ff          jmpq   4ada6b <_bt_first+0x7db>
         :
         :	                start = PageGetMaxOffsetNumber(page);
         :	        }
         :	        else
         :	        {
         :	                elog(ERROR, "invalid scan direction: %d", (int) dir);
    0.00 :	  4adbb9:       ba e9 48 7b 00          mov    $0x7b48e9,%edx
    0.00 :	  4adbbe:       be 44 06 00 00          mov    $0x644,%esi
    0.00 :	  4adbc3:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4adbc8:       e8 53 d8 2c 00          callq  77b420 <elog_start>
    0.00 :	  4adbcd:       8b 95 9c ec ff ff       mov    -0x1364(%rbp),%edx
    0.00 :	  4adbd3:       be 7c 47 7b 00          mov    $0x7b477c,%esi
    0.00 :	  4adbd8:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4adbdd:       31 c0                   xor    %eax,%eax
    0.00 :	  4adbdf:       e8 4c d6 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4adbe4:       e8 e7 b8 fb ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   35.71 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:669
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:669
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b16a0 <ExecEvalScalarVarFast>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
   28.57 :	  5b16a0:       55                      push   %rbp
         :	        Var                *variable = (Var *) exprstate->expr;
         :	        TupleTableSlot *slot;
         :	        AttrNumber      attnum;
         :
         :	        if (isDone)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:669
   14.29 :	  5b16a1:       48 85 c9                test   %rcx,%rcx
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        Var                *variable = (Var *) exprstate->expr;
    0.00 :	  5b16a4:       4c 8b 47 08             mov    0x8(%rdi),%r8
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalScalarVarFast(ExprState *exprstate, ExprContext *econtext,
         :	                                          bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:664
    7.14 :	  5b16a8:       48 89 e5                mov    %rsp,%rbp
         :	        Var                *variable = (Var *) exprstate->expr;
         :	        TupleTableSlot *slot;
         :	        AttrNumber      attnum;
         :
         :	        if (isDone)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:669
    7.14 :	  5b16ab:       74 06                   je     5b16b3 <ExecEvalScalarVarFast+0x13>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b16ad:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /* Get the input slot and attribute number we want */
         :	        switch (variable->varno)
    0.00 :	  5b16b3:       41 8b 40 04             mov    0x4(%r8),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:673
   35.71 :	  5b16b7:       3d e8 fd 00 00          cmp    $0xfde8,%eax
    0.00 :	  5b16bc:       74 1a                   je     5b16d8 <ExecEvalScalarVarFast+0x38>
    7.14 :	  5b16be:       3d e9 fd 00 00          cmp    $0xfde9,%eax
    0.00 :	  5b16c3:       74 2b                   je     5b16f0 <ExecEvalScalarVarFast+0x50>
         :
         :	                        /* INDEX_VAR is handled by default case */
         :
         :	                default:                                /* get the tuple from the relation being
         :	                                                                 * scanned */
         :	                        slot = econtext->ecxt_scantuple;
    0.00 :	  5b16c5:       48 8b 7e 08             mov    0x8(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16c9:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16ce:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16cf:       e9 2c dd eb ff          jmpq   46f400 <slot_getattr>
    0.00 :	  5b16d4:       0f 1f 40 00             nopl   0x0(%rax)
         :
         :	        /* Get the input slot and attribute number we want */
         :	        switch (variable->varno)
         :	        {
         :	                case INNER_VAR: /* get the tuple from the inner node */
         :	                        slot = econtext->ecxt_innertuple;
    0.00 :	  5b16d8:       48 8b 7e 10             mov    0x10(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16dc:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16e1:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16e2:       e9 19 dd eb ff          jmpq   46f400 <slot_getattr>
    0.00 :	  5b16e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5b16ee:       00 00 
         :	                case INNER_VAR: /* get the tuple from the inner node */
         :	                        slot = econtext->ecxt_innertuple;
         :	                        break;
         :
         :	                case OUTER_VAR: /* get the tuple from the outer node */
         :	                        slot = econtext->ecxt_outertuple;
    0.00 :	  5b16f0:       48 8b 7e 18             mov    0x18(%rsi),%rdi
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16f4:       41 0f bf 70 08          movswl 0x8(%r8),%esi
         :	}
    0.00 :	  5b16f9:       c9                      leaveq 
         :	        }
         :
         :	        attnum = variable->varattno;
         :
         :	        /* Fetch the value from the slot */
         :	        return slot_getattr(slot, attnum, isNull);
    0.00 :	  5b16fa:       e9 01 dd eb ff          jmpq   46f400 <slot_getattr>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   71.43 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1857
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1872
    7.14 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1901
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000675260 <SyncOneBuffer>:
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1857
    7.14 :	  675260:       55                      push   %rbp
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  675261:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  675266:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  675269:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  67526d:       48 63 df                movslq %edi,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675270:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  675274:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675278:       48 c1 e3 06             shl    $0x6,%rbx
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  67527c:       48 83 ec 20             sub    $0x20,%rsp
         :	        volatile BufferDesc *bufHdr = &BufferDescriptors[buf_id];
    0.00 :	  675280:       48 03 1d 79 a8 54 00    add    0x54a879(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	 *
         :	 * Note: caller must have done ResourceOwnerEnlargeBuffers.
         :	 */
         :	static int
         :	SyncOneBuffer(int buf_id, bool skip_recently_used)
         :	{
    0.00 :	  675287:       41 89 f5                mov    %esi,%r13d
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1870
    7.14 :	  67528a:       48 8d 7b 20             lea    0x20(%rbx),%rdi
    0.00 :	  67528e:       f0 86 07                lock xchg %al,(%rdi)
   71.43 :	  675291:       84 c0                   test   %al,%al
    0.00 :	  675293:       75 5b                   jne    6752f0 <SyncOneBuffer+0x90>
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  675295:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  675298:       85 c0                   test   %eax,%eax
    0.00 :	  67529a:       75 0f                   jne    6752ab <SyncOneBuffer+0x4b>
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1872
    7.14 :	  67529c:       0f b7 43 16             movzwl 0x16(%rbx),%eax
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752a0:       41 bc 02 00 00 00       mov    $0x2,%r12d
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
         :
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
    0.00 :	  6752a6:       66 85 c0                test   %ax,%ax
    0.00 :	  6752a9:       74 08                   je     6752b3 <SyncOneBuffer+0x53>
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
    0.00 :	  6752ab:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752ae:       45 84 ed                test   %r13b,%r13b
    0.00 :	  6752b1:       75 2d                   jne    6752e0 <SyncOneBuffer+0x80>
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
         :	                return result;
         :	        }
         :
         :	        if (!(bufHdr->flags & BM_VALID) || !(bufHdr->flags & BM_DIRTY))
    0.00 :	  6752b3:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752b7:       a8 02                   test   $0x2,%al
    0.00 :	  6752b9:       74 08                   je     6752c3 <SyncOneBuffer+0x63>
    0.00 :	  6752bb:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6752bf:       a8 01                   test   $0x1,%al
    0.00 :	  6752c1:       75 45                   jne    675308 <SyncOneBuffer+0xa8>
         :	        {
         :	                /* It's clean, so nothing to do */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752c3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1901
    7.14 :	  6752c7:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6752ca:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  6752ce:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6752d2:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  6752d6:       c9                      leaveq 
    0.00 :	  6752d7:       c3                      retq   
    0.00 :	  6752d8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  6752df:       00 
         :	        if (bufHdr->refcount == 0 && bufHdr->usage_count == 0)
         :	                result |= BUF_REUSABLE;
         :	        else if (skip_recently_used)
         :	        {
         :	                /* Caller told us not to write recently-used buffers */
         :	                UnlockBufHdr(bufHdr);
    0.00 :	  6752e0:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  6752e3:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  6752e7:       eb de                   jmp    6752c7 <SyncOneBuffer+0x67>
    0.00 :	  6752e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * as we mark pages dirty in access methods *before* logging changes with
         :	         * XLogInsert(): if someone marks the buffer dirty just after our check we
         :	         * don't worry because our checkpoint.redo points before log record for
         :	         * upcoming changes and so we are not required to write such dirty buffer.
         :	         */
         :	        LockBufHdr(bufHdr);
    0.00 :	  6752f0:       ba 4e 07 00 00          mov    $0x74e,%edx
    0.00 :	  6752f5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6752fa:       e8 41 ad 01 00          callq  690040 <s_lock>
    0.00 :	  6752ff:       eb 94                   jmp    675295 <SyncOneBuffer+0x35>
    0.00 :	  675301:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  675308:       48 89 df                mov    %rbx,%rdi
         :	        FlushBuffer(bufHdr, NULL);
         :
         :	        LWLockRelease(bufHdr->content_lock);
         :	        UnpinBuffer(bufHdr, true);
         :
         :	        return result | BUF_WRITTEN;
    0.00 :	  67530b:       41 83 cc 01             or     $0x1,%r12d
         :
         :	        /*
         :	         * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
         :	         * buffer is clean by the time we've locked it.)
         :	         */
         :	        PinBuffer_Locked(bufHdr);
    0.00 :	  67530f:       e8 bc f8 ff ff          callq  674bd0 <PinBuffer_Locked>
         :	        LWLockAcquire(bufHdr->content_lock, LW_SHARED);
    0.00 :	  675314:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675318:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67531d:       e8 ce a7 01 00          callq  68faf0 <LWLockAcquire>
         :
         :	        FlushBuffer(bufHdr, NULL);
    0.00 :	  675322:       31 f6                   xor    %esi,%esi
    0.00 :	  675324:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675327:       e8 24 fc ff ff          callq  674f50 <FlushBuffer>
         :
         :	        LWLockRelease(bufHdr->content_lock);
    0.00 :	  67532c:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  675330:       e8 6b a0 01 00          callq  68f3a0 <LWLockRelease>
         :	        UnpinBuffer(bufHdr, true);
    0.00 :	  675335:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67533a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  67533d:       e8 ee f9 ff ff          callq  674d30 <UnpinBuffer>
         :
         :	        return result | BUF_WRITTEN;
         :	}
    0.00 :	  675342:       eb 83                   jmp    6752c7 <SyncOneBuffer+0x67>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   61.54 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
   23.08 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:397
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:397
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:397
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b43e0 <ExecStoreMinimalTuple>:
         :	 */
         :	TupleTableSlot *
         :	ExecStoreMinimalTuple(MinimalTuple mtup,
         :	                                          TupleTableSlot *slot,
         :	                                          bool shouldFree)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:397
   23.08 :	  5b43e0:       55                      push   %rbp
    7.69 :	  5b43e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b43e4:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  5b43e8:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  5b43ec:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  5b43ef:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  5b43f3:       48 83 ec 20             sub    $0x20,%rsp
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b43f7:       80 7e 05 00             cmpb   $0x0,0x5(%rsi)
         :	 */
         :	TupleTableSlot *
         :	ExecStoreMinimalTuple(MinimalTuple mtup,
         :	                                          TupleTableSlot *slot,
         :	                                          bool shouldFree)
         :	{
    7.69 :	  5b43fb:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5b43fe:       41 89 d5                mov    %edx,%r13d
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b4401:       75 6d                   jne    5b4470 <ExecStoreMinimalTuple+0x90>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b4403:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
    0.00 :	  5b4407:       75 57                   jne    5b4460 <ExecStoreMinimalTuple+0x80>
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b4409:       8b 7b 20                mov    0x20(%rbx),%edi
    0.00 :	  5b440c:       85 ff                   test   %edi,%edi
    0.00 :	  5b440e:       74 05                   je     5b4415 <ExecStoreMinimalTuple+0x35>
         :	                ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4410:       e8 4b 0a 0c 00          callq  674e60 <ReleaseBuffer>
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
    0.00 :	  5b4415:       48 8d 43 40             lea    0x40(%rbx),%rax
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
    0.00 :	  5b4419:       44 88 6b 06             mov    %r13b,0x6(%rbx)
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
    0.00 :	  5b441d:       4c 89 63 38             mov    %r12,0x38(%rbx)
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
         :	                ReleaseBuffer(slot->tts_buffer);
         :
         :	        slot->tts_buffer = InvalidBuffer;
    0.00 :	  5b4421:       c7 43 20 00 00 00 00    movl   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
    0.00 :	  5b4428:       c6 43 04 00             movb   $0x0,0x4(%rbx)
         :	        slot->tts_shouldFree = false;
    0.00 :	  5b442c:       c6 43 05 00             movb   $0x0,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
    0.00 :	  5b4430:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  5b4434:       41 8b 04 24             mov    (%r12),%eax
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:438
   61.54 :	  5b4438:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
         :	        /* no need to set t_self or t_tableOid since we won't allow access */
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b443c:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :	        slot->tts_shouldFree = false;
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
    0.00 :	  5b4443:       83 c0 08                add    $0x8,%eax
    0.00 :	  5b4446:       89 43 40                mov    %eax,0x40(%rbx)
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
    0.00 :	  5b4449:       49 8d 44 24 f8          lea    -0x8(%r12),%rax
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
    0.00 :	  5b444e:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
         :	        slot->tts_shouldFreeMin = shouldFree;
         :	        slot->tts_tuple = &slot->tts_minhdr;
         :	        slot->tts_mintuple = mtup;
         :
         :	        slot->tts_minhdr.t_len = mtup->t_len + MINIMAL_TUPLE_OFFSET;
         :	        slot->tts_minhdr.t_data = (HeapTupleHeader) ((char *) mtup - MINIMAL_TUPLE_OFFSET);
    0.00 :	  5b4452:       48 89 43 50             mov    %rax,0x50(%rbx)
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
    0.00 :	  5b4456:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b4459:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  5b445d:       c9                      leaveq 
    0.00 :	  5b445e:       c3                      retq   
    0.00 :	  5b445f:       90                      nop
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4460:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b4464:       e8 47 a8 eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4469:       eb 9e                   jmp    5b4409 <ExecStoreMinimalTuple+0x29>
    0.00 :	  5b446b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4470:       48 8b 7e 08             mov    0x8(%rsi),%rdi
    0.00 :	  5b4474:       e8 47 a8 eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4479:       eb 88                   jmp    5b4403 <ExecStoreMinimalTuple+0x23>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   15.38 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:373
   15.38 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:359
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:347
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:355
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
    7.69 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b4480 <ExecStoreTuple>:
         :	TupleTableSlot *
         :	ExecStoreTuple(HeapTuple tuple,
         :	                           TupleTableSlot *slot,
         :	                           Buffer buffer,
         :	                           bool shouldFree)
         :	{
    0.00 :	  5b4480:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:334
    7.69 :	  5b4481:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b4484:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    7.69 :	  5b4488:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  5b448c:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  5b448f:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  5b4493:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  5b4497:       48 83 ec 20             sub    $0x20,%rsp
         :	        Assert(BufferIsValid(buffer) ? (!shouldFree) : true);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b449b:       80 7e 05 00             cmpb   $0x0,0x5(%rsi)
         :	TupleTableSlot *
         :	ExecStoreTuple(HeapTuple tuple,
         :	                           TupleTableSlot *slot,
         :	                           Buffer buffer,
         :	                           bool shouldFree)
         :	{
    7.69 :	  5b449f:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5b44a2:       41 89 d4                mov    %edx,%r12d
    7.69 :	  5b44a5:       41 89 cd                mov    %ecx,%r13d
         :	        Assert(BufferIsValid(buffer) ? (!shouldFree) : true);
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:347
    7.69 :	  5b44a8:       0f 85 92 00 00 00       jne    5b4540 <ExecStoreTuple+0xc0>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b44ae:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
    0.00 :	  5b44b2:       75 74                   jne    5b4528 <ExecStoreTuple+0xa8>
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:373
   15.38 :	  5b44b4:       8b 7b 20                mov    0x20(%rbx),%edi
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        /*
         :	         * Store the new tuple into the specified slot.
         :	         */
         :	        slot->tts_isempty = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:355
    7.69 :	  5b44b7:       c6 43 04 00             movb   $0x0,0x4(%rbx)
         :	        slot->tts_shouldFree = shouldFree;
    0.00 :	  5b44bb:       44 88 6b 05             mov    %r13b,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = false;
    0.00 :	  5b44bf:       c6 43 06 00             movb   $0x0,0x6(%rbx)
         :	        slot->tts_tuple = tuple;
    0.00 :	  5b44c3:       4c 89 73 08             mov    %r14,0x8(%rbx)
         :	        slot->tts_mintuple = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:359
   15.38 :	  5b44c7:       48 c7 43 38 00 00 00    movq   $0x0,0x38(%rbx)
    0.00 :	  5b44ce:       00 
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
    0.00 :	  5b44cf:       44 39 e7                cmp    %r12d,%edi
         :	        slot->tts_shouldFreeMin = false;
         :	        slot->tts_tuple = tuple;
         :	        slot->tts_mintuple = NULL;
         :
         :	        /* Mark extracted state invalid */
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b44d2:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :	         * This is coded to optimize the case where the slot previously held a
         :	         * tuple on the same disk page: in that case releasing and re-acquiring
         :	         * the pin is a waste of cycles.  This is a common situation during
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
    0.00 :	  5b44d9:       74 0d                   je     5b44e8 <ExecStoreTuple+0x68>
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b44db:       85 ff                   test   %edi,%edi
    0.00 :	  5b44dd:       75 31                   jne    5b4510 <ExecStoreTuple+0x90>
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b44df:       45 85 e4                test   %r12d,%r12d
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
    0.00 :	  5b44e2:       44 89 63 20             mov    %r12d,0x20(%rbx)
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b44e6:       75 18                   jne    5b4500 <ExecStoreTuple+0x80>
         :	                        IncrBufferRefCount(buffer);
         :	        }
         :
         :	        return slot;
         :	}
    0.00 :	  5b44e8:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b44eb:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  5b44f0:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5b44f4:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:383
    7.69 :	  5b44f9:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    7.69 :	  5b44fe:       c9                      leaveq 
    7.69 :	  5b44ff:       c3                      retq   
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
         :	                        IncrBufferRefCount(buffer);
    0.00 :	  5b4500:       44 89 e7                mov    %r12d,%edi
    0.00 :	  5b4503:       e8 58 06 0c 00          callq  674b60 <IncrBufferRefCount>
    0.00 :	  5b4508:       eb de                   jmp    5b44e8 <ExecStoreTuple+0x68>
    0.00 :	  5b450a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * seqscans, so it's worth troubling over.
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4510:       e8 4b 09 0c 00          callq  674e60 <ReleaseBuffer>
         :	                slot->tts_buffer = buffer;
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b4515:       45 85 e4                test   %r12d,%r12d
         :	         */
         :	        if (slot->tts_buffer != buffer)
         :	        {
         :	                if (BufferIsValid(slot->tts_buffer))
         :	                        ReleaseBuffer(slot->tts_buffer);
         :	                slot->tts_buffer = buffer;
    0.00 :	  5b4518:       44 89 63 20             mov    %r12d,0x20(%rbx)
    0.00 :	  5b451c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                if (BufferIsValid(buffer))
    0.00 :	  5b4520:       74 c6                   je     5b44e8 <ExecStoreTuple+0x68>
    0.00 :	  5b4522:       eb dc                   jmp    5b4500 <ExecStoreTuple+0x80>
    0.00 :	  5b4524:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4528:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b452c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5b4530:       e8 7b a7 eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4535:       e9 7a ff ff ff          jmpq   5b44b4 <ExecStoreTuple+0x34>
    0.00 :	  5b453a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free any old physical tuple belonging to the slot.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4540:       48 8b 7e 08             mov    0x8(%rsi),%rdi
    0.00 :	  5b4544:       e8 77 a7 eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4549:       e9 60 ff ff ff          jmpq   5b44ae <ExecStoreTuple+0x2e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:206
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:179
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:203
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:204
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:212
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:243
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:248
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004acf70 <_bt_moveright>:
         :	                          ScanKey scankey,
         :	                          bool nextkey,
         :	                          bool forupdate,
         :	                          BTStack stack,
         :	                          int access)
         :	{
    0.00 :	  4acf70:       55                      push   %rbp
         :	         * needed.
         :	         *
         :	         * We also have to move right if we followed a link that brought us to a
         :	         * dead page.
         :	         */
         :	        cmpval = nextkey ? 0 : 1;
    0.00 :	  4acf71:       31 c0                   xor    %eax,%eax
         :	                          ScanKey scankey,
         :	                          bool nextkey,
         :	                          bool forupdate,
         :	                          BTStack stack,
         :	                          int access)
         :	{
    0.00 :	  4acf73:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:179
    8.33 :	  4acf76:       41 57                   push   %r15
    0.00 :	  4acf78:       45 89 cf                mov    %r9d,%r15d
    0.00 :	  4acf7b:       41 56                   push   %r14
    0.00 :	  4acf7d:       41 55                   push   %r13
    0.00 :	  4acf7f:       49 89 fd                mov    %rdi,%r13
    0.00 :	  4acf82:       41 54                   push   %r12
    0.00 :	  4acf84:       41 89 f4                mov    %esi,%r12d
    0.00 :	  4acf87:       53                      push   %rbx
    0.00 :	  4acf88:       48 83 ec 18             sub    $0x18,%rsp
         :	         * needed.
         :	         *
         :	         * We also have to move right if we followed a link that brought us to a
         :	         * dead page.
         :	         */
         :	        cmpval = nextkey ? 0 : 1;
    0.00 :	  4acf8c:       45 84 c0                test   %r8b,%r8b
         :	                          ScanKey scankey,
         :	                          bool nextkey,
         :	                          bool forupdate,
         :	                          BTStack stack,
         :	                          int access)
         :	{
    0.00 :	  4acf8f:       44 8b 75 18             mov    0x18(%rbp),%r14d
         :	         * needed.
         :	         *
         :	         * We also have to move right if we followed a link that brought us to a
         :	         * dead page.
         :	         */
         :	        cmpval = nextkey ? 0 : 1;
    0.00 :	  4acf93:       0f 94 c0                sete   %al
         :	                          ScanKey scankey,
         :	                          bool nextkey,
         :	                          bool forupdate,
         :	                          BTStack stack,
         :	                          int access)
         :	{
    0.00 :	  4acf96:       89 55 cc                mov    %edx,-0x34(%rbp)
    0.00 :	  4acf99:       48 89 4d c0             mov    %rcx,-0x40(%rbp)
         :	         * needed.
         :	         *
         :	         * We also have to move right if we followed a link that brought us to a
         :	         * dead page.
         :	         */
         :	        cmpval = nextkey ? 0 : 1;
    0.00 :	  4acf9d:       89 45 d0                mov    %eax,-0x30(%rbp)
         :
         :	        for (;;)
         :	        {
         :	                page = BufferGetPage(buf);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:203
    8.33 :	  4acfa0:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4acfa3:       78 70                   js     4ad015 <_bt_moveright+0xa5>
    0.00 :	  4acfa5:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4acfaa:       48 63 c8                movslq %eax,%rcx
    0.00 :	  4acfad:       48 c1 e1 0d             shl    $0xd,%rcx
    0.00 :	  4acfb1:       48 03 0d 40 2b 71 00    add    0x712b40(%rip),%rcx        # bbfaf8 <BufferBlocks>
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4acfb8:       0f b7 41 10             movzwl 0x10(%rcx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:204
    8.33 :	  4acfbc:       48 8d 1c 01             lea    (%rcx,%rax,1),%rbx
         :
         :	                if (P_RIGHTMOST(opaque))
    0.00 :	  4acfc0:       8b 53 04                mov    0x4(%rbx),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:206
   50.00 :	  4acfc3:       85 d2                   test   %edx,%edx
    0.00 :	  4acfc5:       74 6f                   je     4ad036 <_bt_moveright+0xc6>
         :	                        break;
         :
         :	                /*
         :	                 * Finish any incomplete splits we encounter along the way.
         :	                 */
         :	                if (forupdate && P_INCOMPLETE_SPLIT(opaque))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:212
    8.33 :	  4acfc7:       45 84 ff                test   %r15b,%r15b
    0.00 :	  4acfca:       0f 84 88 00 00 00       je     4ad058 <_bt_moveright+0xe8>
    0.00 :	  4acfd0:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  4acfd4:       84 c0                   test   %al,%al
    0.00 :	  4acfd6:       0f 88 8c 00 00 00       js     4ad068 <_bt_moveright+0xf8>
         :	                        /* re-acquire the lock in the right mode, and re-check */
         :	                        buf = _bt_getbuf(rel, blkno, access);
         :	                        continue;
         :	                }
         :
         :	                if (P_IGNORE(opaque) || _bt_compare(rel, keysz, scankey, page, P_HIKEY) >= cmpval)
    0.00 :	  4acfdc:       a8 14                   test   $0x14,%al
    0.00 :	  4acfde:       66 90                   xchg   %ax,%ax
    0.00 :	  4acfe0:       75 1d                   jne    4acfff <_bt_moveright+0x8f>
    0.00 :	  4acfe2:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  4acfe6:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  4acfe9:       41 b8 01 00 00 00       mov    $0x1,%r8d
    0.00 :	  4acfef:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4acff2:       e8 59 fc ff ff          callq  4acc50 <_bt_compare>
    0.00 :	  4acff7:       39 45 d0                cmp    %eax,-0x30(%rbp)
    0.00 :	  4acffa:       7f 3a                   jg     4ad036 <_bt_moveright+0xc6>
    0.00 :	  4acffc:       8b 53 04                mov    0x4(%rbx),%edx
         :	                {
         :	                        /* step right one page */
         :	                        buf = _bt_relandgetbuf(rel, buf, opaque->btpo_next, access);
    0.00 :	  4acfff:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4ad002:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  4ad005:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad008:       e8 d3 bf ff ff          callq  4a8fe0 <_bt_relandgetbuf>
    0.00 :	  4ad00d:       41 89 c4                mov    %eax,%r12d
         :	         */
         :	        cmpval = nextkey ? 0 : 1;
         :
         :	        for (;;)
         :	        {
         :	                page = BufferGetPage(buf);
    0.00 :	  4ad010:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4ad013:       79 90                   jns    4acfa5 <_bt_moveright+0x35>
    0.00 :	  4ad015:       48 8b 15 fc 00 6d 00    mov    0x6d00fc(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ad01c:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4ad01f:       f7 d0                   not    %eax
    0.00 :	  4ad021:       48 98                   cltq   
    0.00 :	  4ad023:       48 8b 0c c2             mov    (%rdx,%rax,8),%rcx
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ad027:       0f b7 41 10             movzwl 0x10(%rcx),%eax
    0.00 :	  4ad02b:       48 8d 1c 01             lea    (%rcx,%rax,1),%rbx
         :
         :	                if (P_RIGHTMOST(opaque))
    0.00 :	  4ad02f:       8b 53 04                mov    0x4(%rbx),%edx
    0.00 :	  4ad032:       85 d2                   test   %edx,%edx
    0.00 :	  4ad034:       75 91                   jne    4acfc7 <_bt_moveright+0x57>
         :	                }
         :	                else
         :	                        break;
         :	        }
         :
         :	        if (P_IGNORE(opaque))
    0.00 :	  4ad036:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:243
    8.33 :	  4ad03a:       a8 14                   test   $0x14,%al
    0.00 :	  4ad03c:       0f 85 8f 00 00 00       jne    4ad0d1 <_bt_moveright+0x161>
         :	                elog(ERROR, "fell off the end of index \"%s\"",
         :	                         RelationGetRelationName(rel));
         :
         :	        return buf;
         :	}
    0.00 :	  4ad042:       48 83 c4 18             add    $0x18,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:248
    8.33 :	  4ad046:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4ad049:       5b                      pop    %rbx
    0.00 :	  4ad04a:       41 5c                   pop    %r12
    0.00 :	  4ad04c:       41 5d                   pop    %r13
    0.00 :	  4ad04e:       41 5e                   pop    %r14
    0.00 :	  4ad050:       41 5f                   pop    %r15
    0.00 :	  4ad052:       c9                      leaveq 
    0.00 :	  4ad053:       c3                      retq   
    0.00 :	  4ad054:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        else
         :	                                _bt_relbuf(rel, buf);
         :
         :	                        /* re-acquire the lock in the right mode, and re-check */
         :	                        buf = _bt_getbuf(rel, blkno, access);
         :	                        continue;
    0.00 :	  4ad058:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  4ad05c:       e9 7b ff ff ff          jmpq   4acfdc <_bt_moveright+0x6c>
    0.00 :	  4ad061:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Finish any incomplete splits we encounter along the way.
         :	                 */
         :	                if (forupdate && P_INCOMPLETE_SPLIT(opaque))
         :	                {
         :	                        BlockNumber blkno = BufferGetBlockNumber(buf);
    0.00 :	  4ad068:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4ad06b:       e8 c0 6f 1c 00          callq  674030 <BufferGetBlockNumber>
         :
         :	                        /* upgrade our lock if necessary */
         :	                        if (access == BT_READ)
    0.00 :	  4ad070:       41 83 fe 01             cmp    $0x1,%r14d
         :	                /*
         :	                 * Finish any incomplete splits we encounter along the way.
         :	                 */
         :	                if (forupdate && P_INCOMPLETE_SPLIT(opaque))
         :	                {
         :	                        BlockNumber blkno = BufferGetBlockNumber(buf);
    0.00 :	  4ad074:       89 45 d4                mov    %eax,-0x2c(%rbp)
         :
         :	                        /* upgrade our lock if necessary */
         :	                        if (access == BT_READ)
    0.00 :	  4ad077:       74 3f                   je     4ad0b8 <_bt_moveright+0x148>
         :	                        {
         :	                                LockBuffer(buf, BUFFER_LOCK_UNLOCK);
         :	                                LockBuffer(buf, BT_WRITE);
         :	                        }
         :
         :	                        if (P_INCOMPLETE_SPLIT(opaque))
    0.00 :	  4ad079:       80 7b 0c 00             cmpb   $0x0,0xc(%rbx)
    0.00 :	  4ad07d:       79 29                   jns    4ad0a8 <_bt_moveright+0x138>
         :	                                _bt_finish_split(rel, buf, stack);
    0.00 :	  4ad07f:       48 8b 55 10             mov    0x10(%rbp),%rdx
    0.00 :	  4ad083:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4ad086:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad089:       e8 52 aa ff ff          callq  4a7ae0 <_bt_finish_split>
         :	                        else
         :	                                _bt_relbuf(rel, buf);
         :
         :	                        /* re-acquire the lock in the right mode, and re-check */
         :	                        buf = _bt_getbuf(rel, blkno, access);
    0.00 :	  4ad08e:       8b 75 d4                mov    -0x2c(%rbp),%esi
    0.00 :	  4ad091:       44 89 f2                mov    %r14d,%edx
    0.00 :	  4ad094:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad097:       e8 b4 bf ff ff          callq  4a9050 <_bt_getbuf>
    0.00 :	  4ad09c:       41 89 c4                mov    %eax,%r12d
         :	                        continue;
    0.00 :	  4ad09f:       e9 fc fe ff ff          jmpq   4acfa0 <_bt_moveright+0x30>
    0.00 :	  4ad0a4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        }
         :
         :	                        if (P_INCOMPLETE_SPLIT(opaque))
         :	                                _bt_finish_split(rel, buf, stack);
         :	                        else
         :	                                _bt_relbuf(rel, buf);
    0.00 :	  4ad0a8:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4ad0ab:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ad0ae:       e8 1d bf ff ff          callq  4a8fd0 <_bt_relbuf>
    0.00 :	  4ad0b3:       eb d9                   jmp    4ad08e <_bt_moveright+0x11e>
    0.00 :	  4ad0b5:       0f 1f 00                nopl   (%rax)
         :	                        BlockNumber blkno = BufferGetBlockNumber(buf);
         :
         :	                        /* upgrade our lock if necessary */
         :	                        if (access == BT_READ)
         :	                        {
         :	                                LockBuffer(buf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4ad0b8:       31 f6                   xor    %esi,%esi
    0.00 :	  4ad0ba:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4ad0bd:       e8 4e 76 1c 00          callq  674710 <LockBuffer>
         :	                                LockBuffer(buf, BT_WRITE);
    0.00 :	  4ad0c2:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  4ad0c7:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4ad0ca:       e8 41 76 1c 00          callq  674710 <LockBuffer>
    0.00 :	  4ad0cf:       eb a8                   jmp    4ad079 <_bt_moveright+0x109>
         :	                else
         :	                        break;
         :	        }
         :
         :	        if (P_IGNORE(opaque))
         :	                elog(ERROR, "fell off the end of index \"%s\"",
    0.00 :	  4ad0d1:       ba f6 48 7b 00          mov    $0x7b48f6,%edx
    0.00 :	  4ad0d6:       be f5 00 00 00          mov    $0xf5,%esi
    0.00 :	  4ad0db:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4ad0e0:       e8 3b e3 2c 00          callq  77b420 <elog_start>
    0.00 :	  4ad0e5:       49 8b 55 30             mov    0x30(%r13),%rdx
    0.00 :	  4ad0e9:       be 60 41 7b 00          mov    $0x7b4160,%esi
    0.00 :	  4ad0ee:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ad0f3:       31 c0                   xor    %eax,%eax
    0.00 :	  4ad0f5:       e8 36 e1 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4ad0fa:       e8 d1 c3 fb ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5493
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5386
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5421
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5435
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5265
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5494
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005ad000 <ExecProject>:
         :	 *              data will be valid, he must call ExecMaterializeSlot on the
         :	 *              result slot.
         :	 */
         :	TupleTableSlot *
         :	ExecProject(ProjectionInfo *projInfo, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5386
    8.33 :	  5ad000:       55                      push   %rbp
    0.00 :	  5ad001:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5ad004:       41 57                   push   %r15
    0.00 :	  5ad006:       41 56                   push   %r14
    0.00 :	  5ad008:       41 55                   push   %r13
    0.00 :	  5ad00a:       41 54                   push   %r12
    0.00 :	  5ad00c:       53                      push   %rbx
    0.00 :	  5ad00d:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5ad010:       48 83 ec 48             sub    $0x48,%rsp
    0.00 :	  5ad014:       48 89 75 90             mov    %rsi,-0x70(%rbp)
         :	        Assert(projInfo != NULL);
         :
         :	        /*
         :	         * get the projection info we want
         :	         */
         :	        slot = projInfo->pi_slot;
    0.00 :	  5ad018:       48 8b 47 18             mov    0x18(%rdi),%rax
         :	        econtext = projInfo->pi_exprContext;
         :
         :	        /* Assume single result row until proven otherwise */
         :	        if (isDone)
    0.00 :	  5ad01c:       48 85 f6                test   %rsi,%rsi
         :	        Assert(projInfo != NULL);
         :
         :	        /*
         :	         * get the projection info we want
         :	         */
         :	        slot = projInfo->pi_slot;
    0.00 :	  5ad01f:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :	        econtext = projInfo->pi_exprContext;
    0.00 :	  5ad023:       4c 8b 77 10             mov    0x10(%rdi),%r14
         :
         :	        /* Assume single result row until proven otherwise */
         :	        if (isDone)
    0.00 :	  5ad027:       74 06                   je     5ad02f <ExecProject+0x2f>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5ad029:       c7 06 00 00 00 00       movl   $0x0,(%rsi)
         :	        /*
         :	         * Clear any former contents of the result slot.  This makes it safe for
         :	         * us to use the slot's Datum/isnull arrays as workspace. (Also, we can
         :	         * return the slot as-is if we decide no rows can be projected.)
         :	         */
         :	        ExecClearTuple(slot);
    0.00 :	  5ad02f:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  5ad033:       e8 d8 70 00 00          callq  5b4110 <ExecClearTuple>
         :	        /*
         :	         * Force extraction of all input values that we'll need.  The
         :	         * Var-extraction loops below depend on this, and we are also prefetching
         :	         * all attributes that will be referenced in the generic expressions.
         :	         */
         :	        if (projInfo->pi_lastInnerVar > 0)
    0.00 :	  5ad038:       8b 73 48                mov    0x48(%rbx),%esi
    0.00 :	  5ad03b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad03d:       7e 09                   jle    5ad048 <ExecProject+0x48>
         :	                slot_getsomeattrs(econtext->ecxt_innertuple,
    0.00 :	  5ad03f:       49 8b 7e 10             mov    0x10(%r14),%rdi
    0.00 :	  5ad043:       e8 18 22 ec ff          callq  46f260 <slot_getsomeattrs>
         :	                                                  projInfo->pi_lastInnerVar);
         :	        if (projInfo->pi_lastOuterVar > 0)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5421
    8.33 :	  5ad048:       8b 73 4c                mov    0x4c(%rbx),%esi
    0.00 :	  5ad04b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad04d:       7e 09                   jle    5ad058 <ExecProject+0x58>
         :	                slot_getsomeattrs(econtext->ecxt_outertuple,
    0.00 :	  5ad04f:       49 8b 7e 18             mov    0x18(%r14),%rdi
    0.00 :	  5ad053:       e8 08 22 ec ff          callq  46f260 <slot_getsomeattrs>
         :	                                                  projInfo->pi_lastOuterVar);
         :	        if (projInfo->pi_lastScanVar > 0)
    0.00 :	  5ad058:       8b 73 50                mov    0x50(%rbx),%esi
    0.00 :	  5ad05b:       85 f6                   test   %esi,%esi
    0.00 :	  5ad05d:       7e 09                   jle    5ad068 <ExecProject+0x68>
         :	                slot_getsomeattrs(econtext->ecxt_scantuple,
    0.00 :	  5ad05f:       49 8b 7e 08             mov    0x8(%r14),%rdi
    0.00 :	  5ad063:       e8 f8 21 ec ff          callq  46f260 <slot_getsomeattrs>
         :
         :	        /*
         :	         * Assign simple Vars to result by direct extraction of fields from source
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
    0.00 :	  5ad068:       44 8b 43 2c             mov    0x2c(%rbx),%r8d
         :	        if (numSimpleVars > 0)
    0.00 :	  5ad06c:       45 85 c0                test   %r8d,%r8d
    0.00 :	  5ad06f:       7e 5d                   jle    5ad0ce <ExecProject+0xce>
         :	                bool       *isnull = slot->tts_isnull;
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
         :	                int                *varNumbers = projInfo->pi_varNumbers;
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
    0.00 :	  5ad071:       80 7b 28 00             cmpb   $0x0,0x28(%rbx)
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
         :	        if (numSimpleVars > 0)
         :	        {
         :	                Datum      *values = slot->tts_values;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5435
    8.33 :	  5ad075:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
         :	                bool       *isnull = slot->tts_isnull;
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
    0.00 :	  5ad079:       4c 8b 5b 30             mov    0x30(%rbx),%r11
         :	                int                *varNumbers = projInfo->pi_varNumbers;
    0.00 :	  5ad07d:       4c 8b 53 38             mov    0x38(%rbx),%r10
         :	         * slots ... a mite ugly, but fast ...
         :	         */
         :	        numSimpleVars = projInfo->pi_numSimpleVars;
         :	        if (numSimpleVars > 0)
         :	        {
         :	                Datum      *values = slot->tts_values;
    0.00 :	  5ad081:       4c 8b 6a 28             mov    0x28(%rdx),%r13
         :	                bool       *isnull = slot->tts_isnull;
    0.00 :	  5ad085:       4c 8b 62 30             mov    0x30(%rdx),%r12
         :	                int                *varSlotOffsets = projInfo->pi_varSlotOffsets;
         :	                int                *varNumbers = projInfo->pi_varNumbers;
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
    0.00 :	  5ad089:       0f 84 e1 01 00 00       je     5ad270 <ExecProject+0x270>
    0.00 :	  5ad08f:       4c 89 df                mov    %r11,%rdi
    0.00 :	  5ad092:       31 f6                   xor    %esi,%esi
    0.00 :	  5ad094:       0f 1f 40 00             nopl   0x0(%rax)
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad098:       48 63 07                movslq (%rdi),%rax
         :	                                int                     varNumber = varNumbers[i] - 1;
         :
         :	                                values[i] = varSlot->tts_values[varNumber];
         :	                                isnull[i] = varSlot->tts_isnull[varNumber];
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    8.33 :	  5ad09b:       48 83 c7 04             add    $0x4,%rdi
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad09f:       49 8b 0c 06             mov    (%r14,%rax,1),%rcx
         :	                                int                     varNumber = varNumbers[i] - 1;
         :
         :	                                values[i] = varSlot->tts_values[varNumber];
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5450
    8.33 :	  5ad0a3:       41 8b 04 b2             mov    (%r10,%rsi,4),%eax
    0.00 :	  5ad0a7:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  5ad0ab:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad0ae:       48 98                   cltq   
    0.00 :	  5ad0b0:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    8.33 :	  5ad0b4:       49 89 54 f5 00          mov    %rdx,0x0(%r13,%rsi,8)
         :	                                isnull[i] = varSlot->tts_isnull[varNumber];
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5451
    8.33 :	  5ad0b9:       48 8b 51 30             mov    0x30(%rcx),%rdx
    0.00 :	  5ad0bd:       0f b6 04 02             movzbl (%rdx,%rax,1),%eax
    8.33 :	  5ad0c1:       41 88 04 34             mov    %al,(%r12,%rsi,1)
    0.00 :	  5ad0c5:       48 83 c6 01             add    $0x1,%rsi
         :	                int                     i;
         :
         :	                if (projInfo->pi_directMap)
         :	                {
         :	                        /* especially simple case where vars go to output in order */
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad0c9:       41 39 f0                cmp    %esi,%r8d
    0.00 :	  5ad0cc:       7f ca                   jg     5ad098 <ExecProject+0x98>
         :	         * If there are any generic expressions, evaluate them.  It's possible
         :	         * that there are set-returning functions in such expressions; if so and
         :	         * we have reached the end of the set, we return the result slot, which we
         :	         * already marked empty.
         :	         */
         :	        if (projInfo->pi_targetlist)
    0.00 :	  5ad0ce:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  5ad0d2:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad0d5:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	  5ad0d9:       0f 84 fc 00 00 00       je     5ad1db <ExecProject+0x1db>
         :	        {
         :	                if (!ExecTargetList(projInfo->pi_targetlist,
    0.00 :	  5ad0df:       48 8b 55 b0             mov    -0x50(%rbp),%rdx
    0.00 :	  5ad0e3:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5ad0e7:       4c 8b 7b 20             mov    0x20(%rbx),%r15
    0.00 :	  5ad0eb:       48 8b 52 30             mov    0x30(%rdx),%rdx
    0.00 :	  5ad0ef:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ad0f3:       48 8b 15 66 d7 60 00    mov    0x60d766(%rip),%rdx        # bba860 <CurrentMemoryContext>
    0.00 :	  5ad0fa:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ad0fe:       48 89 55 c8             mov    %rdx,-0x38(%rbp)
    0.00 :	  5ad102:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ad106:       49 8b 46 28             mov    0x28(%r14),%rax
    0.00 :	  5ad10a:       48 89 05 4f d7 60 00    mov    %rax,0x60d74f(%rip)        # bba860 <CurrentMemoryContext>
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5ad111:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5ad115:       4c 8b 68 08             mov    0x8(%rax),%r13
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad119:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad11c:       0f 84 ae 00 00 00       je     5ad1d0 <ExecProject+0x1d0>
    0.00 :	  5ad122:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  5ad126:       eb 15                   jmp    5ad13d <ExecProject+0x13d>
    0.00 :	  5ad128:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ad12f:       00 
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
         :	                                ereport(ERROR,
         :	                                                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
         :	                                                 errmsg("set-valued function called in context that cannot accept a set")));
         :	                        if (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad130:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad134:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad138:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad13b:       74 63                   je     5ad1a0 <ExecProject+0x1a0>
         :	        {
         :	                GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad13d:       49 8b 55 00             mov    0x0(%r13),%rdx
         :	                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                AttrNumber      resind = tle->resno - 1;
         :
         :	                values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad141:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad144:       48 8b 42 08             mov    0x8(%rdx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5265
    8.33 :	  5ad148:       0f b7 58 10             movzwl 0x10(%rax),%ebx
    0.00 :	  5ad14c:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad150:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ad154:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad157:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  5ad15a:       48 0f bf db             movswq %bx,%rbx
    0.00 :	  5ad15e:       4d 8d 24 9f             lea    (%r15,%rbx,4),%r12
    0.00 :	  5ad162:       48 01 da                add    %rbx,%rdx
    0.00 :	  5ad165:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  5ad168:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad16b:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad16f:       48 89 04 da             mov    %rax,(%rdx,%rbx,8)
         :	                                                                          econtext,
         :	                                                                          &isnull[resind],
         :	                                                                          &itemIsDone[resind]);
         :
         :	                if (itemIsDone[resind] != ExprSingleResult)
    0.00 :	  5ad173:       41 8b 04 24             mov    (%r12),%eax
    0.00 :	  5ad177:       85 c0                   test   %eax,%eax
    0.00 :	  5ad179:       74 b9                   je     5ad134 <ExecProject+0x134>
         :	                {
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
    0.00 :	  5ad17b:       48 83 7d 90 00          cmpq   $0x0,-0x70(%rbp)
    0.00 :	  5ad180:       0f 84 fd 01 00 00       je     5ad383 <ExecProject+0x383>
         :	                                ereport(ERROR,
         :	                                                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
         :	                                                 errmsg("set-valued function called in context that cannot accept a set")));
         :	                        if (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad186:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad189:       75 a5                   jne    5ad130 <ExecProject+0x130>
         :	                        {
         :	                                /* we have undone sets in the tlist, set flag */
         :	                                *isDone = ExprMultipleResult;
    0.00 :	  5ad18b:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  5ad18f:       c7 00 01 00 00 00       movl   $0x1,(%rax)
         :	        /*
         :	         * evaluate all the expressions in the target list
         :	         */
         :	        haveDoneSets = false;           /* any exhausted set exprs in tlist? */
         :
         :	        foreach(tl, targetlist)
    0.00 :	  5ad195:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad199:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad19c:       75 9f                   jne    5ad13d <ExecProject+0x13d>
    0.00 :	  5ad19e:       66 90                   xchg   %ax,%ax
         :	                                haveDoneSets = true;
         :	                        }
         :	                }
         :	        }
         :
         :	        if (haveDoneSets)
    0.00 :	  5ad1a0:       80 7d c7 00             cmpb   $0x0,-0x39(%rbp)
    0.00 :	  5ad1a4:       74 2a                   je     5ad1d0 <ExecProject+0x1d0>
         :	        {
         :	                /*
         :	                 * note: can't get here unless we verified isDone != NULL
         :	                 */
         :	                if (*isDone == ExprSingleResult)
    0.00 :	  5ad1a6:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  5ad1aa:       8b 02                   mov    (%rdx),%eax
    0.00 :	  5ad1ac:       85 c0                   test   %eax,%eax
    0.00 :	  5ad1ae:       0f 84 bc 01 00 00       je     5ad370 <ExecProject+0x370>
    0.00 :	  5ad1b4:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5ad1b8:       4c 8b 6a 08             mov    0x8(%rdx),%r13
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad1bc:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad1bf:       75 6f                   jne    5ad230 <ExecProject+0x230>
         :	                         * have to cycle the nonempty sets to completion, else resources
         :	                         * will not be released from subplans etc.
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
    0.00 :	  5ad1c1:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5ad1c4:       0f 84 02 01 00 00       je     5ad2cc <ExecProject+0x2cc>
    0.00 :	  5ad1ca:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5ad1d0:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  5ad1d4:       48 89 05 85 d6 60 00    mov    %rax,0x60d685(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
    0.00 :	  5ad1db:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
         :	}
    0.00 :	  5ad1df:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5ad1e3:       5b                      pop    %rbx
    0.00 :	  5ad1e4:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5494
    8.33 :	  5ad1e6:       41 5d                   pop    %r13
    0.00 :	  5ad1e8:       41 5e                   pop    %r14
    0.00 :	  5ad1ea:       41 5f                   pop    %r15
    0.00 :	  5ad1ec:       c9                      leaveq 
         :
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5493
   16.67 :	  5ad1ed:       e9 2e 68 00 00          jmpq   5b3a20 <ExecStoreVirtualTuple>
    0.00 :	  5ad1f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                AttrNumber      resind = tle->resno - 1;
         :
         :	                                if (itemIsDone[resind] == ExprEndResult)
         :	                                {
         :	                                        values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad1f8:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad1fc:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ad200:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  5ad203:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad206:       48 01 da                add    %rbx,%rdx
    0.00 :	  5ad209:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad20c:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad20f:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad213:       48 89 04 da             mov    %rax,(%rdx,%rbx,8)
         :	                                                                                                  econtext,
         :	                                                                                                  &isnull[resind],
         :	                                                                                                  &itemIsDone[resind]);
         :
         :	                                        if (itemIsDone[resind] == ExprEndResult)
    0.00 :	  5ad217:       41 83 3c 24 02          cmpl   $0x2,(%r12)
    0.00 :	  5ad21c:       0f 84 a0 00 00 00       je     5ad2c2 <ExecProject+0x2c2>
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad222:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad226:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad229:       74 2c                   je     5ad257 <ExecProject+0x257>
    0.00 :	  5ad22b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        {
         :	                                GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad230:       49 8b 55 00             mov    0x0(%r13),%rdx
         :	                                TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                AttrNumber      resind = tle->resno - 1;
         :
         :	                                if (itemIsDone[resind] == ExprEndResult)
    0.00 :	  5ad234:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ad238:       0f b7 40 10             movzwl 0x10(%rax),%eax
    0.00 :	  5ad23c:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad23f:       48 0f bf d8             movswq %ax,%rbx
    0.00 :	  5ad243:       4d 8d 24 9f             lea    (%r15,%rbx,4),%r12
    0.00 :	  5ad247:       41 83 3c 24 02          cmpl   $0x2,(%r12)
    0.00 :	  5ad24c:       74 aa                   je     5ad1f8 <ExecProject+0x1f8>
         :	                {
         :	                        /*
         :	                         * We have some done and some undone sets.  Restart the done ones
         :	                         * so that we can deliver a tuple (if possible).
         :	                         */
         :	                        foreach(tl, targetlist)
    0.00 :	  5ad24e:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5ad252:       4d 85 ed                test   %r13,%r13
    0.00 :	  5ad255:       75 d9                   jne    5ad230 <ExecProject+0x230>
    0.00 :	  5ad257:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  5ad25b:       8b 02                   mov    (%rdx),%eax
         :	                         * have to cycle the nonempty sets to completion, else resources
         :	                         * will not be released from subplans etc.
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
    0.00 :	  5ad25d:       83 f8 02                cmp    $0x2,%eax
    0.00 :	  5ad260:       0f 85 6a ff ff ff       jne    5ad1d0 <ExecProject+0x1d0>
    0.00 :	  5ad266:       eb 64                   jmp    5ad2cc <ExecProject+0x2cc>
    0.00 :	  5ad268:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5ad26f:       00 
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
    0.00 :	  5ad270:       4c 8b 4b 40             mov    0x40(%rbx),%r9
    0.00 :	  5ad274:       31 ff                   xor    %edi,%edi
    0.00 :	  5ad276:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5ad27d:       00 00 00 
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad280:       49 63 04 bb             movslq (%r11,%rdi,4),%rax
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad284:       41 8b 0c b9             mov    (%r9,%rdi,4),%ecx
    0.00 :	  5ad288:       83 e9 01                sub    $0x1,%ecx
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
         :	                        {
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
    0.00 :	  5ad28b:       49 8b 34 06             mov    (%r14,%rax,1),%rsi
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad28f:       41 8b 04 ba             mov    (%r10,%rdi,4),%eax
    0.00 :	  5ad293:       48 63 c9                movslq %ecx,%rcx
         :	                                isnull[varOutputCol] = varSlot->tts_isnull[varNumber];
    0.00 :	  5ad296:       48 83 c7 01             add    $0x1,%rdi
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad29a:       48 8b 56 28             mov    0x28(%rsi),%rdx
    0.00 :	  5ad29e:       83 e8 01                sub    $0x1,%eax
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad2a1:       41 39 f8                cmp    %edi,%r8d
         :	                                char       *slotptr = ((char *) econtext) + varSlotOffsets[i];
         :	                                TupleTableSlot *varSlot = *((TupleTableSlot **) slotptr);
         :	                                int                     varNumber = varNumbers[i] - 1;
         :	                                int                     varOutputCol = varOutputCols[i] - 1;
         :
         :	                                values[varOutputCol] = varSlot->tts_values[varNumber];
    0.00 :	  5ad2a4:       48 98                   cltq   
    0.00 :	  5ad2a6:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  5ad2aa:       49 89 54 cd 00          mov    %rdx,0x0(%r13,%rcx,8)
         :	                                isnull[varOutputCol] = varSlot->tts_isnull[varNumber];
    0.00 :	  5ad2af:       48 8b 56 30             mov    0x30(%rsi),%rdx
    0.00 :	  5ad2b3:       0f b6 04 02             movzbl (%rdx,%rax,1),%eax
    0.00 :	  5ad2b7:       41 88 04 0c             mov    %al,(%r12,%rcx,1)
         :	                else
         :	                {
         :	                        /* we have to pay attention to varOutputCols[] */
         :	                        int                *varOutputCols = projInfo->pi_varOutputCols;
         :
         :	                        for (i = 0; i < numSimpleVars; i++)
    0.00 :	  5ad2bb:       7f c3                   jg     5ad280 <ExecProject+0x280>
    0.00 :	  5ad2bd:       e9 0c fe ff ff          jmpq   5ad0ce <ExecProject+0xce>
         :	                                        {
         :	                                                /*
         :	                                                 * Oh dear, this item is returning an empty set. Guess
         :	                                                 * we can't make a tuple after all.
         :	                                                 */
         :	                                                *isDone = ExprEndResult;
    0.00 :	  5ad2c2:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  5ad2c6:       c7 00 02 00 00 00       movl   $0x2,(%rax)
    0.00 :	  5ad2cc:       48 8b 45 98             mov    -0x68(%rbp),%rax
    0.00 :	  5ad2d0:       48 8b 40 08             mov    0x8(%rax),%rax
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
         :	                        {
         :	                                foreach(tl, targetlist)
    0.00 :	  5ad2d4:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad2d7:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5ad2db:       74 6c                   je     5ad349 <ExecProject+0x349>
    0.00 :	  5ad2dd:       0f 1f 00                nopl   (%rax)
         :	                                {
         :	                                        GenericExprState *gstate = (GenericExprState *) lfirst(tl);
    0.00 :	  5ad2e0:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  5ad2e4:       48 8b 12                mov    (%rdx),%rdx
    0.00 :	  5ad2e7:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	                                        TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                        AttrNumber      resind = tle->resno - 1;
         :
         :	                                        while (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad2eb:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  5ad2ef:       0f b7 40 10             movzwl 0x10(%rax),%eax
    0.00 :	  5ad2f3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ad2f6:       48 0f bf c0             movswq %ax,%rax
    0.00 :	  5ad2fa:       49 8d 1c 87             lea    (%r15,%rax,4),%rbx
    0.00 :	  5ad2fe:       83 3b 01                cmpl   $0x1,(%rbx)
    0.00 :	  5ad301:       75 35                   jne    5ad338 <ExecProject+0x338>
    0.00 :	  5ad303:       48 8b 55 a8             mov    -0x58(%rbp),%rdx
    0.00 :	  5ad307:       4c 8b 65 a0             mov    -0x60(%rbp),%r12
    0.00 :	  5ad30b:       4c 8d 2c c2             lea    (%rdx,%rax,8),%r13
    0.00 :	  5ad30f:       49 01 c4                add    %rax,%r12
    0.00 :	  5ad312:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        {
         :	                                                values[resind] = ExecEvalExpr(gstate->arg,
    0.00 :	  5ad318:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  5ad31c:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  5ad31f:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5ad322:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  5ad326:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  5ad329:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5ad32c:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5ad32f:       49 89 45 00             mov    %rax,0x0(%r13)
         :	                                {
         :	                                        GenericExprState *gstate = (GenericExprState *) lfirst(tl);
         :	                                        TargetEntry *tle = (TargetEntry *) gstate->xprstate.expr;
         :	                                        AttrNumber      resind = tle->resno - 1;
         :
         :	                                        while (itemIsDone[resind] == ExprMultipleResult)
    0.00 :	  5ad333:       83 3b 01                cmpl   $0x1,(%rbx)
    0.00 :	  5ad336:       74 e0                   je     5ad318 <ExecProject+0x318>
         :	                         *
         :	                         * XXX is that still necessary?
         :	                         */
         :	                        if (*isDone == ExprEndResult)
         :	                        {
         :	                                foreach(tl, targetlist)
    0.00 :	  5ad338:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  5ad33c:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	  5ad340:       48 85 c0                test   %rax,%rax
    0.00 :	  5ad343:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5ad347:       75 97                   jne    5ad2e0 <ExecProject+0x2e0>
    0.00 :	  5ad349:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  5ad34d:       48 89 15 0c d5 60 00    mov    %rdx,0x60d50c(%rip)        # bba860 <CurrentMemoryContext>
         :	        /*
         :	         * Successfully formed a result row.  Mark the result slot as containing a
         :	         * valid virtual tuple.
         :	         */
         :	        return ExecStoreVirtualTuple(slot);
         :	}
    0.00 :	  5ad354:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  5ad358:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5ad35c:       5b                      pop    %rbx
    0.00 :	  5ad35d:       41 5c                   pop    %r12
    0.00 :	  5ad35f:       41 5d                   pop    %r13
    0.00 :	  5ad361:       41 5e                   pop    %r14
    0.00 :	  5ad363:       41 5f                   pop    %r15
    0.00 :	  5ad365:       c9                      leaveq 
    0.00 :	  5ad366:       c3                      retq   
    0.00 :	  5ad367:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5ad36e:       00 00 
         :	                if (*isDone == ExprSingleResult)
         :	                {
         :	                        /*
         :	                         * all sets are done, so report that tlist expansion is complete.
         :	                         */
         :	                        *isDone = ExprEndResult;
    0.00 :	  5ad370:       c7 02 02 00 00 00       movl   $0x2,(%rdx)
    0.00 :	  5ad376:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  5ad37a:       48 89 05 df d4 60 00    mov    %rax,0x60d4df(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5ad381:       eb d1                   jmp    5ad354 <ExecProject+0x354>
         :
         :	                if (itemIsDone[resind] != ExprSingleResult)
         :	                {
         :	                        /* We have a set-valued expression in the tlist */
         :	                        if (isDone == NULL)
         :	                                ereport(ERROR,
    0.00 :	  5ad383:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  5ad386:       b9 f0 ad 88 00          mov    $0x88adf0,%ecx
    0.00 :	  5ad38b:       ba 9c 14 00 00          mov    $0x149c,%edx
    0.00 :	  5ad390:       be fc a3 88 00          mov    $0x88a3fc,%esi
    0.00 :	  5ad395:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5ad39a:       e8 21 d7 1c 00          callq  77aac0 <errstart>
    0.00 :	  5ad39f:       84 c0                   test   %al,%al
    0.00 :	  5ad3a1:       75 05                   jne    5ad3a8 <ExecProject+0x3a8>
    0.00 :	  5ad3a3:       e8 28 c1 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5ad3a8:       bf 30 b3 87 00          mov    $0x87b330,%edi
    0.00 :	  5ad3ad:       31 c0                   xor    %eax,%eax
    0.00 :	  5ad3af:       e8 ec f4 1c 00          callq  77c8a0 <errmsg>
    0.00 :	  5ad3b4:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  5ad3b9:       89 c3                   mov    %eax,%ebx
    0.00 :	  5ad3bb:       e8 90 f9 1c 00          callq  77cd50 <errcode>
    0.00 :	  5ad3c0:       89 de                   mov    %ebx,%esi
    0.00 :	  5ad3c2:       89 c7                   mov    %eax,%edi
    0.00 :	  5ad3c4:       31 c0                   xor    %eax,%eax
    0.00 :	  5ad3c6:       e8 15 d2 1c 00          callq  77a5e0 <errfinish>
    0.00 :	  5ad3cb:       eb d6                   jmp    5ad3a3 <ExecProject+0x3a3>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:456
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:465
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:444
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:444
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:456
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:457
    8.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:458
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007832f0 <CHashSearch>:
         :	 * from the data in the hash table and return true.  If not, it will return
         :	 * false.
         :	 */
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
    0.00 :	  7832f0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:444
    8.33 :	  7832f1:       48 89 e5                mov    %rsp,%rbp
    8.33 :	  7832f4:       41 54                   push   %r12
    0.00 :	  7832f6:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7832f9:       53                      push   %rbx
    0.00 :	  7832fa:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7832fd:       48 83 ec 20             sub    $0x20,%rsp
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  783301:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  783305:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  783308:       e8 43 d0 d0 ff          callq  490350 <hash_any>
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  78330d:       0f b6 4b 14             movzbl 0x14(%rbx),%ecx
         :	 */
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  783311:       8b 7b 10                mov    0x10(%rbx),%edi
    0.00 :	  783314:       21 c7                   and    %eax,%edi
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  783316:       89 fe                   mov    %edi,%esi
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783318:       d3 ef                   shr    %cl,%edi
    0.00 :	  78331a:       0f b6 4b 15             movzbl 0x15(%rbx),%ecx
    0.00 :	  78331e:       89 fa                   mov    %edi,%edx
         :	bool
         :	CHashSearch(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  783320:       48 c1 e6 02             shl    $0x2,%rsi
    0.00 :	  783324:       48 03 73 20             add    0x20(%rbx),%rsi
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  783328:       d3 ea                   shr    %cl,%edx
    0.00 :	  78332a:       48 8b 0d 17 a6 3f 00    mov    0x3fa617(%rip),%rcx        # b7d948 <MyProc>
    0.00 :	  783331:       01 fa                   add    %edi,%edx
    0.00 :	  783333:       48 c1 e2 02             shl    $0x2,%rdx
    0.00 :	  783337:       48 03 53 28             add    0x28(%rbx),%rdx
    0.00 :	  78333b:       48 89 91 e8 02 00 00    mov    %rdx,0x2e8(%rcx)
         :	        pg_memory_barrier();
    0.00 :	  783342:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :
         :	        /* Scan bucket and return data from any matching entry. */
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:456
   33.33 :	  783347:       4c 8d 45 d0             lea    -0x30(%rbp),%r8
    0.00 :	  78334b:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  78334e:       89 c2                   mov    %eax,%edx
    0.00 :	  783350:       48 89 df                mov    %rbx,%rdi
    8.33 :	  783353:       e8 48 f9 ff ff          callq  782ca0 <CHashBucketScan>
         :	        if (scan.found)
    0.00 :	  783358:       80 7d e8 00             cmpb   $0x0,-0x18(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:457
    8.33 :	  78335c:       75 32                   jne    783390 <CHashSearch+0xa0>
         :	                           CHashNodeGetItem(scan.target_node) + table->desc.key_size,
         :	                           table->desc.element_size - table->desc.key_size);
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  78335e:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:465
   25.00 :	  783363:       48 8b 05 de a5 3f 00    mov    0x3fa5de(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  78336a:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  783371:       00 00 00 00 
         :
         :	        CHashTableIncrementStatistic(table, CHS_Search);
         :	        if (!scan.found)
    0.00 :	  783375:       0f b6 45 e8             movzbl -0x18(%rbp),%eax
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
         :	        MyProc->hazard[0] = NULL;
         :
         :	        CHashTableIncrementStatistic(table, CHS_Search);
    0.00 :	  783379:       48 83 43 40 01          addq   $0x1,0x40(%rbx)
         :	        if (!scan.found)
    0.00 :	  78337e:       84 c0                   test   %al,%al
    0.00 :	  783380:       75 05                   jne    783387 <CHashSearch+0x97>
         :	                CHashTableIncrementStatistic(table, CHS_Search_Failed);
    0.00 :	  783382:       48 83 43 48 01          addq   $0x1,0x48(%rbx)
         :	        return scan.found;
         :	}
    0.00 :	  783387:       48 83 c4 20             add    $0x20,%rsp
    0.00 :	  78338b:       5b                      pop    %rbx
    0.00 :	  78338c:       41 5c                   pop    %r12
    0.00 :	  78338e:       c9                      leaveq 
    0.00 :	  78338f:       c3                      retq   
         :	        pg_memory_barrier();
         :
         :	        /* Scan bucket and return data from any matching entry. */
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
         :	        if (scan.found)
         :	                memcpy(((char *) entry) + table->desc.key_size,
    0.00 :	  783390:       0f b7 43 0e             movzwl 0xe(%rbx),%eax
    0.00 :	  783394:       0f b7 53 0c             movzwl 0xc(%rbx),%edx
    0.00 :	  783398:       0f b7 f0                movzwl %ax,%esi
    0.00 :	  78339b:       29 c2                   sub    %eax,%edx
    0.00 :	  78339d:       49 8d 3c 34             lea    (%r12,%rsi,1),%rdi
    0.00 :	  7833a1:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	  7833a5:       48 03 75 e0             add    -0x20(%rbp),%rsi
    0.00 :	  7833a9:       48 63 d2                movslq %edx,%rdx
    0.00 :	  7833ac:       e8 3f 68 ce ff          callq  469bf0 <memcpy@plt>
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:458
    8.33 :	  7833b1:       eb ab                   jmp    78335e <CHashSearch+0x6e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   27.27 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:103
   27.27 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:103
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:95
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:93
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:99
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5c40 <btint4cmp>:
         :
         :	Datum
         :	btint4cmp(PG_FUNCTION_ARGS)
         :	{
         :	        int32           a = PG_GETARG_INT32(0);
         :	        int32           b = PG_GETARG_INT32(1);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:95
   18.18 :	  4a5c40:       8b 47 28                mov    0x28(%rdi),%eax
         :
         :	        if (a > b)
    0.00 :	  4a5c43:       39 47 20                cmp    %eax,0x20(%rdi)
    0.00 :	  4a5c46:       ba 01 00 00 00          mov    $0x1,%edx
         :	        PG_RETURN_VOID();
         :	}
         :
         :	Datum
         :	btint4cmp(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:93
   18.18 :	  4a5c4b:       55                      push   %rbp
    0.00 :	  4a5c4c:       48 89 e5                mov    %rsp,%rbp
         :	        int32           a = PG_GETARG_INT32(0);
         :	        int32           b = PG_GETARG_INT32(1);
         :
         :	        if (a > b)
    0.00 :	  4a5c4f:       7f 0e                   jg     4a5c5f <btint4cmp+0x1f>
         :	                PG_RETURN_INT32(1);
         :	        else if (a == b)
    0.00 :	  4a5c51:       ba ff ff ff ff          mov    $0xffffffff,%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:99
    9.09 :	  4a5c56:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  4a5c5b:       48 0f 44 d0             cmove  %rax,%rdx
         :	                PG_RETURN_INT32(0);
         :	        else
         :	                PG_RETURN_INT32(-1);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtcompare.c:103
   27.27 :	  4a5c5f:       48 89 d0                mov    %rdx,%rax
   27.27 :	  4a5c62:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   27.27 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1966
   18.18 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1992
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1946
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1962
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1979
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1989
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1995
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1998
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b1430 <ExecMakeFunctionResultNoSets>:
         :	static Datum
         :	ExecMakeFunctionResultNoSets(FuncExprState *fcache,
         :	                                                         ExprContext *econtext,
         :	                                                         bool *isNull,
         :	                                                         ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1946
    9.09 :	  5b1430:       55                      push   %rbp
    0.00 :	  5b1431:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b1434:       41 57                   push   %r15
    0.00 :	  5b1436:       49 89 d7                mov    %rdx,%r15
    0.00 :	  5b1439:       41 56                   push   %r14
    0.00 :	  5b143b:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5b143e:       41 55                   push   %r13
    0.00 :	  5b1440:       49 89 fd                mov    %rdi,%r13
    0.00 :	  5b1443:       41 54                   push   %r12
    0.00 :	  5b1445:       53                      push   %rbx
    0.00 :	  5b1446:       48 89 cb                mov    %rcx,%rbx
    0.00 :	  5b1449:       48 83 ec 48             sub    $0x48,%rsp
         :	        FunctionCallInfo fcinfo;
         :	        PgStat_FunctionCallUsage fcusage;
         :	        int                     i;
         :
         :	        /* Guard against stack overflow due to overly complex expressions */
         :	        check_stack_depth();
    0.00 :	  5b144d:       e8 8e a5 0e 00          callq  69b9e0 <check_stack_depth>
         :
         :	        if (isDone)
    0.00 :	  5b1452:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b1455:       74 06                   je     5b145d <ExecMakeFunctionResultNoSets+0x2d>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b1457:       c7 03 00 00 00 00       movl   $0x0,(%rbx)
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b145d:       49 8b 45 18             mov    0x18(%r13),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5b1461:       48 85 c0                test   %rax,%rax
    0.00 :	  5b1464:       0f 84 c2 00 00 00       je     5b152c <ExecMakeFunctionResultNoSets+0xfc>
    0.00 :	  5b146a:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  5b146e:       4d 85 e4                test   %r12,%r12
    0.00 :	  5b1471:       0f 84 b5 00 00 00       je     5b152c <ExecMakeFunctionResultNoSets+0xfc>
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1962
    9.09 :	  5b1477:       31 db                   xor    %ebx,%ebx
    0.00 :	  5b1479:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        {
         :	                ExprState  *argstate = (ExprState *) lfirst(arg);
    0.00 :	  5b1480:       49 8b 04 24             mov    (%r12),%rax
         :
         :	                fcinfo->arg[i] = ExecEvalExpr(argstate,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1966
   27.27 :	  5b1484:       49 8d 94 1d b0 03 00    lea    0x3b0(%r13,%rbx,1),%rdx
    0.00 :	  5b148b:       00 
    0.00 :	  5b148c:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5b148e:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5b1491:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5b1494:       ff 50 10                callq  *0x10(%rax)
    0.00 :	  5b1497:       49 89 84 dd 90 00 00    mov    %rax,0x90(%r13,%rbx,8)
    0.00 :	  5b149e:       00 
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b149f:       4d 8b 64 24 08          mov    0x8(%r12),%r12
         :	        {
         :	                ExprState  *argstate = (ExprState *) lfirst(arg);
         :
         :	                fcinfo->arg[i] = ExecEvalExpr(argstate,
    0.00 :	  5b14a4:       8d 53 01                lea    0x1(%rbx),%edx
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b14a7:       48 83 c3 01             add    $0x1,%rbx
    0.00 :	  5b14ab:       4d 85 e4                test   %r12,%r12
    0.00 :	  5b14ae:       75 d0                   jne    5b1480 <ExecMakeFunctionResultNoSets+0x50>
         :
         :	        /*
         :	         * If function is strict, and there are any NULL arguments, skip calling
         :	         * the function and return NULL.
         :	         */
         :	        if (fcache->func.fn_strict)
    0.00 :	  5b14b0:       41 80 7d 2e 00          cmpb   $0x0,0x2e(%r13)
    0.00 :	  5b14b5:       74 34                   je     5b14eb <ExecMakeFunctionResultNoSets+0xbb>
    0.00 :	  5b14b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  5b14be:       00 00 
         :	        {
         :	                while (--i >= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1979
    9.09 :	  5b14c0:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5b14c3:       78 26                   js     5b14eb <ExecMakeFunctionResultNoSets+0xbb>
         :	                {
         :	                        if (fcinfo->argnull[i])
    0.00 :	  5b14c5:       48 63 c2                movslq %edx,%rax
    0.00 :	  5b14c8:       41 80 bc 05 b0 03 00    cmpb   $0x0,0x3b0(%r13,%rax,1)
    0.00 :	  5b14cf:       00 00 
    0.00 :	  5b14d1:       74 ed                   je     5b14c0 <ExecMakeFunctionResultNoSets+0x90>
         :	                        {
         :	                                *isNull = true;
    0.00 :	  5b14d3:       41 c6 07 01             movb   $0x1,(%r15)
    0.00 :	  5b14d7:       31 db                   xor    %ebx,%ebx
         :	        *isNull = fcinfo->isnull;
         :
         :	        pgstat_end_function_usage(&fcusage, true);
         :
         :	        return result;
         :	}
    0.00 :	  5b14d9:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5b14dd:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5b14e0:       5b                      pop    %rbx
    0.00 :	  5b14e1:       41 5c                   pop    %r12
    0.00 :	  5b14e3:       41 5d                   pop    %r13
    0.00 :	  5b14e5:       41 5e                   pop    %r14
    0.00 :	  5b14e7:       41 5f                   pop    %r15
    0.00 :	  5b14e9:       c9                      leaveq 
    0.00 :	  5b14ea:       c3                      retq   
         :
         :	        if (isDone)
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
    0.00 :	  5b14eb:       49 8d 5d 70             lea    0x70(%r13),%rbx
         :	                                return (Datum) 0;
         :	                        }
         :	                }
         :	        }
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
    0.00 :	  5b14ef:       4c 8d 65 90             lea    -0x70(%rbp),%r12
    0.00 :	  5b14f3:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b14f6:       4c 89 e6                mov    %r12,%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1989
    9.09 :	  5b14f9:       e8 82 12 09 00          callq  642780 <pgstat_init_function_usage>
         :
         :	        fcinfo->isnull = false;
         :	        result = FunctionCallInvoke(fcinfo);
    0.00 :	  5b14fe:       49 8b 45 70             mov    0x70(%r13),%rax
    0.00 :	  5b1502:       48 89 df                mov    %rbx,%rdi
         :	                }
         :	        }
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
         :
         :	        fcinfo->isnull = false;
    0.00 :	  5b1505:       41 c6 85 8c 00 00 00    movb   $0x0,0x8c(%r13)
    0.00 :	  5b150c:       00 
         :	        result = FunctionCallInvoke(fcinfo);
    0.00 :	  5b150d:       ff 10                   callq  *(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1992
   18.18 :	  5b150f:       48 89 c3                mov    %rax,%rbx
         :	        *isNull = fcinfo->isnull;
    0.00 :	  5b1512:       41 0f b6 85 8c 00 00    movzbl 0x8c(%r13),%eax
    0.00 :	  5b1519:       00 
         :
         :	        pgstat_end_function_usage(&fcusage, true);
    0.00 :	  5b151a:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5b151f:       4c 89 e7                mov    %r12,%rdi
         :
         :	        pgstat_init_function_usage(fcinfo, &fcusage);
         :
         :	        fcinfo->isnull = false;
         :	        result = FunctionCallInvoke(fcinfo);
         :	        *isNull = fcinfo->isnull;
    0.00 :	  5b1522:       41 88 07                mov    %al,(%r15)
         :
         :	        pgstat_end_function_usage(&fcusage, true);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1995
    9.09 :	  5b1525:       e8 a6 10 09 00          callq  6425d0 <pgstat_end_function_usage>
         :
         :	        return result;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1998
    9.09 :	  5b152a:       eb ad                   jmp    5b14d9 <ExecMakeFunctionResultNoSets+0xa9>
         :	                *isDone = ExprSingleResult;
         :
         :	        /* inlined, simplified version of ExecEvalFuncArgs */
         :	        fcinfo = &fcache->fcinfo_data;
         :	        i = 0;
         :	        foreach(arg, fcache->args)
    0.00 :	  5b152c:       31 d2                   xor    %edx,%edx
    0.00 :	  5b152e:       eb 80                   jmp    5b14b0 <ExecMakeFunctionResultNoSets+0x80>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   18.18 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3020
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3003
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3003
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3003
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3003
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3010
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3012
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3020
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3020
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3015
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674710 <LockBuffer>:
         :	/*
         :	 * Acquire or release the content_lock for the buffer.
         :	 */
         :	void
         :	LockBuffer(Buffer buffer, int mode)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3003
    9.09 :	  674710:       55                      push   %rbp
    9.09 :	  674711:       48 89 e5                mov    %rsp,%rbp
    9.09 :	  674714:       53                      push   %rbx
    9.09 :	  674715:       89 f3                   mov    %esi,%ebx
    0.00 :	  674717:       48 83 ec 08             sub    $0x8,%rsp
         :	        volatile BufferDesc *buf;
         :
         :	        Assert(BufferIsValid(buffer));
         :	        if (BufferIsLocal(buffer))
    0.00 :	  67471b:       85 ff                   test   %edi,%edi
    0.00 :	  67471d:       78 31                   js     674750 <LockBuffer+0x40>
         :	                return;                                 /* local buffers need no lock */
         :
         :	        buf = &(BufferDescriptors[buffer - 1]);
    0.00 :	  67471f:       48 63 c7                movslq %edi,%rax
    0.00 :	  674722:       48 83 e8 01             sub    $0x1,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3010
    9.09 :	  674726:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  67472a:       48 03 05 cf b3 54 00    add    0x54b3cf(%rip),%rax        # bbfb00 <BufferDescriptors>
         :
         :	        if (mode == BUFFER_LOCK_UNLOCK)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3012
    9.09 :	  674731:       85 f6                   test   %esi,%esi
    0.00 :	  674733:       74 2b                   je     674760 <LockBuffer+0x50>
         :	                LWLockRelease(buf->content_lock);
         :	        else if (mode == BUFFER_LOCK_SHARE)
    0.00 :	  674735:       83 fe 01                cmp    $0x1,%esi
    0.00 :	  674738:       74 36                   je     674770 <LockBuffer+0x60>
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
    0.00 :	  67473a:       83 fe 02                cmp    $0x2,%esi
    0.00 :	  67473d:       75 45                   jne    674784 <LockBuffer+0x74>
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
    0.00 :	  67473f:       48 8b 78 38             mov    0x38(%rax),%rdi
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
    0.00 :	  674743:       48 83 c4 08             add    $0x8,%rsp
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
         :	        else if (mode == BUFFER_LOCK_SHARE)
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
    0.00 :	  674747:       31 f6                   xor    %esi,%esi
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
    0.00 :	  674749:       5b                      pop    %rbx
    0.00 :	  67474a:       c9                      leaveq 
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
         :	        else if (mode == BUFFER_LOCK_SHARE)
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
    0.00 :	  67474b:       e9 a0 b3 01 00          jmpq   68faf0 <LWLockAcquire>
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
    0.00 :	  674750:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674754:       5b                      pop    %rbx
    0.00 :	  674755:       c9                      leaveq 
    0.00 :	  674756:       c3                      retq   
    0.00 :	  674757:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  67475e:       00 00 
         :	                return;                                 /* local buffers need no lock */
         :
         :	        buf = &(BufferDescriptors[buffer - 1]);
         :
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
    0.00 :	  674760:       48 8b 78 38             mov    0x38(%rax),%rdi
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3020
    9.09 :	  674764:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674768:       5b                      pop    %rbx
    9.09 :	  674769:       c9                      leaveq 
         :	                return;                                 /* local buffers need no lock */
         :
         :	        buf = &(BufferDescriptors[buffer - 1]);
         :
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
    0.00 :	  67476a:       e9 31 ac 01 00          jmpq   68f3a0 <LWLockRelease>
    0.00 :	  67476f:       90                      nop
         :	        else if (mode == BUFFER_LOCK_SHARE)
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3015
    9.09 :	  674770:       48 8b 78 38             mov    0x38(%rax),%rdi
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3020
   18.18 :	  674774:       48 83 c4 08             add    $0x8,%rsp
         :	        buf = &(BufferDescriptors[buffer - 1]);
         :
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
         :	        else if (mode == BUFFER_LOCK_SHARE)
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
    0.00 :	  674778:       be 01 00 00 00          mov    $0x1,%esi
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
         :	}
    0.00 :	  67477d:       5b                      pop    %rbx
    0.00 :	  67477e:       c9                      leaveq 
         :	        buf = &(BufferDescriptors[buffer - 1]);
         :
         :	        if (mode == BUFFER_LOCK_UNLOCK)
         :	                LWLockRelease(buf->content_lock);
         :	        else if (mode == BUFFER_LOCK_SHARE)
         :	                LWLockAcquire(buf->content_lock, LW_SHARED);
    0.00 :	  67477f:       e9 6c b3 01 00          jmpq   68faf0 <LWLockAcquire>
         :	        else if (mode == BUFFER_LOCK_EXCLUSIVE)
         :	                LWLockAcquire(buf->content_lock, LW_EXCLUSIVE);
         :	        else
         :	                elog(ERROR, "unrecognized buffer lock mode: %d", mode);
    0.00 :	  674784:       ba 15 a0 8a 00          mov    $0x8aa015,%edx
    0.00 :	  674789:       be cb 0b 00 00          mov    $0xbcb,%esi
    0.00 :	  67478e:       bf 53 9d 8a 00          mov    $0x8a9d53,%edi
    0.00 :	  674793:       e8 88 6c 10 00          callq  77b420 <elog_start>
    0.00 :	  674798:       89 da                   mov    %ebx,%edx
    0.00 :	  67479a:       be f8 9d 8a 00          mov    $0x8a9df8,%esi
    0.00 :	  67479f:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  6747a4:       31 c0                   xor    %eax,%eax
    0.00 :	  6747a6:       e8 85 6a 10 00          callq  77b230 <elog_finish>
    0.00 :	  6747ab:       e8 20 4d df ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   45.45 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1379
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1364
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1360
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1360
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:335
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1401
    9.09 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1401
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674d30 <UnpinBuffer>:
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    0.00 :	  674d30:       55                      push   %rbp
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1364
    9.09 :	  674d31:       31 d2                   xor    %edx,%edx
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    0.00 :	  674d33:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674d36:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  674d3a:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1360
    9.09 :	  674d3e:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  674d41:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  674d45:       48 83 ec 30             sub    $0x30,%rsp
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
    0.00 :	  674d49:       8b 7f 24                mov    0x24(%rdi),%edi
         :	 * Most but not all callers want CurrentResourceOwner to be adjusted.
         :	 * Those that don't should pass fixOwner = FALSE.
         :	 */
         :	static void
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
    9.09 :	  674d4c:       41 89 f4                mov    %esi,%r12d
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
    0.00 :	  674d4f:       31 f6                   xor    %esi,%esi
    0.00 :	  674d51:       83 c7 01                add    $0x1,%edi
    0.00 :	  674d54:       e8 c7 f7 ff ff          callq  674520 <GetPrivateRefCountEntry>
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
    0.00 :	  674d59:       45 84 e4                test   %r12b,%r12b
         :	UnpinBuffer(volatile BufferDesc *buf, bool fixOwner)
         :	{
         :	        PrivateRefCountEntry *ref;
         :	        int                     b = buf->buf_id;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
    0.00 :	  674d5c:       49 89 c5                mov    %rax,%r13
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
    0.00 :	  674d5f:       0f 85 b3 00 00 00       jne    674e18 <UnpinBuffer+0xe8>
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
         :	                                                                  BufferDescriptorGetBuffer(buf));
         :
         :	        Assert(ref->refcount > 0);
         :	        ref->refcount--;
    0.00 :	  674d65:       41 8b 45 04             mov    0x4(%r13),%eax
    0.00 :	  674d69:       83 e8 01                sub    $0x1,%eax
         :	        if (ref->refcount == 0)
    0.00 :	  674d6c:       85 c0                   test   %eax,%eax
         :	        if (fixOwner)
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
         :	                                                                  BufferDescriptorGetBuffer(buf));
         :
         :	        Assert(ref->refcount > 0);
         :	        ref->refcount--;
    0.00 :	  674d6e:       41 89 45 04             mov    %eax,0x4(%r13)
         :	        if (ref->refcount == 0)
    0.00 :	  674d72:       75 66                   jne    674dda <UnpinBuffer+0xaa>
         :	        {
         :	                /* I'd better not still hold any locks on the buffer */
         :	                Assert(!LWLockHeldByMe(buf->content_lock));
         :	                Assert(!LWLockHeldByMe(buf->io_in_progress_lock));
         :
         :	                LockBufHdr(buf);
    0.00 :	  674d74:       48 8d 7b 20             lea    0x20(%rbx),%rdi
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  674d78:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  674d7d:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1379
   45.45 :	  674d80:       84 c0                   test   %al,%al
    0.00 :	  674d82:       0f 85 a8 00 00 00       jne    674e30 <UnpinBuffer+0x100>
         :
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
    0.00 :	  674d88:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674d8b:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674d8e:       89 43 18                mov    %eax,0x18(%rbx)
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674d91:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674d95:       a8 40                   test   $0x40,%al
    0.00 :	  674d97:       75 57                   jne    674df0 <UnpinBuffer+0xc0>
         :	                        buf->flags &= ~BM_PIN_COUNT_WAITER;
         :	                        UnlockBufHdr(buf);
         :	                        ProcSendSignal(wait_backend_pid);
         :	                }
         :	                else
         :	                        UnlockBufHdr(buf);
    0.00 :	  674d99:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	static void
         :	ForgetPrivateRefCountEntry(PrivateRefCountEntry *ref)
         :	{
         :	        Assert(ref->refcount == 0);
         :
         :	        if (ref >= &PrivateRefCountArray[0] &&
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:335
    9.09 :	  674d9d:       49 81 fd c0 d0 b7 00    cmp    $0xb7d0c0,%r13
    0.00 :	  674da4:       72 0d                   jb     674db3 <UnpinBuffer+0x83>
    0.00 :	  674da6:       49 81 fd 00 d1 b7 00    cmp    $0xb7d100,%r13
    0.00 :	  674dad:       0f 82 95 00 00 00       jb     674e48 <UnpinBuffer+0x118>
         :	                ref->buffer = InvalidBuffer;
         :	        }
         :	        else
         :	        {
         :	                bool found;
         :	                Buffer buffer = ref->buffer;
    0.00 :	  674db3:       41 8b 45 00             mov    0x0(%r13),%eax
         :	                hash_search(PrivateRefCountHash,
    0.00 :	  674db7:       48 8b 3d ba 82 50 00    mov    0x5082ba(%rip),%rdi        # b7d078 <PrivateRefCountHash>
    0.00 :	  674dbe:       48 8d 4d e7             lea    -0x19(%rbp),%rcx
    0.00 :	  674dc2:       48 8d 75 e0             lea    -0x20(%rbp),%rsi
    0.00 :	  674dc6:       ba 02 00 00 00          mov    $0x2,%edx
         :	                ref->buffer = InvalidBuffer;
         :	        }
         :	        else
         :	        {
         :	                bool found;
         :	                Buffer buffer = ref->buffer;
    0.00 :	  674dcb:       89 45 e0                mov    %eax,-0x20(%rbp)
         :	                hash_search(PrivateRefCountHash,
    0.00 :	  674dce:       e8 cd f8 10 00          callq  7846a0 <hash_search>
         :	                                        (void *) &buffer,
         :	                                        HASH_REMOVE,
         :	                                        &found);
         :	                Assert(found);
         :	                Assert(PrivateRefCountOverflowed > 0);
         :	                PrivateRefCountOverflowed--;
    0.00 :	  674dd3:       83 2d 96 82 50 00 01    subl   $0x1,0x508296(%rip)        # b7d070 <PrivateRefCountOverflowed>
         :	                else
         :	                        UnlockBufHdr(buf);
         :
         :	                ForgetPrivateRefCountEntry(ref);
         :	        }
         :	}
    0.00 :	  674dda:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1401
    9.09 :	  674dde:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  674de2:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  674de6:       c9                      leaveq 
    9.09 :	  674de7:       c3                      retq   
    0.00 :	  674de8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  674def:       00 
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674df0:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674df3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674df6:       75 a1                   jne    674d99 <UnpinBuffer+0x69>
         :	                        buf->refcount == 1)
         :	                {
         :	                        /* we just released the last pin other than the waiter's */
         :	                        int                     wait_backend_pid = buf->wait_backend_pid;
    0.00 :	  674df8:       8b 7b 1c                mov    0x1c(%rbx),%edi
         :
         :	                        buf->flags &= ~BM_PIN_COUNT_WAITER;
    0.00 :	  674dfb:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674dff:       83 e0 bf                and    $0xffffffbf,%eax
    0.00 :	  674e02:       66 89 43 14             mov    %ax,0x14(%rbx)
         :	                        UnlockBufHdr(buf);
    0.00 :	  674e06:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                        ProcSendSignal(wait_backend_pid);
    0.00 :	  674e0a:       e8 b1 76 01 00          callq  68c4c0 <ProcSendSignal>
         :	                /* Decrement the shared reference count */
         :	                Assert(buf->refcount > 0);
         :	                buf->refcount--;
         :
         :	                /* Support LockBufferForCleanup() */
         :	                if ((buf->flags & BM_PIN_COUNT_WAITER) &&
    0.00 :	  674e0f:       eb 8c                   jmp    674d9d <UnpinBuffer+0x6d>
    0.00 :	  674e11:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, false, false);
         :	        Assert(ref != NULL);
         :
         :	        if (fixOwner)
         :	                ResourceOwnerForgetBuffer(CurrentResourceOwner,
    0.00 :	  674e18:       8b 73 24                mov    0x24(%rbx),%esi
    0.00 :	  674e1b:       48 8b 3d 9e 5a 54 00    mov    0x545a9e(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674e22:       83 c6 01                add    $0x1,%esi
    0.00 :	  674e25:       e8 d6 5a 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
    0.00 :	  674e2a:       e9 36 ff ff ff          jmpq   674d65 <UnpinBuffer+0x35>
    0.00 :	  674e2f:       90                      nop
         :	        {
         :	                /* I'd better not still hold any locks on the buffer */
         :	                Assert(!LWLockHeldByMe(buf->content_lock));
         :	                Assert(!LWLockHeldByMe(buf->io_in_progress_lock));
         :
         :	                LockBufHdr(buf);
    0.00 :	  674e30:       ba 63 05 00 00          mov    $0x563,%edx
    0.00 :	  674e35:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  674e3a:       e8 01 b2 01 00          callq  690040 <s_lock>
    0.00 :	  674e3f:       e9 44 ff ff ff          jmpq   674d88 <UnpinBuffer+0x58>
    0.00 :	  674e44:       0f 1f 40 00             nopl   0x0(%rax)
         :	        Assert(ref->refcount == 0);
         :
         :	        if (ref >= &PrivateRefCountArray[0] &&
         :	                ref < &PrivateRefCountArray[REFCOUNT_ARRAY_ENTRIES])
         :	        {
         :	                ref->buffer = InvalidBuffer;
    0.00 :	  674e48:       41 c7 45 00 00 00 00    movl   $0x0,0x0(%r13)
    0.00 :	  674e4f:       00 
    0.00 :	  674e50:       eb 88                   jmp    674dda <UnpinBuffer+0xaa>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:580
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1039
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:578
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:824
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:824
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:842
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:735
   10.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:777
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000675ca0 <ReadBuffer_common>:
         :	 */
         :	static Buffer
         :	ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
         :	                                  BlockNumber blockNum, ReadBufferMode mode,
         :	                                  BufferAccessStrategy strategy, bool *hit)
         :	{
    0.00 :	  675ca0:       55                      push   %rbp
    0.00 :	  675ca1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  675ca4:       41 57                   push   %r15
    0.00 :	  675ca6:       4d 89 cf                mov    %r9,%r15
    0.00 :	  675ca9:       41 56                   push   %r14
    0.00 :	  675cab:       41 55                   push   %r13
    0.00 :	  675cad:       41 54                   push   %r12
    0.00 :	  675caf:       53                      push   %rbx
    0.00 :	  675cb0:       48 83 ec 68             sub    $0x68,%rsp
    0.00 :	  675cb4:       48 89 7d 80             mov    %rdi,-0x80(%rbp)
    0.00 :	  675cb8:       89 95 78 ff ff ff       mov    %edx,-0x88(%rbp)
    0.00 :	  675cbe:       89 8d 74 ff ff ff       mov    %ecx,-0x8c(%rbp)
    0.00 :	  675cc4:       44 89 85 70 ff ff ff    mov    %r8d,-0x90(%rbp)
    0.00 :	  675ccb:       40 88 b5 7f ff ff ff    mov    %sil,-0x81(%rbp)
         :	        volatile BufferDesc *bufHdr;
         :	        Block           bufBlock;
         :	        bool            found;
         :	        bool            isExtend;
         :	        bool            isLocalBuf = SmgrIsTemp(smgr);
    0.00 :	  675cd2:       83 7f 0c ff             cmpl   $0xffffffff,0xc(%rdi)
         :
         :	        *hit = false;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:580
   20.00 :	  675cd6:       48 8b 45 10             mov    0x10(%rbp),%rax
         :	{
         :	        volatile BufferDesc *bufHdr;
         :	        Block           bufBlock;
         :	        bool            found;
         :	        bool            isExtend;
         :	        bool            isLocalBuf = SmgrIsTemp(smgr);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:578
   10.00 :	  675cda:       0f 95 45 8f             setne  -0x71(%rbp)
         :
         :	        *hit = false;
    0.00 :	  675cde:       c6 00 00                movb   $0x0,(%rax)
         :
         :	        /* Make sure we will have room to remember the buffer pin */
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  675ce1:       48 8b 3d d8 4b 54 00    mov    0x544bd8(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  675ce8:       e8 83 51 12 00          callq  79ae70 <ResourceOwnerEnlargeBuffers>
         :
         :	        isExtend = (blockNum == P_NEW);
    0.00 :	  675ced:       83 bd 74 ff ff ff ff    cmpl   $0xffffffff,-0x8c(%rbp)
         :	                                                                           smgr->smgr_rnode.node.relNode,
         :	                                                                           smgr->smgr_rnode.backend,
         :	                                                                           isExtend);
         :
         :	        /* Substitute proper block number if caller asked for P_NEW */
         :	        if (isExtend)
    0.00 :	  675cf4:       0f 94 45 8e             sete   -0x72(%rbp)
    0.00 :	  675cf8:       0f 84 2f 05 00 00       je     67622d <ReadBuffer_common+0x58d>
         :	                blockNum = smgrnblocks(smgr, forkNum);
         :
         :	        if (isLocalBuf)
    0.00 :	  675cfe:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675d02:       74 7b                   je     675d7f <ReadBuffer_common+0xdf>
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
    0.00 :	  675d04:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675d0a:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  675d10:       48 8d 4d cf             lea    -0x31(%rbp),%rcx
    0.00 :	  675d14:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  675d18:       e8 c3 20 00 00          callq  677de0 <LocalBufferAlloc>
         :	                if (found)
    0.00 :	  675d1d:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :	        if (isExtend)
         :	                blockNum = smgrnblocks(smgr, forkNum);
         :
         :	        if (isLocalBuf)
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
    0.00 :	  675d21:       49 89 c6                mov    %rax,%r14
         :	                if (found)
    0.00 :	  675d24:       0f 85 1b 04 00 00       jne    676145 <ReadBuffer_common+0x4a5>
         :	                        pgBufferUsage.local_blks_hit++;
         :	                else
         :	                        pgBufferUsage.local_blks_read++;
    0.00 :	  675d2a:       48 83 05 56 9a 54 00    addq   $0x1,0x549a56(%rip)        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  675d31:       01 
         :	        }
         :
         :	        /* At this point we do NOT hold any locks. */
         :
         :	        /* if it was already in the buffer pool, we're done */
         :	        if (found)
    0.00 :	  675d32:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  675d36:       0f 84 fa 00 00 00       je     675e36 <ReadBuffer_common+0x196>
         :	        {
         :	                if (!isExtend)
    0.00 :	  675d3c:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
    0.00 :	  675d40:       0f 85 01 05 00 00       jne    676247 <ReadBuffer_common+0x5a7>
         :	                {
         :	                        /* Just need to update stats before we exit */
         :	                        *hit = true;
    0.00 :	  675d46:       48 8b 45 10             mov    0x10(%rbp),%rax
    0.00 :	  675d4a:       c6 00 01                movb   $0x1,(%rax)
         :	                        VacuumPageHit++;
    0.00 :	  675d4d:       83 05 80 43 54 00 01    addl   $0x1,0x544380(%rip)        # bba0d4 <VacuumPageHit>
         :
         :	                        if (VacuumCostActive)
    0.00 :	  675d54:       80 3d 89 43 54 00 00    cmpb   $0x0,0x544389(%rip)        # bba0e4 <VacuumCostActive>
    0.00 :	  675d5b:       74 0c                   je     675d69 <ReadBuffer_common+0xc9>
         :	                                VacuumCostBalance += VacuumCostPageHit;
    0.00 :	  675d5d:       8b 05 c9 2d 4f 00       mov    0x4f2dc9(%rip),%eax        # b68b2c <VacuumCostPageHit>
    0.00 :	  675d63:       01 05 77 43 54 00       add    %eax,0x544377(%rip)        # bba0e0 <VacuumCostBalance>
         :	                                                                          smgr->smgr_rnode.node.relNode,
         :	                                                                          smgr->smgr_rnode.backend,
         :	                                                                          isExtend,
         :	                                                                          found);
         :
         :	        return BufferDescriptorGetBuffer(bufHdr);
    0.00 :	  675d69:       41 8b 46 24             mov    0x24(%r14),%eax
         :	}
    0.00 :	  675d6d:       48 83 c4 68             add    $0x68,%rsp
    0.00 :	  675d71:       5b                      pop    %rbx
    0.00 :	  675d72:       41 5c                   pop    %r12
    0.00 :	  675d74:       41 5d                   pop    %r13
    0.00 :	  675d76:       41 5e                   pop    %r14
         :	                                                                          smgr->smgr_rnode.node.relNode,
         :	                                                                          smgr->smgr_rnode.backend,
         :	                                                                          isExtend,
         :	                                                                          found);
         :
         :	        return BufferDescriptorGetBuffer(bufHdr);
    0.00 :	  675d78:       83 c0 01                add    $0x1,%eax
         :	}
    0.00 :	  675d7b:       41 5f                   pop    %r15
    0.00 :	  675d7d:       c9                      leaveq 
    0.00 :	  675d7e:       c3                      retq   
         :	        int                     buf_id;
         :	        volatile BufferDesc *buf;
         :	        bool            valid;
         :
         :	        /* create a tag so we can lookup the buffer */
         :	        INIT_BUFFERTAG(newTag, smgr->smgr_rnode.node, forkNum, blockNum);
    0.00 :	  675d7f:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  675d83:       48 8b 02                mov    (%rdx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:824
   10.00 :	  675d86:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  675d8a:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  675d8d:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675d93:       89 45 b8                mov    %eax,-0x48(%rbp)
    0.00 :	  675d96:       8b 85 78 ff ff ff       mov    -0x88(%rbp),%eax
   10.00 :	  675d9c:       89 55 c0                mov    %edx,-0x40(%rbp)
    0.00 :	  675d9f:       89 45 bc                mov    %eax,-0x44(%rbp)
    0.00 :	  675da2:       eb 11                   jmp    675db5 <ReadBuffer_common+0x115>
    0.00 :	  675da4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                valid = PinBuffer(foundbuf, strategy);
         :
         :	                /* Check whether someone recycled the buffer before we pinned it. */
         :	                if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
         :	                {
         :	                        UnpinBuffer(foundbuf, true);
    0.00 :	  675da8:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675dad:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675db0:       e8 7b ef ff ff          callq  674d30 <UnpinBuffer>
         :	        /* create a tag so we can lookup the buffer */
         :	        INIT_BUFFERTAG(newTag, smgr->smgr_rnode.node, forkNum, blockNum);
         :
         :	        /* see if the block is in the buffer pool already */
         :	start:
         :	        buf_id = BufTableLookup(&newTag);
    0.00 :	  675db5:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  675db9:       e8 22 e0 ff ff          callq  673de0 <BufTableLookup>
         :	        if (buf_id >= 0)
    0.00 :	  675dbe:       85 c0                   test   %eax,%eax
    0.00 :	  675dc0:       0f 88 bb 01 00 00       js     675f81 <ReadBuffer_common+0x2e1>
         :
         :	                /*
         :	                 * Found it.  Now, pin the buffer so no one can steal it from the
         :	                 * buffer pool.
         :	                 */
         :	                foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675dc6:       48 63 d8                movslq %eax,%rbx
         :
         :	                valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675dc9:       4c 89 fe                mov    %r15,%rsi
         :
         :	                /*
         :	                 * Found it.  Now, pin the buffer so no one can steal it from the
         :	                 * buffer pool.
         :	                 */
         :	                foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675dcc:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  675dd0:       48 03 1d 29 9d 54 00    add    0x549d29(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :
         :	                valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675dd7:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675dda:       49 89 dc                mov    %rbx,%r12
    0.00 :	  675ddd:       e8 4e ee ff ff          callq  674c30 <PinBuffer>
    0.00 :	  675de2:       89 c2                   mov    %eax,%edx
         :
         :	                /* Check whether someone recycled the buffer before we pinned it. */
         :	                if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
    0.00 :	  675de4:       8b 45 b8                mov    -0x48(%rbp),%eax
    0.00 :	  675de7:       3b 43 08                cmp    0x8(%rbx),%eax
    0.00 :	  675dea:       75 bc                   jne    675da8 <ReadBuffer_common+0x108>
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:842
   10.00 :	  675dec:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  675def:       3b 43 04                cmp    0x4(%rbx),%eax
    0.00 :	  675df2:       75 b4                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675df4:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  675df7:       3b 03                   cmp    (%rbx),%eax
    0.00 :	  675df9:       75 ad                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675dfb:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  675dfe:       3b 43 10                cmp    0x10(%rbx),%eax
    0.00 :	  675e01:       75 a5                   jne    675da8 <ReadBuffer_common+0x108>
    0.00 :	  675e03:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  675e06:       3b 43 0c                cmp    0xc(%rbx),%eax
    0.00 :	  675e09:       75 9d                   jne    675da8 <ReadBuffer_common+0x108>
         :	                }
         :
         :	                *foundPtr = TRUE;
         :
         :	                /* Check to see if the correct data has been loaded into the buffer. */
         :	                if (!valid)
    0.00 :	  675e0b:       84 d2                   test   %dl,%dl
         :	                {
         :	                        UnpinBuffer(foundbuf, true);
         :	                        goto start;
         :	                }
         :
         :	                *foundPtr = TRUE;
    0.00 :	  675e0d:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
         :
         :	                /* Check to see if the correct data has been loaded into the buffer. */
         :	                if (!valid)
    0.00 :	  675e11:       0f 84 33 02 00 00       je     67604a <ReadBuffer_common+0x3aa>
         :	                 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
         :	                 * not currently in memory.
         :	                 */
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
    0.00 :	  675e17:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
         :	                        pgBufferUsage.shared_blks_hit++;
    0.00 :	  675e1b:       4d 89 e6                mov    %r12,%r14
         :	                 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
         :	                 * not currently in memory.
         :	                 */
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
    0.00 :	  675e1e:       0f 84 9a 03 00 00       je     6761be <ReadBuffer_common+0x51e>
         :	                        pgBufferUsage.shared_blks_hit++;
    0.00 :	  675e24:       48 83 05 34 99 54 00    addq   $0x1,0x549934(%rip)        # bbf760 <pgBufferUsage>
    0.00 :	  675e2b:       01 
         :	        }
         :
         :	        /* At this point we do NOT hold any locks. */
         :
         :	        /* if it was already in the buffer pool, we're done */
         :	        if (found)
    0.00 :	  675e2c:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  675e30:       0f 85 06 ff ff ff       jne    675d3c <ReadBuffer_common+0x9c>
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  675e36:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675e3a:       0f 84 8b 03 00 00       je     6761cb <ReadBuffer_common+0x52b>
    0.00 :	  675e40:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  675e44:       ba fe ff ff ff          mov    $0xfffffffe,%edx
    0.00 :	  675e49:       29 c2                   sub    %eax,%edx
         :
         :	        if (isExtend)
    0.00 :	  675e4b:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  675e4f:       48 8b 05 c2 72 50 00    mov    0x5072c2(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  675e56:       48 63 d2                movslq %edx,%rdx
    0.00 :	  675e59:       4c 8b 24 d0             mov    (%rax,%rdx,8),%r12
         :
         :	        if (isExtend)
    0.00 :	  675e5d:       0f 85 84 03 00 00       jne    6761e7 <ReadBuffer_common+0x547>
         :	        {
         :	                /*
         :	                 * Read in the page, unless the caller intends to overwrite it and
         :	                 * just wants us to allocate a buffer.
         :	                 */
         :	                if (mode == RBM_ZERO)
    0.00 :	  675e63:       83 bd 70 ff ff ff 01    cmpl   $0x1,-0x90(%rbp)
    0.00 :	  675e6a:       74 7e                   je     675eea <ReadBuffer_common+0x24a>
         :	                else
         :	                {
         :	                        instr_time      io_start,
         :	                                                io_time;
         :
         :	                        if (track_io_timing)
    0.00 :	  675e6c:       80 3d ee 71 50 00 00    cmpb   $0x0,0x5071ee(%rip)        # b7d061 <track_io_timing>
    0.00 :	  675e73:       0f 85 d1 04 00 00       jne    67634a <ReadBuffer_common+0x6aa>
         :	                                INSTR_TIME_SET_CURRENT(io_start);
         :
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
    0.00 :	  675e79:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  675e7f:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  675e85:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  675e88:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  675e8c:       e8 7f 35 02 00          callq  699410 <smgrread>
         :
         :	                        if (track_io_timing)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:735
   10.00 :	  675e91:       80 3d c9 71 50 00 00    cmpb   $0x0,0x5071c9(%rip)        # b7d061 <track_io_timing>
    0.00 :	  675e98:       0f 85 bc 04 00 00       jne    67635a <ReadBuffer_common+0x6ba>
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
         :	                        }
         :
         :	                        /* check for garbage data */
         :	                        if (!PageIsVerified((Page) bufBlock, blockNum))
    0.00 :	  675e9e:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  675ea4:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  675ea7:       e8 24 f0 01 00          callq  694ed0 <PageIsVerified>
    0.00 :	  675eac:       84 c0                   test   %al,%al
    0.00 :	  675eae:       75 47                   jne    675ef7 <ReadBuffer_common+0x257>
         :	                        {
         :	                                if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
    0.00 :	  675eb0:       83 bd 70 ff ff ff 02    cmpl   $0x2,-0x90(%rbp)
    0.00 :	  675eb7:       74 0d                   je     675ec6 <ReadBuffer_common+0x226>
    0.00 :	  675eb9:       80 3d a0 71 50 00 00    cmpb   $0x0,0x5071a0(%rip)        # b7d060 <zero_damaged_pages>
    0.00 :	  675ec0:       0f 84 51 05 00 00       je     676417 <ReadBuffer_common+0x777>
         :	                                {
         :	                                        ereport(WARNING,
    0.00 :	  675ec6:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  675ec9:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  675ece:       ba f0 02 00 00          mov    $0x2f0,%edx
    0.00 :	  675ed3:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  675ed8:       bf 13 00 00 00          mov    $0x13,%edi
    0.00 :	  675edd:       e8 de 4b 10 00          callq  77aac0 <errstart>
    0.00 :	  675ee2:       84 c0                   test   %al,%al
    0.00 :	  675ee4:       0f 85 11 04 00 00       jne    6762fb <ReadBuffer_common+0x65b>
         :	                                                        (errcode(ERRCODE_DATA_CORRUPTED),
         :	                                                         errmsg("invalid page in block %u of relation %s; zeroing out page",
         :	                                                                        blockNum,
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                                        MemSet((char *) bufBlock, 0, BLCKSZ);
    0.00 :	  675eea:       b9 00 04 00 00          mov    $0x400,%ecx
    0.00 :	  675eef:       31 c0                   xor    %eax,%eax
    0.00 :	  675ef1:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  675ef4:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                        }
         :	                }
         :	        }
         :
         :	        if (isLocalBuf)
    0.00 :	  675ef7:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  675efb:       0f 84 18 03 00 00       je     676219 <ReadBuffer_common+0x579>
         :	        {
         :	                /* Only need to adjust flags */
         :	                bufHdr->flags |= BM_VALID;
    0.00 :	  675f01:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  675f06:       83 c8 02                or     $0x2,%eax
    0.00 :	  675f09:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        {
         :	                /* Set BM_VALID, terminate IO, and wake up any waiters */
         :	                TerminateBufferIO(bufHdr, false, BM_VALID);
         :	        }
         :
         :	        VacuumPageMiss++;
    0.00 :	  675f0e:       83 05 c3 41 54 00 01    addl   $0x1,0x5441c3(%rip)        # bba0d8 <VacuumPageMiss>
         :	        if (VacuumCostActive)
    0.00 :	  675f15:       80 3d c8 41 54 00 00    cmpb   $0x0,0x5441c8(%rip)        # bba0e4 <VacuumCostActive>
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:777
   10.00 :	  675f1c:       0f 84 47 fe ff ff       je     675d69 <ReadBuffer_common+0xc9>
         :	                VacuumCostBalance += VacuumCostPageMiss;
    0.00 :	  675f22:       8b 05 08 2c 4f 00       mov    0x4f2c08(%rip),%eax        # b68b30 <VacuumCostPageMiss>
    0.00 :	  675f28:       01 05 b2 41 54 00       add    %eax,0x5441b2(%rip)        # bba0e0 <VacuumCostBalance>
    0.00 :	  675f2e:       e9 36 fe ff ff          jmpq   675d69 <ReadBuffer_common+0xc9>
    0.00 :	  675f33:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                }
         :
         :	                /*
         :	                 * Need to lock the buffer header too in order to change its tag.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  675f38:       49 8d 5e 20             lea    0x20(%r14),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  675f3c:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  675f41:       f0 86 03                lock xchg %al,(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1039
   20.00 :	  675f44:       84 c0                   test   %al,%al
    0.00 :	  675f46:       0f 85 a4 01 00 00       jne    6760f0 <ReadBuffer_common+0x450>
         :	                 * Somebody could have pinned or re-dirtied the buffer while we were
         :	                 * doing the I/O and making the new hashtable entry.  If so, we can't
         :	                 * recycle this buffer; we must undo everything we've done and start
         :	                 * over with a new victim buffer.
         :	                 */
         :	                oldFlags = buf->flags;
    0.00 :	  675f4c:       41 0f b7 56 14          movzwl 0x14(%r14),%edx
         :	                if (buf->refcount == 1 && !(oldFlags & BM_DIRTY))
    0.00 :	  675f51:       41 8b 46 18             mov    0x18(%r14),%eax
    0.00 :	  675f55:       83 e8 01                sub    $0x1,%eax
    0.00 :	  675f58:       75 0c                   jne    675f66 <ReadBuffer_common+0x2c6>
    0.00 :	  675f5a:       0f b7 d2                movzwl %dx,%edx
    0.00 :	  675f5d:       f6 c2 01                test   $0x1,%dl
    0.00 :	  675f60:       0f 84 ec 01 00 00       je     676152 <ReadBuffer_common+0x4b2>
         :	                        break;
         :
         :	                UnlockBufHdr(buf);
         :	                BufTableDelete(&newTag);
    0.00 :	  675f66:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
         :	                 */
         :	                oldFlags = buf->flags;
         :	                if (buf->refcount == 1 && !(oldFlags & BM_DIRTY))
         :	                        break;
         :
         :	                UnlockBufHdr(buf);
    0.00 :	  675f6a:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :	                BufTableDelete(&newTag);
    0.00 :	  675f6f:       e8 dc dd ff ff          callq  673d50 <BufTableDelete>
         :	                UnpinBuffer(buf, true);
    0.00 :	  675f74:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675f79:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  675f7c:       e8 af ed ff ff          callq  674d30 <UnpinBuffer>
         :	        {
         :	                /*
         :	                 * Select a victim buffer.  The buffer is returned with its header
         :	                 * spinlock still held!
         :	                 */
         :	                buf = StrategyGetBuffer(strategy);
    0.00 :	  675f81:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  675f84:       e8 d7 15 00 00          callq  677560 <StrategyGetBuffer>
         :
         :	                Assert(buf->refcount == 0);
         :
         :	                /* Must copy buffer flags while we still hold the spinlock */
         :	                oldFlags = buf->flags;
    0.00 :	  675f89:       0f b7 58 14             movzwl 0x14(%rax),%ebx
         :
         :	                /* Pin the buffer and then release the buffer spinlock */
         :	                PinBuffer_Locked(buf);
    0.00 :	  675f8d:       48 89 c7                mov    %rax,%rdi
         :	        {
         :	                /*
         :	                 * Select a victim buffer.  The buffer is returned with its header
         :	                 * spinlock still held!
         :	                 */
         :	                buf = StrategyGetBuffer(strategy);
    0.00 :	  675f90:       49 89 c6                mov    %rax,%r14
         :
         :	                /* Must copy buffer flags while we still hold the spinlock */
         :	                oldFlags = buf->flags;
         :
         :	                /* Pin the buffer and then release the buffer spinlock */
         :	                PinBuffer_Locked(buf);
    0.00 :	  675f93:       e8 38 ec ff ff          callq  674bd0 <PinBuffer_Locked>
         :	                 * condition here, in that someone might dirty it after we released it
         :	                 * above, or even while we are writing it out (since our share-lock
         :	                 * won't prevent hint-bit updates).  We will recheck the dirty bit
         :	                 * after re-locking the buffer header.
         :	                 */
         :	                if (oldFlags & BM_DIRTY)
    0.00 :	  675f98:       0f b7 db                movzwl %bx,%ebx
    0.00 :	  675f9b:       f6 c3 01                test   $0x1,%bl
    0.00 :	  675f9e:       0f 85 cc 00 00 00       jne    676070 <ReadBuffer_common+0x3d0>
         :
         :	                /*
         :	                 * To change the association of a valid buffer, we'll need to have
         :	                 * exclusive lock on both the old and new mapping partitions.
         :	                 */
         :	                if (oldFlags & BM_TAG_VALID)
    0.00 :	  675fa4:       83 e3 04                and    $0x4,%ebx
    0.00 :	  675fa7:       74 2c                   je     675fd5 <ReadBuffer_common+0x335>
         :	                {
         :	                        /* Save old tag. */
         :	                        oldTag = buf->tag;
    0.00 :	  675fa9:       49 8b 06                mov    (%r14),%rax
    0.00 :	  675fac:       48 89 45 90             mov    %rax,-0x70(%rbp)
    0.00 :	  675fb0:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  675fb4:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	  675fb8:       41 8b 46 10             mov    0x10(%r14),%eax
    0.00 :	  675fbc:       89 45 a0                mov    %eax,-0x60(%rbp)
    0.00 :	  675fbf:       eb 14                   jmp    675fd5 <ReadBuffer_common+0x335>
    0.00 :	  675fc1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
         :	                        valid = PinBuffer(foundbuf, strategy);
         :	                        if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
         :	                        {
         :	                                UnpinBuffer(foundbuf, true);
    0.00 :	  675fc8:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  675fcd:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675fd0:       e8 5b ed ff ff          callq  674d30 <UnpinBuffer>
         :	                 * allocated another buffer for the same block we want to read in.
         :	                 * Note that we have not yet removed the hashtable entry for the old
         :	                 * tag.
         :	                 */
         :	enter:
         :	                buf_id = BufTableInsert(&newTag, buf->buf_id);
    0.00 :	  675fd5:       41 8b 76 24             mov    0x24(%r14),%esi
    0.00 :	  675fd9:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  675fdd:       e8 be dd ff ff          callq  673da0 <BufTableInsert>
         :
         :	                if (buf_id >= 0)
    0.00 :	  675fe2:       85 c0                   test   %eax,%eax
    0.00 :	  675fe4:       0f 88 4e ff ff ff       js     675f38 <ReadBuffer_common+0x298>
         :	                         * did what we were about to do.  We can handle this as if we had
         :	                         * found the buffer in the pool in the first place, but we must
         :	                         * recheck the buffer tag after pinning it, because it could still
         :	                         * get renamed under us.
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675fea:       48 63 d8                movslq %eax,%rbx
         :	                        valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675fed:       4c 89 fe                mov    %r15,%rsi
         :	                         * did what we were about to do.  We can handle this as if we had
         :	                         * found the buffer in the pool in the first place, but we must
         :	                         * recheck the buffer tag after pinning it, because it could still
         :	                         * get renamed under us.
         :	                         */
         :	                        foundbuf = &BufferDescriptors[buf_id];
    0.00 :	  675ff0:       48 c1 e3 06             shl    $0x6,%rbx
    0.00 :	  675ff4:       48 03 1d 05 9b 54 00    add    0x549b05(%rip),%rbx        # bbfb00 <BufferDescriptors>
         :	                        valid = PinBuffer(foundbuf, strategy);
    0.00 :	  675ffb:       48 89 df                mov    %rbx,%rdi
    0.00 :	  675ffe:       49 89 dc                mov    %rbx,%r12
    0.00 :	  676001:       e8 2a ec ff ff          callq  674c30 <PinBuffer>
    0.00 :	  676006:       41 89 c5                mov    %eax,%r13d
         :	                        if (!BUFFERTAGS_EQUAL(newTag, foundbuf->tag))
    0.00 :	  676009:       8b 45 b8                mov    -0x48(%rbp),%eax
    0.00 :	  67600c:       3b 43 08                cmp    0x8(%rbx),%eax
    0.00 :	  67600f:       75 b7                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676011:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  676014:       3b 43 04                cmp    0x4(%rbx),%eax
    0.00 :	  676017:       75 af                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676019:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  67601c:       3b 03                   cmp    (%rbx),%eax
    0.00 :	  67601e:       75 a8                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676020:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  676023:       3b 43 10                cmp    0x10(%rbx),%eax
    0.00 :	  676026:       75 a0                   jne    675fc8 <ReadBuffer_common+0x328>
    0.00 :	  676028:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  67602b:       3b 43 0c                cmp    0xc(%rbx),%eax
    0.00 :	  67602e:       75 98                   jne    675fc8 <ReadBuffer_common+0x328>
         :
         :	                        /*
         :	                         * Collision confirmed.  Give up the buffer we were planning to
         :	                         * use.
         :	                         */
         :	                        UnpinBuffer(buf, true);
    0.00 :	  676030:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676035:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676038:       e8 f3 ec ff ff          callq  674d30 <UnpinBuffer>
         :
         :	                        *foundPtr = TRUE;
         :
         :	                        if (!valid)
    0.00 :	  67603d:       45 84 ed                test   %r13b,%r13b
         :	                         * Collision confirmed.  Give up the buffer we were planning to
         :	                         * use.
         :	                         */
         :	                        UnpinBuffer(buf, true);
         :
         :	                        *foundPtr = TRUE;
    0.00 :	  676040:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
         :
         :	                        if (!valid)
    0.00 :	  676044:       0f 85 cd fd ff ff       jne    675e17 <ReadBuffer_common+0x177>
         :	                                 * in the page, or (b) a previous read attempt failed.  We
         :	                                 * have to wait for any active read attempt to finish, and
         :	                                 * then set up our own read attempt if the page is still not
         :	                                 * BM_VALID.  StartBufferIO does it all.
         :	                                 */
         :	                                if (StartBufferIO(foundbuf, true))
    0.00 :	  67604a:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  67604f:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  676052:       e8 e9 e3 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  676057:       84 c0                   test   %al,%al
    0.00 :	  676059:       0f 84 b8 fd ff ff       je     675e17 <ReadBuffer_common+0x177>
         :	                                {
         :	                                        /*
         :	                                         * If we get here, previous attempts to read the buffer
         :	                                         * must have failed ... but we shall bravely try again.
         :	                                         */
         :	                                        *foundPtr = FALSE;
    0.00 :	  67605f:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
    0.00 :	  676063:       e9 af fd ff ff          jmpq   675e17 <ReadBuffer_common+0x177>
    0.00 :	  676068:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  67606f:       00 
         :	                         * (This has been observed to happen when two backends are both
         :	                         * trying to split btree index pages, and the second one just
         :	                         * happens to be trying to split the page the first one got from
         :	                         * StrategyGetBuffer.)
         :	                         */
         :	                        if (LWLockConditionalAcquire(buf->content_lock, LW_SHARED))
    0.00 :	  676070:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  676074:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676079:       e8 22 8f 01 00          callq  68efa0 <LWLockConditionalAcquire>
    0.00 :	  67607e:       84 c0                   test   %al,%al
    0.00 :	  676080:       0f 84 ee fe ff ff       je     675f74 <ReadBuffer_common+0x2d4>
         :	                                 * would require a WAL flush, let the strategy decide whether
         :	                                 * to go ahead and write/reuse the buffer or to choose another
         :	                                 * victim.  We need lock to inspect the page LSN, so this
         :	                                 * can't be done inside StrategyGetBuffer.
         :	                                 */
         :	                                if (strategy != NULL)
    0.00 :	  676086:       4d 85 ff                test   %r15,%r15
    0.00 :	  676089:       74 4c                   je     6760d7 <ReadBuffer_common+0x437>
         :	                                {
         :	                                        XLogRecPtr      lsn;
         :
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
    0.00 :	  67608b:       49 8d 7e 20             lea    0x20(%r14),%rdi
    0.00 :	  67608f:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  676094:       f0 86 07                lock xchg %al,(%rdi)
    0.00 :	  676097:       84 c0                   test   %al,%al
    0.00 :	  676099:       0f 85 92 00 00 00       jne    676131 <ReadBuffer_common+0x491>
         :	                                        lsn = BufferGetLSN(buf);
    0.00 :	  67609f:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6760a3:       41 8b 56 24             mov    0x24(%r14),%edx
    0.00 :	  6760a7:       48 8b 0d 4a 9a 54 00    mov    0x549a4a(%rip),%rcx        # bbfaf8 <BufferBlocks>
    0.00 :	  6760ae:       48 98                   cltq   
    0.00 :	  6760b0:       48 63 d2                movslq %edx,%rdx
    0.00 :	  6760b3:       48 c1 e0 0d             shl    $0xd,%rax
    0.00 :	  6760b7:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  6760bb:       8b 3c 01                mov    (%rcx,%rax,1),%edi
    0.00 :	  6760be:       8b 44 11 04             mov    0x4(%rcx,%rdx,1),%eax
    0.00 :	  6760c2:       48 c1 e7 20             shl    $0x20,%rdi
    0.00 :	  6760c6:       48 09 c7                or     %rax,%rdi
         :	                                        UnlockBufHdr(buf);
    0.00 :	  6760c9:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :
         :	                                        if (XLogNeedsFlush(lsn) &&
    0.00 :	  6760ce:       e8 dd dc e5 ff          callq  4d3db0 <XLogNeedsFlush>
    0.00 :	  6760d3:       84 c0                   test   %al,%al
    0.00 :	  6760d5:       75 30                   jne    676107 <ReadBuffer_common+0x467>
         :	                                TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START(forkNum, blockNum,
         :	                                                                                           smgr->smgr_rnode.node.spcNode,
         :	                                                                                                smgr->smgr_rnode.node.dbNode,
         :	                                                                                          smgr->smgr_rnode.node.relNode);
         :
         :	                                FlushBuffer(buf, NULL);
    0.00 :	  6760d7:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6760da:       31 f6                   xor    %esi,%esi
    0.00 :	  6760dc:       e8 6f ee ff ff          callq  674f50 <FlushBuffer>
         :	                                LWLockRelease(buf->content_lock);
    0.00 :	  6760e1:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  6760e5:       e8 b6 92 01 00          callq  68f3a0 <LWLockRelease>
    0.00 :	  6760ea:       e9 b5 fe ff ff          jmpq   675fa4 <ReadBuffer_common+0x304>
    0.00 :	  6760ef:       90                      nop
         :	                }
         :
         :	                /*
         :	                 * Need to lock the buffer header too in order to change its tag.
         :	                 */
         :	                LockBufHdr(buf);
    0.00 :	  6760f0:       ba 0f 04 00 00          mov    $0x40f,%edx
    0.00 :	  6760f5:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6760fa:       48 89 df                mov    %rbx,%rdi
    0.00 :	  6760fd:       e8 3e 9f 01 00          callq  690040 <s_lock>
    0.00 :	  676102:       e9 45 fe ff ff          jmpq   675f4c <ReadBuffer_common+0x2ac>
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
         :	                                        lsn = BufferGetLSN(buf);
         :	                                        UnlockBufHdr(buf);
         :
         :	                                        if (XLogNeedsFlush(lsn) &&
    0.00 :	  676107:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  67610a:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  67610d:       e8 0e 11 00 00          callq  677220 <StrategyRejectBuffer>
    0.00 :	  676112:       84 c0                   test   %al,%al
    0.00 :	  676114:       74 c1                   je     6760d7 <ReadBuffer_common+0x437>
         :	                                                StrategyRejectBuffer(strategy, buf))
         :	                                        {
         :	                                                /* Drop lock/pin and loop around for another buffer */
         :	                                                LWLockRelease(buf->content_lock);
    0.00 :	  676116:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  67611a:       e8 81 92 01 00          callq  68f3a0 <LWLockRelease>
         :	                                                UnpinBuffer(buf, true);
    0.00 :	  67611f:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676124:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676127:       e8 04 ec ff ff          callq  674d30 <UnpinBuffer>
    0.00 :	  67612c:       e9 50 fe ff ff          jmpq   675f81 <ReadBuffer_common+0x2e1>
         :	                                if (strategy != NULL)
         :	                                {
         :	                                        XLogRecPtr      lsn;
         :
         :	                                        /* Read the LSN while holding buffer header lock */
         :	                                        LockBufHdr(buf);
    0.00 :	  676131:       ba a0 03 00 00          mov    $0x3a0,%edx
    0.00 :	  676136:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  67613b:       e8 00 9f 01 00          callq  690040 <s_lock>
    0.00 :	  676140:       e9 5a ff ff ff          jmpq   67609f <ReadBuffer_common+0x3ff>
         :
         :	        if (isLocalBuf)
         :	        {
         :	                bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &found);
         :	                if (found)
         :	                        pgBufferUsage.local_blks_hit++;
    0.00 :	  676145:       48 83 05 33 96 54 00    addq   $0x1,0x549633(%rip)        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  67614c:       01 
    0.00 :	  67614d:       e9 e0 fb ff ff          jmpq   675d32 <ReadBuffer_common+0x92>
         :	         * Clearing BM_VALID here is necessary, clearing the dirtybits is just
         :	         * paranoia.  We also reset the usage_count since any recency of use of
         :	         * the old content is no longer relevant.  (The usage_count starts out at
         :	         * 1 so that the buffer can survive one clock-sweep pass.)
         :	         */
         :	        buf->tag = newTag;
    0.00 :	  676152:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  676156:       49 89 06                mov    %rax,(%r14)
    0.00 :	  676159:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  67615d:       49 89 46 08             mov    %rax,0x8(%r14)
    0.00 :	  676161:       8b 45 c0                mov    -0x40(%rbp),%eax
    0.00 :	  676164:       41 89 46 10             mov    %eax,0x10(%r14)
         :	        buf->flags &= ~(BM_VALID | BM_DIRTY | BM_JUST_DIRTIED | BM_CHECKPOINT_NEEDED | BM_IO_ERROR | BM_PERMANENT);
    0.00 :	  676168:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  67616d:       66 25 4c fe             and    $0xfe4c,%ax
    0.00 :	  676171:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        if (relpersistence == RELPERSISTENCE_PERMANENT)
    0.00 :	  676176:       80 bd 7f ff ff ff 70    cmpb   $0x70,-0x81(%rbp)
    0.00 :	  67617d:       0f 84 73 02 00 00       je     6763f6 <ReadBuffer_common+0x756>
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
         :	        else
         :	                buf->flags |= BM_TAG_VALID;
    0.00 :	  676183:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  676188:       83 c8 04                or     $0x4,%eax
    0.00 :	  67618b:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	        buf->usage_count = 1;
    0.00 :	  676190:       66 41 c7 46 16 01 00    movw   $0x1,0x16(%r14)
         :
         :	        UnlockBufHdr(buf);
         :
         :	        if (oldFlags & BM_TAG_VALID)
    0.00 :	  676197:       83 e2 04                and    $0x4,%edx
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
         :	        else
         :	                buf->flags |= BM_TAG_VALID;
         :	        buf->usage_count = 1;
         :
         :	        UnlockBufHdr(buf);
    0.00 :	  67619a:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :
         :	        if (oldFlags & BM_TAG_VALID)
    0.00 :	  67619f:       0f 85 64 02 00 00       jne    676409 <ReadBuffer_common+0x769>
         :	        /*
         :	         * Buffer contents are currently invalid.  Try to get the io_in_progress
         :	         * lock.  If StartBufferIO returns false, then someone else managed to
         :	         * read it before we did, so there's nothing left for BufferAlloc() to do.
         :	         */
         :	        if (StartBufferIO(buf, true))
    0.00 :	  6761a5:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  6761aa:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6761ad:       e8 8e e2 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  6761b2:       84 c0                   test   %al,%al
    0.00 :	  6761b4:       0f 84 d5 00 00 00       je     67628f <ReadBuffer_common+0x5ef>
         :	                *foundPtr = FALSE;
    0.00 :	  6761ba:       c6 45 cf 00             movb   $0x0,-0x31(%rbp)
         :	                bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,
         :	                                                         strategy, &found);
         :	                if (found)
         :	                        pgBufferUsage.shared_blks_hit++;
         :	                else
         :	                        pgBufferUsage.shared_blks_read++;
    0.00 :	  6761be:       48 83 05 a2 95 54 00    addq   $0x1,0x5495a2(%rip)        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  6761c5:       01 
    0.00 :	  6761c6:       e9 67 fb ff ff          jmpq   675d32 <ReadBuffer_common+0x92>
         :	         * it's not been recycled) but come right back here to try smgrextend
         :	         * again.
         :	         */
         :	        Assert(!(bufHdr->flags & BM_VALID));            /* spinlock not needed */
         :
         :	        bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  6761cb:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6761cf:       4c 63 e0                movslq %eax,%r12
    0.00 :	  6761d2:       49 c1 e4 0d             shl    $0xd,%r12
    0.00 :	  6761d6:       4c 03 25 1b 99 54 00    add    0x54991b(%rip),%r12        # bbfaf8 <BufferBlocks>
         :
         :	        if (isExtend)
    0.00 :	  6761dd:       80 7d 8e 00             cmpb   $0x0,-0x72(%rbp)
    0.00 :	  6761e1:       0f 84 7c fc ff ff       je     675e63 <ReadBuffer_common+0x1c3>
         :	        {
         :	                /* new buffers are zero-filled */
         :	                MemSet((char *) bufBlock, 0, BLCKSZ);
    0.00 :	  6761e7:       31 c0                   xor    %eax,%eax
    0.00 :	  6761e9:       b9 00 04 00 00          mov    $0x400,%ecx
    0.00 :	  6761ee:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6761f1:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                /* don't set checksum for all-zero page */
         :	                smgrextend(smgr, forkNum, blockNum, (char *) bufBlock, false);
    0.00 :	  6761f4:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6761f7:       4c 89 e1                mov    %r12,%rcx
    0.00 :	  6761fa:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  676200:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  676206:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  67620a:       e8 c1 31 02 00          callq  6993d0 <smgrextend>
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                        }
         :	                }
         :	        }
         :
         :	        if (isLocalBuf)
    0.00 :	  67620f:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  676213:       0f 85 e8 fc ff ff       jne    675f01 <ReadBuffer_common+0x261>
         :	                bufHdr->flags |= BM_VALID;
         :	        }
         :	        else
         :	        {
         :	                /* Set BM_VALID, terminate IO, and wake up any waiters */
         :	                TerminateBufferIO(bufHdr, false, BM_VALID);
    0.00 :	  676219:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  67621e:       31 f6                   xor    %esi,%esi
    0.00 :	  676220:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  676223:       e8 a8 df ff ff          callq  6741d0 <TerminateBufferIO>
    0.00 :	  676228:       e9 e1 fc ff ff          jmpq   675f0e <ReadBuffer_common+0x26e>
         :	                                                                           smgr->smgr_rnode.backend,
         :	                                                                           isExtend);
         :
         :	        /* Substitute proper block number if caller asked for P_NEW */
         :	        if (isExtend)
         :	                blockNum = smgrnblocks(smgr, forkNum);
    0.00 :	  67622d:       8b b5 78 ff ff ff       mov    -0x88(%rbp),%esi
    0.00 :	  676233:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  676237:       e8 14 32 02 00          callq  699450 <smgrnblocks>
    0.00 :	  67623c:       89 85 74 ff ff ff       mov    %eax,-0x8c(%rbp)
    0.00 :	  676242:       e9 b7 fa ff ff          jmpq   675cfe <ReadBuffer_common+0x5e>
         :	                 * lseek(SEEK_END) result that doesn't account for a recent write. In
         :	                 * that situation, the pre-existing buffer would contain valid data
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  676247:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  67624b:       0f 85 8c 00 00 00       jne    6762dd <ReadBuffer_common+0x63d>
    0.00 :	  676251:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  676255:       48 98                   cltq   
    0.00 :	  676257:       48 c1 e0 0d             shl    $0xd,%rax
    0.00 :	  67625b:       48 03 05 96 98 54 00    add    0x549896(%rip),%rax        # bbfaf8 <BufferBlocks>
         :	                if (!PageIsNew((Page) bufBlock))
    0.00 :	  676262:       66 83 78 0e 00          cmpw   $0x0,0xe(%rax)
    0.00 :	  676267:       0f 85 19 02 00 00       jne    676486 <ReadBuffer_common+0x7e6>
         :	                 * We *must* do smgrextend before succeeding, else the page will not
         :	                 * be reserved by the kernel, and the next P_NEW call will decide to
         :	                 * return the same page.  Clear the BM_VALID bit, do the StartBufferIO
         :	                 * call that BufferAlloc didn't, and proceed.
         :	                 */
         :	                if (isLocalBuf)
    0.00 :	  67626d:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  676271:       49 8d 5e 20             lea    0x20(%r14),%rbx
    0.00 :	  676275:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  67627b:       74 54                   je     6762d1 <ReadBuffer_common+0x631>
         :	                {
         :	                        /* Only need to adjust flags */
         :	                        Assert(bufHdr->flags & BM_VALID);
         :	                        bufHdr->flags &= ~BM_VALID;
    0.00 :	  67627d:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  676282:       83 e0 fd                and    $0xfffffffd,%eax
    0.00 :	  676285:       66 41 89 46 14          mov    %ax,0x14(%r14)
    0.00 :	  67628a:       e9 b1 fb ff ff          jmpq   675e40 <ReadBuffer_common+0x1a0>
         :	         * read it before we did, so there's nothing left for BufferAlloc() to do.
         :	         */
         :	        if (StartBufferIO(buf, true))
         :	                *foundPtr = FALSE;
         :	        else
         :	                *foundPtr = TRUE;
    0.00 :	  67628f:       c6 45 cf 01             movb   $0x1,-0x31(%rbp)
    0.00 :	  676293:       e9 8c fb ff ff          jmpq   675e24 <ReadBuffer_common+0x184>
         :	                         * BM_VALID between our clearing it and StartBufferIO inspecting
         :	                         * it.
         :	                         */
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
    0.00 :	  676298:       ba ae 02 00 00          mov    $0x2ae,%edx
    0.00 :	  67629d:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  6762a2:       48 89 df                mov    %rbx,%rdi
    0.00 :	  6762a5:       e8 96 9d 01 00          callq  690040 <s_lock>
         :	                                Assert(bufHdr->flags & BM_VALID);
         :	                                bufHdr->flags &= ~BM_VALID;
    0.00 :	  6762aa:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  6762af:       83 e0 fd                and    $0xfffffffd,%eax
    0.00 :	  6762b2:       66 41 89 46 14          mov    %ax,0x14(%r14)
         :	                                UnlockBufHdr(bufHdr);
         :	                        } while (!StartBufferIO(bufHdr, true));
    0.00 :	  6762b7:       be 01 00 00 00          mov    $0x1,%esi
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
         :	                                Assert(bufHdr->flags & BM_VALID);
         :	                                bufHdr->flags &= ~BM_VALID;
         :	                                UnlockBufHdr(bufHdr);
    0.00 :	  6762bc:       41 c6 46 20 00          movb   $0x0,0x20(%r14)
         :	                        } while (!StartBufferIO(bufHdr, true));
    0.00 :	  6762c1:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  6762c4:       e8 77 e1 ff ff          callq  674440 <StartBufferIO>
    0.00 :	  6762c9:       84 c0                   test   %al,%al
    0.00 :	  6762cb:       0f 85 fa fe ff ff       jne    6761cb <ReadBuffer_common+0x52b>
    0.00 :	  6762d1:       44 89 e0                mov    %r12d,%eax
    0.00 :	  6762d4:       f0 86 03                lock xchg %al,(%rbx)
         :	                         * BM_VALID between our clearing it and StartBufferIO inspecting
         :	                         * it.
         :	                         */
         :	                        do
         :	                        {
         :	                                LockBufHdr(bufHdr);
    0.00 :	  6762d7:       84 c0                   test   %al,%al
    0.00 :	  6762d9:       74 cf                   je     6762aa <ReadBuffer_common+0x60a>
    0.00 :	  6762db:       eb bb                   jmp    676298 <ReadBuffer_common+0x5f8>
         :	                 * lseek(SEEK_END) result that doesn't account for a recent write. In
         :	                 * that situation, the pre-existing buffer would contain valid data
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
    0.00 :	  6762dd:       41 8b 46 24             mov    0x24(%r14),%eax
    0.00 :	  6762e1:       ba fe ff ff ff          mov    $0xfffffffe,%edx
    0.00 :	  6762e6:       29 c2                   sub    %eax,%edx
    0.00 :	  6762e8:       48 8b 05 29 6e 50 00    mov    0x506e29(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  6762ef:       48 63 d2                movslq %edx,%rdx
    0.00 :	  6762f2:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  6762f6:       e9 67 ff ff ff          jmpq   676262 <ReadBuffer_common+0x5c2>
         :	                        /* check for garbage data */
         :	                        if (!PageIsVerified((Page) bufBlock, blockNum))
         :	                        {
         :	                                if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
         :	                                {
         :	                                        ereport(WARNING,
    0.00 :	  6762fb:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  6762ff:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  676306:       48 89 d0                mov    %rdx,%rax
    0.00 :	  676309:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  67630c:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  67630f:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  676312:       8b 30                   mov    (%rax),%esi
    0.00 :	  676314:       e8 b7 82 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  676319:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  67631f:       48 89 c2                mov    %rax,%rdx
    0.00 :	  676322:       bf c8 9e 8a 00          mov    $0x8a9ec8,%edi
    0.00 :	  676327:       31 c0                   xor    %eax,%eax
    0.00 :	  676329:       e8 72 65 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67632e:       bf 28 0a 00 01          mov    $0x1000a28,%edi
    0.00 :	  676333:       89 c3                   mov    %eax,%ebx
    0.00 :	  676335:       e8 16 6a 10 00          callq  77cd50 <errcode>
    0.00 :	  67633a:       89 de                   mov    %ebx,%esi
    0.00 :	  67633c:       89 c7                   mov    %eax,%edi
    0.00 :	  67633e:       31 c0                   xor    %eax,%eax
    0.00 :	  676340:       e8 9b 42 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676345:       e9 a0 fb ff ff          jmpq   675eea <ReadBuffer_common+0x24a>
         :	                {
         :	                        instr_time      io_start,
         :	                                                io_time;
         :
         :	                        if (track_io_timing)
         :	                                INSTR_TIME_SET_CURRENT(io_start);
    0.00 :	  67634a:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  67634e:       31 f6                   xor    %esi,%esi
    0.00 :	  676350:       e8 6b 32 df ff          callq  4695c0 <gettimeofday@plt>
    0.00 :	  676355:       e9 1f fb ff ff          jmpq   675e79 <ReadBuffer_common+0x1d9>
         :
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
    0.00 :	  67635a:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  67635e:       31 f6                   xor    %esi,%esi
    0.00 :	  676360:       e8 5b 32 df ff          callq  4695c0 <gettimeofday@plt>
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
    0.00 :	  676365:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
    0.00 :	  676369:       48 2b 55 98             sub    -0x68(%rbp),%rdx
    0.00 :	  67636d:       48 8b 45 b0             mov    -0x50(%rbp),%rax
    0.00 :	  676371:       48 2b 45 90             sub    -0x70(%rbp),%rax
    0.00 :	  676375:       48 85 d2                test   %rdx,%rdx
    0.00 :	  676378:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
    0.00 :	  67637c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  67637f:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  676383:       79 18                   jns    67639d <ReadBuffer_common+0x6fd>
         :	 */
         :	static Buffer
         :	ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
         :	                                  BlockNumber blockNum, ReadBufferMode mode,
         :	                                  BufferAccessStrategy strategy, bool *hit)
         :	{
    0.00 :	  676385:       48 83 e8 01             sub    $0x1,%rax
         :	                        smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
    0.00 :	  676389:       48 81 c2 40 42 0f 00    add    $0xf4240,%rdx
    0.00 :	  676390:       78 f3                   js     676385 <ReadBuffer_common+0x6e5>
    0.00 :	  676392:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  676396:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
    0.00 :	  67639a:       48 89 c1                mov    %rax,%rcx
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
    0.00 :	  67639d:       48 69 c1 40 42 0f 00    imul   $0xf4240,%rcx,%rax
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
    0.00 :	  6763a4:       48 01 0d 05 94 54 00    add    %rcx,0x549405(%rip)        # bbf7b0 <pgBufferUsage+0x50>
         :
         :	                        if (track_io_timing)
         :	                        {
         :	                                INSTR_TIME_SET_CURRENT(io_time);
         :	                                INSTR_TIME_SUBTRACT(io_time, io_start);
         :	                                pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));
    0.00 :	  6763ab:       48 8d 04 02             lea    (%rdx,%rax,1),%rax
    0.00 :	  6763af:       48 01 05 0a 58 50 00    add    %rax,0x50580a(%rip)        # b7bbc0 <pgStatBlockReadTime>
         :	                                INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);
    0.00 :	  6763b6:       48 8b 05 fb 93 54 00    mov    0x5493fb(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763bd:       48 03 45 b8             add    -0x48(%rbp),%rax
    0.00 :	  6763c1:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6763c7:       48 89 05 ea 93 54 00    mov    %rax,0x5493ea(%rip)        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763ce:       0f 8e ca fa ff ff       jle    675e9e <ReadBuffer_common+0x1fe>
    0.00 :	  6763d4:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  6763da:       48 83 05 ce 93 54 00    addq   $0x1,0x5493ce(%rip)        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  6763e1:       01 
    0.00 :	  6763e2:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6763e8:       48 89 05 c9 93 54 00    mov    %rax,0x5493c9(%rip)        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  6763ef:       7f e3                   jg     6763d4 <ReadBuffer_common+0x734>
    0.00 :	  6763f1:       e9 a8 fa ff ff          jmpq   675e9e <ReadBuffer_common+0x1fe>
         :	         * 1 so that the buffer can survive one clock-sweep pass.)
         :	         */
         :	        buf->tag = newTag;
         :	        buf->flags &= ~(BM_VALID | BM_DIRTY | BM_JUST_DIRTIED | BM_CHECKPOINT_NEEDED | BM_IO_ERROR | BM_PERMANENT);
         :	        if (relpersistence == RELPERSISTENCE_PERMANENT)
         :	                buf->flags |= BM_TAG_VALID | BM_PERMANENT;
    0.00 :	  6763f6:       41 0f b7 46 14          movzwl 0x14(%r14),%eax
    0.00 :	  6763fb:       66 0d 04 01             or     $0x104,%ax
    0.00 :	  6763ff:       66 41 89 46 14          mov    %ax,0x14(%r14)
    0.00 :	  676404:       e9 87 fd ff ff          jmpq   676190 <ReadBuffer_common+0x4f0>
         :	        buf->usage_count = 1;
         :
         :	        UnlockBufHdr(buf);
         :
         :	        if (oldFlags & BM_TAG_VALID)
         :	                BufTableDelete(&oldTag);
    0.00 :	  676409:       48 8d 7d 90             lea    -0x70(%rbp),%rdi
    0.00 :	  67640d:       e8 3e d9 ff ff          callq  673d50 <BufTableDelete>
    0.00 :	  676412:       e9 8e fd ff ff          jmpq   6761a5 <ReadBuffer_common+0x505>
         :	                                                                        blockNum,
         :	                                                                        relpath(smgr->smgr_rnode, forkNum))));
         :	                                        MemSet((char *) bufBlock, 0, BLCKSZ);
         :	                                }
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  676417:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  67641a:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  67641f:       ba f8 02 00 00          mov    $0x2f8,%edx
    0.00 :	  676424:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676429:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67642e:       e8 8d 46 10 00          callq  77aac0 <errstart>
    0.00 :	  676433:       84 c0                   test   %al,%al
    0.00 :	  676435:       74 4a                   je     676481 <ReadBuffer_common+0x7e1>
    0.00 :	  676437:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  67643b:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  676442:       48 89 d0                mov    %rdx,%rax
    0.00 :	  676445:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  676448:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  67644b:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  67644e:       8b 30                   mov    (%rax),%esi
    0.00 :	  676450:       e8 7b 81 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  676455:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  67645b:       48 89 c2                mov    %rax,%rdx
    0.00 :	  67645e:       bf 48 28 88 00          mov    $0x882848,%edi
    0.00 :	  676463:       31 c0                   xor    %eax,%eax
    0.00 :	  676465:       e8 36 64 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67646a:       bf 28 0a 00 01          mov    $0x1000a28,%edi
    0.00 :	  67646f:       89 c3                   mov    %eax,%ebx
    0.00 :	  676471:       e8 da 68 10 00          callq  77cd50 <errcode>
    0.00 :	  676476:       89 de                   mov    %ebx,%esi
    0.00 :	  676478:       89 c7                   mov    %eax,%edi
    0.00 :	  67647a:       31 c0                   xor    %eax,%eax
    0.00 :	  67647c:       e8 5f 41 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676481:       e8 4a 30 df ff          callq  4694d0 <abort@plt>
         :	                 * that we don't want to overwrite.  Since the legitimate case should
         :	                 * always have left a zero-filled buffer, complain if not PageIsNew.
         :	                 */
         :	                bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);
         :	                if (!PageIsNew((Page) bufBlock))
         :	                        ereport(ERROR,
    0.00 :	  676486:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  676489:       b9 a0 a0 8a 00          mov    $0x8aa0a0,%ecx
    0.00 :	  67648e:       ba 97 02 00 00          mov    $0x297,%edx
    0.00 :	  676493:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676498:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67649d:       e8 1e 46 10 00          callq  77aac0 <errstart>
    0.00 :	  6764a2:       84 c0                   test   %al,%al
    0.00 :	  6764a4:       74 db                   je     676481 <ReadBuffer_common+0x7e1>
    0.00 :	  6764a6:       bf 40 9e 8a 00          mov    $0x8a9e40,%edi
    0.00 :	  6764ab:       31 c0                   xor    %eax,%eax
    0.00 :	  6764ad:       e8 ee 57 10 00          callq  77bca0 <errhint>
    0.00 :	  6764b2:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	  6764b6:       89 c3                   mov    %eax,%ebx
    0.00 :	  6764b8:       44 8b 85 78 ff ff ff    mov    -0x88(%rbp),%r8d
    0.00 :	  6764bf:       48 89 d0                mov    %rdx,%rax
    0.00 :	  6764c2:       8b 4a 0c                mov    0xc(%rdx),%ecx
    0.00 :	  6764c5:       8b 52 08                mov    0x8(%rdx),%edx
    0.00 :	  6764c8:       8b 78 04                mov    0x4(%rax),%edi
    0.00 :	  6764cb:       8b 30                   mov    (%rax),%esi
    0.00 :	  6764cd:       e8 fe 80 13 00          callq  7ae5d0 <GetRelationPath>
    0.00 :	  6764d2:       8b b5 74 ff ff ff       mov    -0x8c(%rbp),%esi
    0.00 :	  6764d8:       48 89 c2                mov    %rax,%rdx
    0.00 :	  6764db:       bf 90 9e 8a 00          mov    $0x8a9e90,%edi
    0.00 :	  6764e0:       31 c0                   xor    %eax,%eax
    0.00 :	  6764e2:       e8 b9 63 10 00          callq  77c8a0 <errmsg>
    0.00 :	  6764e7:       89 de                   mov    %ebx,%esi
    0.00 :	  6764e9:       89 c7                   mov    %eax,%edi
    0.00 :	  6764eb:       31 c0                   xor    %eax,%eax
    0.00 :	  6764ed:       e8 ee 40 10 00          callq  77a5e0 <errfinish>
    0.00 :	  6764f2:       eb 8d                   jmp    676481 <ReadBuffer_common+0x7e1>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   40.00 ??:0
   30.00 ??:0
   20.00 ??:0
   10.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000099390 <__gettimeofday>:
 ??:0
   20.00 :	   99390:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   99394:       48 8b 05 ad de 2d 00    mov    0x2ddead(%rip),%rax        # 377248 <__vdso_gettimeofday>
   40.00 :	   9939b:       48 c1 c8 11             ror    $0x11,%rax
   10.00 :	   9939f:       64 48 33 04 25 30 00    xor    %fs:0x30,%rax
    0.00 :	   993a6:       00 00 
    0.00 :	   993a8:       ff d0                   callq  *%rax
   30.00 :	   993aa:       3d 01 f0 ff ff          cmp    $0xfffff001,%eax
    0.00 :	   993af:       73 05                   jae    993b6 <__gettimeofday+0x26>
    0.00 :	   993b1:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   993b5:       c3                      retq   
    0.00 :	   993b6:       48 8b 0d 7b 8a 2d 00    mov    0x2d8a7b(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   993bd:       31 d2                   xor    %edx,%edx
    0.00 :	   993bf:       48 29 c2                sub    %rax,%rdx
    0.00 :	   993c2:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   993c5:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   993c9:       eb e6                   jmp    993b1 <__gettimeofday+0x21>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:60
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:60
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:67
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:101
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:101
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:110
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:125
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:94
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:99
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ad100 <_bt_search>:
         :	 * any incomplete splits encountered during the search will be finished.
         :	 */
         :	BTStack
         :	_bt_search(Relation rel, int keysz, ScanKey scankey, bool nextkey,
         :	                   Buffer *bufP, int access)
         :	{
    0.00 :	  4ad100:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:60
   11.11 :	  4ad101:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ad104:       41 57                   push   %r15
    0.00 :	  4ad106:       41 56                   push   %r14
   11.11 :	  4ad108:       41 55                   push   %r13
    0.00 :	  4ad10a:       41 54                   push   %r12
    0.00 :	  4ad10c:       41 89 cc                mov    %ecx,%r12d
    0.00 :	  4ad10f:       53                      push   %rbx
    0.00 :	  4ad110:       44 89 cb                mov    %r9d,%ebx
    0.00 :	  4ad113:       48 83 ec 48             sub    $0x48,%rsp
    0.00 :	  4ad117:       89 75 bc                mov    %esi,-0x44(%rbp)
         :	        BTStack         stack_in = NULL;
         :
         :	        /* Get the root page to start with */
         :	        *bufP = _bt_getroot(rel, access);
    0.00 :	  4ad11a:       44 89 ce                mov    %r9d,%esi
         :	 * any incomplete splits encountered during the search will be finished.
         :	 */
         :	BTStack
         :	_bt_search(Relation rel, int keysz, ScanKey scankey, bool nextkey,
         :	                   Buffer *bufP, int access)
         :	{
    0.00 :	  4ad11d:       48 89 7d c0             mov    %rdi,-0x40(%rbp)
    0.00 :	  4ad121:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
    0.00 :	  4ad125:       4c 89 45 a8             mov    %r8,-0x58(%rbp)
         :	        BTStack         stack_in = NULL;
         :
         :	        /* Get the root page to start with */
         :	        *bufP = _bt_getroot(rel, access);
    0.00 :	  4ad129:       e8 f2 da ff ff          callq  4aac20 <_bt_getroot>
    0.00 :	  4ad12e:       89 c6                   mov    %eax,%esi
    0.00 :	  4ad130:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :
         :	        /* If index is empty and access = BT_READ, no root page is created. */
         :	        if (!BufferIsValid(*bufP))
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:67
   11.11 :	  4ad134:       85 f6                   test   %esi,%esi
         :	                   Buffer *bufP, int access)
         :	{
         :	        BTStack         stack_in = NULL;
         :
         :	        /* Get the root page to start with */
         :	        *bufP = _bt_getroot(rel, access);
    0.00 :	  4ad136:       89 30                   mov    %esi,(%rax)
         :	                /* drop the read lock on the parent page, acquire one on the child */
         :	                *bufP = _bt_relandgetbuf(rel, *bufP, blkno, BT_READ);
         :
         :	                /* okay, all set to move down a level */
         :	                stack_in = new_stack;
         :	        }
    0.00 :	  4ad138:       48 c7 45 c8 00 00 00    movq   $0x0,-0x38(%rbp)
    0.00 :	  4ad13f:       00 
         :
         :	        /* Get the root page to start with */
         :	        *bufP = _bt_getroot(rel, access);
         :
         :	        /* If index is empty and access = BT_READ, no root page is created. */
         :	        if (!BufferIsValid(*bufP))
    0.00 :	  4ad140:       0f 84 2a 01 00 00       je     4ad270 <_bt_search+0x170>
    0.00 :	  4ad146:       31 c0                   xor    %eax,%eax
    0.00 :	  4ad148:       83 fb 02                cmp    $0x2,%ebx
    0.00 :	  4ad14b:       45 0f be e4             movsbl %r12b,%r12d
    0.00 :	  4ad14f:       0f 94 c0                sete   %al
    0.00 :	  4ad152:       44 89 65 d0             mov    %r12d,-0x30(%rbp)
    0.00 :	  4ad156:       89 45 d4                mov    %eax,-0x2c(%rbp)
    0.00 :	  4ad159:       e9 b5 00 00 00          jmpq   4ad213 <_bt_search+0x113>
    0.00 :	  4ad15e:       66 90                   xchg   %ax,%ax
         :	                *bufP = _bt_moveright(rel, *bufP, keysz, scankey, nextkey,
         :	                                                          (access == BT_WRITE), stack_in,
         :	                                                          BT_READ);
         :
         :	                /* if this is a leaf page, we're done */
         :	                page = BufferGetPage(*bufP);
    0.00 :	  4ad160:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ad163:       4c 63 e0                movslq %eax,%r12
    0.00 :	  4ad166:       49 c1 e4 0d             shl    $0xd,%r12
    0.00 :	  4ad16a:       4c 03 25 87 29 71 00    add    0x712987(%rip),%r12        # bbfaf8 <BufferBlocks>
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                if (P_ISLEAF(opaque))
    0.00 :	  4ad171:       41 0f b7 44 24 10       movzwl 0x10(%r12),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:101
   11.11 :	  4ad177:       41 f6 44 04 0c 01       testb  $0x1,0xc(%r12,%rax,1)
   11.11 :	  4ad17d:       0f 85 ed 00 00 00       jne    4ad270 <_bt_search+0x170>
         :
         :	                /*
         :	                 * Find the appropriate item on the internal page, and get the child
         :	                 * page that it points to.
         :	                 */
         :	                offnum = _bt_binsrch(rel, *bufP, keysz, scankey, nextkey);
    0.00 :	  4ad183:       44 8b 45 d0             mov    -0x30(%rbp),%r8d
    0.00 :	  4ad187:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
    0.00 :	  4ad18b:       8b 55 bc                mov    -0x44(%rbp),%edx
    0.00 :	  4ad18e:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  4ad192:       e8 c9 fc ff ff          callq  4ace60 <_bt_binsrch>
    0.00 :	  4ad197:       41 89 c7                mov    %eax,%r15d
         :	                itemid = PageGetItemId(page, offnum);
         :	                itup = (IndexTuple) PageGetItem(page, itemid);
    0.00 :	  4ad19a:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4ad19d:       41 0f b7 5c 84 14       movzwl 0x14(%r12,%rax,4),%ebx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:110
   11.11 :	  4ad1a3:       81 e3 ff 7f 00 00       and    $0x7fff,%ebx
    0.00 :	  4ad1a9:       49 8d 1c 1c             lea    (%r12,%rbx,1),%rbx
         :	                blkno = ItemPointerGetBlockNumber(&(itup->t_tid));
    0.00 :	  4ad1ad:       44 0f b7 2b             movzwl (%rbx),%r13d
    0.00 :	  4ad1b1:       0f b7 43 02             movzwl 0x2(%rbx),%eax
    0.00 :	  4ad1b5:       41 c1 e5 10             shl    $0x10,%r13d
    0.00 :	  4ad1b9:       41 09 c5                or     %eax,%r13d
         :	                par_blkno = BufferGetBlockNumber(*bufP);
    0.00 :	  4ad1bc:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  4ad1c0:       8b 38                   mov    (%rax),%edi
    0.00 :	  4ad1c2:       e8 69 6e 1c 00          callq  674030 <BufferGetBlockNumber>
         :	                 * moves right while we're working lower in the tree.  See the paper
         :	                 * by Lehman and Yao for how this is detected and handled. (We use the
         :	                 * child link to disambiguate duplicate keys in the index -- Lehman
         :	                 * and Yao disallow duplicate keys.)
         :	                 */
         :	                new_stack = (BTStack) palloc(sizeof(BTStackData));
    0.00 :	  4ad1c7:       bf 18 00 00 00          mov    $0x18,%edi
         :	                 */
         :	                offnum = _bt_binsrch(rel, *bufP, keysz, scankey, nextkey);
         :	                itemid = PageGetItemId(page, offnum);
         :	                itup = (IndexTuple) PageGetItem(page, itemid);
         :	                blkno = ItemPointerGetBlockNumber(&(itup->t_tid));
         :	                par_blkno = BufferGetBlockNumber(*bufP);
    0.00 :	  4ad1cc:       41 89 c6                mov    %eax,%r14d
         :	                 * moves right while we're working lower in the tree.  See the paper
         :	                 * by Lehman and Yao for how this is detected and handled. (We use the
         :	                 * child link to disambiguate duplicate keys in the index -- Lehman
         :	                 * and Yao disallow duplicate keys.)
         :	                 */
         :	                new_stack = (BTStack) palloc(sizeof(BTStackData));
    0.00 :	  4ad1cf:       e8 7c bb 2e 00          callq  798d50 <palloc>
         :	                new_stack->bts_blkno = par_blkno;
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:125
   11.11 :	  4ad1d4:       44 89 30                mov    %r14d,(%rax)
         :	                new_stack->bts_offset = offnum;
    0.00 :	  4ad1d7:       66 44 89 78 04          mov    %r15w,0x4(%rax)
         :	                 * moves right while we're working lower in the tree.  See the paper
         :	                 * by Lehman and Yao for how this is detected and handled. (We use the
         :	                 * child link to disambiguate duplicate keys in the index -- Lehman
         :	                 * and Yao disallow duplicate keys.)
         :	                 */
         :	                new_stack = (BTStack) palloc(sizeof(BTStackData));
    0.00 :	  4ad1dc:       49 89 c4                mov    %rax,%r12
         :	                new_stack->bts_blkno = par_blkno;
         :	                new_stack->bts_offset = offnum;
         :	                memcpy(&new_stack->bts_btentry, itup, sizeof(IndexTupleData));
    0.00 :	  4ad1df:       48 8b 03                mov    (%rbx),%rax
         :	                new_stack->bts_parent = stack_in;
         :
         :	                /* drop the read lock on the parent page, acquire one on the child */
         :	                *bufP = _bt_relandgetbuf(rel, *bufP, blkno, BT_READ);
    0.00 :	  4ad1e2:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ad1e7:       44 89 ea                mov    %r13d,%edx
         :	                 * and Yao disallow duplicate keys.)
         :	                 */
         :	                new_stack = (BTStack) palloc(sizeof(BTStackData));
         :	                new_stack->bts_blkno = par_blkno;
         :	                new_stack->bts_offset = offnum;
         :	                memcpy(&new_stack->bts_btentry, itup, sizeof(IndexTupleData));
    0.00 :	  4ad1ea:       49 89 44 24 06          mov    %rax,0x6(%r12)
         :	                new_stack->bts_parent = stack_in;
    0.00 :	  4ad1ef:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4ad1f3:       49 89 44 24 10          mov    %rax,0x10(%r12)
         :
         :	                /* drop the read lock on the parent page, acquire one on the child */
         :	                *bufP = _bt_relandgetbuf(rel, *bufP, blkno, BT_READ);
    0.00 :	  4ad1f8:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  4ad1fc:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  4ad200:       8b 30                   mov    (%rax),%esi
    0.00 :	  4ad202:       e8 d9 bd ff ff          callq  4a8fe0 <_bt_relandgetbuf>
    0.00 :	  4ad207:       89 c6                   mov    %eax,%esi
    0.00 :	  4ad209:       48 8b 45 a8             mov    -0x58(%rbp),%rax
    0.00 :	  4ad20d:       89 30                   mov    %esi,(%rax)
    0.00 :	  4ad20f:       4c 89 65 c8             mov    %r12,-0x38(%rbp)
         :	                 * incomplete split on the leaf page we're about to insert to, not on
         :	                 * any of the upper levels (they is taken care of in _bt_getstackbuf,
         :	                 * if the leaf page is split and we insert to the parent page).  But
         :	                 * this is a good opportunity to finish splits of internal pages too.
         :	                 */
         :	                *bufP = _bt_moveright(rel, *bufP, keysz, scankey, nextkey,
    0.00 :	  4ad213:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4ad217:       44 8b 4d d4             mov    -0x2c(%rbp),%r9d
    0.00 :	  4ad21b:       44 8b 45 d0             mov    -0x30(%rbp),%r8d
    0.00 :	  4ad21f:       48 8b 4d b0             mov    -0x50(%rbp),%rcx
    0.00 :	  4ad223:       8b 55 bc                mov    -0x44(%rbp),%edx
    0.00 :	  4ad226:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:94
   11.11 :	  4ad22a:       c7 44 24 08 01 00 00    movl   $0x1,0x8(%rsp)
    0.00 :	  4ad231:       00 
    0.00 :	  4ad232:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  4ad236:       e8 35 fd ff ff          callq  4acf70 <_bt_moveright>
    0.00 :	  4ad23b:       89 c6                   mov    %eax,%esi
    0.00 :	  4ad23d:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	                                                          (access == BT_WRITE), stack_in,
         :	                                                          BT_READ);
         :
         :	                /* if this is a leaf page, we're done */
         :	                page = BufferGetPage(*bufP);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:99
   11.11 :	  4ad241:       85 f6                   test   %esi,%esi
         :	                 * incomplete split on the leaf page we're about to insert to, not on
         :	                 * any of the upper levels (they is taken care of in _bt_getstackbuf,
         :	                 * if the leaf page is split and we insert to the parent page).  But
         :	                 * this is a good opportunity to finish splits of internal pages too.
         :	                 */
         :	                *bufP = _bt_moveright(rel, *bufP, keysz, scankey, nextkey,
    0.00 :	  4ad243:       89 30                   mov    %esi,(%rax)
         :	                                                          (access == BT_WRITE), stack_in,
         :	                                                          BT_READ);
         :
         :	                /* if this is a leaf page, we're done */
         :	                page = BufferGetPage(*bufP);
    0.00 :	  4ad245:       0f 89 15 ff ff ff       jns    4ad160 <_bt_search+0x60>
    0.00 :	  4ad24b:       89 f0                   mov    %esi,%eax
    0.00 :	  4ad24d:       48 8b 15 c4 fe 6c 00    mov    0x6cfec4(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ad254:       f7 d0                   not    %eax
    0.00 :	  4ad256:       48 98                   cltq   
    0.00 :	  4ad258:       4c 8b 24 c2             mov    (%rdx,%rax,8),%r12
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                if (P_ISLEAF(opaque))
    0.00 :	  4ad25c:       41 0f b7 44 24 10       movzwl 0x10(%r12),%eax
    0.00 :	  4ad262:       41 f6 44 04 0c 01       testb  $0x1,0xc(%r12,%rax,1)
    0.00 :	  4ad268:       0f 84 15 ff ff ff       je     4ad183 <_bt_search+0x83>
    0.00 :	  4ad26e:       66 90                   xchg   %ax,%ax
         :	                /* okay, all set to move down a level */
         :	                stack_in = new_stack;
         :	        }
         :
         :	        return stack_in;
         :	}
    0.00 :	  4ad270:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4ad274:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  4ad278:       5b                      pop    %rbx
    0.00 :	  4ad279:       41 5c                   pop    %r12
    0.00 :	  4ad27b:       41 5d                   pop    %r13
    0.00 :	  4ad27d:       41 5e                   pop    %r14
    0.00 :	  4ad27f:       41 5f                   pop    %r15
    0.00 :	  4ad281:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:54
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:57
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:65
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b7f00 <InstrStartNode>:
         :	}
         :
         :	/* Entry to a plan node */
         :	void
         :	InstrStartNode(Instrumentation *instr)
         :	{
    0.00 :	  5b7f00:       55                      push   %rbp
    0.00 :	  5b7f01:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b7f04:       53                      push   %rbx
    0.00 :	  5b7f05:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b7f08:       48 83 ec 08             sub    $0x8,%rsp
         :	        if (instr->need_timer)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:54
   11.11 :	  5b7f0c:       80 3f 00                cmpb   $0x0,(%rdi)
    0.00 :	  5b7f0f:       74 4a                   je     5b7f5b <InstrStartNode+0x5b>
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
    0.00 :	  5b7f11:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
    0.00 :	  5b7f16:       75 07                   jne    5b7f1f <InstrStartNode+0x1f>
    0.00 :	  5b7f18:       48 83 7f 08 00          cmpq   $0x0,0x8(%rdi)
    0.00 :	  5b7f1d:       74 31                   je     5b7f50 <InstrStartNode+0x50>
         :	                        INSTR_TIME_SET_CURRENT(instr->starttime);
         :	                else
         :	                        elog(ERROR, "InstrStartNode called twice in a row");
    0.00 :	  5b7f1f:       ba 98 b6 88 00          mov    $0x88b698,%edx
    0.00 :	  5b7f24:       be 3b 00 00 00          mov    $0x3b,%esi
    0.00 :	  5b7f29:       bf fa b5 88 00          mov    $0x88b5fa,%edi
    0.00 :	  5b7f2e:       e8 ed 34 1c 00          callq  77b420 <elog_start>
    0.00 :	  5b7f33:       be 58 b6 88 00          mov    $0x88b658,%esi
    0.00 :	  5b7f38:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b7f3d:       31 c0                   xor    %eax,%eax
    0.00 :	  5b7f3f:       e8 ec 32 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5b7f44:       e8 87 15 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5b7f49:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	InstrStartNode(Instrumentation *instr)
         :	{
         :	        if (instr->need_timer)
         :	        {
         :	                if (INSTR_TIME_IS_ZERO(instr->starttime))
         :	                        INSTR_TIME_SET_CURRENT(instr->starttime);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:57
   11.11 :	  5b7f50:       48 8d 7f 08             lea    0x8(%rdi),%rdi
    0.00 :	  5b7f54:       31 f6                   xor    %esi,%esi
    0.00 :	  5b7f56:       e8 65 16 eb ff          callq  4695c0 <gettimeofday@plt>
         :	                else
         :	                        elog(ERROR, "InstrStartNode called twice in a row");
         :	        }
         :
         :	        /* save buffer usage totals at node entry, if needed */
         :	        if (instr->need_bufusage)
    0.00 :	  5b7f5b:       80 7b 01 00             cmpb   $0x0,0x1(%rbx)
    0.00 :	  5b7f5f:       0f 84 a9 00 00 00       je     5b800e <InstrStartNode+0x10e>
         :	                instr->bufusage_start = pgBufferUsage;
    0.00 :	  5b7f65:       48 8b 05 f4 77 60 00    mov    0x6077f4(%rip),%rax        # bbf760 <pgBufferUsage>
    0.00 :	  5b7f6c:       48 89 43 38             mov    %rax,0x38(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:64
   11.11 :	  5b7f70:       48 8b 05 f1 77 60 00    mov    0x6077f1(%rip),%rax        # bbf768 <pgBufferUsage+0x8>
    0.00 :	  5b7f77:       48 89 43 40             mov    %rax,0x40(%rbx)
    0.00 :	  5b7f7b:       48 8b 05 ee 77 60 00    mov    0x6077ee(%rip),%rax        # bbf770 <pgBufferUsage+0x10>
    0.00 :	  5b7f82:       48 89 43 48             mov    %rax,0x48(%rbx)
   11.11 :	  5b7f86:       48 8b 05 eb 77 60 00    mov    0x6077eb(%rip),%rax        # bbf778 <pgBufferUsage+0x18>
    0.00 :	  5b7f8d:       48 89 43 50             mov    %rax,0x50(%rbx)
    0.00 :	  5b7f91:       48 8b 05 e8 77 60 00    mov    0x6077e8(%rip),%rax        # bbf780 <pgBufferUsage+0x20>
    0.00 :	  5b7f98:       48 89 43 58             mov    %rax,0x58(%rbx)
    0.00 :	  5b7f9c:       48 8b 05 e5 77 60 00    mov    0x6077e5(%rip),%rax        # bbf788 <pgBufferUsage+0x28>
    0.00 :	  5b7fa3:       48 89 43 60             mov    %rax,0x60(%rbx)
    0.00 :	  5b7fa7:       48 8b 05 e2 77 60 00    mov    0x6077e2(%rip),%rax        # bbf790 <pgBufferUsage+0x30>
    0.00 :	  5b7fae:       48 89 43 68             mov    %rax,0x68(%rbx)
   33.33 :	  5b7fb2:       48 8b 05 df 77 60 00    mov    0x6077df(%rip),%rax        # bbf798 <pgBufferUsage+0x38>
    0.00 :	  5b7fb9:       48 89 43 70             mov    %rax,0x70(%rbx)
    0.00 :	  5b7fbd:       48 8b 05 dc 77 60 00    mov    0x6077dc(%rip),%rax        # bbf7a0 <pgBufferUsage+0x40>
    0.00 :	  5b7fc4:       48 89 43 78             mov    %rax,0x78(%rbx)
    0.00 :	  5b7fc8:       48 8b 05 d9 77 60 00    mov    0x6077d9(%rip),%rax        # bbf7a8 <pgBufferUsage+0x48>
    0.00 :	  5b7fcf:       48 89 83 80 00 00 00    mov    %rax,0x80(%rbx)
    0.00 :	  5b7fd6:       48 8b 05 d3 77 60 00    mov    0x6077d3(%rip),%rax        # bbf7b0 <pgBufferUsage+0x50>
    0.00 :	  5b7fdd:       48 89 83 88 00 00 00    mov    %rax,0x88(%rbx)
    0.00 :	  5b7fe4:       48 8b 05 cd 77 60 00    mov    0x6077cd(%rip),%rax        # bbf7b8 <pgBufferUsage+0x58>
    0.00 :	  5b7feb:       48 89 83 90 00 00 00    mov    %rax,0x90(%rbx)
    0.00 :	  5b7ff2:       48 8b 05 c7 77 60 00    mov    0x6077c7(%rip),%rax        # bbf7c0 <pgBufferUsage+0x60>
    0.00 :	  5b7ff9:       48 89 83 98 00 00 00    mov    %rax,0x98(%rbx)
   11.11 :	  5b8000:       48 8b 05 c1 77 60 00    mov    0x6077c1(%rip),%rax        # bbf7c8 <pgBufferUsage+0x68>
    0.00 :	  5b8007:       48 89 83 a0 00 00 00    mov    %rax,0xa0(%rbx)
         :	}
    0.00 :	  5b800e:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5b8012:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:65
   11.11 :	  5b8013:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   55.56 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1438
   22.22 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1472
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1438
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1472
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbbb0 <ExecHashGetSkewBucket>:
         :	 *              or INVALID_SKEW_BUCKET_NO if the hashvalue is not
         :	 *              associated with any active skew bucket.
         :	 */
         :	int
         :	ExecHashGetSkewBucket(HashJoinTable hashtable, uint32 hashvalue)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1438
   11.11 :	  5bbbb0:       55                      push   %rbp
         :
         :	        /*
         :	         * Always return INVALID_SKEW_BUCKET_NO if not doing skew optimization (in
         :	         * particular, this happens after the initial batch is done).
         :	         */
         :	        if (!hashtable->skewEnabled)
    0.00 :	  5bbbb1:       80 7f 21 00             cmpb   $0x0,0x21(%rdi)
         :	 *              or INVALID_SKEW_BUCKET_NO if the hashvalue is not
         :	 *              associated with any active skew bucket.
         :	 */
         :	int
         :	ExecHashGetSkewBucket(HashJoinTable hashtable, uint32 hashvalue)
         :	{
   55.56 :	  5bbbb5:       48 89 e5                mov    %rsp,%rbp
         :
         :	        /*
         :	         * Always return INVALID_SKEW_BUCKET_NO if not doing skew optimization (in
         :	         * particular, this happens after the initial batch is done).
         :	         */
         :	        if (!hashtable->skewEnabled)
    0.00 :	  5bbbb8:       74 46                   je     5bbc00 <ExecHashGetSkewBucket+0x50>
         :	                return INVALID_SKEW_BUCKET_NO;
         :
         :	        /*
         :	         * Since skewBucketLen is a power of 2, we can do a modulo by ANDing.
         :	         */
         :	        bucket = hashvalue & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbba:       8b 47 30                mov    0x30(%rdi),%eax
    0.00 :	  5bbbbd:       89 f2                   mov    %esi,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbbf:       48 8b 4f 28             mov    0x28(%rdi),%rcx
         :	                return INVALID_SKEW_BUCKET_NO;
         :
         :	        /*
         :	         * Since skewBucketLen is a power of 2, we can do a modulo by ANDing.
         :	         */
         :	        bucket = hashvalue & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbc3:       44 8d 40 ff             lea    -0x1(%rax),%r8d
    0.00 :	  5bbbc7:       44 21 c2                and    %r8d,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbca:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bbbcd:       48 8b 04 c1             mov    (%rcx,%rax,8),%rax
    0.00 :	  5bbbd1:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbbd4:       75 1c                   jne    5bbbf2 <ExecHashGetSkewBucket+0x42>
    0.00 :	  5bbbd6:       eb 28                   jmp    5bbc00 <ExecHashGetSkewBucket+0x50>
    0.00 :	  5bbbd8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5bbbdf:       00 
         :	                   hashtable->skewBucket[bucket]->hashvalue != hashvalue)
         :	                bucket = (bucket + 1) & (hashtable->skewBucketLen - 1);
    0.00 :	  5bbbe0:       83 c2 01                add    $0x1,%edx
    0.00 :	  5bbbe3:       44 21 c2                and    %r8d,%edx
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbbe6:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bbbe9:       48 8b 04 c1             mov    (%rcx,%rax,8),%rax
    0.00 :	  5bbbed:       48 85 c0                test   %rax,%rax
    0.00 :	  5bbbf0:       74 0e                   je     5bbc00 <ExecHashGetSkewBucket+0x50>
    0.00 :	  5bbbf2:       39 30                   cmp    %esi,(%rax)
    0.00 :	  5bbbf4:       75 ea                   jne    5bbbe0 <ExecHashGetSkewBucket+0x30>
         :
         :	        /*
         :	         * There must not be any hashtable entry for this hash value.
         :	         */
         :	        return INVALID_SKEW_BUCKET_NO;
         :	}
    0.00 :	  5bbbf6:       89 d0                   mov    %edx,%eax
    0.00 :	  5bbbf8:       c9                      leaveq 
    0.00 :	  5bbbf9:       c3                      retq   
    0.00 :	  5bbbfa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        /*
         :	         * While we have not hit a hole in the hashtable and have not hit the
         :	         * desired bucket, we have collided with some other hash value, so try the
         :	         * next bucket location.
         :	         */
         :	        while (hashtable->skewBucket[bucket] != NULL &&
    0.00 :	  5bbc00:       ba ff ff ff ff          mov    $0xffffffff,%edx
         :
         :	        /*
         :	         * There must not be any hashtable entry for this hash value.
         :	         */
         :	        return INVALID_SKEW_BUCKET_NO;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1472
   11.11 :	  5bbc05:       c9                      leaveq 
   22.22 :	  5bbc06:       89 d0                   mov    %edx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1317
   22.22 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1331
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1309
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1317
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1321
   11.11 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1327
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077e030 <FunctionCall2Coll>:
         :	        return result;
         :	}
         :
         :	Datum
         :	FunctionCall2Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)
         :	{
    0.00 :	  77e030:       55                      push   %rbp
    0.00 :	  77e031:       48 89 f8                mov    %rdi,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1309
   11.11 :	  77e034:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  77e037:       48 81 ec b0 03 00 00    sub    $0x3b0,%rsp
         :	         * utils/sort/tuplesort.c!
         :	         */
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);
    0.00 :	  77e03e:       48 89 bd 50 fc ff ff    mov    %rdi,-0x3b0(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1317
   33.33 :	  77e045:       48 c7 85 58 fc ff ff    movq   $0x0,-0x3a8(%rbp)
    0.00 :	  77e04c:       00 00 00 00 
         :	        fcinfo.arg[0] = arg1;
         :	        fcinfo.arg[1] = arg2;
         :	        fcinfo.argnull[0] = false;
         :	        fcinfo.argnull[1] = false;
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77e050:       48 8d bd 50 fc ff ff    lea    -0x3b0(%rbp),%rdi
         :	         * utils/sort/tuplesort.c!
         :	         */
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);
   11.11 :	  77e057:       48 c7 85 60 fc ff ff    movq   $0x0,-0x3a0(%rbp)
    0.00 :	  77e05e:       00 00 00 00 
    0.00 :	  77e062:       89 b5 68 fc ff ff       mov    %esi,-0x398(%rbp)
    0.00 :	  77e068:       c6 85 6c fc ff ff 00    movb   $0x0,-0x394(%rbp)
    0.00 :	  77e06f:       66 c7 85 6e fc ff ff    movw   $0x2,-0x392(%rbp)
    0.00 :	  77e076:       02 00 
         :
         :	        fcinfo.arg[0] = arg1;
    0.00 :	  77e078:       48 89 95 70 fc ff ff    mov    %rdx,-0x390(%rbp)
         :	        fcinfo.arg[1] = arg2;
    0.00 :	  77e07f:       48 89 8d 78 fc ff ff    mov    %rcx,-0x388(%rbp)
         :	        fcinfo.argnull[0] = false;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1321
   11.11 :	  77e086:       c6 45 90 00             movb   $0x0,-0x70(%rbp)
         :	        fcinfo.argnull[1] = false;
    0.00 :	  77e08a:       c6 45 91 00             movb   $0x0,-0x6f(%rbp)
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77e08e:       ff 10                   callq  *(%rax)
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
    0.00 :	  77e090:       80 bd 6c fc ff ff 00    cmpb   $0x0,-0x394(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1327
   11.11 :	  77e097:       75 02                   jne    77e09b <FunctionCall2Coll+0x6b>
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
         :
         :	        return result;
         :	}
    0.00 :	  77e099:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1331
   22.22 :	  77e09a:       c3                      retq   
         :
         :	        result = FunctionCallInvoke(&fcinfo);
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
    0.00 :	  77e09b:       ba 40 52 8d 00          mov    $0x8d5240,%edx
    0.00 :	  77e0a0:       be 30 05 00 00          mov    $0x530,%esi
    0.00 :	  77e0a5:       bf b3 47 8d 00          mov    $0x8d47b3,%edi
    0.00 :	  77e0aa:       e8 71 d3 ff ff          callq  77b420 <elog_start>
    0.00 :	  77e0af:       48 8b 85 50 fc ff ff    mov    -0x3b0(%rbp),%rax
    0.00 :	  77e0b6:       be 97 4c 8d 00          mov    $0x8d4c97,%esi
    0.00 :	  77e0bb:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  77e0c0:       8b 50 08                mov    0x8(%rax),%edx
    0.00 :	  77e0c3:       31 c0                   xor    %eax,%eax
    0.00 :	  77e0c5:       e8 66 d1 ff ff          callq  77b230 <elog_finish>
    0.00 :	  77e0ca:       e8 01 b4 ce ff          callq  4694d0 <abort@plt>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:509
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:545
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:564
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:564
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:518
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:525
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:518
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:526
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5520 <index_fetch_heap>:
         :	 * enough information to do it efficiently in the general case.
         :	 * ----------------
         :	 */
         :	HeapTuple
         :	index_fetch_heap(IndexScanDesc scan)
         :	{
    0.00 :	  4a5520:       55                      push   %rbp
    0.00 :	  4a5521:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a5524:       41 55                   push   %r13
    0.00 :	  4a5526:       41 54                   push   %r12
    0.00 :	  4a5528:       49 89 fc                mov    %rdi,%r12
    0.00 :	  4a552b:       53                      push   %rbx
    0.00 :	  4a552c:       48 83 ec 18             sub    $0x18,%rsp
         :	        ItemPointer tid = &scan->xs_ctup.t_self;
         :	        bool            all_dead = false;
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:509
   12.50 :	  4a5530:       c6 45 e7 00             movb   $0x0,-0x19(%rbp)
         :	        bool            got_heap_tuple;
         :
         :	        /* We can skip the buffer-switching logic if we're in mid-HOT chain. */
         :	        if (!scan->xs_continue_hot)
    0.00 :	  4a5534:       80 7f 6d 00             cmpb   $0x0,0x6d(%rdi)
    0.00 :	  4a5538:       0f 84 9a 00 00 00       je     4a55d8 <index_fetch_heap+0xb8>
         :	                if (prev_buf != scan->xs_cbuf)
         :	                        heap_page_prune_opt(scan->heapRelation, scan->xs_cbuf);
         :	        }
         :
         :	        /* Obtain share-lock on the buffer so we can examine visibility */
         :	        LockBuffer(scan->xs_cbuf, BUFFER_LOCK_SHARE);
    0.00 :	  4a553e:       41 8b 7c 24 68          mov    0x68(%r12),%edi
    0.00 :	  4a5543:       be 01 00 00 00          mov    $0x1,%esi
         :	        got_heap_tuple = heap_hot_search_buffer(tid, scan->heapRelation,
    0.00 :	  4a5548:       4d 8d 6c 24 50          lea    0x50(%r12),%r13
         :	                if (prev_buf != scan->xs_cbuf)
         :	                        heap_page_prune_opt(scan->heapRelation, scan->xs_cbuf);
         :	        }
         :
         :	        /* Obtain share-lock on the buffer so we can examine visibility */
         :	        LockBuffer(scan->xs_cbuf, BUFFER_LOCK_SHARE);
    0.00 :	  4a554d:       e8 be f1 1c 00          callq  674710 <LockBuffer>
         :	        got_heap_tuple = heap_hot_search_buffer(tid, scan->heapRelation,
    0.00 :	  4a5552:       31 c0                   xor    %eax,%eax
    0.00 :	  4a5554:       41 80 7c 24 6d 00       cmpb   $0x0,0x6d(%r12)
    0.00 :	  4a555a:       49 8b 4c 24 10          mov    0x10(%r12),%rcx
    0.00 :	  4a555f:       41 8b 54 24 68          mov    0x68(%r12),%edx
    0.00 :	  4a5564:       49 8b 34 24             mov    (%r12),%rsi
    0.00 :	  4a5568:       49 8d 7c 24 54          lea    0x54(%r12),%rdi
    0.00 :	  4a556d:       4c 8d 4d e7             lea    -0x19(%rbp),%r9
    0.00 :	  4a5571:       4d 89 e8                mov    %r13,%r8
    0.00 :	  4a5574:       0f 94 c0                sete   %al
    0.00 :	  4a5577:       89 04 24                mov    %eax,(%rsp)
    0.00 :	  4a557a:       e8 a1 7c ff ff          callq  49d220 <heap_hot_search_buffer>
         :	                                                                                        scan->xs_cbuf,
         :	                                                                                        scan->xs_snapshot,
         :	                                                                                        &scan->xs_ctup,
         :	                                                                                        &all_dead,
         :	                                                                                        !scan->xs_continue_hot);
         :	        LockBuffer(scan->xs_cbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4a557f:       41 8b 7c 24 68          mov    0x68(%r12),%edi
         :	                        heap_page_prune_opt(scan->heapRelation, scan->xs_cbuf);
         :	        }
         :
         :	        /* Obtain share-lock on the buffer so we can examine visibility */
         :	        LockBuffer(scan->xs_cbuf, BUFFER_LOCK_SHARE);
         :	        got_heap_tuple = heap_hot_search_buffer(tid, scan->heapRelation,
    0.00 :	  4a5584:       89 c3                   mov    %eax,%ebx
         :	                                                                                        scan->xs_cbuf,
         :	                                                                                        scan->xs_snapshot,
         :	                                                                                        &scan->xs_ctup,
         :	                                                                                        &all_dead,
         :	                                                                                        !scan->xs_continue_hot);
         :	        LockBuffer(scan->xs_cbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4a5586:       31 f6                   xor    %esi,%esi
    0.00 :	  4a5588:       e8 83 f1 1c 00          callq  674710 <LockBuffer>
         :
         :	        if (got_heap_tuple)
    0.00 :	  4a558d:       84 db                   test   %bl,%bl
    0.00 :	  4a558f:       74 7f                   je     4a5610 <index_fetch_heap+0xf0>
         :	        {
         :	                /*
         :	                 * Only in a non-MVCC snapshot can more than one member of the HOT
         :	                 * chain be visible.
         :	                 */
         :	                scan->xs_continue_hot = !IsMVCCSnapshot(scan->xs_snapshot);
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:545
   12.50 :	  4a5591:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  4a5596:       31 d2                   xor    %edx,%edx
    0.00 :	  4a5598:       48 8b 00                mov    (%rax),%rax
    0.00 :	  4a559b:       48 3d 50 57 7a 00       cmp    $0x7a5750,%rax
    0.00 :	  4a55a1:       74 09                   je     4a55ac <index_fetch_heap+0x8c>
    0.00 :	  4a55a3:       48 3d 60 47 7a 00       cmp    $0x7a4760,%rax
    0.00 :	  4a55a9:       0f 95 c2                setne  %dl
         :	                pgstat_count_heap_fetch(scan->indexRelation);
    0.00 :	  4a55ac:       49 8b 44 24 08          mov    0x8(%r12),%rax
         :	        {
         :	                /*
         :	                 * Only in a non-MVCC snapshot can more than one member of the HOT
         :	                 * chain be visible.
         :	                 */
         :	                scan->xs_continue_hot = !IsMVCCSnapshot(scan->xs_snapshot);
    0.00 :	  4a55b1:       41 88 54 24 6d          mov    %dl,0x6d(%r12)
         :	                pgstat_count_heap_fetch(scan->indexRelation);
    0.00 :	  4a55b6:       48 8b 80 38 01 00 00    mov    0x138(%rax),%rax
    0.00 :	  4a55bd:       48 85 c0                test   %rax,%rax
    0.00 :	  4a55c0:       74 05                   je     4a55c7 <index_fetch_heap+0xa7>
    0.00 :	  4a55c2:       48 83 40 20 01          addq   $0x1,0x20(%rax)
         :	         */
         :	        if (!scan->xactStartedInRecovery)
         :	                scan->kill_prior_tuple = all_dead;
         :
         :	        return NULL;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:564
   12.50 :	  4a55c7:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  4a55cb:       4c 89 e8                mov    %r13,%rax
    0.00 :	  4a55ce:       5b                      pop    %rbx
    0.00 :	  4a55cf:       41 5c                   pop    %r12
    0.00 :	  4a55d1:       41 5d                   pop    %r13
    0.00 :	  4a55d3:       c9                      leaveq 
   12.50 :	  4a55d4:       c3                      retq   
    0.00 :	  4a55d5:       0f 1f 00                nopl   (%rax)
         :	        if (!scan->xs_continue_hot)
         :	        {
         :	                /* Switch to correct buffer if we don't have it already */
         :	                Buffer          prev_buf = scan->xs_cbuf;
         :
         :	                scan->xs_cbuf = ReleaseAndReadBuffer(scan->xs_cbuf,
    0.00 :	  4a55d8:       0f b7 57 54             movzwl 0x54(%rdi),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:518
   12.50 :	  4a55dc:       0f b7 47 56             movzwl 0x56(%rdi),%eax
         :
         :	        /* We can skip the buffer-switching logic if we're in mid-HOT chain. */
         :	        if (!scan->xs_continue_hot)
         :	        {
         :	                /* Switch to correct buffer if we don't have it already */
         :	                Buffer          prev_buf = scan->xs_cbuf;
    0.00 :	  4a55e0:       8b 5f 68                mov    0x68(%rdi),%ebx
         :
         :	                scan->xs_cbuf = ReleaseAndReadBuffer(scan->xs_cbuf,
    0.00 :	  4a55e3:       48 8b 37                mov    (%rdi),%rsi
    0.00 :	  4a55e6:       c1 e2 10                shl    $0x10,%edx
    0.00 :	  4a55e9:       89 df                   mov    %ebx,%edi
    0.00 :	  4a55eb:       09 c2                   or     %eax,%edx
    0.00 :	  4a55ed:       e8 ce 10 1d 00          callq  6766c0 <ReleaseAndReadBuffer>
         :	                                                                                         ItemPointerGetBlockNumber(tid));
         :
         :	                /*
         :	                 * Prune page, but only if we weren't already on this page
         :	                 */
         :	                if (prev_buf != scan->xs_cbuf)
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:525
   12.50 :	  4a55f2:       39 c3                   cmp    %eax,%ebx
         :	        if (!scan->xs_continue_hot)
         :	        {
         :	                /* Switch to correct buffer if we don't have it already */
         :	                Buffer          prev_buf = scan->xs_cbuf;
         :
         :	                scan->xs_cbuf = ReleaseAndReadBuffer(scan->xs_cbuf,
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:518
   12.50 :	  4a55f4:       41 89 44 24 68          mov    %eax,0x68(%r12)
         :	                                                                                         ItemPointerGetBlockNumber(tid));
         :
         :	                /*
         :	                 * Prune page, but only if we weren't already on this page
         :	                 */
         :	                if (prev_buf != scan->xs_cbuf)
    0.00 :	  4a55f9:       0f 84 3f ff ff ff       je     4a553e <index_fetch_heap+0x1e>
         :	                        heap_page_prune_opt(scan->heapRelation, scan->xs_cbuf);
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:526
   12.50 :	  4a55ff:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  4a5603:       89 c6                   mov    %eax,%esi
    0.00 :	  4a5605:       e8 46 a0 ff ff          callq  49f650 <heap_page_prune_opt>
    0.00 :	  4a560a:       e9 2f ff ff ff          jmpq   4a553e <index_fetch_heap+0x1e>
    0.00 :	  4a560f:       90                      nop
         :	         * AM to kill its entry for that TID (this will take effect in the next
         :	         * amgettuple call, in index_getnext_tid).  We do not do this when in
         :	         * recovery because it may violate MVCC to do so.  See comments in
         :	         * RelationGetIndexScan().
         :	         */
         :	        if (!scan->xactStartedInRecovery)
    0.00 :	  4a5610:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4a5613:       41 80 7c 24 33 00       cmpb   $0x0,0x33(%r12)
         :	                pgstat_count_heap_fetch(scan->indexRelation);
         :	                return &scan->xs_ctup;
         :	        }
         :
         :	        /* We've reached the end of the HOT chain. */
         :	        scan->xs_continue_hot = false;
    0.00 :	  4a5619:       41 c6 44 24 6d 00       movb   $0x0,0x6d(%r12)
         :	         * AM to kill its entry for that TID (this will take effect in the next
         :	         * amgettuple call, in index_getnext_tid).  We do not do this when in
         :	         * recovery because it may violate MVCC to do so.  See comments in
         :	         * RelationGetIndexScan().
         :	         */
         :	        if (!scan->xactStartedInRecovery)
    0.00 :	  4a561f:       75 a6                   jne    4a55c7 <index_fetch_heap+0xa7>
         :	                scan->kill_prior_tuple = all_dead;
    0.00 :	  4a5621:       0f b6 45 e7             movzbl -0x19(%rbp),%eax
    0.00 :	  4a5625:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  4a5628:       41 88 44 24 31          mov    %al,0x31(%r12)
    0.00 :	  4a562d:       eb 98                   jmp    4a55c7 <index_fetch_heap+0xa7>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   62.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:503
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:494
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:495
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:514
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a8ad0 <_bt_checkpage>:
         :	/*
         :	 *      _bt_checkpage() -- Verify that a freshly-read page looks sane.
         :	 */
         :	void
         :	_bt_checkpage(Relation rel, Buffer buf)
         :	{
    0.00 :	  4a8ad0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:494
   12.50 :	  4a8ad1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a8ad4:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  4a8ad8:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  4a8adc:       89 f3                   mov    %esi,%ebx
    0.00 :	  4a8ade:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  4a8ae2:       48 83 ec 20             sub    $0x20,%rsp
         :	        Page            page = BufferGetPage(buf);
    0.00 :	  4a8ae6:       85 f6                   test   %esi,%esi
         :	/*
         :	 *      _bt_checkpage() -- Verify that a freshly-read page looks sane.
         :	 */
         :	void
         :	_bt_checkpage(Relation rel, Buffer buf)
         :	{
    0.00 :	  4a8ae8:       49 89 fd                mov    %rdi,%r13
         :	        Page            page = BufferGetPage(buf);
    0.00 :	  4a8aeb:       78 3b                   js     4a8b28 <_bt_checkpage+0x58>
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:495
   12.50 :	  4a8aed:       8d 43 ff                lea    -0x1(%rbx),%eax
    0.00 :	  4a8af0:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4a8af3:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4a8af7:       48 03 15 fa 6f 71 00    add    0x716ffa(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	         * ReadBuffer verifies that every newly-read page passes
         :	         * PageHeaderIsValid, which means it either contains a reasonably sane
         :	         * page header or is all-zero.  We have to defend against the all-zero
         :	         * case, however.
         :	         */
         :	        if (PageIsNew(page))
    0.00 :	  4a8afe:       66 83 7a 0e 00          cmpw   $0x0,0xe(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:503
   62.50 :	  4a8b03:       74 36                   je     4a8b3b <_bt_checkpage+0x6b>
         :	                                 errhint("Please REINDEX it.")));
         :
         :	        /*
         :	         * Additionally check that the special area looks sane.
         :	         */
         :	        if (PageGetSpecialSize(page) != MAXALIGN(sizeof(BTPageOpaqueData)))
    0.00 :	  4a8b05:       0f b7 42 12             movzwl 0x12(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:514
   12.50 :	  4a8b09:       30 c0                   xor    %al,%al
    0.00 :	  4a8b0b:       66 2b 42 10             sub    0x10(%rdx),%ax
    0.00 :	  4a8b0f:       66 83 f8 10             cmp    $0x10,%ax
    0.00 :	  4a8b13:       75 4b                   jne    4a8b60 <_bt_checkpage+0x90>
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" contains corrupted page at block %u",
         :	                                                RelationGetRelationName(rel),
         :	                                                BufferGetBlockNumber(buf)),
         :	                                 errhint("Please REINDEX it.")));
         :	}
    0.00 :	  4a8b15:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  4a8b19:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  4a8b1d:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  4a8b21:       c9                      leaveq 
    0.00 :	  4a8b22:       c3                      retq   
    0.00 :	  4a8b23:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	 *      _bt_checkpage() -- Verify that a freshly-read page looks sane.
         :	 */
         :	void
         :	_bt_checkpage(Relation rel, Buffer buf)
         :	{
         :	        Page            page = BufferGetPage(buf);
    0.00 :	  4a8b28:       89 f0                   mov    %esi,%eax
    0.00 :	  4a8b2a:       48 8b 15 e7 45 6d 00    mov    0x6d45e7(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4a8b31:       f7 d0                   not    %eax
    0.00 :	  4a8b33:       48 98                   cltq   
    0.00 :	  4a8b35:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4a8b39:       eb c3                   jmp    4a8afe <_bt_checkpage+0x2e>
         :	         * PageHeaderIsValid, which means it either contains a reasonably sane
         :	         * page header or is all-zero.  We have to defend against the all-zero
         :	         * case, however.
         :	         */
         :	        if (PageIsNew(page))
         :	                ereport(ERROR,
    0.00 :	  4a8b3b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4a8b3e:       b9 04 47 7b 00          mov    $0x7b4704,%ecx
    0.00 :	  4a8b43:       ba fd 01 00 00          mov    $0x1fd,%edx
    0.00 :	  4a8b48:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4a8b4d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4a8b52:       e8 69 1f 2d 00          callq  77aac0 <errstart>
    0.00 :	  4a8b57:       84 c0                   test   %al,%al
    0.00 :	  4a8b59:       75 69                   jne    4a8bc4 <_bt_checkpage+0xf4>
         :
         :	        /*
         :	         * Additionally check that the special area looks sane.
         :	         */
         :	        if (PageGetSpecialSize(page) != MAXALIGN(sizeof(BTPageOpaqueData)))
         :	                ereport(ERROR,
    0.00 :	  4a8b5b:       e8 70 09 fc ff          callq  4694d0 <abort@plt>
    0.00 :	  4a8b60:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4a8b63:       b9 04 47 7b 00          mov    $0x7b4704,%ecx
    0.00 :	  4a8b68:       ba 08 02 00 00          mov    $0x208,%edx
    0.00 :	  4a8b6d:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4a8b72:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4a8b77:       e8 44 1f 2d 00          callq  77aac0 <errstart>
    0.00 :	  4a8b7c:       84 c0                   test   %al,%al
    0.00 :	  4a8b7e:       74 db                   je     4a8b5b <_bt_checkpage+0x8b>
    0.00 :	  4a8b80:       bf 12 15 7b 00          mov    $0x7b1512,%edi
    0.00 :	  4a8b85:       31 c0                   xor    %eax,%eax
    0.00 :	  4a8b87:       e8 14 31 2d 00          callq  77bca0 <errhint>
    0.00 :	  4a8b8c:       89 df                   mov    %ebx,%edi
    0.00 :	  4a8b8e:       41 89 c4                mov    %eax,%r12d
    0.00 :	  4a8b91:       e8 9a b4 1c 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  4a8b96:       49 8b 75 30             mov    0x30(%r13),%rsi
    0.00 :	  4a8b9a:       89 c2                   mov    %eax,%edx
    0.00 :	  4a8b9c:       bf 38 17 7b 00          mov    $0x7b1738,%edi
    0.00 :	  4a8ba1:       31 c0                   xor    %eax,%eax
    0.00 :	  4a8ba3:       e8 f8 3c 2d 00          callq  77c8a0 <errmsg>
    0.00 :	  4a8ba8:       bf 28 0a 00 02          mov    $0x2000a28,%edi
    0.00 :	  4a8bad:       89 c3                   mov    %eax,%ebx
    0.00 :	  4a8baf:       e8 9c 41 2d 00          callq  77cd50 <errcode>
    0.00 :	  4a8bb4:       44 89 e2                mov    %r12d,%edx
    0.00 :	  4a8bb7:       89 c7                   mov    %eax,%edi
    0.00 :	  4a8bb9:       89 de                   mov    %ebx,%esi
    0.00 :	  4a8bbb:       31 c0                   xor    %eax,%eax
    0.00 :	  4a8bbd:       e8 1e 1a 2d 00          callq  77a5e0 <errfinish>
    0.00 :	  4a8bc2:       eb 97                   jmp    4a8b5b <_bt_checkpage+0x8b>
         :	         * PageHeaderIsValid, which means it either contains a reasonably sane
         :	         * page header or is all-zero.  We have to defend against the all-zero
         :	         * case, however.
         :	         */
         :	        if (PageIsNew(page))
         :	                ereport(ERROR,
    0.00 :	  4a8bc4:       bf 12 15 7b 00          mov    $0x7b1512,%edi
    0.00 :	  4a8bc9:       31 c0                   xor    %eax,%eax
    0.00 :	  4a8bcb:       e8 d0 30 2d 00          callq  77bca0 <errhint>
    0.00 :	  4a8bd0:       89 df                   mov    %ebx,%edi
    0.00 :	  4a8bd2:       41 89 c4                mov    %eax,%r12d
    0.00 :	  4a8bd5:       e8 56 b4 1c 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  4a8bda:       49 8b 75 30             mov    0x30(%r13),%rsi
    0.00 :	  4a8bde:       89 c2                   mov    %eax,%edx
    0.00 :	  4a8be0:       bf 00 17 7b 00          mov    $0x7b1700,%edi
    0.00 :	  4a8be5:       eb ba                   jmp    4a8ba1 <_bt_checkpage+0xd1>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:255
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:324
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:255
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:255
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:262
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:324
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004abe70 <btgettuple>:
         :	/*
         :	 *      btgettuple() -- Get the next tuple in the scan.
         :	 */
         :	Datum
         :	btgettuple(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:255
   12.50 :	  4abe70:       55                      push   %rbp
   12.50 :	  4abe71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4abe74:       41 55                   push   %r13
   25.00 :	  4abe76:       41 54                   push   %r12
    0.00 :	  4abe78:       53                      push   %rbx
    0.00 :	  4abe79:       48 83 ec 08             sub    $0x8,%rsp
         :	        IndexScanDesc scan = (IndexScanDesc) PG_GETARG_POINTER(0);
    0.00 :	  4abe7d:       4c 8b 67 20             mov    0x20(%rdi),%r12
         :	        ScanDirection dir = (ScanDirection) PG_GETARG_INT32(1);
    0.00 :	  4abe81:       48 8b 4f 28             mov    0x28(%rdi),%rcx
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4abe85:       49 8b 5c 24 38          mov    0x38(%r12),%rbx
         :	        bool            res;
         :
         :	        /* btree indexes are never lossy */
         :	        scan->xs_recheck = false;
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:262
   12.50 :	  4abe8a:       41 c6 44 24 6c 00       movb   $0x0,0x6c(%r12)
         :	 */
         :	Datum
         :	btgettuple(PG_FUNCTION_ARGS)
         :	{
         :	        IndexScanDesc scan = (IndexScanDesc) PG_GETARG_POINTER(0);
         :	        ScanDirection dir = (ScanDirection) PG_GETARG_INT32(1);
    0.00 :	  4abe90:       41 89 cd                mov    %ecx,%r13d
         :	        /*
         :	         * If we have any array keys, initialize them during first call for a
         :	         * scan.  We can't do this in btrescan because we don't know the scan
         :	         * direction at that time.
         :	         */
         :	        if (so->numArrayKeys && !BTScanPosIsValid(so->currPos))
    0.00 :	  4abe93:       8b 53 18                mov    0x18(%rbx),%edx
    0.00 :	  4abe96:       85 d2                   test   %edx,%edx
    0.00 :	  4abe98:       74 7b                   je     4abf15 <btgettuple+0xa5>
    0.00 :	  4abe9a:       8b 43 54                mov    0x54(%rbx),%eax
    0.00 :	  4abe9d:       85 c0                   test   %eax,%eax
    0.00 :	  4abe9f:       75 74                   jne    4abf15 <btgettuple+0xa5>
         :	        {
         :	                /* punt if we have any unsatisfiable array keys */
         :	                if (so->numArrayKeys < 0)
    0.00 :	  4abea1:       31 c0                   xor    %eax,%eax
    0.00 :	  4abea3:       85 d2                   test   %edx,%edx
    0.00 :	  4abea5:       0f 88 97 00 00 00       js     4abf42 <btgettuple+0xd2>
         :	                        PG_RETURN_BOOL(false);
         :
         :	                _bt_start_array_keys(scan, dir);
    0.00 :	  4abeab:       89 ce                   mov    %ecx,%esi
    0.00 :	  4abead:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4abeb0:       e8 3b 1d 00 00          callq  4adbf0 <_bt_start_array_keys>
         :	                /*
         :	                 * If we've already initialized this scan, we can just advance it in
         :	                 * the appropriate direction.  If we haven't done so yet, we call
         :	                 * _bt_first() to get the first item in the scan.
         :	                 */
         :	                if (!BTScanPosIsValid(so->currPos))
    0.00 :	  4abeb5:       8b 43 54                mov    0x54(%rbx),%eax
    0.00 :	  4abeb8:       85 c0                   test   %eax,%eax
    0.00 :	  4abeba:       74 60                   je     4abf1c <btgettuple+0xac>
    0.00 :	  4abebc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                else
         :	                {
         :	                        /*
         :	                         * Check to see if we should kill the previously-fetched tuple.
         :	                         */
         :	                        if (scan->kill_prior_tuple)
    0.00 :	  4abec0:       41 80 7c 24 31 00       cmpb   $0x0,0x31(%r12)
    0.00 :	  4abec6:       74 28                   je     4abef0 <btgettuple+0x80>
         :	                                 * caller reverses direction in the indexscan then the same
         :	                                 * item might get entered multiple times. It's not worth
         :	                                 * trying to optimize that, so we don't detect it, but instead
         :	                                 * just forget any excess entries.
         :	                                 */
         :	                                if (so->killedItems == NULL)
    0.00 :	  4abec8:       48 83 7b 30 00          cmpq   $0x0,0x30(%rbx)
    0.00 :	  4abecd:       0f 1f 00                nopl   (%rax)
    0.00 :	  4abed0:       74 7e                   je     4abf50 <btgettuple+0xe0>
         :	                                        so->killedItems = (int *)
         :	                                                palloc(MaxIndexTuplesPerPage * sizeof(int));
         :	                                if (so->numKilled < MaxIndexTuplesPerPage)
    0.00 :	  4abed2:       8b 73 38                mov    0x38(%rbx),%esi
    0.00 :	  4abed5:       81 fe 97 01 00 00       cmp    $0x197,%esi
    0.00 :	  4abedb:       7f 13                   jg     4abef0 <btgettuple+0x80>
         :	                                        so->killedItems[so->numKilled++] = so->currPos.itemIndex;
    0.00 :	  4abedd:       8b 43 6c                mov    0x6c(%rbx),%eax
    0.00 :	  4abee0:       48 8b 53 30             mov    0x30(%rbx),%rdx
    0.00 :	  4abee4:       48 63 ce                movslq %esi,%rcx
    0.00 :	  4abee7:       89 04 8a                mov    %eax,(%rdx,%rcx,4)
    0.00 :	  4abeea:       8d 46 01                lea    0x1(%rsi),%eax
    0.00 :	  4abeed:       89 43 38                mov    %eax,0x38(%rbx)
         :	                        }
         :
         :	                        /*
         :	                         * Now continue the scan.
         :	                         */
         :	                        res = _bt_next(scan, dir);
    0.00 :	  4abef0:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4abef3:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4abef6:       e8 75 0c 00 00          callq  4acb70 <_bt_next>
         :	                }
         :
         :	                /* If we have a tuple, return it ... */
         :	                if (res)
    0.00 :	  4abefb:       84 c0                   test   %al,%al
    0.00 :	  4abefd:       75 2c                   jne    4abf2b <btgettuple+0xbb>
         :	                        break;
         :	                /* ... otherwise see if we have more array keys to deal with */
         :	        } while (so->numArrayKeys && _bt_advance_array_keys(scan, dir));
    0.00 :	  4abeff:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  4abf02:       85 c0                   test   %eax,%eax
    0.00 :	  4abf04:       74 3a                   je     4abf40 <btgettuple+0xd0>
    0.00 :	  4abf06:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4abf09:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4abf0c:       e8 5f 1d 00 00          callq  4adc70 <_bt_advance_array_keys>
    0.00 :	  4abf11:       84 c0                   test   %al,%al
    0.00 :	  4abf13:       74 2b                   je     4abf40 <btgettuple+0xd0>
         :	                /*
         :	                 * If we've already initialized this scan, we can just advance it in
         :	                 * the appropriate direction.  If we haven't done so yet, we call
         :	                 * _bt_first() to get the first item in the scan.
         :	                 */
         :	                if (!BTScanPosIsValid(so->currPos))
    0.00 :	  4abf15:       8b 43 54                mov    0x54(%rbx),%eax
    0.00 :	  4abf18:       85 c0                   test   %eax,%eax
    0.00 :	  4abf1a:       75 a4                   jne    4abec0 <btgettuple+0x50>
         :	                        res = _bt_first(scan, dir);
    0.00 :	  4abf1c:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4abf1f:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4abf22:       e8 69 13 00 00          callq  4ad290 <_bt_first>
         :	                         */
         :	                        res = _bt_next(scan, dir);
         :	                }
         :
         :	                /* If we have a tuple, return it ... */
         :	                if (res)
    0.00 :	  4abf27:       84 c0                   test   %al,%al
    0.00 :	  4abf29:       74 d4                   je     4abeff <btgettuple+0x8f>
         :	                        break;
         :	                /* ... otherwise see if we have more array keys to deal with */
         :	        } while (so->numArrayKeys && _bt_advance_array_keys(scan, dir));
         :
         :	        PG_RETURN_BOOL(res);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtree.c:324
   25.00 :	  4abf2b:       48 83 c4 08             add    $0x8,%rsp
         :	                        res = _bt_next(scan, dir);
         :	                }
         :
         :	                /* If we have a tuple, return it ... */
         :	                if (res)
         :	                        break;
    0.00 :	  4abf2f:       b8 01 00 00 00          mov    $0x1,%eax
         :	                /* ... otherwise see if we have more array keys to deal with */
         :	        } while (so->numArrayKeys && _bt_advance_array_keys(scan, dir));
         :
         :	        PG_RETURN_BOOL(res);
         :	}
    0.00 :	  4abf34:       5b                      pop    %rbx
    0.00 :	  4abf35:       41 5c                   pop    %r12
    0.00 :	  4abf37:       41 5d                   pop    %r13
    0.00 :	  4abf39:       c9                      leaveq 
    0.00 :	  4abf3a:       c3                      retq   
    0.00 :	  4abf3b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	                /* If we have a tuple, return it ... */
         :	                if (res)
         :	                        break;
         :	                /* ... otherwise see if we have more array keys to deal with */
         :	        } while (so->numArrayKeys && _bt_advance_array_keys(scan, dir));
    0.00 :	  4abf40:       31 c0                   xor    %eax,%eax
         :
         :	        PG_RETURN_BOOL(res);
         :	}
    0.00 :	  4abf42:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  4abf46:       5b                      pop    %rbx
    0.00 :	  4abf47:       41 5c                   pop    %r12
    0.00 :	  4abf49:       41 5d                   pop    %r13
   12.50 :	  4abf4b:       c9                      leaveq 
    0.00 :	  4abf4c:       c3                      retq   
    0.00 :	  4abf4d:       0f 1f 00                nopl   (%rax)
         :	                                 * item might get entered multiple times. It's not worth
         :	                                 * trying to optimize that, so we don't detect it, but instead
         :	                                 * just forget any excess entries.
         :	                                 */
         :	                                if (so->killedItems == NULL)
         :	                                        so->killedItems = (int *)
    0.00 :	  4abf50:       bf 60 06 00 00          mov    $0x660,%edi
    0.00 :	  4abf55:       e8 f6 cd 2e 00          callq  798d50 <palloc>
    0.00 :	  4abf5a:       48 89 43 30             mov    %rax,0x30(%rbx)
    0.00 :	  4abf5e:       e9 6f ff ff ff          jmpq   4abed2 <btgettuple+0x62>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   37.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5169
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5161
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5130
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5167
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5190
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005acf10 <ExecQual>:
         :	 *
         :	 * ----------------------------------------------------------------
         :	 */
         :	bool
         :	ExecQual(List *qual, ExprContext *econtext, bool resultForNull)
         :	{
    0.00 :	  5acf10:       55                      push   %rbp
    0.00 :	  5acf11:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5acf14:       41 57                   push   %r15
    0.00 :	  5acf16:       41 56                   push   %r14
    0.00 :	  5acf18:       41 89 d6                mov    %edx,%r14d
    0.00 :	  5acf1b:       41 55                   push   %r13
    0.00 :	  5acf1d:       41 54                   push   %r12
    0.00 :	  5acf1f:       49 89 f4                mov    %rsi,%r12
    0.00 :	  5acf22:       53                      push   %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5130
   12.50 :	  5acf23:       48 83 ec 18             sub    $0x18,%rsp
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf27:       48 8b 46 28             mov    0x28(%rsi),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5acf2b:       48 85 ff                test   %rdi,%rdi
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5acf2e:       4c 8b 3d 2b d9 60 00    mov    0x60d92b(%rip),%r15        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5acf35:       48 89 05 24 d9 60 00    mov    %rax,0x60d924(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5acf3c:       74 4a                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf3e:       48 8b 5f 08             mov    0x8(%rdi),%rbx
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5161
   25.00 :	  5acf42:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf45:       74 41                   je     5acf88 <ExecQual+0x78>
    0.00 :	  5acf47:       4c 8d 6d d7             lea    -0x29(%rbp),%r13
    0.00 :	  5acf4b:       eb 11                   jmp    5acf5e <ExecQual+0x4e>
    0.00 :	  5acf4d:       0f 1f 00                nopl   (%rax)
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
         :
         :	                if (isNull)
         :	                {
         :	                        if (resultForNull == false)
    0.00 :	  5acf50:       45 84 f6                test   %r14b,%r14b
    0.00 :	  5acf53:       74 24                   je     5acf79 <ExecQual+0x69>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf55:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5acf59:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acf5c:       74 2a                   je     5acf88 <ExecQual+0x78>
         :	        {
         :	                ExprState  *clause = (ExprState *) lfirst(l);
    0.00 :	  5acf5e:       48 8b 03                mov    (%rbx),%rax
         :	                Datum           expr_value;
         :	                bool            isNull;
         :
         :	                expr_value = ExecEvalExpr(clause, econtext, &isNull, NULL);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5167
   12.50 :	  5acf61:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5acf63:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  5acf66:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5acf69:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5acf6c:       ff 50 10                callq  *0x10(%rax)
         :
         :	                if (isNull)
    0.00 :	  5acf6f:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5169
   37.50 :	  5acf73:       75 db                   jne    5acf50 <ExecQual+0x40>
         :	                                break;
         :	                        }
         :	                }
         :	                else
         :	                {
         :	                        if (!DatumGetBool(expr_value))
    0.00 :	  5acf75:       84 c0                   test   %al,%al
    0.00 :	  5acf77:       75 dc                   jne    5acf55 <ExecQual+0x45>
         :	         * or more NULL subresult, with all the rest TRUE) and the caller has
         :	         * specified resultForNull = TRUE.
         :	         */
         :	        result = true;
         :
         :	        foreach(l, qual)
    0.00 :	  5acf79:       31 c0                   xor    %eax,%eax
    0.00 :	  5acf7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  5acf80:       eb 0b                   jmp    5acf8d <ExecQual+0x7d>
    0.00 :	  5acf82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5acf88:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5acf8d:       4c 89 3d cc d8 60 00    mov    %r15,0x60d8cc(%rip)        # bba860 <CurrentMemoryContext>
         :	        }
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return result;
         :	}
    0.00 :	  5acf94:       48 83 c4 18             add    $0x18,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:5190
   12.50 :	  5acf98:       5b                      pop    %rbx
    0.00 :	  5acf99:       41 5c                   pop    %r12
    0.00 :	  5acf9b:       41 5d                   pop    %r13
    0.00 :	  5acf9d:       41 5e                   pop    %r14
    0.00 :	  5acf9f:       41 5f                   pop    %r15
    0.00 :	  5acfa1:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:740
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:337
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:736
   12.50 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:337
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798110 <AllocSetAlloc>:
         :	 *              MAXALIGN_DOWN(SIZE_MAX) - ALLOC_BLOCKHDRSZ - ALLOC_CHUNKHDRSZ
         :	 * All callers use a much-lower limit.
         :	 */
         :	static void *
         :	AllocSetAlloc(MemoryContext context, Size size)
         :	{
    0.00 :	  798110:       55                      push   %rbp
    0.00 :	  798111:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  798114:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  798118:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  79811c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  79811f:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  798123:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  798127:       49 89 f6                mov    %rsi,%r14
    0.00 :	  79812a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  79812e:       48 83 ec 30             sub    $0x30,%rsp
         :
         :	        /*
         :	         * If requested size exceeds maximum for chunks, allocate an entire block
         :	         * for this request.
         :	         */
         :	        if (size > set->allocChunkLimit)
    0.00 :	  798132:       48 39 b7 b0 00 00 00    cmp    %rsi,0xb0(%rdi)
    0.00 :	  798139:       72 6d                   jb     7981a8 <AllocSetAlloc+0x98>
         :	{
         :	        int                     idx;
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
    0.00 :	  79813b:       31 f6                   xor    %esi,%esi
    0.00 :	  79813d:       49 83 fe 08             cmp    $0x8,%r14
    0.00 :	  798141:       77 3d                   ja     798180 <AllocSetAlloc+0x70>
         :	         * corresponding free list to see if there is a free chunk we could reuse.
         :	         * If one is found, remove it from the free list, make it again a member
         :	         * of the alloc set and return its data address.
         :	         */
         :	        fidx = AllocSetFreeIndex(size);
         :	        chunk = set->freelist[fidx];
    0.00 :	  798143:       48 63 c6                movslq %esi,%rax
    0.00 :	  798146:       48 8d 48 08             lea    0x8(%rax),%rcx
    0.00 :	  79814a:       49 8b 14 cc             mov    (%r12,%rcx,8),%rdx
         :	        if (chunk != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:736
   12.50 :	  79814e:       48 85 d2                test   %rdx,%rdx
    0.00 :	  798151:       0f 84 c9 00 00 00       je     798220 <AllocSetAlloc+0x110>
         :	        {
         :	                Assert(chunk->size >= size);
         :
         :	                set->freelist[fidx] = (AllocChunk) chunk->aset;
    0.00 :	  798157:       48 8b 02                mov    (%rdx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:740
   50.00 :	  79815a:       49 89 04 cc             mov    %rax,(%r12,%rcx,8)
         :	                /* fill the allocated space with junk */
         :	                randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	                AllocAllocInfo(set, chunk);
         :	                return AllocChunkGetPointer(chunk);
    0.00 :	  79815e:       48 8d 42 10             lea    0x10(%rdx),%rax
         :	        {
         :	                Assert(chunk->size >= size);
         :
         :	                set->freelist[fidx] = (AllocChunk) chunk->aset;
         :
         :	                chunk->aset = (void *) set;
    0.00 :	  798162:       4c 89 22                mov    %r12,(%rdx)
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  798165:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  798169:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  79816d:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  798171:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  798175:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  798179:       c9                      leaveq 
    0.00 :	  79817a:       c3                      retq   
    0.00 :	  79817b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
         :	        {
         :	                tsize = (size - 1) >> ALLOC_MINBITS;
    0.00 :	  798180:       49 8d 46 ff             lea    -0x1(%r14),%rax
    0.00 :	  798184:       48 89 c2                mov    %rax,%rdx
    0.00 :	  798187:       48 c1 ea 03             shr    $0x3,%rdx
         :	                 * justify micro-optimization effort.  The best approach seems to be
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
    0.00 :	  79818b:       89 d0                   mov    %edx,%eax
    0.00 :	  79818d:       c1 e8 08                shr    $0x8,%eax
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798190:       85 c0                   test   %eax,%eax
    0.00 :	  798192:       74 7c                   je     798210 <AllocSetAlloc+0x100>
    0.00 :	  798194:       89 c0                   mov    %eax,%eax
    0.00 :	  798196:       0f b6 80 80 1e 8e 00    movzbl 0x8e1e80(%rax),%eax
    0.00 :	  79819d:       8d 70 08                lea    0x8(%rax),%esi
    0.00 :	  7981a0:       eb a1                   jmp    798143 <AllocSetAlloc+0x33>
    0.00 :	  7981a2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	         * If requested size exceeds maximum for chunks, allocate an entire block
         :	         * for this request.
         :	         */
         :	        if (size > set->allocChunkLimit)
         :	        {
         :	                chunk_size = MAXALIGN(size);
    0.00 :	  7981a8:       48 8d 5e 07             lea    0x7(%rsi),%rbx
    0.00 :	  7981ac:       48 83 e3 f8             and    $0xfffffffffffffff8,%rbx
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    0.00 :	  7981b0:       4c 8d 6b 30             lea    0x30(%rbx),%r13
         :	                block = (AllocBlock) malloc(blksize);
    0.00 :	  7981b4:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  7981b7:       e8 74 14 cd ff          callq  469630 <malloc@plt>
         :	                if (block == NULL)
    0.00 :	  7981bc:       48 85 c0                test   %rax,%rax
         :	         */
         :	        if (size > set->allocChunkLimit)
         :	        {
         :	                chunk_size = MAXALIGN(size);
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                block = (AllocBlock) malloc(blksize);
    0.00 :	  7981bf:       48 89 c2                mov    %rax,%rdx
         :	                if (block == NULL)
    0.00 :	  7981c2:       0f 84 2e 02 00 00       je     7983f6 <AllocSetAlloc+0x2e6>
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
    0.00 :	  7981c8:       4c 89 20                mov    %r12,(%rax)
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
    0.00 :	  7981cb:       48 8d 72 20             lea    0x20(%rdx),%rsi
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
    0.00 :	  7981cf:       4a 8d 04 28             lea    (%rax,%r13,1),%rax
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
         :	                chunk->aset = set;
    0.00 :	  7981d3:       4c 89 62 20             mov    %r12,0x20(%rdx)
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :	                block->aset = set;
         :	                block->freeptr = block->endptr = ((char *) block) + blksize;
    0.00 :	  7981d7:       48 89 42 18             mov    %rax,0x18(%rdx)
    0.00 :	  7981db:       48 89 42 10             mov    %rax,0x10(%rdx)
         :
         :	                chunk = (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ);
         :	                chunk->aset = set;
         :	                chunk->size = chunk_size;
    0.00 :	  7981df:       48 89 5e 08             mov    %rbx,0x8(%rsi)
         :
         :	                /*
         :	                 * Stick the new block underneath the active allocation block, so that
         :	                 * we don't lose the use of the space remaining therein.
         :	                 */
         :	                if (set->blocks != NULL)
    0.00 :	  7981e3:       49 8b 4c 24 38          mov    0x38(%r12),%rcx
    0.00 :	  7981e8:       48 85 c9                test   %rcx,%rcx
    0.00 :	  7981eb:       0f 84 cf 01 00 00       je     7983c0 <AllocSetAlloc+0x2b0>
         :	                {
         :	                        block->next = set->blocks->next;
    0.00 :	  7981f1:       48 8b 41 08             mov    0x8(%rcx),%rax
    0.00 :	  7981f5:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                        set->blocks->next = block;
    0.00 :	  7981f9:       48 89 51 08             mov    %rdx,0x8(%rcx)
         :	                 * if any, NOACCESS.
         :	                 */
         :	                VALGRIND_MAKE_MEM_NOACCESS((char *) chunk + ALLOC_CHUNK_PUBLIC,
         :	                                                 chunk_size + ALLOC_CHUNKHDRSZ - ALLOC_CHUNK_PUBLIC);
         :
         :	                return AllocChunkGetPointer(chunk);
    0.00 :	  7981fd:       48 8d 46 10             lea    0x10(%rsi),%rax
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  798201:       e9 5f ff ff ff          jmpq   798165 <AllocSetAlloc+0x55>
    0.00 :	  798206:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  79820d:       00 00 00 
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:337
   25.00 :	  798210:       89 d0                   mov    %edx,%eax
    0.00 :	  798212:       0f b6 b0 80 1e 8e 00    movzbl 0x8e1e80(%rax),%esi
   12.50 :	  798219:       e9 25 ff ff ff          jmpq   798143 <AllocSetAlloc+0x33>
    0.00 :	  79821e:       66 90                   xchg   %ax,%ax
         :
         :	        /*
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
    0.00 :	  798220:       4d 8b 4c 24 38          mov    0x38(%r12),%r9
         :	        }
         :
         :	        /*
         :	         * Choose the actual chunk size to allocate.
         :	         */
         :	        chunk_size = (1 << ALLOC_MINBITS) << fidx;
    0.00 :	  798225:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	  79822a:       89 f1                   mov    %esi,%ecx
    0.00 :	  79822c:       d3 e0                   shl    %cl,%eax
    0.00 :	  79822e:       4c 63 f8                movslq %eax,%r15
         :
         :	        /*
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
    0.00 :	  798231:       4d 85 c9                test   %r9,%r9
    0.00 :	  798234:       0f 84 ce 00 00 00       je     798308 <AllocSetAlloc+0x1f8>
         :	        {
         :	                Size            availspace = block->endptr - block->freeptr;
    0.00 :	  79823a:       49 8b 79 10             mov    0x10(%r9),%rdi
    0.00 :	  79823e:       4d 8b 41 18             mov    0x18(%r9),%r8
         :
         :	                if (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))
    0.00 :	  798242:       49 8d 47 10             lea    0x10(%r15),%rax
         :	         * If there is enough room in the active allocation block, we will put the
         :	         * chunk into that block.  Else must start a new one.
         :	         */
         :	        if ((block = set->blocks) != NULL)
         :	        {
         :	                Size            availspace = block->endptr - block->freeptr;
    0.00 :	  798246:       49 29 f8                sub    %rdi,%r8
         :
         :	                if (availspace < (chunk_size + ALLOC_CHUNKHDRSZ))
    0.00 :	  798249:       49 39 c0                cmp    %rax,%r8
    0.00 :	  79824c:       0f 83 52 01 00 00       jae    7983a4 <AllocSetAlloc+0x294>
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  798252:       49 83 f8 17             cmp    $0x17,%r8
    0.00 :	  798256:       0f 86 ac 00 00 00       jbe    798308 <AllocSetAlloc+0x1f8>
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  79825c:       41 ba 01 00 00 00       mov    $0x1,%r10d
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  798262:       49 c7 c3 f0 ff ff ff    mov    $0xfffffffffffffff0,%r11
    0.00 :	  798269:       eb 5d                   jmp    7982c8 <AllocSetAlloc+0x1b8>
    0.00 :	  79826b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798270:       89 c0                   mov    %eax,%eax
    0.00 :	  798272:       0f b6 88 80 1e 8e 00    movzbl 0x8e1e80(%rax),%ecx
    0.00 :	  798279:       4c 89 d0                mov    %r10,%rax
    0.00 :	  79827c:       8d 51 08                lea    0x8(%rcx),%edx
    0.00 :	  79827f:       83 c1 0b                add    $0xb,%ecx
    0.00 :	  798282:       48 d3 e0                shl    %cl,%rax
         :	                                /*
         :	                                 * In most cases, we'll get back the index of the next larger
         :	                                 * freelist than the one we need to put this chunk on.  The
         :	                                 * exception is when availchunk is exactly a power of 2.
         :	                                 */
         :	                                if (availchunk != ((Size) 1 << (a_fidx + ALLOC_MINBITS)))
    0.00 :	  798285:       48 39 c6                cmp    %rax,%rsi
    0.00 :	  798288:       74 0c                   je     798296 <AllocSetAlloc+0x186>
         :	                                {
         :	                                        a_fidx--;
    0.00 :	  79828a:       83 ea 01                sub    $0x1,%edx
         :	                                        Assert(a_fidx >= 0);
         :	                                        availchunk = ((Size) 1 << (a_fidx + ALLOC_MINBITS));
    0.00 :	  79828d:       4c 89 d6                mov    %r10,%rsi
    0.00 :	  798290:       8d 4a 03                lea    0x3(%rdx),%ecx
    0.00 :	  798293:       48 d3 e6                shl    %cl,%rsi
         :	                                chunk = (AllocChunk) (block->freeptr);
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  798296:       48 8d 44 37 10          lea    0x10(%rdi,%rsi,1),%rax
    0.00 :	  79829b:       49 89 41 10             mov    %rax,0x10(%r9)
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  79829f:       4c 89 d8                mov    %r11,%rax
         :
         :	                                chunk->size = availchunk;
    0.00 :	  7982a2:       48 89 77 08             mov    %rsi,0x8(%rdi)
         :
         :	                                /* Prepare to initialize the chunk header. */
         :	                                VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	                                block->freeptr += (availchunk + ALLOC_CHUNKHDRSZ);
         :	                                availspace -= (availchunk + ALLOC_CHUNKHDRSZ);
    0.00 :	  7982a6:       48 29 f0                sub    %rsi,%rax
    0.00 :	  7982a9:       49 01 c0                add    %rax,%r8
         :
         :	                                chunk->size = availchunk;
         :	#ifdef MEMORY_CONTEXT_CHECKING
         :	                                chunk->requested_size = 0;              /* mark it free */
         :	#endif
         :	                                chunk->aset = (void *) set->freelist[a_fidx];
    0.00 :	  7982ac:       48 63 c2                movslq %edx,%rax
    0.00 :	  7982af:       48 83 c0 08             add    $0x8,%rax
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  7982b3:       49 83 f8 17             cmp    $0x17,%r8
         :
         :	                                chunk->size = availchunk;
         :	#ifdef MEMORY_CONTEXT_CHECKING
         :	                                chunk->requested_size = 0;              /* mark it free */
         :	#endif
         :	                                chunk->aset = (void *) set->freelist[a_fidx];
    0.00 :	  7982b7:       49 8b 14 c4             mov    (%r12,%rax,8),%rdx
    0.00 :	  7982bb:       48 89 17                mov    %rdx,(%rdi)
         :	                                set->freelist[a_fidx] = chunk;
    0.00 :	  7982be:       49 89 3c c4             mov    %rdi,(%r12,%rax,8)
         :	                         *
         :	                         * Because we can only get here when there's less than
         :	                         * ALLOC_CHUNK_LIMIT left in the block, this loop cannot iterate
         :	                         * more than ALLOCSET_NUM_FREELISTS-1 times.
         :	                         */
         :	                        while (availspace >= ((1 << ALLOC_MINBITS) + ALLOC_CHUNKHDRSZ))
    0.00 :	  7982c2:       76 44                   jbe    798308 <AllocSetAlloc+0x1f8>
    0.00 :	  7982c4:       49 8b 79 10             mov    0x10(%r9),%rdi
         :	                        {
         :	                                Size            availchunk = availspace - ALLOC_CHUNKHDRSZ;
    0.00 :	  7982c8:       49 8d 70 f0             lea    -0x10(%r8),%rsi
         :	{
         :	        int                     idx;
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
    0.00 :	  7982cc:       31 d2                   xor    %edx,%edx
    0.00 :	  7982ce:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	  7982d3:       48 83 fe 08             cmp    $0x8,%rsi
    0.00 :	  7982d7:       76 ac                   jbe    798285 <AllocSetAlloc+0x175>
         :	        {
         :	                tsize = (size - 1) >> ALLOC_MINBITS;
    0.00 :	  7982d9:       49 8d 40 ef             lea    -0x11(%r8),%rax
    0.00 :	  7982dd:       48 89 c2                mov    %rax,%rdx
    0.00 :	  7982e0:       48 c1 ea 03             shr    $0x3,%rdx
         :	                 * justify micro-optimization effort.  The best approach seems to be
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
    0.00 :	  7982e4:       89 d0                   mov    %edx,%eax
    0.00 :	  7982e6:       c1 e8 08                shr    $0x8,%eax
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  7982e9:       85 c0                   test   %eax,%eax
    0.00 :	  7982eb:       75 83                   jne    798270 <AllocSetAlloc+0x160>
    0.00 :	  7982ed:       89 d0                   mov    %edx,%eax
    0.00 :	  7982ef:       0f b6 90 80 1e 8e 00    movzbl 0x8e1e80(%rax),%edx
    0.00 :	  7982f6:       4c 89 d0                mov    %r10,%rax
    0.00 :	  7982f9:       8d 4a 03                lea    0x3(%rdx),%ecx
    0.00 :	  7982fc:       48 d3 e0                shl    %cl,%rax
    0.00 :	  7982ff:       eb 84                   jmp    798285 <AllocSetAlloc+0x175>
    0.00 :	  798301:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
    0.00 :	  798308:       49 8b 94 24 a8 00 00    mov    0xa8(%r12),%rdx
    0.00 :	  79830f:       00 
         :	                set->nextBlockSize <<= 1;
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  798310:       49 8b 8c 24 a0 00 00    mov    0xa0(%r12),%rcx
    0.00 :	  798317:       00 
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
         :	                set->nextBlockSize <<= 1;
    0.00 :	  798318:       48 8d 04 12             lea    (%rdx,%rdx,1),%rax
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  79831c:       48 39 c8                cmp    %rcx,%rax
         :	                /*
         :	                 * The first such block has size initBlockSize, and we double the
         :	                 * space in each succeeding block, but not more than maxBlockSize.
         :	                 */
         :	                blksize = set->nextBlockSize;
         :	                set->nextBlockSize <<= 1;
    0.00 :	  79831f:       49 89 84 24 a8 00 00    mov    %rax,0xa8(%r12)
    0.00 :	  798326:       00 
         :	                if (set->nextBlockSize > set->maxBlockSize)
    0.00 :	  798327:       76 08                   jbe    798331 <AllocSetAlloc+0x221>
         :	                        set->nextBlockSize = set->maxBlockSize;
    0.00 :	  798329:       49 89 8c 24 a8 00 00    mov    %rcx,0xa8(%r12)
    0.00 :	  798330:       00 
         :
         :	                /*
         :	                 * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more
         :	                 * space... but try to keep it a power of 2.
         :	                 */
         :	                required_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
    0.00 :	  798331:       4d 8d 6f 30             lea    0x30(%r15),%r13
         :	                while (blksize < required_size)
    0.00 :	  798335:       4c 39 ea                cmp    %r13,%rdx
    0.00 :	  798338:       73 0e                   jae    798348 <AllocSetAlloc+0x238>
    0.00 :	  79833a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        blksize <<= 1;
    0.00 :	  798340:       48 01 d2                add    %rdx,%rdx
         :	                /*
         :	                 * If initBlockSize is less than ALLOC_CHUNK_LIMIT, we could need more
         :	                 * space... but try to keep it a power of 2.
         :	                 */
         :	                required_size = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                while (blksize < required_size)
    0.00 :	  798343:       49 39 d5                cmp    %rdx,%r13
    0.00 :	  798346:       77 f8                   ja     798340 <AllocSetAlloc+0x230>
    0.00 :	  798348:       48 89 d3                mov    %rdx,%rbx
    0.00 :	  79834b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                while (block == NULL && blksize > 1024 * 1024)
         :	                {
         :	                        blksize >>= 1;
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
    0.00 :	  798350:       48 89 df                mov    %rbx,%rdi
    0.00 :	  798353:       e8 d8 12 cd ff          callq  469630 <malloc@plt>
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  798358:       48 85 c0                test   %rax,%rax
         :	                {
         :	                        blksize >>= 1;
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
    0.00 :	  79835b:       48 89 c2                mov    %rax,%rdx
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  79835e:       74 78                   je     7983d8 <AllocSetAlloc+0x2c8>
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
    0.00 :	  798360:       48 85 d2                test   %rdx,%rdx
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  798363:       49 89 d1                mov    %rdx,%r9
         :	                        if (blksize < required_size)
         :	                                break;
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
    0.00 :	  798366:       0f 84 10 01 00 00       je     79847c <AllocSetAlloc+0x36c>
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :
         :	                block->aset = set;
         :	                block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    0.00 :	  79836c:       48 8d 42 20             lea    0x20(%rdx),%rax
         :	                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                         errmsg("out of memory"),
         :	                                         errdetail("Failed on request of size %zu.", size)));
         :	                }
         :
         :	                block->aset = set;
    0.00 :	  798370:       4c 89 22                mov    %r12,(%rdx)
         :	                block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;
    0.00 :	  798373:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	                block->endptr = ((char *) block) + blksize;
    0.00 :	  798377:       48 8d 04 1a             lea    (%rdx,%rbx,1),%rax
    0.00 :	  79837b:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	                 * cycling even for contexts created with minContextSize = 0; that way
         :	                 * we don't have to force space to be allocated in contexts that might
         :	                 * never need any space.  Don't mark an oversize block as a keeper,
         :	                 * however.
         :	                 */
         :	                if (set->keeper == NULL && blksize == set->initBlockSize)
    0.00 :	  79837f:       49 83 bc 24 b8 00 00    cmpq   $0x0,0xb8(%r12)
    0.00 :	  798386:       00 00 
    0.00 :	  798388:       0f 84 99 00 00 00       je     798427 <AllocSetAlloc+0x317>
         :
         :	                /* Mark unallocated space NOACCESS. */
         :	                VALGRIND_MAKE_MEM_NOACCESS(block->freeptr,
         :	                                                                   blksize - ALLOC_BLOCKHDRSZ);
         :
         :	                block->next = set->blocks;
    0.00 :	  79838e:       49 8b 44 24 38          mov    0x38(%r12),%rax
    0.00 :	  798393:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                set->blocks = block;
    0.00 :	  798397:       49 89 54 24 38          mov    %rdx,0x38(%r12)
    0.00 :	  79839c:       49 8d 47 10             lea    0x10(%r15),%rax
    0.00 :	  7983a0:       48 8b 7a 10             mov    0x10(%rdx),%rdi
         :	        chunk = (AllocChunk) (block->freeptr);
         :
         :	        /* Prepare to initialize the chunk header. */
         :	        VALGRIND_MAKE_MEM_UNDEFINED(chunk, ALLOC_CHUNK_USED);
         :
         :	        block->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);
    0.00 :	  7983a4:       48 8d 04 07             lea    (%rdi,%rax,1),%rax
    0.00 :	  7983a8:       49 89 41 10             mov    %rax,0x10(%r9)
         :	        Assert(block->freeptr <= block->endptr);
         :
         :	        chunk->aset = (void *) set;
    0.00 :	  7983ac:       4c 89 27                mov    %r12,(%rdi)
         :	        /* fill the allocated space with junk */
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
    0.00 :	  7983af:       48 8d 47 10             lea    0x10(%rdi),%rax
         :
         :	        block->freeptr += (chunk_size + ALLOC_CHUNKHDRSZ);
         :	        Assert(block->freeptr <= block->endptr);
         :
         :	        chunk->aset = (void *) set;
         :	        chunk->size = chunk_size;
    0.00 :	  7983b3:       4c 89 7f 08             mov    %r15,0x8(%rdi)
         :	        randomize_mem((char *) AllocChunkGetPointer(chunk), size);
         :	#endif
         :
         :	        AllocAllocInfo(set, chunk);
         :	        return AllocChunkGetPointer(chunk);
         :	}
    0.00 :	  7983b7:       e9 a9 fd ff ff          jmpq   798165 <AllocSetAlloc+0x55>
    0.00 :	  7983bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        block->next = set->blocks->next;
         :	                        set->blocks->next = block;
         :	                }
         :	                else
         :	                {
         :	                        block->next = NULL;
    0.00 :	  7983c0:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)
    0.00 :	  7983c7:       00 
         :	                        set->blocks = block;
    0.00 :	  7983c8:       49 89 54 24 38          mov    %rdx,0x38(%r12)
    0.00 :	  7983cd:       e9 2b fe ff ff          jmpq   7981fd <AllocSetAlloc+0xed>
    0.00 :	  7983d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /*
         :	                 * We could be asking for pretty big blocks here, so cope if malloc
         :	                 * fails.  But give up if there's less than a meg or so available...
         :	                 */
         :	                while (block == NULL && blksize > 1024 * 1024)
    0.00 :	  7983d8:       48 81 fb 00 00 10 00    cmp    $0x100000,%rbx
    0.00 :	  7983df:       0f 86 7b ff ff ff       jbe    798360 <AllocSetAlloc+0x250>
         :	                {
         :	                        blksize >>= 1;
    0.00 :	  7983e5:       48 d1 eb                shr    %rbx
         :	                        if (blksize < required_size)
    0.00 :	  7983e8:       49 39 dd                cmp    %rbx,%r13
    0.00 :	  7983eb:       0f 86 5f ff ff ff       jbe    798350 <AllocSetAlloc+0x240>
    0.00 :	  7983f1:       e9 6a ff ff ff          jmpq   798360 <AllocSetAlloc+0x250>
         :	                chunk_size = MAXALIGN(size);
         :	                blksize = chunk_size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;
         :	                block = (AllocBlock) malloc(blksize);
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
    0.00 :	  7983f6:       48 8b 3d 6b 24 42 00    mov    0x42246b(%rip),%rdi        # bba868 <TopMemoryContext>
    0.00 :	  7983fd:       e8 3e 07 00 00          callq  798b40 <MemoryContextStats>
         :	                        ereport(ERROR,
    0.00 :	  798402:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  798405:       b9 80 1f 8e 00          mov    $0x8e1f80,%ecx
    0.00 :	  79840a:       ba a7 02 00 00          mov    $0x2a7,%edx
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
         :	                        ereport(ERROR,
    0.00 :	  79840f:       be 6d 1d 8e 00          mov    $0x8e1d6d,%esi
    0.00 :	  798414:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  798419:       e8 a2 26 fe ff          callq  77aac0 <errstart>
    0.00 :	  79841e:       84 c0                   test   %al,%al
    0.00 :	  798420:       75 20                   jne    798442 <AllocSetAlloc+0x332>
    0.00 :	  798422:       e8 a9 10 cd ff          callq  4694d0 <abort@plt>
         :	                 * cycling even for contexts created with minContextSize = 0; that way
         :	                 * we don't have to force space to be allocated in contexts that might
         :	                 * never need any space.  Don't mark an oversize block as a keeper,
         :	                 * however.
         :	                 */
         :	                if (set->keeper == NULL && blksize == set->initBlockSize)
    0.00 :	  798427:       49 39 9c 24 98 00 00    cmp    %rbx,0x98(%r12)
    0.00 :	  79842e:       00 
    0.00 :	  79842f:       0f 85 59 ff ff ff       jne    79838e <AllocSetAlloc+0x27e>
         :	                        set->keeper = block;
    0.00 :	  798435:       49 89 94 24 b8 00 00    mov    %rdx,0xb8(%r12)
    0.00 :	  79843c:       00 
    0.00 :	  79843d:       e9 4c ff ff ff          jmpq   79838e <AllocSetAlloc+0x27e>
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
         :	                        ereport(ERROR,
    0.00 :	  798442:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  798445:       bf a8 1d 8e 00          mov    $0x8e1da8,%edi
    0.00 :	  79844a:       31 c0                   xor    %eax,%eax
    0.00 :	  79844c:       e8 df 40 fe ff          callq  77c530 <errdetail>
    0.00 :	  798451:       bf 04 9c 7b 00          mov    $0x7b9c04,%edi
    0.00 :	  798456:       41 89 c4                mov    %eax,%r12d
    0.00 :	  798459:       31 c0                   xor    %eax,%eax
    0.00 :	  79845b:       e8 40 44 fe ff          callq  77c8a0 <errmsg>
    0.00 :	  798460:       bf c5 20 00 00          mov    $0x20c5,%edi
    0.00 :	  798465:       89 c3                   mov    %eax,%ebx
    0.00 :	  798467:       e8 e4 48 fe ff          callq  77cd50 <errcode>
    0.00 :	  79846c:       44 89 e2                mov    %r12d,%edx
    0.00 :	  79846f:       89 c7                   mov    %eax,%edi
    0.00 :	  798471:       89 de                   mov    %ebx,%esi
    0.00 :	  798473:       31 c0                   xor    %eax,%eax
    0.00 :	  798475:       e8 66 21 fe ff          callq  77a5e0 <errfinish>
    0.00 :	  79847a:       eb a6                   jmp    798422 <AllocSetAlloc+0x312>
         :	                        block = (AllocBlock) malloc(blksize);
         :	                }
         :
         :	                if (block == NULL)
         :	                {
         :	                        MemoryContextStats(TopMemoryContext);
    0.00 :	  79847c:       48 8b 3d e5 23 42 00    mov    0x4223e5(%rip),%rdi        # bba868 <TopMemoryContext>
    0.00 :	  798483:       e8 b8 06 00 00          callq  798b40 <MemoryContextStats>
         :	                        ereport(ERROR,
    0.00 :	  798488:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  79848b:       b9 80 1f 8e 00          mov    $0x8e1f80,%ecx
    0.00 :	  798490:       ba 69 03 00 00          mov    $0x369,%edx
    0.00 :	  798495:       e9 75 ff ff ff          jmpq   79840f <AllocSetAlloc+0x2ff>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   42.86 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1508
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1483
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1489
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1494
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1506
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000496e90 <heap_getnext>:
         :	#endif   /* !defined(HEAPDEBUGALL) */
         :
         :
         :	HeapTuple
         :	heap_getnext(HeapScanDesc scan, ScanDirection direction)
         :	{
    0.00 :	  496e90:       55                      push   %rbp
    0.00 :	  496e91:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1483
   14.29 :	  496e94:       53                      push   %rbx
    0.00 :	  496e95:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  496e98:       48 83 ec 08             sub    $0x8,%rsp
         :	        /* Note: no locking manipulations needed */
         :
         :	        HEAPDEBUG_1;                            /* heap_getnext( info ) */
         :
         :	        if (scan->rs_pageatatime)
    0.00 :	  496e9c:       80 7f 21 00             cmpb   $0x0,0x21(%rdi)
    0.00 :	  496ea0:       74 3e                   je     496ee0 <heap_getnext+0x50>
         :	                heapgettup_pagemode(scan, direction,
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1489
   14.29 :	  496ea2:       48 8b 4f 18             mov    0x18(%rdi),%rcx
    0.00 :	  496ea6:       8b 57 10                mov    0x10(%rdi),%edx
    0.00 :	  496ea9:       e8 42 f2 ff ff          callq  4960f0 <heapgettup_pagemode>
         :	                                                        scan->rs_nkeys, scan->rs_key);
         :	        else
         :	                heapgettup(scan, direction, scan->rs_nkeys, scan->rs_key);
         :
         :	        if (scan->rs_ctup.t_data == NULL)
    0.00 :	  496eae:       31 c0                   xor    %eax,%eax
    0.00 :	  496eb0:       48 83 7b 58 00          cmpq   $0x0,0x58(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1494
   14.29 :	  496eb5:       74 18                   je     496ecf <heap_getnext+0x3f>
         :	         * if we get here it means we have a new current scan tuple, so point to
         :	         * the proper return buffer and return the tuple.
         :	         */
         :	        HEAPDEBUG_3;                            /* heap_getnext returning tuple */
         :
         :	        pgstat_count_heap_getnext(scan->rs_rd);
    0.00 :	  496eb7:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  496eba:       48 8b 80 38 01 00 00    mov    0x138(%rax),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1506
   14.29 :	  496ec1:       48 85 c0                test   %rax,%rax
    0.00 :	  496ec4:       74 05                   je     496ecb <heap_getnext+0x3b>
    0.00 :	  496ec6:       48 83 40 18 01          addq   $0x1,0x18(%rax)
         :
         :	        return &(scan->rs_ctup);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:1508
   42.86 :	  496ecb:       48 8d 43 48             lea    0x48(%rbx),%rax
         :	}
    0.00 :	  496ecf:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  496ed3:       5b                      pop    %rbx
    0.00 :	  496ed4:       c9                      leaveq 
    0.00 :	  496ed5:       c3                      retq   
    0.00 :	  496ed6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  496edd:       00 00 00 
         :
         :	        if (scan->rs_pageatatime)
         :	                heapgettup_pagemode(scan, direction,
         :	                                                        scan->rs_nkeys, scan->rs_key);
         :	        else
         :	                heapgettup(scan, direction, scan->rs_nkeys, scan->rs_key);
    0.00 :	  496ee0:       48 8b 4f 18             mov    0x18(%rdi),%rcx
    0.00 :	  496ee4:       8b 57 10                mov    0x10(%rdi),%edx
    0.00 :	  496ee7:       e8 c4 f7 ff ff          callq  4966b0 <heapgettup>
    0.00 :	  496eec:       eb c0                   jmp    496eae <heap_getnext+0x1e>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:61
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:76
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:86
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c5930 <SeqNext>:
         :	 *              This is a workhorse for ExecSeqScan
         :	 * ----------------------------------------------------------------
         :	 */
         :	static TupleTableSlot *
         :	SeqNext(SeqScanState *node)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:48
   28.57 :	  5c5930:       55                      push   %rbp
   14.29 :	  5c5931:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c5934:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  5c5938:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  5c593c:       48 83 ec 10             sub    $0x10,%rsp
         :	        slot = node->ss_ScanTupleSlot;
         :
         :	        /*
         :	         * get the next tuple from the table
         :	         */
         :	        tuple = heap_getnext(scandesc, direction);
    0.00 :	  5c5940:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	        TupleTableSlot *slot;
         :
         :	        /*
         :	         * get information from the estate and scan state
         :	         */
         :	        scandesc = node->ss_currentScanDesc;
    0.00 :	  5c5944:       4c 8b a7 80 00 00 00    mov    0x80(%rdi),%r12
         :	        estate = node->ps.state;
         :	        direction = estate->es_direction;
         :	        slot = node->ss_ScanTupleSlot;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:61
   28.57 :	  5c594b:       48 8b 9f 88 00 00 00    mov    0x88(%rdi),%rbx
         :
         :	        /*
         :	         * get the next tuple from the table
         :	         */
         :	        tuple = heap_getnext(scandesc, direction);
    0.00 :	  5c5952:       8b 70 04                mov    0x4(%rax),%esi
    0.00 :	  5c5955:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5c5958:       e8 33 15 ed ff          callq  496e90 <heap_getnext>
         :	         * tuples returned by heap_getnext() are pointers onto disk pages and were
         :	         * not created with palloc() and so should not be pfree()'d.  Note also
         :	         * that ExecStoreTuple will increment the refcount of the buffer; the
         :	         * refcount will not be dropped until the tuple table slot is cleared.
         :	         */
         :	        if (tuple)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:76
   14.29 :	  5c595d:       48 85 c0                test   %rax,%rax
    0.00 :	  5c5960:       74 26                   je     5c5988 <SeqNext+0x58>
         :	                ExecStoreTuple(tuple,   /* tuple to store */
    0.00 :	  5c5962:       41 8b 54 24 64          mov    0x64(%r12),%edx
    0.00 :	  5c5967:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5c5969:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5c596c:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5c596f:       e8 0c eb fe ff          callq  5b4480 <ExecStoreTuple>
         :	                                           false);      /* don't pfree this pointer */
         :	        else
         :	                ExecClearTuple(slot);
         :
         :	        return slot;
         :	}
    0.00 :	  5c5974:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5c5977:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  5c597c:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5c5980:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:86
   14.29 :	  5c5981:       c3                      retq   
    0.00 :	  5c5982:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                           slot,        /* slot to store in */
         :	                                           scandesc->rs_cbuf,           /* buffer associated with this
         :	                                                                                                 * tuple */
         :	                                           false);      /* don't pfree this pointer */
         :	        else
         :	                ExecClearTuple(slot);
    0.00 :	  5c5988:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5c598b:       e8 80 e7 fe ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5c5990:       eb e2                   jmp    5c5974 <SeqNext+0x44>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1504
   28.57 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1508
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1504
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1504
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1508
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000642780 <pgstat_init_function_usage>:
         :	 * Called by the executor before invoking a function.
         :	 */
         :	void
         :	pgstat_init_function_usage(FunctionCallInfoData *fcinfo,
         :	                                                   PgStat_FunctionCallUsage *fcu)
         :	{
    0.00 :	  642780:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1504
   28.57 :	  642781:       48 89 e5                mov    %rsp,%rbp
   14.29 :	  642784:       41 54                   push   %r12
    0.00 :	  642786:       49 89 fc                mov    %rdi,%r12
    0.00 :	  642789:       53                      push   %rbx
   14.29 :	  64278a:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  64278d:       48 83 ec 70             sub    $0x70,%rsp
         :	        PgStat_BackendFunctionEntry *htabent;
         :	        bool            found;
         :
         :	        if (pgstat_track_functions <= fcinfo->flinfo->fn_stats)
    0.00 :	  642791:       48 8b 17                mov    (%rdi),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1508
   28.57 :	  642794:       0f b6 42 10             movzbl 0x10(%rdx),%eax
    0.00 :	  642798:       3b 05 06 94 53 00       cmp    0x539406(%rip),%eax        # b7bba4 <pgstat_track_functions>
   14.29 :	  64279e:       0f 8d ac 00 00 00       jge    642850 <pgstat_init_function_usage+0xd0>
         :	                /* stats not wanted */
         :	                fcu->fs = NULL;
         :	                return;
         :	        }
         :
         :	        if (!pgStatFunctions)
    0.00 :	  6427a4:       48 83 3d 04 95 53 00    cmpq   $0x0,0x539504(%rip)        # b7bcb0 <pgStatFunctions>
    0.00 :	  6427ab:       00 
    0.00 :	  6427ac:       0f 84 de 00 00 00       je     642890 <pgstat_init_function_usage+0x110>
         :	                                                                          &hash_ctl,
         :	                                                                          HASH_ELEM | HASH_FUNCTION);
         :	        }
         :
         :	        /* Get the stats entry for this function, create if necessary */
         :	        htabent = hash_search(pgStatFunctions, &fcinfo->flinfo->fn_oid,
    0.00 :	  6427b2:       48 8b 3d f7 94 53 00    mov    0x5394f7(%rip),%rdi        # b7bcb0 <pgStatFunctions>
    0.00 :	  6427b9:       48 8d 72 08             lea    0x8(%rdx),%rsi
    0.00 :	  6427bd:       48 8d 4d ef             lea    -0x11(%rbp),%rcx
    0.00 :	  6427c1:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  6427c6:       e8 d5 1e 14 00          callq  7846a0 <hash_search>
         :	                                                  HASH_ENTER, &found);
         :	        if (!found)
    0.00 :	  6427cb:       80 7d ef 00             cmpb   $0x0,-0x11(%rbp)
         :	                                                                          &hash_ctl,
         :	                                                                          HASH_ELEM | HASH_FUNCTION);
         :	        }
         :
         :	        /* Get the stats entry for this function, create if necessary */
         :	        htabent = hash_search(pgStatFunctions, &fcinfo->flinfo->fn_oid,
    0.00 :	  6427cf:       48 89 c2                mov    %rax,%rdx
    0.00 :	  6427d2:       48 8d 40 08             lea    0x8(%rax),%rax
         :	                                                  HASH_ENTER, &found);
         :	        if (!found)
    0.00 :	  6427d6:       74 40                   je     642818 <pgstat_init_function_usage+0x98>
         :	                MemSet(&htabent->f_counts, 0, sizeof(PgStat_FunctionCounts));
         :
         :	        fcu->fs = &htabent->f_counts;
    0.00 :	  6427d8:       48 89 03                mov    %rax,(%rbx)
         :
         :	        /* save stats for this function, later used to compensate for recursion */
         :	        fcu->save_f_total_time = htabent->f_counts.f_total_time;
    0.00 :	  6427db:       48 8b 42 10             mov    0x10(%rdx),%rax
         :
         :	        /* save current backend-wide total time */
         :	        fcu->save_total = total_func_time;
         :
         :	        /* get clock time as of function start */
         :	        INSTR_TIME_SET_CURRENT(fcu->f_start);
    0.00 :	  6427df:       48 8d 7b 28             lea    0x28(%rbx),%rdi
    0.00 :	  6427e3:       31 f6                   xor    %esi,%esi
         :	                MemSet(&htabent->f_counts, 0, sizeof(PgStat_FunctionCounts));
         :
         :	        fcu->fs = &htabent->f_counts;
         :
         :	        /* save stats for this function, later used to compensate for recursion */
         :	        fcu->save_f_total_time = htabent->f_counts.f_total_time;
    0.00 :	  6427e5:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  6427e9:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  6427ed:       48 89 43 10             mov    %rax,0x10(%rbx)
         :
         :	        /* save current backend-wide total time */
         :	        fcu->save_total = total_func_time;
    0.00 :	  6427f1:       48 8b 05 28 97 53 00    mov    0x539728(%rip),%rax        # b7bf20 <total_func_time>
    0.00 :	  6427f8:       48 89 43 18             mov    %rax,0x18(%rbx)
    0.00 :	  6427fc:       48 8b 05 25 97 53 00    mov    0x539725(%rip),%rax        # b7bf28 <total_func_time+0x8>
    0.00 :	  642803:       48 89 43 20             mov    %rax,0x20(%rbx)
         :
         :	        /* get clock time as of function start */
         :	        INSTR_TIME_SET_CURRENT(fcu->f_start);
    0.00 :	  642807:       e8 b4 6d e2 ff          callq  4695c0 <gettimeofday@plt>
         :	}
    0.00 :	  64280c:       48 83 c4 70             add    $0x70,%rsp
    0.00 :	  642810:       5b                      pop    %rbx
    0.00 :	  642811:       41 5c                   pop    %r12
    0.00 :	  642813:       c9                      leaveq 
    0.00 :	  642814:       c3                      retq   
    0.00 :	  642815:       0f 1f 00                nopl   (%rax)
         :
         :	        /* Get the stats entry for this function, create if necessary */
         :	        htabent = hash_search(pgStatFunctions, &fcinfo->flinfo->fn_oid,
         :	                                                  HASH_ENTER, &found);
         :	        if (!found)
         :	                MemSet(&htabent->f_counts, 0, sizeof(PgStat_FunctionCounts));
    0.00 :	  642818:       a8 07                   test   $0x7,%al
    0.00 :	  64281a:       75 44                   jne    642860 <pgstat_init_function_usage+0xe0>
    0.00 :	  64281c:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)
    0.00 :	  642823:       00 
    0.00 :	  642824:       48 c7 42 10 00 00 00    movq   $0x0,0x10(%rdx)
    0.00 :	  64282b:       00 
    0.00 :	  64282c:       48 c7 42 18 00 00 00    movq   $0x0,0x18(%rdx)
    0.00 :	  642833:       00 
    0.00 :	  642834:       48 c7 42 20 00 00 00    movq   $0x0,0x20(%rdx)
    0.00 :	  64283b:       00 
    0.00 :	  64283c:       48 c7 42 28 00 00 00    movq   $0x0,0x28(%rdx)
    0.00 :	  642843:       00 
    0.00 :	  642844:       eb 92                   jmp    6427d8 <pgstat_init_function_usage+0x58>
    0.00 :	  642846:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  64284d:       00 00 00 
         :	        bool            found;
         :
         :	        if (pgstat_track_functions <= fcinfo->flinfo->fn_stats)
         :	        {
         :	                /* stats not wanted */
         :	                fcu->fs = NULL;
    0.00 :	  642850:       48 c7 06 00 00 00 00    movq   $0x0,(%rsi)
         :	        /* save current backend-wide total time */
         :	        fcu->save_total = total_func_time;
         :
         :	        /* get clock time as of function start */
         :	        INSTR_TIME_SET_CURRENT(fcu->f_start);
         :	}
    0.00 :	  642857:       48 83 c4 70             add    $0x70,%rsp
    0.00 :	  64285b:       5b                      pop    %rbx
    0.00 :	  64285c:       41 5c                   pop    %r12
    0.00 :	  64285e:       c9                      leaveq 
    0.00 :	  64285f:       c3                      retq   
         :
         :	        /* Get the stats entry for this function, create if necessary */
         :	        htabent = hash_search(pgStatFunctions, &fcinfo->flinfo->fn_oid,
         :	                                                  HASH_ENTER, &found);
         :	        if (!found)
         :	                MemSet(&htabent->f_counts, 0, sizeof(PgStat_FunctionCounts));
    0.00 :	  642860:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)
    0.00 :	  642867:       00 
    0.00 :	  642868:       48 c7 40 08 00 00 00    movq   $0x0,0x8(%rax)
    0.00 :	  64286f:       00 
    0.00 :	  642870:       48 c7 40 10 00 00 00    movq   $0x0,0x10(%rax)
    0.00 :	  642877:       00 
    0.00 :	  642878:       48 c7 40 18 00 00 00    movq   $0x0,0x18(%rax)
    0.00 :	  64287f:       00 
    0.00 :	  642880:       48 c7 40 20 00 00 00    movq   $0x0,0x20(%rax)
    0.00 :	  642887:       00 
    0.00 :	  642888:       e9 4b ff ff ff          jmpq   6427d8 <pgstat_init_function_usage+0x58>
    0.00 :	  64288d:       0f 1f 00                nopl   (%rax)
         :	        if (!pgStatFunctions)
         :	        {
         :	                /* First time through - initialize function stat table */
         :	                HASHCTL         hash_ctl;
         :
         :	                memset(&hash_ctl, 0, sizeof(hash_ctl));
    0.00 :	  642890:       48 8d 55 80             lea    -0x80(%rbp),%rdx
    0.00 :	  642894:       31 c0                   xor    %eax,%eax
    0.00 :	  642896:       b9 0d 00 00 00          mov    $0xd,%ecx
         :	                hash_ctl.keysize = sizeof(Oid);
         :	                hash_ctl.entrysize = sizeof(PgStat_BackendFunctionEntry);
         :	                hash_ctl.hash = oid_hash;
         :	                pgStatFunctions = hash_create("Function stat entries",
    0.00 :	  64289b:       be 00 02 00 00          mov    $0x200,%esi
         :	        if (!pgStatFunctions)
         :	        {
         :	                /* First time through - initialize function stat table */
         :	                HASHCTL         hash_ctl;
         :
         :	                memset(&hash_ctl, 0, sizeof(hash_ctl));
    0.00 :	  6428a0:       48 89 d7                mov    %rdx,%rdi
    0.00 :	  6428a3:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                hash_ctl.keysize = sizeof(Oid);
    0.00 :	  6428a6:       48 c7 45 a8 04 00 00    movq   $0x4,-0x58(%rbp)
    0.00 :	  6428ad:       00 
         :	                hash_ctl.entrysize = sizeof(PgStat_BackendFunctionEntry);
    0.00 :	  6428ae:       48 c7 45 b0 30 00 00    movq   $0x30,-0x50(%rbp)
    0.00 :	  6428b5:       00 
         :	                hash_ctl.hash = oid_hash;
         :	                pgStatFunctions = hash_create("Function stat entries",
    0.00 :	  6428b6:       bf 1c f0 89 00          mov    $0x89f01c,%edi
         :	                HASHCTL         hash_ctl;
         :
         :	                memset(&hash_ctl, 0, sizeof(hash_ctl));
         :	                hash_ctl.keysize = sizeof(Oid);
         :	                hash_ctl.entrysize = sizeof(PgStat_BackendFunctionEntry);
         :	                hash_ctl.hash = oid_hash;
    0.00 :	  6428bb:       48 c7 45 b8 50 4f 78    movq   $0x784f50,-0x48(%rbp)
    0.00 :	  6428c2:       00 
         :	                pgStatFunctions = hash_create("Function stat entries",
    0.00 :	  6428c3:       b1 30                   mov    $0x30,%cl
    0.00 :	  6428c5:       e8 e6 1f 14 00          callq  7848b0 <hash_create>
    0.00 :	  6428ca:       48 89 05 df 93 53 00    mov    %rax,0x5393df(%rip)        # b7bcb0 <pgStatFunctions>
    0.00 :	  6428d1:       49 8b 14 24             mov    (%r12),%rdx
    0.00 :	  6428d5:       e9 d8 fe ff ff          jmpq   6427b2 <pgstat_init_function_usage+0x32>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   28.57 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1435
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1435
   14.29 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007a5600 <XidInMVCCSnapshot>:
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1423
   28.57 :	  7a5600:       55                      push   %rbp
    0.00 :	  7a5601:       48 89 e5                mov    %rsp,%rbp
   14.29 :	  7a5604:       41 54                   push   %r12
   14.29 :	  7a5606:       49 89 f4                mov    %rsi,%r12
    0.00 :	  7a5609:       53                      push   %rbx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1435
   14.29 :	  7a560a:       8b 76 08                mov    0x8(%rsi),%esi
         :	 * by this function.  This is OK for current uses, because we actually only
         :	 * apply this for known-committed XIDs.
         :	 */
         :	static bool
         :	XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)
         :	{
    0.00 :	  7a560d:       89 fb                   mov    %edi,%ebx
         :	         * a parent with XID < xmin, while one with XID >= xmax must belong to a
         :	         * parent that was not yet committed at the time of this snapshot.
         :	         */
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
   14.29 :	  7a560f:       e8 cc a9 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5614:       84 c0                   test   %al,%al
    0.00 :	  7a5616:       74 08                   je     7a5620 <XidInMVCCSnapshot+0x20>
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a5618:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5619:       31 c0                   xor    %eax,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a561b:       41 5c                   pop    %r12
    0.00 :	  7a561d:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/time/tqual.c:1525
   14.29 :	  7a561e:       c3                      retq   
    0.00 :	  7a561f:       90                      nop
         :
         :	        /* Any xid < xmin is not in-progress */
         :	        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                return false;
         :	        /* Any xid >= xmax is in-progress */
         :	        if (TransactionIdFollowsOrEquals(xid, snapshot->xmax))
    0.00 :	  7a5620:       41 8b 74 24 0c          mov    0xc(%r12),%esi
    0.00 :	  7a5625:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5627:       e8 44 aa d1 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  7a562c:       84 c0                   test   %al,%al
    0.00 :	  7a562e:       0f 85 7c 00 00 00       jne    7a56b0 <XidInMVCCSnapshot+0xb0>
         :
         :	        /*
         :	         * Snapshot information is stored slightly differently in snapshots taken
         :	         * during recovery.
         :	         */
         :	        if (!snapshot->takenDuringRecovery)
    0.00 :	  7a5634:       41 80 7c 24 29 00       cmpb   $0x0,0x29(%r12)
    0.00 :	  7a563a:       0f 85 80 00 00 00       jne    7a56c0 <XidInMVCCSnapshot+0xc0>
         :	                 * check things is just to compare the given XID against both subxact
         :	                 * XIDs and top-level XIDs.  If the snapshot overflowed, we have to
         :	                 * use pg_subtrans to convert a subxact XID to its parent XID, but
         :	                 * then we need only look at top-level XIDs not subxacts.
         :	                 */
         :	                if (!snapshot->suboverflowed)
    0.00 :	  7a5640:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a5646:       0f 85 b4 00 00 00       jne    7a5700 <XidInMVCCSnapshot+0x100>
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a564c:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a5651:       85 f6                   test   %esi,%esi
    0.00 :	  7a5653:       7e 25                   jle    7a567a <XidInMVCCSnapshot+0x7a>
         :	                        {
         :	                                if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a5655:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a565a:       31 d2                   xor    %edx,%edx
    0.00 :	  7a565c:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a565e:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a5661:       75 10                   jne    7a5673 <XidInMVCCSnapshot+0x73>
    0.00 :	  7a5663:       eb 4b                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5665:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a5668:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a566b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a566f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a5671:       74 3d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                if (!snapshot->suboverflowed)
         :	                {
         :	                        /* full data, so search subxip */
         :	                        int32           j;
         :
         :	                        for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a5673:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a5676:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a5678:       7c ee                   jl     7a5668 <XidInMVCCSnapshot+0x68>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a567a:       41 8b 74 24 18          mov    0x18(%r12),%esi
    0.00 :	  7a567f:       85 f6                   test   %esi,%esi
    0.00 :	  7a5681:       74 95                   je     7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->xip[i]))
    0.00 :	  7a5683:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  7a5688:       31 d2                   xor    %edx,%edx
    0.00 :	  7a568a:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a568c:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a568f:       75 12                   jne    7a56a3 <XidInMVCCSnapshot+0xa3>
    0.00 :	  7a5691:       eb 1d                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a5693:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  7a5698:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a569b:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a569f:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56a1:       74 0d                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
         :	                                return false;
         :	                }
         :
         :	                for (i = 0; i < snapshot->xcnt; i++)
    0.00 :	  7a56a3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56a6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56a8:       72 ee                   jb     7a5698 <XidInMVCCSnapshot+0x98>
    0.00 :	  7a56aa:       e9 69 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56af:       90                      nop
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b0:       5b                      pop    %rbx
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56b1:       b8 01 00 00 00          mov    $0x1,%eax
         :	                                return true;
         :	                }
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  7a56b6:       41 5c                   pop    %r12
    0.00 :	  7a56b8:       c9                      leaveq 
    0.00 :	  7a56b9:       c3                      retq   
    0.00 :	  7a56ba:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * far the bigger array, and we mostly don't know which xids are
         :	                 * top-level and which are subxacts. The xip array is empty.
         :	                 *
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
    0.00 :	  7a56c0:       41 80 7c 24 28 00       cmpb   $0x0,0x28(%r12)
    0.00 :	  7a56c6:       75 60                   jne    7a5728 <XidInMVCCSnapshot+0x128>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56c8:       41 8b 74 24 1c          mov    0x1c(%r12),%esi
    0.00 :	  7a56cd:       85 f6                   test   %esi,%esi
    0.00 :	  7a56cf:       0f 8e 43 ff ff ff       jle    7a5618 <XidInMVCCSnapshot+0x18>
         :	                {
         :	                        if (TransactionIdEquals(xid, snapshot->subxip[j]))
    0.00 :	  7a56d5:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  7a56da:       31 d2                   xor    %edx,%edx
    0.00 :	  7a56dc:       39 18                   cmp    %ebx,(%rax)
    0.00 :	  7a56de:       48 89 c1                mov    %rax,%rcx
    0.00 :	  7a56e1:       75 10                   jne    7a56f3 <XidInMVCCSnapshot+0xf3>
    0.00 :	  7a56e3:       eb cb                   jmp    7a56b0 <XidInMVCCSnapshot+0xb0>
    0.00 :	  7a56e5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7a56e8:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  7a56eb:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  7a56ef:       39 d8                   cmp    %ebx,%eax
    0.00 :	  7a56f1:       74 bd                   je     7a56b0 <XidInMVCCSnapshot+0xb0>
         :	                /*
         :	                 * We now have either a top-level xid higher than xmin or an
         :	                 * indeterminate xid. We don't know whether it's top level or subxact
         :	                 * but it doesn't matter. If it's present, the xid is visible.
         :	                 */
         :	                for (j = 0; j < snapshot->subxcnt; j++)
    0.00 :	  7a56f3:       83 c2 01                add    $0x1,%edx
    0.00 :	  7a56f6:       39 f2                   cmp    %esi,%edx
    0.00 :	  7a56f8:       7c ee                   jl     7a56e8 <XidInMVCCSnapshot+0xe8>
    0.00 :	  7a56fa:       e9 19 ff ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a56ff:       90                      nop
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5700:       89 df                   mov    %ebx,%edi
    0.00 :	  7a5702:       e8 e9 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5707:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a570c:       89 c7                   mov    %eax,%edi
         :	                        /* not there, fall through to search xip[] */
         :	                }
         :	                else
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a570e:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5710:       e8 cb a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5715:       84 c0                   test   %al,%al
    0.00 :	  7a5717:       0f 84 5d ff ff ff       je     7a567a <XidInMVCCSnapshot+0x7a>
    0.00 :	  7a571d:       e9 f6 fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>
    0.00 :	  7a5722:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a5728:       89 df                   mov    %ebx,%edi
    0.00 :	  7a572a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  7a5730:       e8 bb 11 d2 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a5735:       41 8b 74 24 08          mov    0x8(%r12),%esi
    0.00 :	  7a573a:       89 c7                   mov    %eax,%edi
         :	                 * We start by searching subtrans, if we overflowed.
         :	                 */
         :	                if (snapshot->suboverflowed)
         :	                {
         :	                        /* overflowed, so convert xid to top-level */
         :	                        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  7a573c:       89 c3                   mov    %eax,%ebx
         :	                        /*
         :	                         * If xid was indeed a subxact, we might now have an xid < xmin,
         :	                         * so recheck to avoid an array scan.  No point in rechecking
         :	                         * xmax.
         :	                         */
         :	                        if (TransactionIdPrecedes(xid, snapshot->xmin))
    0.00 :	  7a573e:       e8 9d a8 d1 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  7a5743:       84 c0                   test   %al,%al
    0.00 :	  7a5745:       74 81                   je     7a56c8 <XidInMVCCSnapshot+0xc8>
    0.00 :	  7a5747:       e9 cc fe ff ff          jmpq   7a5618 <XidInMVCCSnapshot+0x18>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:394
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:401
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:409
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:409
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:414
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000495e60 <heapgetpage>:
         :	 * In page-at-a-time mode it performs additional work, namely determining
         :	 * which tuples on the page are visible.
         :	 */
         :	static void
         :	heapgetpage(HeapScanDesc scan, BlockNumber page)
         :	{
    0.00 :	  495e60:       55                      push   %rbp
    0.00 :	  495e61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  495e64:       41 57                   push   %r15
    0.00 :	  495e66:       41 56                   push   %r14
    0.00 :	  495e68:       49 89 fe                mov    %rdi,%r14
    0.00 :	  495e6b:       41 55                   push   %r13
    0.00 :	  495e6d:       41 54                   push   %r12
    0.00 :	  495e6f:       53                      push   %rbx
    0.00 :	  495e70:       48 83 ec 78             sub    $0x78,%rsp
    0.00 :	  495e74:       89 b5 6c ff ff ff       mov    %esi,-0x94(%rbp)
         :	        bool            all_visible;
         :
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        /* release previous scan buffer, if any */
         :	        if (BufferIsValid(scan->rs_cbuf))
    0.00 :	  495e7a:       8b 7f 64                mov    0x64(%rdi),%edi
    0.00 :	  495e7d:       85 ff                   test   %edi,%edi
    0.00 :	  495e7f:       0f 85 fb 01 00 00       jne    496080 <heapgetpage+0x220>
         :	        /*
         :	         * Be sure to check for interrupts at least once per page.  Checks at
         :	         * higher code levels won't be able to stop a seqscan that encounters many
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  495e85:       0f b6 05 04 42 72 00    movzbl 0x724204(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  495e8c:       84 c0                   test   %al,%al
    0.00 :	  495e8e:       0f 85 d4 01 00 00       jne    496068 <heapgetpage+0x208>
         :
         :	        /* read page using selected strategy */
         :	        scan->rs_cbuf = ReadBufferExtended(scan->rs_rd, MAIN_FORKNUM, page,
    0.00 :	  495e94:       4d 8b 46 38             mov    0x38(%r14),%r8
    0.00 :	  495e98:       8b 95 6c ff ff ff       mov    -0x94(%rbp),%edx
    0.00 :	  495e9e:       31 c9                   xor    %ecx,%ecx
    0.00 :	  495ea0:       49 8b 3e                mov    (%r14),%rdi
    0.00 :	  495ea3:       31 f6                   xor    %esi,%esi
    0.00 :	  495ea5:       e8 c6 06 1e 00          callq  676570 <ReadBufferExtended>
         :	                                                                           RBM_NORMAL, scan->rs_strategy);
         :	        scan->rs_cblock = page;
         :
         :	        if (!scan->rs_pageatatime)
    0.00 :	  495eaa:       41 80 7e 21 00          cmpb   $0x0,0x21(%r14)
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
         :
         :	        /* read page using selected strategy */
         :	        scan->rs_cbuf = ReadBufferExtended(scan->rs_rd, MAIN_FORKNUM, page,
    0.00 :	  495eaf:       41 89 c7                mov    %eax,%r15d
    0.00 :	  495eb2:       41 89 46 64             mov    %eax,0x64(%r14)
         :	                                                                           RBM_NORMAL, scan->rs_strategy);
         :	        scan->rs_cblock = page;
    0.00 :	  495eb6:       8b 85 6c ff ff ff       mov    -0x94(%rbp),%eax
    0.00 :	  495ebc:       41 89 46 60             mov    %eax,0x60(%r14)
         :
         :	        if (!scan->rs_pageatatime)
    0.00 :	  495ec0:       75 16                   jne    495ed8 <heapgetpage+0x78>
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
         :	}
    0.00 :	  495ec2:       48 83 c4 78             add    $0x78,%rsp
    0.00 :	  495ec6:       5b                      pop    %rbx
    0.00 :	  495ec7:       41 5c                   pop    %r12
    0.00 :	  495ec9:       41 5d                   pop    %r13
    0.00 :	  495ecb:       41 5e                   pop    %r14
    0.00 :	  495ecd:       41 5f                   pop    %r15
    0.00 :	  495ecf:       c9                      leaveq 
    0.00 :	  495ed0:       c3                      retq   
    0.00 :	  495ed1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	        if (!scan->rs_pageatatime)
         :	                return;
         :
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  495ed8:       49 8b 4e 08             mov    0x8(%r14),%rcx
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  495edc:       44 89 fe                mov    %r15d,%esi
         :
         :	        if (!scan->rs_pageatatime)
         :	                return;
         :
         :	        buffer = scan->rs_cbuf;
         :	        snapshot = scan->rs_snapshot;
    0.00 :	  495edf:       48 89 4d 88             mov    %rcx,-0x78(%rbp)
         :
         :	        /*
         :	         * Prune and repair fragmentation for the whole page, if possible.
         :	         */
         :	        heap_page_prune_opt(scan->rs_rd, buffer);
    0.00 :	  495ee3:       49 8b 3e                mov    (%r14),%rdi
    0.00 :	  495ee6:       e8 65 97 00 00          callq  49f650 <heap_page_prune_opt>
         :	        /*
         :	         * We must hold share lock on the buffer content while examining tuple
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
    0.00 :	  495eeb:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  495ef0:       44 89 ff                mov    %r15d,%edi
    0.00 :	  495ef3:       e8 18 e8 1d 00          callq  674710 <LockBuffer>
         :
         :	        dp = (Page) BufferGetPage(buffer);
    0.00 :	  495ef8:       45 85 ff                test   %r15d,%r15d
    0.00 :	  495efb:       0f 88 cf 01 00 00       js     4960d0 <heapgetpage+0x270>
    0.00 :	  495f01:       41 8d 47 ff             lea    -0x1(%r15),%eax
    0.00 :	  495f05:       48 63 d8                movslq %eax,%rbx
    0.00 :	  495f08:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  495f0c:       48 03 1d e5 9b 72 00    add    0x729be5(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        lines = PageGetMaxOffsetNumber(dp);
    0.00 :	  495f13:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  495f17:       c7 45 90 00 00 00 00    movl   $0x0,-0x70(%rbp)
    0.00 :	  495f1e:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  495f22:       0f 87 88 01 00 00       ja     4960b0 <heapgetpage+0x250>
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  495f28:       c6 45 af 00             movb   $0x0,-0x51(%rbp)
    0.00 :	  495f2c:       f6 43 0a 04             testb  $0x4,0xa(%rbx)
    0.00 :	  495f30:       0f 85 62 01 00 00       jne    496098 <heapgetpage+0x238>
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f36:       8b 7d 90                mov    -0x70(%rbp),%edi
         :	                 lineoff++, lpp++)
    0.00 :	  495f39:       c7 45 a8 00 00 00 00    movl   $0x0,-0x58(%rbp)
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f40:       85 ff                   test   %edi,%edi
    0.00 :	  495f42:       0f 8e c8 00 00 00       jle    496010 <heapgetpage+0x1b0>
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f48:       8b 8d 6c ff ff ff       mov    -0x94(%rbp),%ecx
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
    0.00 :	  495f4e:       4c 8d 6b 18             lea    0x18(%rbx),%r13
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f52:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  495f58:       c1 e9 10                shr    $0x10,%ecx
    0.00 :	  495f5b:       66 89 8d 70 ff ff ff    mov    %cx,-0x90(%rbp)
    0.00 :	  495f62:       eb 19                   jmp    495f7d <heapgetpage+0x11d>
    0.00 :	  495f64:       0f 1f 40 00             nopl   0x0(%rax)
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
         :	                 lineoff++, lpp++)
    0.00 :	  495f68:       41 83 c4 01             add    $0x1,%r12d
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495f6c:       41 0f b7 c4             movzwl %r12w,%eax
    0.00 :	  495f70:       39 45 90                cmp    %eax,-0x70(%rbp)
    0.00 :	  495f73:       0f 8c 97 00 00 00       jl     496010 <heapgetpage+0x1b0>
         :	                 lineoff++, lpp++)
    0.00 :	  495f79:       49 83 c5 04             add    $0x4,%r13
         :	        {
         :	                if (ItemIdIsNormal(lpp))
    0.00 :	  495f7d:       41 8b 45 00             mov    0x0(%r13),%eax
    0.00 :	  495f81:       25 00 80 01 00          and    $0x18000,%eax
    0.00 :	  495f86:       3d 00 80 00 00          cmp    $0x8000,%eax
    0.00 :	  495f8b:       75 db                   jne    495f68 <heapgetpage+0x108>
         :	                {
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
    0.00 :	  495f8d:       49 8b 36                mov    (%r14),%rsi
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495f90:       0f b7 8d 6c ff ff ff    movzwl -0x94(%rbp),%ecx
         :	                if (ItemIdIsNormal(lpp))
         :	                {
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:401
   16.67 :	  495f97:       8b 46 40                mov    0x40(%rsi),%eax
    0.00 :	  495f9a:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
    0.00 :	  495f9d:       41 0f b7 45 00          movzwl 0x0(%r13),%eax
    0.00 :	  495fa2:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	  495fa7:       48 8d 04 03             lea    (%rbx,%rax,1),%rax
    0.00 :	  495fab:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495faf:       41 0f b7 45 02          movzwl 0x2(%r13),%eax
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495fb4:       66 89 4d b6             mov    %cx,-0x4a(%rbp)
    0.00 :	  495fb8:       66 44 89 65 b8          mov    %r12w,-0x48(%rbp)
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495fbd:       66 d1 e8                shr    %ax
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
    0.00 :	  495fc0:       80 7d af 00             cmpb   $0x0,-0x51(%rbp)
         :	                        HeapTupleData loctup;
         :	                        bool            valid;
         :
         :	                        loctup.t_tableOid = RelationGetRelid(scan->rs_rd);
         :	                        loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);
         :	                        loctup.t_len = ItemIdGetLength(lpp);
    0.00 :	  495fc4:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  495fc7:       89 45 b0                mov    %eax,-0x50(%rbp)
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
    0.00 :	  495fca:       0f b7 85 70 ff ff ff    movzwl -0x90(%rbp),%eax
    0.00 :	  495fd1:       66 89 45 b4             mov    %ax,-0x4c(%rbp)
         :
         :	                        if (all_visible)
    0.00 :	  495fd5:       74 59                   je     496030 <heapgetpage+0x1d0>
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  495fd7:       4c 8b 45 88             mov    -0x78(%rbp),%r8
    0.00 :	  495fdb:       48 8d 55 b0             lea    -0x50(%rbp),%rdx
    0.00 :	  495fdf:       44 89 f9                mov    %r15d,%ecx
    0.00 :	  495fe2:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  495fe7:       e8 74 e6 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
    0.00 :	  495fec:       48 63 45 a8             movslq -0x58(%rbp),%rax
    0.00 :	  495ff0:       66 45 89 64 46 7c       mov    %r12w,0x7c(%r14,%rax,2)
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
         :	                 lineoff++, lpp++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:394
   33.33 :	  495ff6:       41 83 c4 01             add    $0x1,%r12d
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
    0.00 :	  495ffa:       83 45 a8 01             addl   $0x1,-0x58(%rbp)
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
         :
         :	        for (lineoff = FirstOffsetNumber, lpp = PageGetItemId(dp, lineoff);
         :	                 lineoff <= lines;
    0.00 :	  495ffe:       41 0f b7 c4             movzwl %r12w,%eax
    0.00 :	  496002:       39 45 90                cmp    %eax,-0x70(%rbp)
    0.00 :	  496005:       0f 8d 6e ff ff ff       jge    495f79 <heapgetpage+0x119>
    0.00 :	  49600b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        if (valid)
         :	                                scan->rs_vistuples[ntup++] = lineoff;
         :	                }
         :	        }
         :
         :	        LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
    0.00 :	  496010:       44 89 ff                mov    %r15d,%edi
    0.00 :	  496013:       31 f6                   xor    %esi,%esi
    0.00 :	  496015:       e8 f6 e6 1d 00          callq  674710 <LockBuffer>
         :
         :	        Assert(ntup <= MaxHeapTuplesPerPage);
         :	        scan->rs_ntuples = ntup;
    0.00 :	  49601a:       8b 45 a8                mov    -0x58(%rbp),%eax
    0.00 :	  49601d:       41 89 46 78             mov    %eax,0x78(%r14)
         :	}
    0.00 :	  496021:       48 83 c4 78             add    $0x78,%rsp
    0.00 :	  496025:       5b                      pop    %rbx
    0.00 :	  496026:       41 5c                   pop    %r12
    0.00 :	  496028:       41 5d                   pop    %r13
    0.00 :	  49602a:       41 5e                   pop    %r14
    0.00 :	  49602c:       41 5f                   pop    %r15
    0.00 :	  49602e:       c9                      leaveq 
    0.00 :	  49602f:       c3                      retq   
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:409
   16.67 :	  496030:       48 8b 75 88             mov    -0x78(%rbp),%rsi
    0.00 :	  496034:       44 89 fa                mov    %r15d,%edx
    0.00 :	  496037:       48 8d 7d b0             lea    -0x50(%rbp),%rdi
    0.00 :	  49603b:       ff 16                   callq  *(%rsi)
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  49603d:       4c 8b 45 88             mov    -0x78(%rbp),%r8
         :	                        ItemPointerSet(&(loctup.t_self), page, lineoff);
         :
         :	                        if (all_visible)
         :	                                valid = true;
         :	                        else
         :	                                valid = HeapTupleSatisfiesVisibility(&loctup, snapshot, buffer);
   16.67 :	  496041:       88 45 ae                mov    %al,-0x52(%rbp)
         :
         :	                        CheckForSerializableConflictOut(valid, scan->rs_rd, &loctup,
    0.00 :	  496044:       48 8d 55 b0             lea    -0x50(%rbp),%rdx
    0.00 :	  496048:       49 8b 36                mov    (%r14),%rsi
    0.00 :	  49604b:       0f be f8                movsbl %al,%edi
    0.00 :	  49604e:       44 89 f9                mov    %r15d,%ecx
    0.00 :	  496051:       e8 0a e6 1f 00          callq  694660 <CheckForSerializableConflictOut>
         :	                                                                                        buffer, snapshot);
         :
         :	                        if (valid)
    0.00 :	  496056:       80 7d ae 00             cmpb   $0x0,-0x52(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/heap/heapam.c:414
   16.67 :	  49605a:       0f 84 08 ff ff ff       je     495f68 <heapgetpage+0x108>
    0.00 :	  496060:       eb 8a                   jmp    495fec <heapgetpage+0x18c>
    0.00 :	  496062:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  496068:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  49606f:       00 
         :	        /*
         :	         * Be sure to check for interrupts at least once per page.  Checks at
         :	         * higher code levels won't be able to stop a seqscan that encounters many
         :	         * pages' worth of consecutive dead tuples.
         :	         */
         :	        CHECK_FOR_INTERRUPTS();
    0.00 :	  496070:       e8 2b 62 20 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  496075:       0f 1f 00                nopl   (%rax)
    0.00 :	  496078:       e9 17 fe ff ff          jmpq   495e94 <heapgetpage+0x34>
    0.00 :	  49607d:       0f 1f 00                nopl   (%rax)
         :	        Assert(page < scan->rs_nblocks);
         :
         :	        /* release previous scan buffer, if any */
         :	        if (BufferIsValid(scan->rs_cbuf))
         :	        {
         :	                ReleaseBuffer(scan->rs_cbuf);
    0.00 :	  496080:       e8 db ed 1d 00          callq  674e60 <ReleaseBuffer>
         :	                scan->rs_cbuf = InvalidBuffer;
    0.00 :	  496085:       41 c7 46 64 00 00 00    movl   $0x0,0x64(%r14)
    0.00 :	  49608c:       00 
    0.00 :	  49608d:       0f 1f 00                nopl   (%rax)
    0.00 :	  496090:       e9 f0 fd ff ff          jmpq   495e85 <heapgetpage+0x25>
    0.00 :	  496095:       0f 1f 00                nopl   (%rax)
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  496098:       48 8b 45 88             mov    -0x78(%rbp),%rax
    0.00 :	  49609c:       80 78 29 00             cmpb   $0x0,0x29(%rax)
    0.00 :	  4960a0:       0f 94 45 af             sete   -0x51(%rbp)
    0.00 :	  4960a4:       e9 8d fe ff ff          jmpq   495f36 <heapgetpage+0xd6>
    0.00 :	  4960a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
         :	        lines = PageGetMaxOffsetNumber(dp);
    0.00 :	  4960b0:       0f b7 c0                movzwl %ax,%eax
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  4960b3:       c6 45 af 00             movb   $0x0,-0x51(%rbp)
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
         :	        lines = PageGetMaxOffsetNumber(dp);
    0.00 :	  4960b7:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4960bb:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4960bf:       89 45 90                mov    %eax,-0x70(%rbp)
         :	         * the page-level flag can be trusted in the same way, because it might
         :	         * get propagated somehow without being explicitly WAL-logged, e.g. via a
         :	         * full page write. Until we can prove that beyond doubt, let's check each
         :	         * tuple for visibility the hard way.
         :	         */
         :	        all_visible = PageIsAllVisible(dp) && !snapshot->takenDuringRecovery;
    0.00 :	  4960c2:       f6 43 0a 04             testb  $0x4,0xa(%rbx)
    0.00 :	  4960c6:       0f 84 6a fe ff ff       je     495f36 <heapgetpage+0xd6>
    0.00 :	  4960cc:       eb ca                   jmp    496098 <heapgetpage+0x238>
    0.00 :	  4960ce:       66 90                   xchg   %ax,%ax
         :	         * visibility.  Afterwards, however, the tuples we have found to be
         :	         * visible are guaranteed good as long as we hold the buffer pin.
         :	         */
         :	        LockBuffer(buffer, BUFFER_LOCK_SHARE);
         :
         :	        dp = (Page) BufferGetPage(buffer);
    0.00 :	  4960d0:       44 89 f8                mov    %r15d,%eax
    0.00 :	  4960d3:       48 8b 15 3e 70 6e 00    mov    0x6e703e(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4960da:       f7 d0                   not    %eax
    0.00 :	  4960dc:       48 98                   cltq   
    0.00 :	  4960de:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  4960e2:       e9 2c fe ff ff          jmpq   495f13 <heapgetpage+0xb3>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:583
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:583
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:589
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:614
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:620
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:620
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5710 <index_getnext>:
         :	 * enough information to do it efficiently in the general case.
         :	 * ----------------
         :	 */
         :	HeapTuple
         :	index_getnext(IndexScanDesc scan, ScanDirection direction)
         :	{
    0.00 :	  4a5710:       55                      push   %rbp
    0.00 :	  4a5711:       48 89 e5                mov    %rsp,%rbp
   16.67 :	  4a5714:       41 54                   push   %r12
   16.67 :	  4a5716:       41 89 f4                mov    %esi,%r12d
    0.00 :	  4a5719:       53                      push   %rbx
    0.00 :	  4a571a:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  4a571d:       0f 1f 00                nopl   (%rax)
         :	        HeapTuple       heapTuple;
         :	        ItemPointer tid;
         :
         :	        for (;;)
         :	        {
         :	                if (scan->xs_continue_hot)
    0.00 :	  4a5720:       80 7b 6d 00             cmpb   $0x0,0x6d(%rbx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:589
   16.67 :	  4a5724:       74 1a                   je     4a5740 <index_getnext+0x30>
         :	                /*
         :	                 * Fetch the next (or only) visible heap tuple for this index entry.
         :	                 * If we don't find anything, loop around and grab the next TID from
         :	                 * the index.
         :	                 */
         :	                heapTuple = index_fetch_heap(scan);
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:614
   16.67 :	  4a5726:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4a5729:       e8 f2 fd ff ff          callq  4a5520 <index_fetch_heap>
         :	                if (heapTuple != NULL)
    0.00 :	  4a572e:       48 85 c0                test   %rax,%rax
    0.00 :	  4a5731:       74 ed                   je     4a5720 <index_getnext+0x10>
         :	                        return heapTuple;
         :	        }
         :
         :	        return NULL;                            /* failure exit */
         :	}
    0.00 :	  4a5733:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:620
   16.67 :	  4a5734:       41 5c                   pop    %r12
    0.00 :	  4a5736:       c9                      leaveq 
   16.67 :	  4a5737:       c3                      retq   
    0.00 :	  4a5738:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4a573f:       00 
         :	                                   BufferGetBlockNumber(scan->xs_cbuf));
         :	                }
         :	                else
         :	                {
         :	                        /* Time to fetch the next TID from the index */
         :	                        tid = index_getnext_tid(scan, direction);
    0.00 :	  4a5740:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4a5743:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4a5746:       e8 e5 fe ff ff          callq  4a5630 <index_getnext_tid>
         :
         :	                        /* If we're out of index entries, we're done */
         :	                        if (tid == NULL)
    0.00 :	  4a574b:       48 85 c0                test   %rax,%rax
    0.00 :	  4a574e:       75 d6                   jne    4a5726 <index_getnext+0x16>
    0.00 :	  4a5750:       eb e1                   jmp    4a5733 <index_getnext+0x23>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:102
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:130
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:314
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004aac20 <_bt_getroot>:
         :	 *              On successful return, the root page is pinned and read-locked.
         :	 *              The metadata page is not locked or pinned on exit.
         :	 */
         :	Buffer
         :	_bt_getroot(Relation rel, int access)
         :	{
    0.00 :	  4aac20:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:102
   16.67 :	  4aac21:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4aac24:       41 57                   push   %r15
    0.00 :	  4aac26:       41 56                   push   %r14
    0.00 :	  4aac28:       49 89 fe                mov    %rdi,%r14
    0.00 :	  4aac2b:       41 55                   push   %r13
    0.00 :	  4aac2d:       41 89 f5                mov    %esi,%r13d
    0.00 :	  4aac30:       41 54                   push   %r12
    0.00 :	  4aac32:       53                      push   %rbx
    0.00 :	  4aac33:       48 83 ec 58             sub    $0x58,%rsp
         :	        /*
         :	         * Try to use previously-cached metapage data to find the root.  This
         :	         * normally saves one buffer access per index search, which is a very
         :	         * helpful savings in bufmgr traffic and hence contention.
         :	         */
         :	        if (rel->rd_amcache != NULL)
    0.00 :	  4aac37:       48 8b 87 18 01 00 00    mov    0x118(%rdi),%rax
    0.00 :	  4aac3e:       48 85 c0                test   %rax,%rax
    0.00 :	  4aac41:       74 6a                   je     4aacad <_bt_getroot+0x8d>
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac43:       8b 70 10                mov    0x10(%rax),%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:130
   16.67 :	  4aac46:       ba 01 00 00 00          mov    $0x1,%edx
         :	                Assert(metad->btm_version == BTREE_VERSION);
         :	                Assert(metad->btm_root != P_NONE);
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aac4b:       8b 58 14                mov    0x14(%rax),%ebx
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac4e:       e8 fd e3 ff ff          callq  4a9050 <_bt_getbuf>
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aac53:       85 c0                   test   %eax,%eax
         :
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
    0.00 :	  4aac55:       41 89 c4                mov    %eax,%r12d
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aac58:       0f 88 6a 02 00 00       js     4aaec8 <_bt_getroot+0x2a8>
    0.00 :	  4aac5e:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aac63:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4aac66:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4aac6a:       48 03 15 87 4e 71 00    add    0x714e87(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aac71:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4aac75:       48 01 c2                add    %rax,%rdx
         :	                 * here than normal.  We *must* check that it's not deleted. If it's
         :	                 * not alone on its level, then we reject too --- this may be overly
         :	                 * paranoid but better safe than sorry.  Note we don't check P_ISROOT,
         :	                 * because that's not set in a "fast root".
         :	                 */
         :	                if (!P_IGNORE(rootopaque) &&
    0.00 :	  4aac78:       0f b7 42 0c             movzwl 0xc(%rdx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
   16.67 :	  4aac7c:       a8 14                   test   $0x14,%al
    0.00 :	  4aac7e:       75 09                   jne    4aac89 <_bt_getroot+0x69>
    0.00 :	  4aac80:       39 5a 08                cmp    %ebx,0x8(%rdx)
    0.00 :	  4aac83:       0f 84 57 02 00 00       je     4aaee0 <_bt_getroot+0x2c0>
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aac89:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aac8c:       e8 9f a2 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	                        /* OK, accept cached page as the root */
         :	                        return rootbuf;
         :	                }
         :	                _bt_relbuf(rel, rootbuf);
         :	                /* Cache is stale, throw it away */
         :	                if (rel->rd_amcache)
    0.00 :	  4aac91:       49 8b be 18 01 00 00    mov    0x118(%r14),%rdi
    0.00 :	  4aac98:       48 85 ff                test   %rdi,%rdi
    0.00 :	  4aac9b:       74 05                   je     4aaca2 <_bt_getroot+0x82>
         :	                        pfree(rel->rd_amcache);
    0.00 :	  4aac9d:       e8 de de 2e 00          callq  798b80 <pfree>
         :	                rel->rd_amcache = NULL;
    0.00 :	  4aaca2:       49 c7 86 18 01 00 00    movq   $0x0,0x118(%r14)
    0.00 :	  4aaca9:       00 00 00 00 
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
    0.00 :	  4aacad:       31 f6                   xor    %esi,%esi
    0.00 :	  4aacaf:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4aacb4:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aacb7:       e8 94 e3 ff ff          callq  4a9050 <_bt_getbuf>
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aacbc:       85 c0                   test   %eax,%eax
         :	                if (rel->rd_amcache)
         :	                        pfree(rel->rd_amcache);
         :	                rel->rd_amcache = NULL;
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
    0.00 :	  4aacbe:       41 89 c0                mov    %eax,%r8d
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aacc1:       0f 88 e9 01 00 00       js     4aaeb0 <_bt_getroot+0x290>
    0.00 :	  4aacc7:       41 8d 40 ff             lea    -0x1(%r8),%eax
    0.00 :	  4aaccb:       48 63 d8                movslq %eax,%rbx
    0.00 :	  4aacce:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  4aacd2:       48 03 1d 1f 4e 71 00    add    0x714e1f(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	        metaopaque = (BTPageOpaque) PageGetSpecialPointer(metapg);
         :	        metad = BTPageGetMeta(metapg);
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
    0.00 :	  4aacd9:       0f b7 43 10             movzwl 0x10(%rbx),%eax
    0.00 :	  4aacdd:       f6 44 03 0c 08          testb  $0x8,0xc(%rbx,%rax,1)
    0.00 :	  4aace2:       74 0d                   je     4aacf1 <_bt_getroot+0xd1>
    0.00 :	  4aace4:       81 7b 18 62 31 05 00    cmpl   $0x53162,0x18(%rbx)
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
         :	        metapg = BufferGetPage(metabuf);
         :	        metaopaque = (BTPageOpaque) PageGetSpecialPointer(metapg);
         :	        metad = BTPageGetMeta(metapg);
    0.00 :	  4aaceb:       4c 8d 7b 18             lea    0x18(%rbx),%r15
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
    0.00 :	  4aacef:       74 5f                   je     4aad50 <_bt_getroot+0x130>
         :	                metad->btm_magic != BTREE_MAGIC)
         :	                ereport(ERROR,
    0.00 :	  4aacf1:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4aacf4:       b9 50 47 7b 00          mov    $0x7b4750,%ecx
    0.00 :	  4aacf9:       ba a7 00 00 00          mov    $0xa7,%edx
    0.00 :	  4aacfe:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4aad03:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4aad08:       e8 b3 fd 2c 00          callq  77aac0 <errstart>
    0.00 :	  4aad0d:       84 c0                   test   %al,%al
    0.00 :	  4aad0f:       75 0f                   jne    4aad20 <_bt_getroot+0x100>
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aad11:       e8 ba e7 fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4aad16:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4aad1d:       00 00 00 
         :	        metad = BTPageGetMeta(metapg);
         :
         :	        /* sanity-check the metapage */
         :	        if (!(metaopaque->btpo_flags & BTP_META) ||
         :	                metad->btm_magic != BTREE_MAGIC)
         :	                ereport(ERROR,
    0.00 :	  4aad20:       49 8b 76 30             mov    0x30(%r14),%rsi
    0.00 :	  4aad24:       bf 4a 43 7b 00          mov    $0x7b434a,%edi
    0.00 :	  4aad29:       31 c0                   xor    %eax,%eax
    0.00 :	  4aad2b:       e8 70 1b 2d 00          callq  77c8a0 <errmsg>
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
         :	                ereport(ERROR,
    0.00 :	  4aad30:       89 c3                   mov    %eax,%ebx
    0.00 :	  4aad32:       bf 28 0a 00 02          mov    $0x2000a28,%edi
    0.00 :	  4aad37:       e8 14 20 2d 00          callq  77cd50 <errcode>
    0.00 :	  4aad3c:       89 de                   mov    %ebx,%esi
    0.00 :	  4aad3e:       89 c7                   mov    %eax,%edi
    0.00 :	  4aad40:       31 c0                   xor    %eax,%eax
    0.00 :	  4aad42:       e8 99 f8 2c 00          callq  77a5e0 <errfinish>
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aad47:       e8 84 e7 fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4aad4c:       0f 1f 40 00             nopl   0x0(%rax)
         :	                ereport(ERROR,
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
    0.00 :	  4aad50:       41 83 7f 04 02          cmpl   $0x2,0x4(%r15)
    0.00 :	  4aad55:       0f 85 7b 03 00 00       jne    4ab0d6 <_bt_getroot+0x4b6>
         :	                                 errmsg("version mismatch in index \"%s\": file version %d, code version %d",
         :	                                                RelationGetRelationName(rel),
         :	                                                metad->btm_version, BTREE_VERSION)));
         :
         :	        /* if no root page initialized yet, do it */
         :	        if (metad->btm_root == P_NONE)
    0.00 :	  4aad5b:       45 8b 57 08             mov    0x8(%r15),%r10d
    0.00 :	  4aad5f:       45 85 d2                test   %r10d,%r10d
    0.00 :	  4aad62:       0f 85 a8 01 00 00       jne    4aaf10 <_bt_getroot+0x2f0>
         :	        {
         :	                /* If access = BT_READ, caller doesn't want us to create root yet */
         :	                if (access == BT_READ)
    0.00 :	  4aad68:       41 83 fd 01             cmp    $0x1,%r13d
    0.00 :	  4aad6c:       0f 84 8e 01 00 00       je     4aaf00 <_bt_getroot+0x2e0>
         :	                        _bt_relbuf(rel, metabuf);
         :	                        return InvalidBuffer;
         :	                }
         :
         :	                /* trade in our read lock for a write lock */
         :	                LockBuffer(metabuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aad72:       31 f6                   xor    %esi,%esi
    0.00 :	  4aad74:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aad77:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aad7b:       e8 90 99 1c 00          callq  674710 <LockBuffer>
         :	                LockBuffer(metabuf, BT_WRITE);
    0.00 :	  4aad80:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aad84:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  4aad89:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aad8c:       e8 7f 99 1c 00          callq  674710 <LockBuffer>
         :	                /*
         :	                 * Race condition:      if someone else initialized the metadata between
         :	                 * the time we released the read lock and acquired the write lock, we
         :	                 * must avoid doing it again.
         :	                 */
         :	                if (metad->btm_root != P_NONE)
    0.00 :	  4aad91:       45 8b 4f 08             mov    0x8(%r15),%r9d
    0.00 :	  4aad95:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aad99:       45 85 c9                test   %r9d,%r9d
    0.00 :	  4aad9c:       0f 85 66 02 00 00       jne    4ab008 <_bt_getroot+0x3e8>
         :	                /*
         :	                 * Get, initialize, write, and leave a lock of the appropriate type on
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
    0.00 :	  4aada2:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  4aada7:       be ff ff ff ff          mov    $0xffffffff,%esi
    0.00 :	  4aadac:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aadaf:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aadb3:       e8 98 e2 ff ff          callq  4a9050 <_bt_getbuf>
    0.00 :	  4aadb8:       41 89 c4                mov    %eax,%r12d
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
    0.00 :	  4aadbb:       89 c7                   mov    %eax,%edi
    0.00 :	  4aadbd:       e8 6e 92 1c 00          callq  674030 <BufferGetBlockNumber>
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aadc2:       45 85 e4                test   %r12d,%r12d
         :	                 * Get, initialize, write, and leave a lock of the appropriate type on
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
    0.00 :	  4aadc5:       89 45 88                mov    %eax,-0x78(%rbp)
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aadc8:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aadcc:       0f 88 56 02 00 00       js     4ab028 <_bt_getroot+0x408>
    0.00 :	  4aadd2:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aadd7:       4c 63 e8                movslq %eax,%r13
    0.00 :	  4aadda:       49 c1 e5 0d             shl    $0xd,%r13
    0.00 :	  4aadde:       4c 03 2d 13 4d 71 00    add    0x714d13(%rip),%r13        # bbfaf8 <BufferBlocks>
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aade5:       41 0f b7 45 10          movzwl 0x10(%r13),%eax
         :	                metad->btm_root = rootblkno;
         :	                metad->btm_level = 0;
         :	                metad->btm_fastroot = rootblkno;
         :	                metad->btm_fastlevel = 0;
         :
         :	                MarkBufferDirty(rootbuf);
    0.00 :	  4aadea:       44 89 e7                mov    %r12d,%edi
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
         :	                rootpage = BufferGetPage(rootbuf);
         :	                rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aaded:       49 8d 44 05 00          lea    0x0(%r13,%rax,1),%rax
         :	                rootopaque->btpo_prev = rootopaque->btpo_next = P_NONE;
    0.00 :	  4aadf2:       c7 40 04 00 00 00 00    movl   $0x0,0x4(%rax)
    0.00 :	  4aadf9:       c7 00 00 00 00 00       movl   $0x0,(%rax)
         :	                rootopaque->btpo_flags = (BTP_LEAF | BTP_ROOT);
    0.00 :	  4aadff:       66 c7 40 0c 03 00       movw   $0x3,0xc(%rax)
         :	                rootopaque->btpo.level = 0;
    0.00 :	  4aae05:       c7 40 08 00 00 00 00    movl   $0x0,0x8(%rax)
         :	                rootopaque->btpo_cycleid = 0;
    0.00 :	  4aae0c:       66 c7 40 0e 00 00       movw   $0x0,0xe(%rax)
         :
         :	                /* NO ELOG(ERROR) till meta is updated */
         :	                START_CRIT_SECTION();
    0.00 :	  4aae12:       8b 05 84 f2 70 00       mov    0x70f284(%rip),%eax        # bba09c <CritSectionCount>
    0.00 :	  4aae18:       83 c0 01                add    $0x1,%eax
    0.00 :	  4aae1b:       89 05 7b f2 70 00       mov    %eax,0x70f27b(%rip)        # bba09c <CritSectionCount>
         :
         :	                metad->btm_root = rootblkno;
    0.00 :	  4aae21:       8b 45 88                mov    -0x78(%rbp),%eax
         :	                metad->btm_level = 0;
    0.00 :	  4aae24:       41 c7 47 0c 00 00 00    movl   $0x0,0xc(%r15)
    0.00 :	  4aae2b:       00 
         :	                metad->btm_fastroot = rootblkno;
         :	                metad->btm_fastlevel = 0;
    0.00 :	  4aae2c:       41 c7 47 14 00 00 00    movl   $0x0,0x14(%r15)
    0.00 :	  4aae33:       00 
         :	                rootopaque->btpo_cycleid = 0;
         :
         :	                /* NO ELOG(ERROR) till meta is updated */
         :	                START_CRIT_SECTION();
         :
         :	                metad->btm_root = rootblkno;
    0.00 :	  4aae34:       41 89 47 08             mov    %eax,0x8(%r15)
         :	                metad->btm_level = 0;
         :	                metad->btm_fastroot = rootblkno;
    0.00 :	  4aae38:       41 89 47 10             mov    %eax,0x10(%r15)
         :	                metad->btm_fastlevel = 0;
         :
         :	                MarkBufferDirty(rootbuf);
    0.00 :	  4aae3c:       44 89 45 80             mov    %r8d,-0x80(%rbp)
    0.00 :	  4aae40:       e8 ab 99 1c 00          callq  6747f0 <MarkBufferDirty>
         :	                MarkBufferDirty(metabuf);
    0.00 :	  4aae45:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae49:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aae4c:       e8 9f 99 1c 00          callq  6747f0 <MarkBufferDirty>
         :
         :	                /* XLOG stuff */
         :	                if (RelationNeedsWAL(rel))
    0.00 :	  4aae51:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  4aae55:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae59:       80 78 6e 70             cmpb   $0x70,0x6e(%rax)
    0.00 :	  4aae5d:       0f 84 0a 02 00 00       je     4ab06d <_bt_getroot+0x44d>
         :
         :	                        PageSetLSN(rootpage, recptr);
         :	                        PageSetLSN(metapg, recptr);
         :	                }
         :
         :	                END_CRIT_SECTION();
    0.00 :	  4aae63:       8b 05 33 f2 70 00       mov    0x70f233(%rip),%eax        # bba09c <CritSectionCount>
         :	                /*
         :	                 * swap root write lock for read lock.  There is no danger of anyone
         :	                 * else accessing the new root page while it's unlocked, since no one
         :	                 * else knows where it is yet.
         :	                 */
         :	                LockBuffer(rootbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aae69:       31 f6                   xor    %esi,%esi
    0.00 :	  4aae6b:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aae6e:       44 89 45 80             mov    %r8d,-0x80(%rbp)
         :
         :	                        PageSetLSN(rootpage, recptr);
         :	                        PageSetLSN(metapg, recptr);
         :	                }
         :
         :	                END_CRIT_SECTION();
    0.00 :	  4aae72:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4aae75:       89 05 21 f2 70 00       mov    %eax,0x70f221(%rip)        # bba09c <CritSectionCount>
         :	                /*
         :	                 * swap root write lock for read lock.  There is no danger of anyone
         :	                 * else accessing the new root page while it's unlocked, since no one
         :	                 * else knows where it is yet.
         :	                 */
         :	                LockBuffer(rootbuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4aae7b:       e8 90 98 1c 00          callq  674710 <LockBuffer>
         :	                LockBuffer(rootbuf, BT_READ);
    0.00 :	  4aae80:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4aae83:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4aae88:       e8 83 98 1c 00          callq  674710 <LockBuffer>
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aae8d:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aae91:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aae94:       e8 97 a0 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4aae99:       48 83 c4 58             add    $0x58,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:314
   16.67 :	  4aae9d:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4aaea0:       5b                      pop    %rbx
    0.00 :	  4aaea1:       41 5c                   pop    %r12
    0.00 :	  4aaea3:       41 5d                   pop    %r13
    0.00 :	  4aaea5:       41 5e                   pop    %r14
    0.00 :	  4aaea7:       41 5f                   pop    %r15
    0.00 :	  4aaea9:       c9                      leaveq 
    0.00 :	  4aaeaa:       c3                      retq   
    0.00 :	  4aaeab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        pfree(rel->rd_amcache);
         :	                rel->rd_amcache = NULL;
         :	        }
         :
         :	        metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_READ);
         :	        metapg = BufferGetPage(metabuf);
    0.00 :	  4aaeb0:       48 8b 15 61 22 6d 00    mov    0x6d2261(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aaeb7:       f7 d0                   not    %eax
    0.00 :	  4aaeb9:       48 98                   cltq   
    0.00 :	  4aaebb:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
    0.00 :	  4aaebf:       e9 15 fe ff ff          jmpq   4aacd9 <_bt_getroot+0xb9>
    0.00 :	  4aaec4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                rootbuf = _bt_getbuf(rel, rootblkno, BT_READ);
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aaec8:       48 8b 15 49 22 6d 00    mov    0x6d2249(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aaecf:       f7 d0                   not    %eax
    0.00 :	  4aaed1:       48 98                   cltq   
    0.00 :	  4aaed3:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4aaed7:       e9 95 fd ff ff          jmpq   4aac71 <_bt_getroot+0x51>
    0.00 :	  4aaedc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                 * here than normal.  We *must* check that it's not deleted. If it's
         :	                 * not alone on its level, then we reject too --- this may be overly
         :	                 * paranoid but better safe than sorry.  Note we don't check P_ISROOT,
         :	                 * because that's not set in a "fast root".
         :	                 */
         :	                if (!P_IGNORE(rootopaque) &&
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:141
   16.67 :	  4aaee0:       8b 1a                   mov    (%rdx),%ebx
   16.67 :	  4aaee2:       85 db                   test   %ebx,%ebx
    0.00 :	  4aaee4:       0f 85 9f fd ff ff       jne    4aac89 <_bt_getroot+0x69>
    0.00 :	  4aaeea:       44 8b 5a 04             mov    0x4(%rdx),%r11d
    0.00 :	  4aaeee:       45 85 db                test   %r11d,%r11d
    0.00 :	  4aaef1:       0f 85 92 fd ff ff       jne    4aac89 <_bt_getroot+0x69>
    0.00 :	  4aaef7:       eb a0                   jmp    4aae99 <_bt_getroot+0x279>
    0.00 :	  4aaef9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4aaf00:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4aaf03:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  4aaf06:       e8 25 a0 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4aaf0b:       eb 8c                   jmp    4aae99 <_bt_getroot+0x279>
    0.00 :	  4aaf0d:       0f 1f 00                nopl   (%rax)
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aaf10:       41 8b 47 14             mov    0x14(%r15),%eax
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf14:       49 8b be b8 00 00 00    mov    0xb8(%r14),%rdi
    0.00 :	  4aaf1b:       be 18 00 00 00          mov    $0x18,%esi
         :	                /* okay, metadata is correct, release lock on it */
         :	                _bt_relbuf(rel, metabuf);
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
    0.00 :	  4aaf20:       45 8b 6f 10             mov    0x10(%r15),%r13d
         :	                rootlevel = metad->btm_fastlevel;
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf24:       44 89 45 80             mov    %r8d,-0x80(%rbp)
         :	        }
         :	        else
         :	        {
         :	                rootblkno = metad->btm_fastroot;
         :	                Assert(rootblkno != P_NONE);
         :	                rootlevel = metad->btm_fastlevel;
    0.00 :	  4aaf28:       89 45 8c                mov    %eax,-0x74(%rbp)
         :
         :	                /*
         :	                 * Cache the metapage data for next time
         :	                 */
         :	                rel->rd_amcache = MemoryContextAlloc(rel->rd_indexcxt,
    0.00 :	  4aaf2b:       e8 60 df 2e 00          callq  798e90 <MemoryContextAlloc>
    0.00 :	  4aaf30:       49 89 86 18 01 00 00    mov    %rax,0x118(%r14)
         :	                                                                                         sizeof(BTMetaPageData));
         :	                memcpy(rel->rd_amcache, metad, sizeof(BTMetaPageData));
    0.00 :	  4aaf37:       49 8b 17                mov    (%r15),%rdx
    0.00 :	  4aaf3a:       48 89 10                mov    %rdx,(%rax)
    0.00 :	  4aaf3d:       49 8b 57 08             mov    0x8(%r15),%rdx
    0.00 :	  4aaf41:       48 89 50 08             mov    %rdx,0x8(%rax)
    0.00 :	  4aaf45:       49 8b 57 10             mov    0x10(%r15),%rdx
    0.00 :	  4aaf49:       48 89 50 10             mov    %rdx,0x10(%rax)
    0.00 :	  4aaf4d:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4aaf51:       45 89 c4                mov    %r8d,%r12d
    0.00 :	  4aaf54:       eb 3a                   jmp    4aaf90 <_bt_getroot+0x370>
    0.00 :	  4aaf56:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4aaf5d:       00 00 00 
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aaf60:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4aaf65:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4aaf68:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4aaf6c:       48 03 15 85 4b 71 00    add    0x714b85(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                        rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);
    0.00 :	  4aaf73:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4aaf77:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
         :
         :	                        if (!P_IGNORE(rootopaque))
    0.00 :	  4aaf7b:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
    0.00 :	  4aaf7f:       a8 14                   test   $0x14,%al
    0.00 :	  4aaf81:       74 3d                   je     4aafc0 <_bt_getroot+0x3a0>
         :	                                break;
         :
         :	                        /* it's dead, Jim.  step right one page */
         :	                        if (P_RIGHTMOST(rootopaque))
    0.00 :	  4aaf83:       44 8b 6b 04             mov    0x4(%rbx),%r13d
    0.00 :	  4aaf87:       45 85 ed                test   %r13d,%r13d
    0.00 :	  4aaf8a:       0f 84 af 00 00 00       je     4ab03f <_bt_getroot+0x41f>
         :	                 */
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
    0.00 :	  4aaf90:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4aaf93:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4aaf98:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4aaf9b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aaf9e:       e8 3d e0 ff ff          callq  4a8fe0 <_bt_relandgetbuf>
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aafa3:       85 c0                   test   %eax,%eax
         :	                 */
         :	                rootbuf = metabuf;
         :
         :	                for (;;)
         :	                {
         :	                        rootbuf = _bt_relandgetbuf(rel, rootbuf, rootblkno, BT_READ);
    0.00 :	  4aafa5:       41 89 c4                mov    %eax,%r12d
         :	                        rootpage = BufferGetPage(rootbuf);
    0.00 :	  4aafa8:       79 b6                   jns    4aaf60 <_bt_getroot+0x340>
    0.00 :	  4aafaa:       48 8b 15 67 21 6d 00    mov    0x6d2167(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aafb1:       f7 d0                   not    %eax
    0.00 :	  4aafb3:       48 98                   cltq   
    0.00 :	  4aafb5:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4aafb9:       eb b8                   jmp    4aaf73 <_bt_getroot+0x353>
    0.00 :	  4aafbb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                         RelationGetRelationName(rel));
         :	                        rootblkno = rootopaque->btpo_next;
         :	                }
         :
         :	                /* Note: can't check btpo.level on deleted pages */
         :	                if (rootopaque->btpo.level != rootlevel)
    0.00 :	  4aafc0:       8b 45 8c                mov    -0x74(%rbp),%eax
    0.00 :	  4aafc3:       39 43 08                cmp    %eax,0x8(%rbx)
    0.00 :	  4aafc6:       0f 84 cd fe ff ff       je     4aae99 <_bt_getroot+0x279>
         :	                        elog(ERROR, "root page %u of index \"%s\" has level %u, expected %u",
    0.00 :	  4aafcc:       ba 50 47 7b 00          mov    $0x7b4750,%edx
    0.00 :	  4aafd1:       be 32 01 00 00          mov    $0x132,%esi
    0.00 :	  4aafd6:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4aafdb:       e8 40 04 2d 00          callq  77b420 <elog_start>
    0.00 :	  4aafe0:       49 8b 4e 30             mov    0x30(%r14),%rcx
    0.00 :	  4aafe4:       44 8b 4d 8c             mov    -0x74(%rbp),%r9d
    0.00 :	  4aafe8:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4aafeb:       44 8b 43 08             mov    0x8(%rbx),%r8d
    0.00 :	  4aafef:       be 58 46 7b 00          mov    $0x7b4658,%esi
    0.00 :	  4aaff4:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4aaff9:       31 c0                   xor    %eax,%eax
    0.00 :	  4aaffb:       e8 30 02 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4ab000:       e9 0c fd ff ff          jmpq   4aad11 <_bt_getroot+0xf1>
    0.00 :	  4ab005:       0f 1f 00                nopl   (%rax)
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4ab008:       44 89 c7                mov    %r8d,%edi
    0.00 :	  4ab00b:       e8 20 9f 1c 00          callq  674f30 <UnlockReleaseBuffer>
         :	                         * deadlocks, we have to release the metadata page and start all
         :	                         * over again.  (Is that really true? But it's hardly worth trying
         :	                         * to optimize this case.)
         :	                         */
         :	                        _bt_relbuf(rel, metabuf);
         :	                        return _bt_getroot(rel, access);
    0.00 :	  4ab010:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4ab013:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4ab016:       e8 05 fc ff ff          callq  4aac20 <_bt_getroot>
    0.00 :	  4ab01b:       41 89 c4                mov    %eax,%r12d
         :	        /*
         :	         * By here, we have a pin and read lock on the root page, and no lock set
         :	         * on the metadata page.  Return the root page's buffer.
         :	         */
         :	        return rootbuf;
         :	}
    0.00 :	  4ab01e:       e9 76 fe ff ff          jmpq   4aae99 <_bt_getroot+0x279>
    0.00 :	  4ab023:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * the new root page.  Since this is the first page in the tree, it's
         :	                 * a leaf as well as the root.
         :	                 */
         :	                rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);
         :	                rootblkno = BufferGetBlockNumber(rootbuf);
         :	                rootpage = BufferGetPage(rootbuf);
    0.00 :	  4ab028:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4ab02b:       48 8b 15 e6 20 6d 00    mov    0x6d20e6(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ab032:       f7 d0                   not    %eax
    0.00 :	  4ab034:       48 98                   cltq   
    0.00 :	  4ab036:       4c 8b 2c c2             mov    (%rdx,%rax,8),%r13
    0.00 :	  4ab03a:       e9 a6 fd ff ff          jmpq   4aade5 <_bt_getroot+0x1c5>
         :	                        if (!P_IGNORE(rootopaque))
         :	                                break;
         :
         :	                        /* it's dead, Jim.  step right one page */
         :	                        if (P_RIGHTMOST(rootopaque))
         :	                                elog(ERROR, "no live root page found in index \"%s\"",
    0.00 :	  4ab03f:       ba 50 47 7b 00          mov    $0x7b4750,%edx
    0.00 :	  4ab044:       be 2a 01 00 00          mov    $0x12a,%esi
    0.00 :	  4ab049:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4ab04e:       e8 cd 03 2d 00          callq  77b420 <elog_start>
    0.00 :	  4ab053:       49 8b 56 30             mov    0x30(%r14),%rdx
    0.00 :	  4ab057:       be 30 46 7b 00          mov    $0x7b4630,%esi
    0.00 :	  4ab05c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ab061:       31 c0                   xor    %eax,%eax
    0.00 :	  4ab063:       e8 c8 01 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4ab068:       e8 63 e4 fb ff          callq  4694d0 <abort@plt>
         :	                {
         :	                        xl_btree_newroot xlrec;
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
    0.00 :	  4ab06d:       49 8b 06                mov    (%r14),%rax
         :	                        rdata.data = (char *) &xlrec;
         :	                        rdata.len = SizeOfBtreeNewroot;
         :	                        rdata.buffer = InvalidBuffer;
         :	                        rdata.next = NULL;
         :
         :	                        recptr = XLogInsert(RM_BTREE_ID, XLOG_BTREE_NEWROOT, &rdata);
    0.00 :	  4ab070:       48 8d 55 90             lea    -0x70(%rbp),%rdx
    0.00 :	  4ab074:       be a0 00 00 00          mov    $0xa0,%esi
    0.00 :	  4ab079:       bf 0b 00 00 00          mov    $0xb,%edi
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
         :	                        xlrec.rootblk = rootblkno;
         :	                        xlrec.level = 0;
    0.00 :	  4ab07e:       c7 45 c0 00 00 00 00    movl   $0x0,-0x40(%rbp)
         :
         :	                        rdata.data = (char *) &xlrec;
         :	                        rdata.len = SizeOfBtreeNewroot;
    0.00 :	  4ab085:       c7 45 98 14 00 00 00    movl   $0x14,-0x68(%rbp)
         :	                        rdata.buffer = InvalidBuffer;
    0.00 :	  4ab08c:       c7 45 9c 00 00 00 00    movl   $0x0,-0x64(%rbp)
         :	                        rdata.next = NULL;
    0.00 :	  4ab093:       48 c7 45 a8 00 00 00    movq   $0x0,-0x58(%rbp)
    0.00 :	  4ab09a:       00 
         :	                {
         :	                        xl_btree_newroot xlrec;
         :	                        XLogRecPtr      recptr;
         :	                        XLogRecData rdata;
         :
         :	                        xlrec.node = rel->rd_node;
    0.00 :	  4ab09b:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	  4ab09f:       41 8b 46 08             mov    0x8(%r14),%eax
    0.00 :	  4ab0a3:       89 45 b8                mov    %eax,-0x48(%rbp)
         :	                        xlrec.rootblk = rootblkno;
    0.00 :	  4ab0a6:       8b 45 88                mov    -0x78(%rbp),%eax
    0.00 :	  4ab0a9:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	                        xlrec.level = 0;
         :
         :	                        rdata.data = (char *) &xlrec;
    0.00 :	  4ab0ac:       48 8d 45 b0             lea    -0x50(%rbp),%rax
    0.00 :	  4ab0b0:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	                        rdata.len = SizeOfBtreeNewroot;
         :	                        rdata.buffer = InvalidBuffer;
         :	                        rdata.next = NULL;
         :
         :	                        recptr = XLogInsert(RM_BTREE_ID, XLOG_BTREE_NEWROOT, &rdata);
    0.00 :	  4ab0b4:       e8 67 9e 02 00          callq  4d4f20 <XLogInsert>
         :
         :	                        PageSetLSN(rootpage, recptr);
    0.00 :	  4ab0b9:       48 89 c2                mov    %rax,%rdx
    0.00 :	  4ab0bc:       41 89 45 04             mov    %eax,0x4(%r13)
    0.00 :	  4ab0c0:       48 c1 ea 20             shr    $0x20,%rdx
    0.00 :	  4ab0c4:       41 89 55 00             mov    %edx,0x0(%r13)
         :	                        PageSetLSN(metapg, recptr);
    0.00 :	  4ab0c8:       89 13                   mov    %edx,(%rbx)
    0.00 :	  4ab0ca:       89 43 04                mov    %eax,0x4(%rbx)
    0.00 :	  4ab0cd:       44 8b 45 80             mov    -0x80(%rbp),%r8d
    0.00 :	  4ab0d1:       e9 8d fd ff ff          jmpq   4aae63 <_bt_getroot+0x243>
         :	                                (errcode(ERRCODE_INDEX_CORRUPTED),
         :	                                 errmsg("index \"%s\" is not a btree",
         :	                                                RelationGetRelationName(rel))));
         :
         :	        if (metad->btm_version != BTREE_VERSION)
         :	                ereport(ERROR,
    0.00 :	  4ab0d6:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  4ab0d9:       b9 50 47 7b 00          mov    $0x7b4750,%ecx
    0.00 :	  4ab0de:       ba ae 00 00 00          mov    $0xae,%edx
    0.00 :	  4ab0e3:       be 22 43 7b 00          mov    $0x7b4322,%esi
    0.00 :	  4ab0e8:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ab0ed:       e8 ce f9 2c 00          callq  77aac0 <errstart>
    0.00 :	  4ab0f2:       84 c0                   test   %al,%al
    0.00 :	  4ab0f4:       0f 84 17 fc ff ff       je     4aad11 <_bt_getroot+0xf1>
    0.00 :	  4ab0fa:       41 8b 57 04             mov    0x4(%r15),%edx
    0.00 :	  4ab0fe:       49 8b 76 30             mov    0x30(%r14),%rsi
    0.00 :	  4ab102:       b9 02 00 00 00          mov    $0x2,%ecx
    0.00 :	  4ab107:       bf e8 45 7b 00          mov    $0x7b45e8,%edi
    0.00 :	  4ab10c:       31 c0                   xor    %eax,%eax
    0.00 :	  4ab10e:       e8 8d 17 2d 00          callq  77c8a0 <errmsg>
    0.00 :	  4ab113:       e9 18 fc ff ff          jmpq   4aad30 <_bt_getroot+0x110>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1040
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1040
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1040
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1082
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1050
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1050
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004acb70 <_bt_next>:
         :	 *              On failure exit (no more tuples), we release pin and set
         :	 *              so->currPos.buf to InvalidBuffer.
         :	 */
         :	bool
         :	_bt_next(IndexScanDesc scan, ScanDirection dir)
         :	{
   16.67 :	  4acb70:       55                      push   %rbp
   16.67 :	  4acb71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4acb74:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
   16.67 :	  4acb78:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  4acb7c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  4acb7f:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  4acb83:       48 83 ec 20             sub    $0x20,%rsp
         :
         :	        /*
         :	         * Advance to next tuple on current page; or if there's no more, try to
         :	         * step to the next page with data.
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4acb87:       83 fe 01                cmp    $0x1,%esi
         :	 *              On failure exit (no more tuples), we release pin and set
         :	 *              so->currPos.buf to InvalidBuffer.
         :	 */
         :	bool
         :	_bt_next(IndexScanDesc scan, ScanDirection dir)
         :	{
    0.00 :	  4acb8a:       41 89 f5                mov    %esi,%r13d
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4acb8d:       48 8b 5f 38             mov    0x38(%rdi),%rbx
         :
         :	        /*
         :	         * Advance to next tuple on current page; or if there's no more, try to
         :	         * step to the next page with data.
         :	         */
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4acb91:       74 7d                   je     4acc10 <_bt_next+0xa0>
         :	                        LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);
         :	                }
         :	        }
         :	        else
         :	        {
         :	                if (--so->currPos.itemIndex < so->currPos.firstItem)
    0.00 :	  4acb93:       8b 43 6c                mov    0x6c(%rbx),%eax
    0.00 :	  4acb96:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4acb99:       3b 43 64                cmp    0x64(%rbx),%eax
    0.00 :	  4acb9c:       89 43 6c                mov    %eax,0x6c(%rbx)
    0.00 :	  4acb9f:       7c 4f                   jl     4acbf0 <_bt_next+0x80>
         :	                        LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);
         :	                }
         :	        }
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
    0.00 :	  4acba1:       48 98                   cltq   
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
    0.00 :	  4acba3:       41 80 7c 24 30 00       cmpb   $0x0,0x30(%r12)
         :	                }
         :	        }
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
    0.00 :	  4acba9:       48 8d 04 80             lea    (%rax,%rax,4),%rax
    0.00 :	  4acbad:       48 8d 54 43 60          lea    0x60(%rbx,%rax,2),%rdx
    0.00 :	  4acbb2:       8b 42 10                mov    0x10(%rdx),%eax
    0.00 :	  4acbb5:       41 89 44 24 54          mov    %eax,0x54(%r12)
    0.00 :	  4acbba:       0f b7 42 14             movzwl 0x14(%rdx),%eax
    0.00 :	  4acbbe:       66 41 89 44 24 58       mov    %ax,0x58(%r12)
         :	        if (scan->xs_want_itup)
    0.00 :	  4acbc4:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  4acbc9:       74 12                   je     4acbdd <_bt_next+0x6d>
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4acbcb:       0f b7 42 18             movzwl 0x18(%rdx),%eax
    0.00 :	  4acbcf:       48 03 43 40             add    0x40(%rbx),%rax
    0.00 :	  4acbd3:       49 89 44 24 40          mov    %rax,0x40(%r12)
    0.00 :	  4acbd8:       b8 01 00 00 00          mov    $0x1,%eax
         :
         :	        return true;
         :	}
    0.00 :	  4acbdd:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  4acbe1:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  4acbe5:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  4acbe9:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1082
   16.67 :	  4acbea:       c3                      retq   
    0.00 :	  4acbeb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                if (--so->currPos.itemIndex < so->currPos.firstItem)
         :	                {
         :	                        /* We must acquire lock before applying _bt_steppage */
         :	                        Assert(BufferIsValid(so->currPos.buf));
         :	                        LockBuffer(so->currPos.buf, BT_READ);
    0.00 :	  4acbf0:       8b 7b 54                mov    0x54(%rbx),%edi
    0.00 :	  4acbf3:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4acbf8:       e8 13 7b 1c 00          callq  674710 <LockBuffer>
         :	                        if (!_bt_steppage(scan, dir))
    0.00 :	  4acbfd:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4acc00:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4acc03:       e8 78 fa ff ff          callq  4ac680 <_bt_steppage>
    0.00 :	  4acc08:       84 c0                   test   %al,%al
    0.00 :	  4acc0a:       75 30                   jne    4acc3c <_bt_next+0xcc>
         :
         :	        /* OK, itemIndex says what to return */
         :	        currItem = &so->currPos.items[so->currPos.itemIndex];
         :	        scan->xs_ctup.t_self = currItem->heapTid;
         :	        if (scan->xs_want_itup)
         :	                scan->xs_itup = (IndexTuple) (so->currTuples + currItem->tupleOffset);
    0.00 :	  4acc0c:       31 c0                   xor    %eax,%eax
    0.00 :	  4acc0e:       eb cd                   jmp    4acbdd <_bt_next+0x6d>
         :	         * Advance to next tuple on current page; or if there's no more, try to
         :	         * step to the next page with data.
         :	         */
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                if (++so->currPos.itemIndex > so->currPos.lastItem)
    0.00 :	  4acc10:       8b 43 6c                mov    0x6c(%rbx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1050
   16.67 :	  4acc13:       83 c0 01                add    $0x1,%eax
    0.00 :	  4acc16:       3b 43 68                cmp    0x68(%rbx),%eax
   16.67 :	  4acc19:       89 43 6c                mov    %eax,0x6c(%rbx)
    0.00 :	  4acc1c:       7e 83                   jle    4acba1 <_bt_next+0x31>
         :	                {
         :	                        /* We must acquire lock before applying _bt_steppage */
         :	                        Assert(BufferIsValid(so->currPos.buf));
         :	                        LockBuffer(so->currPos.buf, BT_READ);
    0.00 :	  4acc1e:       8b 7b 54                mov    0x54(%rbx),%edi
    0.00 :	  4acc21:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4acc26:       e8 e5 7a 1c 00          callq  674710 <LockBuffer>
         :	                        if (!_bt_steppage(scan, dir))
    0.00 :	  4acc2b:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4acc30:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4acc33:       e8 48 fa ff ff          callq  4ac680 <_bt_steppage>
    0.00 :	  4acc38:       84 c0                   test   %al,%al
    0.00 :	  4acc3a:       74 d0                   je     4acc0c <_bt_next+0x9c>
         :	                        Assert(BufferIsValid(so->currPos.buf));
         :	                        LockBuffer(so->currPos.buf, BT_READ);
         :	                        if (!_bt_steppage(scan, dir))
         :	                                return false;
         :	                        /* Drop the lock, but not pin, on the new page */
         :	                        LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4acc3c:       8b 7b 54                mov    0x54(%rbx),%edi
    0.00 :	  4acc3f:       31 f6                   xor    %esi,%esi
    0.00 :	  4acc41:       e8 ca 7a 1c 00          callq  674710 <LockBuffer>
    0.00 :	  4acc46:       8b 43 6c                mov    0x6c(%rbx),%eax
    0.00 :	  4acc49:       e9 53 ff ff ff          jmpq   4acba1 <_bt_next+0x31>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:193
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:193
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:204
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:222
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:224
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:356
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004af350 <_bt_preprocess_array_keys>:
         :	 * on scan->keyData, is that callers are permitted to call btrescan without
         :	 * supplying a new set of scankey data.
         :	 */
         :	void
         :	_bt_preprocess_array_keys(IndexScanDesc scan)
         :	{
    0.00 :	  4af350:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:193
   16.67 :	  4af351:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4af354:       41 57                   push   %r15
   16.67 :	  4af356:       41 56                   push   %r14
    0.00 :	  4af358:       41 55                   push   %r13
    0.00 :	  4af35a:       41 54                   push   %r12
    0.00 :	  4af35c:       53                      push   %rbx
    0.00 :	  4af35d:       48 81 ec b8 00 00 00    sub    $0xb8,%rsp
    0.00 :	  4af364:       48 89 bd 38 ff ff ff    mov    %rdi,-0xc8(%rbp)
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4af36b:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  4af36f:       48 89 85 40 ff ff ff    mov    %rax,-0xc0(%rbp)
         :	        int                     numberOfKeys = scan->numberOfKeys;
    0.00 :	  4af376:       8b 57 18                mov    0x18(%rdi),%edx
    0.00 :	  4af379:       89 95 4c ff ff ff       mov    %edx,-0xb4(%rbp)
         :	        int16      *indoption = scan->indexRelation->rd_indoption;
    0.00 :	  4af37f:       48 8b 47 08             mov    0x8(%rdi),%rax
         :	        int                     i;
         :	        MemoryContext oldContext;
         :
         :	        /* Quick check to see if there are any array keys */
         :	        numArrayKeys = 0;
         :	        for (i = 0; i < numberOfKeys; i++)
    0.00 :	  4af383:       85 d2                   test   %edx,%edx
         :	void
         :	_bt_preprocess_array_keys(IndexScanDesc scan)
         :	{
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
         :	        int                     numberOfKeys = scan->numberOfKeys;
         :	        int16      *indoption = scan->indexRelation->rd_indoption;
    0.00 :	  4af385:       48 8b 80 e8 00 00 00    mov    0xe8(%rax),%rax
    0.00 :	  4af38c:       48 89 85 50 ff ff ff    mov    %rax,-0xb0(%rbp)
         :	        int                     i;
         :	        MemoryContext oldContext;
         :
         :	        /* Quick check to see if there are any array keys */
         :	        numArrayKeys = 0;
         :	        for (i = 0; i < numberOfKeys; i++)
    0.00 :	  4af393:       0f 8e 07 02 00 00       jle    4af5a0 <_bt_preprocess_array_keys+0x250>
    0.00 :	  4af399:       48 8b 77 20             mov    0x20(%rdi),%rsi
    0.00 :	  4af39d:       31 db                   xor    %ebx,%ebx
    0.00 :	  4af39f:       31 c9                   xor    %ecx,%ecx
    0.00 :	  4af3a1:       31 d2                   xor    %edx,%edx
    0.00 :	  4af3a3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                cur = &scan->keyData[i];
         :	                if (cur->sk_flags & SK_SEARCHARRAY)
    0.00 :	  4af3a8:       8b 04 16                mov    (%rsi,%rdx,1),%eax
    0.00 :	  4af3ab:       a8 20                   test   $0x20,%al
    0.00 :	  4af3ad:       74 0b                   je     4af3ba <_bt_preprocess_array_keys+0x6a>
         :	                {
         :	                        numArrayKeys++;
         :	                        Assert(!(cur->sk_flags & (SK_ROW_HEADER | SK_SEARCHNULL | SK_SEARCHNOTNULL)));
         :	                        /* If any arrays are null as a whole, we can quit right now. */
         :	                        if (cur->sk_flags & SK_ISNULL)
    0.00 :	  4af3af:       a8 01                   test   $0x1,%al
    0.00 :	  4af3b1:       0f 85 d9 03 00 00       jne    4af790 <_bt_preprocess_array_keys+0x440>
         :	        for (i = 0; i < numberOfKeys; i++)
         :	        {
         :	                cur = &scan->keyData[i];
         :	                if (cur->sk_flags & SK_SEARCHARRAY)
         :	                {
         :	                        numArrayKeys++;
    0.00 :	  4af3b7:       83 c3 01                add    $0x1,%ebx
         :	        int                     i;
         :	        MemoryContext oldContext;
         :
         :	        /* Quick check to see if there are any array keys */
         :	        numArrayKeys = 0;
         :	        for (i = 0; i < numberOfKeys; i++)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:204
   16.67 :	  4af3ba:       83 c1 01                add    $0x1,%ecx
    0.00 :	  4af3bd:       48 83 c2 48             add    $0x48,%rdx
    0.00 :	  4af3c1:       39 8d 4c ff ff ff       cmp    %ecx,-0xb4(%rbp)
    0.00 :	  4af3c7:       7f df                   jg     4af3a8 <_bt_preprocess_array_keys+0x58>
         :	                        }
         :	                }
         :	        }
         :
         :	        /* Quit if nothing to do. */
         :	        if (numArrayKeys == 0)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:222
   16.67 :	  4af3c9:       85 db                   test   %ebx,%ebx
    0.00 :	  4af3cb:       0f 84 cf 01 00 00       je     4af5a0 <_bt_preprocess_array_keys+0x250>
         :
         :	        /*
         :	         * Make a scan-lifespan context to hold array-associated data, or reset it
         :	         * if we already have one from a previous rescan cycle.
         :	         */
         :	        if (so->arrayContext == NULL)
    0.00 :	  4af3d1:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	  4af3d8:       48 8b 7a 28             mov    0x28(%rdx),%rdi
    0.00 :	  4af3dc:       48 85 ff                test   %rdi,%rdi
    0.00 :	  4af3df:       0f 84 0b 04 00 00       je     4af7f0 <_bt_preprocess_array_keys+0x4a0>
         :	                                                                                                 "BTree Array Context",
         :	                                                                                                 ALLOCSET_SMALL_MINSIZE,
         :	                                                                                                 ALLOCSET_SMALL_INITSIZE,
         :	                                                                                                 ALLOCSET_SMALL_MAXSIZE);
         :	        else
         :	                MemoryContextReset(so->arrayContext);
    0.00 :	  4af3e5:       e8 c6 95 2e 00          callq  7989b0 <MemoryContextReset>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  4af3ea:       48 8b 05 6f b4 70 00    mov    0x70b46f(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  4af3f1:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  4af3f8:       48 89 85 58 ff ff ff    mov    %rax,-0xa8(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  4af3ff:       48 8b 42 28             mov    0x28(%rdx),%rax
    0.00 :	  4af403:       48 89 05 56 b4 70 00    mov    %rax,0x70b456(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	        oldContext = MemoryContextSwitchTo(so->arrayContext);
         :
         :	        /* Create modifiable copy of scan->keyData in the workspace context */
         :	        so->arrayKeyData = (ScanKey) palloc(scan->numberOfKeys * sizeof(ScanKeyData));
    0.00 :	  4af40a:       48 8b 85 38 ff ff ff    mov    -0xc8(%rbp),%rax
    0.00 :	  4af411:       48 63 78 18             movslq 0x18(%rax),%rdi
    0.00 :	  4af415:       48 8d 3c ff             lea    (%rdi,%rdi,8),%rdi
    0.00 :	  4af419:       48 c1 e7 03             shl    $0x3,%rdi
    0.00 :	  4af41d:       e8 2e 99 2e 00          callq  798d50 <palloc>
    0.00 :	  4af422:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	  4af429:       48 89 c7                mov    %rax,%rdi
    0.00 :	  4af42c:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	        memcpy(so->arrayKeyData,
    0.00 :	  4af430:       48 8b 85 38 ff ff ff    mov    -0xc8(%rbp),%rax
    0.00 :	  4af437:       48 63 50 18             movslq 0x18(%rax),%rdx
    0.00 :	  4af43b:       48 8b 70 20             mov    0x20(%rax),%rsi
    0.00 :	  4af43f:       48 8d 14 d2             lea    (%rdx,%rdx,8),%rdx
    0.00 :	  4af443:       48 c1 e2 03             shl    $0x3,%rdx
    0.00 :	  4af447:       e8 a4 a7 fb ff          callq  469bf0 <memcpy@plt>
         :	                   scan->keyData,
         :	                   scan->numberOfKeys * sizeof(ScanKeyData));
         :
         :	        /* Allocate space for per-array data in the workspace context */
         :	        so->arrayKeys = (BTArrayKeyInfo *) palloc0(numArrayKeys * sizeof(BTArrayKeyInfo));
    0.00 :	  4af44c:       48 63 fb                movslq %ebx,%rdi
    0.00 :	  4af44f:       48 8d 3c 7f             lea    (%rdi,%rdi,2),%rdi
    0.00 :	  4af453:       48 c1 e7 03             shl    $0x3,%rdi
    0.00 :	  4af457:       e8 14 9b 2e 00          callq  798f70 <palloc0>
    0.00 :	  4af45c:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	  4af463:       48 89 42 20             mov    %rax,0x20(%rdx)
    0.00 :	  4af467:       c7 85 6c ff ff ff 00    movl   $0x0,-0x94(%rbp)
    0.00 :	  4af46e:       00 00 00 
    0.00 :	  4af471:       c7 85 7c ff ff ff 00    movl   $0x0,-0x84(%rbp)
    0.00 :	  4af478:       00 00 00 
    0.00 :	  4af47b:       48 c7 85 60 ff ff ff    movq   $0x0,-0xa0(%rbp)
    0.00 :	  4af482:       00 00 00 00 
    0.00 :	  4af486:       eb 29                   jmp    4af4b1 <_bt_preprocess_array_keys+0x161>
    0.00 :	  4af488:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4af48f:       00 
         :
         :	        /* Now process each array key */
         :	        numArrayKeys = 0;
         :	        for (i = 0; i < numberOfKeys; i++)
    0.00 :	  4af490:       83 85 7c ff ff ff 01    addl   $0x1,-0x84(%rbp)
    0.00 :	  4af497:       48 83 85 60 ff ff ff    addq   $0x48,-0xa0(%rbp)
    0.00 :	  4af49e:       48 
    0.00 :	  4af49f:       8b 85 7c ff ff ff       mov    -0x84(%rbp),%eax
    0.00 :	  4af4a5:       39 85 4c ff ff ff       cmp    %eax,-0xb4(%rbp)
    0.00 :	  4af4ab:       0f 8e 04 03 00 00       jle    4af7b5 <_bt_preprocess_array_keys+0x465>
         :	                Datum      *elem_values;
         :	                bool       *elem_nulls;
         :	                int                     num_nonnulls;
         :	                int                     j;
         :
         :	                cur = &so->arrayKeyData[i];
    0.00 :	  4af4b1:       48 8b 9d 40 ff ff ff    mov    -0xc0(%rbp),%rbx
    0.00 :	  4af4b8:       4c 8b a5 60 ff ff ff    mov    -0xa0(%rbp),%r12
    0.00 :	  4af4bf:       4c 03 63 10             add    0x10(%rbx),%r12
         :	                if (!(cur->sk_flags & SK_SEARCHARRAY))
    0.00 :	  4af4c3:       41 f6 04 24 20          testb  $0x20,(%r12)
    0.00 :	  4af4c8:       74 c6                   je     4af490 <_bt_preprocess_array_keys+0x140>
         :	                /*
         :	                 * First, deconstruct the array into elements.  Anything allocated
         :	                 * here (including a possibly detoasted array value) is in the
         :	                 * workspace context.
         :	                 */
         :	                arrayval = DatumGetArrayTypeP(cur->sk_argument);
    0.00 :	  4af4ca:       49 8b 7c 24 40          mov    0x40(%r12),%rdi
    0.00 :	  4af4cf:       e8 3c f8 2c 00          callq  77ed10 <pg_detoast_datum>
         :	                /* We could cache this data, but not clear it's worth it */
         :	                get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
    0.00 :	  4af4d4:       8b 78 0c                mov    0xc(%rax),%edi
    0.00 :	  4af4d7:       48 8d 4d ce             lea    -0x32(%rbp),%rcx
    0.00 :	  4af4db:       48 8d 55 cf             lea    -0x31(%rbp),%rdx
    0.00 :	  4af4df:       48 8d 75 cc             lea    -0x34(%rbp),%rsi
         :	                /*
         :	                 * First, deconstruct the array into elements.  Anything allocated
         :	                 * here (including a possibly detoasted array value) is in the
         :	                 * workspace context.
         :	                 */
         :	                arrayval = DatumGetArrayTypeP(cur->sk_argument);
    0.00 :	  4af4e3:       48 89 c3                mov    %rax,%rbx
         :	                /* We could cache this data, but not clear it's worth it */
         :	                get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
    0.00 :	  4af4e6:       e8 85 39 2c 00          callq  772e70 <get_typlenbyvalalign>
         :	                                                         &elmlen, &elmbyval, &elmalign);
         :	                deconstruct_array(arrayval,
    0.00 :	  4af4eb:       48 8d 45 c8             lea    -0x38(%rbp),%rax
    0.00 :	  4af4ef:       44 0f be 45 ce          movsbl -0x32(%rbp),%r8d
    0.00 :	  4af4f4:       0f be 4d cf             movsbl -0x31(%rbp),%ecx
    0.00 :	  4af4f8:       0f bf 55 cc             movswl -0x34(%rbp),%edx
    0.00 :	  4af4fc:       8b 73 0c                mov    0xc(%rbx),%esi
    0.00 :	  4af4ff:       4c 8d 4d c0             lea    -0x40(%rbp),%r9
    0.00 :	  4af503:       48 89 44 24 08          mov    %rax,0x8(%rsp)
    0.00 :	  4af508:       48 8d 45 b8             lea    -0x48(%rbp),%rax
    0.00 :	  4af50c:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4af50f:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  4af513:       e8 48 97 20 00          callq  6b8c60 <deconstruct_array>
         :	                /*
         :	                 * Compress out any null elements.  We can ignore them since we assume
         :	                 * all btree operators are strict.
         :	                 */
         :	                num_nonnulls = 0;
         :	                for (j = 0; j < num_elems; j++)
    0.00 :	  4af518:       8b 7d c8                mov    -0x38(%rbp),%edi
    0.00 :	  4af51b:       85 ff                   test   %edi,%edi
    0.00 :	  4af51d:       0f 8e 88 02 00 00       jle    4af7ab <_bt_preprocess_array_keys+0x45b>
    0.00 :	  4af523:       31 db                   xor    %ebx,%ebx
    0.00 :	  4af525:       31 f6                   xor    %esi,%esi
    0.00 :	  4af527:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4af52e:       00 00 
         :	                {
         :	                        if (!elem_nulls[j])
    0.00 :	  4af530:       48 8b 45 b8             mov    -0x48(%rbp),%rax
    0.00 :	  4af534:       48 63 d6                movslq %esi,%rdx
    0.00 :	  4af537:       80 3c 10 00             cmpb   $0x0,(%rax,%rdx,1)
    0.00 :	  4af53b:       75 12                   jne    4af54f <_bt_preprocess_array_keys+0x1ff>
         :	                                elem_values[num_nonnulls++] = elem_values[j];
    0.00 :	  4af53d:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  4af541:       48 63 cb                movslq %ebx,%rcx
    0.00 :	  4af544:       83 c3 01                add    $0x1,%ebx
    0.00 :	  4af547:       48 8b 14 d0             mov    (%rax,%rdx,8),%rdx
    0.00 :	  4af54b:       48 89 14 c8             mov    %rdx,(%rax,%rcx,8)
         :	                /*
         :	                 * Compress out any null elements.  We can ignore them since we assume
         :	                 * all btree operators are strict.
         :	                 */
         :	                num_nonnulls = 0;
         :	                for (j = 0; j < num_elems; j++)
    0.00 :	  4af54f:       83 c6 01                add    $0x1,%esi
    0.00 :	  4af552:       39 75 c8                cmp    %esi,-0x38(%rbp)
    0.00 :	  4af555:       7f d9                   jg     4af530 <_bt_preprocess_array_keys+0x1e0>
         :	                }
         :
         :	                /* We could pfree(elem_nulls) now, but not worth the cycles */
         :
         :	                /* If there's no non-nulls, the scan qual is unsatisfiable */
         :	                if (num_nonnulls == 0)
    0.00 :	  4af557:       85 db                   test   %ebx,%ebx
    0.00 :	  4af559:       0f 84 4c 02 00 00       je     4af7ab <_bt_preprocess_array_keys+0x45b>
         :	                /*
         :	                 * If the comparison operator is not equality, then the array qual
         :	                 * degenerates to a simple comparison against the smallest or largest
         :	                 * non-null array element, as appropriate.
         :	                 */
         :	                switch (cur->sk_strategy)
    0.00 :	  4af55f:       66 41 83 7c 24 06 05    cmpw   $0x5,0x6(%r12)
    0.00 :	  4af566:       76 68                   jbe    4af5d0 <_bt_preprocess_array_keys+0x280>
         :	                                        _bt_find_extreme_element(scan, cur,
         :	                                                                                         BTLessStrategyNumber,
         :	                                                                                         elem_values, num_nonnulls);
         :	                                continue;
         :	                        default:
         :	                                elog(ERROR, "unrecognized StrategyNumber: %d",
    0.00 :	  4af568:       ba a0 4b 7b 00          mov    $0x7b4ba0,%edx
    0.00 :	  4af56d:       be 4b 01 00 00          mov    $0x14b,%esi
    0.00 :	  4af572:       bf 17 49 7b 00          mov    $0x7b4917,%edi
    0.00 :	  4af577:       e8 a4 be 2c 00          callq  77b420 <elog_start>
    0.00 :	  4af57c:       41 0f b7 54 24 06       movzwl 0x6(%r12),%edx
    0.00 :	  4af582:       be 78 49 7b 00          mov    $0x7b4978,%esi
    0.00 :	  4af587:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4af58c:       31 c0                   xor    %eax,%eax
    0.00 :	  4af58e:       e8 9d bc 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4af593:       e8 38 9f fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4af598:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4af59f:       00 
         :	        }
         :
         :	        /* Quit if nothing to do. */
         :	        if (numArrayKeys == 0)
         :	        {
         :	                so->numArrayKeys = 0;
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:224
   16.67 :	  4af5a0:       48 8b 85 40 ff ff ff    mov    -0xc0(%rbp),%rax
    0.00 :	  4af5a7:       c7 40 18 00 00 00 00    movl   $0x0,0x18(%rax)
         :	                so->arrayKeyData = NULL;
    0.00 :	  4af5ae:       48 c7 40 10 00 00 00    movq   $0x0,0x10(%rax)
    0.00 :	  4af5b5:       00 
         :	        }
         :
         :	        so->numArrayKeys = numArrayKeys;
         :
         :	        MemoryContextSwitchTo(oldContext);
         :	}
    0.00 :	  4af5b6:       48 81 c4 b8 00 00 00    add    $0xb8,%rsp
    0.00 :	  4af5bd:       5b                      pop    %rbx
    0.00 :	  4af5be:       41 5c                   pop    %r12
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:356
   16.67 :	  4af5c0:       41 5d                   pop    %r13
    0.00 :	  4af5c2:       41 5e                   pop    %r14
    0.00 :	  4af5c4:       41 5f                   pop    %r15
    0.00 :	  4af5c6:       c9                      leaveq 
    0.00 :	  4af5c7:       c3                      retq   
    0.00 :	  4af5c8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  4af5cf:       00 
         :	                /*
         :	                 * If the comparison operator is not equality, then the array qual
         :	                 * degenerates to a simple comparison against the smallest or largest
         :	                 * non-null array element, as appropriate.
         :	                 */
         :	                switch (cur->sk_strategy)
    0.00 :	  4af5d0:       41 0f b7 44 24 06       movzwl 0x6(%r12),%eax
    0.00 :	  4af5d6:       ff 24 c5 d0 4a 7b 00    jmpq   *0x7b4ad0(,%rax,8)
         :	                        case BTEqualStrategyNumber:
         :	                                /* proceed with rest of loop */
         :	                                break;
         :	                        case BTGreaterEqualStrategyNumber:
         :	                        case BTGreaterStrategyNumber:
         :	                                cur->sk_argument =
    0.00 :	  4af5dd:       48 8b 4d c0             mov    -0x40(%rbp),%rcx
    0.00 :	  4af5e1:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  4af5e8:       41 89 d8                mov    %ebx,%r8d
    0.00 :	  4af5eb:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4af5f0:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  4af5f3:       e8 e8 fb ff ff          callq  4af1e0 <_bt_find_extreme_element>
    0.00 :	  4af5f8:       49 89 44 24 40          mov    %rax,0x40(%r12)
         :	                                        _bt_find_extreme_element(scan, cur,
         :	                                                                                         BTLessStrategyNumber,
         :	                                                                                         elem_values, num_nonnulls);
         :	                                continue;
    0.00 :	  4af5fd:       e9 8e fe ff ff          jmpq   4af490 <_bt_preprocess_array_keys+0x140>
         :	                /*
         :	                 * Sort the non-null elements and eliminate any duplicates.  We must
         :	                 * sort in the same ordering used by the index column, so that the
         :	                 * successive primitive indexscans produce data in index order.
         :	                 */
         :	                num_elems = _bt_sort_array_elements(scan, cur,
    0.00 :	  4af602:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
         :	        RegProcedure cmp_proc;
         :	        BTSortArrayContext cxt;
         :	        int                     last_non_dup;
         :	        int                     i;
         :
         :	        if (nelems <= 1)
    0.00 :	  4af606:       83 fb 01                cmp    $0x1,%ebx
         :	                /*
         :	                 * Sort the non-null elements and eliminate any duplicates.  We must
         :	                 * sort in the same ordering used by the index column, so that the
         :	                 * successive primitive indexscans produce data in index order.
         :	                 */
         :	                num_elems = _bt_sort_array_elements(scan, cur,
    0.00 :	  4af609:       48 89 95 70 ff ff ff    mov    %rdx,-0x90(%rbp)
    0.00 :	  4af610:       49 0f bf 44 24 04       movswq 0x4(%r12),%rax
         :	static int
         :	_bt_sort_array_elements(IndexScanDesc scan, ScanKey skey,
         :	                                                bool reverse,
         :	                                                Datum *elems, int nelems)
         :	{
         :	        Relation        rel = scan->indexRelation;
    0.00 :	  4af616:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
         :	                /*
         :	                 * Sort the non-null elements and eliminate any duplicates.  We must
         :	                 * sort in the same ordering used by the index column, so that the
         :	                 * successive primitive indexscans produce data in index order.
         :	                 */
         :	                num_elems = _bt_sort_array_elements(scan, cur,
    0.00 :	  4af61d:       48 8d 78 ff             lea    -0x1(%rax),%rdi
    0.00 :	  4af621:       48 8b 85 50 ff ff ff    mov    -0xb0(%rbp),%rax
         :	static int
         :	_bt_sort_array_elements(IndexScanDesc scan, ScanKey skey,
         :	                                                bool reverse,
         :	                                                Datum *elems, int nelems)
         :	{
         :	        Relation        rel = scan->indexRelation;
    0.00 :	  4af628:       4c 8b 72 08             mov    0x8(%rdx),%r14
         :	                /*
         :	                 * Sort the non-null elements and eliminate any duplicates.  We must
         :	                 * sort in the same ordering used by the index column, so that the
         :	                 * successive primitive indexscans produce data in index order.
         :	                 */
         :	                num_elems = _bt_sort_array_elements(scan, cur,
    0.00 :	  4af62c:       44 0f b7 3c 78          movzwl (%rax,%rdi,2),%r15d
         :	        RegProcedure cmp_proc;
         :	        BTSortArrayContext cxt;
         :	        int                     last_non_dup;
         :	        int                     i;
         :
         :	        if (nelems <= 1)
    0.00 :	  4af631:       0f 8e d1 00 00 00       jle    4af708 <_bt_preprocess_array_keys+0x3b8>
         :	        /*
         :	         * Determine the nominal datatype of the array elements.  We have to
         :	         * support the convention that sk_subtype == InvalidOid means the opclass
         :	         * input type; this is a hack to simplify life for ScanKeyInit().
         :	         */
         :	        elemtype = skey->sk_subtype;
    0.00 :	  4af637:       45 8b 6c 24 08          mov    0x8(%r12),%r13d
         :	        if (elemtype == InvalidOid)
    0.00 :	  4af63c:       45 85 ed                test   %r13d,%r13d
    0.00 :	  4af63f:       0f 84 93 01 00 00       je     4af7d8 <_bt_preprocess_array_keys+0x488>
    0.00 :	  4af645:       4c 8d 0c bd 00 00 00    lea    0x0(,%rdi,4),%r9
    0.00 :	  4af64c:       00 
         :	         * Note: it's possible that this would fail, if the opfamily is
         :	         * incomplete, but it seems quite unlikely that an opfamily would omit
         :	         * non-cross-type support functions for any datatype that it supports at
         :	         * all.
         :	         */
         :	        cmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],
    0.00 :	  4af64d:       49 8b 86 c8 00 00 00    mov    0xc8(%r14),%rax
    0.00 :	  4af654:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4af659:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4af65c:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4af65f:       42 8b 3c 08             mov    (%rax,%r9,1),%edi
    0.00 :	  4af663:       e8 48 32 2c 00          callq  7728b0 <get_opfamily_proc>
         :	                                                                 elemtype,
         :	                                                                 elemtype,
         :	                                                                 BTORDER_PROC);
         :	        if (!RegProcedureIsValid(cmp_proc))
    0.00 :	  4af668:       85 c0                   test   %eax,%eax
         :	         * Note: it's possible that this would fail, if the opfamily is
         :	         * incomplete, but it seems quite unlikely that an opfamily would omit
         :	         * non-cross-type support functions for any datatype that it supports at
         :	         * all.
         :	         */
         :	        cmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],
    0.00 :	  4af66a:       89 c7                   mov    %eax,%edi
         :	                                                                 elemtype,
         :	                                                                 elemtype,
         :	                                                                 BTORDER_PROC);
         :	        if (!RegProcedureIsValid(cmp_proc))
    0.00 :	  4af66c:       0f 84 ac 01 00 00       je     4af81e <_bt_preprocess_array_keys+0x4ce>
         :	                elog(ERROR, "missing support function %d(%u,%u) in opfamily %u",
         :	                         BTORDER_PROC, elemtype, elemtype,
         :	                         rel->rd_opfamily[skey->sk_attno - 1]);
         :
         :	        /* Sort the array elements */
         :	        fmgr_info(cmp_proc, &cxt.flinfo);
    0.00 :	  4af672:       48 8d 75 80             lea    -0x80(%rbp),%rsi
         :	        cxt.collation = skey->sk_collation;
         :	        cxt.reverse = reverse;
         :	        qsort_arg((void *) elems, nelems, sizeof(Datum),
    0.00 :	  4af676:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  4af67c:       45 31 f6                xor    %r14d,%r14d
         :	                elog(ERROR, "missing support function %d(%u,%u) in opfamily %u",
         :	                         BTORDER_PROC, elemtype, elemtype,
         :	                         rel->rd_opfamily[skey->sk_attno - 1]);
         :
         :	        /* Sort the array elements */
         :	        fmgr_info(cmp_proc, &cxt.flinfo);
    0.00 :	  4af67f:       e8 dc 09 2d 00          callq  780060 <fmgr_info>
         :	        cxt.collation = skey->sk_collation;
    0.00 :	  4af684:       41 8b 44 24 0c          mov    0xc(%r12),%eax
         :	        cxt.reverse = reverse;
         :	        qsort_arg((void *) elems, nelems, sizeof(Datum),
    0.00 :	  4af689:       48 8b bd 70 ff ff ff    mov    -0x90(%rbp),%rdi
    0.00 :	  4af690:       4c 8d 45 80             lea    -0x80(%rbp),%r8
    0.00 :	  4af694:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  4af697:       b9 80 e9 4a 00          mov    $0x4ae980,%ecx
    0.00 :	  4af69c:       ba 08 00 00 00          mov    $0x8,%edx
         :	                         BTORDER_PROC, elemtype, elemtype,
         :	                         rel->rd_opfamily[skey->sk_attno - 1]);
         :
         :	        /* Sort the array elements */
         :	        fmgr_info(cmp_proc, &cxt.flinfo);
         :	        cxt.collation = skey->sk_collation;
    0.00 :	  4af6a1:       89 45 b0                mov    %eax,-0x50(%rbp)
         :	        cxt.reverse = reverse;
    0.00 :	  4af6a4:       44 89 f8                mov    %r15d,%eax
         :	        qsort_arg((void *) elems, nelems, sizeof(Datum),
    0.00 :	  4af6a7:       45 31 ff                xor    %r15d,%r15d
         :	                         rel->rd_opfamily[skey->sk_attno - 1]);
         :
         :	        /* Sort the array elements */
         :	        fmgr_info(cmp_proc, &cxt.flinfo);
         :	        cxt.collation = skey->sk_collation;
         :	        cxt.reverse = reverse;
    0.00 :	  4af6aa:       83 e0 01                and    $0x1,%eax
    0.00 :	  4af6ad:       88 45 b4                mov    %al,-0x4c(%rbp)
         :	        qsort_arg((void *) elems, nelems, sizeof(Datum),
    0.00 :	  4af6b0:       e8 7b db 2f 00          callq  7ad230 <qsort_arg>
    0.00 :	  4af6b5:       4c 8b a5 70 ff ff ff    mov    -0x90(%rbp),%r12
    0.00 :	  4af6bc:       0f 1f 40 00             nopl   0x0(%rax)
         :	        last_non_dup = 0;
         :	        for (i = 1; i < nelems; i++)
         :	        {
         :	                int32           compare;
         :
         :	                compare = DatumGetInt32(FunctionCall2Coll(&cxt.flinfo,
    0.00 :	  4af6c0:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  4af6c7:       49 8b 4c 24 08          mov    0x8(%r12),%rcx
    0.00 :	  4af6cc:       48 8d 7d 80             lea    -0x80(%rbp),%rdi
    0.00 :	  4af6d0:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  4af6d3:       4a 8b 14 f0             mov    (%rax,%r14,8),%rdx
    0.00 :	  4af6d7:       e8 54 e9 2c 00          callq  77e030 <FunctionCall2Coll>
         :	                                                                                                  cxt.collation,
         :	                                                                                                  elems[last_non_dup],
         :	                                                                                                  elems[i]));
         :	                if (compare != 0)
    0.00 :	  4af6dc:       85 c0                   test   %eax,%eax
    0.00 :	  4af6de:       74 17                   je     4af6f7 <_bt_preprocess_array_keys+0x3a7>
         :	                        elems[++last_non_dup] = elems[i];
    0.00 :	  4af6e0:       49 8b 44 24 08          mov    0x8(%r12),%rax
    0.00 :	  4af6e5:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  4af6ec:       41 83 c7 01             add    $0x1,%r15d
    0.00 :	  4af6f0:       4d 63 f7                movslq %r15d,%r14
    0.00 :	  4af6f3:       4a 89 04 f2             mov    %rax,(%rdx,%r14,8)
         :	        qsort_arg((void *) elems, nelems, sizeof(Datum),
         :	                          _bt_compare_array_elements, (void *) &cxt);
         :
         :	        /* Now scan the sorted elements and remove duplicates */
         :	        last_non_dup = 0;
         :	        for (i = 1; i < nelems; i++)
    0.00 :	  4af6f7:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  4af6fb:       49 83 c4 08             add    $0x8,%r12
    0.00 :	  4af6ff:       44 39 eb                cmp    %r13d,%ebx
    0.00 :	  4af702:       7f bc                   jg     4af6c0 <_bt_preprocess_array_keys+0x370>
         :	                                                                                                  elems[i]));
         :	                if (compare != 0)
         :	                        elems[++last_non_dup] = elems[i];
         :	        }
         :
         :	        return last_non_dup + 1;
    0.00 :	  4af704:       41 8d 5f 01             lea    0x1(%r15),%ebx
         :	                /*
         :	                 * Sort the non-null elements and eliminate any duplicates.  We must
         :	                 * sort in the same ordering used by the index column, so that the
         :	                 * successive primitive indexscans produce data in index order.
         :	                 */
         :	                num_elems = _bt_sort_array_elements(scan, cur,
    0.00 :	  4af708:       89 5d c8                mov    %ebx,-0x38(%rbp)
         :	                                                                                        elem_values, num_nonnulls);
         :
         :	                /*
         :	                 * And set up the BTArrayKeyInfo data.
         :	                 */
         :	                so->arrayKeys[numArrayKeys].scan_key = i;
    0.00 :	  4af70b:       48 63 85 6c ff ff ff    movslq -0x94(%rbp),%rax
    0.00 :	  4af712:       48 8b 9d 40 ff ff ff    mov    -0xc0(%rbp),%rbx
    0.00 :	  4af719:       48 8b 53 20             mov    0x20(%rbx),%rdx
    0.00 :	  4af71d:       8b 9d 7c ff ff ff       mov    -0x84(%rbp),%ebx
    0.00 :	  4af723:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  4af727:       48 8d 0c c5 00 00 00    lea    0x0(,%rax,8),%rcx
    0.00 :	  4af72e:       00 
    0.00 :	  4af72f:       89 1c c2                mov    %ebx,(%rdx,%rax,8)
         :	                so->arrayKeys[numArrayKeys].num_elems = num_elems;
    0.00 :	  4af732:       48 8b 85 40 ff ff ff    mov    -0xc0(%rbp),%rax
    0.00 :	  4af739:       48 8b 50 20             mov    0x20(%rax),%rdx
    0.00 :	  4af73d:       8b 45 c8                mov    -0x38(%rbp),%eax
    0.00 :	  4af740:       89 44 0a 0c             mov    %eax,0xc(%rdx,%rcx,1)
         :	                so->arrayKeys[numArrayKeys].elem_values = elem_values;
    0.00 :	  4af744:       48 8b 9d 40 ff ff ff    mov    -0xc0(%rbp),%rbx
    0.00 :	  4af74b:       48 8b 45 c0             mov    -0x40(%rbp),%rax
    0.00 :	  4af74f:       48 8b 53 20             mov    0x20(%rbx),%rdx
    0.00 :	  4af753:       48 89 44 0a 10          mov    %rax,0x10(%rdx,%rcx,1)
         :	                numArrayKeys++;
    0.00 :	  4af758:       83 85 6c ff ff ff 01    addl   $0x1,-0x94(%rbp)
    0.00 :	  4af75f:       e9 2c fd ff ff          jmpq   4af490 <_bt_preprocess_array_keys+0x140>
         :	                 */
         :	                switch (cur->sk_strategy)
         :	                {
         :	                        case BTLessStrategyNumber:
         :	                        case BTLessEqualStrategyNumber:
         :	                                cur->sk_argument =
    0.00 :	  4af764:       48 8b 4d c0             mov    -0x40(%rbp),%rcx
    0.00 :	  4af768:       48 8b bd 38 ff ff ff    mov    -0xc8(%rbp),%rdi
    0.00 :	  4af76f:       41 89 d8                mov    %ebx,%r8d
    0.00 :	  4af772:       ba 05 00 00 00          mov    $0x5,%edx
    0.00 :	  4af777:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  4af77a:       e8 61 fa ff ff          callq  4af1e0 <_bt_find_extreme_element>
    0.00 :	  4af77f:       49 89 44 24 40          mov    %rax,0x40(%r12)
         :	                                        _bt_find_extreme_element(scan, cur,
         :	                                                                                         BTGreaterStrategyNumber,
         :	                                                                                         elem_values, num_nonnulls);
         :	                                continue;
    0.00 :	  4af784:       e9 07 fd ff ff          jmpq   4af490 <_bt_preprocess_array_keys+0x140>
    0.00 :	  4af789:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        numArrayKeys++;
         :	                        Assert(!(cur->sk_flags & (SK_ROW_HEADER | SK_SEARCHNULL | SK_SEARCHNOTNULL)));
         :	                        /* If any arrays are null as a whole, we can quit right now. */
         :	                        if (cur->sk_flags & SK_ISNULL)
         :	                        {
         :	                                so->numArrayKeys = -1;
    0.00 :	  4af790:       48 8b 9d 40 ff ff ff    mov    -0xc0(%rbp),%rbx
    0.00 :	  4af797:       c7 43 18 ff ff ff ff    movl   $0xffffffff,0x18(%rbx)
         :	                                so->arrayKeyData = NULL;
    0.00 :	  4af79e:       48 c7 43 10 00 00 00    movq   $0x0,0x10(%rbx)
    0.00 :	  4af7a5:       00 
         :	        }
         :
         :	        so->numArrayKeys = numArrayKeys;
         :
         :	        MemoryContextSwitchTo(oldContext);
         :	}
    0.00 :	  4af7a6:       e9 0b fe ff ff          jmpq   4af5b6 <_bt_preprocess_array_keys+0x266>
         :	        /* Allocate space for per-array data in the workspace context */
         :	        so->arrayKeys = (BTArrayKeyInfo *) palloc0(numArrayKeys * sizeof(BTArrayKeyInfo));
         :
         :	        /* Now process each array key */
         :	        numArrayKeys = 0;
         :	        for (i = 0; i < numberOfKeys; i++)
    0.00 :	  4af7ab:       c7 85 6c ff ff ff ff    movl   $0xffffffff,-0x94(%rbp)
    0.00 :	  4af7b2:       ff ff ff 
         :	                so->arrayKeys[numArrayKeys].num_elems = num_elems;
         :	                so->arrayKeys[numArrayKeys].elem_values = elem_values;
         :	                numArrayKeys++;
         :	        }
         :
         :	        so->numArrayKeys = numArrayKeys;
    0.00 :	  4af7b5:       8b 9d 6c ff ff ff       mov    -0x94(%rbp),%ebx
    0.00 :	  4af7bb:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	  4af7c2:       89 5a 18                mov    %ebx,0x18(%rdx)
    0.00 :	  4af7c5:       48 8b 85 58 ff ff ff    mov    -0xa8(%rbp),%rax
    0.00 :	  4af7cc:       48 89 05 8d b0 70 00    mov    %rax,0x70b08d(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  4af7d3:       e9 de fd ff ff          jmpq   4af5b6 <_bt_preprocess_array_keys+0x266>
         :	         * support the convention that sk_subtype == InvalidOid means the opclass
         :	         * input type; this is a hack to simplify life for ScanKeyInit().
         :	         */
         :	        elemtype = skey->sk_subtype;
         :	        if (elemtype == InvalidOid)
         :	                elemtype = rel->rd_opcintype[skey->sk_attno - 1];
    0.00 :	  4af7d8:       49 8b 86 d0 00 00 00    mov    0xd0(%r14),%rax
    0.00 :	  4af7df:       4c 8d 0c bd 00 00 00    lea    0x0(,%rdi,4),%r9
    0.00 :	  4af7e6:       00 
    0.00 :	  4af7e7:       44 8b 2c b8             mov    (%rax,%rdi,4),%r13d
    0.00 :	  4af7eb:       e9 5d fe ff ff          jmpq   4af64d <_bt_preprocess_array_keys+0x2fd>
         :	        /*
         :	         * Make a scan-lifespan context to hold array-associated data, or reset it
         :	         * if we already have one from a previous rescan cycle.
         :	         */
         :	        if (so->arrayContext == NULL)
         :	                so->arrayContext = AllocSetContextCreate(CurrentMemoryContext,
    0.00 :	  4af7f0:       48 8b 3d 69 b0 70 00    mov    0x70b069(%rip),%rdi        # bba860 <CurrentMemoryContext>
    0.00 :	  4af7f7:       31 d2                   xor    %edx,%edx
    0.00 :	  4af7f9:       41 b8 00 20 00 00       mov    $0x2000,%r8d
    0.00 :	  4af7ff:       b9 00 04 00 00          mov    $0x400,%ecx
    0.00 :	  4af804:       be 39 49 7b 00          mov    $0x7b4939,%esi
    0.00 :	  4af809:       e8 82 87 2e 00          callq  797f90 <AllocSetContextCreate>
    0.00 :	  4af80e:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	  4af815:       48 89 42 28             mov    %rax,0x28(%rdx)
    0.00 :	  4af819:       e9 cc fb ff ff          jmpq   4af3ea <_bt_preprocess_array_keys+0x9a>
         :	        cmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],
         :	                                                                 elemtype,
         :	                                                                 elemtype,
         :	                                                                 BTORDER_PROC);
         :	        if (!RegProcedureIsValid(cmp_proc))
         :	                elog(ERROR, "missing support function %d(%u,%u) in opfamily %u",
    0.00 :	  4af81e:       ba e0 4b 7b 00          mov    $0x7b4be0,%edx
    0.00 :	  4af823:       be d7 01 00 00          mov    $0x1d7,%esi
    0.00 :	  4af828:       bf 17 49 7b 00          mov    $0x7b4917,%edi
    0.00 :	  4af82d:       e8 ee bb 2c 00          callq  77b420 <elog_start>
    0.00 :	  4af832:       49 0f bf 54 24 04       movswq 0x4(%r12),%rdx
    0.00 :	  4af838:       49 8b 86 c8 00 00 00    mov    0xc8(%r14),%rax
    0.00 :	  4af83f:       45 89 e8                mov    %r13d,%r8d
    0.00 :	  4af842:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  4af845:       be 38 4a 7b 00          mov    $0x7b4a38,%esi
    0.00 :	  4af84a:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4af84f:       44 8b 4c 90 fc          mov    -0x4(%rax,%rdx,4),%r9d
    0.00 :	  4af854:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4af859:       31 c0                   xor    %eax,%eax
    0.00 :	  4af85b:       e8 d0 b9 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4af860:       e8 6b 9c fb ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/../../../../src/include/storage/s_lock.h:224
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3329
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3326
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3341
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006741d0 <TerminateBufferIO>:
         :	 * be 0, or BM_VALID if we just finished reading in the page.
         :	 */
         :	static void
         :	TerminateBufferIO(volatile BufferDesc *buf, bool clear_dirty,
         :	                                  int set_flag_bits)
         :	{
    0.00 :	  6741d0:       55                      push   %rbp
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/../../../../src/include/storage/s_lock.h:224
   33.33 :	  6741d1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  6741d6:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6741d9:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3326
   16.67 :	  6741dd:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  6741e1:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  6741e4:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  6741e8:       41 89 f4                mov    %esi,%r12d
    0.00 :	  6741eb:       48 83 ec 20             sub    $0x20,%rsp
    0.00 :	  6741ef:       41 89 d5                mov    %edx,%r13d
         :	        Assert(buf == InProgressBuf);
         :
         :	        LockBufHdr(buf);
    0.00 :	  6741f2:       48 8d 7f 20             lea    0x20(%rdi),%rdi
    0.00 :	  6741f6:       f0 86 07                lock xchg %al,(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3329
   33.33 :	  6741f9:       84 c0                   test   %al,%al
    0.00 :	  6741fb:       75 53                   jne    674250 <TerminateBufferIO+0x80>
         :
         :	        Assert(buf->flags & BM_IO_IN_PROGRESS);
         :	        buf->flags &= ~(BM_IO_IN_PROGRESS | BM_IO_ERROR);
    0.00 :	  6741fd:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674201:       83 e0 e7                and    $0xffffffe7,%eax
         :	        if (clear_dirty && !(buf->flags & BM_JUST_DIRTIED))
    0.00 :	  674204:       45 84 e4                test   %r12b,%r12b
         :	        Assert(buf == InProgressBuf);
         :
         :	        LockBufHdr(buf);
         :
         :	        Assert(buf->flags & BM_IO_IN_PROGRESS);
         :	        buf->flags &= ~(BM_IO_IN_PROGRESS | BM_IO_ERROR);
    0.00 :	  674207:       66 89 43 14             mov    %ax,0x14(%rbx)
         :	        if (clear_dirty && !(buf->flags & BM_JUST_DIRTIED))
    0.00 :	  67420b:       74 12                   je     67421f <TerminateBufferIO+0x4f>
    0.00 :	  67420d:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674211:       a8 20                   test   $0x20,%al
    0.00 :	  674213:       75 0a                   jne    67421f <TerminateBufferIO+0x4f>
         :	                buf->flags &= ~(BM_DIRTY | BM_CHECKPOINT_NEEDED);
    0.00 :	  674215:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674219:       24 7e                   and    $0x7e,%al
    0.00 :	  67421b:       66 89 43 14             mov    %ax,0x14(%rbx)
         :	        buf->flags |= set_flag_bits;
    0.00 :	  67421f:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674223:       44 09 e8                or     %r13d,%eax
    0.00 :	  674226:       66 89 43 14             mov    %ax,0x14(%rbx)
         :
         :	        UnlockBufHdr(buf);
    0.00 :	  67422a:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        InProgressBuf = NULL;
    0.00 :	  67422e:       48 c7 05 2f 8e 50 00    movq   $0x0,0x508e2f(%rip)        # b7d068 <InProgressBuf>
    0.00 :	  674235:       00 00 00 00 
         :
         :	        LWLockRelease(buf->io_in_progress_lock);
    0.00 :	  674239:       48 8b 7b 30             mov    0x30(%rbx),%rdi
         :	}
    0.00 :	  67423d:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  674241:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  674245:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  674249:       c9                      leaveq 
         :
         :	        UnlockBufHdr(buf);
         :
         :	        InProgressBuf = NULL;
         :
         :	        LWLockRelease(buf->io_in_progress_lock);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3341
   16.67 :	  67424a:       e9 51 b1 01 00          jmpq   68f3a0 <LWLockRelease>
    0.00 :	  67424f:       90                      nop
         :	TerminateBufferIO(volatile BufferDesc *buf, bool clear_dirty,
         :	                                  int set_flag_bits)
         :	{
         :	        Assert(buf == InProgressBuf);
         :
         :	        LockBufHdr(buf);
    0.00 :	  674250:       ba 01 0d 00 00          mov    $0xd01,%edx
    0.00 :	  674255:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  67425a:       e8 e1 bd 01 00          callq  690040 <s_lock>
    0.00 :	  67425f:       eb 9c                   jmp    6741fd <TerminateBufferIO+0x2d>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1252
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1231
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1250
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1252
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1252
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006766c0 <ReleaseAndReadBuffer>:
         :	 */
         :	Buffer
         :	ReleaseAndReadBuffer(Buffer buffer,
         :	                                         Relation relation,
         :	                                         BlockNumber blockNum)
         :	{
    0.00 :	  6766c0:       55                      push   %rbp
    0.00 :	  6766c1:       89 f9                   mov    %edi,%ecx
    0.00 :	  6766c3:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1231
   16.67 :	  6766c6:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  6766ca:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  6766ce:       48 89 f3                mov    %rsi,%rbx
    0.00 :	  6766d1:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  6766d5:       48 83 ec 20             sub    $0x20,%rsp
         :	        ForkNumber      forkNum = MAIN_FORKNUM;
         :	        volatile BufferDesc *bufHdr;
         :
         :	        if (BufferIsValid(buffer))
    0.00 :	  6766d9:       83 ff 00                cmp    $0x0,%edi
         :	 */
         :	Buffer
         :	ReleaseAndReadBuffer(Buffer buffer,
         :	                                         Relation relation,
         :	                                         BlockNumber blockNum)
         :	{
    0.00 :	  6766dc:       41 89 d4                mov    %edx,%r12d
         :	        ForkNumber      forkNum = MAIN_FORKNUM;
         :	        volatile BufferDesc *bufHdr;
         :
         :	        if (BufferIsValid(buffer))
    0.00 :	  6766df:       74 2d                   je     67670e <ReleaseAndReadBuffer+0x4e>
         :	        {
         :	                Assert(BufferIsPinned(buffer));
         :	                if (BufferIsLocal(buffer))
    0.00 :	  6766e1:       7c 4d                   jl     676730 <ReleaseAndReadBuffer+0x70>
         :	                        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
         :	                        LocalRefCount[-buffer - 1]--;
         :	                }
         :	                else
         :	                {
         :	                        bufHdr = &BufferDescriptors[buffer - 1];
    0.00 :	  6766e3:       48 63 c7                movslq %edi,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1250
   16.67 :	  6766e6:       48 8d 78 ff             lea    -0x1(%rax),%rdi
    0.00 :	  6766ea:       48 c1 e7 06             shl    $0x6,%rdi
    0.00 :	  6766ee:       48 03 3d 0b 94 54 00    add    0x54940b(%rip),%rdi        # bbfb00 <BufferDescriptors>
         :	                        /* we have pin, so it's ok to examine tag without spinlock */
         :	                        if (bufHdr->tag.blockNum == blockNum &&
    0.00 :	  6766f5:       8b 47 10                mov    0x10(%rdi),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1252
   16.67 :	  6766f8:       39 d0                   cmp    %edx,%eax
    0.00 :	  6766fa:       75 08                   jne    676704 <ReleaseAndReadBuffer+0x44>
    0.00 :	  6766fc:       8b 47 08                mov    0x8(%rdi),%eax
    0.00 :	  6766ff:       3b 46 08                cmp    0x8(%rsi),%eax
    0.00 :	  676702:       74 7c                   je     676780 <ReleaseAndReadBuffer+0xc0>
         :	                                RelFileNodeEquals(bufHdr->tag.rnode, relation->rd_node) &&
         :	                                bufHdr->tag.forkNum == forkNum)
         :	                                return buffer;
         :	                        UnpinBuffer(bufHdr, true);
    0.00 :	  676704:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  676709:       e8 22 e6 ff ff          callq  674d30 <UnpinBuffer>
         :	                }
         :	        }
         :
         :	        return ReadBuffer(relation, blockNum);
    0.00 :	  67670e:       44 89 e6                mov    %r12d,%esi
    0.00 :	  676711:       48 89 df                mov    %rbx,%rdi
         :	}
    0.00 :	  676714:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  676718:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  67671c:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  676720:       c9                      leaveq 
         :	                                return buffer;
         :	                        UnpinBuffer(bufHdr, true);
         :	                }
         :	        }
         :
         :	        return ReadBuffer(relation, blockNum);
    0.00 :	  676721:       e9 7a ff ff ff          jmpq   6766a0 <ReadBuffer>
    0.00 :	  676726:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  67672d:       00 00 00 
         :	        if (BufferIsValid(buffer))
         :	        {
         :	                Assert(BufferIsPinned(buffer));
         :	                if (BufferIsLocal(buffer))
         :	                {
         :	                        bufHdr = &LocalBufferDescriptors[-buffer - 1];
    0.00 :	  676730:       89 f8                   mov    %edi,%eax
    0.00 :	  676732:       f7 d0                   not    %eax
    0.00 :	  676734:       4c 63 e8                movslq %eax,%r13
    0.00 :	  676737:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  67673a:       48 c1 e2 06             shl    $0x6,%rdx
    0.00 :	  67673e:       48 03 15 cb 69 50 00    add    0x5069cb(%rip),%rdx        # b7d110 <LocalBufferDescriptors>
         :	                        if (bufHdr->tag.blockNum == blockNum &&
    0.00 :	  676745:       8b 42 10                mov    0x10(%rdx),%eax
    0.00 :	  676748:       44 39 e0                cmp    %r12d,%eax
    0.00 :	  67674b:       75 08                   jne    676755 <ReleaseAndReadBuffer+0x95>
    0.00 :	  67674d:       8b 42 08                mov    0x8(%rdx),%eax
    0.00 :	  676750:       3b 46 08                cmp    0x8(%rsi),%eax
    0.00 :	  676753:       74 53                   je     6767a8 <ReleaseAndReadBuffer+0xe8>
         :	                                RelFileNodeEquals(bufHdr->tag.rnode, relation->rd_node) &&
         :	                                bufHdr->tag.forkNum == forkNum)
         :	                                return buffer;
         :	                        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
    0.00 :	  676755:       48 8b 3d 64 41 54 00    mov    0x544164(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  67675c:       89 ce                   mov    %ecx,%esi
    0.00 :	  67675e:       e8 9d 41 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
         :	                        LocalRefCount[-buffer - 1]--;
    0.00 :	  676763:       4a 8d 04 ad 00 00 00    lea    0x0(,%r13,4),%rax
    0.00 :	  67676a:       00 
    0.00 :	  67676b:       48 03 05 ae 69 50 00    add    0x5069ae(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  676772:       83 28 01                subl   $0x1,(%rax)
    0.00 :	  676775:       eb 97                   jmp    67670e <ReleaseAndReadBuffer+0x4e>
    0.00 :	  676777:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  67677e:       00 00 
         :	                }
         :	                else
         :	                {
         :	                        bufHdr = &BufferDescriptors[buffer - 1];
         :	                        /* we have pin, so it's ok to examine tag without spinlock */
         :	                        if (bufHdr->tag.blockNum == blockNum &&
   33.33 :	  676780:       8b 47 04                mov    0x4(%rdi),%eax
    0.00 :	  676783:       3b 46 04                cmp    0x4(%rsi),%eax
    0.00 :	  676786:       0f 85 78 ff ff ff       jne    676704 <ReleaseAndReadBuffer+0x44>
   16.67 :	  67678c:       8b 07                   mov    (%rdi),%eax
    0.00 :	  67678e:       3b 06                   cmp    (%rsi),%eax
    0.00 :	  676790:       0f 85 6e ff ff ff       jne    676704 <ReleaseAndReadBuffer+0x44>
    0.00 :	  676796:       8b 47 0c                mov    0xc(%rdi),%eax
    0.00 :	  676799:       85 c0                   test   %eax,%eax
    0.00 :	  67679b:       0f 85 63 ff ff ff       jne    676704 <ReleaseAndReadBuffer+0x44>
    0.00 :	  6767a1:       eb 1c                   jmp    6767bf <ReleaseAndReadBuffer+0xff>
    0.00 :	  6767a3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                Assert(BufferIsPinned(buffer));
         :	                if (BufferIsLocal(buffer))
         :	                {
         :	                        bufHdr = &LocalBufferDescriptors[-buffer - 1];
         :	                        if (bufHdr->tag.blockNum == blockNum &&
    0.00 :	  6767a8:       8b 42 04                mov    0x4(%rdx),%eax
    0.00 :	  6767ab:       3b 46 04                cmp    0x4(%rsi),%eax
    0.00 :	  6767ae:       66 90                   xchg   %ax,%ax
    0.00 :	  6767b0:       75 a3                   jne    676755 <ReleaseAndReadBuffer+0x95>
    0.00 :	  6767b2:       8b 02                   mov    (%rdx),%eax
    0.00 :	  6767b4:       3b 06                   cmp    (%rsi),%eax
    0.00 :	  6767b6:       75 9d                   jne    676755 <ReleaseAndReadBuffer+0x95>
    0.00 :	  6767b8:       8b 42 0c                mov    0xc(%rdx),%eax
    0.00 :	  6767bb:       85 c0                   test   %eax,%eax
    0.00 :	  6767bd:       75 96                   jne    676755 <ReleaseAndReadBuffer+0x95>
         :	                        UnpinBuffer(bufHdr, true);
         :	                }
         :	        }
         :
         :	        return ReadBuffer(relation, blockNum);
         :	}
    0.00 :	  6767bf:       89 c8                   mov    %ecx,%eax
    0.00 :	  6767c1:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  6767c5:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6767c9:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  6767cd:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1298
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1296
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1305
   16.67 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1305
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077e0d0 <FunctionCall1Coll>:
         :	 * directly-computed parameter list.  Note that neither arguments nor result
         :	 * are allowed to be NULL.
         :	 */
         :	Datum
         :	FunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)
         :	{
    0.00 :	  77e0d0:       55                      push   %rbp
    0.00 :	  77e0d1:       48 89 f8                mov    %rdi,%rax
    0.00 :	  77e0d4:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  77e0d7:       48 81 ec b0 03 00 00    sub    $0x3b0,%rsp
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);
    0.00 :	  77e0de:       48 89 bd 50 fc ff ff    mov    %rdi,-0x3b0(%rbp)
    0.00 :	  77e0e5:       48 c7 85 58 fc ff ff    movq   $0x0,-0x3a8(%rbp)
    0.00 :	  77e0ec:       00 00 00 00 
         :
         :	        fcinfo.arg[0] = arg1;
         :	        fcinfo.argnull[0] = false;
         :
         :	        result = FunctionCallInvoke(&fcinfo);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1298
   50.00 :	  77e0f0:       48 8d bd 50 fc ff ff    lea    -0x3b0(%rbp),%rdi
         :	FunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)
         :	{
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);
    0.00 :	  77e0f7:       48 c7 85 60 fc ff ff    movq   $0x0,-0x3a0(%rbp)
    0.00 :	  77e0fe:       00 00 00 00 
    0.00 :	  77e102:       89 b5 68 fc ff ff       mov    %esi,-0x398(%rbp)
    0.00 :	  77e108:       c6 85 6c fc ff ff 00    movb   $0x0,-0x394(%rbp)
    0.00 :	  77e10f:       66 c7 85 6e fc ff ff    movw   $0x1,-0x392(%rbp)
    0.00 :	  77e116:       01 00 
         :
         :	        fcinfo.arg[0] = arg1;
    0.00 :	  77e118:       48 89 95 70 fc ff ff    mov    %rdx,-0x390(%rbp)
         :	        fcinfo.argnull[0] = false;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1296
   16.67 :	  77e11f:       c6 45 90 00             movb   $0x0,-0x70(%rbp)
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77e123:       ff 10                   callq  *(%rax)
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
    0.00 :	  77e125:       80 bd 6c fc ff ff 00    cmpb   $0x0,-0x394(%rbp)
    0.00 :	  77e12c:       75 02                   jne    77e130 <FunctionCall1Coll+0x60>
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
         :
         :	        return result;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1305
   16.67 :	  77e12e:       c9                      leaveq 
   16.67 :	  77e12f:       c3                      retq   
         :
         :	        result = FunctionCallInvoke(&fcinfo);
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
    0.00 :	  77e130:       ba 60 52 8d 00          mov    $0x8d5260,%edx
    0.00 :	  77e135:       be 16 05 00 00          mov    $0x516,%esi
    0.00 :	  77e13a:       bf b3 47 8d 00          mov    $0x8d47b3,%edi
    0.00 :	  77e13f:       e8 dc d2 ff ff          callq  77b420 <elog_start>
    0.00 :	  77e144:       48 8b 85 50 fc ff ff    mov    -0x3b0(%rbp),%rax
    0.00 :	  77e14b:       be 97 4c 8d 00          mov    $0x8d4c97,%esi
    0.00 :	  77e150:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  77e155:       8b 50 08                mov    0x8(%rax),%edx
    0.00 :	  77e158:       31 c0                   xor    %eax,%eax
    0.00 :	  77e15a:       e8 d1 d0 ff ff          callq  77b230 <elog_finish>
    0.00 :	  77e15f:       e8 6c b3 ce ff          callq  4694d0 <abort@plt>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   50.00 ??:0
   16.67 ??:0
   16.67 ??:0
   16.67 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000084750 <memcpy>:
    0.00 :	   84750:       48 83 fa 20             cmp    $0x20,%rdx
 ??:0
   50.00 :	   84754:       48 89 f8                mov    %rdi,%rax
    0.00 :	   84757:       73 77                   jae    847d0 <memcpy+0x80>
    0.00 :	   84759:       f6 c2 01                test   $0x1,%dl
    0.00 :	   8475c:       74 0b                   je     84769 <memcpy+0x19>
    0.00 :	   8475e:       0f b6 0e                movzbl (%rsi),%ecx
    0.00 :	   84761:       88 0f                   mov    %cl,(%rdi)
    0.00 :	   84763:       48 ff c6                inc    %rsi
    0.00 :	   84766:       48 ff c7                inc    %rdi
    0.00 :	   84769:       f6 c2 02                test   $0x2,%dl
    0.00 :	   8476c:       74 12                   je     84780 <memcpy+0x30>
    0.00 :	   8476e:       0f b7 0e                movzwl (%rsi),%ecx
    0.00 :	   84771:       66 89 0f                mov    %cx,(%rdi)
    0.00 :	   84774:       48 83 c6 02             add    $0x2,%rsi
    0.00 :	   84778:       48 83 c7 02             add    $0x2,%rdi
    0.00 :	   8477c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   84780:       f6 c2 04                test   $0x4,%dl
    0.00 :	   84783:       74 0c                   je     84791 <memcpy+0x41>
   16.67 :	   84785:       8b 0e                   mov    (%rsi),%ecx
    0.00 :	   84787:       89 0f                   mov    %ecx,(%rdi)
   16.67 :	   84789:       48 83 c6 04             add    $0x4,%rsi
    0.00 :	   8478d:       48 83 c7 04             add    $0x4,%rdi
   16.67 :	   84791:       f6 c2 08                test   $0x8,%dl
    0.00 :	   84794:       74 0e                   je     847a4 <memcpy+0x54>
    0.00 :	   84796:       48 8b 0e                mov    (%rsi),%rcx
    0.00 :	   84799:       48 89 0f                mov    %rcx,(%rdi)
    0.00 :	   8479c:       48 83 c6 08             add    $0x8,%rsi
    0.00 :	   847a0:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	   847a4:       81 e2 f0 00 00 00       and    $0xf0,%edx
    0.00 :	   847aa:       74 1f                   je     847cb <memcpy+0x7b>
    0.00 :	   847ac:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   847b0:       48 8b 0e                mov    (%rsi),%rcx
    0.00 :	   847b3:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   847b7:       48 89 0f                mov    %rcx,(%rdi)
    0.00 :	   847ba:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   847be:       83 ea 10                sub    $0x10,%edx
    0.00 :	   847c1:       48 8d 76 10             lea    0x10(%rsi),%rsi
    0.00 :	   847c5:       48 8d 7f 10             lea    0x10(%rdi),%rdi
    0.00 :	   847c9:       75 e5                   jne    847b0 <memcpy+0x60>
    0.00 :	   847cb:       f3 c3                   repz retq 
    0.00 :	   847cd:       0f 1f 00                nopl   (%rax)
    0.00 :	   847d0:       48 89 44 24 f8          mov    %rax,-0x8(%rsp)
    0.00 :	   847d5:       89 f1                   mov    %esi,%ecx
    0.00 :	   847d7:       83 e1 07                and    $0x7,%ecx
    0.00 :	   847da:       74 34                   je     84810 <memcpy+0xc0>
    0.00 :	   847dc:       48 8d 54 11 f8          lea    -0x8(%rcx,%rdx,1),%rdx
    0.00 :	   847e1:       83 e9 08                sub    $0x8,%ecx
    0.00 :	   847e4:       66 66 66 2e 0f 1f 84    data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   847eb:       00 00 00 00 00 
    0.00 :	   847f0:       0f b6 06                movzbl (%rsi),%eax
    0.00 :	   847f3:       88 07                   mov    %al,(%rdi)
    0.00 :	   847f5:       ff c1                   inc    %ecx
    0.00 :	   847f7:       48 8d 76 01             lea    0x1(%rsi),%rsi
    0.00 :	   847fb:       48 8d 7f 01             lea    0x1(%rdi),%rdi
    0.00 :	   847ff:       75 ef                   jne    847f0 <memcpy+0xa0>
    0.00 :	   84801:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   84808:       0f 1f 84 00 00 00 00 
    0.00 :	   8480f:       00 
    0.00 :	   84810:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	   84817:       77 77                   ja     84890 <memcpy+0x140>
    0.00 :	   84819:       89 d1                   mov    %edx,%ecx
    0.00 :	   8481b:       c1 e9 05                shr    $0x5,%ecx
    0.00 :	   8481e:       74 60                   je     84880 <memcpy+0x130>
    0.00 :	   84820:       ff c9                   dec    %ecx
    0.00 :	   84822:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84825:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84829:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8482d:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84831:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84834:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   84838:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8483c:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84840:       48 8d 76 20             lea    0x20(%rsi),%rsi
    0.00 :	   84844:       48 8d 7f 20             lea    0x20(%rdi),%rdi
    0.00 :	   84848:       74 36                   je     84880 <memcpy+0x130>
    0.00 :	   8484a:       ff c9                   dec    %ecx
    0.00 :	   8484c:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   8484f:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84853:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84857:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   8485b:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   8485e:       4c 89 47 08             mov    %r8,0x8(%rdi)
    0.00 :	   84862:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84866:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8486a:       48 8d 76 20             lea    0x20(%rsi),%rsi
    0.00 :	   8486e:       48 8d 7f 20             lea    0x20(%rdi),%rdi
    0.00 :	   84872:       75 ac                   jne    84820 <memcpy+0xd0>
    0.00 :	   84874:       66 66 66 2e 0f 1f 84    data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	   8487b:       00 00 00 00 00 
    0.00 :	   84880:       83 e2 1f                and    $0x1f,%edx
    0.00 :	   84883:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84888:       0f 85 cb fe ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   8488e:       f3 c3                   repz retq 
    0.00 :	   84890:       4c 8b 1d 79 d8 2e 00    mov    0x2ed879(%rip),%r11        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	   84897:       49 39 d3                cmp    %rdx,%r11
    0.00 :	   8489a:       4c 0f 47 da             cmova  %rdx,%r11
    0.00 :	   8489e:       4c 89 d9                mov    %r11,%rcx
    0.00 :	   848a1:       49 83 e3 f8             and    $0xfffffffffffffff8,%r11
    0.00 :	   848a5:       48 c1 e9 03             shr    $0x3,%rcx
    0.00 :	   848a9:       74 05                   je     848b0 <memcpy+0x160>
    0.00 :	   848ab:       f3 48 a5                rep movsq %ds:(%rsi),%es:(%rdi)
    0.00 :	   848ae:       66 90                   xchg   %ax,%ax
    0.00 :	   848b0:       4c 29 da                sub    %r11,%rdx
    0.00 :	   848b3:       48 f7 c2 f8 ff ff ff    test   $0xfffffffffffffff8,%rdx
    0.00 :	   848ba:       75 14                   jne    848d0 <memcpy+0x180>
    0.00 :	   848bc:       83 e2 07                and    $0x7,%edx
    0.00 :	   848bf:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   848c4:       0f 85 8f fe ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   848ca:       f3 c3                   repz retq 
    0.00 :	   848cc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   848d0:       4c 8b 05 59 d8 2e 00    mov    0x2ed859(%rip),%r8        # 372130 <__x86_64_shared_cache_size_half>
    0.00 :	   848d7:       49 39 d0                cmp    %rdx,%r8
    0.00 :	   848da:       4c 0f 47 c2             cmova  %rdx,%r8
    0.00 :	   848de:       4c 89 c1                mov    %r8,%rcx
    0.00 :	   848e1:       49 83 e0 c0             and    $0xffffffffffffffc0,%r8
    0.00 :	   848e5:       48 c1 e9 06             shr    $0x6,%rcx
    0.00 :	   848e9:       0f 84 ab 01 00 00       je     84a9a <memcpy+0x34a>
    0.00 :	   848ef:       4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
    0.00 :	   848f4:       4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
    0.00 :	   848f9:       4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
    0.00 :	   848fe:       48 89 5c 24 d8          mov    %rbx,-0x28(%rsp)
    0.00 :	   84903:       83 3d 06 2b 2f 00 00    cmpl   $0x0,0x2f2b06(%rip)        # 377410 <__x86_64_prefetchw>
    0.00 :	   8490a:       0f 84 c0 00 00 00       je     849d0 <memcpy+0x280>
    0.00 :	   84910:       48 ff c9                dec    %rcx
    0.00 :	   84913:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84916:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   8491a:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8491e:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84922:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84926:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   8492a:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   8492e:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84932:       0f 18 8e 80 03 00 00    prefetcht0 0x380(%rsi)
    0.00 :	   84939:       0f 18 8e c0 03 00 00    prefetcht0 0x3c0(%rsi)
    0.00 :	   84940:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84943:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84947:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8494b:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8494f:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84953:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84957:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   8495b:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   8495f:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84963:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84967:       0f 84 19 01 00 00       je     84a86 <memcpy+0x336>
    0.00 :	   8496d:       48 ff c9                dec    %rcx
    0.00 :	   84970:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84973:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   84977:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   8497b:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   8497f:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84983:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84987:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   8498b:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   8498f:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84992:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84996:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   8499a:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   8499e:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   849a2:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   849a6:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   849aa:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   849ae:       0f 0d 8f 40 03 00 00    prefetchw 0x340(%rdi)
    0.00 :	   849b5:       0f 0d 8f 80 03 00 00    prefetchw 0x380(%rdi)
    0.00 :	   849bc:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   849c0:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   849c4:       0f 85 46 ff ff ff       jne    84910 <memcpy+0x1c0>
    0.00 :	   849ca:       e9 b7 00 00 00          jmpq   84a86 <memcpy+0x336>
    0.00 :	   849cf:       90                      nop
    0.00 :	   849d0:       48 ff c9                dec    %rcx
    0.00 :	   849d3:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   849d6:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   849da:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   849de:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   849e2:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   849e6:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   849ea:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   849ee:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   849f2:       0f 18 8e 80 03 00 00    prefetcht0 0x380(%rsi)
    0.00 :	   849f9:       0f 18 8e c0 03 00 00    prefetcht0 0x3c0(%rsi)
    0.00 :	   84a00:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84a03:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84a07:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84a0b:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84a0f:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84a13:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84a17:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   84a1b:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   84a1f:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84a23:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84a27:       74 5d                   je     84a86 <memcpy+0x336>
    0.00 :	   84a29:       48 ff c9                dec    %rcx
    0.00 :	   84a2c:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84a2f:       48 8b 5e 08             mov    0x8(%rsi),%rbx
    0.00 :	   84a33:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84a37:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84a3b:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84a3f:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84a43:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   84a47:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84a4b:       0f 18 8f 40 03 00 00    prefetcht0 0x340(%rdi)
    0.00 :	   84a52:       0f 18 8f 80 03 00 00    prefetcht0 0x380(%rdi)
    0.00 :	   84a59:       48 89 07                mov    %rax,(%rdi)
    0.00 :	   84a5c:       48 89 5f 08             mov    %rbx,0x8(%rdi)
    0.00 :	   84a60:       4c 89 4f 10             mov    %r9,0x10(%rdi)
    0.00 :	   84a64:       4c 89 57 18             mov    %r10,0x18(%rdi)
    0.00 :	   84a68:       4c 89 5f 20             mov    %r11,0x20(%rdi)
    0.00 :	   84a6c:       4c 89 67 28             mov    %r12,0x28(%rdi)
    0.00 :	   84a70:       4c 89 6f 30             mov    %r13,0x30(%rdi)
    0.00 :	   84a74:       4c 89 77 38             mov    %r14,0x38(%rdi)
    0.00 :	   84a78:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	   84a7c:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	   84a80:       0f 85 4a ff ff ff       jne    849d0 <memcpy+0x280>
    0.00 :	   84a86:       48 8b 5c 24 d8          mov    -0x28(%rsp),%rbx
    0.00 :	   84a8b:       4c 8b 64 24 e0          mov    -0x20(%rsp),%r12
    0.00 :	   84a90:       4c 8b 6c 24 e8          mov    -0x18(%rsp),%r13
    0.00 :	   84a95:       4c 8b 74 24 f0          mov    -0x10(%rsp),%r14
    0.00 :	   84a9a:       4c 29 c2                sub    %r8,%rdx
    0.00 :	   84a9d:       48 f7 c2 c0 ff ff ff    test   $0xffffffffffffffc0,%rdx
    0.00 :	   84aa4:       75 1a                   jne    84ac0 <memcpy+0x370>
    0.00 :	   84aa6:       83 e2 3f                and    $0x3f,%edx
    0.00 :	   84aa9:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84aae:       0f 85 a5 fc ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   84ab4:       f3 c3                   repz retq 
    0.00 :	   84ab6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	   84abd:       00 00 00 
    0.00 :	   84ac0:       48 89 d1                mov    %rdx,%rcx
    0.00 :	   84ac3:       48 c1 e9 07             shr    $0x7,%rcx
    0.00 :	   84ac7:       0f 84 d8 00 00 00       je     84ba5 <memcpy+0x455>
    0.00 :	   84acd:       4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
    0.00 :	   84ad2:       4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
    0.00 :	   84ad7:       4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
    0.00 :	   84adc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   84ae0:       0f 18 86 00 03 00 00    prefetchnta 0x300(%rsi)
    0.00 :	   84ae7:       0f 18 86 40 03 00 00    prefetchnta 0x340(%rsi)
    0.00 :	   84aee:       48 ff c9                dec    %rcx
    0.00 :	   84af1:       48 8b 06                mov    (%rsi),%rax
    0.00 :	   84af4:       4c 8b 46 08             mov    0x8(%rsi),%r8
    0.00 :	   84af8:       4c 8b 4e 10             mov    0x10(%rsi),%r9
    0.00 :	   84afc:       4c 8b 56 18             mov    0x18(%rsi),%r10
    0.00 :	   84b00:       4c 8b 5e 20             mov    0x20(%rsi),%r11
    0.00 :	   84b04:       4c 8b 66 28             mov    0x28(%rsi),%r12
    0.00 :	   84b08:       4c 8b 6e 30             mov    0x30(%rsi),%r13
    0.00 :	   84b0c:       4c 8b 76 38             mov    0x38(%rsi),%r14
    0.00 :	   84b10:       48 0f c3 07             movnti %rax,(%rdi)
    0.00 :	   84b14:       4c 0f c3 47 08          movnti %r8,0x8(%rdi)
    0.00 :	   84b19:       4c 0f c3 4f 10          movnti %r9,0x10(%rdi)
    0.00 :	   84b1e:       4c 0f c3 57 18          movnti %r10,0x18(%rdi)
    0.00 :	   84b23:       4c 0f c3 5f 20          movnti %r11,0x20(%rdi)
    0.00 :	   84b28:       4c 0f c3 67 28          movnti %r12,0x28(%rdi)
    0.00 :	   84b2d:       4c 0f c3 6f 30          movnti %r13,0x30(%rdi)
    0.00 :	   84b32:       4c 0f c3 77 38          movnti %r14,0x38(%rdi)
    0.00 :	   84b37:       48 8b 46 40             mov    0x40(%rsi),%rax
    0.00 :	   84b3b:       4c 8b 46 48             mov    0x48(%rsi),%r8
    0.00 :	   84b3f:       4c 8b 4e 50             mov    0x50(%rsi),%r9
    0.00 :	   84b43:       4c 8b 56 58             mov    0x58(%rsi),%r10
    0.00 :	   84b47:       4c 8b 5e 60             mov    0x60(%rsi),%r11
    0.00 :	   84b4b:       4c 8b 66 68             mov    0x68(%rsi),%r12
    0.00 :	   84b4f:       4c 8b 6e 70             mov    0x70(%rsi),%r13
    0.00 :	   84b53:       4c 8b 76 78             mov    0x78(%rsi),%r14
    0.00 :	   84b57:       48 0f c3 47 40          movnti %rax,0x40(%rdi)
    0.00 :	   84b5c:       4c 0f c3 47 48          movnti %r8,0x48(%rdi)
    0.00 :	   84b61:       4c 0f c3 4f 50          movnti %r9,0x50(%rdi)
    0.00 :	   84b66:       4c 0f c3 57 58          movnti %r10,0x58(%rdi)
    0.00 :	   84b6b:       4c 0f c3 5f 60          movnti %r11,0x60(%rdi)
    0.00 :	   84b70:       4c 0f c3 67 68          movnti %r12,0x68(%rdi)
    0.00 :	   84b75:       4c 0f c3 6f 70          movnti %r13,0x70(%rdi)
    0.00 :	   84b7a:       4c 0f c3 77 78          movnti %r14,0x78(%rdi)
    0.00 :	   84b7f:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	   84b86:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	   84b8d:       0f 85 4d ff ff ff       jne    84ae0 <memcpy+0x390>
    0.00 :	   84b93:       0f ae f8                sfence 
    0.00 :	   84b96:       4c 8b 64 24 e0          mov    -0x20(%rsp),%r12
    0.00 :	   84b9b:       4c 8b 6c 24 e8          mov    -0x18(%rsp),%r13
    0.00 :	   84ba0:       4c 8b 74 24 f0          mov    -0x10(%rsp),%r14
    0.00 :	   84ba5:       83 e2 7f                and    $0x7f,%edx
    0.00 :	   84ba8:       48 8b 44 24 f8          mov    -0x8(%rsp),%rax
    0.00 :	   84bad:       0f 85 a6 fb ff ff       jne    84759 <memcpy+0x9>
    0.00 :	   84bb3:       f3 c3                   repz retq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:517
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000490660 <hash_uint32>:
         :	        register uint32 a,
         :	                                b,
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
   20.00 :	  490660:       81 ef ac a9 8c 61       sub    $0x618ca9ac,%edi
         :	 *              hash_any(&k, sizeof(uint32))
         :	 * but is faster and doesn't force the caller to store k into memory.
         :	 */
         :	Datum
         :	hash_uint32(uint32 k)
         :	{
    0.00 :	  490666:       55                      push   %rbp
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
    0.00 :	  490667:       81 f7 64 d8 6a 2a       xor    $0x2a6ad864,%edi
    0.00 :	  49066d:       81 ef 53 21 c3 56       sub    $0x56c32153,%edi
         :	 *              hash_any(&k, sizeof(uint32))
         :	 * but is faster and doesn't force the caller to store k into memory.
         :	 */
         :	Datum
         :	hash_uint32(uint32 k)
         :	{
    0.00 :	  490673:       48 89 e5                mov    %rsp,%rbp
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
    0.00 :	  490676:       89 fe                   mov    %edi,%esi
    0.00 :	  490678:       89 f8                   mov    %edi,%eax
    0.00 :	  49067a:       c1 c8 07                ror    $0x7,%eax
    0.00 :	  49067d:       81 f6 54 56 73 9e       xor    $0x9e735654,%esi
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:519
   20.00 :	  490683:       29 c6                   sub    %eax,%esi
         :
         :	        /* report the result */
         :	        return UInt32GetDatum(c);
         :	}
    0.00 :	  490685:       c9                      leaveq 
         :	                                c;
         :
         :	        a = b = c = 0x9e3779b9 + (uint32) sizeof(uint32) + 3923095;
         :	        a += k;
         :
         :	        final(a, b, c);
   20.00 :	  490686:       89 f0                   mov    %esi,%eax
    0.00 :	  490688:       89 f2                   mov    %esi,%edx
    0.00 :	  49068a:       c1 ca 10                ror    $0x10,%edx
    0.00 :	  49068d:       35 64 d8 6a 2a          xor    $0x2a6ad864,%eax
   20.00 :	  490692:       29 d0                   sub    %edx,%eax
    0.00 :	  490694:       89 c2                   mov    %eax,%edx
    0.00 :	  490696:       89 c1                   mov    %eax,%ecx
    0.00 :	  490698:       c1 c9 1c                ror    $0x1c,%ecx
   20.00 :	  49069b:       31 fa                   xor    %edi,%edx
    0.00 :	  49069d:       29 ca                   sub    %ecx,%edx
    0.00 :	  49069f:       89 d1                   mov    %edx,%ecx
    0.00 :	  4906a1:       c1 ca 12                ror    $0x12,%edx
    0.00 :	  4906a4:       31 f1                   xor    %esi,%ecx
    0.00 :	  4906a6:       29 d1                   sub    %edx,%ecx
    0.00 :	  4906a8:       31 c8                   xor    %ecx,%eax
    0.00 :	  4906aa:       c1 c9 08                ror    $0x8,%ecx
    0.00 :	  4906ad:       29 c8                   sub    %ecx,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1101
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1114
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1149
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1138
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1202
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ac3e0 <_bt_readpage>:
         :	 *
         :	 * Returns true if any matching items found on the page, false if none.
         :	 */
         :	static bool
         :	_bt_readpage(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1101
   20.00 :	  4ac3e0:       55                      push   %rbp
    0.00 :	  4ac3e1:       89 d1                   mov    %edx,%ecx
    0.00 :	  4ac3e3:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ac3e6:       41 57                   push   %r15
    0.00 :	  4ac3e8:       41 56                   push   %r14
    0.00 :	  4ac3ea:       41 55                   push   %r13
    0.00 :	  4ac3ec:       41 54                   push   %r12
    0.00 :	  4ac3ee:       53                      push   %rbx
    0.00 :	  4ac3ef:       48 83 ec 58             sub    $0x58,%rsp
    0.00 :	  4ac3f3:       48 89 7d 98             mov    %rdi,-0x68(%rbp)
    0.00 :	  4ac3f7:       89 75 94                mov    %esi,-0x6c(%rbp)
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4ac3fa:       4c 8b 67 38             mov    0x38(%rdi),%r12
         :	        bool            continuescan;
         :
         :	        /* we must have the buffer pinned and locked */
         :	        Assert(BufferIsValid(so->currPos.buf));
         :
         :	        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4ac3fe:       41 8b 44 24 54          mov    0x54(%r12),%eax
    0.00 :	  4ac403:       85 c0                   test   %eax,%eax
    0.00 :	  4ac405:       0f 88 55 02 00 00       js     4ac660 <_bt_readpage+0x280>
    0.00 :	  4ac40b:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4ac40e:       4c 63 f8                movslq %eax,%r15
    0.00 :	  4ac411:       49 c1 e7 0d             shl    $0xd,%r15
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1114
   20.00 :	  4ac415:       4c 03 3d dc 36 71 00    add    0x7136dc(%rip),%r15        # bbfaf8 <BufferBlocks>
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	        minoff = P_FIRSTDATAKEY(opaque);
    0.00 :	  4ac41c:       41 0f b7 47 10          movzwl 0x10(%r15),%eax
    0.00 :	  4ac421:       41 8b 54 07 04          mov    0x4(%r15,%rax,1),%edx
    0.00 :	  4ac426:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  4ac429:       19 c0                   sbb    %eax,%eax
    0.00 :	  4ac42b:       83 c0 02                add    $0x2,%eax
    0.00 :	  4ac42e:       66 89 45 a0             mov    %ax,-0x60(%rbp)
         :	        maxoff = PageGetMaxOffsetNumber(page);
    0.00 :	  4ac432:       41 0f b7 47 0c          movzwl 0xc(%r15),%eax
    0.00 :	  4ac437:       66 c7 45 b0 00 00       movw   $0x0,-0x50(%rbp)
    0.00 :	  4ac43d:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4ac441:       76 0f                   jbe    4ac452 <_bt_readpage+0x72>
    0.00 :	  4ac443:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4ac446:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4ac44a:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4ac44e:       66 89 45 b0             mov    %ax,-0x50(%rbp)
         :	        /*
         :	         * we must save the page's right-link while scanning it; this tells us
         :	         * where to step right to after we're done with these items.  There is no
         :	         * corresponding need for the left-link, since splits always go right.
         :	         */
         :	        so->currPos.nextPage = opaque->btpo_next;
    0.00 :	  4ac452:       41 89 54 24 58          mov    %edx,0x58(%r12)
         :
         :	        /* initialize tuple workspace to empty */
         :	        so->currPos.nextTupleOffset = 0;
    0.00 :	  4ac457:       41 c7 44 24 60 00 00    movl   $0x0,0x60(%r12)
    0.00 :	  4ac45e:       00 00 
         :
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ac460:       83 7d 94 01             cmpl   $0x1,-0x6c(%rbp)
    0.00 :	  4ac464:       0f 84 06 01 00 00       je     4ac570 <_bt_readpage+0x190>
         :	        else
         :	        {
         :	                /* load items[] in descending order */
         :	                itemIndex = MaxIndexTuplesPerPage;
         :
         :	                offnum = Min(offnum, maxoff);
    0.00 :	  4ac46a:       66 39 4d b0             cmp    %cx,-0x50(%rbp)
    0.00 :	  4ac46e:       44 0f b7 6d b0          movzwl -0x50(%rbp),%r13d
    0.00 :	  4ac473:       48 8d 45 cf             lea    -0x31(%rbp),%rax
         :
         :	                while (offnum >= minoff)
    0.00 :	  4ac477:       41 be 98 01 00 00       mov    $0x198,%r14d
    0.00 :	  4ac47d:       48 89 45 88             mov    %rax,-0x78(%rbp)
         :	        else
         :	        {
         :	                /* load items[] in descending order */
         :	                itemIndex = MaxIndexTuplesPerPage;
         :
         :	                offnum = Min(offnum, maxoff);
    0.00 :	  4ac481:       44 0f 47 e9             cmova  %ecx,%r13d
         :
         :	                while (offnum >= minoff)
    0.00 :	  4ac485:       66 44 39 6d a0          cmp    %r13w,-0x60(%rbp)
    0.00 :	  4ac48a:       76 1b                   jbe    4ac4a7 <_bt_readpage+0xc7>
    0.00 :	  4ac48c:       e9 a2 00 00 00          jmpq   4ac533 <_bt_readpage+0x153>
    0.00 :	  4ac491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        }
         :	                        if (!continuescan)
         :	                        {
         :	                                /* there can't be any more matches, so stop */
         :	                                so->currPos.moreLeft = false;
         :	                                break;
    0.00 :	  4ac498:       41 83 ed 01             sub    $0x1,%r13d
         :	                /* load items[] in descending order */
         :	                itemIndex = MaxIndexTuplesPerPage;
         :
         :	                offnum = Min(offnum, maxoff);
         :
         :	                while (offnum >= minoff)
    0.00 :	  4ac49c:       66 44 39 6d a0          cmp    %r13w,-0x60(%rbp)
    0.00 :	  4ac4a1:       0f 87 8c 00 00 00       ja     4ac533 <_bt_readpage+0x153>
         :	                {
         :	                        itup = _bt_checkkeys(scan, page, offnum, dir, &continuescan);
    0.00 :	  4ac4a7:       8b 4d 94                mov    -0x6c(%rbp),%ecx
    0.00 :	  4ac4aa:       4c 8b 45 88             mov    -0x78(%rbp),%r8
    0.00 :	  4ac4ae:       41 0f b7 d5             movzwl %r13w,%edx
    0.00 :	  4ac4b2:       48 8b 7d 98             mov    -0x68(%rbp),%rdi
    0.00 :	  4ac4b6:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  4ac4b9:       e8 62 1f 00 00          callq  4ae420 <_bt_checkkeys>
         :	                        if (itup != NULL)
    0.00 :	  4ac4be:       48 85 c0                test   %rax,%rax
         :
         :	                offnum = Min(offnum, maxoff);
         :
         :	                while (offnum >= minoff)
         :	                {
         :	                        itup = _bt_checkkeys(scan, page, offnum, dir, &continuescan);
    0.00 :	  4ac4c1:       48 89 c1                mov    %rax,%rcx
         :	                        if (itup != NULL)
    0.00 :	  4ac4c4:       74 5d                   je     4ac523 <_bt_readpage+0x143>
         :	                        {
         :	                                /* tuple passes all scan key conditions, so remember it */
         :	                                itemIndex--;
    0.00 :	  4ac4c6:       41 83 ee 01             sub    $0x1,%r14d
         :	/* Save an index item into so->currPos.items[itemIndex] */
         :	static void
         :	_bt_saveitem(BTScanOpaque so, int itemIndex,
         :	                         OffsetNumber offnum, IndexTuple itup)
         :	{
         :	        BTScanPosItem *currItem = &so->currPos.items[itemIndex];
    0.00 :	  4ac4ca:       49 63 c6                movslq %r14d,%rax
         :
         :	        currItem->heapTid = itup->t_tid;
    0.00 :	  4ac4cd:       48 8d 04 80             lea    (%rax,%rax,4),%rax
    0.00 :	  4ac4d1:       49 8d 54 44 60          lea    0x60(%r12,%rax,2),%rdx
    0.00 :	  4ac4d6:       8b 01                   mov    (%rcx),%eax
    0.00 :	  4ac4d8:       89 42 10                mov    %eax,0x10(%rdx)
    0.00 :	  4ac4db:       0f b7 41 04             movzwl 0x4(%rcx),%eax
         :	        currItem->indexOffset = offnum;
    0.00 :	  4ac4df:       66 44 89 6a 16          mov    %r13w,0x16(%rdx)
         :	_bt_saveitem(BTScanOpaque so, int itemIndex,
         :	                         OffsetNumber offnum, IndexTuple itup)
         :	{
         :	        BTScanPosItem *currItem = &so->currPos.items[itemIndex];
         :
         :	        currItem->heapTid = itup->t_tid;
    0.00 :	  4ac4e4:       66 89 42 14             mov    %ax,0x14(%rdx)
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
    0.00 :	  4ac4e8:       49 83 7c 24 40 00       cmpq   $0x0,0x40(%r12)
    0.00 :	  4ac4ee:       74 33                   je     4ac523 <_bt_readpage+0x143>
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
    0.00 :	  4ac4f0:       41 8b 44 24 60          mov    0x60(%r12),%eax
         :
         :	        currItem->heapTid = itup->t_tid;
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
    0.00 :	  4ac4f5:       0f b7 59 06             movzwl 0x6(%rcx),%ebx
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac4f9:       48 89 ce                mov    %rcx,%rsi
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
    0.00 :	  4ac4fc:       66 89 42 18             mov    %ax,0x18(%rdx)
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac500:       49 63 7c 24 60          movslq 0x60(%r12),%rdi
    0.00 :	  4ac505:       49 03 7c 24 40          add    0x40(%r12),%rdi
         :
         :	        currItem->heapTid = itup->t_tid;
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
    0.00 :	  4ac50a:       81 e3 ff 1f 00 00       and    $0x1fff,%ebx
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac510:       48 89 da                mov    %rbx,%rdx
         :	                so->currPos.nextTupleOffset += MAXALIGN(itupsz);
    0.00 :	  4ac513:       83 c3 07                add    $0x7,%ebx
    0.00 :	  4ac516:       83 e3 f8                and    $0xfffffff8,%ebx
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac519:       e8 d2 d6 fb ff          callq  469bf0 <memcpy@plt>
         :	                so->currPos.nextTupleOffset += MAXALIGN(itupsz);
    0.00 :	  4ac51e:       41 01 5c 24 60          add    %ebx,0x60(%r12)
         :	                        {
         :	                                /* tuple passes all scan key conditions, so remember it */
         :	                                itemIndex--;
         :	                                _bt_saveitem(so, itemIndex, offnum, itup);
         :	                        }
         :	                        if (!continuescan)
    0.00 :	  4ac523:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4ac527:       0f 85 6b ff ff ff       jne    4ac498 <_bt_readpage+0xb8>
         :	                        {
         :	                                /* there can't be any more matches, so stop */
         :	                                so->currPos.moreLeft = false;
    0.00 :	  4ac52d:       41 c6 44 24 5c 00       movb   $0x0,0x5c(%r12)
         :
         :	                        offnum = OffsetNumberPrev(offnum);
         :	                }
         :
         :	                Assert(itemIndex >= 0);
         :	                so->currPos.firstItem = itemIndex;
    0.00 :	  4ac533:       45 89 74 24 64          mov    %r14d,0x64(%r12)
         :	                so->currPos.lastItem = MaxIndexTuplesPerPage - 1;
    0.00 :	  4ac538:       41 c7 44 24 68 97 01    movl   $0x197,0x68(%r12)
    0.00 :	  4ac53f:       00 00 
         :	                so->currPos.itemIndex = MaxIndexTuplesPerPage - 1;
    0.00 :	  4ac541:       41 c7 44 24 6c 97 01    movl   $0x197,0x6c(%r12)
    0.00 :	  4ac548:       00 00 
    0.00 :	  4ac54a:       41 8b 44 24 64          mov    0x64(%r12),%eax
    0.00 :	  4ac54f:       41 3b 44 24 68          cmp    0x68(%r12),%eax
    0.00 :	  4ac554:       0f 9e c0                setle  %al
         :	        }
         :
         :	        return (so->currPos.firstItem <= so->currPos.lastItem);
         :	}
    0.00 :	  4ac557:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  4ac55b:       5b                      pop    %rbx
    0.00 :	  4ac55c:       41 5c                   pop    %r12
    0.00 :	  4ac55e:       41 5d                   pop    %r13
    0.00 :	  4ac560:       41 5e                   pop    %r14
    0.00 :	  4ac562:       41 5f                   pop    %r15
    0.00 :	  4ac564:       c9                      leaveq 
    0.00 :	  4ac565:       c3                      retq   
    0.00 :	  4ac566:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4ac56d:       00 00 00 
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                /* load items[] in ascending order */
         :	                itemIndex = 0;
         :
         :	                offnum = Max(offnum, minoff);
    0.00 :	  4ac570:       66 39 4d a0             cmp    %cx,-0x60(%rbp)
    0.00 :	  4ac574:       44 0f b7 6d a0          movzwl -0x60(%rbp),%r13d
    0.00 :	  4ac579:       48 8d 45 cf             lea    -0x31(%rbp),%rax
    0.00 :	  4ac57d:       48 89 45 88             mov    %rax,-0x78(%rbp)
         :
         :	                while (offnum <= maxoff)
    0.00 :	  4ac581:       b8 ff ff ff ff          mov    $0xffffffff,%eax
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                /* load items[] in ascending order */
         :	                itemIndex = 0;
         :
         :	                offnum = Max(offnum, minoff);
    0.00 :	  4ac586:       44 0f 42 e9             cmovb  %ecx,%r13d
         :
         :	                while (offnum <= maxoff)
    0.00 :	  4ac58a:       45 31 f6                xor    %r14d,%r14d
    0.00 :	  4ac58d:       66 44 39 6d b0          cmp    %r13w,-0x50(%rbp)
    0.00 :	  4ac592:       73 1b                   jae    4ac5af <_bt_readpage+0x1cf>
    0.00 :	  4ac594:       e9 a8 00 00 00          jmpq   4ac641 <_bt_readpage+0x261>
    0.00 :	  4ac599:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        }
         :	                        if (!continuescan)
         :	                        {
         :	                                /* there can't be any more matches, so stop */
         :	                                so->currPos.moreRight = false;
         :	                                break;
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1149
   20.00 :	  4ac5a0:       41 83 c5 01             add    $0x1,%r13d
         :	                /* load items[] in ascending order */
         :	                itemIndex = 0;
         :
         :	                offnum = Max(offnum, minoff);
         :
         :	                while (offnum <= maxoff)
    0.00 :	  4ac5a4:       66 44 3b 6d b0          cmp    -0x50(%rbp),%r13w
    0.00 :	  4ac5a9:       0f 87 c9 00 00 00       ja     4ac678 <_bt_readpage+0x298>
         :	                {
         :	                        itup = _bt_checkkeys(scan, page, offnum, dir, &continuescan);
    0.00 :	  4ac5af:       4c 8b 45 88             mov    -0x78(%rbp),%r8
    0.00 :	  4ac5b3:       48 8b 7d 98             mov    -0x68(%rbp),%rdi
    0.00 :	  4ac5b7:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ac5bc:       41 0f b7 d5             movzwl %r13w,%edx
    0.00 :	  4ac5c0:       4c 89 fe                mov    %r15,%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1138
   20.00 :	  4ac5c3:       e8 58 1e 00 00          callq  4ae420 <_bt_checkkeys>
         :	                        if (itup != NULL)
    0.00 :	  4ac5c8:       48 85 c0                test   %rax,%rax
         :
         :	                offnum = Max(offnum, minoff);
         :
         :	                while (offnum <= maxoff)
         :	                {
         :	                        itup = _bt_checkkeys(scan, page, offnum, dir, &continuescan);
    0.00 :	  4ac5cb:       48 89 c1                mov    %rax,%rcx
         :	                        if (itup != NULL)
    0.00 :	  4ac5ce:       74 5d                   je     4ac62d <_bt_readpage+0x24d>
         :	/* Save an index item into so->currPos.items[itemIndex] */
         :	static void
         :	_bt_saveitem(BTScanOpaque so, int itemIndex,
         :	                         OffsetNumber offnum, IndexTuple itup)
         :	{
         :	        BTScanPosItem *currItem = &so->currPos.items[itemIndex];
    0.00 :	  4ac5d0:       49 63 c6                movslq %r14d,%rax
         :
         :	        currItem->heapTid = itup->t_tid;
    0.00 :	  4ac5d3:       48 8d 04 80             lea    (%rax,%rax,4),%rax
    0.00 :	  4ac5d7:       49 8d 54 44 60          lea    0x60(%r12,%rax,2),%rdx
    0.00 :	  4ac5dc:       8b 01                   mov    (%rcx),%eax
    0.00 :	  4ac5de:       89 42 10                mov    %eax,0x10(%rdx)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1202
   20.00 :	  4ac5e1:       0f b7 41 04             movzwl 0x4(%rcx),%eax
         :	        currItem->indexOffset = offnum;
    0.00 :	  4ac5e5:       66 44 89 6a 16          mov    %r13w,0x16(%rdx)
         :	_bt_saveitem(BTScanOpaque so, int itemIndex,
         :	                         OffsetNumber offnum, IndexTuple itup)
         :	{
         :	        BTScanPosItem *currItem = &so->currPos.items[itemIndex];
         :
         :	        currItem->heapTid = itup->t_tid;
    0.00 :	  4ac5ea:       66 89 42 14             mov    %ax,0x14(%rdx)
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
    0.00 :	  4ac5ee:       49 83 7c 24 40 00       cmpq   $0x0,0x40(%r12)
    0.00 :	  4ac5f4:       74 33                   je     4ac629 <_bt_readpage+0x249>
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
    0.00 :	  4ac5f6:       41 8b 44 24 60          mov    0x60(%r12),%eax
         :
         :	        currItem->heapTid = itup->t_tid;
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
    0.00 :	  4ac5fb:       0f b7 59 06             movzwl 0x6(%rcx),%ebx
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac5ff:       48 89 ce                mov    %rcx,%rsi
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
    0.00 :	  4ac602:       66 89 42 18             mov    %ax,0x18(%rdx)
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac606:       49 63 7c 24 60          movslq 0x60(%r12),%rdi
    0.00 :	  4ac60b:       49 03 7c 24 40          add    0x40(%r12),%rdi
         :
         :	        currItem->heapTid = itup->t_tid;
         :	        currItem->indexOffset = offnum;
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
    0.00 :	  4ac610:       81 e3 ff 1f 00 00       and    $0x1fff,%ebx
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac616:       48 89 da                mov    %rbx,%rdx
         :	                so->currPos.nextTupleOffset += MAXALIGN(itupsz);
    0.00 :	  4ac619:       83 c3 07                add    $0x7,%ebx
    0.00 :	  4ac61c:       83 e3 f8                and    $0xfffffff8,%ebx
         :	        if (so->currTuples)
         :	        {
         :	                Size            itupsz = IndexTupleSize(itup);
         :
         :	                currItem->tupleOffset = so->currPos.nextTupleOffset;
         :	                memcpy(so->currTuples + so->currPos.nextTupleOffset, itup, itupsz);
    0.00 :	  4ac61f:       e8 cc d5 fb ff          callq  469bf0 <memcpy@plt>
         :	                so->currPos.nextTupleOffset += MAXALIGN(itupsz);
    0.00 :	  4ac624:       41 01 5c 24 60          add    %ebx,0x60(%r12)
         :	                        itup = _bt_checkkeys(scan, page, offnum, dir, &continuescan);
         :	                        if (itup != NULL)
         :	                        {
         :	                                /* tuple passes all scan key conditions, so remember it */
         :	                                _bt_saveitem(so, itemIndex, offnum, itup);
         :	                                itemIndex++;
    0.00 :	  4ac629:       41 83 c6 01             add    $0x1,%r14d
         :	                        }
         :	                        if (!continuescan)
    0.00 :	  4ac62d:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4ac631:       0f 85 69 ff ff ff       jne    4ac5a0 <_bt_readpage+0x1c0>
         :	                        {
         :	                                /* there can't be any more matches, so stop */
         :	                                so->currPos.moreRight = false;
    0.00 :	  4ac637:       41 8d 46 ff             lea    -0x1(%r14),%eax
    0.00 :	  4ac63b:       41 c6 44 24 5d 00       movb   $0x0,0x5d(%r12)
         :
         :	                        offnum = OffsetNumberNext(offnum);
         :	                }
         :
         :	                Assert(itemIndex <= MaxIndexTuplesPerPage);
         :	                so->currPos.firstItem = 0;
    0.00 :	  4ac641:       41 c7 44 24 64 00 00    movl   $0x0,0x64(%r12)
    0.00 :	  4ac648:       00 00 
         :	                so->currPos.lastItem = itemIndex - 1;
    0.00 :	  4ac64a:       41 89 44 24 68          mov    %eax,0x68(%r12)
         :	                so->currPos.itemIndex = 0;
    0.00 :	  4ac64f:       41 c7 44 24 6c 00 00    movl   $0x0,0x6c(%r12)
    0.00 :	  4ac656:       00 00 
    0.00 :	  4ac658:       e9 ed fe ff ff          jmpq   4ac54a <_bt_readpage+0x16a>
    0.00 :	  4ac65d:       0f 1f 00                nopl   (%rax)
         :	        bool            continuescan;
         :
         :	        /* we must have the buffer pinned and locked */
         :	        Assert(BufferIsValid(so->currPos.buf));
         :
         :	        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4ac660:       f7 d0                   not    %eax
    0.00 :	  4ac662:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac665:       48 8b 05 ac 0a 6d 00    mov    0x6d0aac(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac66c:       4c 8b 3c d0             mov    (%rax,%rdx,8),%r15
    0.00 :	  4ac670:       e9 a7 fd ff ff          jmpq   4ac41c <_bt_readpage+0x3c>
    0.00 :	  4ac675:       0f 1f 00                nopl   (%rax)
         :	                /* load items[] in ascending order */
         :	                itemIndex = 0;
         :
         :	                offnum = Max(offnum, minoff);
         :
         :	                while (offnum <= maxoff)
    0.00 :	  4ac678:       41 8d 46 ff             lea    -0x1(%r14),%eax
    0.00 :	  4ac67c:       eb c3                   jmp    4ac641 <_bt_readpage+0x261>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   80.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1057
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1051
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005aca20 <ExecEvalConst>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1051
   20.00 :	  5aca20:       55                      push   %rbp
         :	        Const      *con = (Const *) exprstate->expr;
         :
         :	        if (isDone)
    0.00 :	  5aca21:       48 85 c9                test   %rcx,%rcx
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
         :	        Const      *con = (Const *) exprstate->expr;
    0.00 :	  5aca24:       48 8b 77 08             mov    0x8(%rdi),%rsi
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalConst(ExprState *exprstate, ExprContext *econtext,
         :	                          bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5aca28:       48 89 e5                mov    %rsp,%rbp
         :	        Const      *con = (Const *) exprstate->expr;
         :
         :	        if (isDone)
    0.00 :	  5aca2b:       74 06                   je     5aca33 <ExecEvalConst+0x13>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5aca2d:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        *isNull = con->constisnull;
    0.00 :	  5aca33:       0f b6 46 20             movzbl 0x20(%rsi),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1057
   80.00 :	  5aca37:       88 02                   mov    %al,(%rdx)
    0.00 :	  5aca39:       48 8b 46 18             mov    0x18(%rsi),%rax
         :	        return con->constvalue;
         :	}
    0.00 :	  5aca3d:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1025
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1025
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1029
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1038
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1040
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bbac0 <ExecHashGetBucketAndBatch>:
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1025
   20.00 :	  5bbac0:       55                      push   %rbp
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
    0.00 :	  5bbac1:       44 8b 47 40             mov    0x40(%rdi),%r8d
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
    0.00 :	  5bbac5:       49 89 c9                mov    %rcx,%r9
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
    0.00 :	  5bbac8:       8b 07                   mov    (%rdi),%eax
         :	void
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
   20.00 :	  5bbaca:       48 89 e5                mov    %rsp,%rbp
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1029
   20.00 :	  5bbacd:       41 83 f8 01             cmp    $0x1,%r8d
    0.00 :	  5bbad1:       76 1d                   jbe    5bbaf0 <ExecHashGetBucketAndBatch+0x30>
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bbad3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bbad6:       21 f0                   and    %esi,%eax
    0.00 :	  5bbad8:       89 02                   mov    %eax,(%rdx)
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bbada:       8b 4f 04                mov    0x4(%rdi),%ecx
    0.00 :	  5bbadd:       41 8d 40 ff             lea    -0x1(%r8),%eax
    0.00 :	  5bbae1:       d3 ee                   shr    %cl,%esi
    0.00 :	  5bbae3:       21 f0                   and    %esi,%eax
    0.00 :	  5bbae5:       41 89 01                mov    %eax,(%r9)
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = 0;
         :	        }
         :	}
    0.00 :	  5bbae8:       c9                      leaveq 
    0.00 :	  5bbae9:       c3                      retq   
    0.00 :	  5bbaea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
         :	        }
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bbaf0:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5bbaf3:       21 f0                   and    %esi,%eax
    0.00 :	  5bbaf5:       89 02                   mov    %eax,(%rdx)
         :	                *batchno = 0;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1038
   20.00 :	  5bbaf7:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :	        }
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:1040
   20.00 :	  5bbafd:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:85
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:50
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:78
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:114
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bf570 <IndexNext>:
         :	 *              using the index specified in the IndexScanState information.
         :	 * ----------------------------------------------------------------
         :	 */
         :	static TupleTableSlot *
         :	IndexNext(IndexScanState *node)
         :	{
    0.00 :	  5bf570:       55                      push   %rbp
    0.00 :	  5bf571:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bf574:       41 57                   push   %r15
    0.00 :	  5bf576:       41 56                   push   %r14
    0.00 :	  5bf578:       41 55                   push   %r13
    0.00 :	  5bf57a:       49 89 fd                mov    %rdi,%r13
    0.00 :	  5bf57d:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:50
   20.00 :	  5bf57f:       53                      push   %rbx
    0.00 :	  5bf580:       48 83 ec 08             sub    $0x8,%rsp
         :
         :	        /*
         :	         * extract necessary information from index scan node
         :	         */
         :	        estate = node->ss.ps.state;
         :	        direction = estate->es_direction;
    0.00 :	  5bf584:       48 8b 47 10             mov    0x10(%rdi),%rax
    0.00 :	  5bf588:       44 8b 78 04             mov    0x4(%rax),%r15d
         :	        /* flip direction if this is an overall backward scan */
         :	        if (ScanDirectionIsBackward(((IndexScan *) node->ss.ps.plan)->indexorderdir))
    0.00 :	  5bf58c:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5bf590:       83 b8 90 00 00 00 ff    cmpl   $0xffffffff,0x90(%rax)
    0.00 :	  5bf597:       0f 84 b3 00 00 00       je     5bf650 <IndexNext+0xe0>
         :	                if (ScanDirectionIsForward(direction))
         :	                        direction = BackwardScanDirection;
         :	                else if (ScanDirectionIsBackward(direction))
         :	                        direction = ForwardScanDirection;
         :	        }
         :	        scandesc = node->iss_ScanDesc;
    0.00 :	  5bf59d:       49 8b 9d d8 00 00 00    mov    0xd8(%r13),%rbx
         :	        econtext = node->ss.ps.ps_ExprContext;
    0.00 :	  5bf5a4:       4d 8b 65 60             mov    0x60(%r13),%r12
         :	        slot = node->ss.ss_ScanTupleSlot;
    0.00 :	  5bf5a8:       4d 8b b5 88 00 00 00    mov    0x88(%r13),%r14
    0.00 :	  5bf5af:       90                      nop
         :
         :	        /*
         :	         * ok, now that we have what we need, fetch the next tuple.
         :	         */
         :	        while ((tuple = index_getnext(scandesc, direction)) != NULL)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:78
   20.00 :	  5bf5b0:       44 89 fe                mov    %r15d,%esi
    0.00 :	  5bf5b3:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5bf5b6:       e8 55 61 ee ff          callq  4a5710 <index_getnext>
    0.00 :	  5bf5bb:       48 85 c0                test   %rax,%rax
    0.00 :	  5bf5be:       74 78                   je     5bf638 <IndexNext+0xc8>
         :	                /*
         :	                 * Store the scanned tuple in the scan tuple slot of the scan state.
         :	                 * Note: we pass 'false' because tuples returned by amgetnext are
         :	                 * pointers onto disk pages and must not be pfree()'d.
         :	                 */
         :	                ExecStoreTuple(tuple,   /* tuple to store */
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:85
   40.00 :	  5bf5c0:       8b 53 68                mov    0x68(%rbx),%edx
    0.00 :	  5bf5c3:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5bf5c5:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5bf5c8:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5bf5cb:       e8 b0 4e ff ff          callq  5b4480 <ExecStoreTuple>
         :
         :	                /*
         :	                 * If the index was lossy, we have to recheck the index quals using
         :	                 * the fetched tuple.
         :	                 */
         :	                if (scandesc->xs_recheck)
    0.00 :	  5bf5d0:       80 7b 6c 00             cmpb   $0x0,0x6c(%rbx)
    0.00 :	  5bf5d4:       74 4a                   je     5bf620 <IndexNext+0xb0>
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
         :	                        ResetExprContext(econtext);
    0.00 :	  5bf5d6:       49 8b 7c 24 28          mov    0x28(%r12),%rdi
         :	                 * If the index was lossy, we have to recheck the index quals using
         :	                 * the fetched tuple.
         :	                 */
         :	                if (scandesc->xs_recheck)
         :	                {
         :	                        econtext->ecxt_scantuple = slot;
    0.00 :	  5bf5db:       4d 89 74 24 08          mov    %r14,0x8(%r12)
         :	                        ResetExprContext(econtext);
    0.00 :	  5bf5e0:       e8 cb 93 1d 00          callq  7989b0 <MemoryContextReset>
         :	                        if (!ExecQual(node->indexqualorig, econtext, false))
    0.00 :	  5bf5e5:       49 8b bd 90 00 00 00    mov    0x90(%r13),%rdi
    0.00 :	  5bf5ec:       31 d2                   xor    %edx,%edx
    0.00 :	  5bf5ee:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5bf5f1:       e8 1a d9 fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5bf5f6:       84 c0                   test   %al,%al
    0.00 :	  5bf5f8:       75 26                   jne    5bf620 <IndexNext+0xb0>
         :	                        {
         :	                                /* Fails recheck, so drop it and loop back for another */
         :	                                InstrCountFiltered2(node, 1);
    0.00 :	  5bf5fa:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  5bf5fe:       48 85 c0                test   %rax,%rax
    0.00 :	  5bf601:       74 ad                   je     5bf5b0 <IndexNext+0x40>
    0.00 :	  5bf603:       f2 0f 10 05 4d fb 1e    movsd  0x1efb4d(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5bf60a:       00 
    0.00 :	  5bf60b:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5bf612:       00 
    0.00 :	  5bf613:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5bf61a:       00 
    0.00 :	  5bf61b:       eb 93                   jmp    5bf5b0 <IndexNext+0x40>
    0.00 :	  5bf61d:       0f 1f 00                nopl   (%rax)
         :	        /*
         :	         * if we get here it means the index scan failed so we are at the end of
         :	         * the scan..
         :	         */
         :	        return ExecClearTuple(slot);
         :	}
    0.00 :	  5bf620:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5bf624:       4c 89 f0                mov    %r14,%rax
    0.00 :	  5bf627:       5b                      pop    %rbx
    0.00 :	  5bf628:       41 5c                   pop    %r12
    0.00 :	  5bf62a:       41 5d                   pop    %r13
    0.00 :	  5bf62c:       41 5e                   pop    %r14
    0.00 :	  5bf62e:       41 5f                   pop    %r15
    0.00 :	  5bf630:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:114
   20.00 :	  5bf631:       c3                      retq   
    0.00 :	  5bf632:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5bf638:       48 83 c4 08             add    $0x8,%rsp
         :
         :	        /*
         :	         * if we get here it means the index scan failed so we are at the end of
         :	         * the scan..
         :	         */
         :	        return ExecClearTuple(slot);
    0.00 :	  5bf63c:       4c 89 f7                mov    %r14,%rdi
         :	}
    0.00 :	  5bf63f:       5b                      pop    %rbx
    0.00 :	  5bf640:       41 5c                   pop    %r12
    0.00 :	  5bf642:       41 5d                   pop    %r13
    0.00 :	  5bf644:       41 5e                   pop    %r14
    0.00 :	  5bf646:       41 5f                   pop    %r15
    0.00 :	  5bf648:       c9                      leaveq 
         :
         :	        /*
         :	         * if we get here it means the index scan failed so we are at the end of
         :	         * the scan..
         :	         */
         :	        return ExecClearTuple(slot);
    0.00 :	  5bf649:       e9 c2 4a ff ff          jmpq   5b4110 <ExecClearTuple>
    0.00 :	  5bf64e:       66 90                   xchg   %ax,%ax
         :	        estate = node->ss.ps.state;
         :	        direction = estate->es_direction;
         :	        /* flip direction if this is an overall backward scan */
         :	        if (ScanDirectionIsBackward(((IndexScan *) node->ss.ps.plan)->indexorderdir))
         :	        {
         :	                if (ScanDirectionIsForward(direction))
    0.00 :	  5bf650:       41 83 ff 01             cmp    $0x1,%r15d
    0.00 :	  5bf654:       74 12                   je     5bf668 <IndexNext+0xf8>
         :	                        direction = BackwardScanDirection;
         :	                else if (ScanDirectionIsBackward(direction))
    0.00 :	  5bf656:       41 83 ff ff             cmp    $0xffffffff,%r15d
    0.00 :	  5bf65a:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5bf65f:       44 0f 44 f8             cmove  %eax,%r15d
    0.00 :	  5bf663:       e9 35 ff ff ff          jmpq   5bf59d <IndexNext+0x2d>
         :	        estate = node->ss.ps.state;
         :	        direction = estate->es_direction;
         :	        /* flip direction if this is an overall backward scan */
         :	        if (ScanDirectionIsBackward(((IndexScan *) node->ss.ps.plan)->indexorderdir))
         :	        {
         :	                if (ScanDirectionIsForward(direction))
    0.00 :	  5bf668:       41 bf ff ff ff ff       mov    $0xffffffff,%r15d
    0.00 :	  5bf66e:       e9 2a ff ff ff          jmpq   5bf59d <IndexNext+0x2d>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006425d0 <pgstat_end_function_usage>:
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:1576
   20.00 :	  6425d0:       55                      push   %rbp
   40.00 :	  6425d1:       48 89 e5                mov    %rsp,%rbp
   20.00 :	  6425d4:       41 55                   push   %r13
   20.00 :	  6425d6:       41 89 f5                mov    %esi,%r13d
    0.00 :	  6425d9:       41 54                   push   %r12
    0.00 :	  6425db:       49 89 fc                mov    %rdi,%r12
    0.00 :	  6425de:       53                      push   %rbx
    0.00 :	  6425df:       48 83 ec 18             sub    $0x18,%rsp
         :	        PgStat_FunctionCounts *fs = fcu->fs;
    0.00 :	  6425e3:       48 8b 1f                mov    (%rdi),%rbx
         :	        instr_time      f_total;
         :	        instr_time      f_others;
         :	        instr_time      f_self;
         :
         :	        /* stats not wanted? */
         :	        if (fs == NULL)
    0.00 :	  6425e6:       48 85 db                test   %rbx,%rbx
    0.00 :	  6425e9:       0f 84 6f 01 00 00       je     64275e <pgstat_end_function_usage+0x18e>
         :	                return;
         :
         :	        /* total elapsed time in this function call */
         :	        INSTR_TIME_SET_CURRENT(f_total);
    0.00 :	  6425ef:       48 8d 7d d0             lea    -0x30(%rbp),%rdi
    0.00 :	  6425f3:       31 f6                   xor    %esi,%esi
    0.00 :	  6425f5:       e8 c6 6f e2 ff          callq  4695c0 <gettimeofday@plt>
         :	        INSTR_TIME_SUBTRACT(f_total, fcu->f_start);
    0.00 :	  6425fa:       48 8b 4d d8             mov    -0x28(%rbp),%rcx
    0.00 :	  6425fe:       49 2b 4c 24 30          sub    0x30(%r12),%rcx
    0.00 :	  642603:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  642607:       49 2b 44 24 28          sub    0x28(%r12),%rax
    0.00 :	  64260c:       48 85 c9                test   %rcx,%rcx
    0.00 :	  64260f:       48 89 4d d8             mov    %rcx,-0x28(%rbp)
    0.00 :	  642613:       49 89 c1                mov    %rax,%r9
    0.00 :	  642616:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  64261a:       79 1c                   jns    642638 <pgstat_end_function_usage+0x68>
    0.00 :	  64261c:       0f 1f 40 00             nopl   0x0(%rax)
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  642620:       48 83 e8 01             sub    $0x1,%rax
         :	        if (fs == NULL)
         :	                return;
         :
         :	        /* total elapsed time in this function call */
         :	        INSTR_TIME_SET_CURRENT(f_total);
         :	        INSTR_TIME_SUBTRACT(f_total, fcu->f_start);
    0.00 :	  642624:       48 81 c1 40 42 0f 00    add    $0xf4240,%rcx
    0.00 :	  64262b:       78 f3                   js     642620 <pgstat_end_function_usage+0x50>
    0.00 :	  64262d:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  642631:       48 89 4d d8             mov    %rcx,-0x28(%rbp)
    0.00 :	  642635:       49 89 c1                mov    %rax,%r9
         :
         :	        /* self usage: elapsed minus anything already charged to other calls */
         :	        f_others = total_func_time;
    0.00 :	  642638:       4c 8b 05 e9 98 53 00    mov    0x5398e9(%rip),%r8        # b7bf28 <total_func_time+0x8>
    0.00 :	  64263f:       4c 8b 15 da 98 53 00    mov    0x5398da(%rip),%r10        # b7bf20 <total_func_time>
         :	        INSTR_TIME_SUBTRACT(f_others, fcu->save_total);
    0.00 :	  642646:       4c 89 c0                mov    %r8,%rax
    0.00 :	  642649:       4c 89 d2                mov    %r10,%rdx
    0.00 :	  64264c:       49 2b 54 24 18          sub    0x18(%r12),%rdx
    0.00 :	  642651:       49 2b 44 24 20          sub    0x20(%r12),%rax
    0.00 :	  642656:       79 14                   jns    64266c <pgstat_end_function_usage+0x9c>
    0.00 :	  642658:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  64265f:       00 
    0.00 :	  642660:       48 83 ea 01             sub    $0x1,%rdx
    0.00 :	  642664:       48 05 40 42 0f 00       add    $0xf4240,%rax
    0.00 :	  64266a:       78 f4                   js     642660 <pgstat_end_function_usage+0x90>
         :	        f_self = f_total;
         :	        INSTR_TIME_SUBTRACT(f_self, f_others);
    0.00 :	  64266c:       4c 89 cf                mov    %r9,%rdi
    0.00 :	  64266f:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  642672:       48 29 d7                sub    %rdx,%rdi
    0.00 :	  642675:       48 29 c6                sub    %rax,%rsi
    0.00 :	  642678:       79 13                   jns    64268d <pgstat_end_function_usage+0xbd>
    0.00 :	  64267a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  642680:       48 83 ef 01             sub    $0x1,%rdi
    0.00 :	  642684:       48 81 c6 40 42 0f 00    add    $0xf4240,%rsi
    0.00 :	  64268b:       78 f3                   js     642680 <pgstat_end_function_usage+0xb0>
         :
         :	        /* update backend-wide total time */
         :	        INSTR_TIME_ADD(total_func_time, f_self);
    0.00 :	  64268d:       4a 8d 04 06             lea    (%rsi,%r8,1),%rax
    0.00 :	  642691:       4a 8d 14 17             lea    (%rdi,%r10,1),%rdx
    0.00 :	  642695:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  64269b:       48 89 15 7e 98 53 00    mov    %rdx,0x53987e(%rip)        # b7bf20 <total_func_time>
    0.00 :	  6426a2:       48 89 05 7f 98 53 00    mov    %rax,0x53987f(%rip)        # b7bf28 <total_func_time+0x8>
    0.00 :	  6426a9:       7e 25                   jle    6426d0 <pgstat_end_function_usage+0x100>
    0.00 :	  6426ab:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  6426b0:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  6426b6:       48 83 c2 01             add    $0x1,%rdx
         :	        INSTR_TIME_SUBTRACT(f_others, fcu->save_total);
         :	        f_self = f_total;
         :	        INSTR_TIME_SUBTRACT(f_self, f_others);
         :
         :	        /* update backend-wide total time */
         :	        INSTR_TIME_ADD(total_func_time, f_self);
    0.00 :	  6426ba:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6426c0:       7f ee                   jg     6426b0 <pgstat_end_function_usage+0xe0>
    0.00 :	  6426c2:       48 89 15 57 98 53 00    mov    %rdx,0x539857(%rip)        # b7bf20 <total_func_time>
    0.00 :	  6426c9:       48 89 05 58 98 53 00    mov    %rax,0x539858(%rip)        # b7bf28 <total_func_time+0x8>
         :	         * pre-call value of f_total_time.  This is necessary to avoid
         :	         * double-counting any time taken by recursive calls of myself.  (We do
         :	         * not need any similar kluge for self time, since that already excludes
         :	         * any recursive calls.)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
    0.00 :	  6426d0:       48 89 c8                mov    %rcx,%rax
    0.00 :	  6426d3:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	  6426d8:       4c 89 ca                mov    %r9,%rdx
    0.00 :	  6426db:       49 03 54 24 08          add    0x8(%r12),%rdx
    0.00 :	  6426e0:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  6426e6:       48 89 45 d8             mov    %rax,-0x28(%rbp)
    0.00 :	  6426ea:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
    0.00 :	  6426ee:       7e 1a                   jle    64270a <pgstat_end_function_usage+0x13a>
    0.00 :	  6426f0:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
         :	 * calls for what the user considers a single call of the function.  The
         :	 * finalize flag should be TRUE on the last call.
         :	 */
         :	void
         :	pgstat_end_function_usage(PgStat_FunctionCallUsage *fcu, bool finalize)
         :	{
    0.00 :	  6426f6:       48 83 c2 01             add    $0x1,%rdx
         :	         * pre-call value of f_total_time.  This is necessary to avoid
         :	         * double-counting any time taken by recursive calls of myself.  (We do
         :	         * not need any similar kluge for self time, since that already excludes
         :	         * any recursive calls.)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
    0.00 :	  6426fa:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642700:       7f ee                   jg     6426f0 <pgstat_end_function_usage+0x120>
    0.00 :	  642702:       48 89 55 d0             mov    %rdx,-0x30(%rbp)
    0.00 :	  642706:       48 89 45 d8             mov    %rax,-0x28(%rbp)
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
    0.00 :	  64270a:       45 84 ed                test   %r13b,%r13b
    0.00 :	  64270d:       75 61                   jne    642770 <pgstat_end_function_usage+0x1a0>
         :	                fs->f_numcalls++;
         :	        fs->f_total_time = f_total;
    0.00 :	  64270f:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  642713:       48 89 43 08             mov    %rax,0x8(%rbx)
    0.00 :	  642717:       48 8b 45 d8             mov    -0x28(%rbp),%rax
         :	        INSTR_TIME_ADD(fs->f_self_time, f_self);
    0.00 :	  64271b:       48 01 7b 18             add    %rdi,0x18(%rbx)
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
         :	                fs->f_numcalls++;
         :	        fs->f_total_time = f_total;
    0.00 :	  64271f:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	        INSTR_TIME_ADD(fs->f_self_time, f_self);
    0.00 :	  642723:       48 89 f0                mov    %rsi,%rax
    0.00 :	  642726:       48 03 43 20             add    0x20(%rbx),%rax
    0.00 :	  64272a:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642730:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  642734:       7e 21                   jle    642757 <pgstat_end_function_usage+0x187>
    0.00 :	  642736:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  64273d:       00 00 00 
    0.00 :	  642740:       48 2d 40 42 0f 00       sub    $0xf4240,%rax
    0.00 :	  642746:       48 83 43 18 01          addq   $0x1,0x18(%rbx)
    0.00 :	  64274b:       48 3d 3f 42 0f 00       cmp    $0xf423f,%rax
    0.00 :	  642751:       48 89 43 20             mov    %rax,0x20(%rbx)
    0.00 :	  642755:       7f e9                   jg     642740 <pgstat_end_function_usage+0x170>
         :
         :	        /* indicate that we have something to send */
         :	        have_function_stats = true;
    0.00 :	  642757:       c6 05 4a 95 53 00 01    movb   $0x1,0x53954a(%rip)        # b7bca8 <have_function_stats>
         :	}
    0.00 :	  64275e:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  642762:       5b                      pop    %rbx
    0.00 :	  642763:       41 5c                   pop    %r12
    0.00 :	  642765:       41 5d                   pop    %r13
    0.00 :	  642767:       c9                      leaveq 
    0.00 :	  642768:       c3                      retq   
    0.00 :	  642769:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         */
         :	        INSTR_TIME_ADD(f_total, fcu->save_f_total_time);
         :
         :	        /* update counters in function stats table */
         :	        if (finalize)
         :	                fs->f_numcalls++;
    0.00 :	  642770:       48 83 03 01             addq   $0x1,(%rbx)
    0.00 :	  642774:       eb 99                   jmp    64270f <pgstat_end_function_usage+0x13f>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:895
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1092
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:897
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:897
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:897
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000068faf0 <LWLockAcquire>:
         :	 *
         :	 * Side effect: cancel/die interrupts are held off until lock release.
         :	 */
         :	bool
         :	LWLockAcquire(LWLock *l, LWLockMode mode)
         :	{
    0.00 :	  68faf0:       55                      push   %rbp
    0.00 :	  68faf1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  68faf4:       41 57                   push   %r15
    0.00 :	  68faf6:       41 89 f7                mov    %esi,%r15d
    0.00 :	  68faf9:       41 56                   push   %r14
    0.00 :	  68fafb:       49 89 fe                mov    %rdi,%r14
    0.00 :	  68fafe:       41 55                   push   %r13
    0.00 :	  68fb00:       41 54                   push   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:895
   20.00 :	  68fb02:       53                      push   %rbx
    0.00 :	  68fb03:       48 83 ec 18             sub    $0x18,%rsp
         :	         * to catch unsafe coding practices.
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
    0.00 :	  68fb07:       81 3d f7 de 4e 00 c7    cmpl   $0xc7,0x4edef7(%rip)        # b7da08 <num_held_lwlocks>
    0.00 :	  68fb0e:       00 00 00 
         :
         :	/* internal function to implement LWLockAcquire and LWLockAcquireWithVar */
         :	static inline bool
         :	LWLockAcquireCommon(LWLock *lock, LWLockMode mode, uint64 *valptr, uint64 val)
         :	{
         :	        PGPROC     *proc = MyProc;
    0.00 :	  68fb11:       4c 8b 25 30 de 4e 00    mov    0x4ede30(%rip),%r12        # b7d948 <MyProc>
         :	         * to catch unsafe coding practices.
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
    0.00 :	  68fb18:       0f 8f 0c 01 00 00       jg     68fc2a <LWLockAcquire+0x13a>
         :	        /*
         :	         * Lock out cancel/die interrupts until we exit the code section protected
         :	         * by the LWLock.  This ensures that interrupts will not interfere with
         :	         * manipulations of data structures in shared memory.
         :	         */
         :	        HOLD_INTERRUPTS();
    0.00 :	  68fb1e:       8b 05 74 a5 52 00       mov    0x52a574(%rip),%eax        # bba098 <InterruptHoldoffCount>
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
         :
         :	                /* not waiting anymore */
         :	                pg_atomic_fetch_sub_u32(&lock->nwaiters, 1);
    0.00 :	  68fb24:       48 8d 57 08             lea    0x8(%rdi),%rdx
         :	                TRACE_POSTGRESQL_LWLOCK_WAIT_START(T_NAME(lock), T_ID(lock), mode);
         :
         :	                for (;;)
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fb28:       4d 8d 6c 24 10          lea    0x10(%r12),%r13
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
         :
         :	                /* not waiting anymore */
         :	                pg_atomic_fetch_sub_u32(&lock->nwaiters, 1);
    0.00 :	  68fb2d:       31 db                   xor    %ebx,%ebx
    0.00 :	  68fb2f:       c6 45 c7 01             movb   $0x1,-0x39(%rbp)
    0.00 :	  68fb33:       48 89 55 c8             mov    %rdx,-0x38(%rbp)
         :	        /*
         :	         * Lock out cancel/die interrupts until we exit the code section protected
         :	         * by the LWLock.  This ensures that interrupts will not interfere with
         :	         * manipulations of data structures in shared memory.
         :	         */
         :	        HOLD_INTERRUPTS();
    0.00 :	  68fb37:       83 c0 01                add    $0x1,%eax
    0.00 :	  68fb3a:       89 05 58 a5 52 00       mov    %eax,0x52a558(%rip)        # bba098 <InterruptHoldoffCount>
         :	                                break;
         :	                        extraWaits++;
         :	                }
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fb40:       48 8d 47 01             lea    0x1(%rdi),%rax
    0.00 :	  68fb44:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  68fb48:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  68fb4f:       00 
         :	                bool            mustwait;
         :
         :	                /*
         :	                 * try to grab the lock the first time, we're not in the waitqueue yet.
         :	                 */
         :	                mustwait = LWLockAttemptLock(lock, mode, NULL);
    0.00 :	  68fb50:       31 d2                   xor    %edx,%edx
    0.00 :	  68fb52:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb55:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb58:       e8 63 f3 ff ff          callq  68eec0 <LWLockAttemptLock>
         :
         :	                if (!mustwait)
    0.00 :	  68fb5d:       84 c0                   test   %al,%al
    0.00 :	  68fb5f:       74 79                   je     68fbda <LWLockAcquire+0xea>
         :	                 * other lock will see our queue entries when releasing since they
         :	                 * existed before we checked for the lock.
         :	                 */
         :
         :	                /* add to the queue */
         :	                LWLockQueueSelf(lock, mode);
    0.00 :	  68fb61:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb64:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb67:       e8 14 f5 ff ff          callq  68f080 <LWLockQueueSelf>
         :
         :	                /* we're now guaranteed to be woken up if necessary */
         :	                mustwait = LWLockAttemptLock(lock, mode, NULL);
    0.00 :	  68fb6c:       31 d2                   xor    %edx,%edx
    0.00 :	  68fb6e:       44 89 fe                mov    %r15d,%esi
    0.00 :	  68fb71:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fb74:       e8 47 f3 ff ff          callq  68eec0 <LWLockAttemptLock>
         :
         :	                /* ok, grabbed the lock the second time round, need to undo queueing */
         :	                if (!mustwait)
    0.00 :	  68fb79:       84 c0                   test   %al,%al
    0.00 :	  68fb7b:       75 06                   jne    68fb83 <LWLockAcquire+0x93>
    0.00 :	  68fb7d:       eb 30                   jmp    68fbaf <LWLockAcquire+0xbf>
    0.00 :	  68fb7f:       90                      nop
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
         :	                        if (!proc->lwWaiting)
         :	                                break;
         :	                        extraWaits++;
    0.00 :	  68fb80:       83 c3 01                add    $0x1,%ebx
         :	                TRACE_POSTGRESQL_LWLOCK_WAIT_START(T_NAME(lock), T_ID(lock), mode);
         :
         :	                for (;;)
         :	                {
         :	                        /* "false" means cannot accept cancel/die interrupt here. */
         :	                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fb83:       31 f6                   xor    %esi,%esi
    0.00 :	  68fb85:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fb88:       e8 93 85 fa ff          callq  638120 <PGSemaphoreLock>
         :	                        if (!proc->lwWaiting)
    0.00 :	  68fb8d:       41 80 7c 24 41 00       cmpb   $0x0,0x41(%r12)
    0.00 :	  68fb93:       75 eb                   jne    68fb80 <LWLockAcquire+0x90>
         :	                                break;
         :	                        extraWaits++;
         :	                }
         :
         :	                /* The atomic subtraction provides the barrier */
         :	                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fb95:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  68fb99:       c6 00 01                movb   $0x1,(%rax)
         :	#define PG_HAVE_ATOMIC_FETCH_ADD_U32
         :	static inline uint32
         :	pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
         :	{
         :	        uint32 res;
         :	        __asm__ __volatile__(
    0.00 :	  68fb9c:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  68fba1:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  68fba5:       f0 0f c1 02             lock xadd %eax,(%rdx)
    0.00 :	  68fba9:       c6 45 c7 00             movb   $0x0,-0x39(%rbp)
    0.00 :	  68fbad:       eb a1                   jmp    68fb50 <LWLockAcquire+0x60>
         :	                        LOG_LWDEBUG("LWLockAcquire", lock, "acquired, undoing queue");
         :
         :	#ifdef LWLOCK_STATS
         :	                        lwstats->dequeue_self_count++;
         :	#endif
         :	                        if (!LWLockDequeueSelf(lock))
    0.00 :	  68fbaf:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  68fbb2:       e8 19 f6 ff ff          callq  68f1d0 <LWLockDequeueSelf>
    0.00 :	  68fbb7:       84 c0                   test   %al,%al
    0.00 :	  68fbb9:       75 1f                   jne    68fbda <LWLockAcquire+0xea>
    0.00 :	  68fbbb:       eb 06                   jmp    68fbc3 <LWLockAcquire+0xd3>
    0.00 :	  68fbbd:       0f 1f 00                nopl   (%rax)
         :	                                for (;;)
         :	                                {
         :	                                        PGSemaphoreLock(&proc->sem, false);
         :	                                        if (!proc->lwWaiting)
         :	                                                break;
         :	                                        extraWaits++;
    0.00 :	  68fbc0:       83 c3 01                add    $0x1,%ebx
         :	                                 * reset at some inconvenient point later, and releaseOk
         :	                                 * wouldn't be managed correctly.
         :	                                 */
         :	                                for (;;)
         :	                                {
         :	                                        PGSemaphoreLock(&proc->sem, false);
    0.00 :	  68fbc3:       31 f6                   xor    %esi,%esi
    0.00 :	  68fbc5:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fbc8:       e8 53 85 fa ff          callq  638120 <PGSemaphoreLock>
         :	                                        if (!proc->lwWaiting)
    0.00 :	  68fbcd:       41 80 7c 24 41 00       cmpb   $0x0,0x41(%r12)
    0.00 :	  68fbd3:       75 eb                   jne    68fbc0 <LWLockAcquire+0xd0>
         :	                                /*
         :	                                 * Reset releaseOk - if somebody woke us they'll have set it
         :	                                 * to false. No need for a barrier here - we got the lock and
         :	                                 * will perform wakeup if necessary.
         :	                                 */
         :	                                BOOL_ACCESS_ONCE(lock->releaseOK) = true;
    0.00 :	  68fbd5:       41 c6 46 01 01          movb   $0x1,0x1(%r14)
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:1092
   20.00 :	  68fbda:       8b 15 28 de 4e 00       mov    0x4ede28(%rip),%edx        # b7da08 <num_held_lwlocks>
    0.00 :	  68fbe0:       48 63 c2                movslq %edx,%rax
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbe3:       83 c2 01                add    $0x1,%edx
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
    0.00 :	  68fbe6:       48 c1 e0 04             shl    $0x4,%rax
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fbea:       85 db                   test   %ebx,%ebx
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbec:       89 15 16 de 4e 00       mov    %edx,0x4ede16(%rip)        # b7da08 <num_held_lwlocks>
         :	                *valptr = val;
         :
         :	        TRACE_POSTGRESQL_LWLOCK_ACQUIRE(T_NAME(lock), T_ID(lock), mode);
         :
         :	        /* Add lock to list of locks held by this backend */
         :	        held_lwlocks[num_held_lwlocks].lock = lock;
    0.00 :	  68fbf2:       4c 89 b0 40 da b7 00    mov    %r14,0xb7da40(%rax)
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
    0.00 :	  68fbf9:       44 89 b8 48 da b7 00    mov    %r15d,0xb7da48(%rax)
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fc00:       7e 15                   jle    68fc17 <LWLockAcquire+0x127>
    0.00 :	  68fc02:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                PGSemaphoreUnlock(&proc->sem);
    0.00 :	  68fc08:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  68fc0b:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  68fc0e:       e8 7d 84 fa ff          callq  638090 <PGSemaphoreUnlock>
         :	        held_lwlocks[num_held_lwlocks++].mode = mode;
         :
         :	        /*
         :	         * Fix the process wait semaphore's count for any absorbed wakeups.
         :	         */
         :	        while (extraWaits-- > 0)
    0.00 :	  68fc13:       85 db                   test   %ebx,%ebx
    0.00 :	  68fc15:       7f f1                   jg     68fc08 <LWLockAcquire+0x118>
         :	 */
         :	bool
         :	LWLockAcquire(LWLock *l, LWLockMode mode)
         :	{
         :	        return LWLockAcquireCommon(l, mode, NULL, 0);
         :	}
    0.00 :	  68fc17:       0f b6 45 c7             movzbl -0x39(%rbp),%eax
    0.00 :	  68fc1b:       48 83 c4 18             add    $0x18,%rsp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/lwlock.c:897
   20.00 :	  68fc1f:       5b                      pop    %rbx
    0.00 :	  68fc20:       41 5c                   pop    %r12
    0.00 :	  68fc22:       41 5d                   pop    %r13
   20.00 :	  68fc24:       41 5e                   pop    %r14
   20.00 :	  68fc26:       41 5f                   pop    %r15
    0.00 :	  68fc28:       c9                      leaveq 
    0.00 :	  68fc29:       c3                      retq   
         :	         */
         :	        Assert(!(proc == NULL && IsUnderPostmaster));
         :
         :	        /* Ensure we will have room to remember the lock */
         :	        if (num_held_lwlocks >= MAX_SIMUL_LWLOCKS)
         :	                elog(ERROR, "too many LWLocks taken");
    0.00 :	  68fc2a:       ba 70 d1 8a 00          mov    $0x8ad170,%edx
    0.00 :	  68fc2f:       be b0 03 00 00          mov    $0x3b0,%esi
    0.00 :	  68fc34:       bf 85 d0 8a 00          mov    $0x8ad085,%edi
    0.00 :	  68fc39:       e8 e2 b7 0e 00          callq  77b420 <elog_start>
    0.00 :	  68fc3e:       be 8e d0 8a 00          mov    $0x8ad08e,%esi
    0.00 :	  68fc43:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  68fc48:       31 c0                   xor    %eax,%eax
    0.00 :	  68fc4a:       e8 e1 b5 0e 00          callq  77b230 <elog_finish>
    0.00 :	  68fc4f:       e8 7c 98 dd ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   40.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:593
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:584
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:638
   20.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:614
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782de0 <CHashDelete>:
         :	 * Delete from a concurrent hash table.  entry need only contain the key field.
         :	 * Returns true if we find and delete a matching key and false otherwise.
         :	 */
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:584
   20.00 :	  782de0:       55                      push   %rbp
    0.00 :	  782de1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  782de4:       41 57                   push   %r15
    0.00 :	  782de6:       41 56                   push   %r14
    0.00 :	  782de8:       49 89 f6                mov    %rsi,%r14
    0.00 :	  782deb:       41 55                   push   %r13
    0.00 :	  782ded:       41 54                   push   %r12
    0.00 :	  782def:       53                      push   %rbx
    0.00 :	  782df0:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  782df3:       48 83 ec 58             sub    $0x58,%rsp
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
    0.00 :	  782df7:       0f b7 77 0e             movzwl 0xe(%rdi),%esi
    0.00 :	  782dfb:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  782dfe:       e8 4d d5 d0 ff          callq  490350 <hash_any>
    0.00 :	  782e03:       41 89 c5                mov    %eax,%r13d
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782e06:       8b 43 10                mov    0x10(%rbx),%eax
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e09:       0f b6 4b 14             movzbl 0x14(%rbx),%ecx
         :	 */
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
    0.00 :	  782e0d:       44 21 e8                and    %r13d,%eax
    0.00 :	  782e10:       89 45 8c                mov    %eax,-0x74(%rbp)
         :	        CHashPtr           *b = &table->bucket[bucket];
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e13:       8b 55 8c                mov    -0x74(%rbp),%edx
         :	bool
         :	CHashDelete(CHashTable table, void *entry)
         :	{
         :	        uint32  hashcode = hash_any(entry, table->desc.key_size);
         :	        uint32  bucket = hashcode & table->bucket_mask;
         :	        CHashPtr           *b = &table->bucket[bucket];
    0.00 :	  782e16:       89 c0                   mov    %eax,%eax
    0.00 :	  782e18:       4c 8d 24 85 00 00 00    lea    0x0(,%rax,4),%r12
    0.00 :	  782e1f:       00 
    0.00 :	  782e20:       4c 03 63 20             add    0x20(%rbx),%r12
         :	        CHashScanResult scan;
         :
         :	        /* Prevent garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] == NULL);
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782e24:       d3 ea                   shr    %cl,%edx
    0.00 :	  782e26:       0f b6 4b 15             movzbl 0x15(%rbx),%ecx
    0.00 :	  782e2a:       89 d0                   mov    %edx,%eax
    0.00 :	  782e2c:       d3 e8                   shr    %cl,%eax
    0.00 :	  782e2e:       01 d0                   add    %edx,%eax
    0.00 :	  782e30:       48 8b 15 11 ab 3f 00    mov    0x3fab11(%rip),%rdx        # b7d948 <MyProc>
    0.00 :	  782e37:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  782e3b:       48 03 43 28             add    0x28(%rbx),%rax
    0.00 :	  782e3f:       48 89 82 e8 02 00 00    mov    %rax,0x2e8(%rdx)
         :	        pg_memory_barrier();
    0.00 :	  782e46:       f0 83 04 24 00          lock addl $0x0,(%rsp)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:593
   40.00 :	  782e4b:       4c 8d 7d b0             lea    -0x50(%rbp),%r15
    0.00 :	  782e4f:       eb 1e                   jmp    782e6f <CHashDelete+0x8f>
    0.00 :	  782e51:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        if (scan.found)
         :	        {
         :	                Assert(!CHashPtrIsMarked(scan.next));
         :
         :	                /* Attempt to apply delete-mark. */
         :	                if (!__sync_bool_compare_and_swap(&scan.target_node->next,
    0.00 :	  782e58:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  782e5b:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  782e5f:       89 c1                   mov    %eax,%ecx
    0.00 :	  782e61:       83 c9 01                or     $0x1,%ecx
    0.00 :	  782e64:       f0 0f b1 0a             lock cmpxchg %ecx,(%rdx)
    0.00 :	  782e68:       74 5e                   je     782ec8 <CHashDelete+0xe8>
         :	                                                                                  scan.next,
         :	                                                                                  CHashPtrMark(scan.next)))
         :	                {
         :	                        CHashTableIncrementStatistic(table, CHS_Delete_Retry);
    0.00 :	  782e6a:       48 83 43 78 01          addq   $0x1,0x78(%rbx)
         :	        MyProc->hazard[0] = CHashTableGetGarbageByBucket(table, bucket);
         :	        pg_memory_barrier();
         :
         :	        /* Scan bucket. */
         :	retry:
         :	        CHashBucketScan(table, b, hashcode, entry, &scan);
    0.00 :	  782e6f:       4d 89 f8                mov    %r15,%r8
    0.00 :	  782e72:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  782e75:       44 89 ea                mov    %r13d,%edx
    0.00 :	  782e78:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  782e7b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782e7e:       e8 1d fe ff ff          callq  782ca0 <CHashBucketScan>
         :
         :	        /* If we found it, try to delete it. */
         :	        if (scan.found)
    0.00 :	  782e83:       80 7d c8 00             cmpb   $0x0,-0x38(%rbp)
    0.00 :	  782e87:       75 cf                   jne    782e58 <CHashDelete+0x78>
         :	                }
         :	        }
         :
         :	        /* Allow garbage collection for this bucket. */
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
    0.00 :	  782e89:       f0 83 04 24 00          lock addl $0x0,(%rsp)
         :	        MyProc->hazard[0] = NULL;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:638
   20.00 :	  782e8e:       48 8b 05 b3 aa 3f 00    mov    0x3faab3(%rip),%rax        # b7d948 <MyProc>
    0.00 :	  782e95:       48 c7 80 e8 02 00 00    movq   $0x0,0x2e8(%rax)
    0.00 :	  782e9c:       00 00 00 00 
         :
         :	        /* We're done. */
         :	        CHashTableIncrementStatistic(table, CHS_Delete);
         :	        if (!scan.found)
    0.00 :	  782ea0:       0f b6 45 c8             movzbl -0x38(%rbp),%eax
         :	        Assert(MyProc->hazard[0] != NULL);
         :	        pg_memory_barrier();
         :	        MyProc->hazard[0] = NULL;
         :
         :	        /* We're done. */
         :	        CHashTableIncrementStatistic(table, CHS_Delete);
    0.00 :	  782ea4:       48 83 43 68 01          addq   $0x1,0x68(%rbx)
         :	        if (!scan.found)
    0.00 :	  782ea9:       84 c0                   test   %al,%al
    0.00 :	  782eab:       75 05                   jne    782eb2 <CHashDelete+0xd2>
         :	                CHashTableIncrementStatistic(table, CHS_Delete_Failed);
    0.00 :	  782ead:       48 83 43 70 01          addq   $0x1,0x70(%rbx)
         :	        return scan.found;
         :	}
    0.00 :	  782eb2:       48 83 c4 58             add    $0x58,%rsp
    0.00 :	  782eb6:       5b                      pop    %rbx
    0.00 :	  782eb7:       41 5c                   pop    %r12
    0.00 :	  782eb9:       41 5d                   pop    %r13
    0.00 :	  782ebb:       41 5e                   pop    %r14
    0.00 :	  782ebd:       41 5f                   pop    %r15
    0.00 :	  782ebf:       c9                      leaveq 
    0.00 :	  782ec0:       c3                      retq   
    0.00 :	  782ec1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        CHashTableIncrementStatistic(table, CHS_Delete_Retry);
         :	                        goto retry;
         :	                }
         :
         :	                /* Deletion is done; attempt to remove node from list. */
         :	                if (__sync_bool_compare_and_swap(scan.pointer_to_target,
    0.00 :	  782ec8:       8b 55 b0                mov    -0x50(%rbp),%edx
    0.00 :	  782ecb:       48 8b 75 b8             mov    -0x48(%rbp),%rsi
    0.00 :	  782ecf:       8b 4d b4                mov    -0x4c(%rbp),%ecx
    0.00 :	  782ed2:       89 d0                   mov    %edx,%eax
    0.00 :	  782ed4:       f0 0f b1 0e             lock cmpxchg %ecx,(%rsi)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:614
   20.00 :	  782ed8:       75 16                   jne    782ef0 <CHashDelete+0x110>
         :	                                                                                 scan.target,
         :	                                                                                 scan.next))
         :	                        CHashAddToGarbage(table, bucket, scan.target);
    0.00 :	  782eda:       8b 55 b0                mov    -0x50(%rbp),%edx
    0.00 :	  782edd:       8b 75 8c                mov    -0x74(%rbp),%esi
    0.00 :	  782ee0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782ee3:       e8 68 fd ff ff          callq  782c50 <CHashAddToGarbage>
    0.00 :	  782ee8:       eb 9f                   jmp    782e89 <CHashDelete+0xa9>
    0.00 :	  782eea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                         * like a regular bucket scan, except that we don't care
         :	                         * about the results.  We're just doing it to achieve the
         :	                         * side-effect of removing delete-marked nodes from the
         :	                         * bucket chain.
         :	                         */
         :	                        CHashTableIncrementStatistic(table, CHS_Cleanup_Scan);
    0.00 :	  782ef0:       48 83 83 98 00 00 00    addq   $0x1,0x98(%rbx)
    0.00 :	  782ef7:       01 
         :	                        CHashBucketScan(table, b, hashcode, entry, &cleanup_scan);
    0.00 :	  782ef8:       4c 8d 45 90             lea    -0x70(%rbp),%r8
    0.00 :	  782efc:       4c 89 f1                mov    %r14,%rcx
    0.00 :	  782eff:       44 89 ea                mov    %r13d,%edx
    0.00 :	  782f02:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  782f05:       48 89 df                mov    %rbx,%rdi
    0.00 :	  782f08:       e8 93 fd ff ff          callq  782ca0 <CHashBucketScan>
    0.00 :	  782f0d:       e9 77 ff ff ff          jmpq   782e89 <CHashDelete+0xa9>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/transam.c:308
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/transam.c:312
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/transam.c:312
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004bffe0 <TransactionIdPrecedes>:
         :	/*
         :	 * TransactionIdPrecedes --- is id1 logically < id2?
         :	 */
         :	bool
         :	TransactionIdPrecedes(TransactionId id1, TransactionId id2)
         :	{
    0.00 :	  4bffe0:       55                      push   %rbp
         :	         * If either ID is a permanent XID then we can just do unsigned
         :	         * comparison.  If both are normal, do a modulo-2^32 comparison.
         :	         */
         :	        int32           diff;
         :
         :	        if (!TransactionIdIsNormal(id1) || !TransactionIdIsNormal(id2))
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/transam.c:308
   50.00 :	  4bffe1:       83 ff 02                cmp    $0x2,%edi
         :	/*
         :	 * TransactionIdPrecedes --- is id1 logically < id2?
         :	 */
         :	bool
         :	TransactionIdPrecedes(TransactionId id1, TransactionId id2)
         :	{
    0.00 :	  4bffe4:       48 89 e5                mov    %rsp,%rbp
         :	         * If either ID is a permanent XID then we can just do unsigned
         :	         * comparison.  If both are normal, do a modulo-2^32 comparison.
         :	         */
         :	        int32           diff;
         :
         :	        if (!TransactionIdIsNormal(id1) || !TransactionIdIsNormal(id2))
    0.00 :	  4bffe7:       76 17                   jbe    4c0000 <TransactionIdPrecedes+0x20>
    0.00 :	  4bffe9:       83 fe 02                cmp    $0x2,%esi
    0.00 :	  4bffec:       76 12                   jbe    4c0000 <TransactionIdPrecedes+0x20>
         :	                return (id1 < id2);
         :
         :	        diff = (int32) (id1 - id2);
         :	        return (diff < 0);
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/transam.c:312
   25.00 :	  4bffee:       29 f7                   sub    %esi,%edi
         :	}
    0.00 :	  4bfff0:       c9                      leaveq 
         :
         :	        if (!TransactionIdIsNormal(id1) || !TransactionIdIsNormal(id2))
         :	                return (id1 < id2);
         :
         :	        diff = (int32) (id1 - id2);
         :	        return (diff < 0);
   25.00 :	  4bfff1:       89 f8                   mov    %edi,%eax
    0.00 :	  4bfff3:       c1 e8 1f                shr    $0x1f,%eax
         :	}
    0.00 :	  4bfff6:       c3                      retq   
    0.00 :	  4bfff7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4bfffe:       00 00 
         :	         * comparison.  If both are normal, do a modulo-2^32 comparison.
         :	         */
         :	        int32           diff;
         :
         :	        if (!TransactionIdIsNormal(id1) || !TransactionIdIsNormal(id2))
         :	                return (id1 < id2);
    0.00 :	  4c0000:       39 f7                   cmp    %esi,%edi
         :
         :	        diff = (int32) (id1 - id2);
         :	        return (diff < 0);
         :	}
    0.00 :	  4c0002:       c9                      leaveq 
         :	         * comparison.  If both are normal, do a modulo-2^32 comparison.
         :	         */
         :	        int32           diff;
         :
         :	        if (!TransactionIdIsNormal(id1) || !TransactionIdIsNormal(id2))
         :	                return (id1 < id2);
    0.00 :	  4c0003:       0f 92 c0                setb   %al

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   75.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:4648
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:4651
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ccfc0 <DataChecksumsEnabled>:
         :	/*
         :	 * Are checksums enabled for data pages?
         :	 */
         :	bool
         :	DataChecksumsEnabled(void)
         :	{
    0.00 :	  4ccfc0:       48 8b 05 d9 c1 6a 00    mov    0x6ac1d9(%rip),%rax        # b791a0 <ControlFile>
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:4648
   75.00 :	  4ccfc7:       55                      push   %rbp
    0.00 :	  4ccfc8:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ccfcb:       8b 80 ec 00 00 00       mov    0xec(%rax),%eax
         :	        Assert(ControlFile != NULL);
         :	        return (ControlFile->data_checksum_version > 0);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/access/transam/xlog.c:4651
   25.00 :	  4ccfd1:       c9                      leaveq 
         :	/*
         :	 * Are checksums enabled for data pages?
         :	 */
         :	bool
         :	DataChecksumsEnabled(void)
         :	{
    0.00 :	  4ccfd2:       85 c0                   test   %eax,%eax
    0.00 :	  4ccfd4:       0f 95 c0                setne  %al

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   75.00 /home/Computational/mark/src/postgres-andres/src/backend/catalog/catalog.c:91
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/catalog/catalog.c:91
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004e2de0 <IsCatalogRelation>:
         :	 *              but this function returns true only for toast relations of system
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
    0.00 :	  4e2de0:       55                      push   %rbp
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
 /home/Computational/mark/src/postgres-andres/src/backend/catalog/catalog.c:91
   25.00 :	  4e2de1:       48 8b 77 30             mov    0x30(%rdi),%rsi
   75.00 :	  4e2de5:       8b 7f 40                mov    0x40(%rdi),%edi
         :	 *              but this function returns true only for toast relations of system
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
    0.00 :	  4e2de8:       48 89 e5                mov    %rsp,%rbp
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
         :	}
    0.00 :	  4e2deb:       c9                      leaveq 
         :	 *              catalogs.
         :	 */
         :	bool
         :	IsCatalogRelation(Relation relation)
         :	{
         :	        return IsCatalogClass(RelationGetRelid(relation), relation->rd_rel);
    0.00 :	  4e2dec:       e9 bf ff ff ff          jmpq   4e2db0 <IsCatalogClass>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:450
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:459
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:466
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:484
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b4110 <ExecClearTuple>:
         :	 *              NB: only the tuple is cleared, not the tuple descriptor (if any).
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *                                /* return: slot passed */
         :	ExecClearTuple(TupleTableSlot *slot)    /* slot in which to store tuple */
         :	{
    0.00 :	  5b4110:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:450
   25.00 :	  5b4111:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b4114:       53                      push   %rbx
    0.00 :	  5b4115:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b4118:       48 83 ec 08             sub    $0x8,%rsp
         :	        Assert(slot != NULL);
         :
         :	        /*
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
    0.00 :	  5b411c:       80 7f 05 00             cmpb   $0x0,0x5(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:459
   25.00 :	  5b4120:       75 5e                   jne    5b4180 <ExecClearTuple+0x70>
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
    0.00 :	  5b4122:       80 7b 06 00             cmpb   $0x0,0x6(%rbx)
    0.00 :	  5b4126:       75 48                   jne    5b4170 <ExecClearTuple+0x60>
         :	        slot->tts_shouldFreeMin = false;
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b4128:       8b 7b 20                mov    0x20(%rbx),%edi
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
         :
         :	        slot->tts_tuple = NULL;
    0.00 :	  5b412b:       48 c7 43 08 00 00 00    movq   $0x0,0x8(%rbx)
    0.00 :	  5b4132:       00 
         :	        slot->tts_mintuple = NULL;
    0.00 :	  5b4133:       48 c7 43 38 00 00 00    movq   $0x0,0x38(%rbx)
    0.00 :	  5b413a:       00 
         :	        slot->tts_shouldFree = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:466
   25.00 :	  5b413b:       c6 43 05 00             movb   $0x0,0x5(%rbx)
         :	        slot->tts_shouldFreeMin = false;
    0.00 :	  5b413f:       c6 43 06 00             movb   $0x0,0x6(%rbx)
         :
         :	        /*
         :	         * Drop the pin on the referenced buffer, if there is one.
         :	         */
         :	        if (BufferIsValid(slot->tts_buffer))
    0.00 :	  5b4143:       85 ff                   test   %edi,%edi
    0.00 :	  5b4145:       74 05                   je     5b414c <ExecClearTuple+0x3c>
         :	                ReleaseBuffer(slot->tts_buffer);
    0.00 :	  5b4147:       e8 14 0d 0c 00          callq  674e60 <ReleaseBuffer>
         :
         :	        slot->tts_buffer = InvalidBuffer;
    0.00 :	  5b414c:       c7 43 20 00 00 00 00    movl   $0x0,0x20(%rbx)
         :
         :	        /*
         :	         * Mark it empty.
         :	         */
         :	        slot->tts_isempty = true;
    0.00 :	  5b4153:       c6 43 04 01             movb   $0x1,0x4(%rbx)
         :	        slot->tts_nvalid = 0;
         :
         :	        return slot;
         :	}
    0.00 :	  5b4157:       48 89 d8                mov    %rbx,%rax
         :
         :	        /*
         :	         * Mark it empty.
         :	         */
         :	        slot->tts_isempty = true;
         :	        slot->tts_nvalid = 0;
    0.00 :	  5b415a:       c7 43 24 00 00 00 00    movl   $0x0,0x24(%rbx)
         :
         :	        return slot;
         :	}
    0.00 :	  5b4161:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5b4165:       5b                      pop    %rbx
    0.00 :	  5b4166:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:484
   25.00 :	  5b4167:       c3                      retq   
    0.00 :	  5b4168:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5b416f:       00 
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
         :	        if (slot->tts_shouldFreeMin)
         :	                heap_free_minimal_tuple(slot->tts_mintuple);
    0.00 :	  5b4170:       48 8b 7b 38             mov    0x38(%rbx),%rdi
    0.00 :	  5b4174:       e8 37 ab eb ff          callq  46ecb0 <heap_free_minimal_tuple>
    0.00 :	  5b4179:       eb ad                   jmp    5b4128 <ExecClearTuple+0x18>
    0.00 :	  5b417b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :
         :	        /*
         :	         * Free the old physical tuple if necessary.
         :	         */
         :	        if (slot->tts_shouldFree)
         :	                heap_freetuple(slot->tts_tuple);
    0.00 :	  5b4180:       48 8b 7f 08             mov    0x8(%rdi),%rdi
    0.00 :	  5b4184:       e8 37 ab eb ff          callq  46ecc0 <heap_freetuple>
    0.00 :	  5b4189:       eb 97                   jmp    5b4122 <ExecClearTuple+0x12>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/buf_table.c:86
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000673de0 <BufTableLookup>:
         :	 * BufTableLookup
         :	 *              Lookup the given BufferTag; return buffer ID, or -1 if not found
         :	 */
         :	int
         :	BufTableLookup(BufferTag *tagPtr)
         :	{
    0.00 :	  673de0:       55                      push   %rbp
    0.00 :	  673de1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  673de4:       48 83 ec 20             sub    $0x20,%rsp
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
    0.00 :	  673de8:       48 8b 07                mov    (%rdi),%rax
         :	        if (!CHashSearch(SharedBufHash, &ent))
    0.00 :	  673deb:       48 8d 75 e0             lea    -0x20(%rbp),%rsi
         :	int
         :	BufTableLookup(BufferTag *tagPtr)
         :	{
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
    0.00 :	  673def:       48 89 45 e0             mov    %rax,-0x20(%rbp)
    0.00 :	  673df3:       48 8b 47 08             mov    0x8(%rdi),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/buf_table.c:86
  100.00 :	  673df7:       48 89 45 e8             mov    %rax,-0x18(%rbp)
    0.00 :	  673dfb:       8b 47 10                mov    0x10(%rdi),%eax
         :	        if (!CHashSearch(SharedBufHash, &ent))
    0.00 :	  673dfe:       48 8b 3d 53 92 50 00    mov    0x509253(%rip),%rdi        # b7d058 <SharedBufHash>
         :	int
         :	BufTableLookup(BufferTag *tagPtr)
         :	{
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
    0.00 :	  673e05:       89 45 f0                mov    %eax,-0x10(%rbp)
         :	        if (!CHashSearch(SharedBufHash, &ent))
    0.00 :	  673e08:       e8 e3 f4 10 00          callq  7832f0 <CHashSearch>
    0.00 :	  673e0d:       89 c2                   mov    %eax,%edx
    0.00 :	  673e0f:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  673e14:       84 d2                   test   %dl,%dl
    0.00 :	  673e16:       0f 45 45 f4             cmovne -0xc(%rbp),%eax
         :	                return -1;
         :
         :	        return ent.id;
         :	}
    0.00 :	  673e1a:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:509
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:509
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:530
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000676570 <ReadBufferExtended>:
         :	 * See buffer/README for details.
         :	 */
         :	Buffer
         :	ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,
         :	                                   ReadBufferMode mode, BufferAccessStrategy strategy)
         :	{
    0.00 :	  676570:       55                      push   %rbp
    0.00 :	  676571:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  676574:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  676578:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  67657c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  67657f:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  676583:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  676587:       41 89 cd                mov    %ecx,%r13d
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:509
   25.00 :	  67658a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  67658e:       48 83 ec 40             sub    $0x40,%rsp
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  676592:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
         :	 * See buffer/README for details.
         :	 */
         :	Buffer
         :	ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,
         :	                                   ReadBufferMode mode, BufferAccessStrategy strategy)
         :	{
   50.00 :	  676597:       41 89 f7                mov    %esi,%r15d
    0.00 :	  67659a:       41 89 d6                mov    %edx,%r14d
    0.00 :	  67659d:       4d 89 c4                mov    %r8,%r12
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  6765a0:       0f 84 aa 00 00 00       je     676650 <ReadBufferExtended+0xe0>
         :	        /*
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
    0.00 :	  6765a6:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  6765aa:       0f b6 50 6e             movzbl 0x6e(%rax),%edx
    0.00 :	  6765ae:       80 fa 74                cmp    $0x74,%dl
    0.00 :	  6765b1:       74 6d                   je     676620 <ReadBufferExtended+0xb0>
         :
         :	        /*
         :	         * Read the buffer, and update pgstat counters to reflect a cache hit or
         :	         * miss.
         :	         */
         :	        pgstat_count_buffer_read(reln);
    0.00 :	  6765b3:       48 8b 83 38 01 00 00    mov    0x138(%rbx),%rax
    0.00 :	  6765ba:       48 85 c0                test   %rax,%rax
    0.00 :	  6765bd:       74 0d                   je     6765cc <ReadBufferExtended+0x5c>
    0.00 :	  6765bf:       48 83 40 60 01          addq   $0x1,0x60(%rax)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:530
   25.00 :	  6765c4:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  6765c8:       0f b6 50 6e             movzbl 0x6e(%rax),%edx
         :	        buf = ReadBuffer_common(reln->rd_smgr, reln->rd_rel->relpersistence,
    0.00 :	  6765cc:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	  6765d0:       48 8d 45 d7             lea    -0x29(%rbp),%rax
    0.00 :	  6765d4:       0f be f2                movsbl %dl,%esi
    0.00 :	  6765d7:       4d 89 e1                mov    %r12,%r9
    0.00 :	  6765da:       45 89 e8                mov    %r13d,%r8d
    0.00 :	  6765dd:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  6765e0:       44 89 fa                mov    %r15d,%edx
    0.00 :	  6765e3:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	  6765e7:       e8 b4 f6 ff ff          callq  675ca0 <ReadBuffer_common>
         :	                                                        forkNum, blockNum, mode, strategy, &hit);
         :	        if (hit)
    0.00 :	  6765ec:       80 7d d7 00             cmpb   $0x0,-0x29(%rbp)
    0.00 :	  6765f0:       74 11                   je     676603 <ReadBufferExtended+0x93>
         :	                pgstat_count_buffer_hit(reln);
    0.00 :	  6765f2:       48 8b 93 38 01 00 00    mov    0x138(%rbx),%rdx
    0.00 :	  6765f9:       48 85 d2                test   %rdx,%rdx
    0.00 :	  6765fc:       74 05                   je     676603 <ReadBufferExtended+0x93>
    0.00 :	  6765fe:       48 83 42 68 01          addq   $0x1,0x68(%rdx)
         :	        return buf;
         :	}
    0.00 :	  676603:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  676607:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  67660b:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  67660f:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  676613:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  676617:       c9                      leaveq 
    0.00 :	  676618:       c3                      retq   
    0.00 :	  676619:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        /*
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
    0.00 :	  676620:       80 7b 20 00             cmpb   $0x0,0x20(%rbx)
    0.00 :	  676624:       75 8d                   jne    6765b3 <ReadBufferExtended+0x43>
         :	                ereport(ERROR,
    0.00 :	  676626:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  676629:       b9 c0 a0 8a 00          mov    $0x8aa0c0,%ecx
    0.00 :	  67662e:       ba 0c 02 00 00          mov    $0x20c,%edx
    0.00 :	  676633:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  676638:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  67663d:       e8 7e 44 10 00          callq  77aac0 <errstart>
    0.00 :	  676642:       84 c0                   test   %al,%al
    0.00 :	  676644:       75 29                   jne    67666f <ReadBufferExtended+0xff>
    0.00 :	  676646:       e8 85 2e df ff          callq  4694d0 <abort@plt>
    0.00 :	  67664b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	{
         :	        bool            hit;
         :	        Buffer          buf;
         :
         :	        /* Open it at the smgr level if not already done */
         :	        RelationOpenSmgr(reln);
    0.00 :	  676650:       8b 57 1c                mov    0x1c(%rdi),%edx
    0.00 :	  676653:       8b 73 08                mov    0x8(%rbx),%esi
    0.00 :	  676656:       48 8b 3f                mov    (%rdi),%rdi
    0.00 :	  676659:       e8 d2 33 02 00          callq  699a30 <smgropen>
    0.00 :	  67665e:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  676662:       48 89 c6                mov    %rax,%rsi
    0.00 :	  676665:       e8 96 2c 02 00          callq  699300 <smgrsetowner>
    0.00 :	  67666a:       e9 37 ff ff ff          jmpq   6765a6 <ReadBufferExtended+0x36>
         :	         * Reject attempts to read non-local temporary relations; we would be
         :	         * likely to get wrong data since we have no visibility into the owning
         :	         * session's local buffers.
         :	         */
         :	        if (RELATION_IS_OTHER_TEMP(reln))
         :	                ereport(ERROR,
    0.00 :	  67666f:       bf 08 9f 8a 00          mov    $0x8a9f08,%edi
    0.00 :	  676674:       31 c0                   xor    %eax,%eax
    0.00 :	  676676:       e8 25 62 10 00          callq  77c8a0 <errmsg>
    0.00 :	  67667b:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  676680:       89 c3                   mov    %eax,%ebx
    0.00 :	  676682:       e8 c9 66 10 00          callq  77cd50 <errcode>
    0.00 :	  676687:       89 de                   mov    %ebx,%esi
    0.00 :	  676689:       89 c7                   mov    %eax,%edi
    0.00 :	  67668b:       31 c0                   xor    %eax,%eax
    0.00 :	  67668d:       e8 4e 3f 10 00          callq  77a5e0 <errfinish>
    0.00 :	  676692:       eb b2                   jmp    676646 <ReadBufferExtended+0xd6>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1289
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1288
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1289
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000679df0 <FileRead>:
         :	#endif
         :	}
         :
         :	int
         :	FileRead(File file, char *buffer, int amount)
         :	{
    0.00 :	  679df0:       55                      push   %rbp
    0.00 :	  679df1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  679df4:       41 56                   push   %r14
    0.00 :	  679df6:       49 89 f6                mov    %rsi,%r14
    0.00 :	  679df9:       41 55                   push   %r13
    0.00 :	  679dfb:       41 89 d5                mov    %edx,%r13d
    0.00 :	  679dfe:       41 54                   push   %r12
    0.00 :	  679e00:       41 89 fc                mov    %edi,%r12d
    0.00 :	  679e03:       53                      push   %rbx
         :	        DO_DB(elog(LOG, "FileRead: %d (%s) " INT64_FORMAT " %d %p",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           amount, buffer));
         :
         :	        returnCode = FileAccess(file);
    0.00 :	  679e04:       e8 17 fb ff ff          callq  679920 <FileAccess>
         :	        if (returnCode < 0)
    0.00 :	  679e09:       85 c0                   test   %eax,%eax
         :	        DO_DB(elog(LOG, "FileRead: %d (%s) " INT64_FORMAT " %d %p",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           amount, buffer));
         :
         :	        returnCode = FileAccess(file);
    0.00 :	  679e0b:       89 c3                   mov    %eax,%ebx
         :	        if (returnCode < 0)
    0.00 :	  679e0d:       78 47                   js     679e56 <FileRead+0x66>
    0.00 :	  679e0f:       4d 63 e4                movslq %r12d,%r12
    0.00 :	  679e12:       4d 63 ed                movslq %r13d,%r13
    0.00 :	  679e15:       49 c1 e4 06             shl    $0x6,%r12
    0.00 :	  679e19:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                return returnCode;
         :
         :	retry:
         :	        returnCode = read(VfdCache[file].fd, buffer, amount);
    0.00 :	  679e20:       48 8b 05 71 33 50 00    mov    0x503371(%rip),%rax        # b7d198 <VfdCache>
    0.00 :	  679e27:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  679e2a:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679e2d:       42 8b 3c 20             mov    (%rax,%r12,1),%edi
    0.00 :	  679e31:       e8 da f7 de ff          callq  469610 <read@plt>
         :
         :	        if (returnCode >= 0)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1288
   25.00 :	  679e36:       85 c0                   test   %eax,%eax
         :	        returnCode = FileAccess(file);
         :	        if (returnCode < 0)
         :	                return returnCode;
         :
         :	retry:
         :	        returnCode = read(VfdCache[file].fd, buffer, amount);
    0.00 :	  679e38:       89 c3                   mov    %eax,%ebx
         :
         :	        if (returnCode >= 0)
    0.00 :	  679e3a:       79 2c                   jns    679e68 <FileRead+0x78>
         :	                                _dosmaperr(error);
         :	                                break;
         :	                }
         :	#endif
         :	                /* OK to retry if interrupted */
         :	                if (errno == EINTR)
    0.00 :	  679e3c:       e8 7f fe de ff          callq  469cc0 <__errno_location@plt>
    0.00 :	  679e41:       83 38 04                cmpl   $0x4,(%rax)
    0.00 :	  679e44:       74 da                   je     679e20 <FileRead+0x30>
         :	                        goto retry;
         :
         :	                /* Trouble, so assume we don't know the file position anymore */
         :	                VfdCache[file].seekPos = FileUnknownPos;
    0.00 :	  679e46:       48 8b 05 4b 33 50 00    mov    0x50334b(%rip),%rax        # b7d198 <VfdCache>
    0.00 :	  679e4d:       4a c7 44 20 20 ff ff    movq   $0xffffffffffffffff,0x20(%rax,%r12,1)
    0.00 :	  679e54:       ff ff 
         :	        }
         :
         :	        return returnCode;
         :	}
    0.00 :	  679e56:       89 d8                   mov    %ebx,%eax
    0.00 :	  679e58:       5b                      pop    %rbx
    0.00 :	  679e59:       41 5c                   pop    %r12
    0.00 :	  679e5b:       41 5d                   pop    %r13
    0.00 :	  679e5d:       41 5e                   pop    %r14
    0.00 :	  679e5f:       c9                      leaveq 
    0.00 :	  679e60:       c3                      retq   
    0.00 :	  679e61:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	retry:
         :	        returnCode = read(VfdCache[file].fd, buffer, amount);
         :
         :	        if (returnCode >= 0)
         :	                VfdCache[file].seekPos += returnCode;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1289
   50.00 :	  679e68:       4c 03 25 29 33 50 00    add    0x503329(%rip),%r12        # b7d198 <VfdCache>
   25.00 :	  679e6f:       48 98                   cltq   
    0.00 :	  679e71:       49 01 44 24 20          add    %rax,0x20(%r12)
         :	                /* Trouble, so assume we don't know the file position anymore */
         :	                VfdCache[file].seekPos = FileUnknownPos;
         :	        }
         :
         :	        return returnCode;
         :	}
    0.00 :	  679e76:       89 d8                   mov    %ebx,%eax
    0.00 :	  679e78:       5b                      pop    %rbx
    0.00 :	  679e79:       41 5c                   pop    %r12
    0.00 :	  679e7b:       41 5d                   pop    %r13
    0.00 :	  679e7d:       41 5e                   pop    %r14
    0.00 :	  679e7f:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:3871
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:3871
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:3871
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000694660 <CheckForSerializableConflictOut>:
         :	 */
         :	void
         :	CheckForSerializableConflictOut(bool visible, Relation relation,
         :	                                                                HeapTuple tuple, Buffer buffer,
         :	                                                                Snapshot snapshot)
         :	{
    0.00 :	  694660:       55                      push   %rbp
    0.00 :	  694661:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:3871
   50.00 :	  694664:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
   25.00 :	  694668:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  69466c:       49 89 d4                mov    %rdx,%r12
    0.00 :	  69466f:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
   25.00 :	  694673:       48 83 ec 30             sub    $0x30,%rsp
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694677:       48 8b 15 42 a0 4e 00    mov    0x4ea042(%rip),%rdx        # b7e6c0 <MySerializableXact>
         :	 */
         :	void
         :	CheckForSerializableConflictOut(bool visible, Relation relation,
         :	                                                                HeapTuple tuple, Buffer buffer,
         :	                                                                Snapshot snapshot)
         :	{
    0.00 :	  69467e:       41 89 fd                mov    %edi,%r13d
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  694681:       48 85 d2                test   %rdx,%rdx
    0.00 :	  694684:       74 13                   je     694699 <CheckForSerializableConflictOut+0x39>
         :	         * This excludes things like CLUSTER and REINDEX. They use the wholesale
         :	         * functions TransferPredicateLocksToHeapRelation() and
         :	         * CheckTableForSerializableConflictIn() to participate serialization, but
         :	         * the scans involved don't need serialization.
         :	         */
         :	        if (!IsMVCCSnapshot(snapshot))
    0.00 :	  694686:       49 8b 00                mov    (%r8),%rax
    0.00 :	  694689:       48 3d 50 57 7a 00       cmp    $0x7a5750,%rax
    0.00 :	  69468f:       74 1f                   je     6946b0 <CheckForSerializableConflictOut+0x50>
    0.00 :	  694691:       48 3d 60 47 7a 00       cmp    $0x7a4760,%rax
    0.00 :	  694697:       74 17                   je     6946b0 <CheckForSerializableConflictOut+0x50>
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
         :	        LWLockRelease(SerializableXactHashLock);
         :	}
    0.00 :	  694699:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  69469d:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  6946a1:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  6946a5:       c9                      leaveq 
    0.00 :	  6946a6:       c3                      retq   
    0.00 :	  6946a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  6946ae:       00 00 
         :	         *
         :	         * A transaction is flagged as RO_SAFE if all concurrent R/W transactions
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
    0.00 :	  6946b0:       8b 52 7c                mov    0x7c(%rdx),%edx
    0.00 :	  6946b3:       84 d2                   test   %dl,%dl
    0.00 :	  6946b5:       78 69                   js     694720 <CheckForSerializableConflictOut+0xc0>
         :	 * relations are exempt, as are materialized views.
         :	 */
         :	static inline bool
         :	PredicateLockingNeededForRelation(Relation relation)
         :	{
         :	        return !(relation->rd_id < FirstBootstrapObjectId ||
    0.00 :	  6946b7:       81 7e 40 0f 27 00 00    cmpl   $0x270f,0x40(%rsi)
    0.00 :	  6946be:       76 d9                   jbe    694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  6946c0:       48 8b 46 30             mov    0x30(%rsi),%rax
    0.00 :	  6946c4:       80 78 6e 74             cmpb   $0x74,0x6e(%rax)
    0.00 :	  6946c8:       74 cf                   je     694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  6946ca:       80 78 6f 6d             cmpb   $0x6d,0x6f(%rax)
    0.00 :	  6946ce:       66 90                   xchg   %ax,%ax
    0.00 :	  6946d0:       74 c7                   je     694699 <CheckForSerializableConflictOut+0x39>
         :
         :	        if (!SerializationNeededForRead(relation, snapshot))
         :	                return;
         :
         :	        /* Check if someone else has already decided that we need to die */
         :	        if (SxactIsDoomed(MySerializableXact))
    0.00 :	  6946d2:       83 e2 08                and    $0x8,%edx
    0.00 :	  6946d5:       0f 85 55 02 00 00       jne    694930 <CheckForSerializableConflictOut+0x2d0>
         :	         * transaction, either to create it not visible to us, or to delete it
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
    0.00 :	  6946db:       8b 35 77 e0 4d 00       mov    0x4de077(%rip),%esi        # b72758 <TransactionXmin>
    0.00 :	  6946e1:       89 ca                   mov    %ecx,%edx
    0.00 :	  6946e3:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6946e6:       e8 35 04 11 00          callq  7a4b20 <HeapTupleSatisfiesVacuum>
         :	        switch (htsvResult)
    0.00 :	  6946eb:       83 f8 04                cmp    $0x4,%eax
         :	         * transaction, either to create it not visible to us, or to delete it
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
    0.00 :	  6946ee:       89 c3                   mov    %eax,%ebx
         :	        switch (htsvResult)
    0.00 :	  6946f0:       76 3e                   jbe    694730 <CheckForSerializableConflictOut+0xd0>
         :	                        /*
         :	                         * The only way to get to this default clause is if a new value is
         :	                         * added to the enum type without adding it to this switch
         :	                         * statement.  That's a bug, so elog.
         :	                         */
         :	                        elog(ERROR, "unrecognized return value from HeapTupleSatisfiesVacuum: %u", htsvResult);
    0.00 :	  6946f2:       ba e0 da 8a 00          mov    $0x8adae0,%edx
    0.00 :	  6946f7:       be 56 0f 00 00          mov    $0xf56,%esi
    0.00 :	  6946fc:       bf d3 d1 8a 00          mov    $0x8ad1d3,%edi
    0.00 :	  694701:       e8 1a 6d 0e 00          callq  77b420 <elog_start>
    0.00 :	  694706:       89 da                   mov    %ebx,%edx
    0.00 :	  694708:       be a0 d8 8a 00          mov    $0x8ad8a0,%esi
    0.00 :	  69470d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694712:       31 c0                   xor    %eax,%eax
    0.00 :	  694714:       e8 17 6b 0e 00          callq  77b230 <elog_finish>
    0.00 :	  694719:       e8 b2 4d dd ff          callq  4694d0 <abort@plt>
    0.00 :	  69471e:       66 90                   xchg   %ax,%ax
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
         :	        {
         :	                ReleasePredicateLocks(false);
    0.00 :	  694720:       31 ff                   xor    %edi,%edi
    0.00 :	  694722:       e8 c9 e1 ff ff          callq  6928f0 <ReleasePredicateLocks>
    0.00 :	  694727:       e9 6d ff ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  69472c:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * while it is visible to us.  The "visible" bool indicates whether the
         :	         * tuple is visible to us, while HeapTupleSatisfiesVacuum checks what else
         :	         * is going on with it.
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
         :	        switch (htsvResult)
    0.00 :	  694730:       89 c0                   mov    %eax,%eax
    0.00 :	  694732:       ff 24 c5 c0 d9 8a 00    jmpq   *0x8ad9c0(,%rax,8)
    0.00 :	  694739:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        if (visible)
         :	                                return;
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_RECENTLY_DEAD:
         :	                        if (!visible)
    0.00 :	  694740:       45 84 ed                test   %r13b,%r13b
    0.00 :	  694743:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  694748:       0f 84 4b ff ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :	                                return;
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
    0.00 :	  69474e:       49 8b 7c 24 10          mov    0x10(%r12),%rdi
    0.00 :	  694753:       0f b7 57 14             movzwl 0x14(%rdi),%edx
    0.00 :	  694757:       89 d0                   mov    %edx,%eax
    0.00 :	  694759:       25 00 18 00 00          and    $0x1800,%eax
    0.00 :	  69475e:       3d 00 10 00 00          cmp    $0x1000,%eax
    0.00 :	  694763:       0f 84 f7 00 00 00       je     694860 <CheckForSerializableConflictOut+0x200>
    0.00 :	  694769:       8b 5f 04                mov    0x4(%rdi),%ebx
         :
         :	        /*
         :	         * Find top level xid.  Bail out if xid is too early to be a conflict, or
         :	         * if it's our own xid.
         :	         */
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
    0.00 :	  69476c:       e8 0f c4 e2 ff          callq  4c0b80 <GetTopTransactionIdIfAny>
    0.00 :	  694771:       39 d8                   cmp    %ebx,%eax
    0.00 :	  694773:       0f 84 20 ff ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :	                return;
         :	        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  694779:       89 df                   mov    %ebx,%edi
    0.00 :	  69477b:       e8 70 21 e3 ff          callq  4c68f0 <SubTransGetTopmostTransaction>
         :	        if (TransactionIdPrecedes(xid, TransactionXmin))
    0.00 :	  694780:       8b 35 d2 df 4d 00       mov    0x4ddfd2(%rip),%esi        # b72758 <TransactionXmin>
    0.00 :	  694786:       89 c7                   mov    %eax,%edi
         :	         * Find top level xid.  Bail out if xid is too early to be a conflict, or
         :	         * if it's our own xid.
         :	         */
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
         :	                return;
         :	        xid = SubTransGetTopmostTransaction(xid);
    0.00 :	  694788:       89 c3                   mov    %eax,%ebx
         :	        if (TransactionIdPrecedes(xid, TransactionXmin))
    0.00 :	  69478a:       e8 51 b8 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  69478f:       84 c0                   test   %al,%al
    0.00 :	  694791:       0f 85 02 ff ff ff       jne    694699 <CheckForSerializableConflictOut+0x39>
         :	                return;
         :	        if (TransactionIdEquals(xid, GetTopTransactionIdIfAny()))
    0.00 :	  694797:       e8 e4 c3 e2 ff          callq  4c0b80 <GetTopTransactionIdIfAny>
    0.00 :	  69479c:       39 c3                   cmp    %eax,%ebx
    0.00 :	  69479e:       66 90                   xchg   %ax,%ax
    0.00 :	  6947a0:       0f 84 f3 fe ff ff       je     694699 <CheckForSerializableConflictOut+0x39>
         :
         :	        /*
         :	         * Find sxact or summarized info for the top level xid.
         :	         */
         :	        sxidtag.xid = xid;
         :	        LWLockAcquire(SerializableXactHashLock, LW_EXCLUSIVE);
    0.00 :	  6947a6:       48 8b 3d 53 92 4e 00    mov    0x4e9253(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6947ad:       31 f6                   xor    %esi,%esi
         :	                return;
         :
         :	        /*
         :	         * Find sxact or summarized info for the top level xid.
         :	         */
         :	        sxidtag.xid = xid;
    0.00 :	  6947af:       89 5d d0                mov    %ebx,-0x30(%rbp)
         :	        LWLockAcquire(SerializableXactHashLock, LW_EXCLUSIVE);
    0.00 :	  6947b2:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  6947b9:       e8 32 b3 ff ff          callq  68faf0 <LWLockAcquire>
         :	        sxid = (SERIALIZABLEXID *)
    0.00 :	  6947be:       48 8b 3d 93 9f 4e 00    mov    0x4e9f93(%rip),%rdi        # b7e758 <SerializableXidHash>
    0.00 :	  6947c5:       48 8d 75 d0             lea    -0x30(%rbp),%rsi
    0.00 :	  6947c9:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6947cb:       31 d2                   xor    %edx,%edx
    0.00 :	  6947cd:       e8 ce fe 0e 00          callq  7846a0 <hash_search>
         :	                hash_search(SerializableXidHash, &sxidtag, HASH_FIND, NULL);
         :	        if (!sxid)
    0.00 :	  6947d2:       48 85 c0                test   %rax,%rax
    0.00 :	  6947d5:       0f 84 c5 01 00 00       je     6949a0 <CheckForSerializableConflictOut+0x340>
         :
         :	                /* It's not serializable or otherwise not important. */
         :	                LWLockRelease(SerializableXactHashLock);
         :	                return;
         :	        }
         :	        sxact = sxid->myXact;
    0.00 :	  6947db:       4c 8b 60 08             mov    0x8(%rax),%r12
         :	        Assert(TransactionIdEquals(sxact->topXid, xid));
         :	        if (sxact == MySerializableXact || SxactIsDoomed(sxact))
    0.00 :	  6947df:       48 8b 0d da 9e 4e 00    mov    0x4e9eda(%rip),%rcx        # b7e6c0 <MySerializableXact>
    0.00 :	  6947e6:       49 39 cc                cmp    %rcx,%r12
    0.00 :	  6947e9:       0f 84 b1 00 00 00       je     6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  6947ef:       41 8b 54 24 7c          mov    0x7c(%r12),%edx
    0.00 :	  6947f4:       f6 c2 08                test   $0x8,%dl
    0.00 :	  6947f7:       0f 85 a3 00 00 00       jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :	         * We have a conflict out to a transaction which has a conflict out to a
         :	         * summarized transaction.  That summarized transaction must have
         :	         * committed first, and we can't tell when it committed in relation to our
         :	         * snapshot acquisition, so something needs to be canceled.
         :	         */
         :	        if (SxactHasSummaryConflictOut(sxact))
    0.00 :	  6947fd:       f6 c6 04                test   $0x4,%dh
    0.00 :	  694800:       0f 84 b2 00 00 00       je     6948b8 <CheckForSerializableConflictOut+0x258>
         :	        {
         :	                if (!SxactIsPrepared(sxact))
    0.00 :	  694806:       f6 c2 02                test   $0x2,%dl
    0.00 :	  694809:       0f 85 39 03 00 00       jne    694b48 <CheckForSerializableConflictOut+0x4e8>
         :	                {
         :	                        sxact->flags |= SXACT_FLAG_DOOMED;
    0.00 :	  69480f:       83 ca 08                or     $0x8,%edx
    0.00 :	  694812:       41 89 54 24 7c          mov    %edx,0x7c(%r12)
         :	                        LWLockRelease(SerializableXactHashLock);
    0.00 :	  694817:       48 8b 3d e2 91 4e 00    mov    0x4e91e2(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  69481e:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  694825:       e8 76 ab ff ff          callq  68f3a0 <LWLockRelease>
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
         :	        LWLockRelease(SerializableXactHashLock);
         :	}
    0.00 :	  69482a:       e9 6a fe ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
    0.00 :	  69482f:       90                      nop
         :	         */
         :	        htsvResult = HeapTupleSatisfiesVacuum(tuple, TransactionXmin, buffer);
         :	        switch (htsvResult)
         :	        {
         :	                case HEAPTUPLE_LIVE:
         :	                        if (visible)
    0.00 :	  694830:       45 84 ed                test   %r13b,%r13b
    0.00 :	  694833:       0f 85 60 fe ff ff       jne    694699 <CheckForSerializableConflictOut+0x39>
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_INSERT_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
    0.00 :	  694839:       49 8b 54 24 10          mov    0x10(%r12),%rdx
         :	                        /*
         :	                         * The only way to get to this default clause is if a new value is
         :	                         * added to the enum type without adding it to this switch
         :	                         * statement.  That's a bug, so elog.
         :	                         */
         :	                        elog(ERROR, "unrecognized return value from HeapTupleSatisfiesVacuum: %u", htsvResult);
    0.00 :	  69483e:       bb 02 00 00 00          mov    $0x2,%ebx
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_INSERT_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetXmin(tuple->t_data);
    0.00 :	  694843:       0f b7 42 14             movzwl 0x14(%rdx),%eax
    0.00 :	  694847:       25 00 03 00 00          and    $0x300,%eax
    0.00 :	  69484c:       3d 00 03 00 00          cmp    $0x300,%eax
    0.00 :	  694851:       0f 84 15 ff ff ff       je     69476c <CheckForSerializableConflictOut+0x10c>
    0.00 :	  694857:       8b 1a                   mov    (%rdx),%ebx
    0.00 :	  694859:       e9 0e ff ff ff          jmpq   69476c <CheckForSerializableConflictOut+0x10c>
    0.00 :	  69485e:       66 90                   xchg   %ax,%ax
         :	                        if (!visible)
         :	                                return;
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
         :	                        break;
         :	                case HEAPTUPLE_DELETE_IN_PROGRESS:
         :	                        xid = HeapTupleHeaderGetUpdateXid(tuple->t_data);
    0.00 :	  694860:       84 d2                   test   %dl,%dl
    0.00 :	  694862:       0f 88 01 ff ff ff       js     694769 <CheckForSerializableConflictOut+0x109>
    0.00 :	  694868:       e8 b3 28 e0 ff          callq  497120 <HeapTupleGetUpdateXid>
    0.00 :	  69486d:       89 c3                   mov    %eax,%ebx
    0.00 :	  69486f:       90                      nop
    0.00 :	  694870:       e9 f7 fe ff ff          jmpq   69476c <CheckForSerializableConflictOut+0x10c>
         :	                /* This write was already in our snapshot; no conflict. */
         :	                LWLockRelease(SerializableXactHashLock);
         :	                return;
         :	        }
         :
         :	        if (RWConflictExists(MySerializableXact, sxact))
    0.00 :	  694875:       48 8b 3d 44 9e 4e 00    mov    0x4e9e44(%rip),%rdi        # b7e6c0 <MySerializableXact>
    0.00 :	  69487c:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  69487f:       e8 1c cc ff ff          callq  6914a0 <RWConflictExists>
    0.00 :	  694884:       84 c0                   test   %al,%al
    0.00 :	  694886:       75 18                   jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :
         :	        /*
         :	         * Flag the conflict.  But first, if this conflict creates a dangerous
         :	         * structure, ereport an error.
         :	         */
         :	        FlagRWConflict(MySerializableXact, sxact);
    0.00 :	  694888:       48 8b 3d 31 9e 4e 00    mov    0x4e9e31(%rip),%rdi        # b7e6c0 <MySerializableXact>
    0.00 :	  69488f:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  694892:       e8 79 c5 ff ff          callq  690e10 <FlagRWConflict>
    0.00 :	  694897:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  69489e:       00 00 
         :	        LWLockRelease(SerializableXactHashLock);
    0.00 :	  6948a0:       48 8b 3d 59 91 4e 00    mov    0x4e9159(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6948a7:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  6948ae:       e8 ed aa ff ff          callq  68f3a0 <LWLockRelease>
    0.00 :	  6948b3:       e9 e1 fd ff ff          jmpq   694699 <CheckForSerializableConflictOut+0x39>
         :	        /*
         :	         * If this is a read-only transaction and the writing transaction has
         :	         * committed, and it doesn't have a rw-conflict to a transaction which
         :	         * committed before it, no conflict.
         :	         */
         :	        if (SxactIsReadOnly(MySerializableXact)
    0.00 :	  6948b8:       f6 41 7c 20             testb  $0x20,0x7c(%rcx)
    0.00 :	  6948bc:       74 10                   je     6948ce <CheckForSerializableConflictOut+0x26e>
    0.00 :	  6948be:       89 d0                   mov    %edx,%eax
    0.00 :	  6948c0:       25 01 04 00 00          and    $0x401,%eax
    0.00 :	  6948c5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  6948c8:       0f 84 e9 01 00 00       je     694ab7 <CheckForSerializableConflictOut+0x457>
         :	        uint32          i;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :	        Assert(!TransactionIdEquals(xid, GetTopTransactionIdIfAny()));
         :
         :	        snap = GetTransactionSnapshot();
    0.00 :	  6948ce:       e8 3d 2d 11 00          callq  7a7610 <GetTransactionSnapshot>
         :
         :	        if (TransactionIdPrecedes(xid, snap->xmin))
    0.00 :	  6948d3:       8b 70 08                mov    0x8(%rax),%esi
    0.00 :	  6948d6:       89 df                   mov    %ebx,%edi
         :	        uint32          i;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :	        Assert(!TransactionIdEquals(xid, GetTopTransactionIdIfAny()));
         :
         :	        snap = GetTransactionSnapshot();
    0.00 :	  6948d8:       49 89 c5                mov    %rax,%r13
         :
         :	        if (TransactionIdPrecedes(xid, snap->xmin))
    0.00 :	  6948db:       e8 00 b7 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  6948e0:       84 c0                   test   %al,%al
    0.00 :	  6948e2:       75 bc                   jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :	                return false;
         :
         :	        if (TransactionIdFollowsOrEquals(xid, snap->xmax))
    0.00 :	  6948e4:       41 8b 75 0c             mov    0xc(%r13),%esi
    0.00 :	  6948e8:       89 df                   mov    %ebx,%edi
    0.00 :	  6948ea:       e8 81 b7 e2 ff          callq  4c0070 <TransactionIdFollowsOrEquals>
    0.00 :	  6948ef:       84 c0                   test   %al,%al
    0.00 :	  6948f1:       75 82                   jne    694875 <CheckForSerializableConflictOut+0x215>
         :	                return true;
         :
         :	        for (i = 0; i < snap->xcnt; i++)
    0.00 :	  6948f3:       41 8b 75 18             mov    0x18(%r13),%esi
    0.00 :	  6948f7:       85 f6                   test   %esi,%esi
    0.00 :	  6948f9:       74 a5                   je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	        {
         :	                if (xid == snap->xip[i])
    0.00 :	  6948fb:       49 8b 45 10             mov    0x10(%r13),%rax
    0.00 :	  6948ff:       31 d2                   xor    %edx,%edx
    0.00 :	  694901:       3b 18                   cmp    (%rax),%ebx
    0.00 :	  694903:       48 89 c1                mov    %rax,%rcx
    0.00 :	  694906:       75 17                   jne    69491f <CheckForSerializableConflictOut+0x2bf>
    0.00 :	  694908:       e9 68 ff ff ff          jmpq   694875 <CheckForSerializableConflictOut+0x215>
    0.00 :	  69490d:       0f 1f 00                nopl   (%rax)
    0.00 :	  694910:       8b 41 04                mov    0x4(%rcx),%eax
    0.00 :	  694913:       48 83 c1 04             add    $0x4,%rcx
    0.00 :	  694917:       39 c3                   cmp    %eax,%ebx
    0.00 :	  694919:       0f 84 56 ff ff ff       je     694875 <CheckForSerializableConflictOut+0x215>
         :	                return false;
         :
         :	        if (TransactionIdFollowsOrEquals(xid, snap->xmax))
         :	                return true;
         :
         :	        for (i = 0; i < snap->xcnt; i++)
    0.00 :	  69491f:       83 c2 01                add    $0x1,%edx
    0.00 :	  694922:       39 f2                   cmp    %esi,%edx
    0.00 :	  694924:       72 ea                   jb     694910 <CheckForSerializableConflictOut+0x2b0>
    0.00 :	  694926:       e9 75 ff ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  69492b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                return;
         :
         :	        /* Check if someone else has already decided that we need to die */
         :	        if (SxactIsDoomed(MySerializableXact))
         :	        {
         :	                ereport(ERROR,
    0.00 :	  694930:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694933:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694938:       ba 30 0f 00 00          mov    $0xf30,%edx
    0.00 :	  69493d:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694942:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694947:       e8 74 61 0e 00          callq  77aac0 <errstart>
    0.00 :	  69494c:       84 c0                   test   %al,%al
    0.00 :	  69494e:       0f 84 c5 fd ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694954:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694959:       31 c0                   xor    %eax,%eax
    0.00 :	  69495b:       e8 40 73 0e 00          callq  77bca0 <errhint>
    0.00 :	  694960:       bf 48 d8 8a 00          mov    $0x8ad848,%edi
    0.00 :	  694965:       41 89 c5                mov    %eax,%r13d
         :	                        return;
         :	                }
         :	                else
         :	                {
         :	                        LWLockRelease(SerializableXactHashLock);
         :	                        ereport(ERROR,
    0.00 :	  694968:       31 c0                   xor    %eax,%eax
    0.00 :	  69496a:       e8 11 7a 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  69496f:       89 c3                   mov    %eax,%ebx
    0.00 :	  694971:       bf 48 d3 8a 00          mov    $0x8ad348,%edi
    0.00 :	  694976:       31 c0                   xor    %eax,%eax
    0.00 :	  694978:       e8 23 7f 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  69497d:       bf 04 00 00 01          mov    $0x1000004,%edi
    0.00 :	  694982:       41 89 c4                mov    %eax,%r12d
    0.00 :	  694985:       e8 c6 83 0e 00          callq  77cd50 <errcode>
    0.00 :	  69498a:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  69498d:       89 c7                   mov    %eax,%edi
    0.00 :	  69498f:       89 da                   mov    %ebx,%edx
    0.00 :	  694991:       44 89 e6                mov    %r12d,%esi
    0.00 :	  694994:       31 c0                   xor    %eax,%eax
    0.00 :	  694996:       e8 45 5c 0e 00          callq  77a5e0 <errfinish>
    0.00 :	  69499b:       e9 79 fd ff ff          jmpq   694719 <CheckForSerializableConflictOut+0xb9>
         :	        SerCommitSeqNo val;
         :	        int                     slotno;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
    0.00 :	  6949a0:       48 8b 3d 59 90 4e 00    mov    0x4e9059(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  6949a7:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  6949ac:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
    0.00 :	  6949b3:       e8 38 b1 ff ff          callq  68faf0 <LWLockAcquire>
         :	        headXid = oldSerXidControl->headXid;
    0.00 :	  6949b8:       48 8b 05 79 9d 4e 00    mov    0x4e9d79(%rip),%rax        # b7e738 <oldSerXidControl>
         :	        tailXid = oldSerXidControl->tailXid;
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949bf:       48 8b 3d 3a 90 4e 00    mov    0x4e903a(%rip),%rdi        # b7da00 <MainLWLockArray>
         :	        int                     slotno;
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
         :	        headXid = oldSerXidControl->headXid;
    0.00 :	  6949c6:       44 8b 60 04             mov    0x4(%rax),%r12d
         :	        tailXid = oldSerXidControl->tailXid;
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949ca:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
         :
         :	        Assert(TransactionIdIsValid(xid));
         :
         :	        LWLockAcquire(OldSerXidLock, LW_SHARED);
         :	        headXid = oldSerXidControl->headXid;
         :	        tailXid = oldSerXidControl->tailXid;
    0.00 :	  6949d1:       44 8b 68 08             mov    0x8(%rax),%r13d
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  6949d5:       e8 c6 a9 ff ff          callq  68f3a0 <LWLockRelease>
         :
         :	        if (!TransactionIdIsValid(headXid))
    0.00 :	  6949da:       45 85 e4                test   %r12d,%r12d
    0.00 :	  6949dd:       0f 84 bd fe ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	                return 0;
         :
         :	        Assert(TransactionIdIsValid(tailXid));
         :
         :	        if (TransactionIdPrecedes(xid, tailXid)
    0.00 :	  6949e3:       44 89 ee                mov    %r13d,%esi
    0.00 :	  6949e6:       89 df                   mov    %ebx,%edi
    0.00 :	  6949e8:       e8 f3 b5 e2 ff          callq  4bffe0 <TransactionIdPrecedes>
    0.00 :	  6949ed:       84 c0                   test   %al,%al
    0.00 :	  6949ef:       0f 85 ab fe ff ff       jne    6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  6949f5:       44 89 e6                mov    %r12d,%esi
    0.00 :	  6949f8:       89 df                   mov    %ebx,%edi
    0.00 :	  6949fa:       e8 41 b6 e2 ff          callq  4c0040 <TransactionIdFollows>
    0.00 :	  6949ff:       84 c0                   test   %al,%al
    0.00 :	  694a01:       0f 85 99 fe ff ff       jne    6948a0 <CheckForSerializableConflictOut+0x240>
         :
         :	        /*
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
    0.00 :	  694a07:       89 de                   mov    %ebx,%esi
    0.00 :	  694a09:       89 da                   mov    %ebx,%edx
    0.00 :	  694a0b:       bf e0 e6 b7 00          mov    $0xb7e6e0,%edi
    0.00 :	  694a10:       c1 ee 0a                shr    $0xa,%esi
    0.00 :	  694a13:       81 e6 ff ff 1f 00       and    $0x1fffff,%esi
    0.00 :	  694a19:       e8 02 1a e3 ff          callq  4c6420 <SimpleLruReadPage_ReadOnly>
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a1e:       48 8b 15 bb 9c 4e 00    mov    0x4e9cbb(%rip),%rdx        # b7e6e0 <OldSerXidSlruCtlData>
    0.00 :	  694a25:       48 98                   cltq   
    0.00 :	  694a27:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  694a2a:       81 e1 ff 03 00 00       and    $0x3ff,%ecx
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a30:       48 8b 3d c9 8f 4e 00    mov    0x4e8fc9(%rip),%rdi        # b7da00 <MainLWLockArray>
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a37:       48 8b 52 10             mov    0x10(%rdx),%rdx
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a3b:       48 81 c7 e0 03 00 00    add    $0x3e0,%rdi
         :	         * The following function must be called without holding OldSerXidLock,
         :	         * but will return with that lock held, which must then be released.
         :	         */
         :	        slotno = SimpleLruReadPage_ReadOnly(OldSerXidSlruCtl,
         :	                                                                                OldSerXidPage(xid), xid);
         :	        val = OldSerXidValue(slotno, xid);
    0.00 :	  694a42:       48 8b 04 c2             mov    (%rdx,%rax,8),%rax
    0.00 :	  694a46:       4c 8b 24 c8             mov    (%rax,%rcx,8),%r12
         :	        LWLockRelease(OldSerXidLock);
    0.00 :	  694a4a:       e8 51 a9 ff ff          callq  68f3a0 <LWLockRelease>
         :	                 * got pushed out to SLRU storage for "old committed" transactions.
         :	                 */
         :	                SerCommitSeqNo conflictCommitSeqNo;
         :
         :	                conflictCommitSeqNo = OldSerXidGetMinConflictCommitSeqNo(xid);
         :	                if (conflictCommitSeqNo != 0)
    0.00 :	  694a4f:       4d 85 e4                test   %r12,%r12
    0.00 :	  694a52:       0f 84 48 fe ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
         :	                {
         :	                        if (conflictCommitSeqNo != InvalidSerCommitSeqNo
    0.00 :	  694a58:       49 83 fc ff             cmp    $0xffffffffffffffff,%r12
    0.00 :	  694a5c:       74 77                   je     694ad5 <CheckForSerializableConflictOut+0x475>
    0.00 :	  694a5e:       48 8b 05 5b 9c 4e 00    mov    0x4e9c5b(%rip),%rax        # b7e6c0 <MySerializableXact>
    0.00 :	  694a65:       f6 40 7c 20             testb  $0x20,0x7c(%rax)
    0.00 :	  694a69:       74 06                   je     694a71 <CheckForSerializableConflictOut+0x411>
    0.00 :	  694a6b:       4c 39 60 18             cmp    %r12,0x18(%rax)
    0.00 :	  694a6f:       72 6b                   jb     694adc <CheckForSerializableConflictOut+0x47c>
         :	                                && (!SxactIsReadOnly(MySerializableXact)
         :	                                        || conflictCommitSeqNo
         :	                                        <= MySerializableXact->SeqNo.lastCommitBeforeSnapshot))
         :	                                ereport(ERROR,
    0.00 :	  694a71:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694a74:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694a79:       ba 89 0f 00 00          mov    $0xf89,%edx
    0.00 :	  694a7e:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694a83:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694a88:       e8 33 60 0e 00          callq  77aac0 <errstart>
    0.00 :	  694a8d:       84 c0                   test   %al,%al
    0.00 :	  694a8f:       0f 84 84 fc ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694a95:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694a9a:       31 c0                   xor    %eax,%eax
    0.00 :	  694a9c:       e8 ff 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694aa1:       89 de                   mov    %ebx,%esi
    0.00 :	  694aa3:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694aa6:       bf e0 d8 8a 00          mov    $0x8ad8e0,%edi
    0.00 :	  694aab:       31 c0                   xor    %eax,%eax
    0.00 :	  694aad:       e8 ce 78 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  694ab2:       e9 b8 fe ff ff          jmpq   69496f <CheckForSerializableConflictOut+0x30f>
         :	        /*
         :	         * If this is a read-only transaction and the writing transaction has
         :	         * committed, and it doesn't have a rw-conflict to a transaction which
         :	         * committed before it, no conflict.
         :	         */
         :	        if (SxactIsReadOnly(MySerializableXact)
    0.00 :	  694ab7:       83 e2 10                and    $0x10,%edx
    0.00 :	  694aba:       0f 84 e0 fd ff ff       je     6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  694ac0:       49 8b 44 24 18          mov    0x18(%r12),%rax
    0.00 :	  694ac5:       48 39 41 18             cmp    %rax,0x18(%rcx)
    0.00 :	  694ac9:       0f 83 ff fd ff ff       jae    6948ce <CheckForSerializableConflictOut+0x26e>
    0.00 :	  694acf:       90                      nop
    0.00 :	  694ad0:       e9 cb fd ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
    0.00 :	  694ad5:       48 8b 05 e4 9b 4e 00    mov    0x4e9be4(%rip),%rax        # b7e6c0 <MySerializableXact>
         :	                                                (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
         :	                                                 errmsg("could not serialize access due to read/write dependencies among transactions"),
         :	                                                 errdetail_internal("Reason code: Canceled on conflict out to old pivot %u.", xid),
         :	                                          errhint("The transaction might succeed if retried.")));
         :
         :	                        if (SxactHasSummaryConflictIn(MySerializableXact)
    0.00 :	  694adc:       f6 40 7d 02             testb  $0x2,0x7d(%rax)
    0.00 :	  694ae0:       75 0d                   jne    694aef <CheckForSerializableConflictOut+0x48f>
    0.00 :	  694ae2:       48 8d 78 30             lea    0x30(%rax),%rdi
    0.00 :	  694ae6:       e8 25 ea fe ff          callq  683510 <SHMQueueEmpty>
    0.00 :	  694aeb:       84 c0                   test   %al,%al
    0.00 :	  694aed:       75 46                   jne    694b35 <CheckForSerializableConflictOut+0x4d5>
         :	                                || !SHMQueueEmpty(&MySerializableXact->inConflicts))
         :	                                ereport(ERROR,
    0.00 :	  694aef:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694af2:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694af7:       ba 91 0f 00 00          mov    $0xf91,%edx
    0.00 :	  694afc:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694b01:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694b06:       e8 b5 5f 0e 00          callq  77aac0 <errstart>
    0.00 :	  694b0b:       84 c0                   test   %al,%al
    0.00 :	  694b0d:       0f 84 06 fc ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694b13:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694b18:       31 c0                   xor    %eax,%eax
    0.00 :	  694b1a:       e8 81 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694b1f:       89 de                   mov    %ebx,%esi
    0.00 :	  694b21:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694b24:       bf 18 d9 8a 00          mov    $0x8ad918,%edi
    0.00 :	  694b29:       31 c0                   xor    %eax,%eax
    0.00 :	  694b2b:       e8 50 78 0e 00          callq  77c380 <errdetail_internal>
    0.00 :	  694b30:       e9 3a fe ff ff          jmpq   69496f <CheckForSerializableConflictOut+0x30f>
         :	                                                (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
         :	                                                 errmsg("could not serialize access due to read/write dependencies among transactions"),
         :	                                                 errdetail_internal("Reason code: Canceled on identification as a pivot, with conflict out to old committed transaction %u.", xid),
         :	                                          errhint("The transaction might succeed if retried.")));
         :
         :	                        MySerializableXact->flags |= SXACT_FLAG_SUMMARY_CONFLICT_OUT;
    0.00 :	  694b35:       48 8b 05 84 9b 4e 00    mov    0x4e9b84(%rip),%rax        # b7e6c0 <MySerializableXact>
    0.00 :	  694b3c:       81 48 7c 00 04 00 00    orl    $0x400,0x7c(%rax)
    0.00 :	  694b43:       e9 58 fd ff ff          jmpq   6948a0 <CheckForSerializableConflictOut+0x240>
         :	                        LWLockRelease(SerializableXactHashLock);
         :	                        return;
         :	                }
         :	                else
         :	                {
         :	                        LWLockRelease(SerializableXactHashLock);
    0.00 :	  694b48:       48 8b 3d b1 8e 4e 00    mov    0x4e8eb1(%rip),%rdi        # b7da00 <MainLWLockArray>
    0.00 :	  694b4f:       48 81 c7 80 03 00 00    add    $0x380,%rdi
    0.00 :	  694b56:       e8 45 a8 ff ff          callq  68f3a0 <LWLockRelease>
         :	                        ereport(ERROR,
    0.00 :	  694b5b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694b5e:       b9 e0 da 8a 00          mov    $0x8adae0,%ecx
    0.00 :	  694b63:       ba b8 0f 00 00          mov    $0xfb8,%edx
    0.00 :	  694b68:       be d3 d1 8a 00          mov    $0x8ad1d3,%esi
    0.00 :	  694b6d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  694b72:       e8 49 5f 0e 00          callq  77aac0 <errstart>
    0.00 :	  694b77:       84 c0                   test   %al,%al
    0.00 :	  694b79:       0f 84 9a fb ff ff       je     694719 <CheckForSerializableConflictOut+0xb9>
    0.00 :	  694b7f:       bf c8 d2 8a 00          mov    $0x8ad2c8,%edi
    0.00 :	  694b84:       31 c0                   xor    %eax,%eax
    0.00 :	  694b86:       e8 15 71 0e 00          callq  77bca0 <errhint>
    0.00 :	  694b8b:       bf 80 d9 8a 00          mov    $0x8ad980,%edi
    0.00 :	  694b90:       41 89 c5                mov    %eax,%r13d
    0.00 :	  694b93:       e9 d0 fd ff ff          jmpq   694968 <CheckForSerializableConflictOut+0x308>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:391
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:396
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006ea7a0 <int4eq>:
         :	 *              intge                   - returns 1 iff arg1 >= arg2
         :	 */
         :
         :	Datum
         :	int4eq(PG_FUNCTION_ARGS)
         :	{
   50.00 :	  6ea7a0:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  6ea7a4:       39 47 20                cmp    %eax,0x20(%rdi)
    0.00 :	  6ea7a7:       55                      push   %rbp
    0.00 :	  6ea7a8:       48 89 e5                mov    %rsp,%rbp
         :	        int32           arg1 = PG_GETARG_INT32(0);
         :	        int32           arg2 = PG_GETARG_INT32(1);
         :
         :	        PG_RETURN_BOOL(arg1 == arg2);
         :	}
    0.00 :	  6ea7ab:       c9                      leaveq 
         :	 *              intge                   - returns 1 iff arg1 >= arg2
         :	 */
         :
         :	Datum
         :	int4eq(PG_FUNCTION_ARGS)
         :	{
   25.00 :	  6ea7ac:       0f 94 c0                sete   %al
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/int.c:396
   25.00 :	  6ea7af:       0f b6 c0                movzbl %al,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:756
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:735
   25.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:754
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798b80 <pfree>:
         :	 * pfree
         :	 *              Release an allocated chunk.
         :	 */
         :	void
         :	pfree(void *pointer)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:735
   25.00 :	  798b80:       55                      push   %rbp
    0.00 :	  798b81:       48 89 f8                mov    %rdi,%rax
         :	        Assert(pointer == (void *) MAXALIGN(pointer));
         :
         :	        /*
         :	         * OK, it's probably safe to look at the chunk header.
         :	         */
         :	        context = ((StandardChunkHeader *)
    0.00 :	  798b84:       48 8b 7f f0             mov    -0x10(%rdi),%rdi
         :	                           ((char *) pointer - STANDARDCHUNKHEADERSIZE))->context;
         :
         :	        AssertArg(MemoryContextIsValid(context));
         :
         :	        (*context->methods->free_p) (context, pointer);
    0.00 :	  798b88:       48 89 c6                mov    %rax,%rsi
         :	 * pfree
         :	 *              Release an allocated chunk.
         :	 */
         :	void
         :	pfree(void *pointer)
         :	{
    0.00 :	  798b8b:       48 89 e5                mov    %rsp,%rbp
         :	        context = ((StandardChunkHeader *)
         :	                           ((char *) pointer - STANDARDCHUNKHEADERSIZE))->context;
         :
         :	        AssertArg(MemoryContextIsValid(context));
         :
         :	        (*context->methods->free_p) (context, pointer);
    0.00 :	  798b8e:       48 8b 57 08             mov    0x8(%rdi),%rdx
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:754
   25.00 :	  798b92:       4c 8b 5a 08             mov    0x8(%rdx),%r11
         :	        VALGRIND_MEMPOOL_FREE(context, pointer);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:756
   50.00 :	  798b96:       c9                      leaveq 
         :	        context = ((StandardChunkHeader *)
         :	                           ((char *) pointer - STANDARDCHUNKHEADERSIZE))->context;
         :
         :	        AssertArg(MemoryContextIsValid(context));
         :
         :	        (*context->methods->free_p) (context, pointer);
    0.00 :	  798b97:       41 ff e3                jmpq   *%r11

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .plt:
         :
         :	00000000004695c0 <gettimeofday@plt>:
 ??:0
  100.00 :	  4695c0:       ff 25 82 db 6f 00       jmpq   *0x6fdb82(%rip)        # b67148 <_GLOBAL_OFFSET_TABLE_+0x148>
    0.00 :	  4695c6:       68 26 00 00 00          pushq  $0x26
    0.00 :	  4695cb:       e9 80 fd ff ff          jmpq   469350 <_init+0x20>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/access/common/scankey.c:109
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/common/scankey.c:109
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000473b40 <ScanKeyEntryInitializeWithInfo>:
         :	                                                           StrategyNumber strategy,
         :	                                                           Oid subtype,
         :	                                                           Oid collation,
         :	                                                           FmgrInfo *finfo,
         :	                                                           Datum argument)
         :	{
   33.33 :	  473b40:       55                      push   %rbp
   66.67 :	  473b41:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  473b44:       4c 8b 55 10             mov    0x10(%rbp),%r10
         :	        entry->sk_flags = flags;
    0.00 :	  473b48:       89 37                   mov    %esi,(%rdi)
         :	        entry->sk_attno = attributeNumber;
    0.00 :	  473b4a:       66 89 57 04             mov    %dx,0x4(%rdi)
         :	        entry->sk_strategy = strategy;
    0.00 :	  473b4e:       66 89 4f 06             mov    %cx,0x6(%rdi)
         :	        entry->sk_subtype = subtype;
    0.00 :	  473b52:       44 89 47 08             mov    %r8d,0x8(%rdi)
         :	        entry->sk_collation = collation;
    0.00 :	  473b56:       44 89 4f 0c             mov    %r9d,0xc(%rdi)
         :	        entry->sk_argument = argument;
    0.00 :	  473b5a:       48 8b 45 18             mov    0x18(%rbp),%rax
         :	        fmgr_info_copy(&entry->sk_func, finfo, CurrentMemoryContext);
    0.00 :	  473b5e:       4c 89 d6                mov    %r10,%rsi
         :	        entry->sk_flags = flags;
         :	        entry->sk_attno = attributeNumber;
         :	        entry->sk_strategy = strategy;
         :	        entry->sk_subtype = subtype;
         :	        entry->sk_collation = collation;
         :	        entry->sk_argument = argument;
    0.00 :	  473b61:       48 89 47 40             mov    %rax,0x40(%rdi)
         :	        fmgr_info_copy(&entry->sk_func, finfo, CurrentMemoryContext);
    0.00 :	  473b65:       48 8b 15 f4 6c 74 00    mov    0x746cf4(%rip),%rdx        # bba860 <CurrentMemoryContext>
    0.00 :	  473b6c:       48 83 c7 10             add    $0x10,%rdi
         :	}
    0.00 :	  473b70:       c9                      leaveq 
         :	        entry->sk_attno = attributeNumber;
         :	        entry->sk_strategy = strategy;
         :	        entry->sk_subtype = subtype;
         :	        entry->sk_collation = collation;
         :	        entry->sk_argument = argument;
         :	        fmgr_info_copy(&entry->sk_func, finfo, CurrentMemoryContext);
    0.00 :	  473b71:       e9 ca bb 30 00          jmpq   77f740 <fmgr_info_copy>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:452
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:481
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:485
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5630 <index_getnext_tid>:
         :	 * or NULL if no more matching tuples exist.
         :	 * ----------------
         :	 */
         :	ItemPointer
         :	index_getnext_tid(IndexScanDesc scan, ScanDirection direction)
         :	{
    0.00 :	  4a5630:       55                      push   %rbp
    0.00 :	  4a5631:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a5634:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  4a5638:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  4a563c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  4a563f:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  4a5643:       48 83 ec 20             sub    $0x20,%rsp
         :	        FmgrInfo   *procedure;
         :	        bool            found;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amgettuple);
    0.00 :	  4a5647:       48 8b 57 08             mov    0x8(%rdi),%rdx
         :	 * or NULL if no more matching tuples exist.
         :	 * ----------------
         :	 */
         :	ItemPointer
         :	index_getnext_tid(IndexScanDesc scan, ScanDirection direction)
         :	{
    0.00 :	  4a564b:       41 89 f5                mov    %esi,%r13d
         :	        FmgrInfo   *procedure;
         :	        bool            found;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amgettuple);
    0.00 :	  4a564e:       48 8b 82 c0 00 00 00    mov    0xc0(%rdx),%rax
    0.00 :	  4a5655:       44 8b 40 68             mov    0x68(%rax),%r8d
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:452
   33.33 :	  4a5659:       4c 8d 60 60             lea    0x60(%rax),%r12
    0.00 :	  4a565d:       45 85 c0                test   %r8d,%r8d
    0.00 :	  4a5660:       75 1d                   jne    4a567f <index_getnext_tid+0x4f>
    0.00 :	  4a5662:       48 8b 82 b0 00 00 00    mov    0xb0(%rdx),%rax
    0.00 :	  4a5669:       8b 78 5c                mov    0x5c(%rax),%edi
    0.00 :	  4a566c:       85 ff                   test   %edi,%edi
    0.00 :	  4a566e:       74 69                   je     4a56d9 <index_getnext_tid+0xa9>
    0.00 :	  4a5670:       48 8b 92 b8 00 00 00    mov    0xb8(%rdx),%rdx
    0.00 :	  4a5677:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  4a567a:       e8 d1 a9 2d 00          callq  780050 <fmgr_info_cxt>
         :	         * The AM's amgettuple proc finds the next index entry matching the scan
         :	         * keys, and puts the TID into scan->xs_ctup.t_self.  It should also set
         :	         * scan->xs_recheck and possibly scan->xs_itup, though we pay no attention
         :	         * to those fields here.
         :	         */
         :	        found = DatumGetBool(FunctionCall2(procedure,
    0.00 :	  4a567f:       31 f6                   xor    %esi,%esi
    0.00 :	  4a5681:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  4a5684:       48 89 da                mov    %rbx,%rdx
    0.00 :	  4a5687:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4a568a:       e8 a1 89 2d 00          callq  77e030 <FunctionCall2Coll>
         :
         :	        /* Reset kill flag immediately for safety */
         :	        scan->kill_prior_tuple = false;
         :
         :	        /* If we're out of index entries, we're done */
         :	        if (!found)
    0.00 :	  4a568f:       84 c0                   test   %al,%al
         :	        found = DatumGetBool(FunctionCall2(procedure,
         :	                                                                           PointerGetDatum(scan),
         :	                                                                           Int32GetDatum(direction)));
         :
         :	        /* Reset kill flag immediately for safety */
         :	        scan->kill_prior_tuple = false;
    0.00 :	  4a5691:       c6 43 31 00             movb   $0x0,0x31(%rbx)
         :
         :	        /* If we're out of index entries, we're done */
         :	        if (!found)
    0.00 :	  4a5695:       74 29                   je     4a56c0 <index_getnext_tid+0x90>
         :	                        scan->xs_cbuf = InvalidBuffer;
         :	                }
         :	                return NULL;
         :	        }
         :
         :	        pgstat_count_index_tuples(scan->indexRelation, 1);
    0.00 :	  4a5697:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  4a569b:       48 8b 80 38 01 00 00    mov    0x138(%rax),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:481
   33.33 :	  4a56a2:       48 85 c0                test   %rax,%rax
    0.00 :	  4a56a5:       74 05                   je     4a56ac <index_getnext_tid+0x7c>
    0.00 :	  4a56a7:       48 83 40 18 01          addq   $0x1,0x18(%rax)
         :
         :	        /* Return the TID of the tuple we found. */
         :	        return &scan->xs_ctup.t_self;
    0.00 :	  4a56ac:       48 8d 43 54             lea    0x54(%rbx),%rax
         :	}
    0.00 :	  4a56b0:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  4a56b4:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  4a56b8:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  4a56bc:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:485
   33.33 :	  4a56bd:       c3                      retq   
    0.00 :	  4a56be:       66 90                   xchg   %ax,%ax
         :
         :	        /* If we're out of index entries, we're done */
         :	        if (!found)
         :	        {
         :	                /* ... but first, release any held pin on a heap page */
         :	                if (BufferIsValid(scan->xs_cbuf))
    0.00 :	  4a56c0:       8b 7b 68                mov    0x68(%rbx),%edi
    0.00 :	  4a56c3:       31 c0                   xor    %eax,%eax
    0.00 :	  4a56c5:       85 ff                   test   %edi,%edi
    0.00 :	  4a56c7:       74 e7                   je     4a56b0 <index_getnext_tid+0x80>
         :	                {
         :	                        ReleaseBuffer(scan->xs_cbuf);
    0.00 :	  4a56c9:       e8 92 f7 1c 00          callq  674e60 <ReleaseBuffer>
         :	                        scan->xs_cbuf = InvalidBuffer;
    0.00 :	  4a56ce:       c7 43 68 00 00 00 00    movl   $0x0,0x68(%rbx)
    0.00 :	  4a56d5:       31 c0                   xor    %eax,%eax
    0.00 :	  4a56d7:       eb d7                   jmp    4a56b0 <index_getnext_tid+0x80>
         :	{
         :	        FmgrInfo   *procedure;
         :	        bool            found;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amgettuple);
    0.00 :	  4a56d9:       ba 50 3c 7b 00          mov    $0x7b3c50,%edx
    0.00 :	  4a56de:       be c4 01 00 00          mov    $0x1c4,%esi
    0.00 :	  4a56e3:       bf 33 3b 7b 00          mov    $0x7b3b33,%edi
    0.00 :	  4a56e8:       e8 33 5d 2d 00          callq  77b420 <elog_start>
    0.00 :	  4a56ed:       ba 8e 3b 7b 00          mov    $0x7b3b8e,%edx
    0.00 :	  4a56f2:       be 48 3b 7b 00          mov    $0x7b3b48,%esi
    0.00 :	  4a56f7:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4a56fc:       31 c0                   xor    %eax,%eax
    0.00 :	  4a56fe:       e8 2d 5b 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4a5703:       e8 c8 3d fc ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:333
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:359
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:359
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a5810 <index_rescan>:
         :	 */
         :	void
         :	index_rescan(IndexScanDesc scan,
         :	                         ScanKey keys, int nkeys,
         :	                         ScanKey orderbys, int norderbys)
         :	{
    0.00 :	  4a5810:       55                      push   %rbp
    0.00 :	  4a5811:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:333
   33.33 :	  4a5814:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  4a5818:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  4a581c:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  4a581f:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  4a5823:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  4a5827:       45 89 c5                mov    %r8d,%r13d
    0.00 :	  4a582a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  4a582e:       48 83 ec 40             sub    $0x40,%rsp
    0.00 :	  4a5832:       41 89 d7                mov    %edx,%r15d
    0.00 :	  4a5835:       48 89 75 d0             mov    %rsi,-0x30(%rbp)
         :	        FmgrInfo   *procedure;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amrescan);
    0.00 :	  4a5839:       48 8b 57 08             mov    0x8(%rdi),%rdx
         :	 */
         :	void
         :	index_rescan(IndexScanDesc scan,
         :	                         ScanKey keys, int nkeys,
         :	                         ScanKey orderbys, int norderbys)
         :	{
    0.00 :	  4a583d:       49 89 ce                mov    %rcx,%r14
         :	        FmgrInfo   *procedure;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amrescan);
    0.00 :	  4a5840:       48 8b 82 c0 00 00 00    mov    0xc0(%rdx),%rax
    0.00 :	  4a5847:       44 8b 90 c8 00 00 00    mov    0xc8(%rax),%r10d
    0.00 :	  4a584e:       4c 8d a0 c0 00 00 00    lea    0xc0(%rax),%r12
    0.00 :	  4a5855:       45 85 d2                test   %r10d,%r10d
    0.00 :	  4a5858:       75 1d                   jne    4a5877 <index_rescan+0x67>
    0.00 :	  4a585a:       48 8b 82 b0 00 00 00    mov    0xb0(%rdx),%rax
    0.00 :	  4a5861:       8b 78 64                mov    0x64(%rax),%edi
    0.00 :	  4a5864:       85 ff                   test   %edi,%edi
    0.00 :	  4a5866:       74 5e                   je     4a58c6 <index_rescan+0xb6>
    0.00 :	  4a5868:       48 8b 92 b8 00 00 00    mov    0xb8(%rdx),%rdx
    0.00 :	  4a586f:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  4a5872:       e8 d9 a7 2d 00          callq  780050 <fmgr_info_cxt>
         :
         :	        Assert(nkeys == scan->numberOfKeys);
         :	        Assert(norderbys == scan->numberOfOrderBys);
         :
         :	        /* Release any held pin on a heap page */
         :	        if (BufferIsValid(scan->xs_cbuf))
    0.00 :	  4a5877:       8b 7b 68                mov    0x68(%rbx),%edi
    0.00 :	  4a587a:       85 ff                   test   %edi,%edi
    0.00 :	  4a587c:       74 0c                   je     4a588a <index_rescan+0x7a>
         :	        {
         :	                ReleaseBuffer(scan->xs_cbuf);
    0.00 :	  4a587e:       e8 dd f5 1c 00          callq  674e60 <ReleaseBuffer>
         :	                scan->xs_cbuf = InvalidBuffer;
    0.00 :	  4a5883:       c7 43 68 00 00 00 00    movl   $0x0,0x68(%rbx)
         :
         :	        scan->xs_continue_hot = false;
         :
         :	        scan->kill_prior_tuple = false;         /* for safety */
         :
         :	        FunctionCall5(procedure,
    0.00 :	  4a588a:       48 8b 4d d0             mov    -0x30(%rbp),%rcx
         :	        {
         :	                ReleaseBuffer(scan->xs_cbuf);
         :	                scan->xs_cbuf = InvalidBuffer;
         :	        }
         :
         :	        scan->xs_continue_hot = false;
    0.00 :	  4a588e:       c6 43 6d 00             movb   $0x0,0x6d(%rbx)
         :
         :	        scan->kill_prior_tuple = false;         /* for safety */
         :
         :	        FunctionCall5(procedure,
    0.00 :	  4a5892:       45 89 ed                mov    %r13d,%r13d
         :	                scan->xs_cbuf = InvalidBuffer;
         :	        }
         :
         :	        scan->xs_continue_hot = false;
         :
         :	        scan->kill_prior_tuple = false;         /* for safety */
    0.00 :	  4a5895:       c6 43 31 00             movb   $0x0,0x31(%rbx)
         :
         :	        FunctionCall5(procedure,
    0.00 :	  4a5899:       4d 89 f1                mov    %r14,%r9
    0.00 :	  4a589c:       45 89 f8                mov    %r15d,%r8d
    0.00 :	  4a589f:       48 89 da                mov    %rbx,%rdx
    0.00 :	  4a58a2:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  4a58a5:       31 f6                   xor    %esi,%esi
    0.00 :	  4a58a7:       4c 89 2c 24             mov    %r13,(%rsp)
    0.00 :	  4a58ab:       e8 40 85 2d 00          callq  77ddf0 <FunctionCall5Coll>
         :	                                  PointerGetDatum(scan),
         :	                                  PointerGetDatum(keys),
         :	                                  Int32GetDatum(nkeys),
         :	                                  PointerGetDatum(orderbys),
         :	                                  Int32GetDatum(norderbys));
         :	}
    0.00 :	  4a58b0:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:359
   33.33 :	  4a58b4:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  4a58b8:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  4a58bc:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  4a58c0:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
   33.33 :	  4a58c4:       c9                      leaveq 
    0.00 :	  4a58c5:       c3                      retq   
         :	                         ScanKey orderbys, int norderbys)
         :	{
         :	        FmgrInfo   *procedure;
         :
         :	        SCAN_CHECKS;
         :	        GET_SCAN_PROCEDURE(amrescan);
    0.00 :	  4a58c6:       ba 8d 3c 7b 00          mov    $0x7b3c8d,%edx
    0.00 :	  4a58cb:       be 51 01 00 00          mov    $0x151,%esi
    0.00 :	  4a58d0:       bf 33 3b 7b 00          mov    $0x7b3b33,%edi
    0.00 :	  4a58d5:       e8 46 5b 2d 00          callq  77b420 <elog_start>
    0.00 :	  4a58da:       ba a3 3b 7b 00          mov    $0x7b3ba3,%edx
    0.00 :	  4a58df:       be 48 3b 7b 00          mov    $0x7b3b48,%esi
    0.00 :	  4a58e4:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4a58e9:       31 c0                   xor    %eax,%eax
    0.00 :	  4a58eb:       e8 40 59 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4a58f0:       e8 db 3b fc ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1228
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1285
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1273
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ac680 <_bt_steppage>:
         :	 * If there are no more matching records in the given direction, we drop all
         :	 * locks and pins, set so->currPos.buf to InvalidBuffer, and return FALSE.
         :	 */
         :	static bool
         :	_bt_steppage(IndexScanDesc scan, ScanDirection dir)
         :	{
    0.00 :	  4ac680:       55                      push   %rbp
    0.00 :	  4ac681:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ac684:       41 57                   push   %r15
    0.00 :	  4ac686:       41 56                   push   %r14
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1228
   33.33 :	  4ac688:       41 55                   push   %r13
    0.00 :	  4ac68a:       41 54                   push   %r12
    0.00 :	  4ac68c:       53                      push   %rbx
    0.00 :	  4ac68d:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  4ac691:       48 89 7d c8             mov    %rdi,-0x38(%rbp)
    0.00 :	  4ac695:       89 75 c4                mov    %esi,-0x3c(%rbp)
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4ac698:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  4ac69c:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :
         :	        /* we must have the buffer pinned and locked */
         :	        Assert(BufferIsValid(so->currPos.buf));
         :
         :	        /* Before leaving current page, deal with any killed items */
         :	        if (so->numKilled > 0)
    0.00 :	  4ac6a0:       8b 70 38                mov    0x38(%rax),%esi
    0.00 :	  4ac6a3:       85 f6                   test   %esi,%esi
    0.00 :	  4ac6a5:       7e 0a                   jle    4ac6b1 <_bt_steppage+0x31>
         :	                _bt_killitems(scan, true);
    0.00 :	  4ac6a7:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4ac6ac:       e8 cf 1b 00 00          callq  4ae280 <_bt_killitems>
         :
         :	        /*
         :	         * Before we modify currPos, make a copy of the page data if there was a
         :	         * mark position that needs it.
         :	         */
         :	        if (so->markItemIndex >= 0)
    0.00 :	  4ac6b1:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4ac6b5:       8b 4a 50                mov    0x50(%rdx),%ecx
    0.00 :	  4ac6b8:       85 c9                   test   %ecx,%ecx
    0.00 :	  4ac6ba:       78 62                   js     4ac71e <_bt_steppage+0x9e>
         :	        {
         :	                /* bump pin on current buffer for assignment to mark buffer */
         :	                IncrBufferRefCount(so->currPos.buf);
    0.00 :	  4ac6bc:       8b 7a 54                mov    0x54(%rdx),%edi
    0.00 :	  4ac6bf:       e8 9c 84 1c 00          callq  674b60 <IncrBufferRefCount>
         :	                memcpy(&so->markPos, &so->currPos,
    0.00 :	  4ac6c4:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  4ac6c8:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  4ac6cc:       48 63 50 68             movslq 0x68(%rax),%rdx
    0.00 :	  4ac6d0:       48 89 c6                mov    %rax,%rsi
    0.00 :	  4ac6d3:       48 81 c7 60 10 00 00    add    $0x1060,%rdi
    0.00 :	  4ac6da:       48 83 c6 54             add    $0x54,%rsi
    0.00 :	  4ac6de:       48 8d 14 92             lea    (%rdx,%rdx,4),%rdx
    0.00 :	  4ac6e2:       48 8d 54 12 26          lea    0x26(%rdx,%rdx,1),%rdx
    0.00 :	  4ac6e7:       e8 04 d5 fb ff          callq  469bf0 <memcpy@plt>
         :	                           offsetof(BTScanPosData, items[1]) +
         :	                           so->currPos.lastItem * sizeof(BTScanPosItem));
         :	                if (so->markTuples)
    0.00 :	  4ac6ec:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4ac6f0:       48 8b 7a 48             mov    0x48(%rdx),%rdi
    0.00 :	  4ac6f4:       48 85 ff                test   %rdi,%rdi
    0.00 :	  4ac6f7:       74 11                   je     4ac70a <_bt_steppage+0x8a>
         :	                        memcpy(so->markTuples, so->currTuples,
    0.00 :	  4ac6f9:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  4ac6fd:       48 63 52 60             movslq 0x60(%rdx),%rdx
    0.00 :	  4ac701:       48 8b 70 40             mov    0x40(%rax),%rsi
    0.00 :	  4ac705:       e8 e6 d4 fb ff          callq  469bf0 <memcpy@plt>
         :	                                   so->currPos.nextTupleOffset);
         :	                so->markPos.itemIndex = so->markItemIndex;
    0.00 :	  4ac70a:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4ac70e:       8b 42 50                mov    0x50(%rdx),%eax
         :	                so->markItemIndex = -1;
    0.00 :	  4ac711:       c7 42 50 ff ff ff ff    movl   $0xffffffff,0x50(%rdx)
         :	                           offsetof(BTScanPosData, items[1]) +
         :	                           so->currPos.lastItem * sizeof(BTScanPosItem));
         :	                if (so->markTuples)
         :	                        memcpy(so->markTuples, so->currTuples,
         :	                                   so->currPos.nextTupleOffset);
         :	                so->markPos.itemIndex = so->markItemIndex;
    0.00 :	  4ac718:       89 82 78 10 00 00       mov    %eax,0x1078(%rdx)
         :	                so->markItemIndex = -1;
         :	        }
         :
         :	        rel = scan->indexRelation;
         :
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ac71e:       83 7d c4 01             cmpl   $0x1,-0x3c(%rbp)
         :	                                   so->currPos.nextTupleOffset);
         :	                so->markPos.itemIndex = so->markItemIndex;
         :	                so->markItemIndex = -1;
         :	        }
         :
         :	        rel = scan->indexRelation;
    0.00 :	  4ac722:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4ac726:       4c 8b 68 08             mov    0x8(%rax),%r13
         :
         :	        if (ScanDirectionIsForward(dir))
    0.00 :	  4ac72a:       0f 84 46 03 00 00       je     4aca76 <_bt_steppage+0x3f6>
         :	                }
         :	        }
         :	        else
         :	        {
         :	                /* Remember we left a page with data */
         :	                so->currPos.moreRight = true;
    0.00 :	  4ac730:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4ac734:       c6 42 5d 01             movb   $0x1,0x5d(%rdx)
         :	                 * it.  See nbtree/README for details.
         :	                 */
         :	                for (;;)
         :	                {
         :	                        /* Done if we know there are no matching keys to the left */
         :	                        if (!so->currPos.moreLeft)
    0.00 :	  4ac738:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  4ac73c:       80 78 5c 00             cmpb   $0x0,0x5c(%rax)
    0.00 :	  4ac740:       0f 84 17 04 00 00       je     4acb5d <_bt_steppage+0x4dd>
         :	                                so->currPos.buf = InvalidBuffer;
         :	                                return false;
         :	                        }
         :
         :	                        /* Step to next physical page */
         :	                        so->currPos.buf = _bt_walk_left(rel, so->currPos.buf);
    0.00 :	  4ac746:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  4ac74a:       44 8b 60 54             mov    0x54(%rax),%r12d
         :	_bt_walk_left(Relation rel, Buffer buf)
         :	{
         :	        Page            page;
         :	        BTPageOpaque opaque;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4ac74e:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4ac751:       0f 88 9d 02 00 00       js     4ac9f4 <_bt_steppage+0x374>
    0.00 :	  4ac757:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4ac75c:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac75f:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ac763:       48 03 15 8e 33 71 00    add    0x71338e(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ac76a:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4ac76e:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
    0.00 :	  4ac772:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                BlockNumber lblkno;
         :	                BlockNumber blkno;
         :	                int                     tries;
         :
         :	                /* if we're at end of tree, release buf and return failure */
         :	                if (P_LEFTMOST(opaque))
    0.00 :	  4ac778:       8b 03                   mov    (%rbx),%eax
    0.00 :	  4ac77a:       85 c0                   test   %eax,%eax
    0.00 :	  4ac77c:       0f 84 b7 02 00 00       je     4aca39 <_bt_steppage+0x3b9>
         :	                {
         :	                        _bt_relbuf(rel, buf);
         :	                        break;
         :	                }
         :	                /* remember original page we are stepping left from */
         :	                obknum = BufferGetBlockNumber(buf);
    0.00 :	  4ac782:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4ac785:       e8 a6 78 1c 00          callq  674030 <BufferGetBlockNumber>
         :	                /* step left */
         :	                blkno = lblkno = opaque->btpo_prev;
         :	                _bt_relbuf(rel, buf);
    0.00 :	  4ac78a:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4ac78d:       4c 89 ef                mov    %r13,%rdi
         :	                {
         :	                        _bt_relbuf(rel, buf);
         :	                        break;
         :	                }
         :	                /* remember original page we are stepping left from */
         :	                obknum = BufferGetBlockNumber(buf);
    0.00 :	  4ac790:       41 89 c6                mov    %eax,%r14d
         :	                /* step left */
         :	                blkno = lblkno = opaque->btpo_prev;
    0.00 :	  4ac793:       44 8b 3b                mov    (%rbx),%r15d
         :	                _bt_relbuf(rel, buf);
    0.00 :	  4ac796:       e8 35 c8 ff ff          callq  4a8fd0 <_bt_relbuf>
         :	                /* check for interrupts while we're not holding any buffer lock */
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  4ac79b:       0f b6 05 ee d8 70 00    movzbl 0x70d8ee(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  4ac7a2:       84 c0                   test   %al,%al
    0.00 :	  4ac7a4:       0f 85 0e 02 00 00       jne    4ac9b8 <_bt_steppage+0x338>
         :	                buf = _bt_getbuf(rel, blkno, BT_READ);
    0.00 :	  4ac7aa:       44 89 fe                mov    %r15d,%esi
    0.00 :	  4ac7ad:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4ac7b2:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ac7b5:       e8 96 c8 ff ff          callq  4a9050 <_bt_getbuf>
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac7ba:       85 c0                   test   %eax,%eax
         :	                /* step left */
         :	                blkno = lblkno = opaque->btpo_prev;
         :	                _bt_relbuf(rel, buf);
         :	                /* check for interrupts while we're not holding any buffer lock */
         :	                CHECK_FOR_INTERRUPTS();
         :	                buf = _bt_getbuf(rel, blkno, BT_READ);
    0.00 :	  4ac7bc:       89 c6                   mov    %eax,%esi
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac7be:       0f 88 04 02 00 00       js     4ac9c8 <_bt_steppage+0x348>
    0.00 :	  4ac7c4:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ac7c7:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac7ca:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ac7ce:       48 03 15 23 33 71 00    add    0x713323(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ac7d5:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4ac7d9:       31 db                   xor    %ebx,%ebx
    0.00 :	  4ac7db:       48 8d 04 02             lea    (%rdx,%rax,1),%rax
         :	                 * must reject half-dead pages if wanted.
         :	                 */
         :	                tries = 0;
         :	                for (;;)
         :	                {
         :	                        if (!P_ISDELETED(opaque) && opaque->btpo_next == obknum)
    0.00 :	  4ac7df:       f6 40 0c 04             testb  $0x4,0xc(%rax)
    0.00 :	  4ac7e3:       74 4d                   je     4ac832 <_bt_steppage+0x1b2>
    0.00 :	  4ac7e5:       8b 50 04                mov    0x4(%rax),%edx
         :	                        {
         :	                                /* Found desired page, return it */
         :	                                return buf;
         :	                        }
         :	                        if (P_RIGHTMOST(opaque) || ++tries > 4)
    0.00 :	  4ac7e8:       85 d2                   test   %edx,%edx
    0.00 :	  4ac7ea:       0f 84 f8 00 00 00       je     4ac8e8 <_bt_steppage+0x268>
    0.00 :	  4ac7f0:       83 c3 01                add    $0x1,%ebx
    0.00 :	  4ac7f3:       83 fb 05                cmp    $0x5,%ebx
    0.00 :	  4ac7f6:       0f 84 ec 00 00 00       je     4ac8e8 <_bt_steppage+0x268>
         :	                                break;
         :	                        blkno = opaque->btpo_next;
         :	                        buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
    0.00 :	  4ac7fc:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ac801:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ac804:       e8 d7 c7 ff ff          callq  4a8fe0 <_bt_relandgetbuf>
         :	                        page = BufferGetPage(buf);
    0.00 :	  4ac809:       85 c0                   test   %eax,%eax
         :	                                return buf;
         :	                        }
         :	                        if (P_RIGHTMOST(opaque) || ++tries > 4)
         :	                                break;
         :	                        blkno = opaque->btpo_next;
         :	                        buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
    0.00 :	  4ac80b:       89 c6                   mov    %eax,%esi
         :	                        page = BufferGetPage(buf);
    0.00 :	  4ac80d:       0f 88 bd 00 00 00       js     4ac8d0 <_bt_steppage+0x250>
    0.00 :	  4ac813:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ac816:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac819:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ac81d:       48 03 15 d4 32 71 00    add    0x7132d4(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ac824:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4ac828:       48 8d 04 02             lea    (%rdx,%rax,1),%rax
         :	                 * must reject half-dead pages if wanted.
         :	                 */
         :	                tries = 0;
         :	                for (;;)
         :	                {
         :	                        if (!P_ISDELETED(opaque) && opaque->btpo_next == obknum)
    0.00 :	  4ac82c:       f6 40 0c 04             testb  $0x4,0xc(%rax)
    0.00 :	  4ac830:       75 b3                   jne    4ac7e5 <_bt_steppage+0x165>
    0.00 :	  4ac832:       8b 50 04                mov    0x4(%rax),%edx
    0.00 :	  4ac835:       41 39 d6                cmp    %edx,%r14d
    0.00 :	  4ac838:       75 ae                   jne    4ac7e8 <_bt_steppage+0x168>
         :	                                so->currPos.buf = InvalidBuffer;
         :	                                return false;
         :	                        }
         :
         :	                        /* Step to next physical page */
         :	                        so->currPos.buf = _bt_walk_left(rel, so->currPos.buf);
    0.00 :	  4ac83a:       48 8b 45 d0             mov    -0x30(%rbp),%rax
         :
         :	                        /* if we're physically at end of index, return failure */
         :	                        if (so->currPos.buf == InvalidBuffer)
    0.00 :	  4ac83e:       83 fe 00                cmp    $0x0,%esi
         :	                                so->currPos.buf = InvalidBuffer;
         :	                                return false;
         :	                        }
         :
         :	                        /* Step to next physical page */
         :	                        so->currPos.buf = _bt_walk_left(rel, so->currPos.buf);
    0.00 :	  4ac841:       89 70 54                mov    %esi,0x54(%rax)
         :
         :	                        /* if we're physically at end of index, return failure */
         :	                        if (so->currPos.buf == InvalidBuffer)
    0.00 :	  4ac844:       0f 84 05 02 00 00       je     4aca4f <_bt_steppage+0x3cf>
         :	                        /*
         :	                         * Okay, we managed to move left to a non-deleted page. Done if
         :	                         * it's not half-dead and contains matching tuples. Else loop back
         :	                         * and do it all again.
         :	                         */
         :	                        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4ac84a:       0f 8c 10 02 00 00       jl     4aca60 <_bt_steppage+0x3e0>
    0.00 :	  4ac850:       8d 46 ff                lea    -0x1(%rsi),%eax
    0.00 :	  4ac853:       4c 63 e0                movslq %eax,%r12
    0.00 :	  4ac856:       49 c1 e4 0d             shl    $0xd,%r12
    0.00 :	  4ac85a:       4c 03 25 97 32 71 00    add    0x713297(%rip),%r12        # bbfaf8 <BufferBlocks>
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                        if (!P_IGNORE(opaque))
    0.00 :	  4ac861:       41 0f b7 44 24 10       movzwl 0x10(%r12),%eax
    0.00 :	  4ac867:       41 0f b7 44 04 0c       movzwl 0xc(%r12,%rax,1),%eax
    0.00 :	  4ac86d:       a8 14                   test   $0x14,%al
    0.00 :	  4ac86f:       0f 85 c3 fe ff ff       jne    4ac738 <_bt_steppage+0xb8>
         :	                        {
         :	                                PredicateLockPage(rel, BufferGetBlockNumber(so->currPos.buf), scan->xs_snapshot);
    0.00 :	  4ac875:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  4ac879:       89 f7                   mov    %esi,%edi
    0.00 :	  4ac87b:       48 8b 5a 10             mov    0x10(%rdx),%rbx
    0.00 :	  4ac87f:       e8 ac 77 1c 00          callq  674030 <BufferGetBlockNumber>
    0.00 :	  4ac884:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ac887:       89 c6                   mov    %eax,%esi
    0.00 :	  4ac889:       48 89 da                mov    %rbx,%rdx
    0.00 :	  4ac88c:       e8 cf 69 1e 00          callq  693260 <PredicateLockPage>
         :	                                /* see if there are any matches on this page */
         :	                                /* note that this will clear moreLeft if we can stop */
         :	                                if (_bt_readpage(scan, dir, PageGetMaxOffsetNumber(page)))
    0.00 :	  4ac891:       41 0f b7 44 24 0c       movzwl 0xc(%r12),%eax
    0.00 :	  4ac897:       31 d2                   xor    %edx,%edx
    0.00 :	  4ac899:       66 83 f8 18             cmp    $0x18,%ax
    0.00 :	  4ac89d:       76 0e                   jbe    4ac8ad <_bt_steppage+0x22d>
    0.00 :	  4ac89f:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4ac8a2:       48 83 e8 18             sub    $0x18,%rax
    0.00 :	  4ac8a6:       48 c1 e8 02             shr    $0x2,%rax
    0.00 :	  4ac8aa:       0f b7 d0                movzwl %ax,%edx
    0.00 :	  4ac8ad:       8b 75 c4                mov    -0x3c(%rbp),%esi
    0.00 :	  4ac8b0:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  4ac8b4:       e8 27 fb ff ff          callq  4ac3e0 <_bt_readpage>
    0.00 :	  4ac8b9:       84 c0                   test   %al,%al
    0.00 :	  4ac8bb:       0f 84 77 fe ff ff       je     4ac738 <_bt_steppage+0xb8>
    0.00 :	  4ac8c1:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  4ac8c6:       e9 86 01 00 00          jmpq   4aca51 <_bt_steppage+0x3d1>
    0.00 :	  4ac8cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                        if (P_RIGHTMOST(opaque) || ++tries > 4)
         :	                                break;
         :	                        blkno = opaque->btpo_next;
         :	                        buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
         :	                        page = BufferGetPage(buf);
    0.00 :	  4ac8d0:       48 8b 15 41 08 6d 00    mov    0x6d0841(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac8d7:       f7 d0                   not    %eax
    0.00 :	  4ac8d9:       48 98                   cltq   
    0.00 :	  4ac8db:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4ac8df:       e9 40 ff ff ff          jmpq   4ac824 <_bt_steppage+0x1a4>
    0.00 :	  4ac8e4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                }
         :
         :	                /* Return to the original page to see what's up */
         :	                buf = _bt_relandgetbuf(rel, buf, obknum, BT_READ);
    0.00 :	  4ac8e8:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ac8ed:       44 89 f2                mov    %r14d,%edx
    0.00 :	  4ac8f0:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ac8f3:       e8 e8 c6 ff ff          callq  4a8fe0 <_bt_relandgetbuf>
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac8f8:       85 c0                   test   %eax,%eax
         :	                        page = BufferGetPage(buf);
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                }
         :
         :	                /* Return to the original page to see what's up */
         :	                buf = _bt_relandgetbuf(rel, buf, obknum, BT_READ);
    0.00 :	  4ac8fa:       41 89 c4                mov    %eax,%r12d
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac8fd:       0f 88 dd 00 00 00       js     4ac9e0 <_bt_steppage+0x360>
    0.00 :	  4ac903:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4ac908:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac90b:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ac90f:       48 03 15 e2 31 71 00    add    0x7131e2(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ac916:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4ac91a:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
         :	                if (P_ISDELETED(opaque))
    0.00 :	  4ac91e:       f6 43 0c 04             testb  $0x4,0xc(%rbx)
    0.00 :	  4ac922:       75 61                   jne    4ac985 <_bt_steppage+0x305>
         :	                        /*
         :	                         * It wasn't deleted; the explanation had better be that the page
         :	                         * to the left got split or deleted. Without this check, we'd go
         :	                         * into an infinite loop if there's anything wrong.
         :	                         */
         :	                        if (opaque->btpo_prev == lblkno)
    0.00 :	  4ac924:       44 3b 3b                cmp    (%rbx),%r15d
    0.00 :	  4ac927:       0f 85 4b fe ff ff       jne    4ac778 <_bt_steppage+0xf8>
         :	                                elog(ERROR, "could not find left sibling of block %u in index \"%s\"",
    0.00 :	  4ac92d:       ba d1 48 7b 00          mov    $0x7b48d1,%edx
    0.00 :	  4ac932:       be b4 05 00 00          mov    $0x5b4,%esi
    0.00 :	  4ac937:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4ac93c:       e8 df ea 2c 00          callq  77b420 <elog_start>
    0.00 :	  4ac941:       49 8b 4d 30             mov    0x30(%r13),%rcx
    0.00 :	  4ac945:       44 89 f2                mov    %r14d,%edx
    0.00 :	  4ac948:       be e0 47 7b 00          mov    $0x7b47e0,%esi
    0.00 :	  4ac94d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ac952:       31 c0                   xor    %eax,%eax
    0.00 :	  4ac954:       e8 d7 e8 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4ac959:       e8 72 cb fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4ac95e:       66 90                   xchg   %ax,%ax
         :	                                if (P_RIGHTMOST(opaque))
         :	                                        elog(ERROR, "fell off the end of index \"%s\"",
         :	                                                 RelationGetRelationName(rel));
         :	                                blkno = opaque->btpo_next;
         :	                                buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
         :	                                page = BufferGetPage(buf);
    0.00 :	  4ac960:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4ac965:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4ac968:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4ac96c:       48 03 15 85 31 71 00    add    0x713185(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                                opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4ac973:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4ac977:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
         :	                                if (!P_ISDELETED(opaque))
    0.00 :	  4ac97b:       f6 43 0c 04             testb  $0x4,0xc(%rbx)
    0.00 :	  4ac97f:       0f 84 f3 fd ff ff       je     4ac778 <_bt_steppage+0xf8>
         :	                         * one's keyspace, so stepping left from it will take us where we
         :	                         * want to be.
         :	                         */
         :	                        for (;;)
         :	                        {
         :	                                if (P_RIGHTMOST(opaque))
    0.00 :	  4ac985:       8b 53 04                mov    0x4(%rbx),%edx
    0.00 :	  4ac988:       85 d2                   test   %edx,%edx
    0.00 :	  4ac98a:       74 7f                   je     4aca0b <_bt_steppage+0x38b>
         :	                                        elog(ERROR, "fell off the end of index \"%s\"",
         :	                                                 RelationGetRelationName(rel));
         :	                                blkno = opaque->btpo_next;
         :	                                buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
    0.00 :	  4ac98c:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4ac98f:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  4ac994:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4ac997:       e8 44 c6 ff ff          callq  4a8fe0 <_bt_relandgetbuf>
         :	                                page = BufferGetPage(buf);
    0.00 :	  4ac99c:       85 c0                   test   %eax,%eax
         :	                        {
         :	                                if (P_RIGHTMOST(opaque))
         :	                                        elog(ERROR, "fell off the end of index \"%s\"",
         :	                                                 RelationGetRelationName(rel));
         :	                                blkno = opaque->btpo_next;
         :	                                buf = _bt_relandgetbuf(rel, buf, blkno, BT_READ);
    0.00 :	  4ac99e:       41 89 c4                mov    %eax,%r12d
         :	                                page = BufferGetPage(buf);
    0.00 :	  4ac9a1:       79 bd                   jns    4ac960 <_bt_steppage+0x2e0>
    0.00 :	  4ac9a3:       48 8b 15 6e 07 6d 00    mov    0x6d076e(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac9aa:       f7 d0                   not    %eax
    0.00 :	  4ac9ac:       48 98                   cltq   
    0.00 :	  4ac9ae:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4ac9b2:       eb bf                   jmp    4ac973 <_bt_steppage+0x2f3>
    0.00 :	  4ac9b4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                obknum = BufferGetBlockNumber(buf);
         :	                /* step left */
         :	                blkno = lblkno = opaque->btpo_prev;
         :	                _bt_relbuf(rel, buf);
         :	                /* check for interrupts while we're not holding any buffer lock */
         :	                CHECK_FOR_INTERRUPTS();
    0.00 :	  4ac9b8:       e8 e3 f8 1e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  4ac9bd:       e9 e8 fd ff ff          jmpq   4ac7aa <_bt_steppage+0x12a>
    0.00 :	  4ac9c2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                buf = _bt_getbuf(rel, blkno, BT_READ);
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac9c8:       48 8b 15 49 07 6d 00    mov    0x6d0749(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac9cf:       f7 d0                   not    %eax
    0.00 :	  4ac9d1:       48 98                   cltq   
    0.00 :	  4ac9d3:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4ac9d7:       e9 f9 fd ff ff          jmpq   4ac7d5 <_bt_steppage+0x155>
    0.00 :	  4ac9dc:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                }
         :
         :	                /* Return to the original page to see what's up */
         :	                buf = _bt_relandgetbuf(rel, buf, obknum, BT_READ);
         :	                page = BufferGetPage(buf);
    0.00 :	  4ac9e0:       48 8b 15 31 07 6d 00    mov    0x6d0731(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac9e7:       f7 d0                   not    %eax
    0.00 :	  4ac9e9:       48 98                   cltq   
    0.00 :	  4ac9eb:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4ac9ef:       e9 22 ff ff ff          jmpq   4ac916 <_bt_steppage+0x296>
         :	_bt_walk_left(Relation rel, Buffer buf)
         :	{
         :	        Page            page;
         :	        BTPageOpaque opaque;
         :
         :	        page = BufferGetPage(buf);
    0.00 :	  4ac9f4:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4ac9f7:       48 8b 15 1a 07 6d 00    mov    0x6d071a(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4ac9fe:       f7 d0                   not    %eax
    0.00 :	  4aca00:       48 98                   cltq   
    0.00 :	  4aca02:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  4aca06:       e9 5f fd ff ff          jmpq   4ac76a <_bt_steppage+0xea>
         :	                         * want to be.
         :	                         */
         :	                        for (;;)
         :	                        {
         :	                                if (P_RIGHTMOST(opaque))
         :	                                        elog(ERROR, "fell off the end of index \"%s\"",
    0.00 :	  4aca0b:       ba d1 48 7b 00          mov    $0x7b48d1,%edx
    0.00 :	  4aca10:       be 9d 05 00 00          mov    $0x59d,%esi
    0.00 :	  4aca15:       bf 70 47 7b 00          mov    $0x7b4770,%edi
    0.00 :	  4aca1a:       e8 01 ea 2c 00          callq  77b420 <elog_start>
    0.00 :	  4aca1f:       49 8b 55 30             mov    0x30(%r13),%rdx
    0.00 :	  4aca23:       be 60 41 7b 00          mov    $0x7b4160,%esi
    0.00 :	  4aca28:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4aca2d:       31 c0                   xor    %eax,%eax
    0.00 :	  4aca2f:       e8 fc e7 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4aca34:       e8 97 ca fb ff          callq  4694d0 <abort@plt>
         :	                int                     tries;
         :
         :	                /* if we're at end of tree, release buf and return failure */
         :	                if (P_LEFTMOST(opaque))
         :	                {
         :	                        _bt_relbuf(rel, buf);
    0.00 :	  4aca39:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4aca3c:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4aca3f:       e8 8c c5 ff ff          callq  4a8fd0 <_bt_relbuf>
         :	                                so->currPos.buf = InvalidBuffer;
         :	                                return false;
         :	                        }
         :
         :	                        /* Step to next physical page */
         :	                        so->currPos.buf = _bt_walk_left(rel, so->currPos.buf);
    0.00 :	  4aca44:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4aca48:       c7 42 54 00 00 00 00    movl   $0x0,0x54(%rdx)
    0.00 :	  4aca4f:       31 c0                   xor    %eax,%eax
         :	                        }
         :	                }
         :	        }
         :
         :	        return true;
         :	}
    0.00 :	  4aca51:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  4aca55:       5b                      pop    %rbx
    0.00 :	  4aca56:       41 5c                   pop    %r12
    0.00 :	  4aca58:       41 5d                   pop    %r13
    0.00 :	  4aca5a:       41 5e                   pop    %r14
    0.00 :	  4aca5c:       41 5f                   pop    %r15
    0.00 :	  4aca5e:       c9                      leaveq 
    0.00 :	  4aca5f:       c3                      retq   
         :	                        /*
         :	                         * Okay, we managed to move left to a non-deleted page. Done if
         :	                         * it's not half-dead and contains matching tuples. Else loop back
         :	                         * and do it all again.
         :	                         */
         :	                        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4aca60:       89 f0                   mov    %esi,%eax
    0.00 :	  4aca62:       48 8b 15 af 06 6d 00    mov    0x6d06af(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4aca69:       f7 d0                   not    %eax
    0.00 :	  4aca6b:       48 98                   cltq   
    0.00 :	  4aca6d:       4c 8b 24 c2             mov    (%rdx,%rax,8),%r12
    0.00 :	  4aca71:       e9 eb fd ff ff          jmpq   4ac861 <_bt_steppage+0x1e1>
         :
         :	        if (ScanDirectionIsForward(dir))
         :	        {
         :	                /* Walk right to the next page with data */
         :	                /* We must rely on the previously saved nextPage link! */
         :	                BlockNumber blkno = so->currPos.nextPage;
    0.00 :	  4aca76:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
    0.00 :	  4aca7a:       44 8b 62 58             mov    0x58(%rdx),%r12d
         :
         :	                /* Remember we left a page with data */
         :	                so->currPos.moreLeft = true;
    0.00 :	  4aca7e:       c6 42 5c 01             movb   $0x1,0x5c(%rdx)
    0.00 :	  4aca82:       eb 48                   jmp    4acacc <_bt_steppage+0x44c>
    0.00 :	  4aca84:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        if (blkno == P_NONE || !so->currPos.moreRight)
         :	                                return false;
         :	                        /* check for interrupts while we're not holding any buffer lock */
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        /* step right one page */
         :	                        so->currPos.buf = _bt_getbuf(rel, blkno, BT_READ);
    0.00 :	  4aca88:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  4aca8d:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4aca90:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4aca93:       e8 b8 c5 ff ff          callq  4a9050 <_bt_getbuf>
    0.00 :	  4aca98:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
         :	                        /* check for deleted page */
         :	                        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4aca9c:       85 c0                   test   %eax,%eax
         :	                        if (blkno == P_NONE || !so->currPos.moreRight)
         :	                                return false;
         :	                        /* check for interrupts while we're not holding any buffer lock */
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        /* step right one page */
         :	                        so->currPos.buf = _bt_getbuf(rel, blkno, BT_READ);
    0.00 :	  4aca9e:       89 42 54                mov    %eax,0x54(%rdx)
         :	                        /* check for deleted page */
         :	                        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4acaa1:       0f 88 a1 00 00 00       js     4acb48 <_bt_steppage+0x4c8>
    0.00 :	  4acaa7:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4acaaa:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4acaad:       48 c1 e2 0d             shl    $0xd,%rdx
    0.00 :	  4acab1:       48 03 15 40 30 71 00    add    0x713040(%rip),%rdx        # bbfaf8 <BufferBlocks>
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
    0.00 :	  4acab8:       0f b7 42 10             movzwl 0x10(%rdx),%eax
    0.00 :	  4acabc:       48 8d 1c 02             lea    (%rdx,%rax,1),%rbx
         :	                        if (!P_IGNORE(opaque))
    0.00 :	  4acac0:       0f b7 43 0c             movzwl 0xc(%rbx),%eax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1285
   33.33 :	  4acac4:       a8 14                   test   $0x14,%al
    0.00 :	  4acac6:       74 48                   je     4acb10 <_bt_steppage+0x490>
         :	                                /* note that this will clear moreRight if we can stop */
         :	                                if (_bt_readpage(scan, dir, P_FIRSTDATAKEY(opaque)))
         :	                                        break;
         :	                        }
         :	                        /* nope, keep going */
         :	                        blkno = opaque->btpo_next;
    0.00 :	  4acac8:       44 8b 63 04             mov    0x4(%rbx),%r12d
         :	                so->currPos.moreLeft = true;
         :
         :	                for (;;)
         :	                {
         :	                        /* release the previous buffer */
         :	                        _bt_relbuf(rel, so->currPos.buf);
    0.00 :	  4acacc:       48 8b 45 d0             mov    -0x30(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtsearch.c:1273
   33.33 :	  4acad0:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4acad3:       8b 70 54                mov    0x54(%rax),%esi
    0.00 :	  4acad6:       e8 f5 c4 ff ff          callq  4a8fd0 <_bt_relbuf>
         :	                        so->currPos.buf = InvalidBuffer;
    0.00 :	  4acadb:       48 8b 55 d0             mov    -0x30(%rbp),%rdx
         :	                        /* if we're at end of scan, give up */
         :	                        if (blkno == P_NONE || !so->currPos.moreRight)
    0.00 :	  4acadf:       45 85 e4                test   %r12d,%r12d
         :
         :	                for (;;)
         :	                {
         :	                        /* release the previous buffer */
         :	                        _bt_relbuf(rel, so->currPos.buf);
         :	                        so->currPos.buf = InvalidBuffer;
    0.00 :	  4acae2:       c7 42 54 00 00 00 00    movl   $0x0,0x54(%rdx)
         :	                        /* if we're at end of scan, give up */
         :	                        if (blkno == P_NONE || !so->currPos.moreRight)
    0.00 :	  4acae9:       0f 84 60 ff ff ff       je     4aca4f <_bt_steppage+0x3cf>
    0.00 :	  4acaef:       80 7a 5d 00             cmpb   $0x0,0x5d(%rdx)
    0.00 :	  4acaf3:       0f 84 56 ff ff ff       je     4aca4f <_bt_steppage+0x3cf>
         :	                                return false;
         :	                        /* check for interrupts while we're not holding any buffer lock */
         :	                        CHECK_FOR_INTERRUPTS();
    0.00 :	  4acaf9:       0f b6 05 90 d5 70 00    movzbl 0x70d590(%rip),%eax        # bba090 <InterruptPending>
    0.00 :	  4acb00:       84 c0                   test   %al,%al
    0.00 :	  4acb02:       74 84                   je     4aca88 <_bt_steppage+0x408>
    0.00 :	  4acb04:       e8 97 f7 1e 00          callq  69c2a0 <ProcessInterrupts>
    0.00 :	  4acb09:       e9 7a ff ff ff          jmpq   4aca88 <_bt_steppage+0x408>
    0.00 :	  4acb0e:       66 90                   xchg   %ax,%ax
         :	                        /* check for deleted page */
         :	                        page = BufferGetPage(so->currPos.buf);
         :	                        opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :	                        if (!P_IGNORE(opaque))
         :	                        {
         :	                                PredicateLockPage(rel, blkno, scan->xs_snapshot);
    0.00 :	  4acb10:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	  4acb14:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4acb17:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  4acb1a:       48 8b 50 10             mov    0x10(%rax),%rdx
    0.00 :	  4acb1e:       e8 3d 67 1e 00          callq  693260 <PredicateLockPage>
         :	                                /* see if there are any matches on this page */
         :	                                /* note that this will clear moreRight if we can stop */
         :	                                if (_bt_readpage(scan, dir, P_FIRSTDATAKEY(opaque)))
    0.00 :	  4acb23:       83 7b 04 01             cmpl   $0x1,0x4(%rbx)
    0.00 :	  4acb27:       48 8b 7d c8             mov    -0x38(%rbp),%rdi
    0.00 :	  4acb2b:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  4acb30:       19 d2                   sbb    %edx,%edx
    0.00 :	  4acb32:       83 c2 02                add    $0x2,%edx
    0.00 :	  4acb35:       e8 a6 f8 ff ff          callq  4ac3e0 <_bt_readpage>
    0.00 :	  4acb3a:       84 c0                   test   %al,%al
    0.00 :	  4acb3c:       74 8a                   je     4acac8 <_bt_steppage+0x448>
    0.00 :	  4acb3e:       e9 7e fd ff ff          jmpq   4ac8c1 <_bt_steppage+0x241>
    0.00 :	  4acb43:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        /* check for interrupts while we're not holding any buffer lock */
         :	                        CHECK_FOR_INTERRUPTS();
         :	                        /* step right one page */
         :	                        so->currPos.buf = _bt_getbuf(rel, blkno, BT_READ);
         :	                        /* check for deleted page */
         :	                        page = BufferGetPage(so->currPos.buf);
    0.00 :	  4acb48:       f7 d0                   not    %eax
    0.00 :	  4acb4a:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4acb4d:       48 8b 05 c4 05 6d 00    mov    0x6d05c4(%rip),%rax        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4acb54:       48 8b 14 d0             mov    (%rax,%rdx,8),%rdx
    0.00 :	  4acb58:       e9 5b ff ff ff          jmpq   4acab8 <_bt_steppage+0x438>
         :	                for (;;)
         :	                {
         :	                        /* Done if we know there are no matching keys to the left */
         :	                        if (!so->currPos.moreLeft)
         :	                        {
         :	                                _bt_relbuf(rel, so->currPos.buf);
    0.00 :	  4acb5d:       8b 70 54                mov    0x54(%rax),%esi
    0.00 :	  4acb60:       e9 d7 fe ff ff          jmpq   4aca3c <_bt_steppage+0x3bc>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   66.67 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:784
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:772
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004aebd0 <_bt_preprocess_keys>:
         :	 * key argument values, which could change on a rescan or after moving to
         :	 * new elements of array keys.  Therefore we can't overwrite the source data.
         :	 */
         :	void
         :	_bt_preprocess_keys(IndexScanDesc scan)
         :	{
    0.00 :	  4aebd0:       55                      push   %rbp
    0.00 :	  4aebd1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4aebd4:       41 57                   push   %r15
    0.00 :	  4aebd6:       41 56                   push   %r14
    0.00 :	  4aebd8:       41 55                   push   %r13
    0.00 :	  4aebda:       41 54                   push   %r12
    0.00 :	  4aebdc:       53                      push   %rbx
    0.00 :	  4aebdd:       48 81 ec 98 00 00 00    sub    $0x98,%rsp
    0.00 :	  4aebe4:       48 89 bd 60 ff ff ff    mov    %rdi,-0xa0(%rbp)
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
    0.00 :	  4aebeb:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  4aebef:       48 89 85 68 ff ff ff    mov    %rax,-0x98(%rbp)
         :	        int                     numberOfKeys = scan->numberOfKeys;
    0.00 :	  4aebf6:       8b 57 18                mov    0x18(%rdi),%edx
         :	        int                     i,
         :	                                j;
         :	        AttrNumber      attno;
         :
         :	        /* initialize result variables */
         :	        so->qual_ok = true;
    0.00 :	  4aebf9:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
         :	 */
         :	void
         :	_bt_preprocess_keys(IndexScanDesc scan)
         :	{
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
         :	        int                     numberOfKeys = scan->numberOfKeys;
    0.00 :	  4aec00:       89 95 74 ff ff ff       mov    %edx,-0x8c(%rbp)
         :	        int16      *indoption = scan->indexRelation->rd_indoption;
    0.00 :	  4aec06:       48 8b 47 08             mov    0x8(%rdi),%rax
         :
         :	        /* initialize result variables */
         :	        so->qual_ok = true;
         :	        so->numberOfKeys = 0;
         :
         :	        if (numberOfKeys < 1)
    0.00 :	  4aec0a:       85 d2                   test   %edx,%edx
         :	void
         :	_bt_preprocess_keys(IndexScanDesc scan)
         :	{
         :	        BTScanOpaque so = (BTScanOpaque) scan->opaque;
         :	        int                     numberOfKeys = scan->numberOfKeys;
         :	        int16      *indoption = scan->indexRelation->rd_indoption;
    0.00 :	  4aec0c:       48 8b 80 e8 00 00 00    mov    0xe8(%rax),%rax
    0.00 :	  4aec13:       48 89 85 78 ff ff ff    mov    %rax,-0x88(%rbp)
         :	        int                     i,
         :	                                j;
         :	        AttrNumber      attno;
         :
         :	        /* initialize result variables */
         :	        so->qual_ok = true;
    0.00 :	  4aec1a:       c6 01 01                movb   $0x1,(%rcx)
         :	        so->numberOfKeys = 0;
    0.00 :	  4aec1d:       c7 41 04 00 00 00 00    movl   $0x0,0x4(%rcx)
         :
         :	        if (numberOfKeys < 1)
    0.00 :	  4aec24:       0f 8e 5e 03 00 00       jle    4aef88 <_bt_preprocess_keys+0x3b8>
         :	                return;                                 /* done if qual-less scan */
         :
         :	        /*
         :	         * Read so->arrayKeyData if array keys are present, else scan->keyData
         :	         */
         :	        if (so->arrayKeyData != NULL)
    0.00 :	  4aec2a:       48 8b 59 10             mov    0x10(%rcx),%rbx
    0.00 :	  4aec2e:       48 85 db                test   %rbx,%rbx
    0.00 :	  4aec31:       0f 84 c6 04 00 00       je     4af0fd <_bt_preprocess_keys+0x52d>
         :	                inkeys = so->arrayKeyData;
         :	        else
         :	                inkeys = scan->keyData;
         :
         :	        outkeys = so->keyData;
    0.00 :	  4aec37:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
         :	        cur = &inkeys[0];
         :	        /* we check that input keys are correctly ordered */
         :	        if (cur->sk_attno < 1)
         :	                elog(ERROR, "btree index keys must be ordered by attribute");
    0.00 :	  4aec3e:       be 0a 03 00 00          mov    $0x30a,%esi
         :	        if (so->arrayKeyData != NULL)
         :	                inkeys = so->arrayKeyData;
         :	        else
         :	                inkeys = scan->keyData;
         :
         :	        outkeys = so->keyData;
    0.00 :	  4aec43:       48 8b 52 08             mov    0x8(%rdx),%rdx
    0.00 :	  4aec47:       48 89 55 88             mov    %rdx,-0x78(%rbp)
         :	        cur = &inkeys[0];
         :	        /* we check that input keys are correctly ordered */
         :	        if (cur->sk_attno < 1)
    0.00 :	  4aec4b:       66 83 7b 04 00          cmpw   $0x0,0x4(%rbx)
         :	                elog(ERROR, "btree index keys must be ordered by attribute");
    0.00 :	  4aec50:       ba 40 4b 7b 00          mov    $0x7b4b40,%edx
         :	                inkeys = scan->keyData;
         :
         :	        outkeys = so->keyData;
         :	        cur = &inkeys[0];
         :	        /* we check that input keys are correctly ordered */
         :	        if (cur->sk_attno < 1)
    0.00 :	  4aec55:       0f 8e cc 04 00 00       jle    4af127 <_bt_preprocess_keys+0x557>
         :	                elog(ERROR, "btree index keys must be ordered by attribute");
         :
         :	        /* We can short-circuit most of the work if there's just one key */
         :	        if (numberOfKeys == 1)
    0.00 :	  4aec5b:       83 bd 74 ff ff ff 01    cmpl   $0x1,-0x8c(%rbp)
    0.00 :	  4aec62:       0f 84 08 04 00 00       je     4af070 <_bt_preprocess_keys+0x4a0>
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTGreaterStrategyNumber - 1] = NULL;
    0.00 :	  4aec68:       48 8d 45 a0             lea    -0x60(%rbp),%rax
         :	                         * unsatisfiable in combination with any other index condition. By
         :	                         * the time we get here, that's been classified as an equality
         :	                         * check, and we've rejected any combination of it with a regular
         :	                         * equality condition; but not with other types of conditions.
         :	                         */
         :	                        if (xform[BTEqualStrategyNumber - 1])
    0.00 :	  4aec6c:       48 8d 4d a0             lea    -0x60(%rbp),%rcx
         :	         *
         :	         * xform[i] points to the currently best scan key of strategy type i+1; it
         :	         * is NULL if we haven't yet found such a key for this attr.
         :	         */
         :	        attno = 1;
         :	        memset(xform, 0, sizeof(xform));
    0.00 :	  4aec70:       45 31 ff                xor    %r15d,%r15d
    0.00 :	  4aec73:       c7 45 94 00 00 00 00    movl   $0x0,-0x6c(%rbp)
    0.00 :	  4aec7a:       48 8d 55 98             lea    -0x68(%rbp),%rdx
    0.00 :	  4aec7e:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  4aec85:       00 
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTGreaterStrategyNumber - 1] = NULL;
    0.00 :	  4aec86:       48 83 c0 18             add    $0x18,%rax
         :	                         * unsatisfiable in combination with any other index condition. By
         :	                         * the time we get here, that's been classified as an equality
         :	                         * check, and we've rejected any combination of it with a regular
         :	                         * equality condition; but not with other types of conditions.
         :	                         */
         :	                        if (xform[BTEqualStrategyNumber - 1])
    0.00 :	  4aec8a:       48 83 c1 20             add    $0x20,%rcx
         :	         *
         :	         * xform[i] points to the currently best scan key of strategy type i+1; it
         :	         * is NULL if we haven't yet found such a key for this attr.
         :	         */
         :	        attno = 1;
         :	        memset(xform, 0, sizeof(xform));
    0.00 :	  4aec8e:       48 c7 45 a8 00 00 00    movq   $0x0,-0x58(%rbp)
    0.00 :	  4aec95:       00 
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTGreaterStrategyNumber - 1] = NULL;
    0.00 :	  4aec96:       48 89 85 58 ff ff ff    mov    %rax,-0xa8(%rbp)
         :	         * handle after-last-key processing.  Actual exit from the loop is at the
         :	         * "break" statement below.
         :	         */
         :	        for (i = 0;; cur++, i++)
         :	        {
         :	                if (i < numberOfKeys)
    0.00 :	  4aec9d:       8b 85 74 ff ff ff       mov    -0x8c(%rbp),%eax
         :	         *
         :	         * xform[i] points to the currently best scan key of strategy type i+1; it
         :	         * is NULL if we haven't yet found such a key for this attr.
         :	         */
         :	        attno = 1;
         :	        memset(xform, 0, sizeof(xform));
    0.00 :	  4aeca3:       49 89 de                mov    %rbx,%r14
         :	         * handle after-last-key processing.  Actual exit from the loop is at the
         :	         * "break" statement below.
         :	         */
         :	        for (i = 0;; cur++, i++)
         :	        {
         :	                if (i < numberOfKeys)
    0.00 :	  4aeca6:       39 45 94                cmp    %eax,-0x6c(%rbp)
         :	         *
         :	         * xform[i] points to the currently best scan key of strategy type i+1; it
         :	         * is NULL if we haven't yet found such a key for this attr.
         :	         */
         :	        attno = 1;
         :	        memset(xform, 0, sizeof(xform));
    0.00 :	  4aeca9:       48 c7 45 b0 00 00 00    movq   $0x0,-0x50(%rbp)
    0.00 :	  4aecb0:       00 
    0.00 :	  4aecb1:       48 c7 45 b8 00 00 00    movq   $0x0,-0x48(%rbp)
    0.00 :	  4aecb8:       00 
    0.00 :	  4aecb9:       48 c7 45 c0 00 00 00    movq   $0x0,-0x40(%rbp)
    0.00 :	  4aecc0:       00 
    0.00 :	  4aecc1:       c7 45 84 00 00 00 00    movl   $0x0,-0x7c(%rbp)
    0.00 :	  4aecc8:       66 c7 45 9a 01 00       movw   $0x1,-0x66(%rbp)
    0.00 :	  4aecce:       48 89 95 48 ff ff ff    mov    %rdx,-0xb8(%rbp)
         :	                         * unsatisfiable in combination with any other index condition. By
         :	                         * the time we get here, that's been classified as an equality
         :	                         * check, and we've rejected any combination of it with a regular
         :	                         * equality condition; but not with other types of conditions.
         :	                         */
         :	                        if (xform[BTEqualStrategyNumber - 1])
    0.00 :	  4aecd5:       48 89 8d 50 ff ff ff    mov    %rcx,-0xb0(%rbp)
         :	         * handle after-last-key processing.  Actual exit from the loop is at the
         :	         * "break" statement below.
         :	         */
         :	        for (i = 0;; cur++, i++)
         :	        {
         :	                if (i < numberOfKeys)
    0.00 :	  4aecdc:       0f 8c 80 02 00 00       jl     4aef62 <_bt_preprocess_keys+0x392>
    0.00 :	  4aece2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /*
         :	                 * If we are at the end of the keys for a particular attr, finish up
         :	                 * processing and emit the cleaned-up keys.
         :	                 */
         :	                if (i == numberOfKeys || cur->sk_attno != attno)
    0.00 :	  4aece8:       8b 8d 74 ff ff ff       mov    -0x8c(%rbp),%ecx
    0.00 :	  4aecee:       39 4d 94                cmp    %ecx,-0x6c(%rbp)
    0.00 :	  4aecf1:       74 2c                   je     4aed1f <_bt_preprocess_keys+0x14f>
    0.00 :	  4aecf3:       45 0f b7 6e 04          movzwl 0x4(%r14),%r13d
    0.00 :	  4aecf8:       8b 45 84                mov    -0x7c(%rbp),%eax
    0.00 :	  4aecfb:       66 44 3b 6d 9a          cmp    -0x66(%rbp),%r13w
    0.00 :	  4aed00:       89 45 9c                mov    %eax,-0x64(%rbp)
    0.00 :	  4aed03:       0f 84 d3 01 00 00       je     4aeedc <_bt_preprocess_keys+0x30c>
         :	                {
         :	                        int                     priorNumberOfEqualCols = numberOfEqualCols;
         :
         :	                        /* check input keys are correctly ordered */
         :	                        if (i < numberOfKeys && cur->sk_attno < attno)
    0.00 :	  4aed09:       8b 95 74 ff ff ff       mov    -0x8c(%rbp),%edx
    0.00 :	  4aed0f:       39 55 94                cmp    %edx,-0x6c(%rbp)
    0.00 :	  4aed12:       7d 0b                   jge    4aed1f <_bt_preprocess_keys+0x14f>
    0.00 :	  4aed14:       66 44 39 6d 9a          cmp    %r13w,-0x66(%rbp)
    0.00 :	  4aed19:       0f 8f fe 03 00 00       jg     4af11d <_bt_preprocess_keys+0x54d>
         :	                         * unsatisfiable in combination with any other index condition. By
         :	                         * the time we get here, that's been classified as an equality
         :	                         * check, and we've rejected any combination of it with a regular
         :	                         * equality condition; but not with other types of conditions.
         :	                         */
         :	                        if (xform[BTEqualStrategyNumber - 1])
    0.00 :	  4aed1f:       4c 8b 6d b0             mov    -0x50(%rbp),%r13
    0.00 :	  4aed23:       8b 4d 84                mov    -0x7c(%rbp),%ecx
    0.00 :	  4aed26:       4d 85 ed                test   %r13,%r13
    0.00 :	  4aed29:       89 4d 9c                mov    %ecx,-0x64(%rbp)
    0.00 :	  4aed2c:       74 66                   je     4aed94 <_bt_preprocess_keys+0x1c4>
    0.00 :	  4aed2e:       4c 8b a5 50 ff ff ff    mov    -0xb0(%rbp),%r12
    0.00 :	  4aed35:       bb 04 00 00 00          mov    $0x4,%ebx
         :	                        {
         :	                                ScanKey         eq = xform[BTEqualStrategyNumber - 1];
         :
         :	                                for (j = BTMaxStrategyNumber; --j >= 0;)
         :	                                {
         :	                                        ScanKey         chk = xform[j];
    0.00 :	  4aed3a:       49 8b 34 24             mov    (%r12),%rsi
         :
         :	                                        if (!chk || j == (BTEqualStrategyNumber - 1))
    0.00 :	  4aed3e:       48 85 f6                test   %rsi,%rsi
    0.00 :	  4aed41:       74 3c                   je     4aed7f <_bt_preprocess_keys+0x1af>
    0.00 :	  4aed43:       83 fb 02                cmp    $0x2,%ebx
    0.00 :	  4aed46:       74 37                   je     4aed7f <_bt_preprocess_keys+0x1af>
         :	                                                continue;
         :
         :	                                        if (eq->sk_flags & SK_SEARCHNULL)
    0.00 :	  4aed48:       41 f6 45 00 40          testb  $0x40,0x0(%r13)
    0.00 :	  4aed4d:       0f 85 0d 03 00 00       jne    4af060 <_bt_preprocess_keys+0x490>
         :	                                                /* IS NULL is contradictory to anything else */
         :	                                                so->qual_ok = false;
         :	                                                return;
         :	                                        }
         :
         :	                                        if (_bt_compare_scankey_args(scan, chk, eq, chk,
    0.00 :	  4aed53:       48 8b bd 60 ff ff ff    mov    -0xa0(%rbp),%rdi
    0.00 :	  4aed5a:       4c 8d 45 cf             lea    -0x31(%rbp),%r8
    0.00 :	  4aed5e:       48 89 f1                mov    %rsi,%rcx
    0.00 :	  4aed61:       4c 89 ea                mov    %r13,%rdx
    0.00 :	  4aed64:       e8 57 fc ff ff          callq  4ae9c0 <_bt_compare_scankey_args>
    0.00 :	  4aed69:       84 c0                   test   %al,%al
    0.00 :	  4aed6b:       74 12                   je     4aed7f <_bt_preprocess_keys+0x1af>
         :	                                                                                                 &test_result))
         :	                                        {
         :	                                                if (!test_result)
    0.00 :	  4aed6d:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4aed71:       0f 84 02 02 00 00       je     4aef79 <_bt_preprocess_keys+0x3a9>
         :	                                                        /* keys proven mutually contradictory */
         :	                                                        so->qual_ok = false;
         :	                                                        return;
         :	                                                }
         :	                                                /* else discard the redundant non-equality key */
         :	                                                xform[j] = NULL;
    0.00 :	  4aed77:       49 c7 04 24 00 00 00    movq   $0x0,(%r12)
    0.00 :	  4aed7e:       00 
         :	                         */
         :	                        if (xform[BTEqualStrategyNumber - 1])
         :	                        {
         :	                                ScanKey         eq = xform[BTEqualStrategyNumber - 1];
         :
         :	                                for (j = BTMaxStrategyNumber; --j >= 0;)
    0.00 :	  4aed7f:       83 eb 01                sub    $0x1,%ebx
    0.00 :	  4aed82:       49 83 ec 08             sub    $0x8,%r12
    0.00 :	  4aed86:       83 fb ff                cmp    $0xffffffff,%ebx
    0.00 :	  4aed89:       75 af                   jne    4aed3a <_bt_preprocess_keys+0x16a>
         :	                                                xform[j] = NULL;
         :	                                        }
         :	                                        /* else, cannot determine redundancy, keep both keys */
         :	                                }
         :	                                /* track number of attrs for which we have "=" keys */
         :	                                numberOfEqualCols++;
    0.00 :	  4aed8b:       8b 4d 84                mov    -0x7c(%rbp),%ecx
    0.00 :	  4aed8e:       83 c1 01                add    $0x1,%ecx
    0.00 :	  4aed91:       89 4d 9c                mov    %ecx,-0x64(%rbp)
         :	                        }
         :
         :	                        /* try to keep only one of <, <= */
         :	                        if (xform[BTLessStrategyNumber - 1]
    0.00 :	  4aed94:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  4aed98:       48 85 d2                test   %rdx,%rdx
    0.00 :	  4aed9b:       74 33                   je     4aedd0 <_bt_preprocess_keys+0x200>
    0.00 :	  4aed9d:       48 8b 75 a8             mov    -0x58(%rbp),%rsi
    0.00 :	  4aeda1:       48 85 f6                test   %rsi,%rsi
    0.00 :	  4aeda4:       74 2a                   je     4aedd0 <_bt_preprocess_keys+0x200>
         :	                                && xform[BTLessEqualStrategyNumber - 1])
         :	                        {
         :	                                ScanKey         lt = xform[BTLessStrategyNumber - 1];
         :	                                ScanKey         le = xform[BTLessEqualStrategyNumber - 1];
         :
         :	                                if (_bt_compare_scankey_args(scan, le, lt, le,
    0.00 :	  4aeda6:       48 8b bd 60 ff ff ff    mov    -0xa0(%rbp),%rdi
    0.00 :	  4aedad:       4c 8d 45 cf             lea    -0x31(%rbp),%r8
    0.00 :	  4aedb1:       48 89 f1                mov    %rsi,%rcx
    0.00 :	  4aedb4:       e8 07 fc ff ff          callq  4ae9c0 <_bt_compare_scankey_args>
    0.00 :	  4aedb9:       84 c0                   test   %al,%al
    0.00 :	  4aedbb:       74 13                   je     4aedd0 <_bt_preprocess_keys+0x200>
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
    0.00 :	  4aedbd:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4aedc1:       0f 84 71 02 00 00       je     4af038 <_bt_preprocess_keys+0x468>
         :	                                                xform[BTLessEqualStrategyNumber - 1] = NULL;
    0.00 :	  4aedc7:       48 c7 45 a8 00 00 00    movq   $0x0,-0x58(%rbp)
    0.00 :	  4aedce:       00 
    0.00 :	  4aedcf:       90                      nop
         :	                                                xform[BTLessStrategyNumber - 1] = NULL;
         :	                                }
         :	                        }
         :
         :	                        /* try to keep only one of >, >= */
         :	                        if (xform[BTGreaterStrategyNumber - 1]
    0.00 :	  4aedd0:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
    0.00 :	  4aedd4:       48 85 d2                test   %rdx,%rdx
    0.00 :	  4aedd7:       74 36                   je     4aee0f <_bt_preprocess_keys+0x23f>
    0.00 :	  4aedd9:       48 8b 75 b8             mov    -0x48(%rbp),%rsi
    0.00 :	  4aeddd:       48 85 f6                test   %rsi,%rsi
    0.00 :	  4aede0:       74 2d                   je     4aee0f <_bt_preprocess_keys+0x23f>
         :	                                && xform[BTGreaterEqualStrategyNumber - 1])
         :	                        {
         :	                                ScanKey         gt = xform[BTGreaterStrategyNumber - 1];
         :	                                ScanKey         ge = xform[BTGreaterEqualStrategyNumber - 1];
         :
         :	                                if (_bt_compare_scankey_args(scan, ge, gt, ge,
    0.00 :	  4aede2:       48 8b bd 60 ff ff ff    mov    -0xa0(%rbp),%rdi
    0.00 :	  4aede9:       4c 8d 45 cf             lea    -0x31(%rbp),%r8
    0.00 :	  4aeded:       48 89 f1                mov    %rsi,%rcx
    0.00 :	  4aedf0:       e8 cb fb ff ff          callq  4ae9c0 <_bt_compare_scankey_args>
    0.00 :	  4aedf5:       84 c0                   test   %al,%al
    0.00 :	  4aedf7:       74 12                   je     4aee0b <_bt_preprocess_keys+0x23b>
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
    0.00 :	  4aedf9:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4aedfd:       0f 84 45 02 00 00       je     4af048 <_bt_preprocess_keys+0x478>
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
    0.00 :	  4aee03:       48 c7 45 b8 00 00 00    movq   $0x0,-0x48(%rbp)
    0.00 :	  4aee0a:       00 
    0.00 :	  4aee0b:       48 8b 55 c0             mov    -0x40(%rbp),%rdx
         :	                                if (xform[j])
         :	                                {
         :	                                        ScanKey         outkey = &outkeys[new_numberOfKeys++];
         :
         :	                                        memcpy(outkey, xform[j], sizeof(ScanKeyData));
         :	                                        if (priorNumberOfEqualCols == attno - 1)
    0.00 :	  4aee0f:       0f bf 45 9a             movswl -0x66(%rbp),%eax
         :	                         * mark them if they are required.  They are required (possibly
         :	                         * only in one direction) if all attrs before this one had "=".
         :	                         */
         :	                        for (j = BTMaxStrategyNumber; --j >= 0;)
         :	                        {
         :	                                if (xform[j])
    0.00 :	  4aee13:       48 85 d2                test   %rdx,%rdx
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTGreaterStrategyNumber - 1] = NULL;
    0.00 :	  4aee16:       48 8b 9d 58 ff ff ff    mov    -0xa8(%rbp),%rbx
         :	                                if (xform[j])
         :	                                {
         :	                                        ScanKey         outkey = &outkeys[new_numberOfKeys++];
         :
         :	                                        memcpy(outkey, xform[j], sizeof(ScanKeyData));
         :	                                        if (priorNumberOfEqualCols == attno - 1)
    0.00 :	  4aee1d:       44 8d 60 ff             lea    -0x1(%rax),%r12d
         :	                         * mark them if they are required.  They are required (possibly
         :	                         * only in one direction) if all attrs before this one had "=".
         :	                         */
         :	                        for (j = BTMaxStrategyNumber; --j >= 0;)
         :	                        {
         :	                                if (xform[j])
    0.00 :	  4aee21:       74 63                   je     4aee86 <_bt_preprocess_keys+0x2b6>
         :	                                {
         :	                                        ScanKey         outkey = &outkeys[new_numberOfKeys++];
    0.00 :	  4aee23:       48 8b 4d 88             mov    -0x78(%rbp),%rcx
    0.00 :	  4aee27:       49 63 c7                movslq %r15d,%rax
    0.00 :	  4aee2a:       41 83 c7 01             add    $0x1,%r15d
    0.00 :	  4aee2e:       48 8d 04 c0             lea    (%rax,%rax,8),%rax
    0.00 :	  4aee32:       48 8d 3c c1             lea    (%rcx,%rax,8),%rdi
         :
         :	                                        memcpy(outkey, xform[j], sizeof(ScanKeyData));
    0.00 :	  4aee36:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  4aee39:       48 89 07                mov    %rax,(%rdi)
    0.00 :	  4aee3c:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  4aee40:       48 89 47 08             mov    %rax,0x8(%rdi)
    0.00 :	  4aee44:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  4aee48:       48 89 47 10             mov    %rax,0x10(%rdi)
    0.00 :	  4aee4c:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  4aee50:       48 89 47 18             mov    %rax,0x18(%rdi)
    0.00 :	  4aee54:       48 8b 42 20             mov    0x20(%rdx),%rax
    0.00 :	  4aee58:       48 89 47 20             mov    %rax,0x20(%rdi)
    0.00 :	  4aee5c:       48 8b 42 28             mov    0x28(%rdx),%rax
    0.00 :	  4aee60:       48 89 47 28             mov    %rax,0x28(%rdi)
    0.00 :	  4aee64:       48 8b 42 30             mov    0x30(%rdx),%rax
    0.00 :	  4aee68:       48 89 47 30             mov    %rax,0x30(%rdi)
    0.00 :	  4aee6c:       48 8b 42 38             mov    0x38(%rdx),%rax
    0.00 :	  4aee70:       48 89 47 38             mov    %rax,0x38(%rdi)
    0.00 :	  4aee74:       48 8b 42 40             mov    0x40(%rdx),%rax
    0.00 :	  4aee78:       48 89 47 40             mov    %rax,0x40(%rdi)
         :	                                        if (priorNumberOfEqualCols == attno - 1)
    0.00 :	  4aee7c:       44 39 65 84             cmp    %r12d,-0x7c(%rbp)
    0.00 :	  4aee80:       0f 84 1a 01 00 00       je     4aefa0 <_bt_preprocess_keys+0x3d0>
         :	                        /*
         :	                         * Emit the cleaned-up keys into the outkeys[] array, and then
         :	                         * mark them if they are required.  They are required (possibly
         :	                         * only in one direction) if all attrs before this one had "=".
         :	                         */
         :	                        for (j = BTMaxStrategyNumber; --j >= 0;)
    0.00 :	  4aee86:       48 3b 9d 48 ff ff ff    cmp    -0xb8(%rbp),%rbx
    0.00 :	  4aee8d:       74 11                   je     4aeea0 <_bt_preprocess_keys+0x2d0>
    0.00 :	  4aee8f:       48 8b 13                mov    (%rbx),%rdx
    0.00 :	  4aee92:       48 83 eb 08             sub    $0x8,%rbx
         :	                        {
         :	                                if (xform[j])
    0.00 :	  4aee96:       48 85 d2                test   %rdx,%rdx
    0.00 :	  4aee99:       75 88                   jne    4aee23 <_bt_preprocess_keys+0x253>
    0.00 :	  4aee9b:       eb e9                   jmp    4aee86 <_bt_preprocess_keys+0x2b6>
    0.00 :	  4aee9d:       0f 1f 00                nopl   (%rax)
         :	                        }
         :
         :	                        /*
         :	                         * Exit loop here if done.
         :	                         */
         :	                        if (i == numberOfKeys)
    0.00 :	  4aeea0:       8b 85 74 ff ff ff       mov    -0x8c(%rbp),%eax
    0.00 :	  4aeea6:       39 45 94                cmp    %eax,-0x6c(%rbp)
    0.00 :	  4aeea9:       0f 84 5e 02 00 00       je     4af10d <_bt_preprocess_keys+0x53d>
         :	                                break;
         :
         :	                        /* Re-initialize for new attno */
         :	                        attno = cur->sk_attno;
    0.00 :	  4aeeaf:       45 0f b7 6e 04          movzwl 0x4(%r14),%r13d
         :	                        memset(xform, 0, sizeof(xform));
    0.00 :	  4aeeb4:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  4aeebb:       00 
    0.00 :	  4aeebc:       48 c7 45 a8 00 00 00    movq   $0x0,-0x58(%rbp)
    0.00 :	  4aeec3:       00 
    0.00 :	  4aeec4:       48 c7 45 b0 00 00 00    movq   $0x0,-0x50(%rbp)
    0.00 :	  4aeecb:       00 
    0.00 :	  4aeecc:       48 c7 45 b8 00 00 00    movq   $0x0,-0x48(%rbp)
    0.00 :	  4aeed3:       00 
    0.00 :	  4aeed4:       48 c7 45 c0 00 00 00    movq   $0x0,-0x40(%rbp)
    0.00 :	  4aeedb:       00 
         :
         :	                /* check strategy this key's operator corresponds to */
         :	                j = cur->sk_strategy - 1;
         :
         :	                /* if row comparison, push it directly to the output array */
         :	                if (cur->sk_flags & SK_ROW_HEADER)
    0.00 :	  4aeedc:       41 f6 06 04             testb  $0x4,(%r14)
         :	                        attno = cur->sk_attno;
         :	                        memset(xform, 0, sizeof(xform));
         :	                }
         :
         :	                /* check strategy this key's operator corresponds to */
         :	                j = cur->sk_strategy - 1;
    0.00 :	  4aeee0:       41 0f b7 46 06          movzwl 0x6(%r14),%eax
         :
         :	                /* if row comparison, push it directly to the output array */
         :	                if (cur->sk_flags & SK_ROW_HEADER)
    0.00 :	  4aeee5:       0f 85 c5 00 00 00       jne    4aefb0 <_bt_preprocess_keys+0x3e0>
         :	                        attno = cur->sk_attno;
         :	                        memset(xform, 0, sizeof(xform));
         :	                }
         :
         :	                /* check strategy this key's operator corresponds to */
         :	                j = cur->sk_strategy - 1;
    0.00 :	  4aeeeb:       0f b7 c0                movzwl %ax,%eax
    0.00 :	  4aeeee:       44 8d 60 ff             lea    -0x1(%rax),%r12d
         :	                        Assert(j != (BTEqualStrategyNumber - 1));
         :	                        continue;
         :	                }
         :
         :	                /* have we seen one of these before? */
         :	                if (xform[j] == NULL)
    0.00 :	  4aeef2:       49 63 dc                movslq %r12d,%rbx
    0.00 :	  4aeef5:       48 8b 4c dd a0          mov    -0x60(%rbp,%rbx,8),%rcx
    0.00 :	  4aeefa:       48 85 c9                test   %rcx,%rcx
    0.00 :	  4aeefd:       0f 84 25 01 00 00       je     4af028 <_bt_preprocess_keys+0x458>
         :	                        xform[j] = cur;
         :	                }
         :	                else
         :	                {
         :	                        /* yup, keep only the more restrictive key */
         :	                        if (_bt_compare_scankey_args(scan, cur, cur, xform[j],
    0.00 :	  4aef03:       48 8b bd 60 ff ff ff    mov    -0xa0(%rbp),%rdi
    0.00 :	  4aef0a:       4c 8d 45 cf             lea    -0x31(%rbp),%r8
    0.00 :	  4aef0e:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  4aef11:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  4aef14:       e8 a7 fa ff ff          callq  4ae9c0 <_bt_compare_scankey_args>
    0.00 :	  4aef19:       84 c0                   test   %al,%al
    0.00 :	  4aef1b:       0f 84 8f 00 00 00       je     4aefb0 <_bt_preprocess_keys+0x3e0>
         :	                                                                                 &test_result))
         :	                        {
         :	                                if (test_result)
    0.00 :	  4aef21:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  4aef25:       0f 85 fd 00 00 00       jne    4af028 <_bt_preprocess_keys+0x458>
         :	                                        xform[j] = cur;
         :	                                else if (j == (BTEqualStrategyNumber - 1))
    0.00 :	  4aef2b:       41 83 fc 02             cmp    $0x2,%r12d
    0.00 :	  4aef2f:       90                      nop
    0.00 :	  4aef30:       0f 84 11 02 00 00       je     4af147 <_bt_preprocess_keys+0x577>
    0.00 :	  4aef36:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  4aef3d:       00 00 00 
         :	        /*
         :	         * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to
         :	         * handle after-last-key processing.  Actual exit from the loop is at the
         :	         * "break" statement below.
         :	         */
         :	        for (i = 0;; cur++, i++)
    0.00 :	  4aef40:       83 45 94 01             addl   $0x1,-0x6c(%rbp)
    0.00 :	  4aef44:       49 83 c6 48             add    $0x48,%r14
         :	        {
         :	                if (i < numberOfKeys)
    0.00 :	  4aef48:       8b 85 74 ff ff ff       mov    -0x8c(%rbp),%eax
    0.00 :	  4aef4e:       39 45 94                cmp    %eax,-0x6c(%rbp)
         :	        /*
         :	         * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to
         :	         * handle after-last-key processing.  Actual exit from the loop is at the
         :	         * "break" statement below.
         :	         */
         :	        for (i = 0;; cur++, i++)
    0.00 :	  4aef51:       8b 4d 9c                mov    -0x64(%rbp),%ecx
    0.00 :	  4aef54:       66 44 89 6d 9a          mov    %r13w,-0x66(%rbp)
    0.00 :	  4aef59:       89 4d 84                mov    %ecx,-0x7c(%rbp)
         :	        {
         :	                if (i < numberOfKeys)
    0.00 :	  4aef5c:       0f 8d 86 fd ff ff       jge    4aece8 <_bt_preprocess_keys+0x118>
         :	                {
         :	                        /* Apply indoption to scankey (might change sk_strategy!) */
         :	                        if (!_bt_fix_scankey_strategy(cur, indoption))
    0.00 :	  4aef62:       48 8b b5 78 ff ff ff    mov    -0x88(%rbp),%rsi
    0.00 :	  4aef69:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4aef6c:       e8 ef ed ff ff          callq  4add60 <_bt_fix_scankey_strategy>
    0.00 :	  4aef71:       84 c0                   test   %al,%al
    0.00 :	  4aef73:       0f 85 6f fd ff ff       jne    4aece8 <_bt_preprocess_keys+0x118>
         :	                                                                                                 &test_result))
         :	                                        {
         :	                                                if (!test_result)
         :	                                                {
         :	                                                        /* keys proven mutually contradictory */
         :	                                                        so->qual_ok = false;
    0.00 :	  4aef79:       48 8b 95 68 ff ff ff    mov    -0x98(%rbp),%rdx
    0.00 :	  4aef80:       c6 02 00                movb   $0x0,(%rdx)
    0.00 :	  4aef83:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	        }
         :
         :	        so->numberOfKeys = new_numberOfKeys;
         :	}
    0.00 :	  4aef88:       48 81 c4 98 00 00 00    add    $0x98,%rsp
    0.00 :	  4aef8f:       5b                      pop    %rbx
    0.00 :	  4aef90:       41 5c                   pop    %r12
    0.00 :	  4aef92:       41 5d                   pop    %r13
    0.00 :	  4aef94:       41 5e                   pop    %r14
    0.00 :	  4aef96:       41 5f                   pop    %r15
    0.00 :	  4aef98:       c9                      leaveq 
    0.00 :	  4aef99:       c3                      retq   
    0.00 :	  4aef9a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                {
         :	                                        ScanKey         outkey = &outkeys[new_numberOfKeys++];
         :
         :	                                        memcpy(outkey, xform[j], sizeof(ScanKeyData));
         :	                                        if (priorNumberOfEqualCols == attno - 1)
         :	                                                _bt_mark_scankey_required(outkey);
    0.00 :	  4aefa0:       e8 0b f2 ff ff          callq  4ae1b0 <_bt_mark_scankey_required>
    0.00 :	  4aefa5:       e9 dc fe ff ff          jmpq   4aee86 <_bt_preprocess_keys+0x2b6>
    0.00 :	  4aefaa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                /*
         :	                                 * We can't determine which key is more restrictive.  Keep the
         :	                                 * previous one in xform[j] and push this one directly to the
         :	                                 * output array.
         :	                                 */
         :	                                ScanKey         outkey = &outkeys[new_numberOfKeys++];
    0.00 :	  4aefb0:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  4aefb4:       49 63 c7                movslq %r15d,%rax
    0.00 :	  4aefb7:       41 83 c7 01             add    $0x1,%r15d
    0.00 :	  4aefbb:       48 8d 04 c0             lea    (%rax,%rax,8),%rax
    0.00 :	  4aefbf:       48 8d 3c c2             lea    (%rdx,%rax,8),%rdi
         :
         :	                                memcpy(outkey, cur, sizeof(ScanKeyData));
    0.00 :	  4aefc3:       49 8b 06                mov    (%r14),%rax
    0.00 :	  4aefc6:       48 89 07                mov    %rax,(%rdi)
    0.00 :	  4aefc9:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  4aefcd:       48 89 47 08             mov    %rax,0x8(%rdi)
    0.00 :	  4aefd1:       49 8b 46 10             mov    0x10(%r14),%rax
    0.00 :	  4aefd5:       48 89 47 10             mov    %rax,0x10(%rdi)
    0.00 :	  4aefd9:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  4aefdd:       48 89 47 18             mov    %rax,0x18(%rdi)
    0.00 :	  4aefe1:       49 8b 46 20             mov    0x20(%r14),%rax
    0.00 :	  4aefe5:       48 89 47 20             mov    %rax,0x20(%rdi)
    0.00 :	  4aefe9:       49 8b 46 28             mov    0x28(%r14),%rax
    0.00 :	  4aefed:       48 89 47 28             mov    %rax,0x28(%rdi)
    0.00 :	  4aeff1:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  4aeff5:       48 89 47 30             mov    %rax,0x30(%rdi)
    0.00 :	  4aeff9:       49 8b 46 38             mov    0x38(%r14),%rax
    0.00 :	  4aeffd:       48 89 47 38             mov    %rax,0x38(%rdi)
    0.00 :	  4af001:       49 8b 46 40             mov    0x40(%r14),%rax
    0.00 :	  4af005:       48 89 47 40             mov    %rax,0x40(%rdi)
         :	                                if (numberOfEqualCols == attno - 1)
    0.00 :	  4af009:       41 0f bf c5             movswl %r13w,%eax
    0.00 :	  4af00d:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4af010:       3b 45 9c                cmp    -0x64(%rbp),%eax
    0.00 :	  4af013:       0f 85 27 ff ff ff       jne    4aef40 <_bt_preprocess_keys+0x370>
         :	                                        _bt_mark_scankey_required(outkey);
    0.00 :	  4af019:       e8 92 f1 ff ff          callq  4ae1b0 <_bt_mark_scankey_required>
    0.00 :	  4af01e:       e9 1d ff ff ff          jmpq   4aef40 <_bt_preprocess_keys+0x370>
    0.00 :	  4af023:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        /* yup, keep only the more restrictive key */
         :	                        if (_bt_compare_scankey_args(scan, cur, cur, xform[j],
         :	                                                                                 &test_result))
         :	                        {
         :	                                if (test_result)
         :	                                        xform[j] = cur;
    0.00 :	  4af028:       4c 89 74 dd a0          mov    %r14,-0x60(%rbp,%rbx,8)
    0.00 :	  4af02d:       0f 1f 00                nopl   (%rax)
    0.00 :	  4af030:       e9 0b ff ff ff          jmpq   4aef40 <_bt_preprocess_keys+0x370>
    0.00 :	  4af035:       0f 1f 00                nopl   (%rax)
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTLessEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTLessStrategyNumber - 1] = NULL;
    0.00 :	  4af038:       48 c7 45 a0 00 00 00    movq   $0x0,-0x60(%rbp)
    0.00 :	  4af03f:       00 
    0.00 :	  4af040:       e9 8b fd ff ff          jmpq   4aedd0 <_bt_preprocess_keys+0x200>
    0.00 :	  4af045:       0f 1f 00                nopl   (%rax)
         :	                                                                                         &test_result))
         :	                                {
         :	                                        if (test_result)
         :	                                                xform[BTGreaterEqualStrategyNumber - 1] = NULL;
         :	                                        else
         :	                                                xform[BTGreaterStrategyNumber - 1] = NULL;
    0.00 :	  4af048:       48 c7 45 c0 00 00 00    movq   $0x0,-0x40(%rbp)
    0.00 :	  4af04f:       00 
    0.00 :	  4af050:       31 d2                   xor    %edx,%edx
    0.00 :	  4af052:       e9 b8 fd ff ff          jmpq   4aee0f <_bt_preprocess_keys+0x23f>
    0.00 :	  4af057:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4af05e:       00 00 
         :	                                                continue;
         :
         :	                                        if (eq->sk_flags & SK_SEARCHNULL)
         :	                                        {
         :	                                                /* IS NULL is contradictory to anything else */
         :	                                                so->qual_ok = false;
    0.00 :	  4af060:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  4af067:       c6 00 00                movb   $0x0,(%rax)
         :	                        }
         :	                }
         :	        }
         :
         :	        so->numberOfKeys = new_numberOfKeys;
         :	}
    0.00 :	  4af06a:       e9 19 ff ff ff          jmpq   4aef88 <_bt_preprocess_keys+0x3b8>
    0.00 :	  4af06f:       90                      nop
         :
         :	        /* We can short-circuit most of the work if there's just one key */
         :	        if (numberOfKeys == 1)
         :	        {
         :	                /* Apply indoption to scankey (might change sk_strategy!) */
         :	                if (!_bt_fix_scankey_strategy(cur, indoption))
    0.00 :	  4af070:       48 8b b5 78 ff ff ff    mov    -0x88(%rbp),%rsi
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:784
   66.67 :	  4af077:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4af07a:       e8 e1 ec ff ff          callq  4add60 <_bt_fix_scankey_strategy>
    0.00 :	  4af07f:       84 c0                   test   %al,%al
    0.00 :	  4af081:       75 0a                   jne    4af08d <_bt_preprocess_keys+0x4bd>
         :	                        so->qual_ok = false;
    0.00 :	  4af083:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  4af08a:       c6 01 00                movb   $0x0,(%rcx)
         :	                memcpy(outkeys, cur, sizeof(ScanKeyData));
    0.00 :	  4af08d:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  4af090:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  4af094:       48 89 02                mov    %rax,(%rdx)
    0.00 :	  4af097:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  4af09b:       48 89 42 08             mov    %rax,0x8(%rdx)
    0.00 :	  4af09f:       48 8b 43 10             mov    0x10(%rbx),%rax
    0.00 :	  4af0a3:       48 89 42 10             mov    %rax,0x10(%rdx)
    0.00 :	  4af0a7:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  4af0ab:       48 89 42 18             mov    %rax,0x18(%rdx)
    0.00 :	  4af0af:       48 8b 43 20             mov    0x20(%rbx),%rax
    0.00 :	  4af0b3:       48 89 42 20             mov    %rax,0x20(%rdx)
    0.00 :	  4af0b7:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  4af0bb:       48 89 42 28             mov    %rax,0x28(%rdx)
    0.00 :	  4af0bf:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  4af0c3:       48 89 42 30             mov    %rax,0x30(%rdx)
    0.00 :	  4af0c7:       48 8b 43 38             mov    0x38(%rbx),%rax
    0.00 :	  4af0cb:       48 89 42 38             mov    %rax,0x38(%rdx)
    0.00 :	  4af0cf:       48 8b 43 40             mov    0x40(%rbx),%rax
    0.00 :	  4af0d3:       48 89 42 40             mov    %rax,0x40(%rdx)
         :	                so->numberOfKeys = 1;
    0.00 :	  4af0d7:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  4af0de:       c7 41 04 01 00 00 00    movl   $0x1,0x4(%rcx)
         :	                /* We can mark the qual as required if it's for first index col */
         :	                if (cur->sk_attno == 1)
    0.00 :	  4af0e5:       66 83 7b 04 01          cmpw   $0x1,0x4(%rbx)
    0.00 :	  4af0ea:       0f 85 98 fe ff ff       jne    4aef88 <_bt_preprocess_keys+0x3b8>
         :	                        _bt_mark_scankey_required(outkeys);
    0.00 :	  4af0f0:       48 89 d7                mov    %rdx,%rdi
    0.00 :	  4af0f3:       e8 b8 f0 ff ff          callq  4ae1b0 <_bt_mark_scankey_required>
    0.00 :	  4af0f8:       e9 8b fe ff ff          jmpq   4aef88 <_bt_preprocess_keys+0x3b8>
         :	         * Read so->arrayKeyData if array keys are present, else scan->keyData
         :	         */
         :	        if (so->arrayKeyData != NULL)
         :	                inkeys = so->arrayKeyData;
         :	        else
         :	                inkeys = scan->keyData;
    0.00 :	  4af0fd:       48 8b 85 60 ff ff ff    mov    -0xa0(%rbp),%rax
    0.00 :	  4af104:       48 8b 58 20             mov    0x20(%rax),%rbx
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:772
   33.33 :	  4af108:       e9 2a fb ff ff          jmpq   4aec37 <_bt_preprocess_keys+0x67>
         :	                                        _bt_mark_scankey_required(outkey);
         :	                        }
         :	                }
         :	        }
         :
         :	        so->numberOfKeys = new_numberOfKeys;
    0.00 :	  4af10d:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  4af114:       44 89 78 04             mov    %r15d,0x4(%rax)
    0.00 :	  4af118:       e9 6b fe ff ff          jmpq   4aef88 <_bt_preprocess_keys+0x3b8>
         :	                {
         :	                        int                     priorNumberOfEqualCols = numberOfEqualCols;
         :
         :	                        /* check input keys are correctly ordered */
         :	                        if (i < numberOfKeys && cur->sk_attno < attno)
         :	                                elog(ERROR, "btree index keys must be ordered by attribute");
    0.00 :	  4af11d:       ba 40 4b 7b 00          mov    $0x7b4b40,%edx
    0.00 :	  4af122:       be 45 03 00 00          mov    $0x345,%esi
    0.00 :	  4af127:       bf 17 49 7b 00          mov    $0x7b4917,%edi
    0.00 :	  4af12c:       e8 ef c2 2c 00          callq  77b420 <elog_start>
    0.00 :	  4af131:       be b8 49 7b 00          mov    $0x7b49b8,%esi
    0.00 :	  4af136:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4af13b:       31 c0                   xor    %eax,%eax
    0.00 :	  4af13d:       e8 ee c0 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4af142:       e8 89 a3 fb ff          callq  4694d0 <abort@plt>
         :	                                if (test_result)
         :	                                        xform[j] = cur;
         :	                                else if (j == (BTEqualStrategyNumber - 1))
         :	                                {
         :	                                        /* key == a && key == b, but a != b */
         :	                                        so->qual_ok = false;
    0.00 :	  4af147:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	  4af14e:       c6 01 00                movb   $0x0,(%rcx)
         :	                        }
         :	                }
         :	        }
         :
         :	        so->numberOfKeys = new_numberOfKeys;
         :	}
    0.00 :	  4af151:       e9 32 fe ff ff          jmpq   4aef88 <_bt_preprocess_keys+0x3b8>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:112
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:113
   33.33 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:116
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c5910 <ExecSeqScan>:
         :	 *              access method functions.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecSeqScan(SeqScanState *node)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:112
   33.33 :	  5c5910:       55                      push   %rbp
         :	        return ExecScan((ScanState *) node,
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:113
   33.33 :	  5c5911:       ba 30 57 5c 00          mov    $0x5c5730,%edx
    0.00 :	  5c5916:       be 30 59 5c 00          mov    $0x5c5930,%esi
         :	 *              access method functions.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecSeqScan(SeqScanState *node)
         :	{
    0.00 :	  5c591b:       48 89 e5                mov    %rsp,%rbp
         :	        return ExecScan((ScanState *) node,
         :	                                        (ExecScanAccessMtd) SeqNext,
         :	                                        (ExecScanRecheckMtd) SeqRecheck);
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeSeqscan.c:116
   33.33 :	  5c591e:       c9                      leaveq 
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecSeqScan(SeqScanState *node)
         :	{
         :	        return ExecScan((ScanState *) node,
    0.00 :	  5c591f:       e9 2c de fe ff          jmpq   5b3750 <ExecScan>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:1736
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006983d0 <_mdfd_getseg>:
         :	 * EXTENSION_CREATE case.
         :	 */
         :	static MdfdVec *
         :	_mdfd_getseg(SMgrRelation reln, ForkNumber forknum, BlockNumber blkno,
         :	                         bool skipFsync, ExtensionBehavior behavior)
         :	{
    0.00 :	  6983d0:       55                      push   %rbp
    0.00 :	  6983d1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  6983d4:       41 57                   push   %r15
    0.00 :	  6983d6:       41 56                   push   %r14
    0.00 :	  6983d8:       41 55                   push   %r13
    0.00 :	  6983da:       41 54                   push   %r12
    0.00 :	  6983dc:       53                      push   %rbx
    0.00 :	  6983dd:       89 cb                   mov    %ecx,%ebx
    0.00 :	  6983df:       48 83 ec 18             sub    $0x18,%rsp
    0.00 :	  6983e3:       89 55 c8                mov    %edx,-0x38(%rbp)
         :	        MdfdVec    *v = mdopen(reln, forknum, behavior);
    0.00 :	  6983e6:       44 89 c2                mov    %r8d,%edx
         :	 * EXTENSION_CREATE case.
         :	 */
         :	static MdfdVec *
         :	_mdfd_getseg(SMgrRelation reln, ForkNumber forknum, BlockNumber blkno,
         :	                         bool skipFsync, ExtensionBehavior behavior)
         :	{
    0.00 :	  6983e9:       48 89 7d d0             mov    %rdi,-0x30(%rbp)
    0.00 :	  6983ed:       89 75 cc                mov    %esi,-0x34(%rbp)
    0.00 :	  6983f0:       44 89 45 c4             mov    %r8d,-0x3c(%rbp)
         :	        MdfdVec    *v = mdopen(reln, forknum, behavior);
    0.00 :	  6983f4:       e8 47 f5 ff ff          callq  697940 <mdopen>
         :	        BlockNumber targetseg;
         :	        BlockNumber nextsegno;
         :
         :	        if (!v)
    0.00 :	  6983f9:       48 85 c0                test   %rax,%rax
         :	 */
         :	static MdfdVec *
         :	_mdfd_getseg(SMgrRelation reln, ForkNumber forknum, BlockNumber blkno,
         :	                         bool skipFsync, ExtensionBehavior behavior)
         :	{
         :	        MdfdVec    *v = mdopen(reln, forknum, behavior);
    0.00 :	  6983fc:       49 89 c4                mov    %rax,%r12
         :	        BlockNumber targetseg;
         :	        BlockNumber nextsegno;
         :
         :	        if (!v)
    0.00 :	  6983ff:       0f 84 d3 00 00 00       je     6984d8 <_mdfd_getseg+0x108>
         :	                return NULL;                    /* only possible if EXTENSION_RETURN_NULL */
         :
         :	        targetseg = blkno / ((BlockNumber) RELSEG_SIZE);
    0.00 :	  698405:       44 8b 7d c8             mov    -0x38(%rbp),%r15d
    0.00 :	  698409:       41 c1 ef 11             shr    $0x11,%r15d
         :	        for (nextsegno = 1; nextsegno <= targetseg; nextsegno++)
    0.00 :	  69840d:       45 85 ff                test   %r15d,%r15d
    0.00 :	  698410:       0f 84 c2 00 00 00       je     6984d8 <_mdfd_getseg+0x108>
         :	                        {
         :	                                if (_mdnblocks(reln, forknum, v) < RELSEG_SIZE)
         :	                                {
         :	                                        char       *zerobuf = palloc0(BLCKSZ);
         :
         :	                                        mdextend(reln, forknum,
    0.00 :	  698416:       0f be db                movsbl %bl,%ebx
         :
         :	        if (!v)
         :	                return NULL;                    /* only possible if EXTENSION_RETURN_NULL */
         :
         :	        targetseg = blkno / ((BlockNumber) RELSEG_SIZE);
         :	        for (nextsegno = 1; nextsegno <= targetseg; nextsegno++)
    0.00 :	  698419:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  69841f:       41 be ff ff 01 00       mov    $0x1ffff,%r14d
         :	                        {
         :	                                if (_mdnblocks(reln, forknum, v) < RELSEG_SIZE)
         :	                                {
         :	                                        char       *zerobuf = palloc0(BLCKSZ);
         :
         :	                                        mdextend(reln, forknum,
    0.00 :	  698425:       89 5d c0                mov    %ebx,-0x40(%rbp)
    0.00 :	  698428:       eb 1d                   jmp    698447 <_mdfd_getseg+0x77>
    0.00 :	  69842a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        if (v->mdfd_chain == NULL)
         :	                        {
         :	                                if (behavior == EXTENSION_RETURN_NULL &&
         :	                                        FILE_POSSIBLY_DELETED(errno))
         :	                                        return NULL;
         :	                                ereport(ERROR,
    0.00 :	  698430:       49 89 c4                mov    %rax,%r12
         :
         :	        if (!v)
         :	                return NULL;                    /* only possible if EXTENSION_RETURN_NULL */
         :
         :	        targetseg = blkno / ((BlockNumber) RELSEG_SIZE);
         :	        for (nextsegno = 1; nextsegno <= targetseg; nextsegno++)
    0.00 :	  698433:       41 83 c5 01             add    $0x1,%r13d
    0.00 :	  698437:       41 81 c6 00 00 02 00    add    $0x20000,%r14d
    0.00 :	  69843e:       45 39 ef                cmp    %r13d,%r15d
    0.00 :	  698441:       0f 82 91 00 00 00       jb     6984d8 <_mdfd_getseg+0x108>
         :	        {
         :	                Assert(nextsegno == v->mdfd_segno + 1);
         :
         :	                if (v->mdfd_chain == NULL)
    0.00 :	  698447:       49 8b 44 24 08          mov    0x8(%r12),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:1736
  100.00 :	  69844c:       48 85 c0                test   %rax,%rax
    0.00 :	  69844f:       75 df                   jne    698430 <_mdfd_getseg+0x60>
         :	                         * active segment are of size RELSEG_SIZE; therefore, pad them out
         :	                         * with zeroes if needed.  (This only matters if caller is
         :	                         * extending the relation discontiguously, but that can happen in
         :	                         * hash indexes.)
         :	                         */
         :	                        if (behavior == EXTENSION_CREATE || InRecovery)
    0.00 :	  698451:       83 7d c4 02             cmpl   $0x2,-0x3c(%rbp)
    0.00 :	  698455:       74 0d                   je     698464 <_mdfd_getseg+0x94>
    0.00 :	  698457:       80 3d 0a 0d 4e 00 00    cmpb   $0x0,0x4e0d0a(%rip)        # b79168 <InRecovery>
    0.00 :	  69845e:       0f 84 8c 00 00 00       je     6984f0 <_mdfd_getseg+0x120>
         :	                        {
         :	                                if (_mdnblocks(reln, forknum, v) < RELSEG_SIZE)
    0.00 :	  698464:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  698467:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  69846b:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  69846e:       e8 9d f7 ff ff          callq  697c10 <_mdnblocks>
    0.00 :	  698473:       3d ff ff 01 00          cmp    $0x1ffff,%eax
    0.00 :	  698478:       76 7e                   jbe    6984f8 <_mdfd_getseg+0x128>
         :	                                        mdextend(reln, forknum,
         :	                                                         nextsegno * ((BlockNumber) RELSEG_SIZE) - 1,
         :	                                                         zerobuf, skipFsync);
         :	                                        pfree(zerobuf);
         :	                                }
         :	                                v->mdfd_chain = _mdfd_openseg(reln, forknum, +nextsegno, O_CREAT);
    0.00 :	  69847a:       b9 40 00 00 00          mov    $0x40,%ecx
         :	                        }
         :	                        else
         :	                        {
         :	                                /* We won't create segment if not existent */
         :	                                v->mdfd_chain = _mdfd_openseg(reln, forknum, nextsegno, 0);
    0.00 :	  69847f:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  698482:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  698486:       44 89 ea                mov    %r13d,%edx
    0.00 :	  698489:       e8 72 f8 ff ff          callq  697d00 <_mdfd_openseg>
    0.00 :	  69848e:       49 89 44 24 08          mov    %rax,0x8(%r12)
         :	                        }
         :	                        if (v->mdfd_chain == NULL)
    0.00 :	  698493:       4d 8b 64 24 08          mov    0x8(%r12),%r12
    0.00 :	  698498:       4d 85 e4                test   %r12,%r12
    0.00 :	  69849b:       75 96                   jne    698433 <_mdfd_getseg+0x63>
         :	                        {
         :	                                if (behavior == EXTENSION_RETURN_NULL &&
    0.00 :	  69849d:       83 7d c4 01             cmpl   $0x1,-0x3c(%rbp)
    0.00 :	  6984a1:       75 0a                   jne    6984ad <_mdfd_getseg+0xdd>
    0.00 :	  6984a3:       e8 18 18 dd ff          callq  469cc0 <__errno_location@plt>
    0.00 :	  6984a8:       83 38 02                cmpl   $0x2,(%rax)
    0.00 :	  6984ab:       74 2b                   je     6984d8 <_mdfd_getseg+0x108>
         :	                                        FILE_POSSIBLY_DELETED(errno))
         :	                                        return NULL;
         :	                                ereport(ERROR,
    0.00 :	  6984ad:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6984b0:       b9 72 e3 8a 00          mov    $0x8ae372,%ecx
    0.00 :	  6984b5:       ba f3 06 00 00          mov    $0x6f3,%edx
    0.00 :	  6984ba:       be db 5b 87 00          mov    $0x875bdb,%esi
    0.00 :	  6984bf:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  6984c4:       e8 f7 25 0e 00          callq  77aac0 <errstart>
    0.00 :	  6984c9:       84 c0                   test   %al,%al
    0.00 :	  6984cb:       75 5b                   jne    698528 <_mdfd_getseg+0x158>
    0.00 :	  6984cd:       e8 fe 0f dd ff          callq  4694d0 <abort@plt>
    0.00 :	  6984d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        }
         :	                }
         :	                v = v->mdfd_chain;
         :	        }
         :	        return v;
         :	}
    0.00 :	  6984d8:       48 83 c4 18             add    $0x18,%rsp
    0.00 :	  6984dc:       4c 89 e0                mov    %r12,%rax
    0.00 :	  6984df:       5b                      pop    %rbx
    0.00 :	  6984e0:       41 5c                   pop    %r12
    0.00 :	  6984e2:       41 5d                   pop    %r13
    0.00 :	  6984e4:       41 5e                   pop    %r14
    0.00 :	  6984e6:       41 5f                   pop    %r15
    0.00 :	  6984e8:       c9                      leaveq 
    0.00 :	  6984e9:       c3                      retq   
    0.00 :	  6984ea:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                v->mdfd_chain = _mdfd_openseg(reln, forknum, +nextsegno, O_CREAT);
         :	                        }
         :	                        else
         :	                        {
         :	                                /* We won't create segment if not existent */
         :	                                v->mdfd_chain = _mdfd_openseg(reln, forknum, nextsegno, 0);
    0.00 :	  6984f0:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6984f2:       eb 8b                   jmp    69847f <_mdfd_getseg+0xaf>
    0.00 :	  6984f4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                         */
         :	                        if (behavior == EXTENSION_CREATE || InRecovery)
         :	                        {
         :	                                if (_mdnblocks(reln, forknum, v) < RELSEG_SIZE)
         :	                                {
         :	                                        char       *zerobuf = palloc0(BLCKSZ);
    0.00 :	  6984f8:       bf 00 20 00 00          mov    $0x2000,%edi
    0.00 :	  6984fd:       e8 6e 0a 10 00          callq  798f70 <palloc0>
         :
         :	                                        mdextend(reln, forknum,
    0.00 :	  698502:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  698506:       44 8b 45 c0             mov    -0x40(%rbp),%r8d
         :	                         */
         :	                        if (behavior == EXTENSION_CREATE || InRecovery)
         :	                        {
         :	                                if (_mdnblocks(reln, forknum, v) < RELSEG_SIZE)
         :	                                {
         :	                                        char       *zerobuf = palloc0(BLCKSZ);
    0.00 :	  69850a:       48 89 c3                mov    %rax,%rbx
         :
         :	                                        mdextend(reln, forknum,
    0.00 :	  69850d:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  698510:       48 89 c1                mov    %rax,%rcx
    0.00 :	  698513:       44 89 f2                mov    %r14d,%edx
    0.00 :	  698516:       e8 35 fc ff ff          callq  698150 <mdextend>
         :	                                                         nextsegno * ((BlockNumber) RELSEG_SIZE) - 1,
         :	                                                         zerobuf, skipFsync);
         :	                                        pfree(zerobuf);
    0.00 :	  69851b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  69851e:       e8 5d 06 10 00          callq  798b80 <pfree>
    0.00 :	  698523:       e9 52 ff ff ff          jmpq   69847a <_mdfd_getseg+0xaa>
         :	                        if (v->mdfd_chain == NULL)
         :	                        {
         :	                                if (behavior == EXTENSION_RETURN_NULL &&
         :	                                        FILE_POSSIBLY_DELETED(errno))
         :	                                        return NULL;
         :	                                ereport(ERROR,
    0.00 :	  698528:       8b 75 cc                mov    -0x34(%rbp),%esi
    0.00 :	  69852b:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  69852f:       44 89 ea                mov    %r13d,%edx
    0.00 :	  698532:       e8 59 f7 ff ff          callq  697c90 <_mdfd_segpath>
    0.00 :	  698537:       8b 55 c8                mov    -0x38(%rbp),%edx
    0.00 :	  69853a:       48 89 c6                mov    %rax,%rsi
    0.00 :	  69853d:       bf b0 e1 8a 00          mov    $0x8ae1b0,%edi
    0.00 :	  698542:       31 c0                   xor    %eax,%eax
    0.00 :	  698544:       e8 57 43 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  698549:       89 c3                   mov    %eax,%ebx
    0.00 :	  69854b:       e8 a0 45 0e 00          callq  77caf0 <errcode_for_file_access>
    0.00 :	  698550:       89 de                   mov    %ebx,%esi
    0.00 :	  698552:       89 c7                   mov    %eax,%edi
    0.00 :	  698554:       31 c0                   xor    %eax,%eax
    0.00 :	  698556:       e8 85 20 0e 00          callq  77a5e0 <errfinish>
    0.00 :	  69855b:       e9 6d ff ff ff          jmpq   6984cd <_mdfd_getseg+0xfd>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/date.c:339
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006c6b50 <date_ge>:
         :	        PG_RETURN_BOOL(dateVal1 > dateVal2);
         :	}
         :
         :	Datum
         :	date_ge(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/date.c:339
  100.00 :	  6c6b50:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  6c6b54:       39 47 20                cmp    %eax,0x20(%rdi)
    0.00 :	  6c6b57:       55                      push   %rbp
    0.00 :	  6c6b58:       48 89 e5                mov    %rsp,%rbp
         :	        DateADT         dateVal1 = PG_GETARG_DATEADT(0);
         :	        DateADT         dateVal2 = PG_GETARG_DATEADT(1);
         :
         :	        PG_RETURN_BOOL(dateVal1 >= dateVal2);
         :	}
    0.00 :	  6c6b5b:       c9                      leaveq 
         :	        PG_RETURN_BOOL(dateVal1 > dateVal2);
         :	}
         :
         :	Datum
         :	date_ge(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  6c6b5c:       0f 9d c0                setge  %al
    0.00 :	  6c6b5f:       0f b6 c0                movzbl %al,%eax

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   66.67 ??:0
   33.33 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000122bb0 <__memmove_ssse3>:
    0.00 :	  122bb0:       48 89 f8                mov    %rdi,%rax
    0.00 :	  122bb3:       48 39 f7                cmp    %rsi,%rdi
    0.00 :	  122bb6:       72 0e                   jb     122bc6 <__memmove_ssse3+0x16>
    0.00 :	  122bb8:       0f 84 7a 1a 00 00       je     124638 <__memmove_ssse3+0x1a88>
    0.00 :	  122bbe:       48 83 fa 4f             cmp    $0x4f,%rdx
    0.00 :	  122bc2:       76 02                   jbe    122bc6 <__memmove_ssse3+0x16>
    0.00 :	  122bc4:       eb 7a                   jmp    122c40 <__memmove_ssse3+0x90>
    0.00 :	  122bc6:       48 83 fa 4f             cmp    $0x4f,%rdx
    0.00 :	  122bca:       4c 8d 1d cf 16 02 00    lea    0x216cf(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122bd1:       77 1d                   ja     122bf0 <__memmove_ssse3+0x40>
    0.00 :	  122bd3:       4d 63 0c 93             movslq (%r11,%rdx,4),%r9
 ??:0
   33.33 :	  122bd7:       48 01 d6                add    %rdx,%rsi
    0.00 :	  122bda:       48 01 d7                add    %rdx,%rdi
    0.00 :	  122bdd:       4d 01 d9                add    %r11,%r9
    0.00 :	  122be0:       41 ff e1                jmpq   *%r9
    0.00 :	  122be3:       0f 0b                   ud2    
    0.00 :	  122be5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  122bec:       00 00 00 00 
    0.00 :	  122bf0:       f3 0f 6f 06             movdqu (%rsi),%xmm0
    0.00 :	  122bf4:       48 89 f9                mov    %rdi,%rcx
    0.00 :	  122bf7:       48 83 e7 f0             and    $0xfffffffffffffff0,%rdi
    0.00 :	  122bfb:       48 83 c7 10             add    $0x10,%rdi
    0.00 :	  122bff:       49 89 c8                mov    %rcx,%r8
    0.00 :	  122c02:       48 29 f9                sub    %rdi,%rcx
    0.00 :	  122c05:       48 01 ca                add    %rcx,%rdx
    0.00 :	  122c08:       48 29 ce                sub    %rcx,%rsi
    0.00 :	  122c0b:       48 8b 0d 1e f5 24 00    mov    0x24f51e(%rip),%rcx        # 372130 <__x86_64_shared_cache_size_half>
    0.00 :	  122c12:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  122c15:       49 89 f1                mov    %rsi,%r9
    0.00 :	  122c18:       0f 87 92 27 00 00       ja     1253b0 <__memmove_ssse3+0x2800>
    0.00 :	  122c1e:       49 83 e1 0f             and    $0xf,%r9
    0.00 :	  122c22:       74 7c                   je     122ca0 <__memmove_ssse3+0xf0>
    0.00 :	  122c24:       48 8b 0d e5 f4 24 00    mov    0x24f4e5(%rip),%rcx        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	  122c2b:       4c 8d 1d ae 17 02 00    lea    0x217ae(%rip),%r11        # 1443e0 <null+0x8a0>
    0.00 :	  122c32:       4f 63 0c 8b             movslq (%r11,%r9,4),%r9
    0.00 :	  122c36:       4f 8d 0c 0b             lea    (%r11,%r9,1),%r9
    0.00 :	  122c3a:       41 ff e1                jmpq   *%r9
    0.00 :	  122c3d:       0f 0b                   ud2    
    0.00 :	  122c3f:       90                      nop
    0.00 :	  122c40:       f3 0f 6f 44 16 f0       movdqu -0x10(%rsi,%rdx,1),%xmm0
    0.00 :	  122c46:       48 01 d6                add    %rdx,%rsi
    0.00 :	  122c49:       4c 8d 44 17 f0          lea    -0x10(%rdi,%rdx,1),%r8
    0.00 :	  122c4e:       48 01 d7                add    %rdx,%rdi
    0.00 :	  122c51:       48 89 f9                mov    %rdi,%rcx
    0.00 :	  122c54:       48 83 e1 0f             and    $0xf,%rcx
    0.00 :	  122c58:       48 31 cf                xor    %rcx,%rdi
    0.00 :	  122c5b:       48 29 ca                sub    %rcx,%rdx
    0.00 :	  122c5e:       48 29 ce                sub    %rcx,%rsi
    0.00 :	  122c61:       48 8b 0d c8 f4 24 00    mov    0x24f4c8(%rip),%rcx        # 372130 <__x86_64_shared_cache_size_half>
    0.00 :	  122c68:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  122c6b:       49 89 f1                mov    %rsi,%r9
    0.00 :	  122c6e:       0f 87 fc 28 00 00       ja     125570 <__memmove_ssse3+0x29c0>
    0.00 :	  122c74:       49 83 e1 0f             and    $0xf,%r9
    0.00 :	  122c78:       0f 84 42 02 00 00       je     122ec0 <__memmove_ssse3+0x310>
    0.00 :	  122c7e:       48 8b 0d 8b f4 24 00    mov    0x24f48b(%rip),%rcx        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	  122c85:       4c 8d 1d 94 17 02 00    lea    0x21794(%rip),%r11        # 144420 <null+0x8e0>
    0.00 :	  122c8c:       4f 63 0c 8b             movslq (%r11,%r9,4),%r9
    0.00 :	  122c90:       4f 8d 0c 0b             lea    (%r11,%r9,1),%r9
    0.00 :	  122c94:       41 ff e1                jmpq   *%r9
    0.00 :	  122c97:       0f 0b                   ud2    
    0.00 :	  122c99:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  122ca0:       48 83 ea 10             sub    $0x10,%rdx
    0.00 :	  122ca4:       66 0f 6f 0e             movdqa (%rsi),%xmm1
    0.00 :	  122ca8:       48 83 c6 10             add    $0x10,%rsi
    0.00 :	  122cac:       66 0f 7f 0f             movdqa %xmm1,(%rdi)
    0.00 :	  122cb0:       48 83 c7 10             add    $0x10,%rdi
    0.00 :	  122cb4:       48 81 fa 80 00 00 00    cmp    $0x80,%rdx
    0.00 :	  122cbb:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  122cc0:       77 4e                   ja     122d10 <__memmove_ssse3+0x160>
    0.00 :	  122cc2:       48 83 fa 40             cmp    $0x40,%rdx
    0.00 :	  122cc6:       72 2a                   jb     122cf2 <__memmove_ssse3+0x142>
    0.00 :	  122cc8:       0f 28 26                movaps (%rsi),%xmm4
    0.00 :	  122ccb:       0f 28 4e 10             movaps 0x10(%rsi),%xmm1
    0.00 :	  122ccf:       0f 28 56 20             movaps 0x20(%rsi),%xmm2
    0.00 :	  122cd3:       0f 28 5e 30             movaps 0x30(%rsi),%xmm3
    0.00 :	  122cd7:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  122cda:       0f 29 4f 10             movaps %xmm1,0x10(%rdi)
    0.00 :	  122cde:       0f 29 57 20             movaps %xmm2,0x20(%rdi)
    0.00 :	  122ce2:       0f 29 5f 30             movaps %xmm3,0x30(%rdi)
    0.00 :	  122ce6:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  122cea:       48 83 c6 40             add    $0x40,%rsi
    0.00 :	  122cee:       48 83 c7 40             add    $0x40,%rdi
    0.00 :	  122cf2:       48 01 d6                add    %rdx,%rsi
    0.00 :	  122cf5:       48 01 d7                add    %rdx,%rdi
    0.00 :	  122cf8:       4c 8d 1d a1 15 02 00    lea    0x215a1(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122cff:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  122d03:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  122d07:       ff e2                   jmpq   *%rdx
    0.00 :	  122d09:       0f 0b                   ud2    
    0.00 :	  122d0b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  122d10:       48 3b 15 f9 f3 24 00    cmp    0x24f3f9(%rip),%rdx        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	  122d17:       48 8d 52 80             lea    -0x80(%rdx),%rdx
    0.00 :	  122d1b:       0f 83 af 00 00 00       jae    122dd0 <__memmove_ssse3+0x220>
    0.00 :	  122d21:       66 0f 6f 26             movdqa (%rsi),%xmm4
    0.00 :	  122d25:       0f 28 4e 10             movaps 0x10(%rsi),%xmm1
    0.00 :	  122d29:       0f 28 56 20             movaps 0x20(%rsi),%xmm2
    0.00 :	  122d2d:       0f 28 5e 30             movaps 0x30(%rsi),%xmm3
    0.00 :	  122d31:       66 0f 7f 27             movdqa %xmm4,(%rdi)
    0.00 :	  122d35:       0f 29 4f 10             movaps %xmm1,0x10(%rdi)
    0.00 :	  122d39:       0f 29 57 20             movaps %xmm2,0x20(%rdi)
    0.00 :	  122d3d:       0f 29 5f 30             movaps %xmm3,0x30(%rdi)
    0.00 :	  122d41:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  122d48:       0f 28 66 40             movaps 0x40(%rsi),%xmm4
    0.00 :	  122d4c:       0f 28 6e 50             movaps 0x50(%rsi),%xmm5
    0.00 :	  122d50:       0f 28 76 60             movaps 0x60(%rsi),%xmm6
    0.00 :	  122d54:       0f 28 7e 70             movaps 0x70(%rsi),%xmm7
    0.00 :	  122d58:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	  122d5f:       0f 29 67 40             movaps %xmm4,0x40(%rdi)
    0.00 :	  122d63:       0f 29 6f 50             movaps %xmm5,0x50(%rdi)
    0.00 :	  122d67:       0f 29 77 60             movaps %xmm6,0x60(%rdi)
    0.00 :	  122d6b:       0f 29 7f 70             movaps %xmm7,0x70(%rdi)
    0.00 :	  122d6f:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	  122d76:       73 a9                   jae    122d21 <__memmove_ssse3+0x171>
    0.00 :	  122d78:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  122d7c:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  122d83:       7c 32                   jl     122db7 <__memmove_ssse3+0x207>
    0.00 :	  122d85:       66 0f 6f 26             movdqa (%rsi),%xmm4
    0.00 :	  122d89:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  122d8d:       66 0f 6f 4e 10          movdqa 0x10(%rsi),%xmm1
    0.00 :	  122d92:       66 0f 7f 27             movdqa %xmm4,(%rdi)
    0.00 :	  122d96:       66 0f 7f 4f 10          movdqa %xmm1,0x10(%rdi)
    0.00 :	  122d9b:       66 0f 6f 66 20          movdqa 0x20(%rsi),%xmm4
    0.00 :	  122da0:       66 0f 6f 4e 30          movdqa 0x30(%rsi),%xmm1
    0.00 :	  122da5:       48 83 c6 40             add    $0x40,%rsi
    0.00 :	  122da9:       66 0f 7f 67 20          movdqa %xmm4,0x20(%rdi)
    0.00 :	  122dae:       66 0f 7f 4f 30          movdqa %xmm1,0x30(%rdi)
    0.00 :	  122db3:       48 83 c7 40             add    $0x40,%rdi
    0.00 :	  122db7:       48 01 d6                add    %rdx,%rsi
    0.00 :	  122dba:       48 01 d7                add    %rdx,%rdi
    0.00 :	  122dbd:       4c 8d 1d dc 14 02 00    lea    0x214dc(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122dc4:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  122dc8:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  122dcc:       ff e2                   jmpq   *%rdx
    0.00 :	  122dce:       0f 0b                   ud2    
    0.00 :	  122dd0:       0f 18 8e c0 01 00 00    prefetcht0 0x1c0(%rsi)
    0.00 :	  122dd7:       0f 18 8e 80 02 00 00    prefetcht0 0x280(%rsi)
    0.00 :	  122dde:       66 0f 6f 06             movdqa (%rsi),%xmm0
    0.00 :	  122de2:       66 0f 6f 4e 10          movdqa 0x10(%rsi),%xmm1
    0.00 :	  122de7:       66 0f 6f 56 20          movdqa 0x20(%rsi),%xmm2
    0.00 :	  122dec:       66 0f 6f 5e 30          movdqa 0x30(%rsi),%xmm3
    0.00 :	  122df1:       66 0f 6f 66 40          movdqa 0x40(%rsi),%xmm4
    0.00 :	  122df6:       66 0f 6f 6e 50          movdqa 0x50(%rsi),%xmm5
    0.00 :	  122dfb:       66 0f 6f 76 60          movdqa 0x60(%rsi),%xmm6
    0.00 :	  122e00:       66 0f 6f 7e 70          movdqa 0x70(%rsi),%xmm7
    0.00 :	  122e05:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	  122e0c:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  122e13:       66 0f 7f 07             movdqa %xmm0,(%rdi)
    0.00 :	  122e17:       66 0f 7f 4f 10          movdqa %xmm1,0x10(%rdi)
    0.00 :	  122e1c:       66 0f 7f 57 20          movdqa %xmm2,0x20(%rdi)
    0.00 :	  122e21:       66 0f 7f 5f 30          movdqa %xmm3,0x30(%rdi)
    0.00 :	  122e26:       66 0f 7f 67 40          movdqa %xmm4,0x40(%rdi)
    0.00 :	  122e2b:       66 0f 7f 6f 50          movdqa %xmm5,0x50(%rdi)
    0.00 :	  122e30:       66 0f 7f 77 60          movdqa %xmm6,0x60(%rdi)
    0.00 :	  122e35:       66 0f 7f 7f 70          movdqa %xmm7,0x70(%rdi)
    0.00 :	  122e3a:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	  122e41:       73 8d                   jae    122dd0 <__memmove_ssse3+0x220>
    0.00 :	  122e43:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  122e47:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  122e4e:       7c 32                   jl     122e82 <__memmove_ssse3+0x2d2>
    0.00 :	  122e50:       66 0f 6f 06             movdqa (%rsi),%xmm0
    0.00 :	  122e54:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  122e58:       66 0f 6f 4e 10          movdqa 0x10(%rsi),%xmm1
    0.00 :	  122e5d:       66 0f 7f 07             movdqa %xmm0,(%rdi)
    0.00 :	  122e61:       66 0f 7f 4f 10          movdqa %xmm1,0x10(%rdi)
    0.00 :	  122e66:       66 0f 6f 46 20          movdqa 0x20(%rsi),%xmm0
    0.00 :	  122e6b:       66 0f 6f 4e 30          movdqa 0x30(%rsi),%xmm1
    0.00 :	  122e70:       48 83 c6 40             add    $0x40,%rsi
    0.00 :	  122e74:       66 0f 7f 47 20          movdqa %xmm0,0x20(%rdi)
    0.00 :	  122e79:       66 0f 7f 4f 30          movdqa %xmm1,0x30(%rdi)
    0.00 :	  122e7e:       48 83 c7 40             add    $0x40,%rdi
    0.00 :	  122e82:       48 83 fa 20             cmp    $0x20,%rdx
    0.00 :	  122e86:       72 1e                   jb     122ea6 <__memmove_ssse3+0x2f6>
    0.00 :	  122e88:       66 0f 6f 06             movdqa (%rsi),%xmm0
    0.00 :	  122e8c:       48 83 ea 20             sub    $0x20,%rdx
    0.00 :	  122e90:       66 0f 6f 4e 10          movdqa 0x10(%rsi),%xmm1
    0.00 :	  122e95:       48 83 c6 20             add    $0x20,%rsi
    0.00 :	  122e99:       66 0f 7f 07             movdqa %xmm0,(%rdi)
    0.00 :	  122e9d:       66 0f 7f 4f 10          movdqa %xmm1,0x10(%rdi)
    0.00 :	  122ea2:       48 83 c7 20             add    $0x20,%rdi
    0.00 :	  122ea6:       48 01 d7                add    %rdx,%rdi
    0.00 :	  122ea9:       48 01 d6                add    %rdx,%rsi
    0.00 :	  122eac:       4c 8d 1d ed 13 02 00    lea    0x213ed(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122eb3:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  122eb7:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  122ebb:       ff e2                   jmpq   *%rdx
    0.00 :	  122ebd:       0f 0b                   ud2    
    0.00 :	  122ebf:       90                      nop
    0.00 :	  122ec0:       48 83 ea 10             sub    $0x10,%rdx
    0.00 :	  122ec4:       66 0f 6f 4e f0          movdqa -0x10(%rsi),%xmm1
    0.00 :	  122ec9:       48 83 ee 10             sub    $0x10,%rsi
    0.00 :	  122ecd:       66 0f 7f 4f f0          movdqa %xmm1,-0x10(%rdi)
    0.00 :	  122ed2:       48 83 ef 10             sub    $0x10,%rdi
    0.00 :	  122ed6:       48 81 fa 80 00 00 00    cmp    $0x80,%rdx
    0.00 :	  122edd:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  122ee2:       77 4c                   ja     122f30 <__memmove_ssse3+0x380>
    0.00 :	  122ee4:       48 83 fa 40             cmp    $0x40,%rdx
    0.00 :	  122ee8:       72 2c                   jb     122f16 <__memmove_ssse3+0x366>
    0.00 :	  122eea:       0f 28 46 f0             movaps -0x10(%rsi),%xmm0
    0.00 :	  122eee:       0f 28 4e e0             movaps -0x20(%rsi),%xmm1
    0.00 :	  122ef2:       0f 28 56 d0             movaps -0x30(%rsi),%xmm2
    0.00 :	  122ef6:       0f 28 5e c0             movaps -0x40(%rsi),%xmm3
    0.00 :	  122efa:       0f 29 47 f0             movaps %xmm0,-0x10(%rdi)
    0.00 :	  122efe:       0f 29 4f e0             movaps %xmm1,-0x20(%rdi)
    0.00 :	  122f02:       0f 29 57 d0             movaps %xmm2,-0x30(%rdi)
    0.00 :	  122f06:       0f 29 5f c0             movaps %xmm3,-0x40(%rdi)
    0.00 :	  122f0a:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  122f0e:       48 83 ee 40             sub    $0x40,%rsi
    0.00 :	  122f12:       48 83 ef 40             sub    $0x40,%rdi
    0.00 :	  122f16:       4c 8d 1d 83 13 02 00    lea    0x21383(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122f1d:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  122f21:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  122f25:       ff e2                   jmpq   *%rdx
    0.00 :	  122f27:       0f 0b                   ud2    
    0.00 :	  122f29:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  122f30:       48 3b 15 d9 f1 24 00    cmp    0x24f1d9(%rip),%rdx        # 372110 <__x86_64_data_cache_size_half>
    0.00 :	  122f37:       48 8d 52 80             lea    -0x80(%rdx),%rdx
    0.00 :	  122f3b:       0f 83 af 00 00 00       jae    122ff0 <__memmove_ssse3+0x440>
    0.00 :	  122f41:       66 0f 6f 46 f0          movdqa -0x10(%rsi),%xmm0
    0.00 :	  122f46:       0f 28 4e e0             movaps -0x20(%rsi),%xmm1
    0.00 :	  122f4a:       0f 28 56 d0             movaps -0x30(%rsi),%xmm2
    0.00 :	  122f4e:       0f 28 5e c0             movaps -0x40(%rsi),%xmm3
    0.00 :	  122f52:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	  122f57:       0f 29 4f e0             movaps %xmm1,-0x20(%rdi)
    0.00 :	  122f5b:       0f 29 57 d0             movaps %xmm2,-0x30(%rdi)
    0.00 :	  122f5f:       0f 29 5f c0             movaps %xmm3,-0x40(%rdi)
    0.00 :	  122f63:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  122f6a:       0f 28 66 b0             movaps -0x50(%rsi),%xmm4
    0.00 :	  122f6e:       0f 28 6e a0             movaps -0x60(%rsi),%xmm5
    0.00 :	  122f72:       0f 28 76 90             movaps -0x70(%rsi),%xmm6
    0.00 :	  122f76:       0f 28 7e 80             movaps -0x80(%rsi),%xmm7
    0.00 :	  122f7a:       48 8d 76 80             lea    -0x80(%rsi),%rsi
    0.00 :	  122f7e:       0f 29 67 b0             movaps %xmm4,-0x50(%rdi)
    0.00 :	  122f82:       0f 29 6f a0             movaps %xmm5,-0x60(%rdi)
    0.00 :	  122f86:       0f 29 77 90             movaps %xmm6,-0x70(%rdi)
    0.00 :	  122f8a:       0f 29 7f 80             movaps %xmm7,-0x80(%rdi)
    0.00 :	  122f8e:       48 8d 7f 80             lea    -0x80(%rdi),%rdi
    0.00 :	  122f92:       73 ad                   jae    122f41 <__memmove_ssse3+0x391>
    0.00 :	  122f94:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  122f98:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  122f9f:       7c 34                   jl     122fd5 <__memmove_ssse3+0x425>
    0.00 :	  122fa1:       66 0f 6f 46 f0          movdqa -0x10(%rsi),%xmm0
    0.00 :	  122fa6:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  122faa:       66 0f 6f 4e e0          movdqa -0x20(%rsi),%xmm1
    0.00 :	  122faf:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	  122fb4:       66 0f 7f 4f e0          movdqa %xmm1,-0x20(%rdi)
    0.00 :	  122fb9:       66 0f 6f 46 d0          movdqa -0x30(%rsi),%xmm0
    0.00 :	  122fbe:       66 0f 6f 4e c0          movdqa -0x40(%rsi),%xmm1
    0.00 :	  122fc3:       48 83 ee 40             sub    $0x40,%rsi
    0.00 :	  122fc7:       66 0f 7f 47 d0          movdqa %xmm0,-0x30(%rdi)
    0.00 :	  122fcc:       66 0f 7f 4f c0          movdqa %xmm1,-0x40(%rdi)
    0.00 :	  122fd1:       48 83 ef 40             sub    $0x40,%rdi
    0.00 :	  122fd5:       4c 8d 1d c4 12 02 00    lea    0x212c4(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  122fdc:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  122fe0:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  122fe4:       ff e2                   jmpq   *%rdx
    0.00 :	  122fe6:       0f 0b                   ud2    
    0.00 :	  122fe8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  122fef:       00 
    0.00 :	  122ff0:       0f 18 8e 40 fe ff ff    prefetcht0 -0x1c0(%rsi)
    0.00 :	  122ff7:       0f 18 8e 80 fd ff ff    prefetcht0 -0x280(%rsi)
    0.00 :	  122ffe:       66 0f 6f 46 f0          movdqa -0x10(%rsi),%xmm0
    0.00 :	  123003:       66 0f 6f 4e e0          movdqa -0x20(%rsi),%xmm1
    0.00 :	  123008:       66 0f 6f 56 d0          movdqa -0x30(%rsi),%xmm2
    0.00 :	  12300d:       66 0f 6f 5e c0          movdqa -0x40(%rsi),%xmm3
    0.00 :	  123012:       66 0f 6f 66 b0          movdqa -0x50(%rsi),%xmm4
    0.00 :	  123017:       66 0f 6f 6e a0          movdqa -0x60(%rsi),%xmm5
    0.00 :	  12301c:       66 0f 6f 76 90          movdqa -0x70(%rsi),%xmm6
    0.00 :	  123021:       66 0f 6f 7e 80          movdqa -0x80(%rsi),%xmm7
    0.00 :	  123026:       48 8d 76 80             lea    -0x80(%rsi),%rsi
    0.00 :	  12302a:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  123031:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	  123036:       66 0f 7f 4f e0          movdqa %xmm1,-0x20(%rdi)
    0.00 :	  12303b:       66 0f 7f 57 d0          movdqa %xmm2,-0x30(%rdi)
    0.00 :	  123040:       66 0f 7f 5f c0          movdqa %xmm3,-0x40(%rdi)
    0.00 :	  123045:       66 0f 7f 67 b0          movdqa %xmm4,-0x50(%rdi)
    0.00 :	  12304a:       66 0f 7f 6f a0          movdqa %xmm5,-0x60(%rdi)
    0.00 :	  12304f:       66 0f 7f 77 90          movdqa %xmm6,-0x70(%rdi)
    0.00 :	  123054:       66 0f 7f 7f 80          movdqa %xmm7,-0x80(%rdi)
    0.00 :	  123059:       48 8d 7f 80             lea    -0x80(%rdi),%rdi
    0.00 :	  12305d:       73 91                   jae    122ff0 <__memmove_ssse3+0x440>
    0.00 :	  12305f:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  123063:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  12306a:       7c 34                   jl     1230a0 <__memmove_ssse3+0x4f0>
    0.00 :	  12306c:       66 0f 6f 46 f0          movdqa -0x10(%rsi),%xmm0
    0.00 :	  123071:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123075:       66 0f 6f 4e e0          movdqa -0x20(%rsi),%xmm1
    0.00 :	  12307a:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	  12307f:       66 0f 7f 4f e0          movdqa %xmm1,-0x20(%rdi)
    0.00 :	  123084:       66 0f 6f 46 d0          movdqa -0x30(%rsi),%xmm0
    0.00 :	  123089:       66 0f 6f 4e c0          movdqa -0x40(%rsi),%xmm1
    0.00 :	  12308e:       48 83 ee 40             sub    $0x40,%rsi
    0.00 :	  123092:       66 0f 7f 47 d0          movdqa %xmm0,-0x30(%rdi)
    0.00 :	  123097:       66 0f 7f 4f c0          movdqa %xmm1,-0x40(%rdi)
    0.00 :	  12309c:       48 83 ef 40             sub    $0x40,%rdi
    0.00 :	  1230a0:       48 83 fa 20             cmp    $0x20,%rdx
    0.00 :	  1230a4:       72 20                   jb     1230c6 <__memmove_ssse3+0x516>
    0.00 :	  1230a6:       66 0f 6f 46 f0          movdqa -0x10(%rsi),%xmm0
    0.00 :	  1230ab:       48 83 ea 20             sub    $0x20,%rdx
    0.00 :	  1230af:       66 0f 6f 4e e0          movdqa -0x20(%rsi),%xmm1
    0.00 :	  1230b4:       48 83 ee 20             sub    $0x20,%rsi
    0.00 :	  1230b8:       66 0f 7f 47 f0          movdqa %xmm0,-0x10(%rdi)
    0.00 :	  1230bd:       66 0f 7f 4f e0          movdqa %xmm1,-0x20(%rdi)
    0.00 :	  1230c2:       48 83 ef 20             sub    $0x20,%rdi
    0.00 :	  1230c6:       4c 8d 1d d3 11 02 00    lea    0x211d3(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1230cd:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1230d1:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1230d5:       ff e2                   jmpq   *%rdx
    0.00 :	  1230d7:       0f 0b                   ud2    
    0.00 :	  1230d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  1230e0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1230e7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1230ea:       0f 28 4e ff             movaps -0x1(%rsi),%xmm1
    0.00 :	  1230ee:       72 07                   jb     1230f7 <__memmove_ssse3+0x547>
    0.00 :	  1230f0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1230f7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1230fb:       41 ff e1                jmpq   *%r9
    0.00 :	  1230fe:       0f 0b                   ud2    
    0.00 :	  123100:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123107:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12310b:       0f 28 56 0f             movaps 0xf(%rsi),%xmm2
    0.00 :	  12310f:       0f 28 5e 1f             movaps 0x1f(%rsi),%xmm3
    0.00 :	  123113:       0f 28 66 2f             movaps 0x2f(%rsi),%xmm4
    0.00 :	  123117:       0f 28 6e 3f             movaps 0x3f(%rsi),%xmm5
    0.00 :	  12311b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12311f:       66 0f 3a 0f ec 01       palignr $0x1,%xmm4,%xmm5
    0.00 :	  123125:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123129:       66 0f 3a 0f e3 01       palignr $0x1,%xmm3,%xmm4
    0.00 :	  12312f:       66 0f 3a 0f da 01       palignr $0x1,%xmm2,%xmm3
    0.00 :	  123135:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123139:       66 0f 3a 0f d1 01       palignr $0x1,%xmm1,%xmm2
    0.00 :	  12313f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123143:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123148:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12314c:       72 0d                   jb     12315b <__memmove_ssse3+0x5ab>
    0.00 :	  12314e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123152:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123156:       41 ff e1                jmpq   *%r9
    0.00 :	  123159:       0f 0b                   ud2    
    0.00 :	  12315b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12315f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123163:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123167:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12316a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12316f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123172:       4c 8d 1d 27 11 02 00    lea    0x21127(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123179:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12317d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123181:       ff e2                   jmpq   *%rdx
    0.00 :	  123183:       0f 0b                   ud2    
    0.00 :	  123185:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12318c:       00 00 00 00 
    0.00 :	  123190:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123197:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12319a:       0f 28 4e ff             movaps -0x1(%rsi),%xmm1
    0.00 :	  12319e:       72 07                   jb     1231a7 <__memmove_ssse3+0x5f7>
    0.00 :	  1231a0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1231a7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1231ab:       41 ff e1                jmpq   *%r9
    0.00 :	  1231ae:       0f 0b                   ud2    
    0.00 :	  1231b0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  1231b7:       0f 28 56 ef             movaps -0x11(%rsi),%xmm2
    0.00 :	  1231bb:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1231bf:       0f 28 5e df             movaps -0x21(%rsi),%xmm3
    0.00 :	  1231c3:       0f 28 66 cf             movaps -0x31(%rsi),%xmm4
    0.00 :	  1231c7:       0f 28 6e bf             movaps -0x41(%rsi),%xmm5
    0.00 :	  1231cb:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  1231cf:       66 0f 3a 0f ca 01       palignr $0x1,%xmm2,%xmm1
    0.00 :	  1231d5:       66 0f 3a 0f d3 01       palignr $0x1,%xmm3,%xmm2
    0.00 :	  1231db:       66 0f 3a 0f dc 01       palignr $0x1,%xmm4,%xmm3
    0.00 :	  1231e1:       66 0f 3a 0f e5 01       palignr $0x1,%xmm5,%xmm4
    0.00 :	  1231e7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  1231eb:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  1231ee:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  1231f2:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  1231f6:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  1231fa:       72 08                   jb     123204 <__memmove_ssse3+0x654>
    0.00 :	  1231fc:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1231ff:       41 ff e1                jmpq   *%r9
    0.00 :	  123202:       0f 0b                   ud2    
    0.00 :	  123204:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123207:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12320b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123210:       4c 8d 1d 89 10 02 00    lea    0x21089(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123217:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12321b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12321f:       ff e2                   jmpq   *%rdx
    0.00 :	  123221:       0f 0b                   ud2    
    0.00 :	  123223:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12322a:       84 00 00 00 00 00 
    0.00 :	  123230:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123237:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12323a:       0f 28 4e fe             movaps -0x2(%rsi),%xmm1
    0.00 :	  12323e:       72 07                   jb     123247 <__memmove_ssse3+0x697>
    0.00 :	  123240:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123247:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12324b:       41 ff e1                jmpq   *%r9
    0.00 :	  12324e:       0f 0b                   ud2    
    0.00 :	  123250:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123257:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12325b:       0f 28 56 0e             movaps 0xe(%rsi),%xmm2
    0.00 :	  12325f:       0f 28 5e 1e             movaps 0x1e(%rsi),%xmm3
    0.00 :	  123263:       0f 28 66 2e             movaps 0x2e(%rsi),%xmm4
    0.00 :	  123267:       0f 28 6e 3e             movaps 0x3e(%rsi),%xmm5
    0.00 :	  12326b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12326f:       66 0f 3a 0f ec 02       palignr $0x2,%xmm4,%xmm5
    0.00 :	  123275:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123279:       66 0f 3a 0f e3 02       palignr $0x2,%xmm3,%xmm4
    0.00 :	  12327f:       66 0f 3a 0f da 02       palignr $0x2,%xmm2,%xmm3
    0.00 :	  123285:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123289:       66 0f 3a 0f d1 02       palignr $0x2,%xmm1,%xmm2
    0.00 :	  12328f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123293:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123298:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12329c:       72 0d                   jb     1232ab <__memmove_ssse3+0x6fb>
    0.00 :	  12329e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1232a2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1232a6:       41 ff e1                jmpq   *%r9
    0.00 :	  1232a9:       0f 0b                   ud2    
    0.00 :	  1232ab:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1232af:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1232b3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1232b7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  1232ba:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1232bf:       48 01 d6                add    %rdx,%rsi
    0.00 :	  1232c2:       4c 8d 1d d7 0f 02 00    lea    0x20fd7(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1232c9:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1232cd:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1232d1:       ff e2                   jmpq   *%rdx
    0.00 :	  1232d3:       0f 0b                   ud2    
    0.00 :	  1232d5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1232dc:       00 00 00 00 
    0.00 :	  1232e0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1232e7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1232ea:       0f 28 4e fe             movaps -0x2(%rsi),%xmm1
    0.00 :	  1232ee:       72 07                   jb     1232f7 <__memmove_ssse3+0x747>
    0.00 :	  1232f0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1232f7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1232fb:       41 ff e1                jmpq   *%r9
    0.00 :	  1232fe:       0f 0b                   ud2    
    0.00 :	  123300:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123307:       0f 28 56 ee             movaps -0x12(%rsi),%xmm2
    0.00 :	  12330b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12330f:       0f 28 5e de             movaps -0x22(%rsi),%xmm3
    0.00 :	  123313:       0f 28 66 ce             movaps -0x32(%rsi),%xmm4
    0.00 :	  123317:       0f 28 6e be             movaps -0x42(%rsi),%xmm5
    0.00 :	  12331b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12331f:       66 0f 3a 0f ca 02       palignr $0x2,%xmm2,%xmm1
    0.00 :	  123325:       66 0f 3a 0f d3 02       palignr $0x2,%xmm3,%xmm2
    0.00 :	  12332b:       66 0f 3a 0f dc 02       palignr $0x2,%xmm4,%xmm3
    0.00 :	  123331:       66 0f 3a 0f e5 02       palignr $0x2,%xmm5,%xmm4
    0.00 :	  123337:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12333b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12333e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123342:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123346:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12334a:       72 08                   jb     123354 <__memmove_ssse3+0x7a4>
    0.00 :	  12334c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12334f:       41 ff e1                jmpq   *%r9
    0.00 :	  123352:       0f 0b                   ud2    
    0.00 :	  123354:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123357:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12335b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123360:       4c 8d 1d 39 0f 02 00    lea    0x20f39(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123367:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12336b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12336f:       ff e2                   jmpq   *%rdx
    0.00 :	  123371:       0f 0b                   ud2    
    0.00 :	  123373:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12337a:       84 00 00 00 00 00 
    0.00 :	  123380:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123387:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12338a:       0f 28 4e fd             movaps -0x3(%rsi),%xmm1
    0.00 :	  12338e:       72 07                   jb     123397 <__memmove_ssse3+0x7e7>
    0.00 :	  123390:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123397:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12339b:       41 ff e1                jmpq   *%r9
    0.00 :	  12339e:       0f 0b                   ud2    
    0.00 :	  1233a0:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  1233a7:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1233ab:       0f 28 56 0d             movaps 0xd(%rsi),%xmm2
    0.00 :	  1233af:       0f 28 5e 1d             movaps 0x1d(%rsi),%xmm3
    0.00 :	  1233b3:       0f 28 66 2d             movaps 0x2d(%rsi),%xmm4
    0.00 :	  1233b7:       0f 28 6e 3d             movaps 0x3d(%rsi),%xmm5
    0.00 :	  1233bb:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  1233bf:       66 0f 3a 0f ec 03       palignr $0x3,%xmm4,%xmm5
    0.00 :	  1233c5:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  1233c9:       66 0f 3a 0f e3 03       palignr $0x3,%xmm3,%xmm4
    0.00 :	  1233cf:       66 0f 3a 0f da 03       palignr $0x3,%xmm2,%xmm3
    0.00 :	  1233d5:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  1233d9:       66 0f 3a 0f d1 03       palignr $0x3,%xmm1,%xmm2
    0.00 :	  1233df:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  1233e3:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  1233e8:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  1233ec:       72 0d                   jb     1233fb <__memmove_ssse3+0x84b>
    0.00 :	  1233ee:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1233f2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1233f6:       41 ff e1                jmpq   *%r9
    0.00 :	  1233f9:       0f 0b                   ud2    
    0.00 :	  1233fb:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1233ff:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123403:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123407:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12340a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12340f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123412:       4c 8d 1d 87 0e 02 00    lea    0x20e87(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123419:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12341d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123421:       ff e2                   jmpq   *%rdx
    0.00 :	  123423:       0f 0b                   ud2    
    0.00 :	  123425:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12342c:       00 00 00 00 
    0.00 :	  123430:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123437:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12343a:       0f 28 4e fd             movaps -0x3(%rsi),%xmm1
    0.00 :	  12343e:       72 07                   jb     123447 <__memmove_ssse3+0x897>
    0.00 :	  123440:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123447:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12344b:       41 ff e1                jmpq   *%r9
    0.00 :	  12344e:       0f 0b                   ud2    
    0.00 :	  123450:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123457:       0f 28 56 ed             movaps -0x13(%rsi),%xmm2
    0.00 :	  12345b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12345f:       0f 28 5e dd             movaps -0x23(%rsi),%xmm3
    0.00 :	  123463:       0f 28 66 cd             movaps -0x33(%rsi),%xmm4
    0.00 :	  123467:       0f 28 6e bd             movaps -0x43(%rsi),%xmm5
    0.00 :	  12346b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12346f:       66 0f 3a 0f ca 03       palignr $0x3,%xmm2,%xmm1
    0.00 :	  123475:       66 0f 3a 0f d3 03       palignr $0x3,%xmm3,%xmm2
    0.00 :	  12347b:       66 0f 3a 0f dc 03       palignr $0x3,%xmm4,%xmm3
    0.00 :	  123481:       66 0f 3a 0f e5 03       palignr $0x3,%xmm5,%xmm4
    0.00 :	  123487:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12348b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12348e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123492:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123496:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12349a:       72 08                   jb     1234a4 <__memmove_ssse3+0x8f4>
    0.00 :	  12349c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12349f:       41 ff e1                jmpq   *%r9
    0.00 :	  1234a2:       0f 0b                   ud2    
    0.00 :	  1234a4:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1234a7:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1234ab:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1234b0:       4c 8d 1d e9 0d 02 00    lea    0x20de9(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1234b7:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1234bb:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1234bf:       ff e2                   jmpq   *%rdx
    0.00 :	  1234c1:       0f 0b                   ud2    
    0.00 :	  1234c3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1234ca:       84 00 00 00 00 00 
    0.00 :	  1234d0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1234d7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1234da:       0f 28 4e fc             movaps -0x4(%rsi),%xmm1
    0.00 :	  1234de:       72 07                   jb     1234e7 <__memmove_ssse3+0x937>
    0.00 :	  1234e0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1234e7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1234eb:       41 ff e1                jmpq   *%r9
    0.00 :	  1234ee:       0f 0b                   ud2    
    0.00 :	  1234f0:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  1234f7:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1234fb:       0f 28 56 0c             movaps 0xc(%rsi),%xmm2
    0.00 :	  1234ff:       0f 28 5e 1c             movaps 0x1c(%rsi),%xmm3
    0.00 :	  123503:       0f 28 66 2c             movaps 0x2c(%rsi),%xmm4
    0.00 :	  123507:       0f 28 6e 3c             movaps 0x3c(%rsi),%xmm5
    0.00 :	  12350b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12350f:       66 0f 3a 0f ec 04       palignr $0x4,%xmm4,%xmm5
    0.00 :	  123515:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123519:       66 0f 3a 0f e3 04       palignr $0x4,%xmm3,%xmm4
    0.00 :	  12351f:       66 0f 3a 0f da 04       palignr $0x4,%xmm2,%xmm3
    0.00 :	  123525:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123529:       66 0f 3a 0f d1 04       palignr $0x4,%xmm1,%xmm2
    0.00 :	  12352f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123533:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123538:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12353c:       72 0d                   jb     12354b <__memmove_ssse3+0x99b>
    0.00 :	  12353e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123542:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123546:       41 ff e1                jmpq   *%r9
    0.00 :	  123549:       0f 0b                   ud2    
    0.00 :	  12354b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12354f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123553:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123557:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12355a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12355f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123562:       4c 8d 1d 37 0d 02 00    lea    0x20d37(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123569:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12356d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123571:       ff e2                   jmpq   *%rdx
    0.00 :	  123573:       0f 0b                   ud2    
    0.00 :	  123575:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12357c:       00 00 00 00 
    0.00 :	  123580:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123587:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12358a:       0f 28 4e fc             movaps -0x4(%rsi),%xmm1
    0.00 :	  12358e:       72 07                   jb     123597 <__memmove_ssse3+0x9e7>
    0.00 :	  123590:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123597:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12359b:       41 ff e1                jmpq   *%r9
    0.00 :	  12359e:       0f 0b                   ud2    
    0.00 :	  1235a0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  1235a7:       0f 28 56 ec             movaps -0x14(%rsi),%xmm2
    0.00 :	  1235ab:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1235af:       0f 28 5e dc             movaps -0x24(%rsi),%xmm3
    0.00 :	  1235b3:       0f 28 66 cc             movaps -0x34(%rsi),%xmm4
    0.00 :	  1235b7:       0f 28 6e bc             movaps -0x44(%rsi),%xmm5
    0.00 :	  1235bb:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  1235bf:       66 0f 3a 0f ca 04       palignr $0x4,%xmm2,%xmm1
    0.00 :	  1235c5:       66 0f 3a 0f d3 04       palignr $0x4,%xmm3,%xmm2
    0.00 :	  1235cb:       66 0f 3a 0f dc 04       palignr $0x4,%xmm4,%xmm3
    0.00 :	  1235d1:       66 0f 3a 0f e5 04       palignr $0x4,%xmm5,%xmm4
    0.00 :	  1235d7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  1235db:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  1235de:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  1235e2:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  1235e6:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  1235ea:       72 08                   jb     1235f4 <__memmove_ssse3+0xa44>
    0.00 :	  1235ec:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1235ef:       41 ff e1                jmpq   *%r9
    0.00 :	  1235f2:       0f 0b                   ud2    
    0.00 :	  1235f4:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1235f7:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1235fb:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123600:       4c 8d 1d 99 0c 02 00    lea    0x20c99(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123607:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12360b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12360f:       ff e2                   jmpq   *%rdx
    0.00 :	  123611:       0f 0b                   ud2    
    0.00 :	  123613:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12361a:       84 00 00 00 00 00 
    0.00 :	  123620:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123627:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12362a:       0f 28 4e fb             movaps -0x5(%rsi),%xmm1
    0.00 :	  12362e:       72 07                   jb     123637 <__memmove_ssse3+0xa87>
    0.00 :	  123630:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123637:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12363b:       41 ff e1                jmpq   *%r9
    0.00 :	  12363e:       0f 0b                   ud2    
    0.00 :	  123640:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123647:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12364b:       0f 28 56 0b             movaps 0xb(%rsi),%xmm2
    0.00 :	  12364f:       0f 28 5e 1b             movaps 0x1b(%rsi),%xmm3
    0.00 :	  123653:       0f 28 66 2b             movaps 0x2b(%rsi),%xmm4
    0.00 :	  123657:       0f 28 6e 3b             movaps 0x3b(%rsi),%xmm5
    0.00 :	  12365b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12365f:       66 0f 3a 0f ec 05       palignr $0x5,%xmm4,%xmm5
    0.00 :	  123665:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123669:       66 0f 3a 0f e3 05       palignr $0x5,%xmm3,%xmm4
    0.00 :	  12366f:       66 0f 3a 0f da 05       palignr $0x5,%xmm2,%xmm3
    0.00 :	  123675:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123679:       66 0f 3a 0f d1 05       palignr $0x5,%xmm1,%xmm2
    0.00 :	  12367f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123683:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123688:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12368c:       72 0d                   jb     12369b <__memmove_ssse3+0xaeb>
    0.00 :	  12368e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123692:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123696:       41 ff e1                jmpq   *%r9
    0.00 :	  123699:       0f 0b                   ud2    
    0.00 :	  12369b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12369f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1236a3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1236a7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  1236aa:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1236af:       48 01 d6                add    %rdx,%rsi
    0.00 :	  1236b2:       4c 8d 1d e7 0b 02 00    lea    0x20be7(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1236b9:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1236bd:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1236c1:       ff e2                   jmpq   *%rdx
    0.00 :	  1236c3:       0f 0b                   ud2    
    0.00 :	  1236c5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1236cc:       00 00 00 00 
    0.00 :	  1236d0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1236d7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1236da:       0f 28 4e fb             movaps -0x5(%rsi),%xmm1
    0.00 :	  1236de:       72 07                   jb     1236e7 <__memmove_ssse3+0xb37>
    0.00 :	  1236e0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1236e7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1236eb:       41 ff e1                jmpq   *%r9
    0.00 :	  1236ee:       0f 0b                   ud2    
    0.00 :	  1236f0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  1236f7:       0f 28 56 eb             movaps -0x15(%rsi),%xmm2
    0.00 :	  1236fb:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1236ff:       0f 28 5e db             movaps -0x25(%rsi),%xmm3
    0.00 :	  123703:       0f 28 66 cb             movaps -0x35(%rsi),%xmm4
    0.00 :	  123707:       0f 28 6e bb             movaps -0x45(%rsi),%xmm5
    0.00 :	  12370b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12370f:       66 0f 3a 0f ca 05       palignr $0x5,%xmm2,%xmm1
    0.00 :	  123715:       66 0f 3a 0f d3 05       palignr $0x5,%xmm3,%xmm2
    0.00 :	  12371b:       66 0f 3a 0f dc 05       palignr $0x5,%xmm4,%xmm3
    0.00 :	  123721:       66 0f 3a 0f e5 05       palignr $0x5,%xmm5,%xmm4
    0.00 :	  123727:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12372b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12372e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123732:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123736:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12373a:       72 08                   jb     123744 <__memmove_ssse3+0xb94>
    0.00 :	  12373c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12373f:       41 ff e1                jmpq   *%r9
    0.00 :	  123742:       0f 0b                   ud2    
    0.00 :	  123744:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123747:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12374b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123750:       4c 8d 1d 49 0b 02 00    lea    0x20b49(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123757:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12375b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12375f:       ff e2                   jmpq   *%rdx
    0.00 :	  123761:       0f 0b                   ud2    
    0.00 :	  123763:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12376a:       84 00 00 00 00 00 
    0.00 :	  123770:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123777:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12377a:       0f 28 4e fa             movaps -0x6(%rsi),%xmm1
    0.00 :	  12377e:       72 07                   jb     123787 <__memmove_ssse3+0xbd7>
    0.00 :	  123780:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123787:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12378b:       41 ff e1                jmpq   *%r9
    0.00 :	  12378e:       0f 0b                   ud2    
    0.00 :	  123790:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123797:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12379b:       0f 28 56 0a             movaps 0xa(%rsi),%xmm2
    0.00 :	  12379f:       0f 28 5e 1a             movaps 0x1a(%rsi),%xmm3
    0.00 :	  1237a3:       0f 28 66 2a             movaps 0x2a(%rsi),%xmm4
    0.00 :	  1237a7:       0f 28 6e 3a             movaps 0x3a(%rsi),%xmm5
    0.00 :	  1237ab:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  1237af:       66 0f 3a 0f ec 06       palignr $0x6,%xmm4,%xmm5
    0.00 :	  1237b5:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  1237b9:       66 0f 3a 0f e3 06       palignr $0x6,%xmm3,%xmm4
    0.00 :	  1237bf:       66 0f 3a 0f da 06       palignr $0x6,%xmm2,%xmm3
    0.00 :	  1237c5:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  1237c9:       66 0f 3a 0f d1 06       palignr $0x6,%xmm1,%xmm2
    0.00 :	  1237cf:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  1237d3:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  1237d8:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  1237dc:       72 0d                   jb     1237eb <__memmove_ssse3+0xc3b>
    0.00 :	  1237de:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1237e2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1237e6:       41 ff e1                jmpq   *%r9
    0.00 :	  1237e9:       0f 0b                   ud2    
    0.00 :	  1237eb:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1237ef:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1237f3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1237f7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  1237fa:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1237ff:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123802:       4c 8d 1d 97 0a 02 00    lea    0x20a97(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123809:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12380d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123811:       ff e2                   jmpq   *%rdx
    0.00 :	  123813:       0f 0b                   ud2    
    0.00 :	  123815:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12381c:       00 00 00 00 
    0.00 :	  123820:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123827:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12382a:       0f 28 4e fa             movaps -0x6(%rsi),%xmm1
    0.00 :	  12382e:       72 07                   jb     123837 <__memmove_ssse3+0xc87>
    0.00 :	  123830:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123837:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12383b:       41 ff e1                jmpq   *%r9
    0.00 :	  12383e:       0f 0b                   ud2    
    0.00 :	  123840:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123847:       0f 28 56 ea             movaps -0x16(%rsi),%xmm2
    0.00 :	  12384b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12384f:       0f 28 5e da             movaps -0x26(%rsi),%xmm3
    0.00 :	  123853:       0f 28 66 ca             movaps -0x36(%rsi),%xmm4
    0.00 :	  123857:       0f 28 6e ba             movaps -0x46(%rsi),%xmm5
    0.00 :	  12385b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12385f:       66 0f 3a 0f ca 06       palignr $0x6,%xmm2,%xmm1
    0.00 :	  123865:       66 0f 3a 0f d3 06       palignr $0x6,%xmm3,%xmm2
    0.00 :	  12386b:       66 0f 3a 0f dc 06       palignr $0x6,%xmm4,%xmm3
    0.00 :	  123871:       66 0f 3a 0f e5 06       palignr $0x6,%xmm5,%xmm4
    0.00 :	  123877:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12387b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12387e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123882:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123886:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12388a:       72 08                   jb     123894 <__memmove_ssse3+0xce4>
    0.00 :	  12388c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12388f:       41 ff e1                jmpq   *%r9
    0.00 :	  123892:       0f 0b                   ud2    
    0.00 :	  123894:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123897:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12389b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1238a0:       4c 8d 1d f9 09 02 00    lea    0x209f9(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1238a7:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1238ab:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1238af:       ff e2                   jmpq   *%rdx
    0.00 :	  1238b1:       0f 0b                   ud2    
    0.00 :	  1238b3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1238ba:       84 00 00 00 00 00 
    0.00 :	  1238c0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1238c7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1238ca:       0f 28 4e f9             movaps -0x7(%rsi),%xmm1
    0.00 :	  1238ce:       72 07                   jb     1238d7 <__memmove_ssse3+0xd27>
    0.00 :	  1238d0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1238d7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1238db:       41 ff e1                jmpq   *%r9
    0.00 :	  1238de:       0f 0b                   ud2    
    0.00 :	  1238e0:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  1238e7:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1238eb:       0f 28 56 09             movaps 0x9(%rsi),%xmm2
    0.00 :	  1238ef:       0f 28 5e 19             movaps 0x19(%rsi),%xmm3
    0.00 :	  1238f3:       0f 28 66 29             movaps 0x29(%rsi),%xmm4
    0.00 :	  1238f7:       0f 28 6e 39             movaps 0x39(%rsi),%xmm5
    0.00 :	  1238fb:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  1238ff:       66 0f 3a 0f ec 07       palignr $0x7,%xmm4,%xmm5
    0.00 :	  123905:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123909:       66 0f 3a 0f e3 07       palignr $0x7,%xmm3,%xmm4
    0.00 :	  12390f:       66 0f 3a 0f da 07       palignr $0x7,%xmm2,%xmm3
    0.00 :	  123915:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123919:       66 0f 3a 0f d1 07       palignr $0x7,%xmm1,%xmm2
    0.00 :	  12391f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123923:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123928:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12392c:       72 0d                   jb     12393b <__memmove_ssse3+0xd8b>
    0.00 :	  12392e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123932:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123936:       41 ff e1                jmpq   *%r9
    0.00 :	  123939:       0f 0b                   ud2    
    0.00 :	  12393b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12393f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123943:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123947:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12394a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12394f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123952:       4c 8d 1d 47 09 02 00    lea    0x20947(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123959:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12395d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123961:       ff e2                   jmpq   *%rdx
    0.00 :	  123963:       0f 0b                   ud2    
    0.00 :	  123965:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12396c:       00 00 00 00 
    0.00 :	  123970:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123977:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12397a:       0f 28 4e f9             movaps -0x7(%rsi),%xmm1
    0.00 :	  12397e:       72 07                   jb     123987 <__memmove_ssse3+0xdd7>
    0.00 :	  123980:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123987:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12398b:       41 ff e1                jmpq   *%r9
    0.00 :	  12398e:       0f 0b                   ud2    
    0.00 :	  123990:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123997:       0f 28 56 e9             movaps -0x17(%rsi),%xmm2
    0.00 :	  12399b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12399f:       0f 28 5e d9             movaps -0x27(%rsi),%xmm3
    0.00 :	  1239a3:       0f 28 66 c9             movaps -0x37(%rsi),%xmm4
    0.00 :	  1239a7:       0f 28 6e b9             movaps -0x47(%rsi),%xmm5
    0.00 :	  1239ab:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  1239af:       66 0f 3a 0f ca 07       palignr $0x7,%xmm2,%xmm1
    0.00 :	  1239b5:       66 0f 3a 0f d3 07       palignr $0x7,%xmm3,%xmm2
    0.00 :	  1239bb:       66 0f 3a 0f dc 07       palignr $0x7,%xmm4,%xmm3
    0.00 :	  1239c1:       66 0f 3a 0f e5 07       palignr $0x7,%xmm5,%xmm4
    0.00 :	  1239c7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  1239cb:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  1239ce:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  1239d2:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  1239d6:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  1239da:       72 08                   jb     1239e4 <__memmove_ssse3+0xe34>
    0.00 :	  1239dc:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1239df:       41 ff e1                jmpq   *%r9
    0.00 :	  1239e2:       0f 0b                   ud2    
    0.00 :	  1239e4:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1239e7:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1239eb:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1239f0:       4c 8d 1d a9 08 02 00    lea    0x208a9(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1239f7:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1239fb:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1239ff:       ff e2                   jmpq   *%rdx
    0.00 :	  123a01:       0f 0b                   ud2    
    0.00 :	  123a03:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123a0a:       84 00 00 00 00 00 
    0.00 :	  123a10:       4d 8d 89 25 00 00 00    lea    0x25(%r9),%r9
    0.00 :	  123a17:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123a1a:       0f 28 4e f8             movaps -0x8(%rsi),%xmm1
    0.00 :	  123a1e:       72 07                   jb     123a27 <__memmove_ssse3+0xe77>
    0.00 :	  123a20:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123a27:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123a2b:       41 ff e1                jmpq   *%r9
    0.00 :	  123a2e:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123a35:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123a39:       0f 28 56 08             movaps 0x8(%rsi),%xmm2
    0.00 :	  123a3d:       0f 28 5e 18             movaps 0x18(%rsi),%xmm3
    0.00 :	  123a41:       0f 28 66 28             movaps 0x28(%rsi),%xmm4
    0.00 :	  123a45:       0f 28 6e 38             movaps 0x38(%rsi),%xmm5
    0.00 :	  123a49:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  123a4d:       66 0f 3a 0f ec 08       palignr $0x8,%xmm4,%xmm5
    0.00 :	  123a53:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123a57:       66 0f 3a 0f e3 08       palignr $0x8,%xmm3,%xmm4
    0.00 :	  123a5d:       66 0f 3a 0f da 08       palignr $0x8,%xmm2,%xmm3
    0.00 :	  123a63:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123a67:       66 0f 3a 0f d1 08       palignr $0x8,%xmm1,%xmm2
    0.00 :	  123a6d:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123a71:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123a76:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  123a7a:       72 14                   jb     123a90 <__memmove_ssse3+0xee0>
    0.00 :	  123a7c:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123a80:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123a84:       41 ff e1                jmpq   *%r9
    0.00 :	  123a87:       0f 0b                   ud2    
    0.00 :	  123a89:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  123a90:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123a94:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123a98:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123a9b:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123a9f:       48 01 d7                add    %rdx,%rdi
    0.00 :	  123aa2:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123aa7:       4c 8d 1d f2 07 02 00    lea    0x207f2(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123aae:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123ab2:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123ab6:       ff e2                   jmpq   *%rdx
    0.00 :	  123ab8:       0f 0b                   ud2    
    0.00 :	  123aba:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  123ac0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123ac7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123aca:       0f 28 4e f8             movaps -0x8(%rsi),%xmm1
    0.00 :	  123ace:       72 07                   jb     123ad7 <__memmove_ssse3+0xf27>
    0.00 :	  123ad0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123ad7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123adb:       41 ff e1                jmpq   *%r9
    0.00 :	  123ade:       0f 0b                   ud2    
    0.00 :	  123ae0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123ae7:       0f 28 56 e8             movaps -0x18(%rsi),%xmm2
    0.00 :	  123aeb:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123aef:       0f 28 5e d8             movaps -0x28(%rsi),%xmm3
    0.00 :	  123af3:       0f 28 66 c8             movaps -0x38(%rsi),%xmm4
    0.00 :	  123af7:       0f 28 6e b8             movaps -0x48(%rsi),%xmm5
    0.00 :	  123afb:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  123aff:       66 0f 3a 0f ca 08       palignr $0x8,%xmm2,%xmm1
    0.00 :	  123b05:       66 0f 3a 0f d3 08       palignr $0x8,%xmm3,%xmm2
    0.00 :	  123b0b:       66 0f 3a 0f dc 08       palignr $0x8,%xmm4,%xmm3
    0.00 :	  123b11:       66 0f 3a 0f e5 08       palignr $0x8,%xmm5,%xmm4
    0.00 :	  123b17:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  123b1b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  123b1e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123b22:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123b26:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  123b2a:       72 08                   jb     123b34 <__memmove_ssse3+0xf84>
    0.00 :	  123b2c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123b2f:       41 ff e1                jmpq   *%r9
    0.00 :	  123b32:       0f 0b                   ud2    
    0.00 :	  123b34:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123b37:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123b3b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123b40:       4c 8d 1d 59 07 02 00    lea    0x20759(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123b47:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123b4b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123b4f:       ff e2                   jmpq   *%rdx
    0.00 :	  123b51:       0f 0b                   ud2    
    0.00 :	  123b53:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123b5a:       84 00 00 00 00 00 
    0.00 :	  123b60:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123b67:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123b6a:       0f 28 4e f7             movaps -0x9(%rsi),%xmm1
    0.00 :	  123b6e:       72 07                   jb     123b77 <__memmove_ssse3+0xfc7>
    0.00 :	  123b70:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123b77:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123b7b:       41 ff e1                jmpq   *%r9
    0.00 :	  123b7e:       0f 0b                   ud2    
    0.00 :	  123b80:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123b87:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123b8b:       0f 28 56 07             movaps 0x7(%rsi),%xmm2
    0.00 :	  123b8f:       0f 28 5e 17             movaps 0x17(%rsi),%xmm3
    0.00 :	  123b93:       0f 28 66 27             movaps 0x27(%rsi),%xmm4
    0.00 :	  123b97:       0f 28 6e 37             movaps 0x37(%rsi),%xmm5
    0.00 :	  123b9b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  123b9f:       66 0f 3a 0f ec 09       palignr $0x9,%xmm4,%xmm5
    0.00 :	  123ba5:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123ba9:       66 0f 3a 0f e3 09       palignr $0x9,%xmm3,%xmm4
    0.00 :	  123baf:       66 0f 3a 0f da 09       palignr $0x9,%xmm2,%xmm3
    0.00 :	  123bb5:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123bb9:       66 0f 3a 0f d1 09       palignr $0x9,%xmm1,%xmm2
    0.00 :	  123bbf:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123bc3:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123bc8:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  123bcc:       72 0d                   jb     123bdb <__memmove_ssse3+0x102b>
    0.00 :	  123bce:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123bd2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123bd6:       41 ff e1                jmpq   *%r9
    0.00 :	  123bd9:       0f 0b                   ud2    
    0.00 :	  123bdb:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123bdf:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123be3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123be7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  123bea:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123bef:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123bf2:       4c 8d 1d a7 06 02 00    lea    0x206a7(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123bf9:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123bfd:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123c01:       ff e2                   jmpq   *%rdx
    0.00 :	  123c03:       0f 0b                   ud2    
    0.00 :	  123c05:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123c0c:       00 00 00 00 
    0.00 :	  123c10:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123c17:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123c1a:       0f 28 4e f7             movaps -0x9(%rsi),%xmm1
    0.00 :	  123c1e:       72 07                   jb     123c27 <__memmove_ssse3+0x1077>
    0.00 :	  123c20:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123c27:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123c2b:       41 ff e1                jmpq   *%r9
    0.00 :	  123c2e:       0f 0b                   ud2    
    0.00 :	  123c30:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123c37:       0f 28 56 e7             movaps -0x19(%rsi),%xmm2
    0.00 :	  123c3b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123c3f:       0f 28 5e d7             movaps -0x29(%rsi),%xmm3
    0.00 :	  123c43:       0f 28 66 c7             movaps -0x39(%rsi),%xmm4
    0.00 :	  123c47:       0f 28 6e b7             movaps -0x49(%rsi),%xmm5
    0.00 :	  123c4b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  123c4f:       66 0f 3a 0f ca 09       palignr $0x9,%xmm2,%xmm1
    0.00 :	  123c55:       66 0f 3a 0f d3 09       palignr $0x9,%xmm3,%xmm2
    0.00 :	  123c5b:       66 0f 3a 0f dc 09       palignr $0x9,%xmm4,%xmm3
    0.00 :	  123c61:       66 0f 3a 0f e5 09       palignr $0x9,%xmm5,%xmm4
    0.00 :	  123c67:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  123c6b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  123c6e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123c72:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123c76:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  123c7a:       72 08                   jb     123c84 <__memmove_ssse3+0x10d4>
    0.00 :	  123c7c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123c7f:       41 ff e1                jmpq   *%r9
    0.00 :	  123c82:       0f 0b                   ud2    
    0.00 :	  123c84:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123c87:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123c8b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123c90:       4c 8d 1d 09 06 02 00    lea    0x20609(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123c97:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123c9b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123c9f:       ff e2                   jmpq   *%rdx
    0.00 :	  123ca1:       0f 0b                   ud2    
    0.00 :	  123ca3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123caa:       84 00 00 00 00 00 
    0.00 :	  123cb0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123cb7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123cba:       0f 28 4e f6             movaps -0xa(%rsi),%xmm1
    0.00 :	  123cbe:       72 07                   jb     123cc7 <__memmove_ssse3+0x1117>
    0.00 :	  123cc0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123cc7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123ccb:       41 ff e1                jmpq   *%r9
    0.00 :	  123cce:       0f 0b                   ud2    
    0.00 :	  123cd0:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123cd7:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123cdb:       0f 28 56 06             movaps 0x6(%rsi),%xmm2
    0.00 :	  123cdf:       0f 28 5e 16             movaps 0x16(%rsi),%xmm3
    0.00 :	  123ce3:       0f 28 66 26             movaps 0x26(%rsi),%xmm4
    0.00 :	  123ce7:       0f 28 6e 36             movaps 0x36(%rsi),%xmm5
    0.00 :	  123ceb:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  123cef:       66 0f 3a 0f ec 0a       palignr $0xa,%xmm4,%xmm5
    0.00 :	  123cf5:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123cf9:       66 0f 3a 0f e3 0a       palignr $0xa,%xmm3,%xmm4
    0.00 :	  123cff:       66 0f 3a 0f da 0a       palignr $0xa,%xmm2,%xmm3
    0.00 :	  123d05:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123d09:       66 0f 3a 0f d1 0a       palignr $0xa,%xmm1,%xmm2
    0.00 :	  123d0f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123d13:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123d18:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  123d1c:       72 0d                   jb     123d2b <__memmove_ssse3+0x117b>
    0.00 :	  123d1e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123d22:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123d26:       41 ff e1                jmpq   *%r9
    0.00 :	  123d29:       0f 0b                   ud2    
    0.00 :	  123d2b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123d2f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123d33:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123d37:       48 01 d7                add    %rdx,%rdi
    0.00 :	  123d3a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123d3f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123d42:       4c 8d 1d 57 05 02 00    lea    0x20557(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123d49:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123d4d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123d51:       ff e2                   jmpq   *%rdx
    0.00 :	  123d53:       0f 0b                   ud2    
    0.00 :	  123d55:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123d5c:       00 00 00 00 
    0.00 :	  123d60:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123d67:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123d6a:       0f 28 4e f6             movaps -0xa(%rsi),%xmm1
    0.00 :	  123d6e:       72 07                   jb     123d77 <__memmove_ssse3+0x11c7>
    0.00 :	  123d70:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123d77:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123d7b:       41 ff e1                jmpq   *%r9
    0.00 :	  123d7e:       0f 0b                   ud2    
    0.00 :	  123d80:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123d87:       0f 28 56 e6             movaps -0x1a(%rsi),%xmm2
    0.00 :	  123d8b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123d8f:       0f 28 5e d6             movaps -0x2a(%rsi),%xmm3
    0.00 :	  123d93:       0f 28 66 c6             movaps -0x3a(%rsi),%xmm4
    0.00 :	  123d97:       0f 28 6e b6             movaps -0x4a(%rsi),%xmm5
    0.00 :	  123d9b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  123d9f:       66 0f 3a 0f ca 0a       palignr $0xa,%xmm2,%xmm1
    0.00 :	  123da5:       66 0f 3a 0f d3 0a       palignr $0xa,%xmm3,%xmm2
    0.00 :	  123dab:       66 0f 3a 0f dc 0a       palignr $0xa,%xmm4,%xmm3
    0.00 :	  123db1:       66 0f 3a 0f e5 0a       palignr $0xa,%xmm5,%xmm4
    0.00 :	  123db7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  123dbb:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  123dbe:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123dc2:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123dc6:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  123dca:       72 08                   jb     123dd4 <__memmove_ssse3+0x1224>
    0.00 :	  123dcc:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123dcf:       41 ff e1                jmpq   *%r9
    0.00 :	  123dd2:       0f 0b                   ud2    
    0.00 :	  123dd4:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123dd7:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123ddb:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123de0:       4c 8d 1d b9 04 02 00    lea    0x204b9(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123de7:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123deb:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123def:       ff e2                   jmpq   *%rdx
    0.00 :	  123df1:       0f 0b                   ud2    
    0.00 :	  123df3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123dfa:       84 00 00 00 00 00 
    0.00 :	  123e00:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123e07:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123e0a:       0f 28 4e f5             movaps -0xb(%rsi),%xmm1
    0.00 :	  123e0e:       72 07                   jb     123e17 <__memmove_ssse3+0x1267>
    0.00 :	  123e10:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123e17:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123e1b:       41 ff e1                jmpq   *%r9
    0.00 :	  123e1e:       0f 0b                   ud2    
    0.00 :	  123e20:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123e27:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123e2b:       0f 28 56 05             movaps 0x5(%rsi),%xmm2
    0.00 :	  123e2f:       0f 28 5e 15             movaps 0x15(%rsi),%xmm3
    0.00 :	  123e33:       0f 28 66 25             movaps 0x25(%rsi),%xmm4
    0.00 :	  123e37:       0f 28 6e 35             movaps 0x35(%rsi),%xmm5
    0.00 :	  123e3b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  123e3f:       66 0f 3a 0f ec 0b       palignr $0xb,%xmm4,%xmm5
    0.00 :	  123e45:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123e49:       66 0f 3a 0f e3 0b       palignr $0xb,%xmm3,%xmm4
    0.00 :	  123e4f:       66 0f 3a 0f da 0b       palignr $0xb,%xmm2,%xmm3
    0.00 :	  123e55:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123e59:       66 0f 3a 0f d1 0b       palignr $0xb,%xmm1,%xmm2
    0.00 :	  123e5f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123e63:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123e68:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  123e6c:       72 0d                   jb     123e7b <__memmove_ssse3+0x12cb>
    0.00 :	  123e6e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123e72:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123e76:       41 ff e1                jmpq   *%r9
    0.00 :	  123e79:       0f 0b                   ud2    
    0.00 :	  123e7b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123e7f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123e83:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123e87:       48 01 d7                add    %rdx,%rdi
    0.00 :	  123e8a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123e8f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123e92:       4c 8d 1d 07 04 02 00    lea    0x20407(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123e99:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123e9d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123ea1:       ff e2                   jmpq   *%rdx
    0.00 :	  123ea3:       0f 0b                   ud2    
    0.00 :	  123ea5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123eac:       00 00 00 00 
    0.00 :	  123eb0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123eb7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123eba:       0f 28 4e f5             movaps -0xb(%rsi),%xmm1
    0.00 :	  123ebe:       72 07                   jb     123ec7 <__memmove_ssse3+0x1317>
    0.00 :	  123ec0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123ec7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123ecb:       41 ff e1                jmpq   *%r9
    0.00 :	  123ece:       0f 0b                   ud2    
    0.00 :	  123ed0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  123ed7:       0f 28 56 e5             movaps -0x1b(%rsi),%xmm2
    0.00 :	  123edb:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123edf:       0f 28 5e d5             movaps -0x2b(%rsi),%xmm3
    0.00 :	  123ee3:       0f 28 66 c5             movaps -0x3b(%rsi),%xmm4
    0.00 :	  123ee7:       0f 28 6e b5             movaps -0x4b(%rsi),%xmm5
    0.00 :	  123eeb:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  123eef:       66 0f 3a 0f ca 0b       palignr $0xb,%xmm2,%xmm1
    0.00 :	  123ef5:       66 0f 3a 0f d3 0b       palignr $0xb,%xmm3,%xmm2
    0.00 :	  123efb:       66 0f 3a 0f dc 0b       palignr $0xb,%xmm4,%xmm3
    0.00 :	  123f01:       66 0f 3a 0f e5 0b       palignr $0xb,%xmm5,%xmm4
    0.00 :	  123f07:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  123f0b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  123f0e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  123f12:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  123f16:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  123f1a:       72 08                   jb     123f24 <__memmove_ssse3+0x1374>
    0.00 :	  123f1c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123f1f:       41 ff e1                jmpq   *%r9
    0.00 :	  123f22:       0f 0b                   ud2    
    0.00 :	  123f24:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  123f27:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123f2b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123f30:       4c 8d 1d 69 03 02 00    lea    0x20369(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123f37:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123f3b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123f3f:       ff e2                   jmpq   *%rdx
    0.00 :	  123f41:       0f 0b                   ud2    
    0.00 :	  123f43:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123f4a:       84 00 00 00 00 00 
    0.00 :	  123f50:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  123f57:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  123f5a:       0f 28 4e f4             movaps -0xc(%rsi),%xmm1
    0.00 :	  123f5e:       72 07                   jb     123f67 <__memmove_ssse3+0x13b7>
    0.00 :	  123f60:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  123f67:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  123f6b:       41 ff e1                jmpq   *%r9
    0.00 :	  123f6e:       0f 0b                   ud2    
    0.00 :	  123f70:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  123f77:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  123f7b:       0f 28 56 04             movaps 0x4(%rsi),%xmm2
    0.00 :	  123f7f:       0f 28 5e 14             movaps 0x14(%rsi),%xmm3
    0.00 :	  123f83:       0f 28 66 24             movaps 0x24(%rsi),%xmm4
    0.00 :	  123f87:       0f 28 6e 34             movaps 0x34(%rsi),%xmm5
    0.00 :	  123f8b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  123f8f:       66 0f 3a 0f ec 0c       palignr $0xc,%xmm4,%xmm5
    0.00 :	  123f95:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  123f99:       66 0f 3a 0f e3 0c       palignr $0xc,%xmm3,%xmm4
    0.00 :	  123f9f:       66 0f 3a 0f da 0c       palignr $0xc,%xmm2,%xmm3
    0.00 :	  123fa5:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  123fa9:       66 0f 3a 0f d1 0c       palignr $0xc,%xmm1,%xmm2
    0.00 :	  123faf:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  123fb3:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  123fb8:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  123fbc:       72 0d                   jb     123fcb <__memmove_ssse3+0x141b>
    0.00 :	  123fbe:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123fc2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123fc6:       41 ff e1                jmpq   *%r9
    0.00 :	  123fc9:       0f 0b                   ud2    
    0.00 :	  123fcb:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  123fcf:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  123fd3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  123fd7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  123fda:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  123fdf:       48 01 d6                add    %rdx,%rsi
    0.00 :	  123fe2:       4c 8d 1d b7 02 02 00    lea    0x202b7(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  123fe9:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  123fed:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  123ff1:       ff e2                   jmpq   *%rdx
    0.00 :	  123ff3:       0f 0b                   ud2    
    0.00 :	  123ff5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  123ffc:       00 00 00 00 
    0.00 :	  124000:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  124007:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12400a:       0f 28 4e f4             movaps -0xc(%rsi),%xmm1
    0.00 :	  12400e:       72 07                   jb     124017 <__memmove_ssse3+0x1467>
    0.00 :	  124010:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  124017:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12401b:       41 ff e1                jmpq   *%r9
    0.00 :	  12401e:       0f 0b                   ud2    
    0.00 :	  124020:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  124027:       0f 28 56 e4             movaps -0x1c(%rsi),%xmm2
    0.00 :	  12402b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12402f:       0f 28 5e d4             movaps -0x2c(%rsi),%xmm3
    0.00 :	  124033:       0f 28 66 c4             movaps -0x3c(%rsi),%xmm4
    0.00 :	  124037:       0f 28 6e b4             movaps -0x4c(%rsi),%xmm5
    0.00 :	  12403b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12403f:       66 0f 3a 0f ca 0c       palignr $0xc,%xmm2,%xmm1
    0.00 :	  124045:       66 0f 3a 0f d3 0c       palignr $0xc,%xmm3,%xmm2
    0.00 :	  12404b:       66 0f 3a 0f dc 0c       palignr $0xc,%xmm4,%xmm3
    0.00 :	  124051:       66 0f 3a 0f e5 0c       palignr $0xc,%xmm5,%xmm4
    0.00 :	  124057:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12405b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12405e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  124062:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  124066:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12406a:       72 08                   jb     124074 <__memmove_ssse3+0x14c4>
    0.00 :	  12406c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12406f:       41 ff e1                jmpq   *%r9
    0.00 :	  124072:       0f 0b                   ud2    
    0.00 :	  124074:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  124077:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12407b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  124080:       4c 8d 1d 19 02 02 00    lea    0x20219(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  124087:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12408b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12408f:       ff e2                   jmpq   *%rdx
    0.00 :	  124091:       0f 0b                   ud2    
    0.00 :	  124093:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12409a:       84 00 00 00 00 00 
    0.00 :	  1240a0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1240a7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1240aa:       0f 28 4e f3             movaps -0xd(%rsi),%xmm1
    0.00 :	  1240ae:       72 07                   jb     1240b7 <__memmove_ssse3+0x1507>
    0.00 :	  1240b0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1240b7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1240bb:       41 ff e1                jmpq   *%r9
    0.00 :	  1240be:       0f 0b                   ud2    
    0.00 :	  1240c0:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  1240c7:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1240cb:       0f 28 56 03             movaps 0x3(%rsi),%xmm2
    0.00 :	  1240cf:       0f 28 5e 13             movaps 0x13(%rsi),%xmm3
    0.00 :	  1240d3:       0f 28 66 23             movaps 0x23(%rsi),%xmm4
    0.00 :	  1240d7:       0f 28 6e 33             movaps 0x33(%rsi),%xmm5
    0.00 :	  1240db:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  1240df:       66 0f 3a 0f ec 0d       palignr $0xd,%xmm4,%xmm5
    0.00 :	  1240e5:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  1240e9:       66 0f 3a 0f e3 0d       palignr $0xd,%xmm3,%xmm4
    0.00 :	  1240ef:       66 0f 3a 0f da 0d       palignr $0xd,%xmm2,%xmm3
    0.00 :	  1240f5:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  1240f9:       66 0f 3a 0f d1 0d       palignr $0xd,%xmm1,%xmm2
    0.00 :	  1240ff:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  124103:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  124108:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12410c:       72 0d                   jb     12411b <__memmove_ssse3+0x156b>
    0.00 :	  12410e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  124112:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  124116:       41 ff e1                jmpq   *%r9
    0.00 :	  124119:       0f 0b                   ud2    
    0.00 :	  12411b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12411f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  124123:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  124127:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12412a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12412f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  124132:       4c 8d 1d 67 01 02 00    lea    0x20167(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  124139:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12413d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  124141:       ff e2                   jmpq   *%rdx
    0.00 :	  124143:       0f 0b                   ud2    
    0.00 :	  124145:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12414c:       00 00 00 00 
    0.00 :	  124150:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  124157:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12415a:       0f 28 4e f3             movaps -0xd(%rsi),%xmm1
    0.00 :	  12415e:       72 07                   jb     124167 <__memmove_ssse3+0x15b7>
    0.00 :	  124160:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  124167:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12416b:       41 ff e1                jmpq   *%r9
    0.00 :	  12416e:       0f 0b                   ud2    
    0.00 :	  124170:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  124177:       0f 28 56 e3             movaps -0x1d(%rsi),%xmm2
    0.00 :	  12417b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12417f:       0f 28 5e d3             movaps -0x2d(%rsi),%xmm3
    0.00 :	  124183:       0f 28 66 c3             movaps -0x3d(%rsi),%xmm4
    0.00 :	  124187:       0f 28 6e b3             movaps -0x4d(%rsi),%xmm5
    0.00 :	  12418b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12418f:       66 0f 3a 0f ca 0d       palignr $0xd,%xmm2,%xmm1
    0.00 :	  124195:       66 0f 3a 0f d3 0d       palignr $0xd,%xmm3,%xmm2
    0.00 :	  12419b:       66 0f 3a 0f dc 0d       palignr $0xd,%xmm4,%xmm3
    0.00 :	  1241a1:       66 0f 3a 0f e5 0d       palignr $0xd,%xmm5,%xmm4
    0.00 :	  1241a7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  1241ab:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  1241ae:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  1241b2:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  1241b6:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  1241ba:       72 08                   jb     1241c4 <__memmove_ssse3+0x1614>
    0.00 :	  1241bc:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1241bf:       41 ff e1                jmpq   *%r9
    0.00 :	  1241c2:       0f 0b                   ud2    
    0.00 :	  1241c4:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  1241c7:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1241cb:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1241d0:       4c 8d 1d c9 00 02 00    lea    0x200c9(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1241d7:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1241db:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1241df:       ff e2                   jmpq   *%rdx
    0.00 :	  1241e1:       0f 0b                   ud2    
    0.00 :	  1241e3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1241ea:       84 00 00 00 00 00 
    0.00 :	  1241f0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1241f7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1241fa:       0f 28 4e f2             movaps -0xe(%rsi),%xmm1
    0.00 :	  1241fe:       72 07                   jb     124207 <__memmove_ssse3+0x1657>
    0.00 :	  124200:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  124207:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12420b:       41 ff e1                jmpq   *%r9
    0.00 :	  12420e:       0f 0b                   ud2    
    0.00 :	  124210:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  124217:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12421b:       0f 28 56 02             movaps 0x2(%rsi),%xmm2
    0.00 :	  12421f:       0f 28 5e 12             movaps 0x12(%rsi),%xmm3
    0.00 :	  124223:       0f 28 66 22             movaps 0x22(%rsi),%xmm4
    0.00 :	  124227:       0f 28 6e 32             movaps 0x32(%rsi),%xmm5
    0.00 :	  12422b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12422f:       66 0f 3a 0f ec 0e       palignr $0xe,%xmm4,%xmm5
    0.00 :	  124235:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  124239:       66 0f 3a 0f e3 0e       palignr $0xe,%xmm3,%xmm4
    0.00 :	  12423f:       66 0f 3a 0f da 0e       palignr $0xe,%xmm2,%xmm3
    0.00 :	  124245:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  124249:       66 0f 3a 0f d1 0e       palignr $0xe,%xmm1,%xmm2
    0.00 :	  12424f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  124253:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  124258:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  12425c:       72 0d                   jb     12426b <__memmove_ssse3+0x16bb>
    0.00 :	  12425e:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  124262:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  124266:       41 ff e1                jmpq   *%r9
    0.00 :	  124269:       0f 0b                   ud2    
    0.00 :	  12426b:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  12426f:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  124273:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  124277:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12427a:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12427f:       48 01 d6                add    %rdx,%rsi
    0.00 :	  124282:       4c 8d 1d 17 00 02 00    lea    0x20017(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  124289:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12428d:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  124291:       ff e2                   jmpq   *%rdx
    0.00 :	  124293:       0f 0b                   ud2    
    0.00 :	  124295:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12429c:       00 00 00 00 
    0.00 :	  1242a0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1242a7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1242aa:       0f 28 4e f2             movaps -0xe(%rsi),%xmm1
    0.00 :	  1242ae:       72 07                   jb     1242b7 <__memmove_ssse3+0x1707>
    0.00 :	  1242b0:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  1242b7:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  1242bb:       41 ff e1                jmpq   *%r9
    0.00 :	  1242be:       0f 0b                   ud2    
    0.00 :	  1242c0:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  1242c7:       0f 28 56 e2             movaps -0x1e(%rsi),%xmm2
    0.00 :	  1242cb:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  1242cf:       0f 28 5e d2             movaps -0x2e(%rsi),%xmm3
    0.00 :	  1242d3:       0f 28 66 c2             movaps -0x3e(%rsi),%xmm4
    0.00 :	  1242d7:       0f 28 6e b2             movaps -0x4e(%rsi),%xmm5
    0.00 :	  1242db:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  1242df:       66 0f 3a 0f ca 0e       palignr $0xe,%xmm2,%xmm1
    0.00 :	  1242e5:       66 0f 3a 0f d3 0e       palignr $0xe,%xmm3,%xmm2
    0.00 :	  1242eb:       66 0f 3a 0f dc 0e       palignr $0xe,%xmm4,%xmm3
    0.00 :	  1242f1:       66 0f 3a 0f e5 0e       palignr $0xe,%xmm5,%xmm4
    0.00 :	  1242f7:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  1242fb:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  1242fe:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  124302:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  124306:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12430a:       72 08                   jb     124314 <__memmove_ssse3+0x1764>
    0.00 :	  12430c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12430f:       41 ff e1                jmpq   *%r9
    0.00 :	  124312:       0f 0b                   ud2    
    0.00 :	  124314:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  124317:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12431b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  124320:       4c 8d 1d 79 ff 01 00    lea    0x1ff79(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  124327:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12432b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12432f:       ff e2                   jmpq   *%rdx
    0.00 :	  124331:       0f 0b                   ud2    
    0.00 :	  124333:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12433a:       84 00 00 00 00 00 
    0.00 :	  124340:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  124347:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  12434a:       0f 28 4e f1             movaps -0xf(%rsi),%xmm1
    0.00 :	  12434e:       72 07                   jb     124357 <__memmove_ssse3+0x17a7>
    0.00 :	  124350:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  124357:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12435b:       41 ff e1                jmpq   *%r9
    0.00 :	  12435e:       0f 0b                   ud2    
    0.00 :	  124360:       0f 18 86 c0 01 00 00    prefetchnta 0x1c0(%rsi)
    0.00 :	  124367:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12436b:       0f 28 56 01             movaps 0x1(%rsi),%xmm2
    0.00 :	  12436f:       0f 28 5e 11             movaps 0x11(%rsi),%xmm3
    0.00 :	  124373:       0f 28 66 21             movaps 0x21(%rsi),%xmm4
    0.00 :	  124377:       0f 28 6e 31             movaps 0x31(%rsi),%xmm5
    0.00 :	  12437b:       66 0f 6f f5             movdqa %xmm5,%xmm6
    0.00 :	  12437f:       66 0f 3a 0f ec 0f       palignr $0xf,%xmm4,%xmm5
    0.00 :	  124385:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  124389:       66 0f 3a 0f e3 0f       palignr $0xf,%xmm3,%xmm4
    0.00 :	  12438f:       66 0f 3a 0f da 0f       palignr $0xf,%xmm2,%xmm3
    0.00 :	  124395:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  124399:       66 0f 3a 0f d1 0f       palignr $0xf,%xmm1,%xmm2
    0.00 :	  12439f:       66 0f 6f ce             movdqa %xmm6,%xmm1
    0.00 :	  1243a3:       66 0f 7f 57 c0          movdqa %xmm2,-0x40(%rdi)
    0.00 :	  1243a8:       0f 29 5f d0             movaps %xmm3,-0x30(%rdi)
    0.00 :	  1243ac:       72 0d                   jb     1243bb <__memmove_ssse3+0x180b>
    0.00 :	  1243ae:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1243b2:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1243b6:       41 ff e1                jmpq   *%r9
    0.00 :	  1243b9:       0f 0b                   ud2    
    0.00 :	  1243bb:       0f 29 67 e0             movaps %xmm4,-0x20(%rdi)
    0.00 :	  1243bf:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  1243c3:       0f 29 6f f0             movaps %xmm5,-0x10(%rdi)
    0.00 :	  1243c7:       48 01 d7                add    %rdx,%rdi
    0.00 :	  1243ca:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1243cf:       48 01 d6                add    %rdx,%rsi
    0.00 :	  1243d2:       4c 8d 1d c7 fe 01 00    lea    0x1fec7(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  1243d9:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  1243dd:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1243e1:       ff e2                   jmpq   *%rdx
    0.00 :	  1243e3:       0f 0b                   ud2    
    0.00 :	  1243e5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1243ec:       00 00 00 00 
    0.00 :	  1243f0:       4d 8d 89 27 00 00 00    lea    0x27(%r9),%r9
    0.00 :	  1243f7:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1243fa:       0f 28 4e f1             movaps -0xf(%rsi),%xmm1
    0.00 :	  1243fe:       72 07                   jb     124407 <__memmove_ssse3+0x1857>
    0.00 :	  124400:       4d 8d 89 f9 ff ff ff    lea    -0x7(%r9),%r9
    0.00 :	  124407:       48 8d 52 c0             lea    -0x40(%rdx),%rdx
    0.00 :	  12440b:       41 ff e1                jmpq   *%r9
    0.00 :	  12440e:       0f 0b                   ud2    
    0.00 :	  124410:       0f 18 86 40 fe ff ff    prefetchnta -0x1c0(%rsi)
    0.00 :	  124417:       0f 28 56 e1             movaps -0x1f(%rsi),%xmm2
    0.00 :	  12441b:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  12441f:       0f 28 5e d1             movaps -0x2f(%rsi),%xmm3
    0.00 :	  124423:       0f 28 66 c1             movaps -0x3f(%rsi),%xmm4
    0.00 :	  124427:       0f 28 6e b1             movaps -0x4f(%rsi),%xmm5
    0.00 :	  12442b:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  12442f:       66 0f 3a 0f ca 0f       palignr $0xf,%xmm2,%xmm1
    0.00 :	  124435:       66 0f 3a 0f d3 0f       palignr $0xf,%xmm3,%xmm2
    0.00 :	  12443b:       66 0f 3a 0f dc 0f       palignr $0xf,%xmm4,%xmm3
    0.00 :	  124441:       66 0f 3a 0f e5 0f       palignr $0xf,%xmm5,%xmm4
    0.00 :	  124447:       0f 29 4f f0             movaps %xmm1,-0x10(%rdi)
    0.00 :	  12444b:       0f 28 cd                movaps %xmm5,%xmm1
    0.00 :	  12444e:       0f 29 57 e0             movaps %xmm2,-0x20(%rdi)
    0.00 :	  124452:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  124456:       0f 29 5f 10             movaps %xmm3,0x10(%rdi)
    0.00 :	  12445a:       72 08                   jb     124464 <__memmove_ssse3+0x18b4>
    0.00 :	  12445c:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  12445f:       41 ff e1                jmpq   *%r9
    0.00 :	  124462:       0f 0b                   ud2    
    0.00 :	  124464:       0f 29 27                movaps %xmm4,(%rdi)
    0.00 :	  124467:       48 8d 52 40             lea    0x40(%rdx),%rdx
    0.00 :	  12446b:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  124470:       4c 8d 1d 29 fe 01 00    lea    0x1fe29(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  124477:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12447b:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12447f:       ff e2                   jmpq   *%rdx
    0.00 :	  124481:       0f 0b                   ud2    
    0.00 :	  124483:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12448a:       84 00 00 00 00 00 
    0.00 :	  124490:       f3 0f 6f 46 b8          movdqu -0x48(%rsi),%xmm0
   66.67 :	  124495:       f3 0f 6f 4e c8          movdqu -0x38(%rsi),%xmm1
    0.00 :	  12449a:       4c 8b 46 d8             mov    -0x28(%rsi),%r8
    0.00 :	  12449e:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  1244a2:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  1244a6:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  1244aa:       48 8b 4e f8             mov    -0x8(%rsi),%rcx
    0.00 :	  1244ae:       f3 0f 7f 47 b8          movdqu %xmm0,-0x48(%rdi)
    0.00 :	  1244b3:       f3 0f 7f 4f c8          movdqu %xmm1,-0x38(%rdi)
    0.00 :	  1244b8:       4c 89 47 d8             mov    %r8,-0x28(%rdi)
    0.00 :	  1244bc:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  1244c0:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  1244c4:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  1244c8:       48 89 4f f8             mov    %rcx,-0x8(%rdi)
    0.00 :	  1244cc:       c3                      retq   
    0.00 :	  1244cd:       0f 1f 00                nopl   (%rax)
    0.00 :	  1244d0:       f3 0f 6f 46 c0          movdqu -0x40(%rsi),%xmm0
    0.00 :	  1244d5:       48 8b 4e d0             mov    -0x30(%rsi),%rcx
    0.00 :	  1244d9:       4c 8b 46 d8             mov    -0x28(%rsi),%r8
    0.00 :	  1244dd:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  1244e1:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  1244e5:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  1244e9:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1244ed:       f3 0f 7f 47 c0          movdqu %xmm0,-0x40(%rdi)
    0.00 :	  1244f2:       48 89 4f d0             mov    %rcx,-0x30(%rdi)
    0.00 :	  1244f6:       4c 89 47 d8             mov    %r8,-0x28(%rdi)
    0.00 :	  1244fa:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  1244fe:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  124502:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  124506:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  12450a:       c3                      retq   
    0.00 :	  12450b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  124510:       f3 0f 6f 46 c8          movdqu -0x38(%rsi),%xmm0
    0.00 :	  124515:       4c 8b 46 d8             mov    -0x28(%rsi),%r8
    0.00 :	  124519:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  12451d:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  124521:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  124525:       48 8b 4e f8             mov    -0x8(%rsi),%rcx
    0.00 :	  124529:       f3 0f 7f 47 c8          movdqu %xmm0,-0x38(%rdi)
    0.00 :	  12452e:       4c 89 47 d8             mov    %r8,-0x28(%rdi)
    0.00 :	  124532:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  124536:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  12453a:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  12453e:       48 89 4f f8             mov    %rcx,-0x8(%rdi)
    0.00 :	  124542:       c3                      retq   
    0.00 :	  124543:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12454a:       84 00 00 00 00 00 
    0.00 :	  124550:       48 8b 4e d0             mov    -0x30(%rsi),%rcx
    0.00 :	  124554:       4c 8b 46 d8             mov    -0x28(%rsi),%r8
    0.00 :	  124558:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  12455c:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  124560:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  124564:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124568:       48 89 4f d0             mov    %rcx,-0x30(%rdi)
    0.00 :	  12456c:       4c 89 47 d8             mov    %r8,-0x28(%rdi)
    0.00 :	  124570:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  124574:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  124578:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  12457c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124580:       c3                      retq   
    0.00 :	  124581:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124588:       0f 1f 84 00 00 00 00 
    0.00 :	  12458f:       00 
    0.00 :	  124590:       4c 8b 46 d8             mov    -0x28(%rsi),%r8
    0.00 :	  124594:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  124598:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  12459c:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  1245a0:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1245a4:       4c 89 47 d8             mov    %r8,-0x28(%rdi)
    0.00 :	  1245a8:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  1245ac:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  1245b0:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  1245b4:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1245b8:       c3                      retq   
    0.00 :	  1245b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  1245c0:       4c 8b 4e e0             mov    -0x20(%rsi),%r9
    0.00 :	  1245c4:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  1245c8:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  1245cc:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1245d0:       4c 89 4f e0             mov    %r9,-0x20(%rdi)
    0.00 :	  1245d4:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  1245d8:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  1245dc:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1245e0:       c3                      retq   
    0.00 :	  1245e1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1245e8:       0f 1f 84 00 00 00 00 
    0.00 :	  1245ef:       00 
    0.00 :	  1245f0:       4c 8b 56 e8             mov    -0x18(%rsi),%r10
    0.00 :	  1245f4:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  1245f8:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1245fc:       4c 89 57 e8             mov    %r10,-0x18(%rdi)
    0.00 :	  124600:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  124604:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124608:       c3                      retq   
    0.00 :	  124609:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124610:       4c 8b 5e f0             mov    -0x10(%rsi),%r11
    0.00 :	  124614:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124618:       4c 89 5f f0             mov    %r11,-0x10(%rdi)
    0.00 :	  12461c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124620:       c3                      retq   
    0.00 :	  124621:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124628:       0f 1f 84 00 00 00 00 
    0.00 :	  12462f:       00 
    0.00 :	  124630:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124634:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124638:       c3                      retq   
    0.00 :	  124639:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124640:       f3 0f 6f 46 b7          movdqu -0x49(%rsi),%xmm0
    0.00 :	  124645:       f3 0f 6f 4e c7          movdqu -0x39(%rsi),%xmm1
    0.00 :	  12464a:       48 8b 4e d7             mov    -0x29(%rsi),%rcx
    0.00 :	  12464e:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  124652:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  124656:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  12465a:       4c 8b 46 f7             mov    -0x9(%rsi),%r8
    0.00 :	  12465e:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124661:       f3 0f 7f 47 b7          movdqu %xmm0,-0x49(%rdi)
    0.00 :	  124666:       f3 0f 7f 4f c7          movdqu %xmm1,-0x39(%rdi)
    0.00 :	  12466b:       48 89 4f d7             mov    %rcx,-0x29(%rdi)
    0.00 :	  12466f:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  124673:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  124677:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  12467b:       4c 89 47 f7             mov    %r8,-0x9(%rdi)
    0.00 :	  12467f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124682:       c3                      retq   
    0.00 :	  124683:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12468a:       84 00 00 00 00 00 
    0.00 :	  124690:       f3 0f 6f 46 bf          movdqu -0x41(%rsi),%xmm0
    0.00 :	  124695:       f3 0f 6f 4e cf          movdqu -0x31(%rsi),%xmm1
    0.00 :	  12469a:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  12469e:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  1246a2:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  1246a6:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  1246aa:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1246ad:       f3 0f 7f 47 bf          movdqu %xmm0,-0x41(%rdi)
    0.00 :	  1246b2:       f3 0f 7f 4f cf          movdqu %xmm1,-0x31(%rdi)
    0.00 :	  1246b7:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  1246bb:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  1246bf:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  1246c3:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  1246c7:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1246ca:       c3                      retq   
    0.00 :	  1246cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  1246d0:       f3 0f 6f 46 c7          movdqu -0x39(%rsi),%xmm0
    0.00 :	  1246d5:       4c 8b 46 d7             mov    -0x29(%rsi),%r8
    0.00 :	  1246d9:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  1246dd:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  1246e1:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  1246e5:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  1246e9:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1246ec:       f3 0f 7f 47 c7          movdqu %xmm0,-0x39(%rdi)
    0.00 :	  1246f1:       4c 89 47 d7             mov    %r8,-0x29(%rdi)
    0.00 :	  1246f5:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  1246f9:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  1246fd:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  124701:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  124705:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124708:       c3                      retq   
    0.00 :	  124709:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124710:       f3 0f 6f 46 cf          movdqu -0x31(%rsi),%xmm0
    0.00 :	  124715:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  124719:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  12471d:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  124721:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  124725:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124728:       f3 0f 7f 47 cf          movdqu %xmm0,-0x31(%rdi)
    0.00 :	  12472d:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  124731:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  124735:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  124739:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  12473d:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124740:       c3                      retq   
    0.00 :	  124741:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124748:       0f 1f 84 00 00 00 00 
    0.00 :	  12474f:       00 
    0.00 :	  124750:       4c 8b 46 d7             mov    -0x29(%rsi),%r8
    0.00 :	  124754:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  124758:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  12475c:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  124760:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  124764:       8a 56 ff                mov    -0x1(%rsi),%dl
    0.00 :	  124767:       4c 89 47 d7             mov    %r8,-0x29(%rdi)
    0.00 :	  12476b:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  12476f:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  124773:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  124777:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  12477b:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	  12477e:       c3                      retq   
    0.00 :	  12477f:       90                      nop
    0.00 :	  124780:       4c 8b 4e df             mov    -0x21(%rsi),%r9
    0.00 :	  124784:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  124788:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  12478c:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  124790:       8a 56 ff                mov    -0x1(%rsi),%dl
    0.00 :	  124793:       4c 89 4f df             mov    %r9,-0x21(%rdi)
    0.00 :	  124797:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  12479b:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  12479f:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  1247a3:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	  1247a6:       c3                      retq   
    0.00 :	  1247a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  1247ae:       00 00 
    0.00 :	  1247b0:       4c 8b 56 e7             mov    -0x19(%rsi),%r10
    0.00 :	  1247b4:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  1247b8:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  1247bc:       8a 56 ff                mov    -0x1(%rsi),%dl
    0.00 :	  1247bf:       4c 89 57 e7             mov    %r10,-0x19(%rdi)
    0.00 :	  1247c3:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  1247c7:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  1247cb:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	  1247ce:       c3                      retq   
    0.00 :	  1247cf:       90                      nop
    0.00 :	  1247d0:       4c 8b 5e ef             mov    -0x11(%rsi),%r11
    0.00 :	  1247d4:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  1247d8:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1247db:       4c 89 5f ef             mov    %r11,-0x11(%rdi)
    0.00 :	  1247df:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  1247e3:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1247e6:       c3                      retq   
    0.00 :	  1247e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  1247ee:       00 00 
    0.00 :	  1247f0:       48 8b 4e f7             mov    -0x9(%rsi),%rcx
    0.00 :	  1247f4:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1247f7:       48 89 4f f7             mov    %rcx,-0x9(%rdi)
    0.00 :	  1247fb:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1247fe:       c3                      retq   
    0.00 :	  1247ff:       90                      nop
    0.00 :	  124800:       8a 56 ff                mov    -0x1(%rsi),%dl
    0.00 :	  124803:       88 57 ff                mov    %dl,-0x1(%rdi)
    0.00 :	  124806:       c3                      retq   
    0.00 :	  124807:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  12480e:       00 00 
    0.00 :	  124810:       f3 0f 6f 46 b6          movdqu -0x4a(%rsi),%xmm0
    0.00 :	  124815:       f3 0f 6f 4e c6          movdqu -0x3a(%rsi),%xmm1
    0.00 :	  12481a:       4c 8b 46 d6             mov    -0x2a(%rsi),%r8
    0.00 :	  12481e:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  124822:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  124826:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  12482a:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  12482e:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124831:       f3 0f 7f 47 b6          movdqu %xmm0,-0x4a(%rdi)
    0.00 :	  124836:       f3 0f 7f 4f c6          movdqu %xmm1,-0x3a(%rdi)
    0.00 :	  12483b:       4c 89 47 d6             mov    %r8,-0x2a(%rdi)
    0.00 :	  12483f:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  124843:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  124847:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  12484b:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  12484f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124852:       c3                      retq   
    0.00 :	  124853:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  12485a:       84 00 00 00 00 00 
    0.00 :	  124860:       f3 0f 6f 46 be          movdqu -0x42(%rsi),%xmm0
    0.00 :	  124865:       f3 0f 6f 4e ce          movdqu -0x32(%rsi),%xmm1
    0.00 :	  12486a:       4c 8b 46 d6             mov    -0x2a(%rsi),%r8
    0.00 :	  12486e:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  124872:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  124876:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  12487a:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  12487e:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124881:       f3 0f 7f 47 be          movdqu %xmm0,-0x42(%rdi)
    0.00 :	  124886:       f3 0f 7f 4f ce          movdqu %xmm1,-0x32(%rdi)
    0.00 :	  12488b:       4c 89 47 d6             mov    %r8,-0x2a(%rdi)
    0.00 :	  12488f:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  124893:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  124897:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  12489b:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  12489f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1248a2:       c3                      retq   
    0.00 :	  1248a3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1248aa:       84 00 00 00 00 00 
    0.00 :	  1248b0:       f3 0f 6f 4e c6          movdqu -0x3a(%rsi),%xmm1
    0.00 :	  1248b5:       4c 8b 46 d6             mov    -0x2a(%rsi),%r8
    0.00 :	  1248b9:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  1248bd:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  1248c1:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  1248c5:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  1248c9:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1248cc:       f3 0f 7f 4f c6          movdqu %xmm1,-0x3a(%rdi)
    0.00 :	  1248d1:       4c 89 47 d6             mov    %r8,-0x2a(%rdi)
    0.00 :	  1248d5:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  1248d9:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  1248dd:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  1248e1:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  1248e5:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1248e8:       c3                      retq   
    0.00 :	  1248e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  1248f0:       f3 0f 6f 46 ce          movdqu -0x32(%rsi),%xmm0
    0.00 :	  1248f5:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  1248f9:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  1248fd:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  124901:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  124905:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124908:       f3 0f 7f 47 ce          movdqu %xmm0,-0x32(%rdi)
    0.00 :	  12490d:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  124911:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  124915:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  124919:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  12491d:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124920:       c3                      retq   
    0.00 :	  124921:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124928:       0f 1f 84 00 00 00 00 
    0.00 :	  12492f:       00 
    0.00 :	  124930:       4c 8b 46 d6             mov    -0x2a(%rsi),%r8
    0.00 :	  124934:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  124938:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  12493c:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  124940:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  124944:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124947:       4c 89 47 d6             mov    %r8,-0x2a(%rdi)
    0.00 :	  12494b:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  12494f:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  124953:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  124957:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  12495b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  12495e:       c3                      retq   
    0.00 :	  12495f:       90                      nop
    0.00 :	  124960:       4c 8b 4e de             mov    -0x22(%rsi),%r9
    0.00 :	  124964:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  124968:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  12496c:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  124970:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124973:       4c 89 4f de             mov    %r9,-0x22(%rdi)
    0.00 :	  124977:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  12497b:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  12497f:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  124983:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124986:       c3                      retq   
    0.00 :	  124987:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  12498e:       00 00 
    0.00 :	  124990:       4c 8b 56 e6             mov    -0x1a(%rsi),%r10
    0.00 :	  124994:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  124998:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  12499c:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  12499f:       4c 89 57 e6             mov    %r10,-0x1a(%rdi)
    0.00 :	  1249a3:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  1249a7:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  1249ab:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1249ae:       c3                      retq   
    0.00 :	  1249af:       90                      nop
    0.00 :	  1249b0:       4c 8b 5e ee             mov    -0x12(%rsi),%r11
    0.00 :	  1249b4:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  1249b8:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1249bb:       4c 89 5f ee             mov    %r11,-0x12(%rdi)
    0.00 :	  1249bf:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  1249c3:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1249c6:       c3                      retq   
    0.00 :	  1249c7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  1249ce:       00 00 
    0.00 :	  1249d0:       48 8b 4e f6             mov    -0xa(%rsi),%rcx
    0.00 :	  1249d4:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  1249d7:       48 89 4f f6             mov    %rcx,-0xa(%rdi)
    0.00 :	  1249db:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  1249de:       c3                      retq   
    0.00 :	  1249df:       90                      nop
    0.00 :	  1249e0:       66 8b 56 fe             mov    -0x2(%rsi),%dx
    0.00 :	  1249e4:       66 89 57 fe             mov    %dx,-0x2(%rdi)
    0.00 :	  1249e8:       c3                      retq   
    0.00 :	  1249e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  1249f0:       f3 0f 6f 46 b5          movdqu -0x4b(%rsi),%xmm0
    0.00 :	  1249f5:       f3 0f 6f 4e c5          movdqu -0x3b(%rsi),%xmm1
    0.00 :	  1249fa:       4c 8b 46 d5             mov    -0x2b(%rsi),%r8
    0.00 :	  1249fe:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124a02:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124a06:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124a0a:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124a0e:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124a11:       f3 0f 7f 47 b5          movdqu %xmm0,-0x4b(%rdi)
    0.00 :	  124a16:       f3 0f 7f 4f c5          movdqu %xmm1,-0x3b(%rdi)
    0.00 :	  124a1b:       4c 89 47 d5             mov    %r8,-0x2b(%rdi)
    0.00 :	  124a1f:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124a23:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124a27:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124a2b:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124a2f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124a32:       c3                      retq   
    0.00 :	  124a33:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124a3a:       84 00 00 00 00 00 
    0.00 :	  124a40:       f3 0f 6f 46 bd          movdqu -0x43(%rsi),%xmm0
    0.00 :	  124a45:       f3 0f 6f 4e c5          movdqu -0x3b(%rsi),%xmm1
    0.00 :	  124a4a:       4c 8b 46 d5             mov    -0x2b(%rsi),%r8
    0.00 :	  124a4e:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124a52:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124a56:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124a5a:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124a5e:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124a61:       f3 0f 7f 47 bd          movdqu %xmm0,-0x43(%rdi)
    0.00 :	  124a66:       f3 0f 7f 4f c5          movdqu %xmm1,-0x3b(%rdi)
    0.00 :	  124a6b:       4c 89 47 d5             mov    %r8,-0x2b(%rdi)
    0.00 :	  124a6f:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124a73:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124a77:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124a7b:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124a7f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124a82:       c3                      retq   
    0.00 :	  124a83:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124a8a:       84 00 00 00 00 00 
    0.00 :	  124a90:       f3 0f 6f 46 c5          movdqu -0x3b(%rsi),%xmm0
    0.00 :	  124a95:       4c 8b 46 d5             mov    -0x2b(%rsi),%r8
    0.00 :	  124a99:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124a9d:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124aa1:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124aa5:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124aa9:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124aac:       f3 0f 7f 47 c5          movdqu %xmm0,-0x3b(%rdi)
    0.00 :	  124ab1:       4c 89 47 d5             mov    %r8,-0x2b(%rdi)
    0.00 :	  124ab5:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124ab9:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124abd:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124ac1:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124ac5:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124ac8:       c3                      retq   
    0.00 :	  124ac9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124ad0:       f3 0f 6f 46 cd          movdqu -0x33(%rsi),%xmm0
    0.00 :	  124ad5:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124ad9:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124add:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124ae1:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124ae5:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124ae8:       f3 0f 7f 47 cd          movdqu %xmm0,-0x33(%rdi)
    0.00 :	  124aed:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124af1:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124af5:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124af9:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124afd:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124b00:       c3                      retq   
    0.00 :	  124b01:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124b08:       0f 1f 84 00 00 00 00 
    0.00 :	  124b0f:       00 
    0.00 :	  124b10:       4c 8b 46 d5             mov    -0x2b(%rsi),%r8
    0.00 :	  124b14:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124b18:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124b1c:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124b20:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124b24:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124b27:       4c 89 47 d5             mov    %r8,-0x2b(%rdi)
    0.00 :	  124b2b:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124b2f:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124b33:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124b37:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124b3b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124b3e:       c3                      retq   
    0.00 :	  124b3f:       90                      nop
    0.00 :	  124b40:       4c 8b 4e dd             mov    -0x23(%rsi),%r9
    0.00 :	  124b44:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124b48:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124b4c:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124b50:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124b53:       4c 89 4f dd             mov    %r9,-0x23(%rdi)
    0.00 :	  124b57:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124b5b:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124b5f:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124b63:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124b66:       c3                      retq   
    0.00 :	  124b67:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124b6e:       00 00 
    0.00 :	  124b70:       4c 8b 56 e5             mov    -0x1b(%rsi),%r10
    0.00 :	  124b74:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124b78:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124b7c:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124b7f:       4c 89 57 e5             mov    %r10,-0x1b(%rdi)
    0.00 :	  124b83:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124b87:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124b8b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124b8e:       c3                      retq   
    0.00 :	  124b8f:       90                      nop
    0.00 :	  124b90:       4c 8b 5e ed             mov    -0x13(%rsi),%r11
    0.00 :	  124b94:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124b98:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124b9b:       4c 89 5f ed             mov    %r11,-0x13(%rdi)
    0.00 :	  124b9f:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124ba3:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124ba6:       c3                      retq   
    0.00 :	  124ba7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124bae:       00 00 
    0.00 :	  124bb0:       48 8b 4e f5             mov    -0xb(%rsi),%rcx
    0.00 :	  124bb4:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124bb7:       48 89 4f f5             mov    %rcx,-0xb(%rdi)
    0.00 :	  124bbb:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124bbe:       c3                      retq   
    0.00 :	  124bbf:       90                      nop
    0.00 :	  124bc0:       66 8b 56 fd             mov    -0x3(%rsi),%dx
    0.00 :	  124bc4:       66 8b 4e fe             mov    -0x2(%rsi),%cx
    0.00 :	  124bc8:       66 89 57 fd             mov    %dx,-0x3(%rdi)
    0.00 :	  124bcc:       66 89 4f fe             mov    %cx,-0x2(%rdi)
    0.00 :	  124bd0:       c3                      retq   
    0.00 :	  124bd1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124bd8:       0f 1f 84 00 00 00 00 
    0.00 :	  124bdf:       00 
    0.00 :	  124be0:       f3 0f 6f 46 b4          movdqu -0x4c(%rsi),%xmm0
    0.00 :	  124be5:       f3 0f 6f 4e c4          movdqu -0x3c(%rsi),%xmm1
    0.00 :	  124bea:       4c 8b 46 d4             mov    -0x2c(%rsi),%r8
    0.00 :	  124bee:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124bf2:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124bf6:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124bfa:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124bfe:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124c01:       f3 0f 7f 47 b4          movdqu %xmm0,-0x4c(%rdi)
    0.00 :	  124c06:       f3 0f 7f 4f c4          movdqu %xmm1,-0x3c(%rdi)
    0.00 :	  124c0b:       4c 89 47 d4             mov    %r8,-0x2c(%rdi)
    0.00 :	  124c0f:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124c13:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124c17:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124c1b:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124c1f:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124c22:       c3                      retq   
    0.00 :	  124c23:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124c2a:       84 00 00 00 00 00 
    0.00 :	  124c30:       f3 0f 6f 46 bc          movdqu -0x44(%rsi),%xmm0
    0.00 :	  124c35:       f3 0f 6f 4e cc          movdqu -0x34(%rsi),%xmm1
    0.00 :	  124c3a:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124c3e:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124c42:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124c46:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124c4a:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124c4d:       f3 0f 7f 47 bc          movdqu %xmm0,-0x44(%rdi)
    0.00 :	  124c52:       f3 0f 7f 4f cc          movdqu %xmm1,-0x34(%rdi)
    0.00 :	  124c57:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124c5b:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124c5f:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124c63:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124c67:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124c6a:       c3                      retq   
    0.00 :	  124c6b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  124c70:       f3 0f 6f 46 c4          movdqu -0x3c(%rsi),%xmm0
    0.00 :	  124c75:       4c 8b 46 d4             mov    -0x2c(%rsi),%r8
    0.00 :	  124c79:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124c7d:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124c81:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124c85:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124c89:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124c8c:       f3 0f 7f 47 c4          movdqu %xmm0,-0x3c(%rdi)
    0.00 :	  124c91:       4c 89 47 d4             mov    %r8,-0x2c(%rdi)
    0.00 :	  124c95:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124c99:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124c9d:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124ca1:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124ca5:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124ca8:       c3                      retq   
    0.00 :	  124ca9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124cb0:       f3 0f 6f 46 cc          movdqu -0x34(%rsi),%xmm0
    0.00 :	  124cb5:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124cb9:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124cbd:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124cc1:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124cc5:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124cc8:       f3 0f 7f 47 cc          movdqu %xmm0,-0x34(%rdi)
    0.00 :	  124ccd:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124cd1:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124cd5:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124cd9:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124cdd:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124ce0:       c3                      retq   
    0.00 :	  124ce1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124ce8:       0f 1f 84 00 00 00 00 
    0.00 :	  124cef:       00 
    0.00 :	  124cf0:       4c 8b 46 d4             mov    -0x2c(%rsi),%r8
    0.00 :	  124cf4:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124cf8:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124cfc:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124d00:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124d04:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124d07:       4c 89 47 d4             mov    %r8,-0x2c(%rdi)
    0.00 :	  124d0b:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124d0f:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124d13:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124d17:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124d1b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124d1e:       c3                      retq   
    0.00 :	  124d1f:       90                      nop
    0.00 :	  124d20:       4c 8b 4e dc             mov    -0x24(%rsi),%r9
    0.00 :	  124d24:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124d28:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124d2c:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124d30:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124d33:       4c 89 4f dc             mov    %r9,-0x24(%rdi)
    0.00 :	  124d37:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124d3b:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124d3f:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124d43:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124d46:       c3                      retq   
    0.00 :	  124d47:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124d4e:       00 00 
    0.00 :	  124d50:       4c 8b 56 e4             mov    -0x1c(%rsi),%r10
    0.00 :	  124d54:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124d58:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124d5c:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124d5f:       4c 89 57 e4             mov    %r10,-0x1c(%rdi)
    0.00 :	  124d63:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124d67:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124d6b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124d6e:       c3                      retq   
    0.00 :	  124d6f:       90                      nop
    0.00 :	  124d70:       4c 8b 5e ec             mov    -0x14(%rsi),%r11
    0.00 :	  124d74:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124d78:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124d7b:       4c 89 5f ec             mov    %r11,-0x14(%rdi)
    0.00 :	  124d7f:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124d83:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124d86:       c3                      retq   
    0.00 :	  124d87:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124d8e:       00 00 
    0.00 :	  124d90:       48 8b 4e f4             mov    -0xc(%rsi),%rcx
    0.00 :	  124d94:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124d97:       48 89 4f f4             mov    %rcx,-0xc(%rdi)
    0.00 :	  124d9b:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124d9e:       c3                      retq   
    0.00 :	  124d9f:       90                      nop
    0.00 :	  124da0:       8b 56 fc                mov    -0x4(%rsi),%edx
    0.00 :	  124da3:       89 57 fc                mov    %edx,-0x4(%rdi)
    0.00 :	  124da6:       c3                      retq   
    0.00 :	  124da7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124dae:       00 00 
    0.00 :	  124db0:       f3 0f 6f 46 b3          movdqu -0x4d(%rsi),%xmm0
    0.00 :	  124db5:       f3 0f 6f 4e c3          movdqu -0x3d(%rsi),%xmm1
    0.00 :	  124dba:       4c 8b 46 d3             mov    -0x2d(%rsi),%r8
    0.00 :	  124dbe:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124dc2:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124dc6:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124dca:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124dce:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124dd2:       f3 0f 7f 47 b3          movdqu %xmm0,-0x4d(%rdi)
    0.00 :	  124dd7:       f3 0f 7f 4f c3          movdqu %xmm1,-0x3d(%rdi)
    0.00 :	  124ddc:       4c 89 47 d3             mov    %r8,-0x2d(%rdi)
    0.00 :	  124de0:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124de4:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124de8:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124dec:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124df0:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124df4:       c3                      retq   
    0.00 :	  124df5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124dfc:       00 00 00 00 
    0.00 :	  124e00:       f3 0f 6f 46 bb          movdqu -0x45(%rsi),%xmm0
    0.00 :	  124e05:       f3 0f 6f 4e cb          movdqu -0x35(%rsi),%xmm1
    0.00 :	  124e0a:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124e0e:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124e12:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124e16:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124e1a:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124e1e:       f3 0f 7f 47 bb          movdqu %xmm0,-0x45(%rdi)
    0.00 :	  124e23:       f3 0f 7f 4f cb          movdqu %xmm1,-0x35(%rdi)
    0.00 :	  124e28:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124e2c:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124e30:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124e34:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124e38:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124e3c:       c3                      retq   
    0.00 :	  124e3d:       0f 1f 00                nopl   (%rax)
    0.00 :	  124e40:       f3 0f 6f 46 c3          movdqu -0x3d(%rsi),%xmm0
    0.00 :	  124e45:       4c 8b 46 d3             mov    -0x2d(%rsi),%r8
    0.00 :	  124e49:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124e4d:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124e51:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124e55:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124e59:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124e5d:       f3 0f 7f 47 c3          movdqu %xmm0,-0x3d(%rdi)
    0.00 :	  124e62:       4c 89 47 d3             mov    %r8,-0x2d(%rdi)
    0.00 :	  124e66:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124e6a:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124e6e:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124e72:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124e76:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124e7a:       c3                      retq   
    0.00 :	  124e7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  124e80:       f3 0f 6f 46 cb          movdqu -0x35(%rsi),%xmm0
    0.00 :	  124e85:       4c 8b 46 d3             mov    -0x2d(%rsi),%r8
    0.00 :	  124e89:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124e8d:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124e91:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124e95:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124e99:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124e9d:       f3 0f 7f 47 cb          movdqu %xmm0,-0x35(%rdi)
    0.00 :	  124ea2:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124ea6:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124eaa:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124eae:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124eb2:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124eb6:       c3                      retq   
    0.00 :	  124eb7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  124ebe:       00 00 
    0.00 :	  124ec0:       4c 8b 46 d3             mov    -0x2d(%rsi),%r8
    0.00 :	  124ec4:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124ec8:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124ecc:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124ed0:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124ed4:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124ed8:       4c 89 47 d3             mov    %r8,-0x2d(%rdi)
    0.00 :	  124edc:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124ee0:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124ee4:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124ee8:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124eec:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124ef0:       c3                      retq   
    0.00 :	  124ef1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124ef8:       0f 1f 84 00 00 00 00 
    0.00 :	  124eff:       00 
    0.00 :	  124f00:       4c 8b 4e db             mov    -0x25(%rsi),%r9
    0.00 :	  124f04:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124f08:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124f0c:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124f10:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124f14:       4c 89 4f db             mov    %r9,-0x25(%rdi)
    0.00 :	  124f18:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124f1c:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124f20:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124f24:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124f28:       c3                      retq   
    0.00 :	  124f29:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124f30:       4c 8b 56 e3             mov    -0x1d(%rsi),%r10
    0.00 :	  124f34:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124f38:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124f3c:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124f40:       4c 89 57 e3             mov    %r10,-0x1d(%rdi)
    0.00 :	  124f44:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124f48:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124f4c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124f50:       c3                      retq   
    0.00 :	  124f51:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124f58:       0f 1f 84 00 00 00 00 
    0.00 :	  124f5f:       00 
    0.00 :	  124f60:       4c 8b 5e eb             mov    -0x15(%rsi),%r11
    0.00 :	  124f64:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124f68:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124f6c:       4c 89 5f eb             mov    %r11,-0x15(%rdi)
    0.00 :	  124f70:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124f74:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124f78:       c3                      retq   
    0.00 :	  124f79:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  124f80:       48 8b 4e f3             mov    -0xd(%rsi),%rcx
    0.00 :	  124f84:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124f88:       48 89 4f f3             mov    %rcx,-0xd(%rdi)
    0.00 :	  124f8c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124f90:       c3                      retq   
    0.00 :	  124f91:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124f98:       0f 1f 84 00 00 00 00 
    0.00 :	  124f9f:       00 
    0.00 :	  124fa0:       8b 56 fb                mov    -0x5(%rsi),%edx
    0.00 :	  124fa3:       8b 4e fc                mov    -0x4(%rsi),%ecx
    0.00 :	  124fa6:       89 57 fb                mov    %edx,-0x5(%rdi)
    0.00 :	  124fa9:       89 4f fc                mov    %ecx,-0x4(%rdi)
    0.00 :	  124fac:       c3                      retq   
    0.00 :	  124fad:       0f 1f 00                nopl   (%rax)
    0.00 :	  124fb0:       f3 0f 6f 46 b2          movdqu -0x4e(%rsi),%xmm0
    0.00 :	  124fb5:       f3 0f 6f 4e c2          movdqu -0x3e(%rsi),%xmm1
    0.00 :	  124fba:       4c 8b 46 d2             mov    -0x2e(%rsi),%r8
    0.00 :	  124fbe:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  124fc2:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  124fc6:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  124fca:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  124fce:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  124fd2:       f3 0f 7f 47 b2          movdqu %xmm0,-0x4e(%rdi)
    0.00 :	  124fd7:       f3 0f 7f 4f c2          movdqu %xmm1,-0x3e(%rdi)
    0.00 :	  124fdc:       4c 89 47 d2             mov    %r8,-0x2e(%rdi)
    0.00 :	  124fe0:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  124fe4:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  124fe8:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  124fec:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  124ff0:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  124ff4:       c3                      retq   
    0.00 :	  124ff5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  124ffc:       00 00 00 00 
    0.00 :	  125000:       f3 0f 6f 46 ba          movdqu -0x46(%rsi),%xmm0
    0.00 :	  125005:       f3 0f 6f 4e ca          movdqu -0x36(%rsi),%xmm1
    0.00 :	  12500a:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  12500e:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  125012:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  125016:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  12501a:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12501e:       f3 0f 7f 47 ba          movdqu %xmm0,-0x46(%rdi)
    0.00 :	  125023:       f3 0f 7f 4f ca          movdqu %xmm1,-0x36(%rdi)
    0.00 :	  125028:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  12502c:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  125030:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  125034:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  125038:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  12503c:       c3                      retq   
    0.00 :	  12503d:       0f 1f 00                nopl   (%rax)
    0.00 :	  125040:       f3 0f 6f 46 c2          movdqu -0x3e(%rsi),%xmm0
    0.00 :	  125045:       4c 8b 46 d2             mov    -0x2e(%rsi),%r8
    0.00 :	  125049:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  12504d:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  125051:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  125055:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  125059:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12505d:       f3 0f 7f 47 c2          movdqu %xmm0,-0x3e(%rdi)
    0.00 :	  125062:       4c 89 47 d2             mov    %r8,-0x2e(%rdi)
    0.00 :	  125066:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  12506a:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  12506e:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  125072:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  125076:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  12507a:       c3                      retq   
    0.00 :	  12507b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  125080:       f3 0f 6f 46 ca          movdqu -0x36(%rsi),%xmm0
    0.00 :	  125085:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  125089:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  12508d:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  125091:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  125095:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125099:       f3 0f 7f 47 ca          movdqu %xmm0,-0x36(%rdi)
    0.00 :	  12509e:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  1250a2:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  1250a6:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  1250aa:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  1250ae:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1250b2:       c3                      retq   
    0.00 :	  1250b3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1250ba:       84 00 00 00 00 00 
    0.00 :	  1250c0:       4c 8b 46 d2             mov    -0x2e(%rsi),%r8
    0.00 :	  1250c4:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  1250c8:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  1250cc:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  1250d0:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  1250d4:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1250d8:       4c 89 47 d2             mov    %r8,-0x2e(%rdi)
    0.00 :	  1250dc:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  1250e0:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  1250e4:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  1250e8:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  1250ec:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1250f0:       c3                      retq   
    0.00 :	  1250f1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1250f8:       0f 1f 84 00 00 00 00 
    0.00 :	  1250ff:       00 
    0.00 :	  125100:       4c 8b 4e da             mov    -0x26(%rsi),%r9
    0.00 :	  125104:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  125108:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  12510c:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  125110:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125114:       4c 89 4f da             mov    %r9,-0x26(%rdi)
    0.00 :	  125118:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  12511c:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  125120:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  125124:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125128:       c3                      retq   
    0.00 :	  125129:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  125130:       4c 8b 56 e2             mov    -0x1e(%rsi),%r10
    0.00 :	  125134:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  125138:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  12513c:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125140:       4c 89 57 e2             mov    %r10,-0x1e(%rdi)
    0.00 :	  125144:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  125148:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  12514c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125150:       c3                      retq   
    0.00 :	  125151:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  125158:       0f 1f 84 00 00 00 00 
    0.00 :	  12515f:       00 
    0.00 :	  125160:       4c 8b 5e ea             mov    -0x16(%rsi),%r11
    0.00 :	  125164:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  125168:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12516c:       4c 89 5f ea             mov    %r11,-0x16(%rdi)
    0.00 :	  125170:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  125174:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125178:       c3                      retq   
    0.00 :	  125179:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  125180:       48 8b 4e f2             mov    -0xe(%rsi),%rcx
    0.00 :	  125184:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125188:       48 89 4f f2             mov    %rcx,-0xe(%rdi)
    0.00 :	  12518c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125190:       c3                      retq   
    0.00 :	  125191:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  125198:       0f 1f 84 00 00 00 00 
    0.00 :	  12519f:       00 
    0.00 :	  1251a0:       8b 56 fa                mov    -0x6(%rsi),%edx
    0.00 :	  1251a3:       8b 4e fc                mov    -0x4(%rsi),%ecx
    0.00 :	  1251a6:       89 57 fa                mov    %edx,-0x6(%rdi)
    0.00 :	  1251a9:       89 4f fc                mov    %ecx,-0x4(%rdi)
    0.00 :	  1251ac:       c3                      retq   
    0.00 :	  1251ad:       0f 1f 00                nopl   (%rax)
    0.00 :	  1251b0:       f3 0f 6f 46 b1          movdqu -0x4f(%rsi),%xmm0
    0.00 :	  1251b5:       f3 0f 6f 4e c1          movdqu -0x3f(%rsi),%xmm1
    0.00 :	  1251ba:       4c 8b 46 d1             mov    -0x2f(%rsi),%r8
    0.00 :	  1251be:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  1251c2:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  1251c6:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  1251ca:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  1251ce:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1251d2:       f3 0f 7f 47 b1          movdqu %xmm0,-0x4f(%rdi)
    0.00 :	  1251d7:       f3 0f 7f 4f c1          movdqu %xmm1,-0x3f(%rdi)
    0.00 :	  1251dc:       4c 89 47 d1             mov    %r8,-0x2f(%rdi)
    0.00 :	  1251e0:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  1251e4:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  1251e8:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  1251ec:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  1251f0:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1251f4:       c3                      retq   
    0.00 :	  1251f5:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1251fc:       00 00 00 00 
    0.00 :	  125200:       f3 0f 6f 46 b9          movdqu -0x47(%rsi),%xmm0
    0.00 :	  125205:       f3 0f 6f 4e c9          movdqu -0x37(%rsi),%xmm1
    0.00 :	  12520a:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  12520e:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  125212:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  125216:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  12521a:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12521e:       f3 0f 7f 47 b9          movdqu %xmm0,-0x47(%rdi)
    0.00 :	  125223:       f3 0f 7f 4f c9          movdqu %xmm1,-0x37(%rdi)
    0.00 :	  125228:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  12522c:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  125230:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  125234:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  125238:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  12523c:       c3                      retq   
    0.00 :	  12523d:       0f 1f 00                nopl   (%rax)
    0.00 :	  125240:       f3 0f 6f 46 c1          movdqu -0x3f(%rsi),%xmm0
    0.00 :	  125245:       4c 8b 46 d1             mov    -0x2f(%rsi),%r8
    0.00 :	  125249:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  12524d:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  125251:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  125255:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  125259:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12525d:       f3 0f 7f 47 c1          movdqu %xmm0,-0x3f(%rdi)
    0.00 :	  125262:       4c 89 47 d1             mov    %r8,-0x2f(%rdi)
    0.00 :	  125266:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  12526a:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  12526e:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  125272:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  125276:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  12527a:       c3                      retq   
    0.00 :	  12527b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  125280:       f3 0f 6f 46 c9          movdqu -0x37(%rsi),%xmm0
    0.00 :	  125285:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  125289:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  12528d:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  125291:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  125295:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125299:       f3 0f 7f 47 c9          movdqu %xmm0,-0x37(%rdi)
    0.00 :	  12529e:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  1252a2:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  1252a6:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  1252aa:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  1252ae:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1252b2:       c3                      retq   
    0.00 :	  1252b3:       66 66 66 66 2e 0f 1f    data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1252ba:       84 00 00 00 00 00 
    0.00 :	  1252c0:       4c 8b 46 d1             mov    -0x2f(%rsi),%r8
    0.00 :	  1252c4:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  1252c8:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  1252cc:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  1252d0:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  1252d4:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  1252d8:       4c 89 47 d1             mov    %r8,-0x2f(%rdi)
    0.00 :	  1252dc:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  1252e0:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  1252e4:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  1252e8:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  1252ec:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  1252f0:       c3                      retq   
    0.00 :	  1252f1:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1252f8:       0f 1f 84 00 00 00 00 
    0.00 :	  1252ff:       00 
    0.00 :	  125300:       4c 8b 4e d9             mov    -0x27(%rsi),%r9
    0.00 :	  125304:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  125308:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  12530c:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  125310:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125314:       4c 89 4f d9             mov    %r9,-0x27(%rdi)
    0.00 :	  125318:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  12531c:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  125320:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  125324:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125328:       c3                      retq   
    0.00 :	  125329:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  125330:       4c 8b 56 e1             mov    -0x1f(%rsi),%r10
    0.00 :	  125334:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  125338:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  12533c:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125340:       4c 89 57 e1             mov    %r10,-0x1f(%rdi)
    0.00 :	  125344:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  125348:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  12534c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125350:       c3                      retq   
    0.00 :	  125351:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  125358:       0f 1f 84 00 00 00 00 
    0.00 :	  12535f:       00 
    0.00 :	  125360:       4c 8b 5e e9             mov    -0x17(%rsi),%r11
    0.00 :	  125364:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  125368:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  12536c:       4c 89 5f e9             mov    %r11,-0x17(%rdi)
    0.00 :	  125370:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  125374:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125378:       c3                      retq   
    0.00 :	  125379:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  125380:       48 8b 4e f1             mov    -0xf(%rsi),%rcx
    0.00 :	  125384:       48 8b 56 f8             mov    -0x8(%rsi),%rdx
    0.00 :	  125388:       48 89 4f f1             mov    %rcx,-0xf(%rdi)
    0.00 :	  12538c:       48 89 57 f8             mov    %rdx,-0x8(%rdi)
    0.00 :	  125390:       c3                      retq   
    0.00 :	  125391:       66 66 66 66 66 66 2e    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  125398:       0f 1f 84 00 00 00 00 
    0.00 :	  12539f:       00 
    0.00 :	  1253a0:       8b 56 f9                mov    -0x7(%rsi),%edx
    0.00 :	  1253a3:       8b 4e fc                mov    -0x4(%rsi),%ecx
    0.00 :	  1253a6:       89 57 f9                mov    %edx,-0x7(%rdi)
    0.00 :	  1253a9:       89 4f fc                mov    %ecx,-0x4(%rdi)
    0.00 :	  1253ac:       c3                      retq   
    0.00 :	  1253ad:       0f 1f 00                nopl   (%rax)
    0.00 :	  1253b0:       f3 0f 6f 0e             movdqu (%rsi),%xmm1
    0.00 :	  1253b4:       48 8d 76 10             lea    0x10(%rsi),%rsi
    0.00 :	  1253b8:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  1253bd:       66 0f e7 0f             movntdq %xmm1,(%rdi)
    0.00 :	  1253c1:       48 8d 7f 10             lea    0x10(%rdi),%rdi
    0.00 :	  1253c5:       48 8d 92 70 ff ff ff    lea    -0x90(%rdx),%rdx
    0.00 :	  1253cc:       49 89 f1                mov    %rsi,%r9
    0.00 :	  1253cf:       49 29 f9                sub    %rdi,%r9
    0.00 :	  1253d2:       49 39 d1                cmp    %rdx,%r9
    0.00 :	  1253d5:       73 0d                   jae    1253e4 <__memmove_ssse3+0x2834>
    0.00 :	  1253d7:       48 c1 e1 02             shl    $0x2,%rcx
    0.00 :	  1253db:       48 39 ca                cmp    %rcx,%rdx
    0.00 :	  1253de:       0f 82 cc 00 00 00       jb     1254b0 <__memmove_ssse3+0x2900>
    0.00 :	  1253e4:       f3 0f 6f 06             movdqu (%rsi),%xmm0
    0.00 :	  1253e8:       f3 0f 6f 4e 10          movdqu 0x10(%rsi),%xmm1
    0.00 :	  1253ed:       f3 0f 6f 56 20          movdqu 0x20(%rsi),%xmm2
    0.00 :	  1253f2:       f3 0f 6f 5e 30          movdqu 0x30(%rsi),%xmm3
    0.00 :	  1253f7:       f3 0f 6f 66 40          movdqu 0x40(%rsi),%xmm4
    0.00 :	  1253fc:       f3 0f 6f 6e 50          movdqu 0x50(%rsi),%xmm5
    0.00 :	  125401:       f3 0f 6f 76 60          movdqu 0x60(%rsi),%xmm6
    0.00 :	  125406:       f3 0f 6f 7e 70          movdqu 0x70(%rsi),%xmm7
    0.00 :	  12540b:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	  125412:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  125419:       66 0f e7 07             movntdq %xmm0,(%rdi)
    0.00 :	  12541d:       66 0f e7 4f 10          movntdq %xmm1,0x10(%rdi)
    0.00 :	  125422:       66 0f e7 57 20          movntdq %xmm2,0x20(%rdi)
    0.00 :	  125427:       66 0f e7 5f 30          movntdq %xmm3,0x30(%rdi)
    0.00 :	  12542c:       66 0f e7 67 40          movntdq %xmm4,0x40(%rdi)
    0.00 :	  125431:       66 0f e7 6f 50          movntdq %xmm5,0x50(%rdi)
    0.00 :	  125436:       66 0f e7 77 60          movntdq %xmm6,0x60(%rdi)
    0.00 :	  12543b:       66 0f e7 7f 70          movntdq %xmm7,0x70(%rdi)
    0.00 :	  125440:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	  125447:       73 9b                   jae    1253e4 <__memmove_ssse3+0x2834>
    0.00 :	  125449:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  12544d:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  125454:       7c 32                   jl     125488 <__memmove_ssse3+0x28d8>
    0.00 :	  125456:       f3 0f 6f 06             movdqu (%rsi),%xmm0
    0.00 :	  12545a:       f3 0f 6f 4e 10          movdqu 0x10(%rsi),%xmm1
    0.00 :	  12545f:       f3 0f 6f 56 20          movdqu 0x20(%rsi),%xmm2
    0.00 :	  125464:       f3 0f 6f 5e 30          movdqu 0x30(%rsi),%xmm3
    0.00 :	  125469:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  12546d:       66 0f e7 07             movntdq %xmm0,(%rdi)
    0.00 :	  125471:       66 0f e7 4f 10          movntdq %xmm1,0x10(%rdi)
    0.00 :	  125476:       66 0f e7 57 20          movntdq %xmm2,0x20(%rdi)
    0.00 :	  12547b:       66 0f e7 5f 30          movntdq %xmm3,0x30(%rdi)
    0.00 :	  125480:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  125484:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  125488:       48 01 d6                add    %rdx,%rsi
    0.00 :	  12548b:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12548e:       0f ae f8                sfence 
    0.00 :	  125491:       4c 8d 1d 08 ee 01 00    lea    0x1ee08(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  125498:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12549c:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  1254a0:       ff e2                   jmpq   *%rdx
    0.00 :	  1254a2:       0f 0b                   ud2    
    0.00 :	  1254a4:       66 66 66 2e 0f 1f 84    data32 data32 nopw %cs:0x0(%rax,%rax,1)
    0.00 :	  1254ab:       00 00 00 00 00 
    0.00 :	  1254b0:       0f 18 8e c0 01 00 00    prefetcht0 0x1c0(%rsi)
    0.00 :	  1254b7:       0f 18 8e 00 02 00 00    prefetcht0 0x200(%rsi)
    0.00 :	  1254be:       f3 0f 6f 06             movdqu (%rsi),%xmm0
    0.00 :	  1254c2:       f3 0f 6f 4e 10          movdqu 0x10(%rsi),%xmm1
    0.00 :	  1254c7:       f3 0f 6f 56 20          movdqu 0x20(%rsi),%xmm2
    0.00 :	  1254cc:       f3 0f 6f 5e 30          movdqu 0x30(%rsi),%xmm3
    0.00 :	  1254d1:       f3 0f 6f 66 40          movdqu 0x40(%rsi),%xmm4
    0.00 :	  1254d6:       f3 0f 6f 6e 50          movdqu 0x50(%rsi),%xmm5
    0.00 :	  1254db:       f3 0f 6f 76 60          movdqu 0x60(%rsi),%xmm6
    0.00 :	  1254e0:       f3 0f 6f 7e 70          movdqu 0x70(%rsi),%xmm7
    0.00 :	  1254e5:       48 8d b6 80 00 00 00    lea    0x80(%rsi),%rsi
    0.00 :	  1254ec:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  1254f3:       0f 29 07                movaps %xmm0,(%rdi)
    0.00 :	  1254f6:       0f 29 4f 10             movaps %xmm1,0x10(%rdi)
    0.00 :	  1254fa:       0f 29 57 20             movaps %xmm2,0x20(%rdi)
    0.00 :	  1254fe:       0f 29 5f 30             movaps %xmm3,0x30(%rdi)
    0.00 :	  125502:       0f 29 67 40             movaps %xmm4,0x40(%rdi)
    0.00 :	  125506:       0f 29 6f 50             movaps %xmm5,0x50(%rdi)
    0.00 :	  12550a:       0f 29 77 60             movaps %xmm6,0x60(%rdi)
    0.00 :	  12550e:       0f 29 7f 70             movaps %xmm7,0x70(%rdi)
    0.00 :	  125512:       48 8d bf 80 00 00 00    lea    0x80(%rdi),%rdi
    0.00 :	  125519:       73 95                   jae    1254b0 <__memmove_ssse3+0x2900>
    0.00 :	  12551b:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  12551f:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  125526:       7c 2e                   jl     125556 <__memmove_ssse3+0x29a6>
    0.00 :	  125528:       f3 0f 6f 06             movdqu (%rsi),%xmm0
    0.00 :	  12552c:       f3 0f 6f 4e 10          movdqu 0x10(%rsi),%xmm1
    0.00 :	  125531:       f3 0f 6f 56 20          movdqu 0x20(%rsi),%xmm2
    0.00 :	  125536:       f3 0f 6f 5e 30          movdqu 0x30(%rsi),%xmm3
    0.00 :	  12553b:       48 8d 76 40             lea    0x40(%rsi),%rsi
    0.00 :	  12553f:       0f 29 07                movaps %xmm0,(%rdi)
    0.00 :	  125542:       0f 29 4f 10             movaps %xmm1,0x10(%rdi)
    0.00 :	  125546:       0f 29 57 20             movaps %xmm2,0x20(%rdi)
    0.00 :	  12554a:       0f 29 5f 30             movaps %xmm3,0x30(%rdi)
    0.00 :	  12554e:       48 8d 7f 40             lea    0x40(%rdi),%rdi
    0.00 :	  125552:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  125556:       48 01 d6                add    %rdx,%rsi
    0.00 :	  125559:       48 01 d7                add    %rdx,%rdi
    0.00 :	  12555c:       4c 8d 1d 3d ed 01 00    lea    0x1ed3d(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  125563:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  125567:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  12556b:       ff e2                   jmpq   *%rdx
    0.00 :	  12556d:       0f 0b                   ud2    
    0.00 :	  12556f:       90                      nop
    0.00 :	  125570:       f3 0f 6f 4e f0          movdqu -0x10(%rsi),%xmm1
    0.00 :	  125575:       48 8d 76 f0             lea    -0x10(%rsi),%rsi
    0.00 :	  125579:       f3 41 0f 7f 00          movdqu %xmm0,(%r8)
    0.00 :	  12557e:       66 0f 7f 4f f0          movdqa %xmm1,-0x10(%rdi)
    0.00 :	  125583:       48 8d 7f f0             lea    -0x10(%rdi),%rdi
    0.00 :	  125587:       48 8d 92 70 ff ff ff    lea    -0x90(%rdx),%rdx
    0.00 :	  12558e:       49 89 f9                mov    %rdi,%r9
    0.00 :	  125591:       49 29 f1                sub    %rsi,%r9
    0.00 :	  125594:       49 39 d1                cmp    %rdx,%r9
    0.00 :	  125597:       73 09                   jae    1255a2 <__memmove_ssse3+0x29f2>
    0.00 :	  125599:       49 39 c9                cmp    %rcx,%r9
    0.00 :	  12559c:       0f 82 be 00 00 00       jb     125660 <__memmove_ssse3+0x2ab0>
    0.00 :	  1255a2:       f3 0f 6f 46 f0          movdqu -0x10(%rsi),%xmm0
    0.00 :	  1255a7:       f3 0f 6f 4e e0          movdqu -0x20(%rsi),%xmm1
    0.00 :	  1255ac:       f3 0f 6f 56 d0          movdqu -0x30(%rsi),%xmm2
    0.00 :	  1255b1:       f3 0f 6f 5e c0          movdqu -0x40(%rsi),%xmm3
    0.00 :	  1255b6:       f3 0f 6f 66 b0          movdqu -0x50(%rsi),%xmm4
    0.00 :	  1255bb:       f3 0f 6f 6e a0          movdqu -0x60(%rsi),%xmm5
    0.00 :	  1255c0:       f3 0f 6f 76 90          movdqu -0x70(%rsi),%xmm6
    0.00 :	  1255c5:       f3 0f 6f 7e 80          movdqu -0x80(%rsi),%xmm7
    0.00 :	  1255ca:       48 8d 76 80             lea    -0x80(%rsi),%rsi
    0.00 :	  1255ce:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  1255d5:       66 0f e7 47 f0          movntdq %xmm0,-0x10(%rdi)
    0.00 :	  1255da:       66 0f e7 4f e0          movntdq %xmm1,-0x20(%rdi)
    0.00 :	  1255df:       66 0f e7 57 d0          movntdq %xmm2,-0x30(%rdi)
    0.00 :	  1255e4:       66 0f e7 5f c0          movntdq %xmm3,-0x40(%rdi)
    0.00 :	  1255e9:       66 0f e7 67 b0          movntdq %xmm4,-0x50(%rdi)
    0.00 :	  1255ee:       66 0f e7 6f a0          movntdq %xmm5,-0x60(%rdi)
    0.00 :	  1255f3:       66 0f e7 77 90          movntdq %xmm6,-0x70(%rdi)
    0.00 :	  1255f8:       66 0f e7 7f 80          movntdq %xmm7,-0x80(%rdi)
    0.00 :	  1255fd:       48 8d 7f 80             lea    -0x80(%rdi),%rdi
    0.00 :	  125601:       73 9f                   jae    1255a2 <__memmove_ssse3+0x29f2>
    0.00 :	  125603:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  125607:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  12560e:       7c 34                   jl     125644 <__memmove_ssse3+0x2a94>
    0.00 :	  125610:       f3 0f 6f 46 f0          movdqu -0x10(%rsi),%xmm0
    0.00 :	  125615:       f3 0f 6f 4e e0          movdqu -0x20(%rsi),%xmm1
    0.00 :	  12561a:       f3 0f 6f 56 d0          movdqu -0x30(%rsi),%xmm2
    0.00 :	  12561f:       f3 0f 6f 5e c0          movdqu -0x40(%rsi),%xmm3
    0.00 :	  125624:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  125628:       66 0f e7 47 f0          movntdq %xmm0,-0x10(%rdi)
    0.00 :	  12562d:       66 0f e7 4f e0          movntdq %xmm1,-0x20(%rdi)
    0.00 :	  125632:       66 0f e7 57 d0          movntdq %xmm2,-0x30(%rdi)
    0.00 :	  125637:       66 0f e7 5f c0          movntdq %xmm3,-0x40(%rdi)
    0.00 :	  12563c:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  125640:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  125644:       0f ae f8                sfence 
    0.00 :	  125647:       4c 8d 1d 52 ec 01 00    lea    0x1ec52(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  12564e:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  125652:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  125656:       ff e2                   jmpq   *%rdx
    0.00 :	  125658:       0f 0b                   ud2    
    0.00 :	  12565a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  125660:       0f 18 8e 40 fe ff ff    prefetcht0 -0x1c0(%rsi)
    0.00 :	  125667:       0f 18 8e 00 fe ff ff    prefetcht0 -0x200(%rsi)
    0.00 :	  12566e:       f3 0f 6f 46 f0          movdqu -0x10(%rsi),%xmm0
    0.00 :	  125673:       f3 0f 6f 4e e0          movdqu -0x20(%rsi),%xmm1
    0.00 :	  125678:       f3 0f 6f 56 d0          movdqu -0x30(%rsi),%xmm2
    0.00 :	  12567d:       f3 0f 6f 5e c0          movdqu -0x40(%rsi),%xmm3
    0.00 :	  125682:       f3 0f 6f 66 b0          movdqu -0x50(%rsi),%xmm4
    0.00 :	  125687:       f3 0f 6f 6e a0          movdqu -0x60(%rsi),%xmm5
    0.00 :	  12568c:       f3 0f 6f 76 90          movdqu -0x70(%rsi),%xmm6
    0.00 :	  125691:       f3 0f 6f 7e 80          movdqu -0x80(%rsi),%xmm7
    0.00 :	  125696:       48 8d 76 80             lea    -0x80(%rsi),%rsi
    0.00 :	  12569a:       48 81 ea 80 00 00 00    sub    $0x80,%rdx
    0.00 :	  1256a1:       0f 29 47 f0             movaps %xmm0,-0x10(%rdi)
    0.00 :	  1256a5:       0f 29 4f e0             movaps %xmm1,-0x20(%rdi)
    0.00 :	  1256a9:       0f 29 57 d0             movaps %xmm2,-0x30(%rdi)
    0.00 :	  1256ad:       0f 29 5f c0             movaps %xmm3,-0x40(%rdi)
    0.00 :	  1256b1:       0f 29 67 b0             movaps %xmm4,-0x50(%rdi)
    0.00 :	  1256b5:       0f 29 6f a0             movaps %xmm5,-0x60(%rdi)
    0.00 :	  1256b9:       0f 29 77 90             movaps %xmm6,-0x70(%rdi)
    0.00 :	  1256bd:       0f 29 7f 80             movaps %xmm7,-0x80(%rdi)
    0.00 :	  1256c1:       48 8d 7f 80             lea    -0x80(%rdi),%rdi
    0.00 :	  1256c5:       73 99                   jae    125660 <__memmove_ssse3+0x2ab0>
    0.00 :	  1256c7:       48 83 fa c0             cmp    $0xffffffffffffffc0,%rdx
    0.00 :	  1256cb:       48 8d 92 80 00 00 00    lea    0x80(%rdx),%rdx
    0.00 :	  1256d2:       7c 30                   jl     125704 <__memmove_ssse3+0x2b54>
    0.00 :	  1256d4:       f3 0f 6f 46 f0          movdqu -0x10(%rsi),%xmm0
    0.00 :	  1256d9:       f3 0f 6f 4e e0          movdqu -0x20(%rsi),%xmm1
    0.00 :	  1256de:       f3 0f 6f 56 d0          movdqu -0x30(%rsi),%xmm2
    0.00 :	  1256e3:       f3 0f 6f 5e c0          movdqu -0x40(%rsi),%xmm3
    0.00 :	  1256e8:       48 8d 76 c0             lea    -0x40(%rsi),%rsi
    0.00 :	  1256ec:       0f 29 47 f0             movaps %xmm0,-0x10(%rdi)
    0.00 :	  1256f0:       0f 29 4f e0             movaps %xmm1,-0x20(%rdi)
    0.00 :	  1256f4:       0f 29 57 d0             movaps %xmm2,-0x30(%rdi)
    0.00 :	  1256f8:       0f 29 5f c0             movaps %xmm3,-0x40(%rdi)
    0.00 :	  1256fc:       48 8d 7f c0             lea    -0x40(%rdi),%rdi
    0.00 :	  125700:       48 83 ea 40             sub    $0x40,%rdx
    0.00 :	  125704:       4c 8d 1d 95 eb 01 00    lea    0x1eb95(%rip),%r11        # 1442a0 <null+0x760>
    0.00 :	  12570b:       49 63 14 93             movslq (%r11,%rdx,4),%rdx
    0.00 :	  12570f:       49 8d 14 13             lea    (%r11,%rdx,1),%rdx
    0.00 :	  125713:       ff e2                   jmpq   *%rdx
    0.00 :	  125715:       0f 0b                   ud2    

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:577
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:584
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a9050 <_bt_getbuf>:
         :	 *              (ie, the buffer is "locked and pinned").  Also, we apply
         :	 *              _bt_checkpage to sanity-check the page (except in P_NEW case).
         :	 */
         :	Buffer
         :	_bt_getbuf(Relation rel, BlockNumber blkno, int access)
         :	{
    0.00 :	  4a9050:       55                      push   %rbp
    0.00 :	  4a9051:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a9054:       41 56                   push   %r14
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:577
   50.00 :	  4a9056:       49 89 fe                mov    %rdi,%r14
    0.00 :	  4a9059:       41 55                   push   %r13
    0.00 :	  4a905b:       41 54                   push   %r12
    0.00 :	  4a905d:       53                      push   %rbx
    0.00 :	  4a905e:       89 d3                   mov    %edx,%ebx
    0.00 :	  4a9060:       48 83 ec 40             sub    $0x40,%rsp
         :	        Buffer          buf;
         :
         :	        if (blkno != P_NEW)
    0.00 :	  4a9064:       83 fe ff                cmp    $0xffffffff,%esi
    0.00 :	  4a9067:       74 5c                   je     4a90c5 <_bt_getbuf+0x75>
         :	        {
         :	                /* Read an existing block of the relation */
         :	                buf = ReadBuffer(rel, blkno);
    0.00 :	  4a9069:       e8 32 d6 1c 00          callq  6766a0 <ReadBuffer>
         :	                LockBuffer(buf, access);
    0.00 :	  4a906e:       89 de                   mov    %ebx,%esi
         :	        Buffer          buf;
         :
         :	        if (blkno != P_NEW)
         :	        {
         :	                /* Read an existing block of the relation */
         :	                buf = ReadBuffer(rel, blkno);
    0.00 :	  4a9070:       41 89 c4                mov    %eax,%r12d
         :	                LockBuffer(buf, access);
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:584
   50.00 :	  4a9073:       89 c7                   mov    %eax,%edi
    0.00 :	  4a9075:       e8 96 b6 1c 00          callq  674710 <LockBuffer>
         :	                _bt_checkpage(rel, buf);
    0.00 :	  4a907a:       44 89 e6                mov    %r12d,%esi
    0.00 :	  4a907d:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a9080:       e8 4b fa ff ff          callq  4a8ad0 <_bt_checkpage>
         :	                _bt_pageinit(page, BufferGetPageSize(buf));
         :	        }
         :
         :	        /* ref count and lock type are correct */
         :	        return buf;
         :	}
    0.00 :	  4a9085:       48 83 c4 40             add    $0x40,%rsp
    0.00 :	  4a9089:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4a908c:       5b                      pop    %rbx
    0.00 :	  4a908d:       41 5c                   pop    %r12
    0.00 :	  4a908f:       41 5d                   pop    %r13
    0.00 :	  4a9091:       41 5e                   pop    %r14
    0.00 :	  4a9093:       c9                      leaveq 
    0.00 :	  4a9094:       c3                      retq   
    0.00 :	  4a9095:       0f 1f 00                nopl   (%rax)
         :	                                elog(DEBUG2, "FSM returned nonrecyclable page");
         :	                                _bt_relbuf(rel, buf);
         :	                        }
         :	                        else
         :	                        {
         :	                                elog(DEBUG2, "FSM returned nonlockable page");
    0.00 :	  4a9098:       ba f9 46 7b 00          mov    $0x7b46f9,%edx
    0.00 :	  4a909d:       be 8a 02 00 00          mov    $0x28a,%esi
    0.00 :	  4a90a2:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4a90a7:       e8 74 23 2d 00          callq  77b420 <elog_start>
    0.00 :	  4a90ac:       bf 0d 00 00 00          mov    $0xd,%edi
    0.00 :	  4a90b1:       be 2c 43 7b 00          mov    $0x7b432c,%esi
    0.00 :	  4a90b6:       31 c0                   xor    %eax,%eax
    0.00 :	  4a90b8:       e8 73 21 2d 00          callq  77b230 <elog_finish>
         :	                                /* couldn't get lock, so just drop pin */
         :	                                ReleaseBuffer(buf);
    0.00 :	  4a90bd:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4a90c0:       e8 9b bd 1c 00          callq  674e60 <ReleaseBuffer>
         :	                 * wrong, the worst consequence is the page will be lost to use till
         :	                 * the next VACUUM, which is no big problem.)
         :	                 */
         :	                for (;;)
         :	                {
         :	                        blkno = GetFreeIndexPage(rel);
    0.00 :	  4a90c5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a90c8:       e8 d3 3c 1d 00          callq  67cda0 <GetFreeIndexPage>
         :	                        if (blkno == InvalidBlockNumber)
    0.00 :	  4a90cd:       83 f8 ff                cmp    $0xffffffff,%eax
         :	                 * wrong, the worst consequence is the page will be lost to use till
         :	                 * the next VACUUM, which is no big problem.)
         :	                 */
         :	                for (;;)
         :	                {
         :	                        blkno = GetFreeIndexPage(rel);
    0.00 :	  4a90d0:       41 89 c5                mov    %eax,%r13d
         :	                        if (blkno == InvalidBlockNumber)
    0.00 :	  4a90d3:       0f 84 d7 00 00 00       je     4a91b0 <_bt_getbuf+0x160>
         :	                                break;
         :	                        buf = ReadBuffer(rel, blkno);
    0.00 :	  4a90d9:       89 c6                   mov    %eax,%esi
    0.00 :	  4a90db:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a90de:       e8 bd d5 1c 00          callq  6766a0 <ReadBuffer>
         :	                        if (ConditionalLockBuffer(buf))
    0.00 :	  4a90e3:       89 c7                   mov    %eax,%edi
         :	                for (;;)
         :	                {
         :	                        blkno = GetFreeIndexPage(rel);
         :	                        if (blkno == InvalidBlockNumber)
         :	                                break;
         :	                        buf = ReadBuffer(rel, blkno);
    0.00 :	  4a90e5:       41 89 c4                mov    %eax,%r12d
         :	                        if (ConditionalLockBuffer(buf))
    0.00 :	  4a90e8:       e8 c3 b6 1c 00          callq  6747b0 <ConditionalLockBuffer>
    0.00 :	  4a90ed:       84 c0                   test   %al,%al
    0.00 :	  4a90ef:       74 a7                   je     4a9098 <_bt_getbuf+0x48>
         :	                        {
         :	                                page = BufferGetPage(buf);
    0.00 :	  4a90f1:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4a90f4:       78 52                   js     4a9148 <_bt_getbuf+0xf8>
    0.00 :	  4a90f6:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4a90fb:       48 63 d8                movslq %eax,%rbx
    0.00 :	  4a90fe:       48 c1 e3 0d             shl    $0xd,%rbx
    0.00 :	  4a9102:       48 03 1d ef 69 71 00    add    0x7169ef(%rip),%rbx        # bbfaf8 <BufferBlocks>
         :	                                if (_bt_page_recyclable(page))
    0.00 :	  4a9109:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4a910c:       e8 ff fd ff ff          callq  4a8f10 <_bt_page_recyclable>
    0.00 :	  4a9111:       84 c0                   test   %al,%al
    0.00 :	  4a9113:       75 51                   jne    4a9166 <_bt_getbuf+0x116>
         :
         :	                                        /* Okay to use page.  Re-initialize and return it */
         :	                                        _bt_pageinit(page, BufferGetPageSize(buf));
         :	                                        return buf;
         :	                                }
         :	                                elog(DEBUG2, "FSM returned nonrecyclable page");
    0.00 :	  4a9115:       ba f9 46 7b 00          mov    $0x7b46f9,%edx
    0.00 :	  4a911a:       be 85 02 00 00          mov    $0x285,%esi
    0.00 :	  4a911f:       bf 22 43 7b 00          mov    $0x7b4322,%edi
    0.00 :	  4a9124:       e8 f7 22 2d 00          callq  77b420 <elog_start>
    0.00 :	  4a9129:       be 68 43 7b 00          mov    $0x7b4368,%esi
    0.00 :	  4a912e:       bf 0d 00 00 00          mov    $0xd,%edi
    0.00 :	  4a9133:       31 c0                   xor    %eax,%eax
    0.00 :	  4a9135:       e8 f6 20 2d 00          callq  77b230 <elog_finish>
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4a913a:       44 89 e7                mov    %r12d,%edi
    0.00 :	  4a913d:       e8 ee bd 1c 00          callq  674f30 <UnlockReleaseBuffer>
    0.00 :	  4a9142:       eb 81                   jmp    4a90c5 <_bt_getbuf+0x75>
    0.00 :	  4a9144:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        if (blkno == InvalidBlockNumber)
         :	                                break;
         :	                        buf = ReadBuffer(rel, blkno);
         :	                        if (ConditionalLockBuffer(buf))
         :	                        {
         :	                                page = BufferGetPage(buf);
    0.00 :	  4a9148:       48 8b 15 c9 3f 6d 00    mov    0x6d3fc9(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4a914f:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4a9152:       f7 d0                   not    %eax
    0.00 :	  4a9154:       48 98                   cltq   
    0.00 :	  4a9156:       48 8b 1c c2             mov    (%rdx,%rax,8),%rbx
         :	                                if (_bt_page_recyclable(page))
    0.00 :	  4a915a:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4a915d:       e8 ae fd ff ff          callq  4a8f10 <_bt_page_recyclable>
    0.00 :	  4a9162:       84 c0                   test   %al,%al
    0.00 :	  4a9164:       74 af                   je     4a9115 <_bt_getbuf+0xc5>
         :	                                        /*
         :	                                         * If we are generating WAL for Hot Standby then create a
         :	                                         * WAL record that will allow us to conflict with queries
         :	                                         * running on standby.
         :	                                         */
         :	                                        if (XLogStandbyInfoActive())
    0.00 :	  4a9166:       83 3d ef ff 6c 00 01    cmpl   $0x1,0x6cffef(%rip)        # b7915c <wal_level>
    0.00 :	  4a916d:       7e 16                   jle    4a9185 <_bt_getbuf+0x135>
         :	                                        {
         :	                                                BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);
         :
         :	                                                _bt_log_reuse_page(rel, blkno, opaque->btpo.xact);
    0.00 :	  4a916f:       0f b7 43 10             movzwl 0x10(%rbx),%eax
    0.00 :	  4a9173:       8b 54 03 08             mov    0x8(%rbx,%rax,1),%edx
         :	 * Log the reuse of a page from the FSM.
         :	 */
         :	static void
         :	_bt_log_reuse_page(Relation rel, BlockNumber blkno, TransactionId latestRemovedXid)
         :	{
         :	        if (!RelationNeedsWAL(rel))
    0.00 :	  4a9177:       49 8b 46 30             mov    0x30(%r14),%rax
    0.00 :	  4a917b:       80 78 6e 70             cmpb   $0x70,0x6e(%rax)
    0.00 :	  4a917f:       0f 84 df 00 00 00       je     4a9264 <_bt_getbuf+0x214>
         :	 * special space is zeroed out.
         :	 */
         :	void
         :	_bt_pageinit(Page page, Size size)
         :	{
         :	        PageInit(page, size, sizeof(BTPageOpaqueData));
    0.00 :	  4a9185:       48 89 df                mov    %rbx,%rdi
    0.00 :	  4a9188:       ba 10 00 00 00          mov    $0x10,%edx
    0.00 :	  4a918d:       be 00 20 00 00          mov    $0x2000,%esi
    0.00 :	  4a9192:       e8 a9 d0 1e 00          callq  696240 <PageInit>
         :	                _bt_pageinit(page, BufferGetPageSize(buf));
         :	        }
         :
         :	        /* ref count and lock type are correct */
         :	        return buf;
         :	}
    0.00 :	  4a9197:       48 83 c4 40             add    $0x40,%rsp
    0.00 :	  4a919b:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4a919e:       5b                      pop    %rbx
    0.00 :	  4a919f:       41 5c                   pop    %r12
    0.00 :	  4a91a1:       41 5d                   pop    %r13
    0.00 :	  4a91a3:       41 5e                   pop    %r14
    0.00 :	  4a91a5:       c9                      leaveq 
    0.00 :	  4a91a6:       c3                      retq   
    0.00 :	  4a91a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4a91ae:       00 00 
         :	                 * page.  We can skip locking for new or temp relations, however,
         :	                 * since no one else could be accessing them.
         :	                 */
         :	                needLock = !RELATION_IS_LOCAL(rel);
         :
         :	                if (needLock)
    0.00 :	  4a91b0:       48 b8 ff 00 00 00 ff    movabs $0xffffffff000000ff,%rax
    0.00 :	  4a91b7:       ff ff ff 
    0.00 :	  4a91ba:       49 85 46 20             test   %rax,0x20(%r14)
    0.00 :	  4a91be:       74 58                   je     4a9218 <_bt_getbuf+0x1c8>
         :	                        LockRelationForExtension(rel, ExclusiveLock);
         :
         :	                buf = ReadBuffer(rel, P_NEW);
    0.00 :	  4a91c0:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4a91c3:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a91c6:       e8 d5 d4 1c 00          callq  6766a0 <ReadBuffer>
         :
         :	                /* Acquire buffer lock on new page */
         :	                LockBuffer(buf, BT_WRITE);
    0.00 :	  4a91cb:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  4a91d0:       89 c7                   mov    %eax,%edi
         :	                needLock = !RELATION_IS_LOCAL(rel);
         :
         :	                if (needLock)
         :	                        LockRelationForExtension(rel, ExclusiveLock);
         :
         :	                buf = ReadBuffer(rel, P_NEW);
    0.00 :	  4a91d2:       41 89 c4                mov    %eax,%r12d
         :
         :	                /* Acquire buffer lock on new page */
         :	                LockBuffer(buf, BT_WRITE);
    0.00 :	  4a91d5:       e8 36 b5 1c 00          callq  674710 <LockBuffer>
         :	                 */
         :	                if (needLock)
         :	                        UnlockRelationForExtension(rel, ExclusiveLock);
         :
         :	                /* Initialize the new page before returning it */
         :	                page = BufferGetPage(buf);
    0.00 :	  4a91da:       45 85 e4                test   %r12d,%r12d
    0.00 :	  4a91dd:       78 71                   js     4a9250 <_bt_getbuf+0x200>
    0.00 :	  4a91df:       41 8d 44 24 ff          lea    -0x1(%r12),%eax
    0.00 :	  4a91e4:       48 63 f8                movslq %eax,%rdi
    0.00 :	  4a91e7:       48 c1 e7 0d             shl    $0xd,%rdi
    0.00 :	  4a91eb:       48 03 3d 06 69 71 00    add    0x716906(%rip),%rdi        # bbfaf8 <BufferBlocks>
         :	 * special space is zeroed out.
         :	 */
         :	void
         :	_bt_pageinit(Page page, Size size)
         :	{
         :	        PageInit(page, size, sizeof(BTPageOpaqueData));
    0.00 :	  4a91f2:       ba 10 00 00 00          mov    $0x10,%edx
    0.00 :	  4a91f7:       be 00 20 00 00          mov    $0x2000,%esi
    0.00 :	  4a91fc:       e8 3f d0 1e 00          callq  696240 <PageInit>
         :	                _bt_pageinit(page, BufferGetPageSize(buf));
         :	        }
         :
         :	        /* ref count and lock type are correct */
         :	        return buf;
         :	}
    0.00 :	  4a9201:       48 83 c4 40             add    $0x40,%rsp
    0.00 :	  4a9205:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4a9208:       5b                      pop    %rbx
    0.00 :	  4a9209:       41 5c                   pop    %r12
    0.00 :	  4a920b:       41 5d                   pop    %r13
    0.00 :	  4a920d:       41 5e                   pop    %r14
    0.00 :	  4a920f:       c9                      leaveq 
    0.00 :	  4a9210:       c3                      retq   
    0.00 :	  4a9211:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                 * since no one else could be accessing them.
         :	                 */
         :	                needLock = !RELATION_IS_LOCAL(rel);
         :
         :	                if (needLock)
         :	                        LockRelationForExtension(rel, ExclusiveLock);
    0.00 :	  4a9218:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a921b:       be 07 00 00 00          mov    $0x7,%esi
    0.00 :	  4a9220:       e8 1b ec 1d 00          callq  687e40 <LockRelationForExtension>
         :
         :	                buf = ReadBuffer(rel, P_NEW);
    0.00 :	  4a9225:       44 89 ee                mov    %r13d,%esi
    0.00 :	  4a9228:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a922b:       e8 70 d4 1c 00          callq  6766a0 <ReadBuffer>
         :
         :	                /* Acquire buffer lock on new page */
         :	                LockBuffer(buf, BT_WRITE);
    0.00 :	  4a9230:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  4a9235:       89 c7                   mov    %eax,%edi
         :	                needLock = !RELATION_IS_LOCAL(rel);
         :
         :	                if (needLock)
         :	                        LockRelationForExtension(rel, ExclusiveLock);
         :
         :	                buf = ReadBuffer(rel, P_NEW);
    0.00 :	  4a9237:       41 89 c4                mov    %eax,%r12d
         :
         :	                /* Acquire buffer lock on new page */
         :	                LockBuffer(buf, BT_WRITE);
    0.00 :	  4a923a:       e8 d1 b4 1c 00          callq  674710 <LockBuffer>
         :	                 * extend the relation some more.  Note that we cannot release this
         :	                 * lock before we have buffer lock on the new page, or we risk a race
         :	                 * condition against btvacuumscan --- see comments therein.
         :	                 */
         :	                if (needLock)
         :	                        UnlockRelationForExtension(rel, ExclusiveLock);
    0.00 :	  4a923f:       be 07 00 00 00          mov    $0x7,%esi
    0.00 :	  4a9244:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a9247:       e8 44 e9 1d 00          callq  687b90 <UnlockRelationForExtension>
    0.00 :	  4a924c:       eb 8c                   jmp    4a91da <_bt_getbuf+0x18a>
    0.00 :	  4a924e:       66 90                   xchg   %ax,%ax
         :
         :	                /* Initialize the new page before returning it */
         :	                page = BufferGetPage(buf);
    0.00 :	  4a9250:       44 89 e0                mov    %r12d,%eax
    0.00 :	  4a9253:       48 8b 15 be 3e 6d 00    mov    0x6d3ebe(%rip),%rdx        # b7d118 <LocalBufferBlockPointers>
    0.00 :	  4a925a:       f7 d0                   not    %eax
    0.00 :	  4a925c:       48 98                   cltq   
    0.00 :	  4a925e:       48 8b 3c c2             mov    (%rdx,%rax,8),%rdi
    0.00 :	  4a9262:       eb 8e                   jmp    4a91f2 <_bt_getbuf+0x1a2>
         :	{
         :	        if (!RelationNeedsWAL(rel))
         :	                return;
         :
         :	        /* No ereport(ERROR) until changes are logged */
         :	        START_CRIT_SECTION();
    0.00 :	  4a9264:       8b 05 32 0e 71 00       mov    0x710e32(%rip),%eax        # bba09c <CritSectionCount>
         :	                rdata[0].data = (char *) &xlrec_reuse;
         :	                rdata[0].len = SizeOfBtreeReusePage;
         :	                rdata[0].buffer = InvalidBuffer;
         :	                rdata[0].next = NULL;
         :
         :	                XLogInsert(RM_BTREE_ID, XLOG_BTREE_REUSE_PAGE, rdata);
    0.00 :	  4a926a:       be d0 00 00 00          mov    $0xd0,%esi
    0.00 :	  4a926f:       bf 0b 00 00 00          mov    $0xb,%edi
         :	{
         :	        if (!RelationNeedsWAL(rel))
         :	                return;
         :
         :	        /* No ereport(ERROR) until changes are logged */
         :	        START_CRIT_SECTION();
    0.00 :	  4a9274:       83 c0 01                add    $0x1,%eax
    0.00 :	  4a9277:       89 05 1f 0e 71 00       mov    %eax,0x710e1f(%rip)        # bba09c <CritSectionCount>
         :	        /* XLOG stuff */
         :	        {
         :	                XLogRecData rdata[1];
         :	                xl_btree_reuse_page xlrec_reuse;
         :
         :	                xlrec_reuse.node = rel->rd_node;
    0.00 :	  4a927d:       49 8b 06                mov    (%r14),%rax
    0.00 :	  4a9280:       48 89 45 c0             mov    %rax,-0x40(%rbp)
    0.00 :	  4a9284:       41 8b 46 08             mov    0x8(%r14),%eax
         :	                xlrec_reuse.block = blkno;
         :	                xlrec_reuse.latestRemovedXid = latestRemovedXid;
    0.00 :	  4a9288:       89 55 d0                mov    %edx,-0x30(%rbp)
         :	                rdata[0].data = (char *) &xlrec_reuse;
         :	                rdata[0].len = SizeOfBtreeReusePage;
         :	                rdata[0].buffer = InvalidBuffer;
         :	                rdata[0].next = NULL;
         :
         :	                XLogInsert(RM_BTREE_ID, XLOG_BTREE_REUSE_PAGE, rdata);
    0.00 :	  4a928b:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
         :	        {
         :	                XLogRecData rdata[1];
         :	                xl_btree_reuse_page xlrec_reuse;
         :
         :	                xlrec_reuse.node = rel->rd_node;
         :	                xlrec_reuse.block = blkno;
    0.00 :	  4a928f:       44 89 6d cc             mov    %r13d,-0x34(%rbp)
         :	                xlrec_reuse.latestRemovedXid = latestRemovedXid;
         :	                rdata[0].data = (char *) &xlrec_reuse;
         :	                rdata[0].len = SizeOfBtreeReusePage;
    0.00 :	  4a9293:       c7 45 a8 14 00 00 00    movl   $0x14,-0x58(%rbp)
         :	                rdata[0].buffer = InvalidBuffer;
    0.00 :	  4a929a:       c7 45 ac 00 00 00 00    movl   $0x0,-0x54(%rbp)
         :	        /* XLOG stuff */
         :	        {
         :	                XLogRecData rdata[1];
         :	                xl_btree_reuse_page xlrec_reuse;
         :
         :	                xlrec_reuse.node = rel->rd_node;
    0.00 :	  4a92a1:       89 45 c8                mov    %eax,-0x38(%rbp)
         :	                xlrec_reuse.block = blkno;
         :	                xlrec_reuse.latestRemovedXid = latestRemovedXid;
         :	                rdata[0].data = (char *) &xlrec_reuse;
    0.00 :	  4a92a4:       48 8d 45 c0             lea    -0x40(%rbp),%rax
         :	                rdata[0].len = SizeOfBtreeReusePage;
         :	                rdata[0].buffer = InvalidBuffer;
         :	                rdata[0].next = NULL;
    0.00 :	  4a92a8:       48 c7 45 b8 00 00 00    movq   $0x0,-0x48(%rbp)
    0.00 :	  4a92af:       00 
         :	                xl_btree_reuse_page xlrec_reuse;
         :
         :	                xlrec_reuse.node = rel->rd_node;
         :	                xlrec_reuse.block = blkno;
         :	                xlrec_reuse.latestRemovedXid = latestRemovedXid;
         :	                rdata[0].data = (char *) &xlrec_reuse;
    0.00 :	  4a92b0:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	                rdata[0].len = SizeOfBtreeReusePage;
         :	                rdata[0].buffer = InvalidBuffer;
         :	                rdata[0].next = NULL;
         :
         :	                XLogInsert(RM_BTREE_ID, XLOG_BTREE_REUSE_PAGE, rdata);
    0.00 :	  4a92b4:       e8 67 bc 02 00          callq  4d4f20 <XLogInsert>
         :	                 * We don't do PageSetLSN here because we're about to initialise the
         :	                 * page, so no need.
         :	                 */
         :	        }
         :
         :	        END_CRIT_SECTION();
    0.00 :	  4a92b9:       8b 05 dd 0d 71 00       mov    0x710ddd(%rip),%eax        # bba09c <CritSectionCount>
    0.00 :	  4a92bf:       83 e8 01                sub    $0x1,%eax
    0.00 :	  4a92c2:       89 05 d4 0d 71 00       mov    %eax,0x710dd4(%rip)        # bba09c <CritSectionCount>
    0.00 :	  4a92c8:       e9 b8 fe ff ff          jmpq   4a9185 <_bt_getbuf+0x135>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execAmi.c:262
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execAmi.c:157
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005a84a0 <ExecReScan>:
         :	 * Note that if the plan node has parameters that have changed value,
         :	 * the output might be different from last time.
         :	 */
         :	void
         :	ExecReScan(PlanState *node)
         :	{
    0.00 :	  5a84a0:       55                      push   %rbp
    0.00 :	  5a84a1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5a84a4:       41 56                   push   %r14
    0.00 :	  5a84a6:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5a84a9:       41 55                   push   %r13
    0.00 :	  5a84ab:       41 54                   push   %r12
    0.00 :	  5a84ad:       53                      push   %rbx
         :	        /* If collecting timing stats, update them */
         :	        if (node->instrument)
    0.00 :	  5a84ae:       48 8b 7f 18             mov    0x18(%rdi),%rdi
    0.00 :	  5a84b2:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5a84b5:       74 05                   je     5a84bc <ExecReScan+0x1c>
         :	                InstrEndLoop(node->instrument);
    0.00 :	  5a84b7:       e8 24 f6 00 00          callq  5b7ae0 <InstrEndLoop>
         :	         * the limited ways in which one InitPlan could depend on another, but
         :	         * eventually we might need to work harder (or else make the planner
         :	         * enlarge the extParam/allParam sets to include the params of depended-on
         :	         * InitPlans).
         :	         */
         :	        if (node->chgParam != NULL)
    0.00 :	  5a84bc:       49 83 7e 50 00          cmpq   $0x0,0x50(%r14)
    0.00 :	  5a84c1:       0f 84 b1 00 00 00       je     5a8578 <ExecReScan+0xd8>
         :	        {
         :	                ListCell   *l;
         :
         :	                foreach(l, node->initPlan)
    0.00 :	  5a84c7:       49 8b 46 40             mov    0x40(%r14),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5a84cb:       48 85 c0                test   %rax,%rax
    0.00 :	  5a84ce:       66 90                   xchg   %ax,%ax
    0.00 :	  5a84d0:       74 49                   je     5a851b <ExecReScan+0x7b>
    0.00 :	  5a84d2:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  5a84d6:       4d 85 e4                test   %r12,%r12
    0.00 :	  5a84d9:       74 40                   je     5a851b <ExecReScan+0x7b>
    0.00 :	  5a84db:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                {
         :	                        SubPlanState *sstate = (SubPlanState *) lfirst(l);
    0.00 :	  5a84e0:       4d 8b 2c 24             mov    (%r12),%r13
         :	                        PlanState  *splan = sstate->planstate;
    0.00 :	  5a84e4:       49 8b 5d 18             mov    0x18(%r13),%rbx
         :
         :	                        if (splan->plan->extParam != NULL)      /* don't care about child
    0.00 :	  5a84e8:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  5a84ec:       48 83 78 50 00          cmpq   $0x0,0x50(%rax)
    0.00 :	  5a84f1:       74 0c                   je     5a84ff <ExecReScan+0x5f>
         :	                                                                                                 * local Params */
         :	                                UpdateChangedParamSet(splan, node->chgParam);
    0.00 :	  5a84f3:       49 8b 76 50             mov    0x50(%r14),%rsi
    0.00 :	  5a84f7:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5a84fa:       e8 d1 c5 00 00          callq  5b4ad0 <UpdateChangedParamSet>
         :	                        if (splan->chgParam != NULL)
    0.00 :	  5a84ff:       48 83 7b 50 00          cmpq   $0x0,0x50(%rbx)
    0.00 :	  5a8504:       74 0b                   je     5a8511 <ExecReScan+0x71>
         :	                                ExecReScanSetParamPlan(sstate, node);
    0.00 :	  5a8506:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5a8509:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5a850c:       e8 2f fb 01 00          callq  5c8040 <ExecReScanSetParamPlan>
         :	         */
         :	        if (node->chgParam != NULL)
         :	        {
         :	                ListCell   *l;
         :
         :	                foreach(l, node->initPlan)
    0.00 :	  5a8511:       4d 8b 64 24 08          mov    0x8(%r12),%r12
    0.00 :	  5a8516:       4d 85 e4                test   %r12,%r12
    0.00 :	  5a8519:       75 c5                   jne    5a84e0 <ExecReScan+0x40>
         :	                                                                                                 * local Params */
         :	                                UpdateChangedParamSet(splan, node->chgParam);
         :	                        if (splan->chgParam != NULL)
         :	                                ExecReScanSetParamPlan(sstate, node);
         :	                }
         :	                foreach(l, node->subPlan)
    0.00 :	  5a851b:       49 8b 46 48             mov    0x48(%r14),%rax
    0.00 :	  5a851f:       48 85 c0                test   %rax,%rax
    0.00 :	  5a8522:       74 30                   je     5a8554 <ExecReScan+0xb4>
    0.00 :	  5a8524:       48 8b 58 08             mov    0x8(%rax),%rbx
    0.00 :	  5a8528:       48 85 db                test   %rbx,%rbx
    0.00 :	  5a852b:       74 27                   je     5a8554 <ExecReScan+0xb4>
    0.00 :	  5a852d:       0f 1f 00                nopl   (%rax)
         :	                {
         :	                        SubPlanState *sstate = (SubPlanState *) lfirst(l);
         :	                        PlanState  *splan = sstate->planstate;
    0.00 :	  5a8530:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  5a8533:       48 8b 78 18             mov    0x18(%rax),%rdi
         :
         :	                        if (splan->plan->extParam != NULL)
    0.00 :	  5a8537:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5a853b:       48 83 78 50 00          cmpq   $0x0,0x50(%rax)
    0.00 :	  5a8540:       74 09                   je     5a854b <ExecReScan+0xab>
         :	                                UpdateChangedParamSet(splan, node->chgParam);
    0.00 :	  5a8542:       49 8b 76 50             mov    0x50(%r14),%rsi
    0.00 :	  5a8546:       e8 85 c5 00 00          callq  5b4ad0 <UpdateChangedParamSet>
         :	                                                                                                 * local Params */
         :	                                UpdateChangedParamSet(splan, node->chgParam);
         :	                        if (splan->chgParam != NULL)
         :	                                ExecReScanSetParamPlan(sstate, node);
         :	                }
         :	                foreach(l, node->subPlan)
    0.00 :	  5a854b:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5a854f:       48 85 db                test   %rbx,%rbx
    0.00 :	  5a8552:       75 dc                   jne    5a8530 <ExecReScan+0x90>
         :
         :	                        if (splan->plan->extParam != NULL)
         :	                                UpdateChangedParamSet(splan, node->chgParam);
         :	                }
         :	                /* Well. Now set chgParam for left/right trees. */
         :	                if (node->lefttree != NULL)
    0.00 :	  5a8554:       49 8b 7e 30             mov    0x30(%r14),%rdi
    0.00 :	  5a8558:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5a855b:       74 09                   je     5a8566 <ExecReScan+0xc6>
         :	                        UpdateChangedParamSet(node->lefttree, node->chgParam);
    0.00 :	  5a855d:       49 8b 76 50             mov    0x50(%r14),%rsi
    0.00 :	  5a8561:       e8 6a c5 00 00          callq  5b4ad0 <UpdateChangedParamSet>
         :	                if (node->righttree != NULL)
    0.00 :	  5a8566:       49 8b 7e 38             mov    0x38(%r14),%rdi
    0.00 :	  5a856a:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5a856d:       74 09                   je     5a8578 <ExecReScan+0xd8>
         :	                        UpdateChangedParamSet(node->righttree, node->chgParam);
    0.00 :	  5a856f:       49 8b 76 50             mov    0x50(%r14),%rsi
    0.00 :	  5a8573:       e8 58 c5 00 00          callq  5b4ad0 <UpdateChangedParamSet>
         :	        }
         :
         :	        /* Shut down any SRFs in the plan node's targetlist */
         :	        if (node->ps_ExprContext)
    0.00 :	  5a8578:       49 8b 7e 60             mov    0x60(%r14),%rdi
    0.00 :	  5a857c:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5a857f:       74 05                   je     5a8586 <ExecReScan+0xe6>
         :	                ReScanExprContext(node->ps_ExprContext);
    0.00 :	  5a8581:       e8 fa cb 00 00          callq  5b5180 <ReScanExprContext>
         :
         :	        /* And do node-type-specific processing */
         :	        switch (nodeTag(node))
    0.00 :	  5a8586:       41 8b 06                mov    (%r14),%eax
    0.00 :	  5a8589:       2d c9 00 00 00          sub    $0xc9,%eax
    0.00 :	  5a858e:       83 f8 21                cmp    $0x21,%eax
    0.00 :	  5a8591:       76 2d                   jbe    5a85c0 <ExecReScan+0x120>
         :	                case T_LimitState:
         :	                        ExecReScanLimit((LimitState *) node);
         :	                        break;
         :
         :	                default:
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
    0.00 :	  5a8593:       ba 13 93 88 00          mov    $0x889313,%edx
    0.00 :	  5a8598:       be fd 00 00 00          mov    $0xfd,%esi
    0.00 :	  5a859d:       bf 08 8f 88 00          mov    $0x888f08,%edi
    0.00 :	  5a85a2:       e8 79 2e 1d 00          callq  77b420 <elog_start>
    0.00 :	  5a85a7:       41 8b 16                mov    (%r14),%edx
    0.00 :	  5a85aa:       be 5c 17 87 00          mov    $0x87175c,%esi
    0.00 :	  5a85af:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5a85b4:       31 c0                   xor    %eax,%eax
    0.00 :	  5a85b6:       e8 75 2c 1d 00          callq  77b230 <elog_finish>
    0.00 :	  5a85bb:       e8 10 0f ec ff          callq  4694d0 <abort@plt>
         :	        /* Shut down any SRFs in the plan node's targetlist */
         :	        if (node->ps_ExprContext)
         :	                ReScanExprContext(node->ps_ExprContext);
         :
         :	        /* And do node-type-specific processing */
         :	        switch (nodeTag(node))
    0.00 :	  5a85c0:       89 c0                   mov    %eax,%eax
    0.00 :	  5a85c2:       ff 24 c5 d0 91 88 00    jmpq   *0x8891d0(,%rax,8)
         :	                case T_LockRowsState:
         :	                        ExecReScanLockRows((LockRowsState *) node);
         :	                        break;
         :
         :	                case T_LimitState:
         :	                        ExecReScanLimit((LimitState *) node);
    0.00 :	  5a85c9:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a85cc:       e8 df 7a 01 00          callq  5c00b0 <ExecReScanLimit>
    0.00 :	  5a85d1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                default:
         :	                        elog(ERROR, "unrecognized node type: %d", (int) nodeTag(node));
         :	                        break;
         :	        }
         :
         :	        if (node->chgParam != NULL)
    0.00 :	  5a85d8:       49 8b 7e 50             mov    0x50(%r14),%rdi
    0.00 :	  5a85dc:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5a85df:       74 0d                   je     5a85ee <ExecReScan+0x14e>
         :	        {
         :	                bms_free(node->chgParam);
    0.00 :	  5a85e1:       e8 ca a7 03 00          callq  5e2db0 <bms_free>
         :	                node->chgParam = NULL;
    0.00 :	  5a85e6:       49 c7 46 50 00 00 00    movq   $0x0,0x50(%r14)
    0.00 :	  5a85ed:       00 
         :	        }
         :	}
    0.00 :	  5a85ee:       5b                      pop    %rbx
    0.00 :	  5a85ef:       41 5c                   pop    %r12
    0.00 :	  5a85f1:       41 5d                   pop    %r13
    0.00 :	  5a85f3:       41 5e                   pop    %r14
    0.00 :	  5a85f5:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execAmi.c:262
   50.00 :	  5a85f6:       c3                      retq   
         :	                case T_SetOpState:
         :	                        ExecReScanSetOp((SetOpState *) node);
         :	                        break;
         :
         :	                case T_LockRowsState:
         :	                        ExecReScanLockRows((LockRowsState *) node);
    0.00 :	  5a85f7:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a85fa:       e8 81 7e 01 00          callq  5c0480 <ExecReScanLockRows>
         :	                        break;
    0.00 :	  5a85ff:       eb d7                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_HashState:
         :	                        ExecReScanHash((HashState *) node);
         :	                        break;
         :
         :	                case T_SetOpState:
         :	                        ExecReScanSetOp((SetOpState *) node);
    0.00 :	  5a8601:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8604:       e8 97 d3 01 00          callq  5c59a0 <ExecReScanSetOp>
         :	                        break;
    0.00 :	  5a8609:       eb cd                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_UniqueState:
         :	                        ExecReScanUnique((UniqueState *) node);
         :	                        break;
         :
         :	                case T_HashState:
         :	                        ExecReScanHash((HashState *) node);
    0.00 :	  5a860b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a860e:       e8 fd 35 01 00          callq  5bbc10 <ExecReScanHash>
         :	                        break;
    0.00 :	  5a8613:       eb c3                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_WindowAggState:
         :	                        ExecReScanWindowAgg((WindowAggState *) node);
         :	                        break;
         :
         :	                case T_UniqueState:
         :	                        ExecReScanUnique((UniqueState *) node);
    0.00 :	  5a8615:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8618:       e8 83 de 01 00          callq  5c64a0 <ExecReScanUnique>
    0.00 :	  5a861d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8620:       eb b6                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_AggState:
         :	                        ExecReScanAgg((AggState *) node);
         :	                        break;
         :
         :	                case T_WindowAggState:
         :	                        ExecReScanWindowAgg((WindowAggState *) node);
    0.00 :	  5a8622:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8625:       e8 56 25 02 00          callq  5cab80 <ExecReScanWindowAgg>
    0.00 :	  5a862a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        break;
    0.00 :	  5a8630:       eb a6                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_GroupState:
         :	                        ExecReScanGroup((GroupState *) node);
         :	                        break;
         :
         :	                case T_AggState:
         :	                        ExecReScanAgg((AggState *) node);
    0.00 :	  5a8632:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8635:       e8 76 fe 00 00          callq  5b84b0 <ExecReScanAgg>
    0.00 :	  5a863a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        break;
    0.00 :	  5a8640:       eb 96                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_SortState:
         :	                        ExecReScanSort((SortState *) node);
         :	                        break;
         :
         :	                case T_GroupState:
         :	                        ExecReScanGroup((GroupState *) node);
    0.00 :	  5a8642:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8645:       e8 b6 e9 01 00          callq  5c7000 <ExecReScanGroup>
    0.00 :	  5a864a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        break;
    0.00 :	  5a8650:       eb 86                   jmp    5a85d8 <ExecReScan+0x138>
         :	                case T_MaterialState:
         :	                        ExecReScanMaterial((MaterialState *) node);
         :	                        break;
         :
         :	                case T_SortState:
         :	                        ExecReScanSort((SortState *) node);
    0.00 :	  5a8652:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8655:       e8 d6 da 01 00          callq  5c6130 <ExecReScanSort>
    0.00 :	  5a865a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        break;
    0.00 :	  5a8660:       e9 73 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_HashJoinState:
         :	                        ExecReScanHashJoin((HashJoinState *) node);
         :	                        break;
         :
         :	                case T_MaterialState:
         :	                        ExecReScanMaterial((MaterialState *) node);
    0.00 :	  5a8665:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8668:       e8 a3 84 01 00          callq  5c0b10 <ExecReScanMaterial>
    0.00 :	  5a866d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8670:       e9 63 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_MergeJoinState:
         :	                        ExecReScanMergeJoin((MergeJoinState *) node);
         :	                        break;
         :
         :	                case T_HashJoinState:
         :	                        ExecReScanHashJoin((HashJoinState *) node);
    0.00 :	  5a8675:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8678:       e8 e3 4d 01 00          callq  5bd460 <ExecReScanHashJoin>
    0.00 :	  5a867d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8680:       e9 53 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_NestLoopState:
         :	                        ExecReScanNestLoop((NestLoopState *) node);
         :	                        break;
         :
         :	                case T_MergeJoinState:
         :	                        ExecReScanMergeJoin((MergeJoinState *) node);
    0.00 :	  5a8685:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8688:       e8 73 8d 01 00          callq  5c1400 <ExecReScanMergeJoin>
    0.00 :	  5a868d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8690:       e9 43 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_ForeignScanState:
         :	                        ExecReScanForeignScan((ForeignScanState *) node);
         :	                        break;
         :
         :	                case T_NestLoopState:
         :	                        ExecReScanNestLoop((NestLoopState *) node);
    0.00 :	  5a8695:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8698:       e8 b3 b9 01 00          callq  5c4050 <ExecReScanNestLoop>
    0.00 :	  5a869d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86a0:       e9 33 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_WorkTableScanState:
         :	                        ExecReScanWorkTableScan((WorkTableScanState *) node);
         :	                        break;
         :
         :	                case T_ForeignScanState:
         :	                        ExecReScanForeignScan((ForeignScanState *) node);
    0.00 :	  5a86a5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86a8:       e8 13 11 02 00          callq  5c97c0 <ExecReScanForeignScan>
    0.00 :	  5a86ad:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86b0:       e9 23 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_CteScanState:
         :	                        ExecReScanCteScan((CteScanState *) node);
         :	                        break;
         :
         :	                case T_WorkTableScanState:
         :	                        ExecReScanWorkTableScan((WorkTableScanState *) node);
    0.00 :	  5a86b5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86b8:       e8 63 e7 01 00          callq  5c6e20 <ExecReScanWorkTableScan>
    0.00 :	  5a86bd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86c0:       e9 13 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_ValuesScanState:
         :	                        ExecReScanValuesScan((ValuesScanState *) node);
         :	                        break;
         :
         :	                case T_CteScanState:
         :	                        ExecReScanCteScan((CteScanState *) node);
    0.00 :	  5a86c5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86c8:       e8 43 e3 01 00          callq  5c6a10 <ExecReScanCteScan>
    0.00 :	  5a86cd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86d0:       e9 03 ff ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_FunctionScanState:
         :	                        ExecReScanFunctionScan((FunctionScanState *) node);
         :	                        break;
         :
         :	                case T_ValuesScanState:
         :	                        ExecReScanValuesScan((ValuesScanState *) node);
    0.00 :	  5a86d5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86d8:       e8 e3 df 01 00          callq  5c66c0 <ExecReScanValuesScan>
    0.00 :	  5a86dd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86e0:       e9 f3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_SubqueryScanState:
         :	                        ExecReScanSubqueryScan((SubqueryScanState *) node);
         :	                        break;
         :
         :	                case T_FunctionScanState:
         :	                        ExecReScanFunctionScan((FunctionScanState *) node);
    0.00 :	  5a86e5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86e8:       e8 73 be 01 00          callq  5c4560 <ExecReScanFunctionScan>
    0.00 :	  5a86ed:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a86f0:       e9 e3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_TidScanState:
         :	                        ExecReScanTidScan((TidScanState *) node);
         :	                        break;
         :
         :	                case T_SubqueryScanState:
         :	                        ExecReScanSubqueryScan((SubqueryScanState *) node);
    0.00 :	  5a86f5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a86f8:       e8 03 06 02 00          callq  5c8d00 <ExecReScanSubqueryScan>
    0.00 :	  5a86fd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8700:       e9 d3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_BitmapHeapScanState:
         :	                        ExecReScanBitmapHeapScan((BitmapHeapScanState *) node);
         :	                        break;
         :
         :	                case T_TidScanState:
         :	                        ExecReScanTidScan((TidScanState *) node);
    0.00 :	  5a8705:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8708:       e8 a3 09 02 00          callq  5c90b0 <ExecReScanTidScan>
    0.00 :	  5a870d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8710:       e9 c3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_BitmapIndexScanState:
         :	                        ExecReScanBitmapIndexScan((BitmapIndexScanState *) node);
         :	                        break;
         :
         :	                case T_BitmapHeapScanState:
         :	                        ExecReScanBitmapHeapScan((BitmapHeapScanState *) node);
    0.00 :	  5a8715:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8718:       e8 53 27 01 00          callq  5bae70 <ExecReScanBitmapHeapScan>
    0.00 :	  5a871d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8720:       e9 b3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_IndexOnlyScanState:
         :	                        ExecReScanIndexOnlyScan((IndexOnlyScanState *) node);
         :	                        break;
         :
         :	                case T_BitmapIndexScanState:
         :	                        ExecReScanBitmapIndexScan((BitmapIndexScanState *) node);
    0.00 :	  5a8725:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8728:       e8 93 31 01 00          callq  5bb8c0 <ExecReScanBitmapIndexScan>
    0.00 :	  5a872d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8730:       e9 a3 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_IndexScanState:
         :	                        ExecReScanIndexScan((IndexScanState *) node);
         :	                        break;
         :
         :	                case T_IndexOnlyScanState:
         :	                        ExecReScanIndexOnlyScan((IndexOnlyScanState *) node);
    0.00 :	  5a8735:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8738:       e8 b3 72 01 00          callq  5bf9f0 <ExecReScanIndexOnlyScan>
    0.00 :	  5a873d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8740:       e9 93 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_SeqScanState:
         :	                        ExecReScanSeqScan((SeqScanState *) node);
         :	                        break;
         :
         :	                case T_IndexScanState:
         :	                        ExecReScanIndexScan((IndexScanState *) node);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execAmi.c:157
   50.00 :	  5a8745:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8748:       e8 03 6d 01 00          callq  5bf450 <ExecReScanIndexScan>
    0.00 :	  5a874d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8750:       e9 83 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_BitmapOrState:
         :	                        ExecReScanBitmapOr((BitmapOrState *) node);
         :	                        break;
         :
         :	                case T_SeqScanState:
         :	                        ExecReScanSeqScan((SeqScanState *) node);
    0.00 :	  5a8755:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8758:       e8 33 d0 01 00          callq  5c5790 <ExecReScanSeqScan>
    0.00 :	  5a875d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8760:       e9 73 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_BitmapAndState:
         :	                        ExecReScanBitmapAnd((BitmapAndState *) node);
         :	                        break;
         :
         :	                case T_BitmapOrState:
         :	                        ExecReScanBitmapOr((BitmapOrState *) node);
    0.00 :	  5a8765:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8768:       e8 e3 21 01 00          callq  5ba950 <ExecReScanBitmapOr>
    0.00 :	  5a876d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8770:       e9 63 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_RecursiveUnionState:
         :	                        ExecReScanRecursiveUnion((RecursiveUnionState *) node);
         :	                        break;
         :
         :	                case T_BitmapAndState:
         :	                        ExecReScanBitmapAnd((BitmapAndState *) node);
    0.00 :	  5a8775:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8778:       e8 13 1f 01 00          callq  5ba690 <ExecReScanBitmapAnd>
    0.00 :	  5a877d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8780:       e9 53 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_MergeAppendState:
         :	                        ExecReScanMergeAppend((MergeAppendState *) node);
         :	                        break;
         :
         :	                case T_RecursiveUnionState:
         :	                        ExecReScanRecursiveUnion((RecursiveUnionState *) node);
    0.00 :	  5a8785:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8788:       e8 13 c8 01 00          callq  5c4fa0 <ExecReScanRecursiveUnion>
    0.00 :	  5a878d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a8790:       e9 43 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_AppendState:
         :	                        ExecReScanAppend((AppendState *) node);
         :	                        break;
         :
         :	                case T_MergeAppendState:
         :	                        ExecReScanMergeAppend((MergeAppendState *) node);
    0.00 :	  5a8795:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8798:       e8 63 87 01 00          callq  5c0f00 <ExecReScanMergeAppend>
    0.00 :	  5a879d:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a87a0:       e9 33 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_ModifyTableState:
         :	                        ExecReScanModifyTable((ModifyTableState *) node);
         :	                        break;
         :
         :	                case T_AppendState:
         :	                        ExecReScanAppend((AppendState *) node);
    0.00 :	  5a87a5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a87a8:       e8 f3 f8 00 00          callq  5b80a0 <ExecReScanAppend>
    0.00 :	  5a87ad:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a87b0:       e9 23 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :	                case T_ResultState:
         :	                        ExecReScanResult((ResultState *) node);
         :	                        break;
         :
         :	                case T_ModifyTableState:
         :	                        ExecReScanModifyTable((ModifyTableState *) node);
    0.00 :	  5a87b5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a87b8:       e8 e3 9f 01 00          callq  5c27a0 <ExecReScanModifyTable>
    0.00 :	  5a87bd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a87c0:       e9 13 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>
         :
         :	        /* And do node-type-specific processing */
         :	        switch (nodeTag(node))
         :	        {
         :	                case T_ResultState:
         :	                        ExecReScanResult((ResultState *) node);
    0.00 :	  5a87c5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a87c8:       e8 93 cc 01 00          callq  5c5460 <ExecReScanResult>
    0.00 :	  5a87cd:       0f 1f 00                nopl   (%rax)
         :	                        break;
    0.00 :	  5a87d0:       e9 03 fe ff ff          jmpq   5a85d8 <ExecReScan+0x138>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2792
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005acb20 <ExecEvalAnd>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalAnd(BoolExprState *andExpr, ExprContext *econtext,
         :	                        bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5acb20:       55                      push   %rbp
         :	        List       *clauses = andExpr->args;
         :	        ListCell   *clause;
         :	        bool            AnyNull;
         :
         :	        if (isDone)
    0.00 :	  5acb21:       48 85 c9                test   %rcx,%rcx
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalAnd(BoolExprState *andExpr, ExprContext *econtext,
         :	                        bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5acb24:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5acb27:       41 56                   push   %r14
    0.00 :	  5acb29:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5acb2c:       41 55                   push   %r13
    0.00 :	  5acb2e:       41 54                   push   %r12
    0.00 :	  5acb30:       49 89 d4                mov    %rdx,%r12
    0.00 :	  5acb33:       53                      push   %rbx
         :	        List       *clauses = andExpr->args;
    0.00 :	  5acb34:       48 8b 47 18             mov    0x18(%rdi),%rax
         :	        ListCell   *clause;
         :	        bool            AnyNull;
         :
         :	        if (isDone)
    0.00 :	  5acb38:       74 06                   je     5acb40 <ExecEvalAnd+0x20>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5acb3a:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5acb40:       48 85 c0                test   %rax,%rax
    0.00 :	  5acb43:       74 6b                   je     5acbb0 <ExecEvalAnd+0x90>
    0.00 :	  5acb45:       48 8b 58 08             mov    0x8(%rax),%rbx
         :	         * we return NULL; otherwise we return TRUE.  This makes sense when you
         :	         * interpret NULL as "don't know", using the same sort of reasoning as for
         :	         * OR, above.
         :	         */
         :
         :	        foreach(clause, clauses)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2792
  100.00 :	  5acb49:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acb4c:       74 62                   je     5acbb0 <ExecEvalAnd+0x90>
    0.00 :	  5acb4e:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5acb51:       eb 14                   jmp    5acb67 <ExecEvalAnd+0x47>
    0.00 :	  5acb53:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                clause_value = ExecEvalExpr(clausestate, econtext, isNull, NULL);
         :
         :	                /*
         :	                 * if we have a non-null false result, then return it.
         :	                 */
         :	                if (*isNull)
    0.00 :	  5acb58:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	         * we return NULL; otherwise we return TRUE.  This makes sense when you
         :	         * interpret NULL as "don't know", using the same sort of reasoning as for
         :	         * OR, above.
         :	         */
         :
         :	        foreach(clause, clauses)
    0.00 :	  5acb5e:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5acb62:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acb65:       74 29                   je     5acb90 <ExecEvalAnd+0x70>
         :	        {
         :	                ExprState  *clausestate = (ExprState *) lfirst(clause);
    0.00 :	  5acb67:       48 8b 03                mov    (%rbx),%rax
         :	                Datum           clause_value;
         :
         :	                clause_value = ExecEvalExpr(clausestate, econtext, isNull, NULL);
    0.00 :	  5acb6a:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5acb6c:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  5acb6f:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5acb72:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5acb75:       ff 50 10                callq  *0x10(%rax)
         :
         :	                /*
         :	                 * if we have a non-null false result, then return it.
         :	                 */
         :	                if (*isNull)
    0.00 :	  5acb78:       41 80 3c 24 00          cmpb   $0x0,(%r12)
    0.00 :	  5acb7d:       75 d9                   jne    5acb58 <ExecEvalAnd+0x38>
         :	                        AnyNull = true;         /* remember we got a null */
         :	                else if (!DatumGetBool(clause_value))
    0.00 :	  5acb7f:       84 c0                   test   %al,%al
    0.00 :	  5acb81:       75 db                   jne    5acb5e <ExecEvalAnd+0x3e>
         :	        }
         :
         :	        /* AnyNull is true if at least one clause evaluated to NULL */
         :	        *isNull = AnyNull;
         :	        return BoolGetDatum(!AnyNull);
         :	}
    0.00 :	  5acb83:       5b                      pop    %rbx
    0.00 :	  5acb84:       41 5c                   pop    %r12
    0.00 :	  5acb86:       41 5d                   pop    %r13
    0.00 :	  5acb88:       41 5e                   pop    %r14
    0.00 :	  5acb8a:       c9                      leaveq 
    0.00 :	  5acb8b:       c3                      retq   
    0.00 :	  5acb8c:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * we return NULL; otherwise we return TRUE.  This makes sense when you
         :	         * interpret NULL as "don't know", using the same sort of reasoning as for
         :	         * OR, above.
         :	         */
         :
         :	        foreach(clause, clauses)
    0.00 :	  5acb90:       44 89 e8                mov    %r13d,%eax
    0.00 :	  5acb93:       83 f0 01                xor    $0x1,%eax
    0.00 :	  5acb96:       0f b6 c0                movzbl %al,%eax
         :	                else if (!DatumGetBool(clause_value))
         :	                        return clause_value;
         :	        }
         :
         :	        /* AnyNull is true if at least one clause evaluated to NULL */
         :	        *isNull = AnyNull;
    0.00 :	  5acb99:       45 88 2c 24             mov    %r13b,(%r12)
         :	        return BoolGetDatum(!AnyNull);
         :	}
    0.00 :	  5acb9d:       5b                      pop    %rbx
    0.00 :	  5acb9e:       41 5c                   pop    %r12
    0.00 :	  5acba0:       41 5d                   pop    %r13
    0.00 :	  5acba2:       41 5e                   pop    %r14
    0.00 :	  5acba4:       c9                      leaveq 
    0.00 :	  5acba5:       c3                      retq   
    0.00 :	  5acba6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5acbad:       00 00 00 
         :	         * we return NULL; otherwise we return TRUE.  This makes sense when you
         :	         * interpret NULL as "don't know", using the same sort of reasoning as for
         :	         * OR, above.
         :	         */
         :
         :	        foreach(clause, clauses)
    0.00 :	  5acbb0:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5acbb3:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5acbb8:       eb df                   jmp    5acb99 <ExecEvalAnd+0x79>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:508
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:508
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b3a20 <ExecStoreVirtualTuple>:
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
         :	        slot->tts_nvalid = slot->tts_tupleDescriptor->natts;
    0.00 :	  5b3a20:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	 * This is a bit unclean but it avoids one round of data copying.
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecStoreVirtualTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3a24:       55                      push   %rbp
         :	         */
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
    0.00 :	  5b3a25:       c6 47 04 00             movb   $0x0,0x4(%rdi)
         :	 * This is a bit unclean but it avoids one round of data copying.
         :	 * --------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecStoreVirtualTuple(TupleTableSlot *slot)
         :	{
    0.00 :	  5b3a29:       48 89 e5                mov    %rsp,%rbp
         :	        Assert(slot != NULL);
         :	        Assert(slot->tts_tupleDescriptor != NULL);
         :	        Assert(slot->tts_isempty);
         :
         :	        slot->tts_isempty = false;
         :	        slot->tts_nvalid = slot->tts_tupleDescriptor->natts;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execTuples.c:508
   50.00 :	  5b3a2c:       8b 00                   mov    (%rax),%eax
   50.00 :	  5b3a2e:       89 47 24                mov    %eax,0x24(%rdi)
         :
         :	        return slot;
         :	}
    0.00 :	  5b3a31:       48 89 f8                mov    %rdi,%rax
    0.00 :	  5b3a34:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:115
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:120
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b7ae0 <InstrEndLoop>:
         :	}
         :
         :	/* Finish a run cycle for a plan node */
         :	void
         :	InstrEndLoop(Instrumentation *instr)
         :	{
    0.00 :	  5b7ae0:       55                      push   %rbp
         :	        double          totaltime;
         :
         :	        /* Skip if nothing has happened, or already shut down */
         :	        if (!instr->running)
    0.00 :	  5b7ae1:       80 7f 02 00             cmpb   $0x0,0x2(%rdi)
         :	}
         :
         :	/* Finish a run cycle for a plan node */
         :	void
         :	InstrEndLoop(Instrumentation *instr)
         :	{
    0.00 :	  5b7ae5:       48 89 e5                mov    %rsp,%rbp
         :	        double          totaltime;
         :
         :	        /* Skip if nothing has happened, or already shut down */
         :	        if (!instr->running)
    0.00 :	  5b7ae8:       0f 84 da 00 00 00       je     5b7bc8 <InstrEndLoop+0xe8>
         :	                return;
         :
         :	        if (!INSTR_TIME_IS_ZERO(instr->starttime))
    0.00 :	  5b7aee:       48 83 7f 10 00          cmpq   $0x0,0x10(%rdi)
    0.00 :	  5b7af3:       75 07                   jne    5b7afc <InstrEndLoop+0x1c>
    0.00 :	  5b7af5:       48 83 7f 08 00          cmpq   $0x0,0x8(%rdi)
    0.00 :	  5b7afa:       74 34                   je     5b7b30 <InstrEndLoop+0x50>
         :	                elog(ERROR, "InstrEndLoop called on running node");
    0.00 :	  5b7afc:       ba 7d b6 88 00          mov    $0x88b67d,%edx
    0.00 :	  5b7b01:       be 70 00 00 00          mov    $0x70,%esi
    0.00 :	  5b7b06:       bf fa b5 88 00          mov    $0x88b5fa,%edi
    0.00 :	  5b7b0b:       e8 10 39 1c 00          callq  77b420 <elog_start>
    0.00 :	  5b7b10:       be 08 b6 88 00          mov    $0x88b608,%esi
    0.00 :	  5b7b15:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5b7b1a:       31 c0                   xor    %eax,%eax
    0.00 :	  5b7b1c:       e8 0f 37 1c 00          callq  77b230 <elog_finish>
    0.00 :	  5b7b21:       e8 aa 19 eb ff          callq  4694d0 <abort@plt>
    0.00 :	  5b7b26:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5b7b2d:       00 00 00 
         :
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7b30:       f2 48 0f 2a 47 20       cvtsi2sdq 0x20(%rdi),%xmm0
    0.00 :	  5b7b36:       f2 0f 5e 05 a2 4a 2c    divsd  0x2c4aa2(%rip),%xmm0        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  5b7b3d:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:115
   50.00 :	  5b7b3e:       f2 48 0f 2a 4f 18       cvtsi2sdq 0x18(%rdi),%xmm1
         :
         :	        /* Reset for next cycle (if any) */
         :	        instr->running = false;
         :	        INSTR_TIME_SET_ZERO(instr->starttime);
         :	        INSTR_TIME_SET_ZERO(instr->counter);
         :	        instr->firsttuple = 0;
    0.00 :	  5b7b44:       31 c0                   xor    %eax,%eax
         :	        instr->total += totaltime;
         :	        instr->ntuples += instr->tuplecount;
         :	        instr->nloops += 1;
         :
         :	        /* Reset for next cycle (if any) */
         :	        instr->running = false;
    0.00 :	  5b7b46:       c6 47 02 00             movb   $0x0,0x2(%rdi)
         :	        INSTR_TIME_SET_ZERO(instr->starttime);
    0.00 :	  5b7b4a:       48 c7 47 08 00 00 00    movq   $0x0,0x8(%rdi)
    0.00 :	  5b7b51:       00 
    0.00 :	  5b7b52:       48 c7 47 10 00 00 00    movq   $0x0,0x10(%rdi)
    0.00 :	  5b7b59:       00 
         :	        INSTR_TIME_SET_ZERO(instr->counter);
    0.00 :	  5b7b5a:       48 c7 47 18 00 00 00    movq   $0x0,0x18(%rdi)
    0.00 :	  5b7b61:       00 
    0.00 :	  5b7b62:       48 c7 47 20 00 00 00    movq   $0x0,0x20(%rdi)
    0.00 :	  5b7b69:       00 
         :
         :	        if (!INSTR_TIME_IS_ZERO(instr->starttime))
         :	                elog(ERROR, "InstrEndLoop called on running node");
         :
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
    0.00 :	  5b7b6a:       f2 0f 58 c8             addsd  %xmm0,%xmm1
         :
         :	        instr->startup += instr->firsttuple;
    0.00 :	  5b7b6e:       f2 0f 10 87 a8 00 00    movsd  0xa8(%rdi),%xmm0
    0.00 :	  5b7b75:       00 
    0.00 :	  5b7b76:       f2 0f 58 47 28          addsd  0x28(%rdi),%xmm0
         :
         :	        /* Reset for next cycle (if any) */
         :	        instr->running = false;
         :	        INSTR_TIME_SET_ZERO(instr->starttime);
         :	        INSTR_TIME_SET_ZERO(instr->counter);
         :	        instr->firsttuple = 0;
    0.00 :	  5b7b7b:       48 89 47 28             mov    %rax,0x28(%rdi)
         :
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
         :
         :	        instr->startup += instr->firsttuple;
         :	        instr->total += totaltime;
    0.00 :	  5b7b7f:       f2 0f 58 8f b0 00 00    addsd  0xb0(%rdi),%xmm1
    0.00 :	  5b7b86:       00 
         :	                elog(ERROR, "InstrEndLoop called on running node");
         :
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
         :
         :	        instr->startup += instr->firsttuple;
    0.00 :	  5b7b87:       f2 0f 11 87 a8 00 00    movsd  %xmm0,0xa8(%rdi)
    0.00 :	  5b7b8e:       00 
         :	        instr->total += totaltime;
         :	        instr->ntuples += instr->tuplecount;
    0.00 :	  5b7b8f:       f2 0f 10 87 b8 00 00    movsd  0xb8(%rdi),%xmm0
    0.00 :	  5b7b96:       00 
         :
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
         :
         :	        instr->startup += instr->firsttuple;
         :	        instr->total += totaltime;
    0.00 :	  5b7b97:       f2 0f 11 8f b0 00 00    movsd  %xmm1,0xb0(%rdi)
    0.00 :	  5b7b9e:       00 
         :	        instr->ntuples += instr->tuplecount;
    0.00 :	  5b7b9f:       f2 0f 58 47 30          addsd  0x30(%rdi),%xmm0
         :	        /* Reset for next cycle (if any) */
         :	        instr->running = false;
         :	        INSTR_TIME_SET_ZERO(instr->starttime);
         :	        INSTR_TIME_SET_ZERO(instr->counter);
         :	        instr->firsttuple = 0;
         :	        instr->tuplecount = 0;
    0.00 :	  5b7ba4:       48 89 47 30             mov    %rax,0x30(%rdi)
         :	        /* Accumulate per-cycle statistics into totals */
         :	        totaltime = INSTR_TIME_GET_DOUBLE(instr->counter);
         :
         :	        instr->startup += instr->firsttuple;
         :	        instr->total += totaltime;
         :	        instr->ntuples += instr->tuplecount;
    0.00 :	  5b7ba8:       f2 0f 11 87 b8 00 00    movsd  %xmm0,0xb8(%rdi)
    0.00 :	  5b7baf:       00 
         :	        instr->nloops += 1;
    0.00 :	  5b7bb0:       f2 0f 10 05 a0 75 1f    movsd  0x1f75a0(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b7bb7:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/instrument.c:120
   50.00 :	  5b7bb8:       f2 0f 58 87 c0 00 00    addsd  0xc0(%rdi),%xmm0
    0.00 :	  5b7bbf:       00 
    0.00 :	  5b7bc0:       f2 0f 11 87 c0 00 00    movsd  %xmm0,0xc0(%rdi)
    0.00 :	  5b7bc7:       00 
         :	        instr->running = false;
         :	        INSTR_TIME_SET_ZERO(instr->starttime);
         :	        INSTR_TIME_SET_ZERO(instr->counter);
         :	        instr->firsttuple = 0;
         :	        instr->tuplecount = 0;
         :	}
    0.00 :	  5b7bc8:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:153
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bf4e0 <ExecIndexScan>:
         :	 *              ExecIndexScan(node)
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecIndexScan(IndexScanState *node)
         :	{
    0.00 :	  5bf4e0:       55                      push   %rbp
    0.00 :	  5bf4e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bf4e4:       53                      push   %rbx
    0.00 :	  5bf4e5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5bf4e8:       48 83 ec 08             sub    $0x8,%rsp
         :	        /*
         :	         * If we have runtime keys and they've not already been set up, do it now.
         :	         */
         :	        if (node->iss_NumRuntimeKeys != 0 && !node->iss_RuntimeKeysReady)
    0.00 :	  5bf4ec:       44 8b 97 c0 00 00 00    mov    0xc0(%rdi),%r10d
    0.00 :	  5bf4f3:       45 85 d2                test   %r10d,%r10d
    0.00 :	  5bf4f6:       74 09                   je     5bf501 <ExecIndexScan+0x21>
    0.00 :	  5bf4f8:       80 bf c4 00 00 00 00    cmpb   $0x0,0xc4(%rdi)
    0.00 :	  5bf4ff:       74 1f                   je     5bf520 <ExecIndexScan+0x40>
         :	                ExecReScan((PlanState *) node);
         :
         :	        return ExecScan(&node->ss,
         :	                                        (ExecScanAccessMtd) IndexNext,
         :	                                        (ExecScanRecheckMtd) IndexRecheck);
         :	}
    0.00 :	  5bf501:       48 83 c4 08             add    $0x8,%rsp
         :	         * If we have runtime keys and they've not already been set up, do it now.
         :	         */
         :	        if (node->iss_NumRuntimeKeys != 0 && !node->iss_RuntimeKeysReady)
         :	                ExecReScan((PlanState *) node);
         :
         :	        return ExecScan(&node->ss,
    0.00 :	  5bf505:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5bf508:       ba 30 f5 5b 00          mov    $0x5bf530,%edx
         :	                                        (ExecScanAccessMtd) IndexNext,
         :	                                        (ExecScanRecheckMtd) IndexRecheck);
         :	}
    0.00 :	  5bf50d:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeIndexscan.c:153
  100.00 :	  5bf50e:       c9                      leaveq 
         :	         * If we have runtime keys and they've not already been set up, do it now.
         :	         */
         :	        if (node->iss_NumRuntimeKeys != 0 && !node->iss_RuntimeKeysReady)
         :	                ExecReScan((PlanState *) node);
         :
         :	        return ExecScan(&node->ss,
    0.00 :	  5bf50f:       be 70 f5 5b 00          mov    $0x5bf570,%esi
    0.00 :	  5bf514:       e9 37 42 ff ff          jmpq   5b3750 <ExecScan>
    0.00 :	  5bf519:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	{
         :	        /*
         :	         * If we have runtime keys and they've not already been set up, do it now.
         :	         */
         :	        if (node->iss_NumRuntimeKeys != 0 && !node->iss_RuntimeKeysReady)
         :	                ExecReScan((PlanState *) node);
    0.00 :	  5bf520:       e8 7b 8f fe ff          callq  5a84a0 <ExecReScan>
    0.00 :	  5bf525:       eb da                   jmp    5bf501 <ExecIndexScan+0x21>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:61
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:238
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005c4240 <ExecNestLoop>:
         :	 *                         are prepared to return the first tuple.
         :	 * ----------------------------------------------------------------
         :	 */
         :	TupleTableSlot *
         :	ExecNestLoop(NestLoopState *node)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:61
   50.00 :	  5c4240:       55                      push   %rbp
    0.00 :	  5c4241:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5c4244:       41 57                   push   %r15
    0.00 :	  5c4246:       41 56                   push   %r14
    0.00 :	  5c4248:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5c424b:       41 55                   push   %r13
    0.00 :	  5c424d:       41 54                   push   %r12
    0.00 :	  5c424f:       53                      push   %rbx
    0.00 :	  5c4250:       48 83 ec 48             sub    $0x48,%rsp
         :	        /*
         :	         * get information from the node
         :	         */
         :	        ENL1_printf("getting info from node");
         :
         :	        nl = (NestLoop *) node->js.ps.plan;
    0.00 :	  5c4254:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5c4258:       48 89 45 98             mov    %rax,-0x68(%rbp)
         :	        joinqual = node->js.joinqual;
    0.00 :	  5c425c:       48 8b 97 80 00 00 00    mov    0x80(%rdi),%rdx
    0.00 :	  5c4263:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        otherqual = node->js.ps.qual;
    0.00 :	  5c4267:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  5c426b:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        outerPlan = outerPlanState(node);
    0.00 :	  5c426f:       48 8b 57 30             mov    0x30(%rdi),%rdx
    0.00 :	  5c4273:       48 89 55 a8             mov    %rdx,-0x58(%rbp)
         :	        innerPlan = innerPlanState(node);
    0.00 :	  5c4277:       48 8b 47 38             mov    0x38(%rdi),%rax
    0.00 :	  5c427b:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5c427f:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
         :	        nl = (NestLoop *) node->js.ps.plan;
         :	        joinqual = node->js.joinqual;
         :	        otherqual = node->js.ps.qual;
         :	        outerPlan = outerPlanState(node);
         :	        innerPlan = innerPlanState(node);
         :	        econtext = node->js.ps.ps_ExprContext;
    0.00 :	  5c4283:       4c 8b 7f 60             mov    0x60(%rdi),%r15
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous join
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->js.ps.ps_TupFromTlist)
    0.00 :	  5c4287:       74 1f                   je     5c42a8 <ExecNestLoop+0x68>
         :	        {
         :	                TupleTableSlot *result;
         :	                ExprDoneCond isDone;
         :
         :	                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c4289:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5c428d:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c4291:       e8 6a 8d fe ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5c4296:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5c429a:       0f 84 71 01 00 00       je     5c4411 <ExecNestLoop+0x1d1>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->js.ps.ps_TupFromTlist = false;
    0.00 :	  5c42a0:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
    0.00 :	  5c42a5:       0f 1f 00                nopl   (%rax)
         :	        /*
         :	         * Reset per-tuple memory context to free any expression evaluation
         :	         * storage allocated in the previous tuple cycle.  Note this can't happen
         :	         * until we're done projecting out tuples from a join tuple.
         :	         */
         :	        ResetExprContext(econtext);
    0.00 :	  5c42a8:       49 8b 7f 28             mov    0x28(%r15),%rdi
    0.00 :	  5c42ac:       e8 ff 46 1d 00          callq  7989b0 <MemoryContextReset>
         :	        {
         :	                /*
         :	                 * If we don't have an outer tuple, get the next one and reset the
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
    0.00 :	  5c42b1:       41 80 be 88 00 00 00    cmpb   $0x0,0x88(%r14)
    0.00 :	  5c42b8:       00 
    0.00 :	  5c42b9:       0f 85 a1 00 00 00       jne    5c4360 <ExecNestLoop+0x120>
         :	                /*
         :	                 * we have an outerTuple, try to get the next inner tuple.
         :	                 */
         :	                ENL1_printf("getting new inner tuple");
         :
         :	                innerTupleSlot = ExecProcNode(innerPlan);
    0.00 :	  5c42bf:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5c42c3:       e8 d8 81 fe ff          callq  5ac4a0 <ExecProcNode>
         :	                econtext->ecxt_innertuple = innerTupleSlot;
         :
         :	                if (TupIsNull(innerTupleSlot))
    0.00 :	  5c42c8:       48 85 c0                test   %rax,%rax
         :	                 * we have an outerTuple, try to get the next inner tuple.
         :	                 */
         :	                ENL1_printf("getting new inner tuple");
         :
         :	                innerTupleSlot = ExecProcNode(innerPlan);
         :	                econtext->ecxt_innertuple = innerTupleSlot;
    0.00 :	  5c42cb:       49 89 47 10             mov    %rax,0x10(%r15)
         :
         :	                if (TupIsNull(innerTupleSlot))
    0.00 :	  5c42cf:       74 0a                   je     5c42db <ExecNestLoop+0x9b>
    0.00 :	  5c42d1:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c42d5:       0f 84 45 01 00 00       je     5c4420 <ExecNestLoop+0x1e0>
         :	                {
         :	                        ENL1_printf("no inner tuple, need new outer tuple");
         :
         :	                        node->nl_NeedNewOuter = true;
         :
         :	                        if (!node->nl_MatchedOuter &&
    0.00 :	  5c42db:       41 80 be 89 00 00 00    cmpb   $0x0,0x89(%r14)
    0.00 :	  5c42e2:       00 
         :
         :	                if (TupIsNull(innerTupleSlot))
         :	                {
         :	                        ENL1_printf("no inner tuple, need new outer tuple");
         :
         :	                        node->nl_NeedNewOuter = true;
    0.00 :	  5c42e3:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c42ea:       01 
         :
         :	                        if (!node->nl_MatchedOuter &&
    0.00 :	  5c42eb:       75 c4                   jne    5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c42ed:       41 8b 46 78             mov    0x78(%r14),%eax
    0.00 :	  5c42f1:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  5c42f4:       74 05                   je     5c42fb <ExecNestLoop+0xbb>
    0.00 :	  5c42f6:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5c42f9:       75 b6                   jne    5c42b1 <ExecNestLoop+0x71>
         :	                                 * We are doing an outer join and there were no join matches
         :	                                 * for this outer tuple.  Generate a fake join tuple with
         :	                                 * nulls for the inner tuple, and return it if it passes the
         :	                                 * non-join quals.
         :	                                 */
         :	                                econtext->ecxt_innertuple = node->nl_NullInnerTupleSlot;
    0.00 :	  5c42fb:       49 8b 86 90 00 00 00    mov    0x90(%r14),%rax
    0.00 :	  5c4302:       49 89 47 10             mov    %rax,0x10(%r15)
         :
         :	                                ENL1_printf("testing qualification for outer-join tuple");
         :
         :	                                if (otherqual == NIL || ExecQual(otherqual, econtext, false))
    0.00 :	  5c4306:       48 83 7d c0 00          cmpq   $0x0,-0x40(%rbp)
    0.00 :	  5c430b:       0f 84 bf 01 00 00       je     5c44d0 <ExecNestLoop+0x290>
    0.00 :	  5c4311:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5c4315:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4317:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c431a:       e8 f1 8b fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c431f:       84 c0                   test   %al,%al
    0.00 :	  5c4321:       0f 85 a9 01 00 00       jne    5c44d0 <ExecNestLoop+0x290>
         :	                                                        (isDone == ExprMultipleResult);
         :	                                                return result;
         :	                                        }
         :	                                }
         :	                                else
         :	                                        InstrCountFiltered2(node, 1);
    0.00 :	  5c4327:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c432b:       48 85 c0                test   %rax,%rax
    0.00 :	  5c432e:       74 81                   je     5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c4330:       f2 0f 10 05 20 ae 1e    movsd  0x1eae20(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c4337:       00 
    0.00 :	  5c4338:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5c433f:       00 
    0.00 :	  5c4340:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5c4347:       00 
         :	        {
         :	                /*
         :	                 * If we don't have an outer tuple, get the next one and reset the
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
    0.00 :	  5c4348:       41 80 be 88 00 00 00    cmpb   $0x0,0x88(%r14)
    0.00 :	  5c434f:       00 
    0.00 :	  5c4350:       0f 84 69 ff ff ff       je     5c42bf <ExecNestLoop+0x7f>
    0.00 :	  5c4356:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5c435d:       00 00 00 
         :	                {
         :	                        ENL1_printf("getting new outer tuple");
         :	                        outerTupleSlot = ExecProcNode(outerPlan);
    0.00 :	  5c4360:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5c4364:       e8 37 81 fe ff          callq  5ac4a0 <ExecProcNode>
         :
         :	                        /*
         :	                         * if there are no more outer tuples, then the join is complete..
         :	                         */
         :	                        if (TupIsNull(outerTupleSlot))
    0.00 :	  5c4369:       48 85 c0                test   %rax,%rax
         :	                 * inner scan.
         :	                 */
         :	                if (node->nl_NeedNewOuter)
         :	                {
         :	                        ENL1_printf("getting new outer tuple");
         :	                        outerTupleSlot = ExecProcNode(outerPlan);
    0.00 :	  5c436c:       48 89 45 b0             mov    %rax,-0x50(%rbp)
         :
         :	                        /*
         :	                         * if there are no more outer tuples, then the join is complete..
         :	                         */
         :	                        if (TupIsNull(outerTupleSlot))
    0.00 :	  5c4370:       0f 84 99 00 00 00       je     5c440f <ExecNestLoop+0x1cf>
    0.00 :	  5c4376:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5c437a:       0f 85 8f 00 00 00       jne    5c440f <ExecNestLoop+0x1cf>
         :	                                ENL1_printf("no outer tuple, ending join");
         :	                                return NULL;
         :	                        }
         :
         :	                        ENL1_printf("saving new outer tuple information");
         :	                        econtext->ecxt_outertuple = outerTupleSlot;
    0.00 :	  5c4380:       49 89 47 18             mov    %rax,0x18(%r15)
         :	                        node->nl_NeedNewOuter = false;
    0.00 :	  5c4384:       41 c6 86 88 00 00 00    movb   $0x0,0x88(%r14)
    0.00 :	  5c438b:       00 
         :	                        node->nl_MatchedOuter = false;
    0.00 :	  5c438c:       41 c6 86 89 00 00 00    movb   $0x0,0x89(%r14)
    0.00 :	  5c4393:       00 
         :
         :	                        /*
         :	                         * fetch the values of any outer Vars that must be passed to the
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
    0.00 :	  5c4394:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5c4398:       48 8b 42 70             mov    0x70(%rdx),%rax
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5c439c:       48 85 c0                test   %rax,%rax
    0.00 :	  5c439f:       74 60                   je     5c4401 <ExecNestLoop+0x1c1>
    0.00 :	  5c43a1:       4c 8b 68 08             mov    0x8(%rax),%r13
    0.00 :	  5c43a5:       4d 85 ed                test   %r13,%r13
    0.00 :	  5c43a8:       74 57                   je     5c4401 <ExecNestLoop+0x1c1>
    0.00 :	  5c43aa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
    0.00 :	  5c43b0:       49 8b 45 00             mov    0x0(%r13),%rax
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43b4:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
    0.00 :	  5c43b8:       44 8b 60 04             mov    0x4(%rax),%r12d
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43bc:       48 8b 40 08             mov    0x8(%rax),%rax
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
         :	                                ParamExecData *prm;
         :
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
    0.00 :	  5c43c0:       49 63 dc                movslq %r12d,%rbx
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43c3:       0f bf 70 08             movswl 0x8(%rax),%esi
         :	                        {
         :	                                NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);
         :	                                int                     paramno = nlp->paramno;
         :	                                ParamExecData *prm;
         :
         :	                                prm = &(econtext->ecxt_param_exec_vals[paramno]);
    0.00 :	  5c43c7:       48 8d 1c 5b             lea    (%rbx,%rbx,2),%rbx
    0.00 :	  5c43cb:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  5c43cf:       49 03 5f 30             add    0x30(%r15),%rbx
         :	                                /* Param value should be an OUTER_VAR var */
         :	                                Assert(IsA(nlp->paramval, Var));
         :	                                Assert(nlp->paramval->varno == OUTER_VAR);
         :	                                Assert(nlp->paramval->varattno > 0);
         :	                                prm->value = slot_getattr(outerTupleSlot,
    0.00 :	  5c43d3:       48 8d 53 10             lea    0x10(%rbx),%rdx
    0.00 :	  5c43d7:       e8 24 b0 ea ff          callq  46f400 <slot_getattr>
    0.00 :	  5c43dc:       48 89 43 08             mov    %rax,0x8(%rbx)
         :	                                                                                  nlp->paramval->varattno,
         :	                                                                                  &(prm->isnull));
         :	                                /* Flag parameter value as changed */
         :	                                innerPlan->chgParam = bms_add_member(innerPlan->chgParam,
    0.00 :	  5c43e0:       48 8b 45 a0             mov    -0x60(%rbp),%rax
    0.00 :	  5c43e4:       44 89 e6                mov    %r12d,%esi
    0.00 :	  5c43e7:       48 8b 78 50             mov    0x50(%rax),%rdi
    0.00 :	  5c43eb:       e8 10 ec 01 00          callq  5e3000 <bms_add_member>
    0.00 :	  5c43f0:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5c43f4:       48 89 42 50             mov    %rax,0x50(%rdx)
         :
         :	                        /*
         :	                         * fetch the values of any outer Vars that must be passed to the
         :	                         * inner scan, and store them in the appropriate PARAM_EXEC slots.
         :	                         */
         :	                        foreach(lc, nl->nestParams)
    0.00 :	  5c43f8:       4d 8b 6d 08             mov    0x8(%r13),%r13
    0.00 :	  5c43fc:       4d 85 ed                test   %r13,%r13
    0.00 :	  5c43ff:       75 af                   jne    5c43b0 <ExecNestLoop+0x170>
         :
         :	                        /*
         :	                         * now rescan the inner plan
         :	                         */
         :	                        ENL1_printf("rescanning inner plan");
         :	                        ExecReScan(innerPlan);
    0.00 :	  5c4401:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
    0.00 :	  5c4405:       e8 96 40 fe ff          callq  5a84a0 <ExecReScan>
    0.00 :	  5c440a:       e9 b0 fe ff ff          jmpq   5c42bf <ExecNestLoop+0x7f>
         :	                        InstrCountFiltered1(node, 1);
         :
         :	                /*
         :	                 * Tuple fails qual, so free per-tuple memory and try again.
         :	                 */
         :	                ResetExprContext(econtext);
    0.00 :	  5c440f:       31 c0                   xor    %eax,%eax
         :
         :	                ENL1_printf("qualification failed, looping");
         :	        }
         :	}
    0.00 :	  5c4411:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5c4415:       5b                      pop    %rbx
    0.00 :	  5c4416:       41 5c                   pop    %r12
    0.00 :	  5c4418:       41 5d                   pop    %r13
    0.00 :	  5c441a:       41 5e                   pop    %r14
    0.00 :	  5c441c:       41 5f                   pop    %r15
    0.00 :	  5c441e:       c9                      leaveq 
    0.00 :	  5c441f:       c3                      retq   
         :	                 * Only the joinquals determine MatchedOuter status, but all quals
         :	                 * must pass to actually return the tuple.
         :	                 */
         :	                ENL1_printf("testing qualification");
         :
         :	                if (ExecQual(joinqual, econtext, false))
    0.00 :	  5c4420:       48 8b 7d b8             mov    -0x48(%rbp),%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeNestloop.c:238
   50.00 :	  5c4424:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4426:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c4429:       e8 e2 8a fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c442e:       84 c0                   test   %al,%al
    0.00 :	  5c4430:       74 6e                   je     5c44a0 <ExecNestLoop+0x260>
         :	                {
         :	                        node->nl_MatchedOuter = true;
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
    0.00 :	  5c4432:       41 8b 46 78             mov    0x78(%r14),%eax
         :	                 */
         :	                ENL1_printf("testing qualification");
         :
         :	                if (ExecQual(joinqual, econtext, false))
         :	                {
         :	                        node->nl_MatchedOuter = true;
    0.00 :	  5c4436:       41 c6 86 89 00 00 00    movb   $0x1,0x89(%r14)
    0.00 :	  5c443d:       01 
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
    0.00 :	  5c443e:       83 f8 05                cmp    $0x5,%eax
    0.00 :	  5c4441:       0f 84 e1 00 00 00       je     5c4528 <ExecNestLoop+0x2e8>
         :
         :	                        /*
         :	                         * In a semijoin, we'll consider returning the first match, but
         :	                         * after that we're done with this outer tuple.
         :	                         */
         :	                        if (node->js.jointype == JOIN_SEMI)
    0.00 :	  5c4447:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  5c444a:       0f 84 e8 00 00 00       je     5c4538 <ExecNestLoop+0x2f8>
         :	                                node->nl_NeedNewOuter = true;
         :
         :	                        if (otherqual == NIL || ExecQual(otherqual, econtext, false))
    0.00 :	  5c4450:       48 83 7d c0 00          cmpq   $0x0,-0x40(%rbp)
    0.00 :	  5c4455:       0f 84 a5 00 00 00       je     5c4500 <ExecNestLoop+0x2c0>
    0.00 :	  5c445b:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5c445f:       31 d2                   xor    %edx,%edx
    0.00 :	  5c4461:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5c4464:       e8 a7 8a fe ff          callq  5acf10 <ExecQual>
    0.00 :	  5c4469:       84 c0                   test   %al,%al
    0.00 :	  5c446b:       0f 85 8f 00 00 00       jne    5c4500 <ExecNestLoop+0x2c0>
         :	                                                (isDone == ExprMultipleResult);
         :	                                        return result;
         :	                                }
         :	                        }
         :	                        else
         :	                                InstrCountFiltered2(node, 1);
    0.00 :	  5c4471:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c4475:       48 85 c0                test   %rax,%rax
    0.00 :	  5c4478:       0f 84 2a fe ff ff       je     5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c447e:       f2 0f 10 05 d2 ac 1e    movsd  0x1eacd2(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c4485:       00 
    0.00 :	  5c4486:       f2 0f 58 80 d0 00 00    addsd  0xd0(%rax),%xmm0
    0.00 :	  5c448d:       00 
    0.00 :	  5c448e:       f2 0f 11 80 d0 00 00    movsd  %xmm0,0xd0(%rax)
    0.00 :	  5c4495:       00 
    0.00 :	  5c4496:       e9 0d fe ff ff          jmpq   5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c449b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                }
         :	                else
         :	                        InstrCountFiltered1(node, 1);
    0.00 :	  5c44a0:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5c44a4:       48 85 c0                test   %rax,%rax
    0.00 :	  5c44a7:       0f 84 fb fd ff ff       je     5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c44ad:       f2 0f 10 05 a3 ac 1e    movsd  0x1eaca3(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5c44b4:       00 
    0.00 :	  5c44b5:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5c44bc:       00 
    0.00 :	  5c44bd:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5c44c4:       00 
    0.00 :	  5c44c5:       e9 de fd ff ff          jmpq   5c42a8 <ExecNestLoop+0x68>
    0.00 :	  5c44ca:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        TupleTableSlot *result;
         :	                                        ExprDoneCond isDone;
         :
         :	                                        ENL1_printf("qualification succeeded, projecting tuple");
         :
         :	                                        result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c44d0:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5c44d4:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c44d8:       e8 23 8b fe ff          callq  5ad000 <ExecProject>
         :
         :	                                        if (isDone != ExprEndResult)
    0.00 :	  5c44dd:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5c44e0:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5c44e3:       0f 84 c8 fd ff ff       je     5c42b1 <ExecNestLoop+0x71>
         :
         :	                                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
         :
         :	                                if (isDone != ExprEndResult)
         :	                                {
         :	                                        node->js.ps.ps_TupFromTlist =
    0.00 :	  5c44e9:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5c44ec:       41 0f 94 46 70          sete   0x70(%r14)
         :	                 */
         :	                ResetExprContext(econtext);
         :
         :	                ENL1_printf("qualification failed, looping");
         :	        }
         :	}
    0.00 :	  5c44f1:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  5c44f5:       5b                      pop    %rbx
    0.00 :	  5c44f6:       41 5c                   pop    %r12
    0.00 :	  5c44f8:       41 5d                   pop    %r13
    0.00 :	  5c44fa:       41 5e                   pop    %r14
    0.00 :	  5c44fc:       41 5f                   pop    %r15
    0.00 :	  5c44fe:       c9                      leaveq 
    0.00 :	  5c44ff:       c3                      retq   
         :	                                TupleTableSlot *result;
         :	                                ExprDoneCond isDone;
         :
         :	                                ENL1_printf("qualification succeeded, projecting tuple");
         :
         :	                                result = ExecProject(node->js.ps.ps_ProjInfo, &isDone);
    0.00 :	  5c4500:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5c4504:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5c4508:       e8 f3 8a fe ff          callq  5ad000 <ExecProject>
         :
         :	                                if (isDone != ExprEndResult)
    0.00 :	  5c450d:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5c4510:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5c4513:       0f 84 8f fd ff ff       je     5c42a8 <ExecNestLoop+0x68>
         :	                                {
         :	                                        node->js.ps.ps_TupFromTlist =
    0.00 :	  5c4519:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5c451c:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5c4521:       eb ce                   jmp    5c44f1 <ExecNestLoop+0x2b1>
    0.00 :	  5c4523:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                        node->nl_MatchedOuter = true;
         :
         :	                        /* In an antijoin, we never return a matched tuple */
         :	                        if (node->js.jointype == JOIN_ANTI)
         :	                        {
         :	                                node->nl_NeedNewOuter = true;
    0.00 :	  5c4528:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c452f:       01 
         :	                                continue;               /* return to top of loop */
    0.00 :	  5c4530:       e9 7c fd ff ff          jmpq   5c42b1 <ExecNestLoop+0x71>
    0.00 :	  5c4535:       0f 1f 00                nopl   (%rax)
         :	                        /*
         :	                         * In a semijoin, we'll consider returning the first match, but
         :	                         * after that we're done with this outer tuple.
         :	                         */
         :	                        if (node->js.jointype == JOIN_SEMI)
         :	                                node->nl_NeedNewOuter = true;
    0.00 :	  5c4538:       41 c6 86 88 00 00 00    movb   $0x1,0x88(%r14)
    0.00 :	  5c453f:       01 
    0.00 :	  5c4540:       e9 0b ff ff ff          jmpq   5c4450 <ExecNestLoop+0x210>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/nodes/bitmapset.c:625
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005e3000 <bms_add_member>:
         :	 *
         :	 * Input set is modified or recycled!
         :	 */
         :	Bitmapset *
         :	bms_add_member(Bitmapset *a, int x)
         :	{
    0.00 :	  5e3000:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/nodes/bitmapset.c:625
  100.00 :	  5e3001:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5e3004:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  5e3008:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  5e300c:       41 89 f5                mov    %esi,%r13d
    0.00 :	  5e300f:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  5e3013:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  5e3017:       48 83 ec 20             sub    $0x20,%rsp
         :	        int                     wordnum,
         :	                                bitnum;
         :
         :	        if (x < 0)
    0.00 :	  5e301b:       85 f6                   test   %esi,%esi
    0.00 :	  5e301d:       0f 88 a8 00 00 00       js     5e30cb <bms_add_member+0xcb>
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        if (a == NULL)
    0.00 :	  5e3023:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5e3026:       0f 84 84 00 00 00       je     5e30b0 <bms_add_member+0xb0>
         :	                return bms_make_singleton(x);
         :	        wordnum = WORDNUM(x);
         :	        bitnum = BITNUM(x);
         :
         :	        /* enlarge the set if necessary */
         :	        if (wordnum >= a->nwords)
    0.00 :	  5e302c:       44 8b 27                mov    (%rdi),%r12d
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        if (a == NULL)
         :	                return bms_make_singleton(x);
         :	        wordnum = WORDNUM(x);
    0.00 :	  5e302f:       41 89 f6                mov    %esi,%r14d
    0.00 :	  5e3032:       41 c1 fe 05             sar    $0x5,%r14d
         :	        bitnum = BITNUM(x);
         :
         :	        /* enlarge the set if necessary */
         :	        if (wordnum >= a->nwords)
    0.00 :	  5e3036:       45 39 e6                cmp    %r12d,%r14d
    0.00 :	  5e3039:       7d 35                   jge    5e3070 <bms_add_member+0x70>
         :	                /* zero out the enlarged portion */
         :	                for (i = oldnwords; i < a->nwords; i++)
         :	                        a->words[i] = 0;
         :	        }
         :
         :	        a->words[wordnum] |= ((bitmapword) 1 << bitnum);
    0.00 :	  5e303b:       41 83 e5 1f             and    $0x1f,%r13d
    0.00 :	  5e303f:       49 63 d6                movslq %r14d,%rdx
    0.00 :	  5e3042:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  5e3047:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  5e304a:       d3 e0                   shl    %cl,%eax
    0.00 :	  5e304c:       09 44 97 04             or     %eax,0x4(%rdi,%rdx,4)
         :	        return a;
         :	}
    0.00 :	  5e3050:       48 89 f8                mov    %rdi,%rax
    0.00 :	  5e3053:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5e3057:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  5e305c:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  5e3061:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  5e3066:       c9                      leaveq 
    0.00 :	  5e3067:       c3                      retq   
    0.00 :	  5e3068:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  5e306f:       00 
         :	        if (wordnum >= a->nwords)
         :	        {
         :	                int                     oldnwords = a->nwords;
         :	                int                     i;
         :
         :	                a = (Bitmapset *) repalloc(a, BITMAPSET_SIZE(wordnum + 1));
    0.00 :	  5e3070:       41 8d 5e 01             lea    0x1(%r14),%ebx
    0.00 :	  5e3074:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  5e3077:       48 8d 34 b5 04 00 00    lea    0x4(,%rsi,4),%rsi
    0.00 :	  5e307e:       00 
    0.00 :	  5e307f:       e8 6c 5c 1b 00          callq  798cf0 <repalloc>
         :	                a->nwords = wordnum + 1;
         :	                /* zero out the enlarged portion */
         :	                for (i = oldnwords; i < a->nwords; i++)
    0.00 :	  5e3084:       41 39 dc                cmp    %ebx,%r12d
         :	        if (wordnum >= a->nwords)
         :	        {
         :	                int                     oldnwords = a->nwords;
         :	                int                     i;
         :
         :	                a = (Bitmapset *) repalloc(a, BITMAPSET_SIZE(wordnum + 1));
    0.00 :	  5e3087:       48 89 c7                mov    %rax,%rdi
         :	                a->nwords = wordnum + 1;
    0.00 :	  5e308a:       89 18                   mov    %ebx,(%rax)
         :	                /* zero out the enlarged portion */
         :	                for (i = oldnwords; i < a->nwords; i++)
    0.00 :	  5e308c:       7d ad                   jge    5e303b <bms_add_member+0x3b>
    0.00 :	  5e308e:       66 90                   xchg   %ax,%ax
         :	                        a->words[i] = 0;
    0.00 :	  5e3090:       49 63 c4                movslq %r12d,%rax
         :	                int                     i;
         :
         :	                a = (Bitmapset *) repalloc(a, BITMAPSET_SIZE(wordnum + 1));
         :	                a->nwords = wordnum + 1;
         :	                /* zero out the enlarged portion */
         :	                for (i = oldnwords; i < a->nwords; i++)
    0.00 :	  5e3093:       41 83 c4 01             add    $0x1,%r12d
         :	                        a->words[i] = 0;
    0.00 :	  5e3097:       c7 44 87 04 00 00 00    movl   $0x0,0x4(%rdi,%rax,4)
    0.00 :	  5e309e:       00 
         :	                int                     i;
         :
         :	                a = (Bitmapset *) repalloc(a, BITMAPSET_SIZE(wordnum + 1));
         :	                a->nwords = wordnum + 1;
         :	                /* zero out the enlarged portion */
         :	                for (i = oldnwords; i < a->nwords; i++)
    0.00 :	  5e309f:       44 39 27                cmp    %r12d,(%rdi)
    0.00 :	  5e30a2:       7f ec                   jg     5e3090 <bms_add_member+0x90>
    0.00 :	  5e30a4:       eb 95                   jmp    5e303b <bms_add_member+0x3b>
    0.00 :	  5e30a6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5e30ad:       00 00 00 
         :	                        a->words[i] = 0;
         :	        }
         :
         :	        a->words[wordnum] |= ((bitmapword) 1 << bitnum);
         :	        return a;
         :	}
    0.00 :	  5e30b0:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  5e30b4:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
         :	                                bitnum;
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        if (a == NULL)
         :	                return bms_make_singleton(x);
    0.00 :	  5e30b9:       89 f7                   mov    %esi,%edi
         :	                        a->words[i] = 0;
         :	        }
         :
         :	        a->words[wordnum] |= ((bitmapword) 1 << bitnum);
         :	        return a;
         :	}
    0.00 :	  5e30bb:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  5e30c0:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  5e30c5:       c9                      leaveq 
         :	                                bitnum;
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        if (a == NULL)
         :	                return bms_make_singleton(x);
    0.00 :	  5e30c6:       e9 a5 fe ff ff          jmpq   5e2f70 <bms_make_singleton>
         :	{
         :	        int                     wordnum,
         :	                                bitnum;
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
    0.00 :	  5e30cb:       ba 6f 23 89 00          mov    $0x89236f,%edx
    0.00 :	  5e30d0:       be 76 02 00 00          mov    $0x276,%esi
    0.00 :	  5e30d5:       bf e2 21 89 00          mov    $0x8921e2,%edi
    0.00 :	  5e30da:       e8 41 83 19 00          callq  77b420 <elog_start>
    0.00 :	  5e30df:       be 08 22 89 00          mov    $0x892208,%esi
    0.00 :	  5e30e4:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5e30e9:       31 c0                   xor    %eax,%eax
    0.00 :	  5e30eb:       e8 40 81 19 00          callq  77b230 <elog_finish>
    0.00 :	  5e30f0:       e8 db 63 e8 ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2112
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674030 <BufferGetBlockNumber>:
         :	 *              Assumes that the buffer is valid and pinned, else the
         :	 *              value may be obsolete immediately...
         :	 */
         :	BlockNumber
         :	BufferGetBlockNumber(Buffer buffer)
         :	{
    0.00 :	  674030:       55                      push   %rbp
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674031:       85 ff                   test   %edi,%edi
         :	 *              Assumes that the buffer is valid and pinned, else the
         :	 *              value may be obsolete immediately...
         :	 */
         :	BlockNumber
         :	BufferGetBlockNumber(Buffer buffer)
         :	{
    0.00 :	  674033:       48 89 e5                mov    %rsp,%rbp
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674036:       78 18                   js     674050 <BufferGetBlockNumber+0x20>
         :	                bufHdr = &(LocalBufferDescriptors[-buffer - 1]);
         :	        else
         :	                bufHdr = &BufferDescriptors[buffer - 1];
    0.00 :	  674038:       48 63 c7                movslq %edi,%rax
    0.00 :	  67403b:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  67403f:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674043:       48 03 05 b6 ba 54 00    add    0x54bab6(%rip),%rax        # bbfb00 <BufferDescriptors>
         :
         :	        /* pinned, so OK to read tag without spinlock */
         :	        return bufHdr->tag.blockNum;
    0.00 :	  67404a:       8b 40 10                mov    0x10(%rax),%eax
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2112
  100.00 :	  67404d:       c9                      leaveq 
    0.00 :	  67404e:       c3                      retq   
    0.00 :	  67404f:       90                      nop
         :	        volatile BufferDesc *bufHdr;
         :
         :	        Assert(BufferIsPinned(buffer));
         :
         :	        if (BufferIsLocal(buffer))
         :	                bufHdr = &(LocalBufferDescriptors[-buffer - 1]);
    0.00 :	  674050:       f7 d7                   not    %edi
    0.00 :	  674052:       48 63 c7                movslq %edi,%rax
    0.00 :	  674055:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674059:       48 03 05 b0 90 50 00    add    0x5090b0(%rip),%rax        # b7d110 <LocalBufferDescriptors>
         :	        else
         :	                bufHdr = &BufferDescriptors[buffer - 1];
         :
         :	        /* pinned, so OK to read tag without spinlock */
         :	        return bufHdr->tag.blockNum;
    0.00 :	  674060:       8b 40 10                mov    0x10(%rax),%eax
         :	}
    0.00 :	  674063:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:468
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:468
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006766a0 <ReadBuffer>:
         :	 * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main
         :	 *              fork with RBM_NORMAL mode and default strategy.
         :	 */
         :	Buffer
         :	ReadBuffer(Relation reln, BlockNumber blockNum)
         :	{
    0.00 :	  6766a0:       55                      push   %rbp
         :	        return ReadBufferExtended(reln, MAIN_FORKNUM, blockNum, RBM_NORMAL, NULL);
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:468
   50.00 :	  6766a1:       89 f2                   mov    %esi,%edx
    0.00 :	  6766a3:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  6766a6:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6766a8:       31 f6                   xor    %esi,%esi
         :	 * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main
         :	 *              fork with RBM_NORMAL mode and default strategy.
         :	 */
         :	Buffer
         :	ReadBuffer(Relation reln, BlockNumber blockNum)
         :	{
    0.00 :	  6766aa:       48 89 e5                mov    %rsp,%rbp
         :	        return ReadBufferExtended(reln, MAIN_FORKNUM, blockNum, RBM_NORMAL, NULL);
         :	}
    0.00 :	  6766ad:       c9                      leaveq 
         :	 *              fork with RBM_NORMAL mode and default strategy.
         :	 */
         :	Buffer
         :	ReadBuffer(Relation reln, BlockNumber blockNum)
         :	{
         :	        return ReadBufferExtended(reln, MAIN_FORKNUM, blockNum, RBM_NORMAL, NULL);
   50.00 :	  6766ae:       e9 bd fe ff ff          jmpq   676570 <ReadBufferExtended>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1448
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000679a90 <FileSeek>:
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679a90:       55                      push   %rbp
    0.00 :	  679a91:       89 f8                   mov    %edi,%eax
    0.00 :	  679a93:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  679a96:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679a9a:       4c 63 ef                movslq %edi,%r13
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679a9d:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679aa1:       49 c1 e5 06             shl    $0x6,%r13
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679aa5:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  679aa9:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679aad:       4d 89 ec                mov    %r13,%r12
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679ab0:       48 83 ec 20             sub    $0x20,%rsp
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679ab4:       4c 03 25 dd 36 50 00    add    0x5036dd(%rip),%r12        # b7d198 <VfdCache>
         :	        return pg_fsync(VfdCache[file].fd);
         :	}
         :
         :	off_t
         :	FileSeek(File file, off_t offset, int whence)
         :	{
    0.00 :	  679abb:       49 89 f6                mov    %rsi,%r14
    0.00 :	  679abe:       89 d3                   mov    %edx,%ebx
         :	        DO_DB(elog(LOG, "FileSeek: %d (%s) " INT64_FORMAT " " INT64_FORMAT " %d",
         :	                           file, VfdCache[file].fileName,
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
    0.00 :	  679ac0:       41 8b 3c 24             mov    (%r12),%edi
 /home/Computational/mark/src/postgres-andres/src/backend/storage/file/fd.c:1448
  100.00 :	  679ac4:       83 ff ff                cmp    $0xffffffff,%edi
    0.00 :	  679ac7:       74 6f                   je     679b38 <FileSeek+0xa8>
         :	                                break;
         :	                }
         :	        }
         :	        else
         :	        {
         :	                switch (whence)
    0.00 :	  679ac9:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  679acc:       0f 84 9e 00 00 00       je     679b70 <FileSeek+0xe0>
    0.00 :	  679ad2:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  679ad5:       0f 84 05 01 00 00       je     679be0 <FileSeek+0x150>
    0.00 :	  679adb:       85 db                   test   %ebx,%ebx
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679add:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679ae2:       be d7 05 00 00          mov    $0x5d7,%esi
         :	                                break;
         :	                }
         :	        }
         :	        else
         :	        {
         :	                switch (whence)
    0.00 :	  679ae7:       75 27                   jne    679b10 <FileSeek+0x80>
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679ae9:       4d 85 f6                test   %r14,%r14
    0.00 :	  679aec:       0f 88 28 01 00 00       js     679c1a <FileSeek+0x18a>
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                if (VfdCache[file].seekPos != offset)
    0.00 :	  679af2:       4d 39 74 24 20          cmp    %r14,0x20(%r12)
    0.00 :	  679af7:       0f 84 8b 00 00 00       je     679b88 <FileSeek+0xf8>
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679afd:       31 d2                   xor    %edx,%edx
    0.00 :	  679aff:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679b02:       e8 69 00 df ff          callq  469b70 <lseek@plt>
    0.00 :	  679b07:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679b0c:       eb 7a                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679b0e:       66 90                   xchg   %ax,%ax
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679b10:       bf f1 a2 8a 00          mov    $0x8aa2f1,%edi
    0.00 :	  679b15:       e8 06 19 10 00          callq  77b420 <elog_start>
    0.00 :	  679b1a:       89 da                   mov    %ebx,%edx
    0.00 :	  679b1c:       be 3a a3 8a 00          mov    $0x8aa33a,%esi
    0.00 :	  679b21:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  679b26:       31 c0                   xor    %eax,%eax
    0.00 :	  679b28:       e8 03 17 10 00          callq  77b230 <elog_finish>
    0.00 :	  679b2d:       e8 9e f9 de ff          callq  4694d0 <abort@plt>
    0.00 :	  679b32:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
    0.00 :	  679b38:       83 fa 01                cmp    $0x1,%edx
    0.00 :	  679b3b:       0f 84 cf 00 00 00       je     679c10 <FileSeek+0x180>
    0.00 :	  679b41:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  679b44:       74 6a                   je     679bb0 <FileSeek+0x120>
    0.00 :	  679b46:       85 db                   test   %ebx,%ebx
         :	                                        return returnCode;
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                           offset, whence);
         :	                                break;
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
    0.00 :	  679b48:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679b4d:       be bd 05 00 00          mov    $0x5bd,%esi
         :	                           (int64) VfdCache[file].seekPos,
         :	                           (int64) offset, whence));
         :
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
    0.00 :	  679b52:       75 bc                   jne    679b10 <FileSeek+0x80>
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679b54:       4d 85 f6                test   %r14,%r14
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
    0.00 :	  679b57:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679b5c:       be af 05 00 00          mov    $0x5af,%esi
         :	        if (FileIsNotOpen(file))
         :	        {
         :	                switch (whence)
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
    0.00 :	  679b61:       0f 88 bd 00 00 00       js     679c24 <FileSeek+0x194>
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                VfdCache[file].seekPos = offset;
    0.00 :	  679b67:       4d 89 74 24 20          mov    %r14,0x20(%r12)
         :	                                break;
    0.00 :	  679b6c:       eb 1a                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679b6e:       66 90                   xchg   %ax,%ax
         :	                                if (VfdCache[file].seekPos != offset)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
    0.00 :	  679b70:       48 85 f6                test   %rsi,%rsi
    0.00 :	  679b73:       0f 85 7f 00 00 00       jne    679bf8 <FileSeek+0x168>
    0.00 :	  679b79:       49 83 7c 24 20 ff       cmpq   $0xffffffffffffffff,0x20(%r12)
    0.00 :	  679b7f:       90                      nop
    0.00 :	  679b80:       74 76                   je     679bf8 <FileSeek+0x168>
    0.00 :	  679b82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        default:
         :	                                elog(ERROR, "invalid whence: %d", whence);
         :	                                break;
         :	                }
         :	        }
         :	        return VfdCache[file].seekPos;
    0.00 :	  679b88:       48 8b 05 09 36 50 00    mov    0x503609(%rip),%rax        # b7d198 <VfdCache>
    0.00 :	  679b8f:       4a 8b 54 28 20          mov    0x20(%rax,%r13,1),%rdx
         :	}
    0.00 :	  679b94:       48 89 d0                mov    %rdx,%rax
    0.00 :	  679b97:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  679b9b:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  679ba0:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  679ba5:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  679baa:       c9                      leaveq 
    0.00 :	  679bab:       c3                      retq   
    0.00 :	  679bac:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
         :	                                break;
         :	                        case SEEK_END:
         :	                                returnCode = FileAccess(file);
    0.00 :	  679bb0:       89 c7                   mov    %eax,%edi
    0.00 :	  679bb2:       e8 69 fd ff ff          callq  679920 <FileAccess>
         :	                                if (returnCode < 0)
    0.00 :	  679bb7:       85 c0                   test   %eax,%eax
         :	                                        return returnCode;
    0.00 :	  679bb9:       48 63 d0                movslq %eax,%rdx
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
         :	                                break;
         :	                        case SEEK_END:
         :	                                returnCode = FileAccess(file);
         :	                                if (returnCode < 0)
    0.00 :	  679bbc:       78 d6                   js     679b94 <FileSeek+0x104>
         :	                                        return returnCode;
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679bbe:       4c 89 eb                mov    %r13,%rbx
    0.00 :	  679bc1:       48 03 1d d0 35 50 00    add    0x5035d0(%rip),%rbx        # b7d198 <VfdCache>
    0.00 :	  679bc8:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  679bcd:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679bd0:       8b 3b                   mov    (%rbx),%edi
    0.00 :	  679bd2:       e8 99 ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679bd7:       48 89 43 20             mov    %rax,0x20(%rbx)
         :	                                                                                           offset, whence);
         :	                                break;
    0.00 :	  679bdb:       eb ab                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679bdd:       0f 1f 00                nopl   (%rax)
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_END:
         :	                                VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679be0:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  679be5:       e8 86 ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679bea:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679bef:       90                      nop
         :	                                                                                           offset, whence);
         :	                                break;
    0.00 :	  679bf0:       eb 96                   jmp    679b88 <FileSeek+0xf8>
    0.00 :	  679bf2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
         :	                                                                                                   offset, whence);
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                if (offset != 0 || VfdCache[file].seekPos == FileUnknownPos)
         :	                                        VfdCache[file].seekPos = lseek(VfdCache[file].fd,
    0.00 :	  679bf8:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  679bfd:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  679c00:       e8 6b ff de ff          callq  469b70 <lseek@plt>
    0.00 :	  679c05:       49 89 44 24 20          mov    %rax,0x20(%r12)
    0.00 :	  679c0a:       e9 79 ff ff ff          jmpq   679b88 <FileSeek+0xf8>
    0.00 :	  679c0f:       90                      nop
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
         :	                                                 (int64) offset);
         :	                                VfdCache[file].seekPos = offset;
         :	                                break;
         :	                        case SEEK_CUR:
         :	                                VfdCache[file].seekPos += offset;
    0.00 :	  679c10:       49 01 74 24 20          add    %rsi,0x20(%r12)
         :	                                break;
    0.00 :	  679c15:       e9 6e ff ff ff          jmpq   679b88 <FileSeek+0xf8>
         :	        {
         :	                switch (whence)
         :	                {
         :	                        case SEEK_SET:
         :	                                if (offset < 0)
         :	                                        elog(ERROR, "invalid seek offset: " INT64_FORMAT,
    0.00 :	  679c1a:       ba bf a9 8a 00          mov    $0x8aa9bf,%edx
    0.00 :	  679c1f:       be c8 05 00 00          mov    $0x5c8,%esi
    0.00 :	  679c24:       bf f1 a2 8a 00          mov    $0x8aa2f1,%edi
    0.00 :	  679c29:       e8 f2 17 10 00          callq  77b420 <elog_start>
    0.00 :	  679c2e:       4c 89 f2                mov    %r14,%rdx
    0.00 :	  679c31:       be 21 a3 8a 00          mov    $0x8aa321,%esi
    0.00 :	  679c36:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  679c3b:       31 c0                   xor    %eax,%eax
    0.00 :	  679c3d:       e8 ee 15 10 00          callq  77b230 <elog_finish>
    0.00 :	  679c42:       e8 89 f8 de ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:2444
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000693260 <PredicateLockPage>:
         :	 * Skip if a coarser predicate lock already covers this page.
         :	 * Clear any finer-grained predicate locks this session has on the relation.
         :	 */
         :	void
         :	PredicateLockPage(Relation relation, BlockNumber blkno, Snapshot snapshot)
         :	{
    0.00 :	  693260:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/lmgr/predicate.c:2444
  100.00 :	  693261:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  693264:       48 83 ec 10             sub    $0x10,%rsp
         :	 */
         :	static inline bool
         :	SerializationNeededForRead(Relation relation, Snapshot snapshot)
         :	{
         :	        /* Nothing to do if this is not a serializable transaction */
         :	        if (MySerializableXact == InvalidSerializableXact)
    0.00 :	  693268:       48 8b 0d 51 b4 4e 00    mov    0x4eb451(%rip),%rcx        # b7e6c0 <MySerializableXact>
    0.00 :	  69326f:       48 85 c9                test   %rcx,%rcx
    0.00 :	  693272:       74 13                   je     693287 <PredicateLockPage+0x27>
         :	         * This excludes things like CLUSTER and REINDEX. They use the wholesale
         :	         * functions TransferPredicateLocksToHeapRelation() and
         :	         * CheckTableForSerializableConflictIn() to participate serialization, but
         :	         * the scans involved don't need serialization.
         :	         */
         :	        if (!IsMVCCSnapshot(snapshot))
    0.00 :	  693274:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  693277:       48 3d 50 57 7a 00       cmp    $0x7a5750,%rax
    0.00 :	  69327d:       74 11                   je     693290 <PredicateLockPage+0x30>
    0.00 :	  69327f:       48 3d 60 47 7a 00       cmp    $0x7a4760,%rax
    0.00 :	  693285:       74 09                   je     693290 <PredicateLockPage+0x30>
         :	        SET_PREDICATELOCKTARGETTAG_PAGE(tag,
         :	                                                                        relation->rd_node.dbNode,
         :	                                                                        relation->rd_id,
         :	                                                                        blkno);
         :	        PredicateLockAcquire(&tag);
         :	}
    0.00 :	  693287:       c9                      leaveq 
    0.00 :	  693288:       c3                      retq   
    0.00 :	  693289:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	         *
         :	         * A transaction is flagged as RO_SAFE if all concurrent R/W transactions
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
    0.00 :	  693290:       80 79 7c 00             cmpb   $0x0,0x7c(%rcx)
    0.00 :	  693294:       78 3a                   js     6932d0 <PredicateLockPage+0x70>
         :	 * relations are exempt, as are materialized views.
         :	 */
         :	static inline bool
         :	PredicateLockingNeededForRelation(Relation relation)
         :	{
         :	        return !(relation->rd_id < FirstBootstrapObjectId ||
    0.00 :	  693296:       8b 57 40                mov    0x40(%rdi),%edx
    0.00 :	  693299:       81 fa 0f 27 00 00       cmp    $0x270f,%edx
    0.00 :	  69329f:       90                      nop
    0.00 :	  6932a0:       76 e5                   jbe    693287 <PredicateLockPage+0x27>
    0.00 :	  6932a2:       48 8b 47 30             mov    0x30(%rdi),%rax
    0.00 :	  6932a6:       80 78 6e 74             cmpb   $0x74,0x6e(%rax)
    0.00 :	  6932aa:       74 db                   je     693287 <PredicateLockPage+0x27>
    0.00 :	  6932ac:       80 78 6f 6d             cmpb   $0x6d,0x6f(%rax)
    0.00 :	  6932b0:       74 d5                   je     693287 <PredicateLockPage+0x27>
         :	        PREDICATELOCKTARGETTAG tag;
         :
         :	        if (!SerializationNeededForRead(relation, snapshot))
         :	                return;
         :
         :	        SET_PREDICATELOCKTARGETTAG_PAGE(tag,
    0.00 :	  6932b2:       8b 47 04                mov    0x4(%rdi),%eax
         :	                                                                        relation->rd_node.dbNode,
         :	                                                                        relation->rd_id,
         :	                                                                        blkno);
         :	        PredicateLockAcquire(&tag);
    0.00 :	  6932b5:       48 8d 7d f0             lea    -0x10(%rbp),%rdi
         :	        PREDICATELOCKTARGETTAG tag;
         :
         :	        if (!SerializationNeededForRead(relation, snapshot))
         :	                return;
         :
         :	        SET_PREDICATELOCKTARGETTAG_PAGE(tag,
    0.00 :	  6932b9:       89 55 f4                mov    %edx,-0xc(%rbp)
    0.00 :	  6932bc:       89 75 f8                mov    %esi,-0x8(%rbp)
    0.00 :	  6932bf:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    0.00 :	  6932c6:       89 45 f0                mov    %eax,-0x10(%rbp)
         :	                                                                        relation->rd_node.dbNode,
         :	                                                                        relation->rd_id,
         :	                                                                        blkno);
         :	        PredicateLockAcquire(&tag);
    0.00 :	  6932c9:       e8 62 ed ff ff          callq  692030 <PredicateLockAcquire>
         :	}
    0.00 :	  6932ce:       c9                      leaveq 
    0.00 :	  6932cf:       c3                      retq   
         :	         * commit without having conflicts out to an earlier snapshot, thus
         :	         * ensuring that no conflicts are possible for this transaction.
         :	         */
         :	        if (SxactIsROSafe(MySerializableXact))
         :	        {
         :	                ReleasePredicateLocks(false);
    0.00 :	  6932d0:       31 ff                   xor    %edi,%edi
    0.00 :	  6932d2:       e8 19 f6 ff ff          callq  6928f0 <ReleasePredicateLocks>
         :	        SET_PREDICATELOCKTARGETTAG_PAGE(tag,
         :	                                                                        relation->rd_node.dbNode,
         :	                                                                        relation->rd_id,
         :	                                                                        blkno);
         :	        PredicateLockAcquire(&tag);
         :	}
    0.00 :	  6932d7:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/page/bufpage.c:82
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/page/bufpage.c:94
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000694ed0 <PageIsVerified>:
         :	 * treat such a page as empty and without free space.  Eventually, VACUUM
         :	 * will clean up such a page and make it usable.
         :	 */
         :	bool
         :	PageIsVerified(Page page, BlockNumber blkno)
         :	{
    0.00 :	  694ed0:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/page/bufpage.c:82
   50.00 :	  694ed1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  694ed4:       41 55                   push   %r13
    0.00 :	  694ed6:       41 54                   push   %r12
    0.00 :	  694ed8:       41 89 f4                mov    %esi,%r12d
    0.00 :	  694edb:       53                      push   %rbx
    0.00 :	  694edc:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  694edf:       48 83 ec 08             sub    $0x8,%rsp
         :	        uint16          checksum = 0;
         :
         :	        /*
         :	         * Don't verify page data unless the page passes basic non-zero test
         :	         */
         :	        if (!PageIsNew(page))
    0.00 :	  694ee3:       66 83 7f 0e 00          cmpw   $0x0,0xe(%rdi)
 /home/Computational/mark/src/postgres-andres/src/backend/storage/page/bufpage.c:94
   50.00 :	  694ee8:       75 56                   jne    694f40 <PageIsVerified+0x70>
    0.00 :	  694eea:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  694eed:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  694ef0:       31 c9                   xor    %ecx,%ecx
         :	                        p->pd_upper <= p->pd_special &&
         :	                        p->pd_special <= BLCKSZ &&
         :	                        p->pd_special == MAXALIGN(p->pd_special))
         :	                        header_sane = true;
         :
         :	                if (header_sane && !checksum_failure)
    0.00 :	  694ef2:       31 c0                   xor    %eax,%eax
    0.00 :	  694ef4:       eb 16                   jmp    694f0c <PageIsVerified+0x3c>
    0.00 :	  694ef6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  694efd:       00 00 00 
         :	        /* Check all-zeroes case */
         :	        all_zeroes = true;
         :	        pagebytes = (char *) page;
         :	        for (i = 0; i < BLCKSZ; i++)
         :	        {
         :	                if (pagebytes[i] != 0)
    0.00 :	  694f00:       48 83 c0 01             add    $0x1,%rax
         :	        }
         :
         :	        /* Check all-zeroes case */
         :	        all_zeroes = true;
         :	        pagebytes = (char *) page;
         :	        for (i = 0; i < BLCKSZ; i++)
    0.00 :	  694f04:       48 3d 00 20 00 00       cmp    $0x2000,%rax
    0.00 :	  694f0a:       74 24                   je     694f30 <PageIsVerified+0x60>
         :	        {
         :	                if (pagebytes[i] != 0)
    0.00 :	  694f0c:       80 3c 03 00             cmpb   $0x0,(%rbx,%rax,1)
    0.00 :	  694f10:       74 ee                   je     694f00 <PageIsVerified+0x30>
         :
         :	        /*
         :	         * Throw a WARNING if the checksum fails, but only after we've checked for
         :	         * the all-zeroes case.
         :	         */
         :	        if (checksum_failure)
    0.00 :	  694f12:       84 c9                   test   %cl,%cl
    0.00 :	  694f14:       0f 85 86 00 00 00       jne    694fa0 <PageIsVerified+0xd0>
         :	                ereport(WARNING,
         :	                                (ERRCODE_DATA_CORRUPTED,
         :	                                 errmsg("page verification failed, calculated checksum %u but expected %u",
         :	                                                checksum, p->pd_checksum)));
         :
         :	                if (header_sane && ignore_checksum_failure)
    0.00 :	  694f1a:       31 c0                   xor    %eax,%eax
         :	                        return true;
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  694f1c:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  694f20:       5b                      pop    %rbx
    0.00 :	  694f21:       41 5c                   pop    %r12
    0.00 :	  694f23:       41 5d                   pop    %r13
    0.00 :	  694f25:       c9                      leaveq 
    0.00 :	  694f26:       c3                      retq   
    0.00 :	  694f27:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  694f2e:       00 00 
    0.00 :	  694f30:       48 83 c4 08             add    $0x8,%rsp
         :	                ereport(WARNING,
         :	                                (ERRCODE_DATA_CORRUPTED,
         :	                                 errmsg("page verification failed, calculated checksum %u but expected %u",
         :	                                                checksum, p->pd_checksum)));
         :
         :	                if (header_sane && ignore_checksum_failure)
    0.00 :	  694f34:       b8 01 00 00 00          mov    $0x1,%eax
         :	                        return true;
         :	        }
         :
         :	        return false;
         :	}
    0.00 :	  694f39:       5b                      pop    %rbx
    0.00 :	  694f3a:       41 5c                   pop    %r12
    0.00 :	  694f3c:       41 5d                   pop    %r13
    0.00 :	  694f3e:       c9                      leaveq 
    0.00 :	  694f3f:       c3                      retq   
         :	        /*
         :	         * Don't verify page data unless the page passes basic non-zero test
         :	         */
         :	        if (!PageIsNew(page))
         :	        {
         :	                if (DataChecksumsEnabled())
    0.00 :	  694f40:       e8 7b 80 e3 ff          callq  4ccfc0 <DataChecksumsEnabled>
    0.00 :	  694f45:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  694f48:       31 c9                   xor    %ecx,%ecx
    0.00 :	  694f4a:       84 c0                   test   %al,%al
    0.00 :	  694f4c:       0f 85 96 00 00 00       jne    694fe8 <PageIsVerified+0x118>
         :	                 * The following checks don't prove the header is correct, only that
         :	                 * it looks sane enough to allow into the buffer pool. Later usage of
         :	                 * the block can still reveal problems, which is why we offer the
         :	                 * checksum option.
         :	                 */
         :	                if ((p->pd_flags & ~PD_VALID_FLAG_BITS) == 0 &&
    0.00 :	  694f52:       0f b7 43 0a             movzwl 0xa(%rbx),%eax
    0.00 :	  694f56:       a9 f8 ff 00 00          test   $0xfff8,%eax
    0.00 :	  694f5b:       0f 85 7f 00 00 00       jne    694fe0 <PageIsVerified+0x110>
    0.00 :	  694f61:       0f b7 43 0e             movzwl 0xe(%rbx),%eax
    0.00 :	  694f65:       66 39 43 0c             cmp    %ax,0xc(%rbx)
    0.00 :	  694f69:       77 75                   ja     694fe0 <PageIsVerified+0x110>
    0.00 :	  694f6b:       0f b7 53 10             movzwl 0x10(%rbx),%edx
    0.00 :	  694f6f:       66 39 d0                cmp    %dx,%ax
    0.00 :	  694f72:       77 6c                   ja     694fe0 <PageIsVerified+0x110>
    0.00 :	  694f74:       66 81 fa 00 20          cmp    $0x2000,%dx
    0.00 :	  694f79:       77 65                   ja     694fe0 <PageIsVerified+0x110>
    0.00 :	  694f7b:       0f b7 d2                movzwl %dx,%edx
    0.00 :	  694f7e:       48 8d 42 07             lea    0x7(%rdx),%rax
    0.00 :	  694f82:       48 83 e0 f8             and    $0xfffffffffffffff8,%rax
    0.00 :	  694f86:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  694f89:       75 55                   jne    694fe0 <PageIsVerified+0x110>
         :	                        p->pd_upper <= p->pd_special &&
         :	                        p->pd_special <= BLCKSZ &&
         :	                        p->pd_special == MAXALIGN(p->pd_special))
         :	                        header_sane = true;
         :
         :	                if (header_sane && !checksum_failure)
    0.00 :	  694f8b:       84 c9                   test   %cl,%cl
    0.00 :	  694f8d:       74 a1                   je     694f30 <PageIsVerified+0x60>
    0.00 :	  694f8f:       41 bc 01 00 00 00       mov    $0x1,%r12d
    0.00 :	  694f95:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  694f9a:       e9 53 ff ff ff          jmpq   694ef2 <PageIsVerified+0x22>
    0.00 :	  694f9f:       90                      nop
         :	         * Throw a WARNING if the checksum fails, but only after we've checked for
         :	         * the all-zeroes case.
         :	         */
         :	        if (checksum_failure)
         :	        {
         :	                ereport(WARNING,
    0.00 :	  694fa0:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  694fa3:       b9 e4 de 8a 00          mov    $0x8adee4,%ecx
    0.00 :	  694fa8:       ba 91 00 00 00          mov    $0x91,%edx
    0.00 :	  694fad:       be 33 dc 8a 00          mov    $0x8adc33,%esi
    0.00 :	  694fb2:       bf 13 00 00 00          mov    $0x13,%edi
    0.00 :	  694fb7:       e8 04 5b 0e 00          callq  77aac0 <errstart>
    0.00 :	  694fbc:       84 c0                   test   %al,%al
    0.00 :	  694fbe:       75 42                   jne    695002 <PageIsVerified+0x132>
         :	                                (ERRCODE_DATA_CORRUPTED,
         :	                                 errmsg("page verification failed, calculated checksum %u but expected %u",
         :	                                                checksum, p->pd_checksum)));
         :
         :	                if (header_sane && ignore_checksum_failure)
    0.00 :	  694fc0:       45 84 e4                test   %r12b,%r12b
    0.00 :	  694fc3:       0f 84 51 ff ff ff       je     694f1a <PageIsVerified+0x4a>
    0.00 :	  694fc9:       80 3d b8 97 4e 00 00    cmpb   $0x0,0x4e97b8(%rip)        # b7e788 <ignore_checksum_failure>
    0.00 :	  694fd0:       0f 95 c0                setne  %al
    0.00 :	  694fd3:       e9 44 ff ff ff          jmpq   694f1c <PageIsVerified+0x4c>
    0.00 :	  694fd8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  694fdf:       00 
         :	                        p->pd_upper <= p->pd_special &&
         :	                        p->pd_special <= BLCKSZ &&
         :	                        p->pd_special == MAXALIGN(p->pd_special))
         :	                        header_sane = true;
         :
         :	                if (header_sane && !checksum_failure)
    0.00 :	  694fe0:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  694fe3:       e9 0a ff ff ff          jmpq   694ef2 <PageIsVerified+0x22>
         :	         */
         :	        if (!PageIsNew(page))
         :	        {
         :	                if (DataChecksumsEnabled())
         :	                {
         :	                        checksum = pg_checksum_page((char *) page, blkno);
    0.00 :	  694fe8:       44 89 e6                mov    %r12d,%esi
    0.00 :	  694feb:       48 89 df                mov    %rbx,%rdi
    0.00 :	  694fee:       e8 7d 13 00 00          callq  696370 <pg_checksum_page>
         :
         :	                        if (checksum != p->pd_checksum)
    0.00 :	  694ff3:       66 3b 43 08             cmp    0x8(%rbx),%ax
         :	         */
         :	        if (!PageIsNew(page))
         :	        {
         :	                if (DataChecksumsEnabled())
         :	                {
         :	                        checksum = pg_checksum_page((char *) page, blkno);
    0.00 :	  694ff7:       41 89 c5                mov    %eax,%r13d
         :
         :	                        if (checksum != p->pd_checksum)
    0.00 :	  694ffa:       0f 95 c1                setne  %cl
    0.00 :	  694ffd:       e9 50 ff ff ff          jmpq   694f52 <PageIsVerified+0x82>
         :	         * Throw a WARNING if the checksum fails, but only after we've checked for
         :	         * the all-zeroes case.
         :	         */
         :	        if (checksum_failure)
         :	        {
         :	                ereport(WARNING,
    0.00 :	  695002:       0f b7 53 08             movzwl 0x8(%rbx),%edx
    0.00 :	  695006:       41 0f b7 f5             movzwl %r13w,%esi
    0.00 :	  69500a:       bf 78 dc 8a 00          mov    $0x8adc78,%edi
    0.00 :	  69500f:       31 c0                   xor    %eax,%eax
    0.00 :	  695011:       e8 8a 78 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  695016:       bf 28 0a 00 01          mov    $0x1000a28,%edi
    0.00 :	  69501b:       89 c6                   mov    %eax,%esi
    0.00 :	  69501d:       31 c0                   xor    %eax,%eax
    0.00 :	  69501f:       e8 bc 55 0e 00          callq  77a5e0 <errfinish>
    0.00 :	  695024:       eb 9a                   jmp    694fc0 <PageIsVerified+0xf0>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:570
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000697940 <mdopen>:
         :	 * EXTENSION_CREATE means it's OK to extend an existing relation, not to
         :	 * invent one out of whole cloth.
         :	 */
         :	static MdfdVec *
         :	mdopen(SMgrRelation reln, ForkNumber forknum, ExtensionBehavior behavior)
         :	{
    0.00 :	  697940:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/smgr/md.c:570
  100.00 :	  697941:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  697944:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
         :	        MdfdVec    *mdfd;
         :	        char       *path;
         :	        File            fd;
         :
         :	        /* No work if already open */
         :	        if (reln->md_fd[forknum])
    0.00 :	  697948:       4c 63 ee                movslq %esi,%r13
         :	 * EXTENSION_CREATE means it's OK to extend an existing relation, not to
         :	 * invent one out of whole cloth.
         :	 */
         :	static MdfdVec *
         :	mdopen(SMgrRelation reln, ForkNumber forknum, ExtensionBehavior behavior)
         :	{
    0.00 :	  69794b:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  69794f:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  697953:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  697957:       49 89 fc                mov    %rdi,%r12
    0.00 :	  69795a:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  69795e:       48 83 ec 30             sub    $0x30,%rsp
         :	        MdfdVec    *mdfd;
         :	        char       *path;
         :	        File            fd;
         :
         :	        /* No work if already open */
         :	        if (reln->md_fd[forknum])
    0.00 :	  697962:       4a 8b 5c ef 28          mov    0x28(%rdi,%r13,8),%rbx
         :	 * EXTENSION_CREATE means it's OK to extend an existing relation, not to
         :	 * invent one out of whole cloth.
         :	 */
         :	static MdfdVec *
         :	mdopen(SMgrRelation reln, ForkNumber forknum, ExtensionBehavior behavior)
         :	{
    0.00 :	  697967:       41 89 d7                mov    %edx,%r15d
         :	        MdfdVec    *mdfd;
         :	        char       *path;
         :	        File            fd;
         :
         :	        /* No work if already open */
         :	        if (reln->md_fd[forknum])
    0.00 :	  69796a:       48 85 db                test   %rbx,%rbx
    0.00 :	  69796d:       74 21                   je     697990 <mdopen+0x50>
         :	        mdfd->mdfd_segno = 0;
         :	        mdfd->mdfd_chain = NULL;
         :	        Assert(_mdnblocks(reln, forknum, mdfd) <= ((BlockNumber) RELSEG_SIZE));
         :
         :	        return mdfd;
         :	}
    0.00 :	  69796f:       48 89 d8                mov    %rbx,%rax
    0.00 :	  697972:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  697976:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  69797a:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  69797e:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  697982:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  697986:       c9                      leaveq 
    0.00 :	  697987:       c3                      retq   
    0.00 :	  697988:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  69798f:       00 
         :
         :	        /* No work if already open */
         :	        if (reln->md_fd[forknum])
         :	                return reln->md_fd[forknum];
         :
         :	        path = relpath(reln->smgr_rnode, forknum);
    0.00 :	  697990:       8b 4f 0c                mov    0xc(%rdi),%ecx
    0.00 :	  697993:       8b 57 08                mov    0x8(%rdi),%edx
    0.00 :	  697996:       41 89 f0                mov    %esi,%r8d
    0.00 :	  697999:       8b 7f 04                mov    0x4(%rdi),%edi
    0.00 :	  69799c:       41 8b 34 24             mov    (%r12),%esi
    0.00 :	  6979a0:       e8 2b 6c 11 00          callq  7ae5d0 <GetRelationPath>
         :
         :	        fd = PathNameOpenFile(path, O_RDWR | PG_BINARY, 0600);
    0.00 :	  6979a5:       ba 80 01 00 00          mov    $0x180,%edx
    0.00 :	  6979aa:       be 02 00 00 00          mov    $0x2,%esi
    0.00 :	  6979af:       48 89 c7                mov    %rax,%rdi
         :
         :	        /* No work if already open */
         :	        if (reln->md_fd[forknum])
         :	                return reln->md_fd[forknum];
         :
         :	        path = relpath(reln->smgr_rnode, forknum);
    0.00 :	  6979b2:       48 89 45 d0             mov    %rax,-0x30(%rbp)
         :
         :	        fd = PathNameOpenFile(path, O_RDWR | PG_BINARY, 0600);
    0.00 :	  6979b6:       e8 45 25 fe ff          callq  679f00 <PathNameOpenFile>
         :
         :	        if (fd < 0)
    0.00 :	  6979bb:       85 c0                   test   %eax,%eax
         :	        if (reln->md_fd[forknum])
         :	                return reln->md_fd[forknum];
         :
         :	        path = relpath(reln->smgr_rnode, forknum);
         :
         :	        fd = PathNameOpenFile(path, O_RDWR | PG_BINARY, 0600);
    0.00 :	  6979bd:       41 89 c6                mov    %eax,%r14d
         :
         :	        if (fd < 0)
    0.00 :	  6979c0:       78 3e                   js     697a00 <mdopen+0xc0>
         :	                                        (errcode_for_file_access(),
         :	                                         errmsg("could not open file \"%s\": %m", path)));
         :	                }
         :	        }
         :
         :	        pfree(path);
    0.00 :	  6979c2:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  6979c6:       e8 b5 11 10 00          callq  798b80 <pfree>
         :	 *      _fdvec_alloc() -- Make a MdfdVec object.
         :	 */
         :	static MdfdVec *
         :	_fdvec_alloc(void)
         :	{
         :	        return (MdfdVec *) MemoryContextAlloc(MdCxt, sizeof(MdfdVec));
    0.00 :	  6979cb:       48 8b 3d de 6d 4e 00    mov    0x4e6dde(%rip),%rdi        # b7e7b0 <MdCxt>
    0.00 :	  6979d2:       be 10 00 00 00          mov    $0x10,%esi
    0.00 :	  6979d7:       e8 b4 14 10 00          callq  798e90 <MemoryContextAlloc>
         :	                }
         :	        }
         :
         :	        pfree(path);
         :
         :	        reln->md_fd[forknum] = mdfd = _fdvec_alloc();
    0.00 :	  6979dc:       4b 89 44 ec 28          mov    %rax,0x28(%r12,%r13,8)
         :	 *      _fdvec_alloc() -- Make a MdfdVec object.
         :	 */
         :	static MdfdVec *
         :	_fdvec_alloc(void)
         :	{
         :	        return (MdfdVec *) MemoryContextAlloc(MdCxt, sizeof(MdfdVec));
    0.00 :	  6979e1:       48 89 c3                mov    %rax,%rbx
         :
         :	        pfree(path);
         :
         :	        reln->md_fd[forknum] = mdfd = _fdvec_alloc();
         :
         :	        mdfd->mdfd_vfd = fd;
    0.00 :	  6979e4:       44 89 30                mov    %r14d,(%rax)
         :	        mdfd->mdfd_segno = 0;
    0.00 :	  6979e7:       c7 40 04 00 00 00 00    movl   $0x0,0x4(%rax)
         :	        mdfd->mdfd_chain = NULL;
    0.00 :	  6979ee:       48 c7 40 08 00 00 00    movq   $0x0,0x8(%rax)
    0.00 :	  6979f5:       00 
         :	        Assert(_mdnblocks(reln, forknum, mdfd) <= ((BlockNumber) RELSEG_SIZE));
         :
         :	        return mdfd;
         :	}
    0.00 :	  6979f6:       e9 74 ff ff ff          jmpq   69796f <mdopen+0x2f>
    0.00 :	  6979fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * During bootstrap, there are cases where a system relation will be
         :	                 * accessed (by internal backend processes) before the bootstrap
         :	                 * script nominally creates it.  Therefore, accept mdopen() as a
         :	                 * substitute for mdcreate() in bootstrap mode only. (See mdcreate)
         :	                 */
         :	                if (IsBootstrapProcessingMode())
    0.00 :	  697a00:       8b 05 36 11 4d 00       mov    0x4d1136(%rip),%eax        # b68b3c <Mode>
    0.00 :	  697a06:       85 c0                   test   %eax,%eax
    0.00 :	  697a08:       74 36                   je     697a40 <mdopen+0x100>
         :	                        fd = PathNameOpenFile(path, O_RDWR | O_CREAT | O_EXCL | PG_BINARY, 0600);
         :	                if (fd < 0)
         :	                {
         :	                        if (behavior == EXTENSION_RETURN_NULL &&
    0.00 :	  697a0a:       41 83 ef 01             sub    $0x1,%r15d
    0.00 :	  697a0e:       75 0a                   jne    697a1a <mdopen+0xda>
    0.00 :	  697a10:       e8 ab 22 dd ff          callq  469cc0 <__errno_location@plt>
    0.00 :	  697a15:       83 38 02                cmpl   $0x2,(%rax)
    0.00 :	  697a18:       74 6a                   je     697a84 <mdopen+0x144>
         :	                                FILE_POSSIBLY_DELETED(errno))
         :	                        {
         :	                                pfree(path);
         :	                                return NULL;
         :	                        }
         :	                        ereport(ERROR,
    0.00 :	  697a1a:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  697a1d:       b9 7f e3 8a 00          mov    $0x8ae37f,%ecx
    0.00 :	  697a22:       ba 5b 02 00 00          mov    $0x25b,%edx
    0.00 :	  697a27:       be db 5b 87 00          mov    $0x875bdb,%esi
    0.00 :	  697a2c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  697a31:       e8 8a 30 0e 00          callq  77aac0 <errstart>
    0.00 :	  697a36:       84 c0                   test   %al,%al
    0.00 :	  697a38:       75 26                   jne    697a60 <mdopen+0x120>
    0.00 :	  697a3a:       e8 91 1a dd ff          callq  4694d0 <abort@plt>
    0.00 :	  697a3f:       90                      nop
         :	                 * accessed (by internal backend processes) before the bootstrap
         :	                 * script nominally creates it.  Therefore, accept mdopen() as a
         :	                 * substitute for mdcreate() in bootstrap mode only. (See mdcreate)
         :	                 */
         :	                if (IsBootstrapProcessingMode())
         :	                        fd = PathNameOpenFile(path, O_RDWR | O_CREAT | O_EXCL | PG_BINARY, 0600);
    0.00 :	  697a40:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  697a44:       ba 80 01 00 00          mov    $0x180,%edx
    0.00 :	  697a49:       be c2 00 00 00          mov    $0xc2,%esi
    0.00 :	  697a4e:       e8 ad 24 fe ff          callq  679f00 <PathNameOpenFile>
         :	                if (fd < 0)
    0.00 :	  697a53:       85 c0                   test   %eax,%eax
         :	                 * accessed (by internal backend processes) before the bootstrap
         :	                 * script nominally creates it.  Therefore, accept mdopen() as a
         :	                 * substitute for mdcreate() in bootstrap mode only. (See mdcreate)
         :	                 */
         :	                if (IsBootstrapProcessingMode())
         :	                        fd = PathNameOpenFile(path, O_RDWR | O_CREAT | O_EXCL | PG_BINARY, 0600);
    0.00 :	  697a55:       41 89 c6                mov    %eax,%r14d
         :	                if (fd < 0)
    0.00 :	  697a58:       0f 89 64 ff ff ff       jns    6979c2 <mdopen+0x82>
    0.00 :	  697a5e:       eb aa                   jmp    697a0a <mdopen+0xca>
         :	                                FILE_POSSIBLY_DELETED(errno))
         :	                        {
         :	                                pfree(path);
         :	                                return NULL;
         :	                        }
         :	                        ereport(ERROR,
    0.00 :	  697a60:       48 8b 75 d0             mov    -0x30(%rbp),%rsi
    0.00 :	  697a64:       bf 53 31 7b 00          mov    $0x7b3153,%edi
    0.00 :	  697a69:       31 c0                   xor    %eax,%eax
    0.00 :	  697a6b:       e8 30 4e 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  697a70:       89 c3                   mov    %eax,%ebx
    0.00 :	  697a72:       e8 79 50 0e 00          callq  77caf0 <errcode_for_file_access>
    0.00 :	  697a77:       89 de                   mov    %ebx,%esi
    0.00 :	  697a79:       89 c7                   mov    %eax,%edi
    0.00 :	  697a7b:       31 c0                   xor    %eax,%eax
    0.00 :	  697a7d:       e8 5e 2b 0e 00          callq  77a5e0 <errfinish>
    0.00 :	  697a82:       eb b6                   jmp    697a3a <mdopen+0xfa>
         :	                if (fd < 0)
         :	                {
         :	                        if (behavior == EXTENSION_RETURN_NULL &&
         :	                                FILE_POSSIBLY_DELETED(errno))
         :	                        {
         :	                                pfree(path);
    0.00 :	  697a84:       48 8b 7d d0             mov    -0x30(%rbp),%rdi
    0.00 :	  697a88:       e8 f3 10 10 00          callq  798b80 <pfree>
    0.00 :	  697a8d:       0f 1f 00                nopl   (%rax)
         :	        mdfd->mdfd_segno = 0;
         :	        mdfd->mdfd_chain = NULL;
         :	        Assert(_mdnblocks(reln, forknum, mdfd) <= ((BlockNumber) RELSEG_SIZE));
         :
         :	        return mdfd;
         :	}
    0.00 :	  697a90:       e9 da fe ff ff          jmpq   69796f <mdopen+0x2f>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/timestamp.c:4316
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/timestamp.c:4343
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007445b0 <timestamp_part>:
         :	/* timestamp_part()
         :	 * Extract specified field from timestamp.
         :	 */
         :	Datum
         :	timestamp_part(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/timestamp.c:4316
   50.00 :	  7445b0:       55                      push   %rbp
    0.00 :	  7445b1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7445b4:       41 55                   push   %r13
    0.00 :	  7445b6:       41 54                   push   %r12
    0.00 :	  7445b8:       53                      push   %rbx
    0.00 :	  7445b9:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  7445bc:       48 83 ec 48             sub    $0x48,%rsp
         :	        text       *units = PG_GETARG_TEXT_PP(0);
    0.00 :	  7445c0:       48 8b 7f 20             mov    0x20(%rdi),%rdi
    0.00 :	  7445c4:       e8 17 a7 03 00          callq  77ece0 <pg_detoast_datum_packed>
         :	        Timestamp       timestamp = PG_GETARG_TIMESTAMP(1);
    0.00 :	  7445c9:       48 8b 5b 28             mov    0x28(%rbx),%rbx
         :	 * Extract specified field from timestamp.
         :	 */
         :	Datum
         :	timestamp_part(PG_FUNCTION_ARGS)
         :	{
         :	        text       *units = PG_GETARG_TEXT_PP(0);
    0.00 :	  7445cd:       48 89 c2                mov    %rax,%rdx
         :	        char       *lowunits;
         :	        fsec_t          fsec;
         :	        struct pg_tm tt,
         :	                           *tm = &tt;
         :
         :	        if (TIMESTAMP_NOT_FINITE(timestamp))
    0.00 :	  7445d0:       48 b8 00 00 00 00 00    movabs $0x8000000000000000,%rax
    0.00 :	  7445d7:       00 00 80 
    0.00 :	  7445da:       48 39 c3                cmp    %rax,%rbx
    0.00 :	  7445dd:       0f 84 e5 00 00 00       je     7446c8 <timestamp_part+0x118>
    0.00 :	  7445e3:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  7445e7:       48 39 c3                cmp    %rax,%rbx
    0.00 :	  7445ea:       0f 84 d8 00 00 00       je     7446c8 <timestamp_part+0x118>
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
         :	        }
         :
         :	        lowunits = downcase_truncate_identifier(VARDATA_ANY(units),
    0.00 :	  7445f0:       0f b6 02                movzbl (%rdx),%eax
    0.00 :	  7445f3:       3c 01                   cmp    $0x1,%al
    0.00 :	  7445f5:       0f 84 a5 00 00 00       je     7446a0 <timestamp_part+0xf0>
    0.00 :	  7445fb:       a8 01                   test   $0x1,%al
    0.00 :	  7445fd:       0f 84 dd 00 00 00       je     7446e0 <timestamp_part+0x130>
    0.00 :	  744603:       d0 e8                   shr    %al
    0.00 :	  744605:       0f b6 c0                movzbl %al,%eax
    0.00 :	  744608:       8d 70 ff                lea    -0x1(%rax),%esi
    0.00 :	  74460b:       48 8d 7a 01             lea    0x1(%rdx),%rdi
         :	                                                                                        VARSIZE_ANY_EXHDR(units),
         :	                                                                                        false);
         :
         :	        type = DecodeUnits(0, lowunits, &val);
    0.00 :	  74460f:       4c 8d 65 dc             lea    -0x24(%rbp),%r12
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
         :	        }
         :
         :	        lowunits = downcase_truncate_identifier(VARDATA_ANY(units),
    0.00 :	  744613:       31 d2                   xor    %edx,%edx
    0.00 :	  744615:       e8 a6 38 e0 ff          callq  547ec0 <downcase_truncate_identifier>
         :	                                                                                        VARSIZE_ANY_EXHDR(units),
         :	                                                                                        false);
         :
         :	        type = DecodeUnits(0, lowunits, &val);
    0.00 :	  74461a:       31 ff                   xor    %edi,%edi
    0.00 :	  74461c:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  74461f:       48 89 c6                mov    %rax,%rsi
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
         :	        }
         :
         :	        lowunits = downcase_truncate_identifier(VARDATA_ANY(units),
    0.00 :	  744622:       49 89 c5                mov    %rax,%r13
         :	                                                                                        VARSIZE_ANY_EXHDR(units),
         :	                                                                                        false);
         :
         :	        type = DecodeUnits(0, lowunits, &val);
    0.00 :	  744625:       e8 76 62 f8 ff          callq  6ca8a0 <DecodeUnits>
         :	        if (type == UNKNOWN_FIELD)
    0.00 :	  74462a:       83 f8 1f                cmp    $0x1f,%eax
    0.00 :	  74462d:       0f 84 fd 01 00 00       je     744830 <timestamp_part+0x280>
         :	                type = DecodeSpecial(0, lowunits, &val);
         :
         :	        if (type == UNITS)
    0.00 :	  744633:       83 f8 11                cmp    $0x11,%eax
    0.00 :	  744636:       0f 84 b4 01 00 00       je     7447f0 <timestamp_part+0x240>
         :	                                                 errmsg("timestamp units \"%s\" not supported",
         :	                                                                lowunits)));
         :	                                result = 0;
         :	                }
         :	        }
         :	        else if (type == RESERV)
    0.00 :	  74463c:       85 c0                   test   %eax,%eax
    0.00 :	  74463e:       66 90                   xchg   %ax,%ax
    0.00 :	  744640:       0f 85 ed 03 00 00       jne    744a33 <timestamp_part+0x483>
         :	        {
         :	                switch (val)
    0.00 :	  744646:       8b 45 dc                mov    -0x24(%rbp),%eax
    0.00 :	  744649:       83 f8 21                cmp    $0x21,%eax
    0.00 :	  74464c:       0f 84 4e 01 00 00       je     7447a0 <timestamp_part+0x1f0>
    0.00 :	  744652:       0f 8f a0 00 00 00       jg     7446f8 <timestamp_part+0x148>
    0.00 :	  744658:       83 f8 0b                cmp    $0xb,%eax
    0.00 :	  74465b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  744660:       0f 84 0a 01 00 00       je     744770 <timestamp_part+0x1c0>
    0.00 :	  744666:       83 f8 20                cmp    $0x20,%eax
    0.00 :	  744669:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  744670:       0f 84 8b 00 00 00       je     744701 <timestamp_part+0x151>
         :	                                result = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)
         :	                                                  - date2j(tm->tm_year, 1, 1) + 1);
         :	                                break;
         :
         :	                        default:
         :	                                ereport(ERROR,
    0.00 :	  744676:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  744679:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  74467e:       ba 98 11 00 00          mov    $0x1198,%edx
    0.00 :	  744683:       be 17 94 8c 00          mov    $0x8c9417,%esi
    0.00 :	  744688:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  74468d:       e8 2e 64 03 00          callq  77aac0 <errstart>
    0.00 :	  744692:       84 c0                   test   %al,%al
    0.00 :	  744694:       0f 85 6e 03 00 00       jne    744a08 <timestamp_part+0x458>
         :	                }
         :
         :	        }
         :	        else
         :	        {
         :	                ereport(ERROR,
    0.00 :	  74469a:       e8 31 4e d2 ff          callq  4694d0 <abort@plt>
    0.00 :	  74469f:       90                      nop
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
         :	        }
         :
         :	        lowunits = downcase_truncate_identifier(VARDATA_ANY(units),
    0.00 :	  7446a0:       0f b6 42 01             movzbl 0x1(%rdx),%eax
    0.00 :	  7446a4:       be 08 00 00 00          mov    $0x8,%esi
    0.00 :	  7446a9:       3c 01                   cmp    $0x1,%al
    0.00 :	  7446ab:       0f 84 5a ff ff ff       je     74460b <timestamp_part+0x5b>
    0.00 :	  7446b1:       3c 12                   cmp    $0x12,%al
    0.00 :	  7446b3:       40 b6 10                mov    $0x10,%sil
    0.00 :	  7446b6:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  7446bb:       0f 45 f0                cmovne %eax,%esi
    0.00 :	  7446be:       e9 48 ff ff ff          jmpq   74460b <timestamp_part+0x5b>
    0.00 :	  7446c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                           *tm = &tt;
         :
         :	        if (TIMESTAMP_NOT_FINITE(timestamp))
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
    0.00 :	  7446c8:       66 0f 57 c0             xorpd  %xmm0,%xmm0
    0.00 :	  7446cc:       e8 ef 92 03 00          callq  77d9c0 <Float8GetDatum>
         :	                                 errmsg("timestamp units \"%s\" not recognized", lowunits)));
         :	                result = 0;
         :	        }
         :
         :	        PG_RETURN_FLOAT8(result);
         :	}
    0.00 :	  7446d1:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  7446d5:       5b                      pop    %rbx
    0.00 :	  7446d6:       41 5c                   pop    %r12
    0.00 :	  7446d8:       41 5d                   pop    %r13
    0.00 :	  7446da:       c9                      leaveq 
    0.00 :	  7446db:       c3                      retq   
    0.00 :	  7446dc:       0f 1f 40 00             nopl   0x0(%rax)
         :	        {
         :	                result = 0;
         :	                PG_RETURN_FLOAT8(result);
         :	        }
         :
         :	        lowunits = downcase_truncate_identifier(VARDATA_ANY(units),
    0.00 :	  7446e0:       8b 02                   mov    (%rdx),%eax
    0.00 :	  7446e2:       48 8d 7a 04             lea    0x4(%rdx),%rdi
    0.00 :	  7446e6:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  7446e9:       8d 70 fc                lea    -0x4(%rax),%esi
    0.00 :	  7446ec:       e9 1e ff ff ff          jmpq   74460f <timestamp_part+0x5f>
    0.00 :	  7446f1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                result = 0;
         :	                }
         :	        }
         :	        else if (type == RESERV)
         :	        {
         :	                switch (val)
    0.00 :	  7446f8:       83 f8 25                cmp    $0x25,%eax
    0.00 :	  7446fb:       0f 85 75 ff ff ff       jne    744676 <timestamp_part+0xc6>
         :	#endif
         :	                                break;
         :
         :	                        case DTK_DOW:
         :	                        case DTK_ISODOW:
         :	                                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
    0.00 :	  744701:       48 8d 4d d8             lea    -0x28(%rbp),%rcx
    0.00 :	  744705:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
    0.00 :	  744709:       45 31 c9                xor    %r9d,%r9d
    0.00 :	  74470c:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  74470f:       31 f6                   xor    %esi,%esi
    0.00 :	  744711:       48 89 df                mov    %rbx,%rdi
    0.00 :	  744714:       e8 87 ed ff ff          callq  7434a0 <timestamp2tm>
    0.00 :	  744719:       85 c0                   test   %eax,%eax
    0.00 :	  74471b:       0f 85 b9 03 00 00       jne    744ada <timestamp_part+0x52a>
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
         :	                                                         errmsg("timestamp out of range")));
         :	                                result = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));
    0.00 :	  744721:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  744724:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  744727:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  74472a:       e8 f1 55 f8 ff          callq  6c9d20 <date2j>
    0.00 :	  74472f:       89 c7                   mov    %eax,%edi
    0.00 :	  744731:       e8 8a 57 f8 ff          callq  6c9ec0 <j2day>
         :	                                if (val == DTK_ISODOW && result == 0)
    0.00 :	  744736:       83 7d dc 25             cmpl   $0x25,-0x24(%rbp)
         :	                        case DTK_ISODOW:
         :	                                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
         :	                                                         errmsg("timestamp out of range")));
         :	                                result = j2day(date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));
    0.00 :	  74473a:       f2 0f 2a d8             cvtsi2sd %eax,%xmm3
         :	                                if (val == DTK_ISODOW && result == 0)
    0.00 :	  74473e:       75 45                   jne    744785 <timestamp_part+0x1d5>
         :	                }
         :
         :	        }
         :	        else
         :	        {
         :	                ereport(ERROR,
    0.00 :	  744740:       66 0f 28 c3             movapd %xmm3,%xmm0
    0.00 :	  744744:       66 0f 28 d3             movapd %xmm3,%xmm2
    0.00 :	  744748:       f2 0f 10 0d 30 5c 18    movsd  0x185c30(%rip),%xmm1        # 8ca380 <__func__.17278+0x30>
    0.00 :	  74474f:       00 
    0.00 :	  744750:       f2 0f c2 05 7f db 06    cmpneqsd 0x6db7f(%rip),%xmm0        # 7b22d8 <__func__.14992+0xcf>
    0.00 :	  744757:       00 04 
    0.00 :	  744759:       66 0f 28 d8             movapd %xmm0,%xmm3
    0.00 :	  74475d:       66 0f 54 d0             andpd  %xmm0,%xmm2
    0.00 :	  744761:       66 0f 55 d9             andnpd %xmm1,%xmm3
    0.00 :	  744765:       66 0f 56 da             orpd   %xmm2,%xmm3
    0.00 :	  744769:       eb 1a                   jmp    744785 <timestamp_part+0x1d5>
    0.00 :	  74476b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        {
         :	                switch (val)
         :	                {
         :	                        case DTK_EPOCH:
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result = (timestamp - SetEpochTimestamp()) / 1000000.0;
    0.00 :	  744770:       e8 fb ec ff ff          callq  743470 <SetEpochTimestamp>
    0.00 :	  744775:       48 29 c3                sub    %rax,%rbx
    0.00 :	  744778:       f2 48 0f 2a db          cvtsi2sd %rbx,%xmm3
    0.00 :	  74477d:       f2 0f 5e 1d 5b 7e 13    divsd  0x137e5b(%rip),%xmm3        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  744784:       00 
         :	                                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
         :	                                 errmsg("timestamp units \"%s\" not recognized", lowunits)));
         :	                result = 0;
         :	        }
         :
         :	        PG_RETURN_FLOAT8(result);
    0.00 :	  744785:       66 0f 28 c3             movapd %xmm3,%xmm0
    0.00 :	  744789:       e8 32 92 03 00          callq  77d9c0 <Float8GetDatum>
         :	}
    0.00 :	  74478e:       48 83 c4 48             add    $0x48,%rsp
    0.00 :	  744792:       5b                      pop    %rbx
    0.00 :	  744793:       41 5c                   pop    %r12
    0.00 :	  744795:       41 5d                   pop    %r13
    0.00 :	  744797:       c9                      leaveq 
    0.00 :	  744798:       c3                      retq   
    0.00 :	  744799:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                if (val == DTK_ISODOW && result == 0)
         :	                                        result = 7;
         :	                                break;
         :
         :	                        case DTK_DOY:
         :	                                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
    0.00 :	  7447a0:       48 8d 4d d8             lea    -0x28(%rbp),%rcx
    0.00 :	  7447a4:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
    0.00 :	  7447a8:       45 31 c9                xor    %r9d,%r9d
    0.00 :	  7447ab:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7447ae:       31 f6                   xor    %esi,%esi
    0.00 :	  7447b0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  7447b3:       e8 e8 ec ff ff          callq  7434a0 <timestamp2tm>
    0.00 :	  7447b8:       85 c0                   test   %eax,%eax
    0.00 :	  7447ba:       0f 85 56 03 00 00       jne    744b16 <timestamp_part+0x566>
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
         :	                                                         errmsg("timestamp out of range")));
         :	                                result = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)
    0.00 :	  7447c0:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  7447c3:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  7447c6:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  7447c9:       e8 52 55 f8 ff          callq  6c9d20 <date2j>
    0.00 :	  7447ce:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  7447d1:       89 c3                   mov    %eax,%ebx
    0.00 :	  7447d3:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  7447d8:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  7447dd:       e8 3e 55 f8 ff          callq  6c9d20 <date2j>
    0.00 :	  7447e2:       8d 53 01                lea    0x1(%rbx),%edx
    0.00 :	  7447e5:       29 c2                   sub    %eax,%edx
    0.00 :	  7447e7:       f2 0f 2a da             cvtsi2sd %edx,%xmm3
         :	                                                  - date2j(tm->tm_year, 1, 1) + 1);
         :	                                break;
    0.00 :	  7447eb:       eb 98                   jmp    744785 <timestamp_part+0x1d5>
    0.00 :	  7447ed:       0f 1f 00                nopl   (%rax)
         :	        if (type == UNKNOWN_FIELD)
         :	                type = DecodeSpecial(0, lowunits, &val);
         :
         :	        if (type == UNITS)
         :	        {
         :	                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
    0.00 :	  7447f0:       48 8d 4d d8             lea    -0x28(%rbp),%rcx
    0.00 :	  7447f4:       48 8d 55 a0             lea    -0x60(%rbp),%rdx
    0.00 :	  7447f8:       45 31 c9                xor    %r9d,%r9d
    0.00 :	  7447fb:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7447fe:       31 f6                   xor    %esi,%esi
    0.00 :	  744800:       48 89 df                mov    %rbx,%rdi
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/timestamp.c:4343
   50.00 :	  744803:       e8 98 ec ff ff          callq  7434a0 <timestamp2tm>
    0.00 :	  744808:       85 c0                   test   %eax,%eax
    0.00 :	  74480a:       0f 85 15 03 00 00       jne    744b25 <timestamp_part+0x575>
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
         :	                                         errmsg("timestamp out of range")));
         :
         :	                switch (val)
    0.00 :	  744810:       8b 45 dc                mov    -0x24(%rbp),%eax
    0.00 :	  744813:       83 e8 12                sub    $0x12,%eax
    0.00 :	  744816:       83 f8 12                cmp    $0x12,%eax
    0.00 :	  744819:       76 2d                   jbe    744848 <timestamp_part+0x298>
         :
         :	                        case DTK_TZ:
         :	                        case DTK_TZ_MINUTE:
         :	                        case DTK_TZ_HOUR:
         :	                        default:
         :	                                ereport(ERROR,
    0.00 :	  74481b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  74481e:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  744823:       ba 70 11 00 00          mov    $0x1170,%edx
    0.00 :	  744828:       e9 56 fe ff ff          jmpq   744683 <timestamp_part+0xd3>
    0.00 :	  74482d:       0f 1f 00                nopl   (%rax)
         :	                                                                                        VARSIZE_ANY_EXHDR(units),
         :	                                                                                        false);
         :
         :	        type = DecodeUnits(0, lowunits, &val);
         :	        if (type == UNKNOWN_FIELD)
         :	                type = DecodeSpecial(0, lowunits, &val);
    0.00 :	  744830:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  744833:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  744836:       31 ff                   xor    %edi,%edi
    0.00 :	  744838:       e8 33 61 f8 ff          callq  6ca970 <DecodeSpecial>
    0.00 :	  74483d:       e9 f1 fd ff ff          jmpq   744633 <timestamp_part+0x83>
    0.00 :	  744842:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
         :	                        ereport(ERROR,
         :	                                        (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
         :	                                         errmsg("timestamp out of range")));
         :
         :	                switch (val)
    0.00 :	  744848:       89 c0                   mov    %eax,%eax
    0.00 :	  74484a:       ff 24 c5 58 9c 8c 00    jmpq   *0x8c9c58(,%rax,8)
         :	                                                   tm->tm_sec + fsec) / (double) SECS_PER_DAY;
         :	#endif
         :	                                break;
         :
         :	                        case DTK_ISOYEAR:
         :	                                result = date2isoyear(tm->tm_year, tm->tm_mon, tm->tm_mday);
    0.00 :	  744851:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  744854:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  744857:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  74485a:       e8 51 e1 ff ff          callq  7429b0 <date2isoyear>
    0.00 :	  74485f:       f2 0f 2a d8             cvtsi2sd %eax,%xmm3
         :	                                break;
    0.00 :	  744863:       e9 1d ff ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                else
         :	                                        result = -((999 - (tm->tm_year - 1)) / 1000);
         :	                                break;
         :
         :	                        case DTK_JULIAN:
         :	                                result = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);
    0.00 :	  744868:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  74486b:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  74486e:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  744871:       e8 aa 54 f8 ff          callq  6c9d20 <date2j>
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +
    0.00 :	  744876:       f2 0f 2a 45 d8          cvtsi2sdl -0x28(%rbp),%xmm0
         :	                                else
         :	                                        result = -((999 - (tm->tm_year - 1)) / 1000);
         :	                                break;
         :
         :	                        case DTK_JULIAN:
         :	                                result = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);
    0.00 :	  74487b:       f2 0f 2a c8             cvtsi2sd %eax,%xmm1
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +
    0.00 :	  74487f:       f2 0f 5e 05 59 7d 13    divsd  0x137d59(%rip),%xmm0        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  744886:       00 
    0.00 :	  744887:       8b 45 a8                mov    -0x58(%rbp),%eax
    0.00 :	  74488a:       41 b9 3c 00 00 00       mov    $0x3c,%r9d
    0.00 :	  744890:       41 b8 3c 00 00 00       mov    $0x3c,%r8d
    0.00 :	  744896:       41 0f af c1             imul   %r9d,%eax
    0.00 :	  74489a:       03 45 a4                add    -0x5c(%rbp),%eax
    0.00 :	  74489d:       41 0f af c0             imul   %r8d,%eax
    0.00 :	  7448a1:       03 45 a0                add    -0x60(%rbp),%eax
    0.00 :	  7448a4:       f2 0f 2a d8             cvtsi2sd %eax,%xmm3
    0.00 :	  7448a8:       f2 0f 58 d8             addsd  %xmm0,%xmm3
    0.00 :	  7448ac:       f2 0f 5e 1d 14 ef 17    divsd  0x17ef14(%rip),%xmm3        # 8c37c8 <__func__.12046+0x1c>
    0.00 :	  7448b3:       00 
    0.00 :	  7448b4:       f2 0f 58 d9             addsd  %xmm1,%xmm3
         :	                                        tm->tm_sec + (fsec / 1000000.0)) / (double) SECS_PER_DAY;
         :	#else
         :	                                result += ((((tm->tm_hour * MINS_PER_HOUR) + tm->tm_min) * SECS_PER_MINUTE) +
         :	                                                   tm->tm_sec + fsec) / (double) SECS_PER_DAY;
         :	#endif
         :	                                break;
    0.00 :	  7448b8:       e9 c8 fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :
         :	                switch (val)
         :	                {
         :	                        case DTK_MICROSEC:
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result = tm->tm_sec * 1000000.0 + fsec;
    0.00 :	  7448bd:       f2 0f 2a 5d a0          cvtsi2sdl -0x60(%rbp),%xmm3
    0.00 :	  7448c2:       f2 0f 59 1d 16 7d 13    mulsd  0x137d16(%rip),%xmm3        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  7448c9:       00 
    0.00 :	  7448ca:       f2 0f 2a 45 d8          cvtsi2sdl -0x28(%rbp),%xmm0
    0.00 :	  7448cf:       f2 0f 58 d8             addsd  %xmm0,%xmm3
         :	#else
         :	                                result = (tm->tm_sec + fsec) * 1000000;
         :	#endif
         :	                                break;
    0.00 :	  7448d3:       e9 ad fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :
         :	                        case DTK_MILLISEC:
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result = tm->tm_sec * 1000.0 + fsec / 1000.0;
    0.00 :	  7448d8:       f2 0f 10 0d f8 7c 13    movsd  0x137cf8(%rip),%xmm1        # 87c5d8 <__func__.18742+0x13>
    0.00 :	  7448df:       00 
    0.00 :	  7448e0:       f2 0f 2a 45 d8          cvtsi2sdl -0x28(%rbp),%xmm0
    0.00 :	  7448e5:       f2 0f 2a 5d a0          cvtsi2sdl -0x60(%rbp),%xmm3
    0.00 :	  7448ea:       f2 0f 5e c1             divsd  %xmm1,%xmm0
    0.00 :	  7448ee:       f2 0f 59 d9             mulsd  %xmm1,%xmm3
    0.00 :	  7448f2:       f2 0f 58 d8             addsd  %xmm0,%xmm3
         :	#else
         :	                                result = (tm->tm_sec + fsec) * 1000;
         :	#endif
         :	                                break;
    0.00 :	  7448f6:       e9 8a fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                        result = -((99 - (tm->tm_year - 1)) / 100);
         :	                                break;
         :
         :	                        case DTK_MILLENNIUM:
         :	                                /* see comments above. */
         :	                                if (tm->tm_year > 0)
    0.00 :	  7448fb:       8b 55 b4                mov    -0x4c(%rbp),%edx
    0.00 :	  7448fe:       85 d2                   test   %edx,%edx
    0.00 :	  744900:       0f 8e 69 01 00 00       jle    744a6f <timestamp_part+0x4bf>
         :	                                        result = (tm->tm_year + 999) / 1000;
    0.00 :	  744906:       8d 8a e7 03 00 00       lea    0x3e7(%rdx),%ecx
    0.00 :	  74490c:       ba d3 4d 62 10          mov    $0x10624dd3,%edx
    0.00 :	  744911:       89 c8                   mov    %ecx,%eax
    0.00 :	  744913:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  744916:       f7 ea                   imul   %edx
    0.00 :	  744918:       c1 fa 06                sar    $0x6,%edx
    0.00 :	  74491b:       29 ca                   sub    %ecx,%edx
    0.00 :	  74491d:       f2 0f 2a da             cvtsi2sd %edx,%xmm3
    0.00 :	  744921:       e9 5f fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                 * centuries AD, c>0: year in [ (c-1)* 100 + 1 : c*100 ]
         :	                                 * centuries BC, c<0: year in [ c*100 : (c+1) * 100 - 1]
         :	                                 * there is no number 0 century.
         :	                                 * ----
         :	                                 */
         :	                                if (tm->tm_year > 0)
    0.00 :	  744926:       8b 55 b4                mov    -0x4c(%rbp),%edx
    0.00 :	  744929:       85 d2                   test   %edx,%edx
    0.00 :	  74492b:       0f 8e 67 01 00 00       jle    744a98 <timestamp_part+0x4e8>
         :	                                        result = (tm->tm_year + 99) / 100;
    0.00 :	  744931:       8d 4a 63                lea    0x63(%rdx),%ecx
    0.00 :	  744934:       ba 1f 85 eb 51          mov    $0x51eb851f,%edx
    0.00 :	  744939:       89 c8                   mov    %ecx,%eax
    0.00 :	  74493b:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  74493e:       f7 ea                   imul   %edx
    0.00 :	  744940:       c1 fa 05                sar    $0x5,%edx
    0.00 :	  744943:       29 ca                   sub    %ecx,%edx
    0.00 :	  744945:       f2 0f 2a da             cvtsi2sd %edx,%xmm3
    0.00 :	  744949:       e9 37 fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_WEEK:
         :	                                result = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);
         :	                                break;
         :
         :	                        case DTK_YEAR:
         :	                                if (tm->tm_year > 0)
    0.00 :	  74494e:       8b 45 b4                mov    -0x4c(%rbp),%eax
    0.00 :	  744951:       85 c0                   test   %eax,%eax
    0.00 :	  744953:       0f 8e 37 01 00 00       jle    744a90 <timestamp_part+0x4e0>
         :	                                        result = tm->tm_year;
         :	                                else
         :	                                        /* there is no year 0, just 1 BC and 1 AD */
         :	                                        result = tm->tm_year - 1;
    0.00 :	  744959:       f2 0f 2a d8             cvtsi2sd %eax,%xmm3
    0.00 :	  74495d:       e9 23 fe ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                /*
         :	                                 * what is a decade wrt dates? let us assume that decade 199
         :	                                 * is 1990 thru 1999... decade 0 starts on year 1 BC, and -1
         :	                                 * is 11 BC thru 2 BC...
         :	                                 */
         :	                                if (tm->tm_year >= 0)
    0.00 :	  744962:       8b 4d b4                mov    -0x4c(%rbp),%ecx
    0.00 :	  744965:       85 c9                   test   %ecx,%ecx
    0.00 :	  744967:       0f 88 4c 01 00 00       js     744ab9 <timestamp_part+0x509>
         :	                                        result = tm->tm_year / 10;
    0.00 :	  74496d:       89 c8                   mov    %ecx,%eax
    0.00 :	  74496f:       ba 67 66 66 66          mov    $0x66666667,%edx
    0.00 :	  744974:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  744977:       f7 ea                   imul   %edx
    0.00 :	  744979:       c1 fa 02                sar    $0x2,%edx
    0.00 :	  74497c:       29 ca                   sub    %ecx,%edx
    0.00 :	  74497e:       f2 0f 2a da             cvtsi2sd %edx,%xmm3
    0.00 :	  744982:       e9 fe fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_MONTH:
         :	                                result = tm->tm_mon;
         :	                                break;
         :
         :	                        case DTK_QUARTER:
         :	                                result = (tm->tm_mon - 1) / 3 + 1;
    0.00 :	  744987:       8b 45 b0                mov    -0x50(%rbp),%eax
    0.00 :	  74498a:       ba 56 55 55 55          mov    $0x55555556,%edx
    0.00 :	  74498f:       8d 48 ff                lea    -0x1(%rax),%ecx
    0.00 :	  744992:       89 c8                   mov    %ecx,%eax
    0.00 :	  744994:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  744997:       f7 ea                   imul   %edx
    0.00 :	  744999:       29 ca                   sub    %ecx,%edx
    0.00 :	  74499b:       83 c2 01                add    $0x1,%edx
    0.00 :	  74499e:       f2 0f 2a da             cvtsi2sd %edx,%xmm3
         :	                                break;
    0.00 :	  7449a2:       e9 de fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_DAY:
         :	                                result = tm->tm_mday;
         :	                                break;
         :
         :	                        case DTK_MONTH:
         :	                                result = tm->tm_mon;
    0.00 :	  7449a7:       f2 0f 2a 5d b0          cvtsi2sdl -0x50(%rbp),%xmm3
         :	                                break;
    0.00 :	  7449ac:       e9 d4 fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_QUARTER:
         :	                                result = (tm->tm_mon - 1) / 3 + 1;
         :	                                break;
         :
         :	                        case DTK_WEEK:
         :	                                result = (float8) date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday);
    0.00 :	  7449b1:       8b 55 ac                mov    -0x54(%rbp),%edx
    0.00 :	  7449b4:       8b 75 b0                mov    -0x50(%rbp),%esi
    0.00 :	  7449b7:       8b 7d b4                mov    -0x4c(%rbp),%edi
    0.00 :	  7449ba:       e8 e1 e0 ff ff          callq  742aa0 <date2isoweek>
    0.00 :	  7449bf:       f2 0f 2a d8             cvtsi2sd %eax,%xmm3
         :	                                break;
    0.00 :	  7449c3:       e9 bd fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_HOUR:
         :	                                result = tm->tm_hour;
         :	                                break;
         :
         :	                        case DTK_DAY:
         :	                                result = tm->tm_mday;
    0.00 :	  7449c8:       f2 0f 2a 5d ac          cvtsi2sdl -0x54(%rbp),%xmm3
         :	                                break;
    0.00 :	  7449cd:       e9 b3 fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_MINUTE:
         :	                                result = tm->tm_min;
         :	                                break;
         :
         :	                        case DTK_HOUR:
         :	                                result = tm->tm_hour;
    0.00 :	  7449d2:       f2 0f 2a 5d a8          cvtsi2sdl -0x58(%rbp),%xmm3
         :	                                break;
    0.00 :	  7449d7:       e9 a9 fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                result = tm->tm_sec + fsec;
         :	#endif
         :	                                break;
         :
         :	                        case DTK_MINUTE:
         :	                                result = tm->tm_min;
    0.00 :	  7449dc:       f2 0f 2a 5d a4          cvtsi2sdl -0x5c(%rbp),%xmm3
         :	                                break;
    0.00 :	  7449e1:       e9 9f fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	#endif
         :	                                break;
         :
         :	                        case DTK_SECOND:
         :	#ifdef HAVE_INT64_TIMESTAMP
         :	                                result = tm->tm_sec + fsec / 1000000.0;
    0.00 :	  7449e6:       f2 0f 2a 45 d8          cvtsi2sdl -0x28(%rbp),%xmm0
    0.00 :	  7449eb:       f2 0f 5e 05 ed 7b 13    divsd  0x137bed(%rip),%xmm0        # 87c5e0 <__func__.18742+0x1b>
    0.00 :	  7449f2:       00 
    0.00 :	  7449f3:       f2 0f 2a 5d a0          cvtsi2sdl -0x60(%rbp),%xmm3
    0.00 :	  7449f8:       f2 0f 58 d8             addsd  %xmm0,%xmm3
         :	#else
         :	                                result = tm->tm_sec + fsec;
         :	#endif
         :	                                break;
    0.00 :	  7449fc:       e9 84 fd ff ff          jmpq   744785 <timestamp_part+0x1d5>
    0.00 :	  744a01:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                                result = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)
         :	                                                  - date2j(tm->tm_year, 1, 1) + 1);
         :	                                break;
         :
         :	                        default:
         :	                                ereport(ERROR,
    0.00 :	  744a08:       bf 50 97 8c 00          mov    $0x8c9750,%edi
    0.00 :	  744a0d:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  744a10:       31 c0                   xor    %eax,%eax
    0.00 :	  744a12:       e8 89 7e 03 00          callq  77c8a0 <errmsg>
    0.00 :	  744a17:       bf 40 04 00 00          mov    $0x440,%edi
    0.00 :	  744a1c:       89 c3                   mov    %eax,%ebx
         :	                }
         :
         :	        }
         :	        else
         :	        {
         :	                ereport(ERROR,
    0.00 :	  744a1e:       e8 2d 83 03 00          callq  77cd50 <errcode>
    0.00 :	  744a23:       89 de                   mov    %ebx,%esi
    0.00 :	  744a25:       89 c7                   mov    %eax,%edi
    0.00 :	  744a27:       31 c0                   xor    %eax,%eax
    0.00 :	  744a29:       e8 b2 5b 03 00          callq  77a5e0 <errfinish>
    0.00 :	  744a2e:       e9 67 fc ff ff          jmpq   74469a <timestamp_part+0xea>
    0.00 :	  744a33:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  744a36:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  744a3b:       ba a1 11 00 00          mov    $0x11a1,%edx
    0.00 :	  744a40:       be 17 94 8c 00          mov    $0x8c9417,%esi
    0.00 :	  744a45:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  744a4a:       e8 71 60 03 00          callq  77aac0 <errstart>
    0.00 :	  744a4f:       84 c0                   test   %al,%al
    0.00 :	  744a51:       0f 84 43 fc ff ff       je     74469a <timestamp_part+0xea>
    0.00 :	  744a57:       bf 78 97 8c 00          mov    $0x8c9778,%edi
    0.00 :	  744a5c:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  744a5f:       31 c0                   xor    %eax,%eax
    0.00 :	  744a61:       e8 3a 7e 03 00          callq  77c8a0 <errmsg>
    0.00 :	  744a66:       bf 82 00 08 03          mov    $0x3080082,%edi
    0.00 :	  744a6b:       89 c3                   mov    %eax,%ebx
    0.00 :	  744a6d:       eb af                   jmp    744a1e <timestamp_part+0x46e>
         :	                        case DTK_MILLENNIUM:
         :	                                /* see comments above. */
         :	                                if (tm->tm_year > 0)
         :	                                        result = (tm->tm_year + 999) / 1000;
         :	                                else
         :	                                        result = -((999 - (tm->tm_year - 1)) / 1000);
    0.00 :	  744a6f:       b9 e8 03 00 00          mov    $0x3e8,%ecx
    0.00 :	  744a74:       29 d1                   sub    %edx,%ecx
    0.00 :	  744a76:       ba d3 4d 62 10          mov    $0x10624dd3,%edx
    0.00 :	  744a7b:       89 c8                   mov    %ecx,%eax
    0.00 :	  744a7d:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  744a80:       f7 ea                   imul   %edx
    0.00 :	  744a82:       c1 fa 06                sar    $0x6,%edx
    0.00 :	  744a85:       29 d1                   sub    %edx,%ecx
    0.00 :	  744a87:       f2 0f 2a d9             cvtsi2sd %ecx,%xmm3
    0.00 :	  744a8b:       e9 f5 fc ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                        case DTK_YEAR:
         :	                                if (tm->tm_year > 0)
         :	                                        result = tm->tm_year;
         :	                                else
         :	                                        /* there is no year 0, just 1 BC and 1 AD */
         :	                                        result = tm->tm_year - 1;
    0.00 :	  744a90:       83 e8 01                sub    $0x1,%eax
    0.00 :	  744a93:       e9 c1 fe ff ff          jmpq   744959 <timestamp_part+0x3a9>
         :	                                 */
         :	                                if (tm->tm_year > 0)
         :	                                        result = (tm->tm_year + 99) / 100;
         :	                                else
         :	                                        /* caution: C division may have negative remainder */
         :	                                        result = -((99 - (tm->tm_year - 1)) / 100);
    0.00 :	  744a98:       b9 64 00 00 00          mov    $0x64,%ecx
    0.00 :	  744a9d:       29 d1                   sub    %edx,%ecx
    0.00 :	  744a9f:       ba 1f 85 eb 51          mov    $0x51eb851f,%edx
    0.00 :	  744aa4:       89 c8                   mov    %ecx,%eax
    0.00 :	  744aa6:       c1 f9 1f                sar    $0x1f,%ecx
    0.00 :	  744aa9:       f7 ea                   imul   %edx
    0.00 :	  744aab:       c1 fa 05                sar    $0x5,%edx
    0.00 :	  744aae:       29 d1                   sub    %edx,%ecx
    0.00 :	  744ab0:       f2 0f 2a d9             cvtsi2sd %ecx,%xmm3
    0.00 :	  744ab4:       e9 cc fc ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                 * is 11 BC thru 2 BC...
         :	                                 */
         :	                                if (tm->tm_year >= 0)
         :	                                        result = tm->tm_year / 10;
         :	                                else
         :	                                        result = -((8 - (tm->tm_year - 1)) / 10);
    0.00 :	  744ab9:       be 09 00 00 00          mov    $0x9,%esi
    0.00 :	  744abe:       ba 67 66 66 66          mov    $0x66666667,%edx
    0.00 :	  744ac3:       29 ce                   sub    %ecx,%esi
    0.00 :	  744ac5:       89 f0                   mov    %esi,%eax
    0.00 :	  744ac7:       c1 fe 1f                sar    $0x1f,%esi
    0.00 :	  744aca:       f7 ea                   imul   %edx
    0.00 :	  744acc:       c1 fa 02                sar    $0x2,%edx
    0.00 :	  744acf:       29 d6                   sub    %edx,%esi
    0.00 :	  744ad1:       f2 0f 2a de             cvtsi2sd %esi,%xmm3
    0.00 :	  744ad5:       e9 ab fc ff ff          jmpq   744785 <timestamp_part+0x1d5>
         :	                                break;
         :
         :	                        case DTK_DOW:
         :	                        case DTK_ISODOW:
         :	                                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
         :	                                        ereport(ERROR,
    0.00 :	  744ada:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  744add:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  744ae2:       ba 85 11 00 00          mov    $0x1185,%edx
         :	                                        result = 7;
         :	                                break;
         :
         :	                        case DTK_DOY:
         :	                                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
         :	                                        ereport(ERROR,
    0.00 :	  744ae7:       be 17 94 8c 00          mov    $0x8c9417,%esi
    0.00 :	  744aec:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  744af1:       e8 ca 5f 03 00          callq  77aac0 <errstart>
    0.00 :	  744af6:       84 c0                   test   %al,%al
    0.00 :	  744af8:       0f 84 9c fb ff ff       je     74469a <timestamp_part+0xea>
    0.00 :	  744afe:       bf f8 94 8b 00          mov    $0x8b94f8,%edi
    0.00 :	  744b03:       31 c0                   xor    %eax,%eax
    0.00 :	  744b05:       e8 96 7d 03 00          callq  77c8a0 <errmsg>
    0.00 :	  744b0a:       bf 82 00 00 08          mov    $0x8000082,%edi
    0.00 :	  744b0f:       89 c3                   mov    %eax,%ebx
    0.00 :	  744b11:       e9 08 ff ff ff          jmpq   744a1e <timestamp_part+0x46e>
    0.00 :	  744b16:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  744b19:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  744b1e:       ba 8f 11 00 00          mov    $0x118f,%edx
    0.00 :	  744b23:       eb c2                   jmp    744ae7 <timestamp_part+0x537>
         :	                type = DecodeSpecial(0, lowunits, &val);
         :
         :	        if (type == UNITS)
         :	        {
         :	                if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)
         :	                        ereport(ERROR,
    0.00 :	  744b25:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  744b28:       b9 81 9f 8c 00          mov    $0x8c9f81,%ecx
    0.00 :	  744b2d:       ba fa 10 00 00          mov    $0x10fa,%edx
    0.00 :	  744b32:       eb b3                   jmp    744ae7 <timestamp_part+0x537>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:666
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000757d90 <bcTruelen>:
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
    0.00 :	  757d90:       55                      push   %rbp
         :	        char       *s = VARDATA_ANY(arg);
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:655
   50.00 :	  757d91:       0f b6 17                movzbl (%rdi),%edx
    0.00 :	  757d94:       48 8d 4f 01             lea    0x1(%rdi),%rcx
    0.00 :	  757d98:       48 8d 47 04             lea    0x4(%rdi),%rax
    0.00 :	  757d9c:       be 01 00 00 00          mov    $0x1,%esi
         :	 *****************************************************************************/
         :
         :	/* "True" length (not counting trailing blanks) of a BpChar */
         :	static int
         :	bcTruelen(BpChar *arg)
         :	{
    0.00 :	  757da1:       48 89 e5                mov    %rsp,%rbp
         :	        char       *s = VARDATA_ANY(arg);
    0.00 :	  757da4:       21 d6                   and    %edx,%esi
    0.00 :	  757da6:       48 0f 44 c8             cmove  %rax,%rcx
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
    0.00 :	  757daa:       80 fa 01                cmp    $0x1,%dl
    0.00 :	  757dad:       74 51                   je     757e00 <bcTruelen+0x70>
    0.00 :	  757daf:       85 f6                   test   %esi,%esi
    0.00 :	  757db1:       75 3d                   jne    757df0 <bcTruelen+0x60>
    0.00 :	  757db3:       8b 07                   mov    (%rdi),%eax
    0.00 :	  757db5:       c1 e8 02                shr    $0x2,%eax
    0.00 :	  757db8:       83 e8 04                sub    $0x4,%eax
         :	        for (i = len - 1; i >= 0; i--)
    0.00 :	  757dbb:       89 c2                   mov    %eax,%edx
    0.00 :	  757dbd:       83 ea 01                sub    $0x1,%edx
    0.00 :	  757dc0:       78 20                   js     757de2 <bcTruelen+0x52>
    0.00 :	  757dc2:       48 63 f2                movslq %edx,%rsi
         :	        {
         :	                if (s[i] != ' ')
    0.00 :	  757dc5:       80 3c 31 20             cmpb   $0x20,(%rcx,%rsi,1)
    0.00 :	  757dc9:       74 0e                   je     757dd9 <bcTruelen+0x49>
    0.00 :	  757dcb:       eb 15                   jmp    757de2 <bcTruelen+0x52>
    0.00 :	  757dcd:       0f 1f 00                nopl   (%rax)
    0.00 :	  757dd0:       48 63 c2                movslq %edx,%rax
    0.00 :	  757dd3:       80 3c 01 20             cmpb   $0x20,(%rcx,%rax,1)
    0.00 :	  757dd7:       75 09                   jne    757de2 <bcTruelen+0x52>
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
         :	        for (i = len - 1; i >= 0; i--)
    0.00 :	  757dd9:       83 ea 01                sub    $0x1,%edx
    0.00 :	  757ddc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  757de0:       79 ee                   jns    757dd0 <bcTruelen+0x40>
    0.00 :	  757de2:       8d 42 01                lea    0x1(%rdx),%eax
         :	        {
         :	                if (s[i] != ' ')
         :	                        break;
         :	        }
         :	        return i + 1;
         :	}
    0.00 :	  757de5:       c9                      leaveq 
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/varchar.c:666
   50.00 :	  757de6:       c3                      retq   
    0.00 :	  757de7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  757dee:       00 00 
         :	{
         :	        char       *s = VARDATA_ANY(arg);
         :	        int                     i;
         :	        int                     len;
         :
         :	        len = VARSIZE_ANY_EXHDR(arg);
    0.00 :	  757df0:       d0 ea                   shr    %dl
    0.00 :	  757df2:       0f b6 c2                movzbl %dl,%eax
    0.00 :	  757df5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  757df8:       eb c1                   jmp    757dbb <bcTruelen+0x2b>
    0.00 :	  757dfa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  757e00:       0f b6 7f 01             movzbl 0x1(%rdi),%edi
    0.00 :	  757e04:       ba 07 00 00 00          mov    $0x7,%edx
    0.00 :	  757e09:       be 07 00 00 00          mov    $0x7,%esi
    0.00 :	  757e0e:       40 80 ff 01             cmp    $0x1,%dil
    0.00 :	  757e12:       74 b1                   je     757dc5 <bcTruelen+0x35>
    0.00 :	  757e14:       40 80 ff 12             cmp    $0x12,%dil
    0.00 :	  757e18:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e1d:       ba 0f 00 00 00          mov    $0xf,%edx
    0.00 :	  757e22:       0f 45 d0                cmovne %eax,%edx
    0.00 :	  757e25:       be 0f 00 00 00          mov    $0xf,%esi
    0.00 :	  757e2a:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  757e2f:       48 0f 45 f0             cmovne %rax,%rsi
    0.00 :	  757e33:       eb 90                   jmp    757dc5 <bcTruelen+0x35>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1398
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1400
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077ddf0 <FunctionCall5Coll>:
         :	}
         :
         :	Datum
         :	FunctionCall5Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,
         :	                                  Datum arg3, Datum arg4, Datum arg5)
         :	{
    0.00 :	  77ddf0:       55                      push   %rbp
    0.00 :	  77ddf1:       49 89 fa                mov    %rdi,%r10
    0.00 :	  77ddf4:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  77ddf7:       48 81 ec b0 03 00 00    sub    $0x3b0,%rsp
         :
         :	        fcinfo.arg[0] = arg1;
         :	        fcinfo.arg[1] = arg2;
         :	        fcinfo.arg[2] = arg3;
         :	        fcinfo.arg[3] = arg4;
         :	        fcinfo.arg[4] = arg5;
    0.00 :	  77ddfe:       48 8b 45 10             mov    0x10(%rbp),%rax
         :	                                  Datum arg3, Datum arg4, Datum arg5)
         :	{
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 5, collation, NULL, NULL);
    0.00 :	  77de02:       48 89 bd 50 fc ff ff    mov    %rdi,-0x3b0(%rbp)
         :	        fcinfo.argnull[1] = false;
         :	        fcinfo.argnull[2] = false;
         :	        fcinfo.argnull[3] = false;
         :	        fcinfo.argnull[4] = false;
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77de09:       48 8d bd 50 fc ff ff    lea    -0x3b0(%rbp),%rdi
         :	                                  Datum arg3, Datum arg4, Datum arg5)
         :	{
         :	        FunctionCallInfoData fcinfo;
         :	        Datum           result;
         :
         :	        InitFunctionCallInfoData(fcinfo, flinfo, 5, collation, NULL, NULL);
    0.00 :	  77de10:       48 c7 85 58 fc ff ff    movq   $0x0,-0x3a8(%rbp)
    0.00 :	  77de17:       00 00 00 00 
    0.00 :	  77de1b:       48 c7 85 60 fc ff ff    movq   $0x0,-0x3a0(%rbp)
    0.00 :	  77de22:       00 00 00 00 
    0.00 :	  77de26:       89 b5 68 fc ff ff       mov    %esi,-0x398(%rbp)
    0.00 :	  77de2c:       c6 85 6c fc ff ff 00    movb   $0x0,-0x394(%rbp)
    0.00 :	  77de33:       66 c7 85 6e fc ff ff    movw   $0x5,-0x392(%rbp)
    0.00 :	  77de3a:       05 00 
         :
         :	        fcinfo.arg[0] = arg1;
    0.00 :	  77de3c:       48 89 95 70 fc ff ff    mov    %rdx,-0x390(%rbp)
         :	        fcinfo.arg[1] = arg2;
    0.00 :	  77de43:       48 89 8d 78 fc ff ff    mov    %rcx,-0x388(%rbp)
         :	        fcinfo.arg[2] = arg3;
    0.00 :	  77de4a:       4c 89 85 80 fc ff ff    mov    %r8,-0x380(%rbp)
         :	        fcinfo.arg[3] = arg4;
    0.00 :	  77de51:       4c 89 8d 88 fc ff ff    mov    %r9,-0x378(%rbp)
         :	        fcinfo.arg[4] = arg5;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1398
   50.00 :	  77de58:       48 89 85 90 fc ff ff    mov    %rax,-0x370(%rbp)
         :	        fcinfo.argnull[0] = false;
    0.00 :	  77de5f:       c6 45 90 00             movb   $0x0,-0x70(%rbp)
         :	        fcinfo.argnull[1] = false;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:1400
   50.00 :	  77de63:       c6 45 91 00             movb   $0x0,-0x6f(%rbp)
         :	        fcinfo.argnull[2] = false;
    0.00 :	  77de67:       c6 45 92 00             movb   $0x0,-0x6e(%rbp)
         :	        fcinfo.argnull[3] = false;
    0.00 :	  77de6b:       c6 45 93 00             movb   $0x0,-0x6d(%rbp)
         :	        fcinfo.argnull[4] = false;
    0.00 :	  77de6f:       c6 45 94 00             movb   $0x0,-0x6c(%rbp)
         :
         :	        result = FunctionCallInvoke(&fcinfo);
    0.00 :	  77de73:       41 ff 12                callq  *(%r10)
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
    0.00 :	  77de76:       80 bd 6c fc ff ff 00    cmpb   $0x0,-0x394(%rbp)
    0.00 :	  77de7d:       75 02                   jne    77de81 <FunctionCall5Coll+0x91>
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
         :
         :	        return result;
         :	}
    0.00 :	  77de7f:       c9                      leaveq 
    0.00 :	  77de80:       c3                      retq   
         :
         :	        result = FunctionCallInvoke(&fcinfo);
         :
         :	        /* Check for null result, since caller is clearly not expecting one */
         :	        if (unlikely(fcinfo.isnull))
         :	                elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
    0.00 :	  77de81:       ba e0 51 8d 00          mov    $0x8d51e0,%edx
    0.00 :	  77de86:       be 81 05 00 00          mov    $0x581,%esi
    0.00 :	  77de8b:       bf b3 47 8d 00          mov    $0x8d47b3,%edi
    0.00 :	  77de90:       e8 8b d5 ff ff          callq  77b420 <elog_start>
    0.00 :	  77de95:       48 8b 85 50 fc ff ff    mov    -0x3b0(%rbp),%rax
    0.00 :	  77de9c:       be 97 4c 8d 00          mov    $0x8d4c97,%esi
    0.00 :	  77dea1:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  77dea6:       8b 50 08                mov    0x8(%rax),%edx
    0.00 :	  77dea9:       31 c0                   xor    %eax,%eax
    0.00 :	  77deab:       e8 80 d3 ff ff          callq  77b230 <elog_finish>
    0.00 :	  77deb0:       e8 1b b6 ce ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:587
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000077f740 <fmgr_info_copy>:
         :	 * instead, meaning that subsidiary info will have to be recomputed.
         :	 */
         :	void
         :	fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,
         :	                           MemoryContext destcxt)
         :	{
    0.00 :	  77f740:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/fmgr/fmgr.c:587
  100.00 :	  77f741:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  77f744:       41 54                   push   %r12
    0.00 :	  77f746:       49 89 fc                mov    %rdi,%r12
    0.00 :	  77f749:       53                      push   %rbx
         :	        memcpy(dstinfo, srcinfo, sizeof(FmgrInfo));
    0.00 :	  77f74a:       48 8b 06                mov    (%rsi),%rax
         :	 * instead, meaning that subsidiary info will have to be recomputed.
         :	 */
         :	void
         :	fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,
         :	                           MemoryContext destcxt)
         :	{
    0.00 :	  77f74d:       48 89 f3                mov    %rsi,%rbx
         :	        memcpy(dstinfo, srcinfo, sizeof(FmgrInfo));
    0.00 :	  77f750:       48 89 07                mov    %rax,(%rdi)
    0.00 :	  77f753:       48 8b 46 08             mov    0x8(%rsi),%rax
         :	        dstinfo->fn_mcxt = destcxt;
         :	        if (dstinfo->fn_addr == fmgr_oldstyle)
    0.00 :	  77f757:       48 81 3f 30 ed 77 00    cmpq   $0x77ed30,(%rdi)
         :	 */
         :	void
         :	fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,
         :	                           MemoryContext destcxt)
         :	{
         :	        memcpy(dstinfo, srcinfo, sizeof(FmgrInfo));
    0.00 :	  77f75e:       48 89 47 08             mov    %rax,0x8(%rdi)
    0.00 :	  77f762:       48 8b 46 10             mov    0x10(%rsi),%rax
    0.00 :	  77f766:       48 89 47 10             mov    %rax,0x10(%rdi)
    0.00 :	  77f76a:       48 8b 46 18             mov    0x18(%rsi),%rax
    0.00 :	  77f76e:       48 89 47 18             mov    %rax,0x18(%rdi)
    0.00 :	  77f772:       48 8b 46 20             mov    0x20(%rsi),%rax
    0.00 :	  77f776:       48 89 47 20             mov    %rax,0x20(%rdi)
    0.00 :	  77f77a:       48 8b 46 28             mov    0x28(%rsi),%rax
         :	        dstinfo->fn_mcxt = destcxt;
    0.00 :	  77f77e:       48 89 57 20             mov    %rdx,0x20(%rdi)
         :	 */
         :	void
         :	fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,
         :	                           MemoryContext destcxt)
         :	{
         :	        memcpy(dstinfo, srcinfo, sizeof(FmgrInfo));
    0.00 :	  77f782:       48 89 47 28             mov    %rax,0x28(%rdi)
         :	        dstinfo->fn_mcxt = destcxt;
         :	        if (dstinfo->fn_addr == fmgr_oldstyle)
    0.00 :	  77f786:       74 10                   je     77f798 <fmgr_info_copy+0x58>
         :	                        MemoryContextAlloc(destcxt, sizeof(Oldstyle_fnextra));
         :	                memcpy(fnextra, srcinfo->fn_extra, sizeof(Oldstyle_fnextra));
         :	                dstinfo->fn_extra = (void *) fnextra;
         :	        }
         :	        else
         :	                dstinfo->fn_extra = NULL;
    0.00 :	  77f788:       48 c7 47 18 00 00 00    movq   $0x0,0x18(%rdi)
    0.00 :	  77f78f:       00 
         :	}
    0.00 :	  77f790:       5b                      pop    %rbx
    0.00 :	  77f791:       41 5c                   pop    %r12
    0.00 :	  77f793:       c9                      leaveq 
    0.00 :	  77f794:       c3                      retq   
    0.00 :	  77f795:       0f 1f 00                nopl   (%rax)
         :	        if (dstinfo->fn_addr == fmgr_oldstyle)
         :	        {
         :	                /* For oldstyle functions we must copy fn_extra */
         :	                Oldstyle_fnextra *fnextra;
         :
         :	                fnextra = (Oldstyle_fnextra *)
    0.00 :	  77f798:       48 89 d7                mov    %rdx,%rdi
    0.00 :	  77f79b:       be 70 00 00 00          mov    $0x70,%esi
    0.00 :	  77f7a0:       e8 eb 96 01 00          callq  798e90 <MemoryContextAlloc>
         :	                        MemoryContextAlloc(destcxt, sizeof(Oldstyle_fnextra));
         :	                memcpy(fnextra, srcinfo->fn_extra, sizeof(Oldstyle_fnextra));
    0.00 :	  77f7a5:       48 8b 4b 18             mov    0x18(%rbx),%rcx
    0.00 :	  77f7a9:       48 8b 11                mov    (%rcx),%rdx
    0.00 :	  77f7ac:       48 89 10                mov    %rdx,(%rax)
    0.00 :	  77f7af:       48 8b 51 08             mov    0x8(%rcx),%rdx
    0.00 :	  77f7b3:       48 89 50 08             mov    %rdx,0x8(%rax)
    0.00 :	  77f7b7:       48 8b 51 10             mov    0x10(%rcx),%rdx
    0.00 :	  77f7bb:       48 89 50 10             mov    %rdx,0x10(%rax)
    0.00 :	  77f7bf:       48 8b 51 18             mov    0x18(%rcx),%rdx
    0.00 :	  77f7c3:       48 89 50 18             mov    %rdx,0x18(%rax)
    0.00 :	  77f7c7:       48 8b 51 20             mov    0x20(%rcx),%rdx
    0.00 :	  77f7cb:       48 89 50 20             mov    %rdx,0x20(%rax)
    0.00 :	  77f7cf:       48 8b 51 28             mov    0x28(%rcx),%rdx
    0.00 :	  77f7d3:       48 89 50 28             mov    %rdx,0x28(%rax)
    0.00 :	  77f7d7:       48 8b 51 30             mov    0x30(%rcx),%rdx
    0.00 :	  77f7db:       48 89 50 30             mov    %rdx,0x30(%rax)
    0.00 :	  77f7df:       48 8b 51 38             mov    0x38(%rcx),%rdx
    0.00 :	  77f7e3:       48 89 50 38             mov    %rdx,0x38(%rax)
    0.00 :	  77f7e7:       48 8b 51 40             mov    0x40(%rcx),%rdx
    0.00 :	  77f7eb:       48 89 50 40             mov    %rdx,0x40(%rax)
    0.00 :	  77f7ef:       48 8b 51 48             mov    0x48(%rcx),%rdx
    0.00 :	  77f7f3:       48 89 50 48             mov    %rdx,0x48(%rax)
    0.00 :	  77f7f7:       48 8b 51 50             mov    0x50(%rcx),%rdx
    0.00 :	  77f7fb:       48 89 50 50             mov    %rdx,0x50(%rax)
    0.00 :	  77f7ff:       48 8b 51 58             mov    0x58(%rcx),%rdx
    0.00 :	  77f803:       48 89 50 58             mov    %rdx,0x58(%rax)
    0.00 :	  77f807:       48 8b 51 60             mov    0x60(%rcx),%rdx
    0.00 :	  77f80b:       48 89 50 60             mov    %rdx,0x60(%rax)
    0.00 :	  77f80f:       48 8b 51 68             mov    0x68(%rcx),%rdx
    0.00 :	  77f813:       48 89 50 68             mov    %rdx,0x68(%rax)
         :	                dstinfo->fn_extra = (void *) fnextra;
    0.00 :	  77f817:       49 89 44 24 18          mov    %rax,0x18(%r12)
    0.00 :	  77f81c:       e9 6f ff ff ff          jmpq   77f790 <fmgr_info_copy+0x50>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1070
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1071
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000782c50 <CHashAddToGarbage>:
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c50:       0f b6 4f 14             movzbl 0x14(%rdi),%ecx
         :	{
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c54:       89 d0                   mov    %edx,%eax
         :	 * failure to match an already-deleted item shouldn't cause any problems;
         :	 * this is why gcnext can share space with the hash value.
         :	 */
         :	static void
         :	CHashAddToGarbage(CHashTable table, uint32 bucket, CHashPtr c)
         :	{
    0.00 :	  782c56:       55                      push   %rbp
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c57:       d1 e8                   shr    %eax
    0.00 :	  782c59:       41 89 c0                mov    %eax,%r8d
         :	 * failure to match an already-deleted item shouldn't cause any problems;
         :	 * this is why gcnext can share space with the hash value.
         :	 */
         :	static void
         :	CHashAddToGarbage(CHashTable table, uint32 bucket, CHashPtr c)
         :	{
    0.00 :	  782c5c:       48 89 e5                mov    %rsp,%rbp
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c5f:       44 0f af 47 1c          imul   0x1c(%rdi),%r8d
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c64:       d3 ee                   shr    %cl,%esi
    0.00 :	  782c66:       0f b6 4f 15             movzbl 0x15(%rdi),%ecx
    0.00 :	  782c6a:       89 f0                   mov    %esi,%eax
         :	{
         :	        CHashPtr        g;
         :	        CHashNode *n;
         :	        CHashPtr *garbage;
         :
         :	        n = CHashTableGetNode(table, c);
    0.00 :	  782c6c:       4c 03 47 30             add    0x30(%rdi),%r8
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
    0.00 :	  782c70:       d3 e8                   shr    %cl,%eax
    0.00 :	  782c72:       01 f0                   add    %esi,%eax
    0.00 :	  782c74:       48 8d 0c 85 00 00 00    lea    0x0(,%rax,4),%rcx
    0.00 :	  782c7b:       00 
    0.00 :	  782c7c:       48 03 4f 28             add    0x28(%rdi),%rcx
    0.00 :	  782c80:       eb 0e                   jmp    782c90 <CHashAddToGarbage+0x40>
    0.00 :	  782c82:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        {
         :	                g = *garbage;
         :	                n->un.gcnext = g;
         :	                if (__sync_bool_compare_and_swap(garbage, g, c))
         :	                        break;
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Enqueue_Retry);
    0.00 :	  782c88:       48 83 87 a8 00 00 00    addq   $0x1,0xa8(%rdi)
    0.00 :	  782c8f:       01 
         :	        n = CHashTableGetNode(table, c);
         :	        garbage = CHashTableGetGarbageByBucket(table, bucket);
         :
         :	        while (1)
         :	        {
         :	                g = *garbage;
    0.00 :	  782c90:       8b 01                   mov    (%rcx),%eax
         :	                n->un.gcnext = g;
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1070
   50.00 :	  782c92:       41 89 40 04             mov    %eax,0x4(%r8)
         :	                if (__sync_bool_compare_and_swap(garbage, g, c))
    0.00 :	  782c96:       f0 0f b1 11             lock cmpxchg %edx,(%rcx)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/chash.c:1071
   50.00 :	  782c9a:       75 ec                   jne    782c88 <CHashAddToGarbage+0x38>
         :	                        break;
         :	                CHashTableIncrementStatistic(table, CHS_Garbage_Enqueue_Retry);
         :	        }
         :	}
    0.00 :	  782c9c:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:936
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:337
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000007986d0 <AllocSetFree>:
         :	 * AllocSetFree
         :	 *              Frees allocated memory; memory is removed from the set.
         :	 */
         :	static void
         :	AllocSetFree(MemoryContext context, void *pointer)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:936
   50.00 :	  7986d0:       55                      push   %rbp
    0.00 :	  7986d1:       48 89 f9                mov    %rdi,%rcx
    0.00 :	  7986d4:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  7986d7:       53                      push   %rbx
         :	        AllocSet        set = (AllocSet) context;
         :	        AllocChunk      chunk = AllocPointerGetChunk(pointer);
    0.00 :	  7986d8:       48 8d 5e f0             lea    -0x10(%rsi),%rbx
         :	 * AllocSetFree
         :	 *              Frees allocated memory; memory is removed from the set.
         :	 */
         :	static void
         :	AllocSetFree(MemoryContext context, void *pointer)
         :	{
    0.00 :	  7986dc:       48 83 ec 08             sub    $0x8,%rsp
         :	                if (!sentinel_ok(pointer, chunk->requested_size))
         :	                        elog(WARNING, "detected write past chunk end in %s %p",
         :	                                 set->header.name, chunk);
         :	#endif
         :
         :	        if (chunk->size > set->allocChunkLimit)
    0.00 :	  7986e0:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    0.00 :	  7986e4:       48 3b 87 b0 00 00 00    cmp    0xb0(%rdi),%rax
    0.00 :	  7986eb:       76 63                   jbe    798750 <AllocSetFree+0x80>
         :	        {
         :	                /*
         :	                 * Big chunks are certain to have been allocated as single-chunk
         :	                 * blocks.  Find the containing block and return it to malloc().
         :	                 */
         :	                AllocBlock      block = set->blocks;
    0.00 :	  7986ed:       48 8b 7f 38             mov    0x38(%rdi),%rdi
         :	                AllocBlock      prevblock = NULL;
         :
         :	                while (block != NULL)
    0.00 :	  7986f1:       48 85 ff                test   %rdi,%rdi
    0.00 :	  7986f4:       74 2c                   je     798722 <AllocSetFree+0x52>
         :	                {
         :	                        if (chunk == (AllocChunk) (((char *) block) + ALLOC_BLOCKHDRSZ))
    0.00 :	  7986f6:       48 8d 47 20             lea    0x20(%rdi),%rax
    0.00 :	  7986fa:       48 39 c3                cmp    %rax,%rbx
    0.00 :	  7986fd:       75 17                   jne    798716 <AllocSetFree+0x46>
    0.00 :	  7986ff:       90                      nop
    0.00 :	  798700:       e9 be 00 00 00          jmpq   7987c3 <AllocSetFree+0xf3>
    0.00 :	  798705:       0f 1f 00                nopl   (%rax)
    0.00 :	  798708:       48 8d 47 20             lea    0x20(%rdi),%rax
    0.00 :	  79870c:       48 39 c3                cmp    %rax,%rbx
    0.00 :	  79870f:       90                      nop
    0.00 :	  798710:       0f 84 8a 00 00 00       je     7987a0 <AllocSetFree+0xd0>
         :	                                break;
    0.00 :	  798716:       48 89 fa                mov    %rdi,%rdx
         :	                        prevblock = block;
         :	                        block = block->next;
    0.00 :	  798719:       48 8b 7f 08             mov    0x8(%rdi),%rdi
         :	                 * blocks.  Find the containing block and return it to malloc().
         :	                 */
         :	                AllocBlock      block = set->blocks;
         :	                AllocBlock      prevblock = NULL;
         :
         :	                while (block != NULL)
    0.00 :	  79871d:       48 85 ff                test   %rdi,%rdi
    0.00 :	  798720:       75 e6                   jne    798708 <AllocSetFree+0x38>
         :	                                break;
         :	                        prevblock = block;
         :	                        block = block->next;
         :	                }
         :	                if (block == NULL)
         :	                        elog(ERROR, "could not find block containing chunk %p", chunk);
    0.00 :	  798722:       ba 70 1e 8e 00          mov    $0x8e1e70,%edx
    0.00 :	  798727:       be c9 03 00 00          mov    $0x3c9,%esi
    0.00 :	  79872c:       bf 6d 1d 8e 00          mov    $0x8e1d6d,%edi
    0.00 :	  798731:       e8 ea 2c fe ff          callq  77b420 <elog_start>
    0.00 :	  798736:       48 89 da                mov    %rbx,%rdx
    0.00 :	  798739:       be 08 1e 8e 00          mov    $0x8e1e08,%esi
    0.00 :	  79873e:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  798743:       31 c0                   xor    %eax,%eax
    0.00 :	  798745:       e8 e6 2a fe ff          callq  77b230 <elog_finish>
    0.00 :	  79874a:       e8 81 0d cd ff          callq  4694d0 <abort@plt>
    0.00 :	  79874f:       90                      nop
         :	{
         :	        int                     idx;
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
    0.00 :	  798750:       31 d2                   xor    %edx,%edx
    0.00 :	  798752:       48 83 f8 08             cmp    $0x8,%rax
    0.00 :	  798756:       77 20                   ja     798778 <AllocSetFree+0xa8>
         :	        else
         :	        {
         :	                /* Normal case, put the chunk into appropriate freelist */
         :	                int                     fidx = AllocSetFreeIndex(chunk->size);
         :
         :	                chunk->aset = (void *) set->freelist[fidx];
    0.00 :	  798758:       48 63 c2                movslq %edx,%rax
    0.00 :	  79875b:       48 83 c0 08             add    $0x8,%rax
    0.00 :	  79875f:       48 8b 14 c1             mov    (%rcx,%rax,8),%rdx
    0.00 :	  798763:       48 89 56 f0             mov    %rdx,-0x10(%rsi)
         :
         :	#ifdef MEMORY_CONTEXT_CHECKING
         :	                /* Reset requested_size to 0 in chunks that are on freelist */
         :	                chunk->requested_size = 0;
         :	#endif
         :	                set->freelist[fidx] = chunk;
    0.00 :	  798767:       48 89 1c c1             mov    %rbx,(%rcx,%rax,8)
         :	        }
         :	}
    0.00 :	  79876b:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  79876f:       5b                      pop    %rbx
    0.00 :	  798770:       c9                      leaveq 
    0.00 :	  798771:       c3                      retq   
    0.00 :	  798772:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	        unsigned int t,
         :	                                tsize;
         :
         :	        if (size > (1 << ALLOC_MINBITS))
         :	        {
         :	                tsize = (size - 1) >> ALLOC_MINBITS;
    0.00 :	  798778:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  79877c:       48 89 c2                mov    %rax,%rdx
    0.00 :	  79877f:       48 c1 ea 03             shr    $0x3,%rdx
         :	                 * justify micro-optimization effort.  The best approach seems to be
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
    0.00 :	  798783:       89 d0                   mov    %edx,%eax
    0.00 :	  798785:       c1 e8 08                shr    $0x8,%eax
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
    0.00 :	  798788:       85 c0                   test   %eax,%eax
    0.00 :	  79878a:       74 2c                   je     7987b8 <AllocSetFree+0xe8>
    0.00 :	  79878c:       89 c0                   mov    %eax,%eax
    0.00 :	  79878e:       0f b6 80 80 1e 8e 00    movzbl 0x8e1e80(%rax),%eax
    0.00 :	  798795:       8d 50 08                lea    0x8(%rax),%edx
    0.00 :	  798798:       eb be                   jmp    798758 <AllocSetFree+0x88>
    0.00 :	  79879a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	                /* OK, remove block from aset's list and free it */
         :	                if (prevblock == NULL)
         :	                        set->blocks = block->next;
         :	                else
         :	                        prevblock->next = block->next;
    0.00 :	  7987a0:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  7987a4:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                /* Reset requested_size to 0 in chunks that are on freelist */
         :	                chunk->requested_size = 0;
         :	#endif
         :	                set->freelist[fidx] = chunk;
         :	        }
         :	}
    0.00 :	  7987a8:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  7987ac:       5b                      pop    %rbx
    0.00 :	  7987ad:       c9                      leaveq 
         :	                else
         :	                        prevblock->next = block->next;
         :	#ifdef CLOBBER_FREED_MEMORY
         :	                wipe_mem(block, block->freeptr - ((char *) block));
         :	#endif
         :	                free(block);
    0.00 :	  7987ae:       e9 6d 10 cd ff          jmpq   469820 <free@plt>
    0.00 :	  7987b3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                 * to use a lookup table.  Note that this code assumes that
         :	                 * ALLOCSET_NUM_FREELISTS <= 17, since we only cope with two bytes of
         :	                 * the tsize value.
         :	                 */
         :	                t = tsize >> 8;
         :	                idx = t ? LogTable256[t] + 8 : LogTable256[tsize];
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/aset.c:337
   50.00 :	  7987b8:       89 d0                   mov    %edx,%eax
    0.00 :	  7987ba:       0f b6 90 80 1e 8e 00    movzbl 0x8e1e80(%rax),%edx
    0.00 :	  7987c1:       eb 95                   jmp    798758 <AllocSetFree+0x88>
         :	                Assert(block->freeptr == ((char *) block) +
         :	                           (chunk->size + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ));
         :
         :	                /* OK, remove block from aset's list and free it */
         :	                if (prevblock == NULL)
         :	                        set->blocks = block->next;
    0.00 :	  7987c3:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  7987c7:       48 89 41 38             mov    %rax,0x38(%rcx)
    0.00 :	  7987cb:       eb db                   jmp    7987a8 <AllocSetFree+0xd8>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:627
   50.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:639
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000079a900 <ResourceOwnerForgetBuffer>:
         :	 * We allow the case owner == NULL because the bufmgr is sometimes invoked
         :	 * outside any transaction (for example, during WAL recovery).
         :	 */
         :	void
         :	ResourceOwnerForgetBuffer(ResourceOwner owner, Buffer buffer)
         :	{
    0.00 :	  79a900:       55                      push   %rbp
         :	        if (owner != NULL)
    0.00 :	  79a901:       48 85 ff                test   %rdi,%rdi
         :	 * We allow the case owner == NULL because the bufmgr is sometimes invoked
         :	 * outside any transaction (for example, during WAL recovery).
         :	 */
         :	void
         :	ResourceOwnerForgetBuffer(ResourceOwner owner, Buffer buffer)
         :	{
    0.00 :	  79a904:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:627
   50.00 :	  79a907:       41 54                   push   %r12
    0.00 :	  79a909:       49 89 fc                mov    %rdi,%r12
    0.00 :	  79a90c:       53                      push   %rbx
    0.00 :	  79a90d:       89 f3                   mov    %esi,%ebx
         :	        if (owner != NULL)
    0.00 :	  79a90f:       74 4d                   je     79a95e <ResourceOwnerForgetBuffer+0x5e>
         :	        {
         :	                Buffer     *buffers = owner->buffers;
         :	                int                     nb1 = owner->nbuffers - 1;
    0.00 :	  79a911:       8b 47 20                mov    0x20(%rdi),%eax
         :	void
         :	ResourceOwnerForgetBuffer(ResourceOwner owner, Buffer buffer)
         :	{
         :	        if (owner != NULL)
         :	        {
         :	                Buffer     *buffers = owner->buffers;
    0.00 :	  79a914:       48 8b 77 28             mov    0x28(%rdi),%rsi
         :	                /*
         :	                 * Scan back-to-front because it's more likely we are releasing a
         :	                 * recently pinned buffer.  This isn't always the case of course, but
         :	                 * it's the way to bet.
         :	                 */
         :	                for (i = nb1; i >= 0; i--)
 /home/Computational/mark/src/postgres-andres/src/backend/utils/resowner/resowner.c:639
   50.00 :	  79a918:       89 c7                   mov    %eax,%edi
    0.00 :	  79a91a:       83 ef 01                sub    $0x1,%edi
    0.00 :	  79a91d:       78 49                   js     79a968 <ResourceOwnerForgetBuffer+0x68>
         :	                {
         :	                        if (buffers[i] == buffer)
    0.00 :	  79a91f:       48 63 c7                movslq %edi,%rax
         :	                                while (i < nb1)
         :	                                {
         :	                                        buffers[i] = buffers[i + 1];
         :	                                        i++;
         :	                                }
         :	                                owner->nbuffers = nb1;
    0.00 :	  79a922:       89 fa                   mov    %edi,%edx
         :	                 * recently pinned buffer.  This isn't always the case of course, but
         :	                 * it's the way to bet.
         :	                 */
         :	                for (i = nb1; i >= 0; i--)
         :	                {
         :	                        if (buffers[i] == buffer)
    0.00 :	  79a924:       39 1c 86                cmp    %ebx,(%rsi,%rax,4)
    0.00 :	  79a927:       74 30                   je     79a959 <ResourceOwnerForgetBuffer+0x59>
    0.00 :	  79a929:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Scan back-to-front because it's more likely we are releasing a
         :	                 * recently pinned buffer.  This isn't always the case of course, but
         :	                 * it's the way to bet.
         :	                 */
         :	                for (i = nb1; i >= 0; i--)
    0.00 :	  79a930:       83 ea 01                sub    $0x1,%edx
    0.00 :	  79a933:       78 33                   js     79a968 <ResourceOwnerForgetBuffer+0x68>
         :	                {
         :	                        if (buffers[i] == buffer)
    0.00 :	  79a935:       48 63 ca                movslq %edx,%rcx
    0.00 :	  79a938:       39 1c 8e                cmp    %ebx,(%rsi,%rcx,4)
    0.00 :	  79a93b:       75 f3                   jne    79a930 <ResourceOwnerForgetBuffer+0x30>
         :	                        {
         :	                                while (i < nb1)
    0.00 :	  79a93d:       39 d7                   cmp    %edx,%edi
    0.00 :	  79a93f:       90                      nop
    0.00 :	  79a940:       7f 09                   jg     79a94b <ResourceOwnerForgetBuffer+0x4b>
    0.00 :	  79a942:       eb 15                   jmp    79a959 <ResourceOwnerForgetBuffer+0x59>
    0.00 :	  79a944:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  79a948:       48 63 ca                movslq %edx,%rcx
         :	                                {
         :	                                        buffers[i] = buffers[i + 1];
    0.00 :	  79a94b:       8b 44 8e 04             mov    0x4(%rsi,%rcx,4),%eax
         :	                                        i++;
    0.00 :	  79a94f:       83 c2 01                add    $0x1,%edx
         :	                 */
         :	                for (i = nb1; i >= 0; i--)
         :	                {
         :	                        if (buffers[i] == buffer)
         :	                        {
         :	                                while (i < nb1)
    0.00 :	  79a952:       39 d7                   cmp    %edx,%edi
         :	                                {
         :	                                        buffers[i] = buffers[i + 1];
    0.00 :	  79a954:       89 04 8e                mov    %eax,(%rsi,%rcx,4)
         :	                 */
         :	                for (i = nb1; i >= 0; i--)
         :	                {
         :	                        if (buffers[i] == buffer)
         :	                        {
         :	                                while (i < nb1)
    0.00 :	  79a957:       7f ef                   jg     79a948 <ResourceOwnerForgetBuffer+0x48>
         :	                                {
         :	                                        buffers[i] = buffers[i + 1];
         :	                                        i++;
         :	                                }
         :	                                owner->nbuffers = nb1;
    0.00 :	  79a959:       41 89 7c 24 20          mov    %edi,0x20(%r12)
         :	                        }
         :	                }
         :	                elog(ERROR, "buffer %d is not owned by resource owner %s",
         :	                         buffer, owner->name);
         :	        }
         :	}
    0.00 :	  79a95e:       5b                      pop    %rbx
    0.00 :	  79a95f:       41 5c                   pop    %r12
    0.00 :	  79a961:       c9                      leaveq 
    0.00 :	  79a962:       c3                      retq   
    0.00 :	  79a963:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                                }
         :	                                owner->nbuffers = nb1;
         :	                                return;
         :	                        }
         :	                }
         :	                elog(ERROR, "buffer %d is not owned by resource owner %s",
    0.00 :	  79a968:       ba 70 27 8e 00          mov    $0x8e2770,%edx
    0.00 :	  79a96d:       be 8d 02 00 00          mov    $0x28d,%esi
    0.00 :	  79a972:       bf 90 22 8e 00          mov    $0x8e2290,%edi
    0.00 :	  79a977:       e8 a4 0a fe ff          callq  77b420 <elog_start>
    0.00 :	  79a97c:       49 8b 4c 24 18          mov    0x18(%r12),%rcx
    0.00 :	  79a981:       89 da                   mov    %ebx,%edx
    0.00 :	  79a983:       be b8 24 8e 00          mov    $0x8e24b8,%esi
    0.00 :	  79a988:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  79a98d:       31 c0                   xor    %eax,%eax
    0.00 :	  79a98f:       e8 9c 08 fe ff          callq  77b230 <elog_finish>
    0.00 :	  79a994:       e8 37 eb cc ff          callq  4694d0 <abort@plt>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

   50.00 ??:0
   50.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000cd5c0 <__read>:
 ??:0
   50.00 :	   cd5c0:       83 3d ed a0 2a 00 00    cmpl   $0x0,0x2aa0ed(%rip)        # 3776b4 <__libc_multiple_threads>
    0.00 :	   cd5c7:       75 10                   jne    cd5d9 <__read_nocancel+0x10>
         :
         :	00000000000cd5c9 <__read_nocancel>:
    0.00 :	   cd5c9:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5ce:       0f 05                   syscall 
    0.00 :	   cd5d0:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd5d6:       73 31                   jae    cd609 <__read_nocancel+0x40>
   50.00 :	   cd5d8:       c3                      retq   
    0.00 :	   cd5d9:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   cd5dd:       e8 4e ac 01 00          callq  e8230 <__libc_enable_asynccancel>
    0.00 :	   cd5e2:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	   cd5e6:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	   cd5eb:       0f 05                   syscall 
    0.00 :	   cd5ed:       48 8b 3c 24             mov    (%rsp),%rdi
    0.00 :	   cd5f1:       48 89 c2                mov    %rax,%rdx
    0.00 :	   cd5f4:       e8 97 ac 01 00          callq  e8290 <__libc_disable_asynccancel>
    0.00 :	   cd5f9:       48 89 d0                mov    %rdx,%rax
    0.00 :	   cd5fc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   cd600:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   cd606:       73 01                   jae    cd609 <__read_nocancel+0x40>
    0.00 :	   cd608:       c3                      retq   
    0.00 :	   cd609:       48 8b 0d 28 48 2a 00    mov    0x2a4828(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   cd610:       31 d2                   xor    %edx,%edx
    0.00 :	   cd612:       48 29 c2                sub    %rax,%rdx
    0.00 :	   cd615:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   cd618:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   cd61c:       eb ea                   jmp    cd608 <__read_nocancel+0x3f>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/ixgbe/ixgbe.ko
----------------------------------------------

   50.00 ??:0
   50.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/ixgbe/ixgbe.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000001800 <ixgbe_update_stats>:
         :	/**
         :	 * ixgbe_update_stats - Update the board statistics counters.
         :	 * @adapter: board private structure
         :	 **/
         :	void ixgbe_update_stats(struct ixgbe_adapter *adapter)
         :	{
    0.00 :	    1800:       41 57                   push   %r15
    0.00 :	    1802:       41 56                   push   %r14
    0.00 :	    1804:       41 55                   push   %r13
    0.00 :	    1806:       41 54                   push   %r12
    0.00 :	    1808:       55                      push   %rbp
    0.00 :	    1809:       53                      push   %rbx
    0.00 :	    180a:       48 89 fb                mov    %rdi,%rbx
    0.00 :	    180d:       48 83 ec 28             sub    $0x28,%rsp
         :	        return oldbit;
         :	}
         :
         :	static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
         :	{
         :	        return ((1UL << (nr % BITS_PER_LONG)) &
    0.00 :	    1811:       48 8b 87 10 02 00 00    mov    0x210(%rdi),%rax
         :	#ifdef HAVE_NETDEV_STATS_IN_NETDEV
         :	        struct net_device_stats *net_stats = &adapter->netdev->stats;
    0.00 :	    1818:       4c 8b bf 00 02 00 00    mov    0x200(%rdi),%r15
         :	        u64 bytes = 0, packets = 0, hw_csum_rx_error = 0;
         :	#ifndef IXGBE_NO_LRO
         :	        u32 flushed = 0, coal = 0;
         :	#endif
         :
         :	        if (test_bit(__IXGBE_DOWN, &adapter->state) ||
    0.00 :	    181f:       a8 04                   test   $0x4,%al
    0.00 :	    1821:       0f 85 b9 09 00 00       jne    21e0 <ixgbe_update_stats+0x9e0>
    0.00 :	    1827:       48 8b 87 10 02 00 00    mov    0x210(%rdi),%rax
    0.00 :	    182e:       a8 02                   test   $0x2,%al
    0.00 :	    1830:       0f 85 aa 09 00 00       jne    21e0 <ixgbe_update_stats+0x9e0>
         :	            test_bit(__IXGBE_RESETTING, &adapter->state))
         :	                return;
         :
         :	        if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
    0.00 :	    1836:       f6 87 1c 02 00 00 02    testb  $0x2,0x21c(%rdi)
    0.00 :	    183d:       0f 85 ac 09 00 00       jne    21ef <ixgbe_update_stats+0x9ef>
    0.00 :	    1843:       44 8b 9f 28 02 00 00    mov    0x228(%rdi),%r11d
         :	                adapter->rsc_total_count = rsc_count;
         :	                adapter->rsc_total_flush = rsc_flush;
         :	        }
         :
         :	#ifndef IXGBE_NO_LRO
         :	        for (i = 0; i < adapter->num_q_vectors; i++) {
    0.00 :	    184a:       8b 83 c0 0b 00 00       mov    0xbc0(%rbx),%eax
    0.00 :	    1850:       31 f6                   xor    %esi,%esi
    0.00 :	    1852:       31 c9                   xor    %ecx,%ecx
    0.00 :	    1854:       85 c0                   test   %eax,%eax
    0.00 :	    1856:       74 3a                   je     1892 <ixgbe_update_stats+0x92>
    0.00 :	    1858:       83 e8 01                sub    $0x1,%eax
    0.00 :	    185b:       31 f6                   xor    %esi,%esi
    0.00 :	    185d:       31 c9                   xor    %ecx,%ecx
    0.00 :	    185f:       48 8d 3c c5 08 00 00    lea    0x8(,%rax,8),%rdi
    0.00 :	    1866:       00 
    0.00 :	    1867:       31 d2                   xor    %edx,%edx
    0.00 :	    1869:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                struct ixgbe_q_vector *q_vector = adapter->q_vector[i];
    0.00 :	    1870:       48 8b 84 13 50 07 00    mov    0x750(%rbx,%rdx,1),%rax
    0.00 :	    1877:       00 
         :	                if (!q_vector)
    0.00 :	    1878:       48 85 c0                test   %rax,%rax
    0.00 :	    187b:       74 0c                   je     1889 <ixgbe_update_stats+0x89>
         :	                        continue;
         :	                flushed += q_vector->lrolist.stats.flushed;
    0.00 :	    187d:       03 b0 b8 02 00 00       add    0x2b8(%rax),%esi
         :	                coal += q_vector->lrolist.stats.coal;
    0.00 :	    1883:       03 88 bc 02 00 00       add    0x2bc(%rax),%ecx
    0.00 :	    1889:       48 83 c2 08             add    $0x8,%rdx
         :	                adapter->rsc_total_count = rsc_count;
         :	                adapter->rsc_total_flush = rsc_flush;
         :	        }
         :
         :	#ifndef IXGBE_NO_LRO
         :	        for (i = 0; i < adapter->num_q_vectors; i++) {
    0.00 :	    188d:       48 39 fa                cmp    %rdi,%rdx
    0.00 :	    1890:       75 de                   jne    1870 <ixgbe_update_stats+0x70>
         :	        }
         :	        adapter->lro_stats.flushed = flushed;
         :	        adapter->lro_stats.coal = coal;
         :
         :	#endif
         :	        for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    1892:       45 85 db                test   %r11d,%r11d
         :	                if (!q_vector)
         :	                        continue;
         :	                flushed += q_vector->lrolist.stats.flushed;
         :	                coal += q_vector->lrolist.stats.coal;
         :	        }
         :	        adapter->lro_stats.flushed = flushed;
    0.00 :	    1895:       89 b3 f8 0b 00 00       mov    %esi,0xbf8(%rbx)
         :	        adapter->lro_stats.coal = coal;
    0.00 :	    189b:       89 8b fc 0b 00 00       mov    %ecx,0xbfc(%rbx)
         :
         :	#endif
         :	        for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    18a1:       0f 84 6b 0f 00 00       je     2812 <ixgbe_update_stats+0x1012>
    0.00 :	    18a7:       41 8d 43 ff             lea    -0x1(%r11),%eax
    0.00 :	    18ab:       45 31 d2                xor    %r10d,%r10d
    0.00 :	    18ae:       31 f6                   xor    %esi,%esi
    0.00 :	    18b0:       31 c9                   xor    %ecx,%ecx
    0.00 :	    18b2:       45 31 c9                xor    %r9d,%r9d
    0.00 :	    18b5:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    18b8:       4c 8d 1c c5 08 00 00    lea    0x8(,%rax,8),%r11
    0.00 :	    18bf:       00 
    0.00 :	    18c0:       31 ff                   xor    %edi,%edi
    0.00 :	    18c2:       31 d2                   xor    %edx,%edx
    0.00 :	    18c4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                struct ixgbe_ring *rx_ring = adapter->rx_ring[i];
    0.00 :	    18c8:       48 8b 84 13 d8 04 00    mov    0x4d8(%rbx,%rdx,1),%rax
    0.00 :	    18cf:       00 
         :	                non_eop_descs += rx_ring->rx_stats.non_eop_descs;
         :	                alloc_rx_page_failed += rx_ring->rx_stats.alloc_rx_page_failed;
         :	                alloc_rx_buff_failed += rx_ring->rx_stats.alloc_rx_buff_failed;
         :	                hw_csum_rx_error += rx_ring->rx_stats.csum_err;
         :	                bytes += rx_ring->stats.bytes;
         :	                packets += rx_ring->stats.packets;
    0.00 :	    18d0:       48 83 c2 08             add    $0x8,%rdx
         :	        adapter->lro_stats.coal = coal;
         :
         :	#endif
         :	        for (i = 0; i < adapter->num_rx_queues; i++) {
         :	                struct ixgbe_ring *rx_ring = adapter->rx_ring[i];
         :	                non_eop_descs += rx_ring->rx_stats.non_eop_descs;
    0.00 :	    18d4:       4c 03 50 78             add    0x78(%rax),%r10
         :	                alloc_rx_page_failed += rx_ring->rx_stats.alloc_rx_page_failed;
    0.00 :	    18d8:       48 03 b0 80 00 00 00    add    0x80(%rax),%rsi
         :	                alloc_rx_buff_failed += rx_ring->rx_stats.alloc_rx_buff_failed;
    0.00 :	    18df:       48 03 88 88 00 00 00    add    0x88(%rax),%rcx
         :	                hw_csum_rx_error += rx_ring->rx_stats.csum_err;
    0.00 :	    18e6:       48 03 b8 90 00 00 00    add    0x90(%rax),%rdi
         :	                bytes += rx_ring->stats.bytes;
    0.00 :	    18ed:       4c 03 48 60             add    0x60(%rax),%r9
         :	                packets += rx_ring->stats.packets;
    0.00 :	    18f1:       4c 03 40 58             add    0x58(%rax),%r8
         :	        }
         :	        adapter->lro_stats.flushed = flushed;
         :	        adapter->lro_stats.coal = coal;
         :
         :	#endif
         :	        for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    18f5:       4c 39 da                cmp    %r11,%rdx
    0.00 :	    18f8:       75 ce                   jne    18c8 <ixgbe_update_stats+0xc8>
    0.00 :	    18fa:       89 f2                   mov    %esi,%edx
    0.00 :	    18fc:       89 c8                   mov    %ecx,%eax
         :	                packets += rx_ring->stats.packets;
         :
         :	        }
         :	        adapter->non_eop_descs = non_eop_descs;
         :	        adapter->alloc_rx_page_failed = alloc_rx_page_failed;
         :	        adapter->alloc_rx_buff_failed = alloc_rx_buff_failed;
    0.00 :	    18fe:       89 83 4c 07 00 00       mov    %eax,0x74c(%rbx)
         :	                hw_csum_rx_error += rx_ring->rx_stats.csum_err;
         :	                bytes += rx_ring->stats.bytes;
         :	                packets += rx_ring->stats.packets;
         :
         :	        }
         :	        adapter->non_eop_descs = non_eop_descs;
    0.00 :	    1904:       4c 89 93 40 07 00 00    mov    %r10,0x740(%rbx)
         :	        adapter->alloc_rx_page_failed = alloc_rx_page_failed;
    0.00 :	    190b:       89 93 48 07 00 00       mov    %edx,0x748(%rbx)
         :	        adapter->alloc_rx_buff_failed = alloc_rx_buff_failed;
         :	        adapter->hw_csum_rx_error = hw_csum_rx_error;
    0.00 :	    1911:       48 89 bb 20 07 00 00    mov    %rdi,0x720(%rbx)
         :	        net_stats->rx_bytes = bytes;
    0.00 :	    1918:       4d 89 8f d8 00 00 00    mov    %r9,0xd8(%r15)
         :	        net_stats->rx_packets = packets;
    0.00 :	    191f:       4d 89 87 c8 00 00 00    mov    %r8,0xc8(%r15)
         :
         :	        bytes = 0;
         :	        packets = 0;
         :	        /* gather some stats to the adapter struct that are per queue */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
    0.00 :	    1926:       8b 83 20 02 00 00       mov    0x220(%rbx),%eax
    0.00 :	    192c:       85 c0                   test   %eax,%eax
    0.00 :	    192e:       0f 84 f2 0e 00 00       je     2826 <ixgbe_update_stats+0x1026>
    0.00 :	    1934:       83 e8 01                sub    $0x1,%eax
    0.00 :	    1937:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    193a:       31 ff                   xor    %edi,%edi
    0.00 :	    193c:       4c 8d 0c c5 08 00 00    lea    0x8(,%rax,8),%r9
    0.00 :	    1943:       00 
    0.00 :	    1944:       31 f6                   xor    %esi,%esi
    0.00 :	    1946:       31 c9                   xor    %ecx,%ecx
    0.00 :	    1948:       31 d2                   xor    %edx,%edx
    0.00 :	    194a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
    0.00 :	    1950:       48 8b 84 13 80 02 00    mov    0x280(%rbx,%rdx,1),%rax
    0.00 :	    1957:       00 
         :	                restart_queue += tx_ring->tx_stats.restart_queue;
         :	                tx_busy += tx_ring->tx_stats.tx_busy;
         :	                bytes += tx_ring->stats.bytes;
         :	                packets += tx_ring->stats.packets;
    0.00 :	    1958:       48 83 c2 08             add    $0x8,%rdx
         :	        bytes = 0;
         :	        packets = 0;
         :	        /* gather some stats to the adapter struct that are per queue */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
         :	                struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
         :	                restart_queue += tx_ring->tx_stats.restart_queue;
    0.00 :	    195c:       4c 03 40 68             add    0x68(%rax),%r8
         :	                tx_busy += tx_ring->tx_stats.tx_busy;
    0.00 :	    1960:       48 03 78 70             add    0x70(%rax),%rdi
         :	                bytes += tx_ring->stats.bytes;
    0.00 :	    1964:       48 03 70 60             add    0x60(%rax),%rsi
         :	                packets += tx_ring->stats.packets;
    0.00 :	    1968:       48 03 48 58             add    0x58(%rax),%rcx
         :	        net_stats->rx_packets = packets;
         :
         :	        bytes = 0;
         :	        packets = 0;
         :	        /* gather some stats to the adapter struct that are per queue */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
    0.00 :	    196c:       4c 39 ca                cmp    %r9,%rdx
    0.00 :	    196f:       75 df                   jne    1950 <ixgbe_update_stats+0x150>
         :	                restart_queue += tx_ring->tx_stats.restart_queue;
         :	                tx_busy += tx_ring->tx_stats.tx_busy;
         :	                bytes += tx_ring->stats.bytes;
         :	                packets += tx_ring->stats.packets;
         :	        }
         :	        adapter->restart_queue = restart_queue;
    0.00 :	    1971:       4c 89 83 c0 04 00 00    mov    %r8,0x4c0(%rbx)
         :	        adapter->tx_busy = tx_busy;
    0.00 :	    1978:       48 89 bb 08 1b 00 00    mov    %rdi,0x1b08(%rbx)
         :	        net_stats->tx_bytes = bytes;
    0.00 :	    197f:       49 89 b7 e0 00 00 00    mov    %rsi,0xe0(%r15)
         :	        net_stats->tx_packets = packets;
    0.00 :	    1986:       49 89 8f d0 00 00 00    mov    %rcx,0xd0(%r15)
         :	{ asm volatile("mov" size " %0,%1": :reg (val), \
         :	"m" (*(volatile type __force *)addr) barrier); }
         :
         :	build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
         :	build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
         :	build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    0.00 :	    198d:       48 8b 93 80 0e 00 00    mov    0xe80(%rbx),%rdx
         :
         :	        hwstats->crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
    0.00 :	    1994:       48 8b 83 b0 14 00 00    mov    0x14b0(%rbx),%rax
    0.00 :	    199b:       48 81 c2 00 40 00 00    add    $0x4000,%rdx
    0.00 :	    19a2:       8b 12                   mov    (%rdx),%edx
    0.00 :	    19a4:       89 d2                   mov    %edx,%edx
    0.00 :	    19a6:       48 89 df                mov    %rbx,%rdi
    0.00 :	    19a9:       48 89 d9                mov    %rbx,%rcx
    0.00 :	    19ac:       48 01 c2                add    %rax,%rdx
    0.00 :	    19af:       45 31 f6                xor    %r14d,%r14d
    0.00 :	    19b2:       45 31 c9                xor    %r9d,%r9d
    0.00 :	    19b5:       48 89 93 b0 14 00 00    mov    %rdx,0x14b0(%rbx)
    0.00 :	    19bc:       be a0 3f 00 00          mov    $0x3fa0,%esi
    0.00 :	    19c1:       41 b8 34 60 00 00       mov    $0x6034,%r8d
    0.00 :	    19c7:       eb 4a                   jmp    1a13 <ixgbe_update_stats+0x213>
    0.00 :	    19c9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                missed_rx += mpc;
         :	                hwstats->mpc[i] += mpc;
         :	                total_mpc += hwstats->mpc[i];
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
         :	                switch (hw->mac.type) {
    0.00 :	    19d0:       72 28                   jb     19fa <ixgbe_update_stats+0x1fa>
    0.00 :	    19d2:       83 f8 03                cmp    $0x3,%eax
    0.00 :	    19d5:       77 23                   ja     19fa <ixgbe_update_stats+0x1fa>
    0.00 :	    19d7:       48 8d 96 a0 01 00 00    lea    0x1a0(%rsi),%rdx
         :	                        hwstats->pxonrxc[i] +=
         :	                                IXGBE_READ_REG(hw, IXGBE_PXONRXC(i));
         :	                        break;
         :	                case ixgbe_mac_82599EB:
         :	                case ixgbe_mac_X540:
         :	                        hwstats->pxonrxc[i] +=
    0.00 :	    19de:       48 8b 81 90 15 00 00    mov    0x1590(%rcx),%rax
    0.00 :	    19e5:       48 03 93 80 0e 00 00    add    0xe80(%rbx),%rdx
    0.00 :	    19ec:       8b 12                   mov    (%rdx),%edx
    0.00 :	    19ee:       89 d2                   mov    %edx,%edx
    0.00 :	    19f0:       48 01 c2                add    %rax,%rdx
    0.00 :	    19f3:       48 89 91 90 15 00 00    mov    %rdx,0x1590(%rcx)
    0.00 :	    19fa:       48 83 c6 04             add    $0x4,%rsi
    0.00 :	    19fe:       48 83 c1 08             add    $0x8,%rcx
    0.00 :	    1a02:       49 83 c0 40             add    $0x40,%r8
         :	        net_stats->tx_packets = packets;
         :
         :	        hwstats->crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
         :
         :	        /* 8 register reads */
         :	        for (i = 0; i < 8; i++) {
    0.00 :	    1a06:       48 81 fe c0 3f 00 00    cmp    $0x3fc0,%rsi
    0.00 :	    1a0d:       0f 84 35 08 00 00       je     2248 <ixgbe_update_stats+0xa48>
    0.00 :	    1a13:       48 89 f0                mov    %rsi,%rax
    0.00 :	    1a16:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1a1d:       8b 00                   mov    (%rax),%eax
         :	                /* for packet buffers not used, the register should read 0 */
         :	                mpc = IXGBE_READ_REG(hw, IXGBE_MPC(i));
         :	                missed_rx += mpc;
    0.00 :	    1a1f:       41 01 c1                add    %eax,%r9d
         :	                hwstats->mpc[i] += mpc;
    0.00 :	    1a22:       89 c0                   mov    %eax,%eax
    0.00 :	    1a24:       48 03 81 d8 14 00 00    add    0x14d8(%rcx),%rax
         :	                total_mpc += hwstats->mpc[i];
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
    0.00 :	    1a2b:       48 8b 91 50 15 00 00    mov    0x1550(%rcx),%rdx
         :	        /* 8 register reads */
         :	        for (i = 0; i < 8; i++) {
         :	                /* for packet buffers not used, the register should read 0 */
         :	                mpc = IXGBE_READ_REG(hw, IXGBE_MPC(i));
         :	                missed_rx += mpc;
         :	                hwstats->mpc[i] += mpc;
    0.00 :	    1a32:       48 89 81 d8 14 00 00    mov    %rax,0x14d8(%rcx)
         :	                total_mpc += hwstats->mpc[i];
    0.00 :	    1a39:       49 01 c6                add    %rax,%r14
    0.00 :	    1a3c:       48 8d 86 60 ff ff ff    lea    -0xa0(%rsi),%rax
    0.00 :	    1a43:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1a4a:       8b 00                   mov    (%rax),%eax
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
    0.00 :	    1a4c:       89 c0                   mov    %eax,%eax
    0.00 :	    1a4e:       48 01 d0                add    %rdx,%rax
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
    0.00 :	    1a51:       48 8b 91 d0 15 00 00    mov    0x15d0(%rcx),%rdx
         :	                /* for packet buffers not used, the register should read 0 */
         :	                mpc = IXGBE_READ_REG(hw, IXGBE_MPC(i));
         :	                missed_rx += mpc;
         :	                hwstats->mpc[i] += mpc;
         :	                total_mpc += hwstats->mpc[i];
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
    0.00 :	    1a58:       48 89 81 50 15 00 00    mov    %rax,0x1550(%rcx)
    0.00 :	    1a5f:       48 8d 46 80             lea    -0x80(%rsi),%rax
    0.00 :	    1a63:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1a6a:       8b 00                   mov    (%rax),%eax
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
    0.00 :	    1a6c:       89 c0                   mov    %eax,%eax
    0.00 :	    1a6e:       48 01 d0                add    %rdx,%rax
    0.00 :	    1a71:       48 89 81 d0 15 00 00    mov    %rax,0x15d0(%rcx)
         :	                switch (hw->mac.type) {
    0.00 :	    1a78:       8b 83 50 10 00 00       mov    0x1050(%rbx),%eax
    0.00 :	    1a7e:       83 f8 01                cmp    $0x1,%eax
    0.00 :	    1a81:       0f 85 49 ff ff ff       jne    19d0 <ixgbe_update_stats+0x1d0>
    0.00 :	    1a87:       48 8d 46 20             lea    0x20(%rsi),%rax
         :	                case ixgbe_mac_82598EB:
         :	                        hwstats->rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
    0.00 :	    1a8b:       48 8b 91 b0 16 00 00    mov    0x16b0(%rcx),%rdx
    0.00 :	    1a92:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1a99:       8b 00                   mov    (%rax),%eax
    0.00 :	    1a9b:       89 c0                   mov    %eax,%eax
    0.00 :	    1a9d:       48 01 d0                add    %rdx,%rax
         :	                        hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
    0.00 :	    1aa0:       48 8b 91 08 19 00 00    mov    0x1908(%rcx),%rdx
         :	                total_mpc += hwstats->mpc[i];
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
         :	                switch (hw->mac.type) {
         :	                case ixgbe_mac_82598EB:
         :	                        hwstats->rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
    0.00 :	    1aa7:       48 89 81 b0 16 00 00    mov    %rax,0x16b0(%rcx)
    0.00 :	    1aae:       4c 89 c0                mov    %r8,%rax
    0.00 :	    1ab1:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1ab8:       8b 00                   mov    (%rax),%eax
         :	                        hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
    0.00 :	    1aba:       89 c0                   mov    %eax,%eax
    0.00 :	    1abc:       48 01 d0                add    %rdx,%rax
         :	                        hwstats->qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC(i));
    0.00 :	    1abf:       48 8b 91 88 18 00 00    mov    0x1888(%rcx),%rdx
         :	                hwstats->pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
         :	                switch (hw->mac.type) {
         :	                case ixgbe_mac_82598EB:
         :	                        hwstats->rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
         :	                        hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
    0.00 :	    1ac6:       48 89 81 08 19 00 00    mov    %rax,0x1908(%rcx)
    0.00 :	    1acd:       49 8d 80 00 b0 ff ff    lea    -0x5000(%r8),%rax
    0.00 :	    1ad4:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1adb:       8b 00                   mov    (%rax),%eax
         :	                        hwstats->qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC(i));
    0.00 :	    1add:       89 c0                   mov    %eax,%eax
    0.00 :	    1adf:       48 01 d0                add    %rdx,%rax
         :	                        hwstats->pxonrxc[i] +=
    0.00 :	    1ae2:       48 8b 91 90 15 00 00    mov    0x1590(%rcx),%rdx
         :	                hwstats->pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
         :	                switch (hw->mac.type) {
         :	                case ixgbe_mac_82598EB:
         :	                        hwstats->rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
         :	                        hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
         :	                        hwstats->qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC(i));
    0.00 :	    1ae9:       48 89 81 88 18 00 00    mov    %rax,0x1888(%rcx)
    0.00 :	    1af0:       48 8d 86 60 8f 00 00    lea    0x8f60(%rsi),%rax
    0.00 :	    1af7:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1afe:       8b 00                   mov    (%rax),%eax
         :	                        hwstats->pxonrxc[i] +=
    0.00 :	    1b00:       89 c0                   mov    %eax,%eax
    0.00 :	    1b02:       48 01 d0                add    %rdx,%rax
    0.00 :	    1b05:       48 89 81 90 15 00 00    mov    %rax,0x1590(%rcx)
         :	                                IXGBE_READ_REG(hw, IXGBE_PXONRXC(i));
         :	                        break;
    0.00 :	    1b0c:       e9 e9 fe ff ff          jmpq   19fa <ixgbe_update_stats+0x1fa>
    0.00 :	    1b11:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	        struct ixgbe_hw *hw = &adapter->hw;
         :	        struct ixgbe_hw_stats *hwstats = &adapter->stats;
         :	        int i;
         :	        u32 data;
         :
         :	        if ((hw->fc.current_mode != ixgbe_fc_full) &&
    0.00 :	    1b18:       8b 83 0c 13 00 00       mov    0x130c(%rbx),%eax
    0.00 :	    1b1e:       83 f8 03                cmp    $0x3,%eax
    0.00 :	    1b21:       0f 84 1c 0c 00 00       je     2743 <ixgbe_update_stats+0xf43>
    0.00 :	    1b27:       83 e8 01                sub    $0x1,%eax
    0.00 :	    1b2a:       0f 84 13 0c 00 00       je     2743 <ixgbe_update_stats+0xf43>
         :	        hwstats->gprc -= missed_rx;
         :
         :	        ixgbe_update_xoff_received(adapter);
         :
         :	        /* 82598 hardware only has a 32 bit counter in the high register */
         :	        switch (hw->mac.type) {
    0.00 :	    1b30:       8b 83 50 10 00 00       mov    0x1050(%rbx),%eax
    0.00 :	    1b36:       83 f8 02                cmp    $0x2,%eax
    0.00 :	    1b39:       0f 84 7a 09 00 00       je     24b9 <ixgbe_update_stats+0xcb9>
    0.00 :	    1b3f:       83 f8 03                cmp    $0x3,%eax
    0.00 :	    1b42:       0f 84 e9 08 00 00       je     2431 <ixgbe_update_stats+0xc31>
    0.00 :	    1b48:       83 e8 01                sub    $0x1,%eax
    0.00 :	    1b4b:       0f 85 88 00 00 00       jne    1bd9 <ixgbe_update_stats+0x3d9>
    0.00 :	    1b51:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	        case ixgbe_mac_82598EB:
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
    0.00 :	    1b58:       48 8b 93 38 15 00 00    mov    0x1538(%rbx),%rdx
    0.00 :	    1b5f:       48 05 60 cf 00 00       add    $0xcf60,%rax
    0.00 :	    1b65:       8b 00                   mov    (%rax),%eax
    0.00 :	    1b67:       89 c0                   mov    %eax,%eax
    0.00 :	    1b69:       48 01 d0                add    %rdx,%rax
         :	                hwstats->gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
    0.00 :	    1b6c:       48 8b 93 a0 16 00 00    mov    0x16a0(%rbx),%rdx
         :	        ixgbe_update_xoff_received(adapter);
         :
         :	        /* 82598 hardware only has a 32 bit counter in the high register */
         :	        switch (hw->mac.type) {
         :	        case ixgbe_mac_82598EB:
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
    0.00 :	    1b73:       48 89 83 38 15 00 00    mov    %rax,0x1538(%rbx)
    0.00 :	    1b7a:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1b81:       48 05 8c 40 00 00       add    $0x408c,%rax
    0.00 :	    1b87:       8b 00                   mov    (%rax),%eax
         :	                hwstats->gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
    0.00 :	    1b89:       89 c0                   mov    %eax,%eax
    0.00 :	    1b8b:       48 01 d0                add    %rdx,%rax
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
    0.00 :	    1b8e:       48 8b 93 a8 16 00 00    mov    0x16a8(%rbx),%rdx
         :
         :	        /* 82598 hardware only has a 32 bit counter in the high register */
         :	        switch (hw->mac.type) {
         :	        case ixgbe_mac_82598EB:
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
         :	                hwstats->gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
    0.00 :	    1b95:       48 89 83 a0 16 00 00    mov    %rax,0x16a0(%rbx)
    0.00 :	    1b9c:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1ba3:       48 05 94 40 00 00       add    $0x4094,%rax
    0.00 :	    1ba9:       8b 00                   mov    (%rax),%eax
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
    0.00 :	    1bab:       89 c0                   mov    %eax,%eax
    0.00 :	    1bad:       48 01 d0                add    %rdx,%rax
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORH);
    0.00 :	    1bb0:       48 8b 93 28 17 00 00    mov    0x1728(%rbx),%rdx
         :	        /* 82598 hardware only has a 32 bit counter in the high register */
         :	        switch (hw->mac.type) {
         :	        case ixgbe_mac_82598EB:
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
         :	                hwstats->gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
    0.00 :	    1bb7:       48 89 83 a8 16 00 00    mov    %rax,0x16a8(%rbx)
    0.00 :	    1bbe:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1bc5:       48 05 c4 40 00 00       add    $0x40c4,%rax
    0.00 :	    1bcb:       8b 00                   mov    (%rax),%eax
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORH);
    0.00 :	    1bcd:       89 c0                   mov    %eax,%eax
    0.00 :	    1bcf:       48 01 d0                add    %rdx,%rax
    0.00 :	    1bd2:       48 89 83 28 17 00 00    mov    %rax,0x1728(%rbx)
    0.00 :	    1bd9:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1be0:       48 05 78 40 00 00       add    $0x4078,%rax
    0.00 :	    1be6:       8b 00                   mov    (%rax),%eax
         :	                break;
         :	        default:
         :	                break;
         :	        }
         :	        bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
         :	        hwstats->bprc += bprc;
    0.00 :	    1be8:       89 c1                   mov    %eax,%ecx
    0.00 :	    1bea:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1bf1:       48 01 8b 88 16 00 00    add    %rcx,0x1688(%rbx)
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
    0.00 :	    1bf8:       48 8b 93 90 16 00 00    mov    0x1690(%rbx),%rdx
    0.00 :	    1bff:       48 05 7c 40 00 00       add    $0x407c,%rax
    0.00 :	    1c05:       8b 00                   mov    (%rax),%eax
    0.00 :	    1c07:       89 c0                   mov    %eax,%eax
    0.00 :	    1c09:       48 01 d0                add    %rdx,%rax
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
    0.00 :	    1c0c:       83 bb 50 10 00 00 01    cmpl   $0x1,0x1050(%rbx)
         :	        default:
         :	                break;
         :	        }
         :	        bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
         :	        hwstats->bprc += bprc;
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
    0.00 :	    1c13:       48 89 83 90 16 00 00    mov    %rax,0x1690(%rbx)
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
    0.00 :	    1c1a:       0f 84 84 0b 00 00       je     27a4 <ixgbe_update_stats+0xfa4>
    0.00 :	    1c20:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
    0.00 :	    1c27:       48 8b 93 00 17 00 00    mov    0x1700(%rbx),%rdx
    0.00 :	    1c2e:       48 05 ac 40 00 00       add    $0x40ac,%rax
    0.00 :	    1c34:       8b 00                   mov    (%rax),%eax
    0.00 :	    1c36:       89 c0                   mov    %eax,%eax
    0.00 :	    1c38:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
    0.00 :	    1c3b:       48 8b 93 50 16 00 00    mov    0x1650(%rbx),%rdx
         :	        bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
         :	        hwstats->bprc += bprc;
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
    0.00 :	    1c42:       48 89 83 00 17 00 00    mov    %rax,0x1700(%rbx)
    0.00 :	    1c49:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1c50:       48 05 5c 40 00 00       add    $0x405c,%rax
    0.00 :	    1c56:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
    0.00 :	    1c58:       89 c0                   mov    %eax,%eax
    0.00 :	    1c5a:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
    0.00 :	    1c5d:       48 8b 93 58 16 00 00    mov    0x1658(%rbx),%rdx
         :	        hwstats->bprc += bprc;
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
    0.00 :	    1c64:       48 89 83 50 16 00 00    mov    %rax,0x1650(%rbx)
    0.00 :	    1c6b:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1c72:       48 05 60 40 00 00       add    $0x4060,%rax
    0.00 :	    1c78:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
    0.00 :	    1c7a:       89 c0                   mov    %eax,%eax
    0.00 :	    1c7c:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
    0.00 :	    1c7f:       48 8b 93 60 16 00 00    mov    0x1660(%rbx),%rdx
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
    0.00 :	    1c86:       48 89 83 58 16 00 00    mov    %rax,0x1658(%rbx)
    0.00 :	    1c8d:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1c94:       48 05 64 40 00 00       add    $0x4064,%rax
    0.00 :	    1c9a:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
    0.00 :	    1c9c:       89 c0                   mov    %eax,%eax
    0.00 :	    1c9e:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
    0.00 :	    1ca1:       48 8b 93 68 16 00 00    mov    0x1668(%rbx),%rdx
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
    0.00 :	    1ca8:       48 89 83 60 16 00 00    mov    %rax,0x1660(%rbx)
    0.00 :	    1caf:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1cb6:       48 05 68 40 00 00       add    $0x4068,%rax
    0.00 :	    1cbc:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
    0.00 :	    1cbe:       89 c0                   mov    %eax,%eax
    0.00 :	    1cc0:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
    0.00 :	    1cc3:       48 8b 93 70 16 00 00    mov    0x1670(%rbx),%rdx
         :	                hwstats->mprc -= bprc;
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
         :	        hwstats->prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
    0.00 :	    1cca:       48 89 83 68 16 00 00    mov    %rax,0x1668(%rbx)
    0.00 :	    1cd1:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1cd8:       48 05 6c 40 00 00       add    $0x406c,%rax
    0.00 :	    1cde:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
    0.00 :	    1ce0:       89 c0                   mov    %eax,%eax
    0.00 :	    1ce2:       48 01 d0                add    %rdx,%rax
         :	        hwstats->prc1522 += IXGBE_READ_REG(hw, IXGBE_PRC1522);
    0.00 :	    1ce5:       48 8b 93 78 16 00 00    mov    0x1678(%rbx),%rdx
         :	        hwstats->roc += IXGBE_READ_REG(hw, IXGBE_ROC);
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
         :	        hwstats->prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
         :	        hwstats->prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
    0.00 :	    1cec:       48 89 83 70 16 00 00    mov    %rax,0x1670(%rbx)
    0.00 :	    1cf3:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1cfa:       48 05 70 40 00 00       add    $0x4070,%rax
    0.00 :	    1d00:       8b 00                   mov    (%rax),%eax
         :	        hwstats->prc1522 += IXGBE_READ_REG(hw, IXGBE_PRC1522);
    0.00 :	    1d02:       89 c0                   mov    %eax,%eax
    0.00 :	    1d04:       48 01 d0                add    %rdx,%rax
         :	        hwstats->rlec += IXGBE_READ_REG(hw, IXGBE_RLEC);
    0.00 :	    1d07:       48 8b 93 28 15 00 00    mov    0x1528(%rbx),%rdx
         :	        hwstats->prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
         :	        hwstats->prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
         :	        hwstats->prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
         :	        hwstats->prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
         :	        hwstats->prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
         :	        hwstats->prc1522 += IXGBE_READ_REG(hw, IXGBE_PRC1522);
    0.00 :	    1d0e:       48 89 83 78 16 00 00    mov    %rax,0x1678(%rbx)
    0.00 :	    1d15:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1d1c:       48 05 40 40 00 00       add    $0x4040,%rax
    0.00 :	    1d22:       8b 00                   mov    (%rax),%eax
         :	        hwstats->rlec += IXGBE_READ_REG(hw, IXGBE_RLEC);
    0.00 :	    1d24:       89 c0                   mov    %eax,%eax
    0.00 :	    1d26:       48 01 d0                add    %rdx,%rax
    0.00 :	    1d29:       48 89 83 28 15 00 00    mov    %rax,0x1528(%rbx)
    0.00 :	    1d30:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1d37:       48 05 60 3f 00 00       add    $0x3f60,%rax
    0.00 :	    1d3d:       8b 30                   mov    (%rax),%esi
         :	        lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
         :	        hwstats->lxontxc += lxon;
    0.00 :	    1d3f:       89 f0                   mov    %esi,%eax
    0.00 :	    1d41:       48 01 83 30 15 00 00    add    %rax,0x1530(%rbx)
    0.00 :	    1d48:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1d4f:       48 05 68 3f 00 00       add    $0x3f68,%rax
    0.00 :	    1d55:       8b 10                   mov    (%rax),%edx
         :	        lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
         :	        hwstats->lxofftxc += lxoff;
    0.00 :	    1d57:       89 d0                   mov    %edx,%eax
    0.00 :	    1d59:       48 01 83 40 15 00 00    add    %rax,0x1540(%rbx)
    0.00 :	    1d60:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	        hwstats->gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
    0.00 :	    1d67:       48 8b 8b 98 16 00 00    mov    0x1698(%rbx),%rcx
    0.00 :	    1d6e:       48 05 80 40 00 00       add    $0x4080,%rax
    0.00 :	    1d74:       8b 00                   mov    (%rax),%eax
    0.00 :	    1d76:       89 c0                   mov    %eax,%eax
    0.00 :	    1d78:       48 01 c8                add    %rcx,%rax
         :	        hwstats->mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
    0.00 :	    1d7b:       48 8b 8b 70 17 00 00    mov    0x1770(%rbx),%rcx
         :	        hwstats->rlec += IXGBE_READ_REG(hw, IXGBE_RLEC);
         :	        lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
         :	        hwstats->lxontxc += lxon;
         :	        lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
         :	        hwstats->lxofftxc += lxoff;
         :	        hwstats->gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
    0.00 :	    1d82:       48 89 83 98 16 00 00    mov    %rax,0x1698(%rbx)
    0.00 :	    1d89:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1d90:       48 05 f0 40 00 00       add    $0x40f0,%rax
    0.00 :	    1d96:       8b 00                   mov    (%rax),%eax
         :	        hwstats->mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
    0.00 :	    1d98:       89 c0                   mov    %eax,%eax
         :	        /*
         :	         * 82598 errata - tx of flow control packets is included in tx counters
         :	         */
         :	        xon_off_tot = lxon + lxoff;
    0.00 :	    1d9a:       01 f2                   add    %esi,%edx
         :	        lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
         :	        hwstats->lxontxc += lxon;
         :	        lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
         :	        hwstats->lxofftxc += lxoff;
         :	        hwstats->gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
         :	        hwstats->mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
    0.00 :	    1d9c:       48 01 c8                add    %rcx,%rax
         :	        /*
         :	         * 82598 errata - tx of flow control packets is included in tx counters
         :	         */
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
    0.00 :	    1d9f:       89 d1                   mov    %edx,%ecx
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
    0.00 :	    1da1:       c1 e2 06                shl    $0x6,%edx
         :	        lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
         :	        hwstats->lxontxc += lxon;
         :	        lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
         :	        hwstats->lxofftxc += lxoff;
         :	        hwstats->gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
         :	        hwstats->mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
    0.00 :	    1da4:       48 89 83 70 17 00 00    mov    %rax,0x1770(%rbx)
    0.00 :	    1dab:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	         * 82598 errata - tx of flow control packets is included in tx counters
         :	         */
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
    0.00 :	    1db2:       89 d2                   mov    %edx,%edx
         :	        hwstats->mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
         :	        /*
         :	         * 82598 errata - tx of flow control packets is included in tx counters
         :	         */
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
    0.00 :	    1db4:       48 29 8b 98 16 00 00    sub    %rcx,0x1698(%rbx)
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
    0.00 :	    1dbb:       48 29 93 a8 16 00 00    sub    %rdx,0x16a8(%rbx)
         :	        /*
         :	         * 82598 errata - tx of flow control packets is included in tx counters
         :	         */
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
         :	        hwstats->mptc -= xon_off_tot;
    0.00 :	    1dc2:       48 29 8b 70 17 00 00    sub    %rcx,0x1770(%rbx)
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
    0.00 :	    1dc9:       48 8b 93 f0 16 00 00    mov    0x16f0(%rbx),%rdx
    0.00 :	    1dd0:       48 05 a4 40 00 00       add    $0x40a4,%rax
    0.00 :	    1dd6:       8b 00                   mov    (%rax),%eax
    0.00 :	    1dd8:       89 c0                   mov    %eax,%eax
    0.00 :	    1dda:       48 01 d0                add    %rdx,%rax
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
    0.00 :	    1ddd:       48 8b 93 f8 16 00 00    mov    0x16f8(%rbx),%rdx
         :	         */
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
    0.00 :	    1de4:       48 89 83 f0 16 00 00    mov    %rax,0x16f0(%rbx)
    0.00 :	    1deb:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1df2:       48 05 a8 40 00 00       add    $0x40a8,%rax
    0.00 :	    1df8:       8b 00                   mov    (%rax),%eax
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
    0.00 :	    1dfa:       89 c0                   mov    %eax,%eax
    0.00 :	    1dfc:       48 01 d0                add    %rdx,%rax
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
    0.00 :	    1dff:       48 8b 93 08 17 00 00    mov    0x1708(%rbx),%rdx
         :	        xon_off_tot = lxon + lxoff;
         :	        hwstats->gptc -= xon_off_tot;
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
    0.00 :	    1e06:       48 89 83 f8 16 00 00    mov    %rax,0x16f8(%rbx)
    0.00 :	    1e0d:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1e14:       48 05 b0 40 00 00       add    $0x40b0,%rax
    0.00 :	    1e1a:       8b 00                   mov    (%rax),%eax
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
    0.00 :	    1e1c:       89 c0                   mov    %eax,%eax
    0.00 :	    1e1e:       48 01 d0                add    %rdx,%rax
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
    0.00 :	    1e21:       48 8b 93 30 17 00 00    mov    0x1730(%rbx),%rdx
         :	        hwstats->gptc -= xon_off_tot;
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
    0.00 :	    1e28:       48 89 83 08 17 00 00    mov    %rax,0x1708(%rbx)
    0.00 :	    1e2f:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1e36:       48 05 d0 40 00 00       add    $0x40d0,%rax
    0.00 :	    1e3c:       8b 00                   mov    (%rax),%eax
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
    0.00 :	    1e3e:       89 c0                   mov    %eax,%eax
    0.00 :	    1e40:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
    0.00 :	    1e43:       48 8b 93 40 17 00 00    mov    0x1740(%rbx),%rdx
         :	        hwstats->mptc -= xon_off_tot;
         :	        hwstats->gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
    0.00 :	    1e4a:       48 89 83 30 17 00 00    mov    %rax,0x1730(%rbx)
    0.00 :	    1e51:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1e58:       48 05 d8 40 00 00       add    $0x40d8,%rax
    0.00 :	    1e5e:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
    0.00 :	    1e60:       89 c0                   mov    %eax,%eax
    0.00 :	    1e62:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
    0.00 :	    1e65:       48 8b 93 48 17 00 00    mov    0x1748(%rbx),%rdx
         :	        hwstats->ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
    0.00 :	    1e6c:       48 29 c8                sub    %rcx,%rax
    0.00 :	    1e6f:       48 89 83 40 17 00 00    mov    %rax,0x1740(%rbx)
    0.00 :	    1e76:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1e7d:       48 05 dc 40 00 00       add    $0x40dc,%rax
    0.00 :	    1e83:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
    0.00 :	    1e85:       89 c0                   mov    %eax,%eax
    0.00 :	    1e87:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
    0.00 :	    1e8a:       48 8b 93 50 17 00 00    mov    0x1750(%rbx),%rdx
         :	        hwstats->rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
    0.00 :	    1e91:       48 89 83 48 17 00 00    mov    %rax,0x1748(%rbx)
    0.00 :	    1e98:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1e9f:       48 05 e0 40 00 00       add    $0x40e0,%rax
    0.00 :	    1ea5:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
    0.00 :	    1ea7:       89 c0                   mov    %eax,%eax
    0.00 :	    1ea9:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
    0.00 :	    1eac:       48 8b 93 58 17 00 00    mov    0x1758(%rbx),%rdx
         :	        hwstats->rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
    0.00 :	    1eb3:       48 89 83 50 17 00 00    mov    %rax,0x1750(%rbx)
    0.00 :	    1eba:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1ec1:       48 05 e4 40 00 00       add    $0x40e4,%rax
    0.00 :	    1ec7:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
    0.00 :	    1ec9:       89 c0                   mov    %eax,%eax
    0.00 :	    1ecb:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
    0.00 :	    1ece:       48 8b 93 60 17 00 00    mov    0x1760(%rbx),%rdx
         :	        hwstats->tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
         :	        hwstats->ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
    0.00 :	    1ed5:       48 89 83 58 17 00 00    mov    %rax,0x1758(%rbx)
    0.00 :	    1edc:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1ee3:       48 05 e8 40 00 00       add    $0x40e8,%rax
    0.00 :	    1ee9:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
    0.00 :	    1eeb:       89 c0                   mov    %eax,%eax
    0.00 :	    1eed:       48 01 d0                add    %rdx,%rax
         :	        hwstats->ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
    0.00 :	    1ef0:       48 8b 93 68 17 00 00    mov    0x1768(%rbx),%rdx
         :	        hwstats->ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
         :	        hwstats->ptc64 -= xon_off_tot;
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
         :	        hwstats->ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
         :	        hwstats->ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
    0.00 :	    1ef7:       48 89 83 60 17 00 00    mov    %rax,0x1760(%rbx)
    0.00 :	    1efe:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1f05:       48 05 ec 40 00 00       add    $0x40ec,%rax
    0.00 :	    1f0b:       8b 00                   mov    (%rax),%eax
         :	        hwstats->ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
    0.00 :	    1f0d:       89 c0                   mov    %eax,%eax
    0.00 :	    1f0f:       48 01 d0                add    %rdx,%rax
         :	        hwstats->bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
    0.00 :	    1f12:       48 8b 93 78 17 00 00    mov    0x1778(%rbx),%rdx
         :	        hwstats->ptc64 -= xon_off_tot;
         :	        hwstats->ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
         :	        hwstats->ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
         :	        hwstats->ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
         :	        hwstats->ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
         :	        hwstats->ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
    0.00 :	    1f19:       48 89 83 68 17 00 00    mov    %rax,0x1768(%rbx)
    0.00 :	    1f20:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    1f27:       48 05 f4 40 00 00       add    $0x40f4,%rax
    0.00 :	    1f2d:       8b 00                   mov    (%rax),%eax
         :	        hwstats->bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
    0.00 :	    1f2f:       89 c0                   mov    %eax,%eax
    0.00 :	    1f31:       48 01 d0                add    %rdx,%rax
    0.00 :	    1f34:       48 89 83 78 17 00 00    mov    %rax,0x1778(%rbx)
         :	        /* Fill out the OS statistics structure */
         :	        net_stats->multicast = hwstats->mprc;
    0.00 :	    1f3b:       48 8b 83 90 16 00 00    mov    0x1690(%rbx),%rax
    0.00 :	    1f42:       49 89 87 08 01 00 00    mov    %rax,0x108(%r15)
         :
         :	        /* Rx Errors */
         :	        net_stats->rx_errors = hwstats->crcerrs +
    0.00 :	    1f49:       48 8b 83 28 15 00 00    mov    0x1528(%rbx),%rax
    0.00 :	    1f50:       48 03 83 b0 14 00 00    add    0x14b0(%rbx),%rax
         :	                                       hwstats->rlec;
         :	        net_stats->rx_dropped = 0;
    0.00 :	    1f57:       49 c7 87 f8 00 00 00    movq   $0x0,0xf8(%r15)
    0.00 :	    1f5e:       00 00 00 00 
         :	        hwstats->bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
         :	        /* Fill out the OS statistics structure */
         :	        net_stats->multicast = hwstats->mprc;
         :
         :	        /* Rx Errors */
         :	        net_stats->rx_errors = hwstats->crcerrs +
    0.00 :	    1f62:       49 89 87 e8 00 00 00    mov    %rax,0xe8(%r15)
         :	                                       hwstats->rlec;
         :	        net_stats->rx_dropped = 0;
         :	        net_stats->rx_length_errors = hwstats->rlec;
    0.00 :	    1f69:       48 8b 83 28 15 00 00    mov    0x1528(%rbx),%rax
    0.00 :	    1f70:       49 89 87 18 01 00 00    mov    %rax,0x118(%r15)
         :	        net_stats->rx_crc_errors = hwstats->crcerrs;
    0.00 :	    1f77:       48 8b 83 b0 14 00 00    mov    0x14b0(%rbx),%rax
         :	        net_stats->rx_missed_errors = total_mpc;
    0.00 :	    1f7e:       4d 89 b7 40 01 00 00    mov    %r14,0x140(%r15)
         :	        /* Rx Errors */
         :	        net_stats->rx_errors = hwstats->crcerrs +
         :	                                       hwstats->rlec;
         :	        net_stats->rx_dropped = 0;
         :	        net_stats->rx_length_errors = hwstats->rlec;
         :	        net_stats->rx_crc_errors = hwstats->crcerrs;
    0.00 :	    1f85:       49 89 87 28 01 00 00    mov    %rax,0x128(%r15)
    0.00 :	    1f8c:       48 8b 83 10 02 00 00    mov    0x210(%rbx),%rax
         :	        /*
         :	         * VF Stats Collection - skip while resetting because these
         :	         * are not clear on read and otherwise you'll sometimes get
         :	         * crazy values.
         :	         */
         :	        if (!test_bit(__IXGBE_RESETTING, &adapter->state)) {
    0.00 :	    1f93:       a8 02                   test   $0x2,%al
    0.00 :	    1f95:       0f 85 45 02 00 00       jne    21e0 <ixgbe_update_stats+0x9e0>
         :	                for (i = 0; i < adapter->num_vfs; i++) {
    0.00 :	    1f9b:       8b 83 58 7c 00 00       mov    0x7c58(%rbx),%eax
    0.00 :	    1fa1:       85 c0                   test   %eax,%eax
    0.00 :	    1fa3:       0f 84 37 02 00 00       je     21e0 <ixgbe_update_stats+0x9e0>
    0.00 :	    1fa9:       45 31 c9                xor    %r9d,%r9d
    0.00 :	    1fac:       bf 1c 10 00 00          mov    $0x101c,%edi
    0.00 :	    1fb1:       41 b8 00 84 00 00       mov    $0x8400,%r8d
    0.00 :	    1fb7:       41 ba 00 83 00 00       mov    $0x8300,%r10d
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPRC(i),             \
    0.00 :	    1fbd:       48 bd 00 00 00 00 01    movabs $0x100000000,%rbp
    0.00 :	    1fc4:       00 00 00 
    0.00 :	    1fc7:       49 bb 00 00 00 00 ff    movabs $0xffffffff00000000,%r11
    0.00 :	    1fce:       ff ff ff 
         :	                                        adapter->vfinfo[i].last_vfstats.gprc, \
         :	                                        adapter->vfinfo[i].vfstats.gprc);
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPTC(i),             \
         :	                                        adapter->vfinfo[i].last_vfstats.gptc, \
         :	                                        adapter->vfinfo[i].vfstats.gptc);
         :	                        UPDATE_VF_COUNTER_36bit(IXGBE_PVFGORC_LSB(i),         \
    0.00 :	    1fd1:       49 bd 00 00 00 00 10    movabs $0x1000000000,%r13
    0.00 :	    1fd8:       00 00 00 
    0.00 :	    1fdb:       49 bc 00 00 00 00 f0    movabs $0xfffffff000000000,%r12
    0.00 :	    1fe2:       ff ff ff 
    0.00 :	    1fe5:       0f 1f 00                nopl   (%rax)
    0.00 :	    1fe8:       89 f8                   mov    %edi,%eax
    0.00 :	    1fea:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    1ff1:       8b 00                   mov    (%rax),%eax
         :	         * are not clear on read and otherwise you'll sometimes get
         :	         * crazy values.
         :	         */
         :	        if (!test_bit(__IXGBE_RESETTING, &adapter->state)) {
         :	                for (i = 0; i < adapter->num_vfs; i++) {
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPRC(i),             \
    0.00 :	    1ff3:       89 c2                   mov    %eax,%edx
    0.00 :	    1ff5:       44 89 c8                mov    %r9d,%eax
    0.00 :	    1ff8:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	    1ffc:       48 8d 04 c0             lea    (%rax,%rax,8),%rax
    0.00 :	    2000:       48 8d 0c c5 00 00 00    lea    0x0(,%rax,8),%rcx
    0.00 :	    2007:       00 
    0.00 :	    2008:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    200f:       48 01 c8                add    %rcx,%rax
    0.00 :	    2012:       48 3b 50 78             cmp    0x78(%rax),%rdx
    0.00 :	    2016:       73 0e                   jae    2026 <ixgbe_update_stats+0x826>
    0.00 :	    2018:       48 01 68 50             add    %rbp,0x50(%rax)
    0.00 :	    201c:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2023:       48 01 c8                add    %rcx,%rax
    0.00 :	    2026:       48 89 50 78             mov    %rdx,0x78(%rax)
    0.00 :	    202a:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2031:       48 01 c8                add    %rcx,%rax
    0.00 :	    2034:       4c 21 58 50             and    %r11,0x50(%rax)
    0.00 :	    2038:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    203f:       48 01 c8                add    %rcx,%rax
    0.00 :	    2042:       48 09 50 50             or     %rdx,0x50(%rax)
    0.00 :	    2046:       44 89 d0                mov    %r10d,%eax
    0.00 :	    2049:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    2050:       8b 00                   mov    (%rax),%eax
         :	                                        adapter->vfinfo[i].last_vfstats.gprc, \
         :	                                        adapter->vfinfo[i].vfstats.gprc);
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPTC(i),             \
    0.00 :	    2052:       89 c2                   mov    %eax,%edx
    0.00 :	    2054:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    205b:       48 01 c8                add    %rcx,%rax
    0.00 :	    205e:       48 3b 90 88 00 00 00    cmp    0x88(%rax),%rdx
    0.00 :	    2065:       73 0e                   jae    2075 <ixgbe_update_stats+0x875>
    0.00 :	    2067:       48 01 68 60             add    %rbp,0x60(%rax)
    0.00 :	    206b:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2072:       48 01 c8                add    %rcx,%rax
    0.00 :	    2075:       48 89 90 88 00 00 00    mov    %rdx,0x88(%rax)
    0.00 :	    207c:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2083:       48 01 c8                add    %rcx,%rax
    0.00 :	    2086:       4c 21 58 60             and    %r11,0x60(%rax)
    0.00 :	    208a:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2091:       48 01 c8                add    %rcx,%rax
    0.00 :	    2094:       48 09 50 60             or     %rdx,0x60(%rax)
    0.00 :	    2098:       8d 47 04                lea    0x4(%rdi),%eax
    0.00 :	    209b:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    20a2:       8b 10                   mov    (%rax),%edx
    0.00 :	    20a4:       8d 87 04 c0 00 00       lea    0xc004(%rdi),%eax
    0.00 :	    20aa:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    20b1:       8b 00                   mov    (%rax),%eax
         :	                                        adapter->vfinfo[i].last_vfstats.gptc, \
         :	                                        adapter->vfinfo[i].vfstats.gptc);
         :	                        UPDATE_VF_COUNTER_36bit(IXGBE_PVFGORC_LSB(i),         \
    0.00 :	    20b3:       48 89 c6                mov    %rax,%rsi
    0.00 :	    20b6:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    20bd:       89 d2                   mov    %edx,%edx
    0.00 :	    20bf:       48 c1 e6 20             shl    $0x20,%rsi
    0.00 :	    20c3:       48 09 d6                or     %rdx,%rsi
    0.00 :	    20c6:       48 01 c8                add    %rcx,%rax
    0.00 :	    20c9:       48 3b b0 80 00 00 00    cmp    0x80(%rax),%rsi
    0.00 :	    20d0:       73 0e                   jae    20e0 <ixgbe_update_stats+0x8e0>
    0.00 :	    20d2:       4c 01 68 58             add    %r13,0x58(%rax)
    0.00 :	    20d6:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    20dd:       48 01 c8                add    %rcx,%rax
    0.00 :	    20e0:       48 89 b0 80 00 00 00    mov    %rsi,0x80(%rax)
    0.00 :	    20e7:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    20ee:       48 01 c8                add    %rcx,%rax
    0.00 :	    20f1:       4c 21 60 58             and    %r12,0x58(%rax)
    0.00 :	    20f5:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    20fc:       48 01 c8                add    %rcx,%rax
    0.00 :	    20ff:       48 09 70 58             or     %rsi,0x58(%rax)
    0.00 :	    2103:       44 89 c0                mov    %r8d,%eax
    0.00 :	    2106:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    210d:       8b 10                   mov    (%rax),%edx
    0.00 :	    210f:       41 8d 40 04             lea    0x4(%r8),%eax
    0.00 :	    2113:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    211a:       8b 00                   mov    (%rax),%eax
         :	                                        IXGBE_PVFGORC_MSB(i),                 \
         :	                                        adapter->vfinfo[i].last_vfstats.gorc, \
         :	                                        adapter->vfinfo[i].vfstats.gorc);
         :	                        UPDATE_VF_COUNTER_36bit(IXGBE_PVFGOTC_LSB(i),         \
    0.00 :	    211c:       48 89 c6                mov    %rax,%rsi
    0.00 :	    211f:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2126:       89 d2                   mov    %edx,%edx
    0.00 :	    2128:       48 c1 e6 20             shl    $0x20,%rsi
    0.00 :	    212c:       48 09 d6                or     %rdx,%rsi
    0.00 :	    212f:       48 01 c8                add    %rcx,%rax
    0.00 :	    2132:       48 3b b0 90 00 00 00    cmp    0x90(%rax),%rsi
    0.00 :	    2139:       73 0e                   jae    2149 <ixgbe_update_stats+0x949>
    0.00 :	    213b:       4c 01 68 68             add    %r13,0x68(%rax)
    0.00 :	    213f:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2146:       48 01 c8                add    %rcx,%rax
    0.00 :	    2149:       48 89 b0 90 00 00 00    mov    %rsi,0x90(%rax)
    0.00 :	    2150:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2157:       48 01 c8                add    %rcx,%rax
    0.00 :	    215a:       4c 21 60 68             and    %r12,0x68(%rax)
    0.00 :	    215e:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2165:       48 01 c8                add    %rcx,%rax
    0.00 :	    2168:       48 09 70 68             or     %rsi,0x68(%rax)
    0.00 :	    216c:       8d 87 00 c0 00 00       lea    0xc000(%rdi),%eax
    0.00 :	    2172:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    2179:       8b 00                   mov    (%rax),%eax
         :	                                        IXGBE_PVFGOTC_MSB(i),                 \
         :	                                        adapter->vfinfo[i].last_vfstats.gotc, \
         :	                                        adapter->vfinfo[i].vfstats.gotc);
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),             \
    0.00 :	    217b:       89 c2                   mov    %eax,%edx
    0.00 :	    217d:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    2184:       48 01 c8                add    %rcx,%rax
    0.00 :	    2187:       48 3b 90 98 00 00 00    cmp    0x98(%rax),%rdx
    0.00 :	    218e:       73 0e                   jae    219e <ixgbe_update_stats+0x99e>
    0.00 :	    2190:       48 01 68 70             add    %rbp,0x70(%rax)
    0.00 :	    2194:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
    0.00 :	    219b:       48 01 c8                add    %rcx,%rax
    0.00 :	    219e:       48 89 90 98 00 00 00    mov    %rdx,0x98(%rax)
    0.00 :	    21a5:       48 8b 83 60 7c 00 00    mov    0x7c60(%rbx),%rax
         :	         * VF Stats Collection - skip while resetting because these
         :	         * are not clear on read and otherwise you'll sometimes get
         :	         * crazy values.
         :	         */
         :	        if (!test_bit(__IXGBE_RESETTING, &adapter->state)) {
         :	                for (i = 0; i < adapter->num_vfs; i++) {
    0.00 :	    21ac:       41 83 c1 01             add    $0x1,%r9d
    0.00 :	    21b0:       83 c7 40                add    $0x40,%edi
    0.00 :	    21b3:       41 83 c0 08             add    $0x8,%r8d
    0.00 :	    21b7:       41 83 c2 04             add    $0x4,%r10d
         :	                                        adapter->vfinfo[i].vfstats.gorc);
         :	                        UPDATE_VF_COUNTER_36bit(IXGBE_PVFGOTC_LSB(i),         \
         :	                                        IXGBE_PVFGOTC_MSB(i),                 \
         :	                                        adapter->vfinfo[i].last_vfstats.gotc, \
         :	                                        adapter->vfinfo[i].vfstats.gotc);
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),             \
    0.00 :	    21bb:       48 01 c8                add    %rcx,%rax
    0.00 :	    21be:       4c 21 58 70             and    %r11,0x70(%rax)
    0.00 :	    21c2:       48 89 c8                mov    %rcx,%rax
    0.00 :	    21c5:       48 03 83 60 7c 00 00    add    0x7c60(%rbx),%rax
    0.00 :	    21cc:       48 09 50 70             or     %rdx,0x70(%rax)
         :	         * VF Stats Collection - skip while resetting because these
         :	         * are not clear on read and otherwise you'll sometimes get
         :	         * crazy values.
         :	         */
         :	        if (!test_bit(__IXGBE_RESETTING, &adapter->state)) {
         :	                for (i = 0; i < adapter->num_vfs; i++) {
    0.00 :	    21d0:       44 39 8b 58 7c 00 00    cmp    %r9d,0x7c58(%rbx)
    0.00 :	    21d7:       0f 87 0b fe ff ff       ja     1fe8 <ixgbe_update_stats+0x7e8>
    0.00 :	    21dd:       0f 1f 00                nopl   (%rax)
         :	                        UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),             \
         :	                                        adapter->vfinfo[i].last_vfstats.mprc, \
         :	                                        adapter->vfinfo[i].vfstats.mprc);
         :	                }
         :	        }
         :	}
    0.00 :	    21e0:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	    21e4:       5b                      pop    %rbx
    0.00 :	    21e5:       5d                      pop    %rbp
    0.00 :	    21e6:       41 5c                   pop    %r12
    0.00 :	    21e8:       41 5d                   pop    %r13
    0.00 :	    21ea:       41 5e                   pop    %r14
    0.00 :	    21ec:       41 5f                   pop    %r15
    0.00 :	    21ee:       c3                      retq   
         :	                return;
         :
         :	        if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
         :	                u64 rsc_count = 0;
         :	                u64 rsc_flush = 0;
         :	                for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    21ef:       44 8b 9f 28 02 00 00    mov    0x228(%rdi),%r11d
    0.00 :	    21f6:       31 f6                   xor    %esi,%esi
    0.00 :	    21f8:       31 c9                   xor    %ecx,%ecx
    0.00 :	    21fa:       45 85 db                test   %r11d,%r11d
    0.00 :	    21fd:       74 32                   je     2231 <ixgbe_update_stats+0xa31>
    0.00 :	    21ff:       41 8d 43 ff             lea    -0x1(%r11),%eax
    0.00 :	    2203:       31 f6                   xor    %esi,%esi
    0.00 :	    2205:       31 c9                   xor    %ecx,%ecx
    0.00 :	    2207:       31 d2                   xor    %edx,%edx
    0.00 :	    2209:       48 8d 3c c5 08 00 00    lea    0x8(,%rax,8),%rdi
    0.00 :	    2210:       00 
    0.00 :	    2211:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        rsc_count += adapter->rx_ring[i]->rx_stats.rsc_count;
    0.00 :	    2218:       48 8b 84 13 d8 04 00    mov    0x4d8(%rbx,%rdx,1),%rax
    0.00 :	    221f:       00 
         :	                        rsc_flush += adapter->rx_ring[i]->rx_stats.rsc_flush;
    0.00 :	    2220:       48 83 c2 08             add    $0x8,%rdx
         :
         :	        if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
         :	                u64 rsc_count = 0;
         :	                u64 rsc_flush = 0;
         :	                for (i = 0; i < adapter->num_rx_queues; i++) {
         :	                        rsc_count += adapter->rx_ring[i]->rx_stats.rsc_count;
    0.00 :	    2224:       48 03 70 68             add    0x68(%rax),%rsi
         :	                        rsc_flush += adapter->rx_ring[i]->rx_stats.rsc_flush;
    0.00 :	    2228:       48 03 48 70             add    0x70(%rax),%rcx
         :	                return;
         :
         :	        if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
         :	                u64 rsc_count = 0;
         :	                u64 rsc_flush = 0;
         :	                for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    222c:       48 39 fa                cmp    %rdi,%rdx
    0.00 :	    222f:       75 e7                   jne    2218 <ixgbe_update_stats+0xa18>
         :	                        rsc_count += adapter->rx_ring[i]->rx_stats.rsc_count;
         :	                        rsc_flush += adapter->rx_ring[i]->rx_stats.rsc_flush;
         :	                }
         :	                adapter->rsc_total_count = rsc_count;
    0.00 :	    2231:       48 89 b3 30 07 00 00    mov    %rsi,0x730(%rbx)
         :	                adapter->rsc_total_flush = rsc_flush;
    0.00 :	    2238:       48 89 8b 38 07 00 00    mov    %rcx,0x738(%rbx)
    0.00 :	    223f:       e9 06 f6 ff ff          jmpq   184a <ixgbe_update_stats+0x4a>
    0.00 :	    2244:       0f 1f 40 00             nopl   0x0(%rax)
         :	        net_stats->tx_packets = packets;
         :
         :	        hwstats->crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
         :
         :	        /* 8 register reads */
         :	        for (i = 0; i < 8; i++) {
    0.00 :	    2248:       66 be 30 60             mov    $0x6030,%si
    0.00 :	    224c:       b9 00 87 00 00          mov    $0x8700,%ecx
    0.00 :	    2251:       eb 1a                   jmp    226d <ixgbe_update_stats+0xa6d>
    0.00 :	    2253:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	    2258:       48 83 c6 40             add    $0x40,%rsi
    0.00 :	    225c:       48 83 c1 08             add    $0x8,%rcx
         :	                        break;
         :	                }
         :	        }
         :
         :	        /*16 register reads */
         :	        for (i = 0; i < 16; i++) {
    0.00 :	    2260:       48 81 fe 30 64 00 00    cmp    $0x6430,%rsi
    0.00 :	    2267:       0f 84 c3 00 00 00       je     2330 <ixgbe_update_stats+0xb30>
    0.00 :	    226d:       48 89 f0                mov    %rsi,%rax
         :	                hwstats->qptc[i] += IXGBE_READ_REG(hw, IXGBE_QPTC(i));
    0.00 :	    2270:       48 8b 94 0b 08 91 ff    mov    -0x6ef8(%rbx,%rcx,1),%rdx
    0.00 :	    2277:       ff 
    0.00 :	    2278:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    227f:       8b 00                   mov    (%rax),%eax
    0.00 :	    2281:       89 c0                   mov    %eax,%eax
    0.00 :	    2283:       48 01 d0                add    %rdx,%rax
         :	                hwstats->qprc[i] += IXGBE_READ_REG(hw, IXGBE_QPRC(i));
    0.00 :	    2286:       48 8b 94 0b 88 90 ff    mov    -0x6f78(%rbx,%rcx,1),%rdx
    0.00 :	    228d:       ff 
         :	                }
         :	        }
         :
         :	        /*16 register reads */
         :	        for (i = 0; i < 16; i++) {
         :	                hwstats->qptc[i] += IXGBE_READ_REG(hw, IXGBE_QPTC(i));
    0.00 :	    228e:       48 89 84 0b 08 91 ff    mov    %rax,-0x6ef8(%rbx,%rcx,1)
    0.00 :	    2295:       ff 
    0.00 :	    2296:       48 8d 86 00 b0 ff ff    lea    -0x5000(%rsi),%rax
    0.00 :	    229d:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    22a4:       8b 00                   mov    (%rax),%eax
         :	                hwstats->qprc[i] += IXGBE_READ_REG(hw, IXGBE_QPRC(i));
    0.00 :	    22a6:       89 c0                   mov    %eax,%eax
    0.00 :	    22a8:       48 01 d0                add    %rdx,%rax
    0.00 :	    22ab:       48 89 84 0b 88 90 ff    mov    %rax,-0x6f78(%rbx,%rcx,1)
    0.00 :	    22b2:       ff 
         :	                if ((hw->mac.type == ixgbe_mac_82599EB) ||
    0.00 :	    22b3:       8b 83 50 10 00 00       mov    0x1050(%rbx),%eax
    0.00 :	    22b9:       83 e8 02                sub    $0x2,%eax
    0.00 :	    22bc:       83 f8 01                cmp    $0x1,%eax
    0.00 :	    22bf:       77 97                   ja     2258 <ixgbe_update_stats+0xa58>
    0.00 :	    22c1:       48 89 c8                mov    %rcx,%rax
         :	                    (hw->mac.type == ixgbe_mac_X540)) {
         :	                        hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC_L(i));
    0.00 :	    22c4:       48 8b 94 0b 08 92 ff    mov    -0x6df8(%rbx,%rcx,1),%rdx
    0.00 :	    22cb:       ff 
    0.00 :	    22cc:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    22d3:       8b 00                   mov    (%rax),%eax
    0.00 :	    22d5:       89 c0                   mov    %eax,%eax
    0.00 :	    22d7:       48 01 d0                add    %rdx,%rax
    0.00 :	    22da:       48 89 84 0b 08 92 ff    mov    %rax,-0x6df8(%rbx,%rcx,1)
    0.00 :	    22e1:       ff 
    0.00 :	    22e2:       48 8d 41 04             lea    0x4(%rcx),%rax
    0.00 :	    22e6:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    22ed:       8b 00                   mov    (%rax),%eax
 ??:0
   50.00 :	    22ef:       48 8d 86 04 b0 ff ff    lea    -0x4ffc(%rsi),%rax
         :	                        IXGBE_READ_REG(hw, IXGBE_QBTC_H(i)); /* to clear */
         :	                        hwstats->qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC_L(i));
    0.00 :	    22f6:       48 8b 94 0b 88 91 ff    mov    -0x6e78(%rbx,%rcx,1),%rdx
    0.00 :	    22fd:       ff 
    0.00 :	    22fe:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    2305:       8b 00                   mov    (%rax),%eax
    0.00 :	    2307:       89 c0                   mov    %eax,%eax
    0.00 :	    2309:       48 01 d0                add    %rdx,%rax
    0.00 :	    230c:       48 89 84 0b 88 91 ff    mov    %rax,-0x6e78(%rbx,%rcx,1)
    0.00 :	    2313:       ff 
    0.00 :	    2314:       48 8d 86 08 b0 ff ff    lea    -0x4ff8(%rsi),%rax
    0.00 :	    231b:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    2322:       8b 00                   mov    (%rax),%eax
   50.00 :	    2324:       e9 2f ff ff ff          jmpq   2258 <ixgbe_update_stats+0xa58>
    0.00 :	    2329:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    2330:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                        IXGBE_READ_REG(hw, IXGBE_QBRC_H(i)); /* to clear */
         :	                }
         :	        }
         :
         :	        hwstats->gprc += IXGBE_READ_REG(hw, IXGBE_GPRC);
    0.00 :	    2337:       48 8b 8b 80 16 00 00    mov    0x1680(%rbx),%rcx
    0.00 :	    233e:       48 05 74 40 00 00       add    $0x4074,%rax
    0.00 :	    2344:       8b 00                   mov    (%rax),%eax
         :	        /* work around hardware counting issue */
         :	        hwstats->gprc -= missed_rx;
    0.00 :	    2346:       44 89 ca                mov    %r9d,%edx
    0.00 :	    2349:       89 c0                   mov    %eax,%eax
    0.00 :	    234b:       48 29 d1                sub    %rdx,%rcx
         :	{
         :	        struct ixgbe_hw *hw = &adapter->hw;
         :	        struct ixgbe_hw_stats *hwstats = &adapter->stats;
         :	        u32 xoff[8] = {0};
         :	        int i;
         :	        bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
    0.00 :	    234e:       0f b6 93 7a 0a 00 00    movzbl 0xa7a(%rbx),%edx
         :	                }
         :	        }
         :
         :	        hwstats->gprc += IXGBE_READ_REG(hw, IXGBE_GPRC);
         :	        /* work around hardware counting issue */
         :	        hwstats->gprc -= missed_rx;
    0.00 :	    2355:       48 01 c1                add    %rax,%rcx
         :	        u32 xoff[8] = {0};
         :	        int i;
         :	        bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
         :
         :	#ifdef HAVE_DCBNL_IEEE
         :	        if (adapter->ixgbe_ieee_pfc)
    0.00 :	    2358:       48 8b 83 50 09 00 00    mov    0x950(%rbx),%rax
         :	                }
         :	        }
         :
         :	        hwstats->gprc += IXGBE_READ_REG(hw, IXGBE_GPRC);
         :	        /* work around hardware counting issue */
         :	        hwstats->gprc -= missed_rx;
    0.00 :	    235f:       48 89 8b 80 16 00 00    mov    %rcx,0x1680(%rbx)
         :	        u32 xoff[8] = {0};
         :	        int i;
         :	        bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
         :
         :	#ifdef HAVE_DCBNL_IEEE
         :	        if (adapter->ixgbe_ieee_pfc)
    0.00 :	    2366:       48 85 c0                test   %rax,%rax
    0.00 :	    2369:       74 12                   je     237d <ixgbe_update_stats+0xb7d>
         :	                pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
    0.00 :	    236b:       80 78 01 00             cmpb   $0x0,0x1(%rax)
    0.00 :	    236f:       0f b6 d2                movzbl %dl,%edx
    0.00 :	    2372:       0f 95 c0                setne  %al
    0.00 :	    2375:       0f b6 c0                movzbl %al,%eax
    0.00 :	    2378:       09 d0                   or     %edx,%eax
    0.00 :	    237a:       0f 95 c2                setne  %dl
         :
         :	#endif
         :	        if (!(adapter->flags & IXGBE_FLAG_DCB_ENABLED) || !pfc_en) {
    0.00 :	    237d:       f6 83 19 02 00 00 04    testb  $0x4,0x219(%rbx)
    0.00 :	    2384:       0f 84 8e f7 ff ff       je     1b18 <ixgbe_update_stats+0x318>
    0.00 :	    238a:       84 d2                   test   %dl,%dl
    0.00 :	    238c:       0f 84 86 f7 ff ff       je     1b18 <ixgbe_update_stats+0x318>
         :
         :	static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter)
         :	{
         :	        struct ixgbe_hw *hw = &adapter->hw;
         :	        struct ixgbe_hw_stats *hwstats = &adapter->stats;
         :	        u32 xoff[8] = {0};
    0.00 :	    2392:       48 c7 04 24 00 00 00    movq   $0x0,(%rsp)
    0.00 :	    2399:       00 
    0.00 :	    239a:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
    0.00 :	    23a1:       00 00 
    0.00 :	    23a3:       31 c9                   xor    %ecx,%ecx
    0.00 :	    23a5:       48 c7 44 24 10 00 00    movq   $0x0,0x10(%rsp)
    0.00 :	    23ac:       00 00 
    0.00 :	    23ae:       48 c7 44 24 18 00 00    movq   $0x0,0x18(%rsp)
    0.00 :	    23b5:       00 00 
    0.00 :	    23b7:       ba 20 cf 00 00          mov    $0xcf20,%edx
    0.00 :	    23bc:       48 89 e6                mov    %rsp,%rsi
    0.00 :	    23bf:       eb 52                   jmp    2413 <ixgbe_update_stats+0xc13>
    0.00 :	    23c1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    23c8:       48 8d 82 40 72 ff ff    lea    -0x8dc0(%rdx),%rax
    0.00 :	    23cf:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    23d6:       8b 00                   mov    (%rax),%eax
         :	                switch (hw->mac.type) {
         :	                case ixgbe_mac_82598EB:
         :	                        xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
         :	                        break;
         :	                default:
         :	                        xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));
    0.00 :	    23d8:       89 84 16 e0 30 ff ff    mov    %eax,-0xcf20(%rsi,%rdx,1)
         :	                }
         :	                hwstats->pxoffrxc[i] += xoff[i];
    0.00 :	    23df:       8b 84 16 e0 30 ff ff    mov    -0xcf20(%rsi,%rdx,1),%eax
         :	                ixgbe_update_xoff_rx_lfc(adapter);
         :	                return;
         :	        }
         :
         :	        /* update stats for each tc, only valid with PFC enabled */
         :	        for (i = 0; i < MAX_TX_PACKET_BUFFERS; i++) {
    0.00 :	    23e6:       83 c1 01                add    $0x1,%ecx
         :	                        xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
         :	                        break;
         :	                default:
         :	                        xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));
         :	                }
         :	                hwstats->pxoffrxc[i] += xoff[i];
    0.00 :	    23e9:       48 01 84 53 d0 77 fe    add    %rax,-0x18830(%rbx,%rdx,2)
    0.00 :	    23f0:       ff 
         :	                ixgbe_update_xoff_rx_lfc(adapter);
         :	                return;
         :	        }
         :
         :	        /* update stats for each tc, only valid with PFC enabled */
         :	        for (i = 0; i < MAX_TX_PACKET_BUFFERS; i++) {
    0.00 :	    23f1:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    23f7:       25 00 04 00 00          and    $0x400,%eax
    0.00 :	    23fc:       83 f8 01                cmp    $0x1,%eax
    0.00 :	    23ff:       19 c0                   sbb    %eax,%eax
    0.00 :	    2401:       48 83 c2 04             add    $0x4,%rdx
    0.00 :	    2405:       83 e0 f9                and    $0xfffffff9,%eax
    0.00 :	    2408:       83 c0 08                add    $0x8,%eax
    0.00 :	    240b:       39 c8                   cmp    %ecx,%eax
    0.00 :	    240d:       0f 8e a0 03 00 00       jle    27b3 <ixgbe_update_stats+0xfb3>
         :	                switch (hw->mac.type) {
    0.00 :	    2413:       83 bb 50 10 00 00 01    cmpl   $0x1,0x1050(%rbx)
    0.00 :	    241a:       75 ac                   jne    23c8 <ixgbe_update_stats+0xbc8>
    0.00 :	    241c:       48 89 d0                mov    %rdx,%rax
    0.00 :	    241f:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    2426:       8b 00                   mov    (%rax),%eax
         :	                case ixgbe_mac_82598EB:
         :	                        xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
    0.00 :	    2428:       89 84 16 e0 30 ff ff    mov    %eax,-0xcf20(%rsi,%rdx,1)
    0.00 :	    242f:       eb ae                   jmp    23df <ixgbe_update_stats+0xbdf>
    0.00 :	    2431:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORH);
         :	                break;
         :	        case ixgbe_mac_X540:
         :	                /* OS2BMC stats are X540 only*/
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
    0.00 :	    2438:       48 8b 93 e0 1a 00 00    mov    0x1ae0(%rbx),%rdx
    0.00 :	    243f:       48 05 c4 41 00 00       add    $0x41c4,%rax
    0.00 :	    2445:       8b 00                   mov    (%rax),%eax
    0.00 :	    2447:       89 c0                   mov    %eax,%eax
    0.00 :	    2449:       48 01 d0                add    %rdx,%rax
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
    0.00 :	    244c:       48 8b 93 e8 1a 00 00    mov    0x1ae8(%rbx),%rdx
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORH);
         :	                break;
         :	        case ixgbe_mac_X540:
         :	                /* OS2BMC stats are X540 only*/
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
    0.00 :	    2453:       48 89 83 e0 1a 00 00    mov    %rax,0x1ae0(%rbx)
    0.00 :	    245a:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2461:       48 05 b0 87 00 00       add    $0x87b0,%rax
    0.00 :	    2467:       8b 00                   mov    (%rax),%eax
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
    0.00 :	    2469:       89 c0                   mov    %eax,%eax
    0.00 :	    246b:       48 01 d0                add    %rdx,%rax
         :	                hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
    0.00 :	    246e:       48 8b 93 d0 1a 00 00    mov    0x1ad0(%rbx),%rdx
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORH);
         :	                break;
         :	        case ixgbe_mac_X540:
         :	                /* OS2BMC stats are X540 only*/
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
    0.00 :	    2475:       48 89 83 e8 1a 00 00    mov    %rax,0x1ae8(%rbx)
    0.00 :	    247c:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2483:       48 05 c0 41 00 00       add    $0x41c0,%rax
    0.00 :	    2489:       8b 00                   mov    (%rax),%eax
         :	                hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
    0.00 :	    248b:       89 c0                   mov    %eax,%eax
    0.00 :	    248d:       48 01 d0                add    %rdx,%rax
         :	                hwstats->b2ogprc += IXGBE_READ_REG(hw, IXGBE_B2OGPRC);
    0.00 :	    2490:       48 8b 93 d8 1a 00 00    mov    0x1ad8(%rbx),%rdx
         :	                break;
         :	        case ixgbe_mac_X540:
         :	                /* OS2BMC stats are X540 only*/
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
         :	                hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
    0.00 :	    2497:       48 89 83 d0 1a 00 00    mov    %rax,0x1ad0(%rbx)
    0.00 :	    249e:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    24a5:       48 05 90 2f 00 00       add    $0x2f90,%rax
    0.00 :	    24ab:       8b 00                   mov    (%rax),%eax
         :	                hwstats->b2ogprc += IXGBE_READ_REG(hw, IXGBE_B2OGPRC);
    0.00 :	    24ad:       89 c0                   mov    %eax,%eax
    0.00 :	    24af:       48 01 d0                add    %rdx,%rax
    0.00 :	    24b2:       48 89 83 d8 1a 00 00    mov    %rax,0x1ad8(%rbx)
    0.00 :	    24b9:       b9 30 14 00 00          mov    $0x1430,%ecx
    0.00 :	    24be:       66 90                   xchg   %ax,%ax
    0.00 :	    24c0:       48 89 c8                mov    %rcx,%rax
         :	        case ixgbe_mac_82599EB:
         :	                for (i = 0; i < 16; i++)
         :	                        adapter->hw_rx_no_dma_resources +=
    0.00 :	    24c3:       48 8b 93 28 07 00 00    mov    0x728(%rbx),%rdx
    0.00 :	    24ca:       48 03 83 80 0e 00 00    add    0xe80(%rbx),%rax
    0.00 :	    24d1:       8b 00                   mov    (%rax),%eax
    0.00 :	    24d3:       89 c0                   mov    %eax,%eax
    0.00 :	    24d5:       48 83 c1 40             add    $0x40,%rcx
    0.00 :	    24d9:       48 01 d0                add    %rdx,%rax
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
         :	                hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
         :	                hwstats->b2ogprc += IXGBE_READ_REG(hw, IXGBE_B2OGPRC);
         :	        case ixgbe_mac_82599EB:
         :	                for (i = 0; i < 16; i++)
    0.00 :	    24dc:       48 81 f9 30 18 00 00    cmp    $0x1830,%rcx
         :	                        adapter->hw_rx_no_dma_resources +=
    0.00 :	    24e3:       48 89 83 28 07 00 00    mov    %rax,0x728(%rbx)
         :	                hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
         :	                hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
         :	                hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
         :	                hwstats->b2ogprc += IXGBE_READ_REG(hw, IXGBE_B2OGPRC);
         :	        case ixgbe_mac_82599EB:
         :	                for (i = 0; i < 16; i++)
    0.00 :	    24ea:       75 d4                   jne    24c0 <ixgbe_update_stats+0xcc0>
    0.00 :	    24ec:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                        adapter->hw_rx_no_dma_resources +=
         :	                                             IXGBE_READ_REG(hw, IXGBE_QPRDC(i));
         :	                hwstats->gorc += IXGBE_READ_REG(hw, IXGBE_GORCL);
    0.00 :	    24f3:       48 8b 93 a0 16 00 00    mov    0x16a0(%rbx),%rdx
    0.00 :	    24fa:       48 05 88 40 00 00       add    $0x4088,%rax
    0.00 :	    2500:       8b 00                   mov    (%rax),%eax
    0.00 :	    2502:       89 c0                   mov    %eax,%eax
    0.00 :	    2504:       48 01 d0                add    %rdx,%rax
    0.00 :	    2507:       48 89 83 a0 16 00 00    mov    %rax,0x16a0(%rbx)
    0.00 :	    250e:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2515:       48 05 8c 40 00 00       add    $0x408c,%rax
    0.00 :	    251b:       8b 00                   mov    (%rax),%eax
    0.00 :	    251d:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                IXGBE_READ_REG(hw, IXGBE_GORCH); /* to clear */
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCL);
    0.00 :	    2524:       48 8b 93 a8 16 00 00    mov    0x16a8(%rbx),%rdx
    0.00 :	    252b:       48 05 90 40 00 00       add    $0x4090,%rax
    0.00 :	    2531:       8b 00                   mov    (%rax),%eax
    0.00 :	    2533:       89 c0                   mov    %eax,%eax
    0.00 :	    2535:       48 01 d0                add    %rdx,%rax
    0.00 :	    2538:       48 89 83 a8 16 00 00    mov    %rax,0x16a8(%rbx)
    0.00 :	    253f:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2546:       48 05 94 40 00 00       add    $0x4094,%rax
    0.00 :	    254c:       8b 00                   mov    (%rax),%eax
    0.00 :	    254e:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                IXGBE_READ_REG(hw, IXGBE_GOTCH); /* to clear */
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORL);
    0.00 :	    2555:       48 8b 93 28 17 00 00    mov    0x1728(%rbx),%rdx
    0.00 :	    255c:       48 05 c0 40 00 00       add    $0x40c0,%rax
    0.00 :	    2562:       8b 00                   mov    (%rax),%eax
    0.00 :	    2564:       89 c0                   mov    %eax,%eax
    0.00 :	    2566:       48 01 d0                add    %rdx,%rax
    0.00 :	    2569:       48 89 83 28 17 00 00    mov    %rax,0x1728(%rbx)
    0.00 :	    2570:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2577:       48 05 c4 40 00 00       add    $0x40c4,%rax
    0.00 :	    257d:       8b 00                   mov    (%rax),%eax
    0.00 :	    257f:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
         :	                IXGBE_READ_REG(hw, IXGBE_TORH); /* to clear */
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
    0.00 :	    2586:       48 8b 93 38 15 00 00    mov    0x1538(%rbx),%rdx
    0.00 :	    258d:       48 05 a4 41 00 00       add    $0x41a4,%rax
    0.00 :	    2593:       8b 00                   mov    (%rax),%eax
    0.00 :	    2595:       89 c0                   mov    %eax,%eax
    0.00 :	    2597:       48 01 d0                add    %rdx,%rax
         :	#ifdef HAVE_TX_MQ
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
    0.00 :	    259a:       48 8b 93 68 1a 00 00    mov    0x1a68(%rbx),%rdx
         :	                IXGBE_READ_REG(hw, IXGBE_GORCH); /* to clear */
         :	                hwstats->gotc += IXGBE_READ_REG(hw, IXGBE_GOTCL);
         :	                IXGBE_READ_REG(hw, IXGBE_GOTCH); /* to clear */
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORL);
         :	                IXGBE_READ_REG(hw, IXGBE_TORH); /* to clear */
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
    0.00 :	    25a1:       48 89 83 38 15 00 00    mov    %rax,0x1538(%rbx)
    0.00 :	    25a8:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    25af:       48 05 58 ee 00 00       add    $0xee58,%rax
    0.00 :	    25b5:       8b 00                   mov    (%rax),%eax
         :	#ifdef HAVE_TX_MQ
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
    0.00 :	    25b7:       89 c0                   mov    %eax,%eax
    0.00 :	    25b9:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
    0.00 :	    25bc:       48 8b 93 70 1a 00 00    mov    0x1a70(%rbx),%rdx
         :	                IXGBE_READ_REG(hw, IXGBE_GOTCH); /* to clear */
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORL);
         :	                IXGBE_READ_REG(hw, IXGBE_TORH); /* to clear */
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
         :	#ifdef HAVE_TX_MQ
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
    0.00 :	    25c3:       48 89 83 68 1a 00 00    mov    %rax,0x1a68(%rbx)
    0.00 :	    25ca:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    25d1:       48 05 5c ee 00 00       add    $0xee5c,%rax
    0.00 :	    25d7:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
    0.00 :	    25d9:       89 c0                   mov    %eax,%eax
    0.00 :	    25db:       48 01 d0                add    %rdx,%rax
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
    0.00 :	    25de:       48 8b 93 78 1a 00 00    mov    0x1a78(%rbx),%rdx
         :	                hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORL);
         :	                IXGBE_READ_REG(hw, IXGBE_TORH); /* to clear */
         :	                hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
         :	#ifdef HAVE_TX_MQ
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
    0.00 :	    25e5:       48 89 83 70 1a 00 00    mov    %rax,0x1a70(%rbx)
    0.00 :	    25ec:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    25f3:       48 05 18 51 00 00       add    $0x5118,%rax
    0.00 :	    25f9:       8b 00                   mov    (%rax),%eax
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
    0.00 :	    25fb:       89 c0                   mov    %eax,%eax
    0.00 :	    25fd:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
    0.00 :	    2600:       48 8b 93 80 1a 00 00    mov    0x1a80(%rbx),%rdx
         :	#ifdef HAVE_TX_MQ
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
    0.00 :	    2607:       48 89 83 78 1a 00 00    mov    %rax,0x1a78(%rbx)
    0.00 :	    260e:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2615:       48 05 24 24 00 00       add    $0x2424,%rax
    0.00 :	    261b:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
    0.00 :	    261d:       89 c0                   mov    %eax,%eax
    0.00 :	    261f:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
    0.00 :	    2622:       48 8b 93 88 1a 00 00    mov    0x1a88(%rbx),%rdx
         :	                hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
    0.00 :	    2629:       48 89 83 80 1a 00 00    mov    %rax,0x1a80(%rbx)
    0.00 :	    2630:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2637:       48 05 1c 24 00 00       add    $0x241c,%rax
    0.00 :	    263d:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
    0.00 :	    263f:       89 c0                   mov    %eax,%eax
    0.00 :	    2641:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
    0.00 :	    2644:       48 8b 93 90 1a 00 00    mov    0x1a90(%rbx),%rdx
         :	                hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
    0.00 :	    264b:       48 89 83 88 1a 00 00    mov    %rax,0x1a88(%rbx)
    0.00 :	    2652:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2659:       48 05 28 24 00 00       add    $0x2428,%rax
    0.00 :	    265f:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
    0.00 :	    2661:       89 c0                   mov    %eax,%eax
    0.00 :	    2663:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
    0.00 :	    2666:       48 8b 93 98 1a 00 00    mov    0x1a98(%rbx),%rdx
         :	#endif /* HAVE_TX_MQ */
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
    0.00 :	    266d:       48 89 83 90 1a 00 00    mov    %rax,0x1a90(%rbx)
    0.00 :	    2674:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    267b:       48 05 84 87 00 00       add    $0x8784,%rax
    0.00 :	    2681:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
    0.00 :	    2683:       89 c0                   mov    %eax,%eax
    0.00 :	    2685:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
    0.00 :	    2688:       48 8b 93 a0 1a 00 00    mov    0x1aa0(%rbx),%rdx
         :	#ifdef IXGBE_FCOE
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
         :	                hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
    0.00 :	    268f:       48 89 83 98 1a 00 00    mov    %rax,0x1a98(%rbx)
    0.00 :	    2696:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    269d:       48 05 2c 24 00 00       add    $0x242c,%rax
    0.00 :	    26a3:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
    0.00 :	    26a5:       89 c0                   mov    %eax,%eax
    0.00 :	    26a7:       48 01 d0                add    %rdx,%rax
         :	                hwstats->fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
    0.00 :	    26aa:       48 8b 93 a8 1a 00 00    mov    0x1aa8(%rbx),%rdx
         :	                hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
         :	                hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
         :	                hwstats->fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
    0.00 :	    26b1:       48 89 83 a0 1a 00 00    mov    %rax,0x1aa0(%rbx)
    0.00 :	    26b8:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    26bf:       48 05 88 87 00 00       add    $0x8788,%rax
    0.00 :	    26c5:       8b 00                   mov    (%rax),%eax
         :	                hwstats->fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
    0.00 :	    26c7:       89 c0                   mov    %eax,%eax
    0.00 :	    26c9:       48 01 d0                add    %rdx,%rax
         :	                /* Add up per cpu counters for total ddp alloc fail */
         :	                if (adapter->fcoe.ddp_pool) {
    0.00 :	    26cc:       48 83 bb e8 1b 00 00    cmpq   $0x0,0x1be8(%rbx)
    0.00 :	    26d3:       00 
         :	                hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
         :	                hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
         :	                hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
         :	                hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
         :	                hwstats->fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
         :	                hwstats->fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
    0.00 :	    26d4:       48 89 83 a8 1a 00 00    mov    %rax,0x1aa8(%rbx)
         :	                /* Add up per cpu counters for total ddp alloc fail */
         :	                if (adapter->fcoe.ddp_pool) {
    0.00 :	    26db:       0f 84 f8 f4 ff ff       je     1bd9 <ixgbe_update_stats+0x3d9>
         :	static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
         :	{
         :	        /* -1 is a legal arg here. */
         :	        if (n != -1)
         :	                cpumask_check(n);
         :	        return find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
    0.00 :	    26e1:       4c 8b 2d 00 00 00 00    mov    0x0(%rip),%r13        # 26e8 <ixgbe_update_stats+0xee8>
    0.00 :	    26e8:       b9 ff ff ff ff          mov    $0xffffffff,%ecx
    0.00 :	    26ed:       45 31 e4                xor    %r12d,%r12d
    0.00 :	    26f0:       31 ed                   xor    %ebp,%ebp
    0.00 :	    26f2:       eb 1d                   jmp    2711 <ixgbe_update_stats+0xf11>
    0.00 :	    26f4:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        struct ixgbe_fcoe *fcoe = &adapter->fcoe;
         :	                        struct ixgbe_fcoe_ddp_pool *ddp_pool;
         :	                        unsigned int cpu;
         :	                        u64 noddp = 0, noddp_ext_buff = 0;
         :	                        for_each_possible_cpu(cpu) {
         :	                                ddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);
    0.00 :	    26f8:       89 ca                   mov    %ecx,%edx
    0.00 :	    26fa:       48 8b 83 e8 1b 00 00    mov    0x1be8(%rbx),%rax
    0.00 :	    2701:       48 03 04 d5 00 00 00    add    0x0(,%rdx,8),%rax
    0.00 :	    2708:       00 
         :	                                noddp += ddp_pool->noddp;
    0.00 :	    2709:       4c 03 60 08             add    0x8(%rax),%r12
         :	                                noddp_ext_buff += ddp_pool->noddp_ext_buff;
    0.00 :	    270d:       48 03 68 10             add    0x10(%rax),%rbp
    0.00 :	    2711:       48 63 35 00 00 00 00    movslq 0x0(%rip),%rsi        # 2718 <ixgbe_update_stats+0xf18>
    0.00 :	    2718:       8d 51 01                lea    0x1(%rcx),%edx
    0.00 :	    271b:       4c 89 ef                mov    %r13,%rdi
    0.00 :	    271e:       48 63 d2                movslq %edx,%rdx
    0.00 :	    2721:       e8 00 00 00 00          callq  2726 <ixgbe_update_stats+0xf26>
         :	                if (adapter->fcoe.ddp_pool) {
         :	                        struct ixgbe_fcoe *fcoe = &adapter->fcoe;
         :	                        struct ixgbe_fcoe_ddp_pool *ddp_pool;
         :	                        unsigned int cpu;
         :	                        u64 noddp = 0, noddp_ext_buff = 0;
         :	                        for_each_possible_cpu(cpu) {
    0.00 :	    2726:       39 05 00 00 00 00       cmp    %eax,0x0(%rip)        # 272c <ixgbe_update_stats+0xf2c>
    0.00 :	    272c:       89 c1                   mov    %eax,%ecx
    0.00 :	    272e:       77 c8                   ja     26f8 <ixgbe_update_stats+0xef8>
         :	                                ddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);
         :	                                noddp += ddp_pool->noddp;
         :	                                noddp_ext_buff += ddp_pool->noddp_ext_buff;
         :	                        }
         :	                        hwstats->fcoe_noddp = noddp;
    0.00 :	    2730:       4c 89 a3 b0 1a 00 00    mov    %r12,0x1ab0(%rbx)
         :	                        hwstats->fcoe_noddp_ext_buff = noddp_ext_buff;
    0.00 :	    2737:       48 89 ab b8 1a 00 00    mov    %rbp,0x1ab8(%rbx)
    0.00 :	    273e:       e9 96 f4 ff ff          jmpq   1bd9 <ixgbe_update_stats+0x3d9>
         :
         :	        if ((hw->fc.current_mode != ixgbe_fc_full) &&
         :	            (hw->fc.current_mode != ixgbe_fc_rx_pause))
         :	                return;
         :
         :	        switch (hw->mac.type) {
    0.00 :	    2743:       83 bb 50 10 00 00 01    cmpl   $0x1,0x1050(%rbx)
    0.00 :	    274a:       0f 84 ae 00 00 00       je     27fe <ixgbe_update_stats+0xffe>
    0.00 :	    2750:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2757:       48 05 a8 41 00 00       add    $0x41a8,%rax
    0.00 :	    275d:       8b 10                   mov    (%rax),%edx
         :	                data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXC);
         :	                break;
         :	        default:
         :	                data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);
         :	        }
         :	        hwstats->lxoffrxc += data;
    0.00 :	    275f:       89 d0                   mov    %edx,%eax
    0.00 :	    2761:       48 01 83 48 15 00 00    add    %rax,0x1548(%rbx)
         :
         :	        /* refill credits (no tx hang) if we received xoff */
         :	        if (!data)
    0.00 :	    2768:       85 d2                   test   %edx,%edx
    0.00 :	    276a:       0f 84 c0 f3 ff ff       je     1b30 <ixgbe_update_stats+0x330>
         :	                return;
         :
         :	        for (i = 0; i < adapter->num_tx_queues; i++)
    0.00 :	    2770:       8b 93 20 02 00 00       mov    0x220(%rbx),%edx
    0.00 :	    2776:       85 d2                   test   %edx,%edx
    0.00 :	    2778:       0f 8e b2 f3 ff ff       jle    1b30 <ixgbe_update_stats+0x330>
    0.00 :	    277e:       31 c9                   xor    %ecx,%ecx
         :	 */
         :	static __always_inline void
         :	clear_bit(int nr, volatile unsigned long *addr)
         :	{
         :	        if (IS_IMMEDIATE(nr)) {
         :	                asm volatile(LOCK_PREFIX "andb %1,%0"
    0.00 :	    2780:       48 8b 97 80 02 00 00    mov    0x280(%rdi),%rdx
    0.00 :	    2787:       48 8d 42 30             lea    0x30(%rdx),%rax
    0.00 :	    278b:       f0 80 62 30 fb          lock andb $0xfb,0x30(%rdx)
    0.00 :	    2790:       83 c1 01                add    $0x1,%ecx
    0.00 :	    2793:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	    2797:       3b 8b 20 02 00 00       cmp    0x220(%rbx),%ecx
    0.00 :	    279d:       7c e1                   jl     2780 <ixgbe_update_stats+0xf80>
    0.00 :	    279f:       e9 8c f3 ff ff          jmpq   1b30 <ixgbe_update_stats+0x330>
         :	        }
         :	        bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
         :	        hwstats->bprc += bprc;
         :	        hwstats->mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
         :	        if (hw->mac.type == ixgbe_mac_82598EB)
         :	                hwstats->mprc -= bprc;
    0.00 :	    27a4:       48 29 c8                sub    %rcx,%rax
    0.00 :	    27a7:       48 89 83 90 16 00 00    mov    %rax,0x1690(%rbx)
    0.00 :	    27ae:       e9 6d f4 ff ff          jmpq   1c20 <ixgbe_update_stats+0x420>
         :	                }
         :	                hwstats->pxoffrxc[i] += xoff[i];
         :	        }
         :
         :	        /* disarm tx queues that have received xoff frames */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
    0.00 :	    27b3:       8b 83 20 02 00 00       mov    0x220(%rbx),%eax
    0.00 :	    27b9:       85 c0                   test   %eax,%eax
    0.00 :	    27bb:       0f 8e 6f f3 ff ff       jle    1b30 <ixgbe_update_stats+0x330>
    0.00 :	    27c1:       31 c9                   xor    %ecx,%ecx
    0.00 :	    27c3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
    0.00 :	    27c8:       48 8b 97 80 02 00 00    mov    0x280(%rdi),%rdx
         :	                u8 tc = tx_ring->dcb_tc;
    0.00 :	    27cf:       0f b6 42 56             movzbl 0x56(%rdx),%eax
         :
         :	                if ((tc <= 7) && (xoff[tc]))
    0.00 :	    27d3:       3c 07                   cmp    $0x7,%al
    0.00 :	    27d5:       77 13                   ja     27ea <ixgbe_update_stats+0xfea>
    0.00 :	    27d7:       0f b6 c0                movzbl %al,%eax
    0.00 :	    27da:       8b 04 84                mov    (%rsp,%rax,4),%eax
    0.00 :	    27dd:       85 c0                   test   %eax,%eax
    0.00 :	    27df:       74 09                   je     27ea <ixgbe_update_stats+0xfea>
    0.00 :	    27e1:       48 8d 42 30             lea    0x30(%rdx),%rax
    0.00 :	    27e5:       f0 80 62 30 fb          lock andb $0xfb,0x30(%rdx)
         :	                }
         :	                hwstats->pxoffrxc[i] += xoff[i];
         :	        }
         :
         :	        /* disarm tx queues that have received xoff frames */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
    0.00 :	    27ea:       83 c1 01                add    $0x1,%ecx
    0.00 :	    27ed:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	    27f1:       3b 8b 20 02 00 00       cmp    0x220(%rbx),%ecx
    0.00 :	    27f7:       7c cf                   jl     27c8 <ixgbe_update_stats+0xfc8>
    0.00 :	    27f9:       e9 32 f3 ff ff          jmpq   1b30 <ixgbe_update_stats+0x330>
    0.00 :	    27fe:       48 8b 83 80 0e 00 00    mov    0xe80(%rbx),%rax
    0.00 :	    2805:       48 05 68 cf 00 00       add    $0xcf68,%rax
    0.00 :	    280b:       8b 10                   mov    (%rax),%edx
    0.00 :	    280d:       e9 4d ff ff ff          jmpq   275f <ixgbe_update_stats+0xf5f>
         :	        }
         :	        adapter->lro_stats.flushed = flushed;
         :	        adapter->lro_stats.coal = coal;
         :
         :	#endif
         :	        for (i = 0; i < adapter->num_rx_queues; i++) {
    0.00 :	    2812:       45 31 d2                xor    %r10d,%r10d
    0.00 :	    2815:       45 31 c9                xor    %r9d,%r9d
    0.00 :	    2818:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    281b:       31 ff                   xor    %edi,%edi
    0.00 :	    281d:       31 d2                   xor    %edx,%edx
    0.00 :	    281f:       31 c0                   xor    %eax,%eax
    0.00 :	    2821:       e9 d8 f0 ff ff          jmpq   18fe <ixgbe_update_stats+0xfe>
         :	        net_stats->rx_packets = packets;
         :
         :	        bytes = 0;
         :	        packets = 0;
         :	        /* gather some stats to the adapter struct that are per queue */
         :	        for (i = 0; i < adapter->num_tx_queues; i++) {
    0.00 :	    2826:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    2829:       31 ff                   xor    %edi,%edi
    0.00 :	    282b:       31 f6                   xor    %esi,%esi
    0.00 :	    282d:       31 c9                   xor    %ecx,%ecx
    0.00 :	    282f:       e9 3d f1 ff ff          jmpq   1971 <ixgbe_update_stats+0x171>
         :
         :	Disassembly of section .devinit.text:
         :
         :	0000000000001800 <ixgbe_check_options+0x40e>:
         :	                        struct ixgbe_option opt = {
         :	                                .type = enable_option,
         :	                                .name = "Enabled/Disable FCoE offload",
         :	                                .err = "defaulting to Enabled",
         :	                                .def = OPTION_ENABLED
         :	                        };
    0.00 :	    1800:       48 c7 44 24 70 00 00    movq   $0x0,0x70(%rsp)
    0.00 :	    1807:       00 00 
    0.00 :	    1809:       c7 44 24 78 01 00 00    movl   $0x1,0x78(%rsp)
    0.00 :	    1810:       00 
         :	#ifdef module_param_array
         :	                        if (num_FCoE > bd) {
    0.00 :	    1811:       0f 82 f7 05 00 00       jb     1e0e <ixgbe_check_options+0xa1c>
         :	                                if (fcoe)
         :	                                        *aflags |= IXGBE_FLAG_FCOE_CAPABLE;
         :	#ifdef module_param_array
         :	                        } else {
         :	                                if (opt.def == OPTION_ENABLED)
         :	                                        *aflags |= IXGBE_FLAG_FCOE_CAPABLE;
    0.00 :	    1817:       81 8b 18 02 00 00 00    orl    $0x20000,0x218(%rbx)
    0.00 :	    181e:       00 02 00 
         :	                        }
         :	#endif
         :	                        DPRINTK(PROBE, INFO, "FCoE Offload feature %sabled\n",
    0.00 :	    1821:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1828:       0f 85 a6 05 00 00       jne    1dd4 <ixgbe_check_options+0x9e2>
         :	                struct ixgbe_option opt = {
         :	                        .type = enable_option,
         :	                        .name = "LRO - Large Receive Offload",
         :	                        .err  = "defaulting to Enabled",
         :	                        .def  = OPTION_ENABLED
         :	                };
    0.00 :	    182e:       48 8d 54 24 30          lea    0x30(%rsp),%rdx
    0.00 :	    1833:       31 c0                   xor    %eax,%eax
    0.00 :	    1835:       b9 06 00 00 00          mov    $0x6,%ecx
         :	                if (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE))
         :	                        opt.def = OPTION_DISABLED;
         :
         :	#endif
         :	#ifdef module_param_array
         :	                if (num_LRO > bd) {
    0.00 :	    183a:       44 3b 25 00 00 00 00    cmp    0x0(%rip),%r12d        # 1841 <ixgbe_check_options+0x44f>
         :	                struct ixgbe_option opt = {
         :	                        .type = enable_option,
         :	                        .name = "LRO - Large Receive Offload",
         :	                        .err  = "defaulting to Enabled",
         :	                        .def  = OPTION_ENABLED
         :	                };
    0.00 :	    1841:       48 89 d7                mov    %rdx,%rdi
    0.00 :	    1844:       f3 48 ab                rep stos %rax,%es:(%rdi)
    0.00 :	    1847:       48 c7 44 24 38 00 00    movq   $0x0,0x38(%rsp)
    0.00 :	    184e:       00 00 
    0.00 :	    1850:       48 c7 44 24 40 00 00    movq   $0x0,0x40(%rsp)
    0.00 :	    1857:       00 00 
    0.00 :	    1859:       c7 44 24 48 01 00 00    movl   $0x1,0x48(%rsp)
    0.00 :	    1860:       00 
         :	                struct net_device *netdev = adapter->netdev;
    0.00 :	    1861:       48 8b ab 00 02 00 00    mov    0x200(%rbx),%rbp
         :	                if (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE))
         :	                        opt.def = OPTION_DISABLED;
         :
         :	#endif
         :	#ifdef module_param_array
         :	                if (num_LRO > bd) {
    0.00 :	    1868:       0f 82 e0 00 00 00       jb     194e <ixgbe_check_options+0x55c>
         :	                                netdev->features |= NETIF_F_LRO;
         :	                        else
         :	                                netdev->features &= ~NETIF_F_LRO;
         :	#ifdef module_param_array
         :	                } else if (opt.def == OPTION_ENABLED) {
         :	                        netdev->features |= NETIF_F_LRO;
    0.00 :	    186e:       81 8d b0 00 00 00 00    orl    $0x8000,0xb0(%rbp)
    0.00 :	    1875:       80 00 00 
         :	        struct ixgbe_option opt = {
         :	                        .type = enable_option,
         :	                        .name = "allow_unsupported_sfp",
         :	                        .err  = "defaulting to Disabled",
         :	                        .def  = OPTION_DISABLED
         :	                };
    0.00 :	    1878:       31 c0                   xor    %eax,%eax
         :	#ifdef module_param_array
         :	                if (num_allow_unsupported_sfp > bd) {
    0.00 :	    187a:       44 3b 25 00 00 00 00    cmp    0x0(%rip),%r12d        # 1881 <ixgbe_check_options+0x48f>
         :	        struct ixgbe_option opt = {
         :	                        .type = enable_option,
         :	                        .name = "allow_unsupported_sfp",
         :	                        .err  = "defaulting to Disabled",
         :	                        .def  = OPTION_DISABLED
         :	                };
    0.00 :	    1881:       b9 06 00 00 00          mov    $0x6,%ecx
    0.00 :	    1886:       48 89 e7                mov    %rsp,%rdi
    0.00 :	    1889:       f3 48 ab                rep stos %rax,%es:(%rdi)
    0.00 :	    188c:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
    0.00 :	    1893:       00 00 
    0.00 :	    1895:       48 c7 44 24 10 00 00    movq   $0x0,0x10(%rsp)
    0.00 :	    189c:       00 00 
         :	#ifdef module_param_array
         :	                if (num_allow_unsupported_sfp > bd) {
    0.00 :	    189e:       72 7a                   jb     191a <ixgbe_check_options+0x528>
         :	                        } else {
         :	                                adapter->hw.allow_unsupported_sfp = false;
         :	                        }
         :	#ifdef module_param_array
         :	                } else if (opt.def == OPTION_ENABLED) {
         :	                                adapter->hw.allow_unsupported_sfp = true;
    0.00 :	    18a0:       83 7c 24 18 01          cmpl   $0x1,0x18(%rsp)
    0.00 :	    18a5:       0f 94 83 a1 14 00 00    sete   0x14a1(%rbx)
         :	                } else {
         :	                                adapter->hw.allow_unsupported_sfp = false;
         :	                }
         :	#endif
         :	        }
         :	}
    0.00 :	    18ac:       48 81 c4 a8 00 00 00    add    $0xa8,%rsp
    0.00 :	    18b3:       5b                      pop    %rbx
    0.00 :	    18b4:       5d                      pop    %rbp
    0.00 :	    18b5:       41 5c                   pop    %r12
    0.00 :	    18b7:       41 5d                   pop    %r13
    0.00 :	    18b9:       c3                      retq   
         :	                        adapter->atr_sample_rate = IXGBE_ATR_SAMPLE_RATE_OFF;
         :	                } else if (num_AtrSampleRate > bd) {
         :	                        adapter->atr_sample_rate = AtrSampleRate[bd];
         :
         :	                        if (adapter->atr_sample_rate) {
         :	                                ixgbe_validate_option(&adapter->atr_sample_rate,
    0.00 :	    18ba:       48 8d bb dc 1b 00 00    lea    0x1bdc(%rbx),%rdi
    0.00 :	    18c1:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    18c8:       e8 23 fa ff ff          callq  12f0 <ixgbe_validate_option>
         :	                                                      &opt);
         :	                                DPRINTK(PROBE, INFO, "%s %d\n", atr_string,
    0.00 :	    18cd:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    18d4:       0f 84 ec fe ff ff       je     17c6 <ixgbe_check_options+0x3d4>
    0.00 :	    18da:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    18e1:       44 8b 83 dc 1b 00 00    mov    0x1bdc(%rbx),%r8d
    0.00 :	    18e8:       48 c7 c1 00 00 00 00    mov    $0x0,%rcx
    0.00 :	    18ef:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    18f6:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    18fd:       31 c0                   xor    %eax,%eax
    0.00 :	    18ff:       e8 00 00 00 00          callq  1904 <ixgbe_check_options+0x512>
    0.00 :	    1904:       e9 bd fe ff ff          jmpq   17c6 <ixgbe_check_options+0x3d4>
         :	                                        adapter->atr_sample_rate);
         :	                        }
         :	                } else {
         :	                        adapter->atr_sample_rate = opt.def;
    0.00 :	    1909:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 190f <ixgbe_check_options+0x51d>
    0.00 :	    190f:       89 83 dc 1b 00 00       mov    %eax,0x1bdc(%rbx)
    0.00 :	    1915:       e9 ac fe ff ff          jmpq   17c6 <ixgbe_check_options+0x3d4>
         :	                };
         :	#ifdef module_param_array
         :	                if (num_allow_unsupported_sfp > bd) {
         :	#endif
         :	                        unsigned int enable_unsupported_sfp =
         :	                                                      allow_unsupported_sfp[bd];
    0.00 :	    191a:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1921:       00 
         :	                        ixgbe_validate_option(&enable_unsupported_sfp, &opt);
    0.00 :	    1922:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1929:       00 
    0.00 :	    192a:       48 89 e6                mov    %rsp,%rsi
         :	                };
         :	#ifdef module_param_array
         :	                if (num_allow_unsupported_sfp > bd) {
         :	#endif
         :	                        unsigned int enable_unsupported_sfp =
         :	                                                      allow_unsupported_sfp[bd];
    0.00 :	    192d:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&enable_unsupported_sfp, &opt);
    0.00 :	    1934:       e8 b7 f9 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (enable_unsupported_sfp) {
         :	                                adapter->hw.allow_unsupported_sfp = true;
    0.00 :	    1939:       8b 84 24 9c 00 00 00    mov    0x9c(%rsp),%eax
    0.00 :	    1940:       85 c0                   test   %eax,%eax
    0.00 :	    1942:       0f 95 83 a1 14 00 00    setne  0x14a1(%rbx)
    0.00 :	    1949:       e9 5e ff ff ff          jmpq   18ac <ixgbe_check_options+0x4ba>
         :
         :	#endif
         :	#ifdef module_param_array
         :	                if (num_LRO > bd) {
         :	#endif
         :	                        unsigned int lro = LRO[bd];
    0.00 :	    194e:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1955:       00 
         :	                        ixgbe_validate_option(&lro, &opt);
    0.00 :	    1956:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    195d:       00 
    0.00 :	    195e:       48 89 d6                mov    %rdx,%rsi
         :
         :	#endif
         :	#ifdef module_param_array
         :	                if (num_LRO > bd) {
         :	#endif
         :	                        unsigned int lro = LRO[bd];
    0.00 :	    1961:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&lro, &opt);
    0.00 :	    1968:       e8 83 f9 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (lro)
    0.00 :	    196d:       8b 94 24 9c 00 00 00    mov    0x9c(%rsp),%edx
    0.00 :	    1974:       85 d2                   test   %edx,%edx
    0.00 :	    1976:       0f 85 f2 fe ff ff       jne    186e <ixgbe_check_options+0x47c>
         :	                                netdev->features |= NETIF_F_LRO;
         :	                        else
         :	                                netdev->features &= ~NETIF_F_LRO;
    0.00 :	    197c:       81 a5 b0 00 00 00 ff    andl   $0xffff7fff,0xb0(%rbp)
    0.00 :	    1983:       7f ff ff 
    0.00 :	    1986:       e9 ed fe ff ff          jmpq   1878 <ixgbe_check_options+0x486>
         :	                };
         :	                static const char atr_string[] =
         :	                                            "ATR Tx Packet sample rate set to";
         :
         :	                if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
         :	                        adapter->atr_sample_rate = IXGBE_ATR_SAMPLE_RATE_OFF;
    0.00 :	    198b:       c7 83 dc 1b 00 00 00    movl   $0x0,0x1bdc(%rbx)
    0.00 :	    1992:       00 00 00 
    0.00 :	    1995:       e9 2c fe ff ff          jmpq   17c6 <ixgbe_check_options+0x3d4>
         :	                char pstring[10];
         :
         :	                if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
         :	                        adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_NONE;
         :	                } else if (num_FdirPballoc > bd) {
         :	                        fdir_pballoc_mode = FdirPballoc[bd];
    0.00 :	    199a:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    19a1:       00 
         :	                        ixgbe_validate_option(&fdir_pballoc_mode, &opt);
    0.00 :	    19a2:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    19a9:       00 
    0.00 :	    19aa:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                char pstring[10];
         :
         :	                if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
         :	                        adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_NONE;
         :	                } else if (num_FdirPballoc > bd) {
         :	                        fdir_pballoc_mode = FdirPballoc[bd];
    0.00 :	    19b1:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&fdir_pballoc_mode, &opt);
    0.00 :	    19b8:       e8 33 f9 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        switch (fdir_pballoc_mode) {
    0.00 :	    19bd:       8b 84 24 9c 00 00 00    mov    0x9c(%rsp),%eax
    0.00 :	    19c4:       83 f8 02                cmp    $0x2,%eax
    0.00 :	    19c7:       0f 84 bf 00 00 00       je     1a8c <ixgbe_check_options+0x69a>
    0.00 :	    19cd:       83 f8 03                cmp    $0x3,%eax
    0.00 :	    19d0:       0f 84 8a 00 00 00       je     1a60 <ixgbe_check_options+0x66e>
         :	                                sprintf(pstring, "128kB");
         :	                                break;
         :	                        case IXGBE_FDIR_PBALLOC_64K:
         :	                        default:
         :	                                adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_64K;
         :	                                sprintf(pstring, "64kB");
    0.00 :	    19d6:       48 8d 8c 24 90 00 00    lea    0x90(%rsp),%rcx
    0.00 :	    19dd:       00 
         :	                                adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_128K;
         :	                                sprintf(pstring, "128kB");
         :	                                break;
         :	                        case IXGBE_FDIR_PBALLOC_64K:
         :	                        default:
         :	                                adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_64K;
    0.00 :	    19de:       c7 83 d8 1b 00 00 01    movl   $0x1,0x1bd8(%rbx)
    0.00 :	    19e5:       00 00 00 
         :	                                sprintf(pstring, "64kB");
    0.00 :	    19e8:       c7 84 24 90 00 00 00    movl   $0x426b3436,0x90(%rsp)
    0.00 :	    19ef:       36 34 6b 42 
    0.00 :	    19f3:       c6 84 24 94 00 00 00    movb   $0x0,0x94(%rsp)
    0.00 :	    19fa:       00 
         :	                                break;
         :	                        }
         :	                        DPRINTK(PROBE, INFO, "Flow Director will be allocated "
    0.00 :	    19fb:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1a02:       0f 84 8e fd ff ff       je     1796 <ixgbe_check_options+0x3a4>
    0.00 :	    1a08:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1a0f:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1a16:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1a1d:       31 c0                   xor    %eax,%eax
    0.00 :	    1a1f:       e8 00 00 00 00          callq  1a24 <ixgbe_check_options+0x632>
    0.00 :	    1a24:       e9 6d fd ff ff          jmpq   1796 <ixgbe_check_options+0x3a4>
         :	                                      .max = IXGBE_FDIR_PBALLOC_256K} }
         :	                };
         :	                char pstring[10];
         :
         :	                if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
         :	                        adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_NONE;
    0.00 :	    1a29:       c7 83 d8 1b 00 00 00    movl   $0x0,0x1bd8(%rbx)
    0.00 :	    1a30:       00 00 00 
    0.00 :	    1a33:       e9 5e fd ff ff          jmpq   1796 <ixgbe_check_options+0x3a4>
         :	                        adapter->lli_vlan_pri = LLIVLANP[bd];
         :	                        if (adapter->lli_vlan_pri) {
         :	                                ixgbe_validate_option(&adapter->lli_vlan_pri,
         :	                                                      &opt);
         :	                        } else {
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
    0.00 :	    1a38:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1a3f:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 1a46 <ixgbe_check_options+0x654>
    0.00 :	    1a46:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1a4d:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1a54:       31 c0                   xor    %eax,%eax
    0.00 :	    1a56:       e8 00 00 00 00          callq  1a5b <ixgbe_check_options+0x669>
    0.00 :	    1a5b:       e9 10 fd ff ff          jmpq   1770 <ixgbe_check_options+0x37e>
         :	                } else if (num_FdirPballoc > bd) {
         :	                        fdir_pballoc_mode = FdirPballoc[bd];
         :	                        ixgbe_validate_option(&fdir_pballoc_mode, &opt);
         :	                        switch (fdir_pballoc_mode) {
         :	                        case IXGBE_FDIR_PBALLOC_256K:
         :	                                adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_256K;
    0.00 :	    1a60:       c7 83 d8 1b 00 00 03    movl   $0x3,0x1bd8(%rbx)
    0.00 :	    1a67:       00 00 00 
         :	                                sprintf(pstring, "256kB");
    0.00 :	    1a6a:       48 8d 8c 24 90 00 00    lea    0x90(%rsp),%rcx
    0.00 :	    1a71:       00 
    0.00 :	    1a72:       c7 84 24 90 00 00 00    movl   $0x6b363532,0x90(%rsp)
    0.00 :	    1a79:       32 35 36 6b 
    0.00 :	    1a7d:       66 c7 84 24 94 00 00    movw   $0x42,0x94(%rsp)
    0.00 :	    1a84:       00 42 00 
         :	                                break;
    0.00 :	    1a87:       e9 6f ff ff ff          jmpq   19fb <ixgbe_check_options+0x609>
         :	                        case IXGBE_FDIR_PBALLOC_128K:
         :	                                adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_128K;
    0.00 :	    1a8c:       c7 83 d8 1b 00 00 02    movl   $0x2,0x1bd8(%rbx)
    0.00 :	    1a93:       00 00 00 
         :	                                sprintf(pstring, "128kB");
    0.00 :	    1a96:       48 8d 8c 24 90 00 00    lea    0x90(%rsp),%rcx
    0.00 :	    1a9d:       00 
    0.00 :	    1a9e:       c7 84 24 90 00 00 00    movl   $0x6b383231,0x90(%rsp)
    0.00 :	    1aa5:       31 32 38 6b 
    0.00 :	    1aa9:       66 c7 84 24 94 00 00    movw   $0x42,0x94(%rsp)
    0.00 :	    1ab0:       00 42 00 
         :	                                break;
    0.00 :	    1ab3:       e9 43 ff ff ff          jmpq   19fb <ixgbe_check_options+0x609>
         :	#ifdef module_param_array
         :	                if (num_LLIVLANP > bd) {
         :	#endif
         :	                        adapter->lli_vlan_pri = LLIVLANP[bd];
         :	                        if (adapter->lli_vlan_pri) {
         :	                                ixgbe_validate_option(&adapter->lli_vlan_pri,
    0.00 :	    1ab8:       48 8d bb fc 1a 00 00    lea    0x1afc(%rbx),%rdi
    0.00 :	    1abf:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1ac6:       e8 25 f8 ff ff          callq  12f0 <ixgbe_validate_option>
    0.00 :	    1acb:       e9 a0 fc ff ff          jmpq   1770 <ixgbe_check_options+0x37e>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        adapter->lli_vlan_pri = opt.def;
    0.00 :	    1ad0:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1ad6 <ixgbe_check_options+0x6e4>
    0.00 :	    1ad6:       89 83 fc 1a 00 00       mov    %eax,0x1afc(%rbx)
    0.00 :	    1adc:       e9 8f fc ff ff          jmpq   1770 <ixgbe_check_options+0x37e>
         :	                        adapter->lli_etype = LLIEType[bd];
         :	                        if (adapter->lli_etype) {
         :	                                ixgbe_validate_option(&adapter->lli_etype,
         :	                                                      &opt);
         :	                        } else {
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
    0.00 :	    1ae1:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1ae8:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 1aef <ixgbe_check_options+0x6fd>
    0.00 :	    1aef:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1af6:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1afd:       31 c0                   xor    %eax,%eax
    0.00 :	    1aff:       e8 00 00 00 00          callq  1b04 <ixgbe_check_options+0x712>
    0.00 :	    1b04:       e9 37 fc ff ff          jmpq   1740 <ixgbe_check_options+0x34e>
         :	#ifdef module_param_array
         :	                if (num_LLIEType > bd) {
         :	#endif
         :	                        adapter->lli_etype = LLIEType[bd];
         :	                        if (adapter->lli_etype) {
         :	                                ixgbe_validate_option(&adapter->lli_etype,
    0.00 :	    1b09:       48 8d bb f8 1a 00 00    lea    0x1af8(%rbx),%rdi
    0.00 :	    1b10:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1b17:       e8 d4 f7 ff ff          callq  12f0 <ixgbe_validate_option>
    0.00 :	    1b1c:       e9 1f fc ff ff          jmpq   1740 <ixgbe_check_options+0x34e>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        adapter->lli_etype = opt.def;
    0.00 :	    1b21:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1b27 <ixgbe_check_options+0x735>
    0.00 :	    1b27:       89 83 f8 1a 00 00       mov    %eax,0x1af8(%rbx)
    0.00 :	    1b2d:       e9 0e fc ff ff          jmpq   1740 <ixgbe_check_options+0x34e>
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_LLIPush > bd) {
         :	#endif
         :	                        unsigned int lli_push = LLIPush[bd];
    0.00 :	    1b32:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1b39:       00 
         :	                        ixgbe_validate_option(&lli_push, &opt);
    0.00 :	    1b3a:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1b41:       00 
    0.00 :	    1b42:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_LLIPush > bd) {
         :	#endif
         :	                        unsigned int lli_push = LLIPush[bd];
    0.00 :	    1b49:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&lli_push, &opt);
    0.00 :	    1b50:       e8 9b f7 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (lli_push)
    0.00 :	    1b55:       8b b4 24 9c 00 00 00    mov    0x9c(%rsp),%esi
    0.00 :	    1b5c:       85 f6                   test   %esi,%esi
    0.00 :	    1b5e:       0f 84 a5 fb ff ff       je     1709 <ixgbe_check_options+0x317>
         :	                        else
         :	                                *aflags &= ~IXGBE_FLAG_LLI_PUSH;
         :	#ifdef module_param_array
         :	                } else {
         :	                        if (opt.def == OPTION_ENABLED)
         :	                                *aflags |= IXGBE_FLAG_LLI_PUSH;
    0.00 :	    1b64:       83 8b 18 02 00 00 10    orl    $0x10,0x218(%rbx)
    0.00 :	    1b6b:       e9 a0 fb ff ff          jmpq   1710 <ixgbe_check_options+0x31e>
         :	#endif
         :	                        adapter->lli_size = LLISize[bd];
         :	                        if (adapter->lli_size) {
         :	                                ixgbe_validate_option(&adapter->lli_size, &opt);
         :	                        } else {
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
    0.00 :	    1b70:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1b77:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 1b7e <ixgbe_check_options+0x78c>
    0.00 :	    1b7e:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1b85:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1b8c:       31 c0                   xor    %eax,%eax
    0.00 :	    1b8e:       e8 00 00 00 00          callq  1b93 <ixgbe_check_options+0x7a1>
    0.00 :	    1b93:       e9 57 fb ff ff          jmpq   16ef <ixgbe_check_options+0x2fd>
         :	#ifdef module_param_array
         :	                if (num_LLISize > bd) {
         :	#endif
         :	                        adapter->lli_size = LLISize[bd];
         :	                        if (adapter->lli_size) {
         :	                                ixgbe_validate_option(&adapter->lli_size, &opt);
    0.00 :	    1b98:       48 8d bb f4 1a 00 00    lea    0x1af4(%rbx),%rdi
    0.00 :	    1b9f:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1ba6:       e8 45 f7 ff ff          callq  12f0 <ixgbe_validate_option>
    0.00 :	    1bab:       e9 3f fb ff ff          jmpq   16ef <ixgbe_check_options+0x2fd>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        adapter->lli_size = opt.def;
    0.00 :	    1bb0:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1bb6 <ixgbe_check_options+0x7c4>
    0.00 :	    1bb6:       89 83 f4 1a 00 00       mov    %eax,0x1af4(%rbx)
    0.00 :	    1bbc:       e9 2e fb ff ff          jmpq   16ef <ixgbe_check_options+0x2fd>
         :	#endif
         :	                        adapter->lli_port = LLIPort[bd];
         :	                        if (adapter->lli_port) {
         :	                                ixgbe_validate_option(&adapter->lli_port, &opt);
         :	                        } else {
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
    0.00 :	    1bc1:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1bc8:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 1bcf <ixgbe_check_options+0x7dd>
    0.00 :	    1bcf:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1bd6:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1bdd:       31 c0                   xor    %eax,%eax
    0.00 :	    1bdf:       e8 00 00 00 00          callq  1be4 <ixgbe_check_options+0x7f2>
    0.00 :	    1be4:       e9 d6 fa ff ff          jmpq   16bf <ixgbe_check_options+0x2cd>
         :	#ifdef module_param_array
         :	                if (num_LLIPort > bd) {
         :	#endif
         :	                        adapter->lli_port = LLIPort[bd];
         :	                        if (adapter->lli_port) {
         :	                                ixgbe_validate_option(&adapter->lli_port, &opt);
    0.00 :	    1be9:       48 8d bb f0 1a 00 00    lea    0x1af0(%rbx),%rdi
    0.00 :	    1bf0:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1bf7:       e8 f4 f6 ff ff          callq  12f0 <ixgbe_validate_option>
    0.00 :	    1bfc:       e9 be fa ff ff          jmpq   16bf <ixgbe_check_options+0x2cd>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        adapter->lli_port = opt.def;
    0.00 :	    1c01:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1c07 <ixgbe_check_options+0x815>
    0.00 :	    1c07:       89 83 f0 1a 00 00       mov    %eax,0x1af0(%rbx)
    0.00 :	    1c0d:       e9 ad fa ff ff          jmpq   16bf <ixgbe_check_options+0x2cd>
         :	                if (num_InterruptThrottleRate > bd) {
         :	#endif
         :	                        u32 itr = InterruptThrottleRate[bd];
         :	                        switch (itr) {
         :	                        case 0:
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
    0.00 :	    1c12:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1c19:       48 8b 0d 00 00 00 00    mov    0x0(%rip),%rcx        # 1c20 <ixgbe_check_options+0x82e>
    0.00 :	    1c20:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1c27:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1c2e:       31 c0                   xor    %eax,%eax
    0.00 :	    1c30:       e8 00 00 00 00          callq  1c35 <ixgbe_check_options+0x843>
    0.00 :	    1c35:       e9 3e fa ff ff          jmpq   1678 <ixgbe_check_options+0x286>
         :
         :	#ifdef module_param_array
         :	                if (num_InterruptThrottleRate > bd) {
         :	#endif
         :	                        u32 itr = InterruptThrottleRate[bd];
         :	                        switch (itr) {
    0.00 :	    1c3a:       83 e8 01                sub    $0x1,%eax
    0.00 :	    1c3d:       74 50                   je     1c8f <ixgbe_check_options+0x89d>
         :	                                DPRINTK(PROBE, INFO, "dynamic interrupt "
         :	                                        "throttling enabled\n");
         :	                                adapter->rx_itr_setting = 1;
         :	                                break;
         :	                        default:
         :	                                ixgbe_validate_option(&itr, &opt);
    0.00 :	    1c3f:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1c46:       00 
    0.00 :	    1c47:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1c4e:       e8 9d f6 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                                /* the first bit is used as control */
         :	                                adapter->rx_itr_setting = (1000000/itr) << 2;
    0.00 :	    1c53:       b8 40 42 0f 00          mov    $0xf4240,%eax
    0.00 :	    1c58:       31 d2                   xor    %edx,%edx
    0.00 :	    1c5a:       f7 b4 24 9c 00 00 00    divl   0x9c(%rsp)
    0.00 :	    1c61:       c1 e0 02                shl    $0x2,%eax
    0.00 :	    1c64:       66 89 83 2c 02 00 00    mov    %ax,0x22c(%rbx)
    0.00 :	    1c6b:       e9 11 fa ff ff          jmpq   1681 <ixgbe_check_options+0x28f>
         :	                                break;
         :	                        }
         :	                        adapter->tx_itr_setting = adapter->rx_itr_setting;
         :	#ifdef module_param_array
         :	                } else {
         :	                        adapter->rx_itr_setting = opt.def;
    0.00 :	    1c70:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1c76 <ixgbe_check_options+0x884>
    0.00 :	    1c76:       66 89 83 2c 02 00 00    mov    %ax,0x22c(%rbx)
         :	                        adapter->tx_itr_setting = opt.def;
    0.00 :	    1c7d:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1c83 <ixgbe_check_options+0x891>
    0.00 :	    1c83:       66 89 83 24 02 00 00    mov    %ax,0x224(%rbx)
    0.00 :	    1c8a:       e9 00 fa ff ff          jmpq   168f <ixgbe_check_options+0x29d>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                                adapter->rx_itr_setting = 0;
         :	                                break;
         :	                        case 1:
         :	                                DPRINTK(PROBE, INFO, "dynamic interrupt "
    0.00 :	    1c8f:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1c96:       0f 85 a5 01 00 00       jne    1e41 <ixgbe_check_options+0xa4f>
         :	                                        "throttling enabled\n");
         :	                                adapter->rx_itr_setting = 1;
    0.00 :	    1c9c:       66 c7 83 2c 02 00 00    movw   $0x1,0x22c(%rbx)
    0.00 :	    1ca3:       01 00 
         :	                                break;
    0.00 :	    1ca5:       e9 d7 f9 ff ff          jmpq   1681 <ixgbe_check_options+0x28f>
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_L2LBen > bd) {
         :	#endif
         :	                        unsigned int l2LBen = L2LBen[bd];
    0.00 :	    1caa:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1cb1:       00 
         :	                        ixgbe_validate_option(&l2LBen, &opt);
    0.00 :	    1cb2:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1cb9:       00 
    0.00 :	    1cba:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_L2LBen > bd) {
         :	#endif
         :	                        unsigned int l2LBen = L2LBen[bd];
    0.00 :	    1cc1:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&l2LBen, &opt);
    0.00 :	    1cc8:       e8 23 f6 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (l2LBen)
    0.00 :	    1ccd:       8b bc 24 9c 00 00 00    mov    0x9c(%rsp),%edi
    0.00 :	    1cd4:       85 ff                   test   %edi,%edi
    0.00 :	    1cd6:       0f 84 6b f9 ff ff       je     1647 <ixgbe_check_options+0x255>
         :	                                adapter->flags |=
         :	                                        IXGBE_FLAG_SRIOV_L2LOOPBACK_ENABLE;
         :	#ifdef module_param_array
         :	                } else {
         :	                        if (opt.def == OPTION_ENABLED)
         :	                                adapter->flags |=
    0.00 :	    1cdc:       81 8b 18 02 00 00 00    orl    $0x800000,0x218(%rbx)
    0.00 :	    1ce3:       00 80 00 
    0.00 :	    1ce6:       e9 5c f9 ff ff          jmpq   1647 <ixgbe_check_options+0x255>
         :	                } else {
         :	                        if (opt.def == OPTION_DISABLED) {
         :	                                adapter->num_vfs = 0;
         :	                                *aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
         :	                        } else {
         :	                                adapter->num_vfs = opt.def;
    0.00 :	    1ceb:       89 83 58 7c 00 00       mov    %eax,0x7c58(%rbx)
         :	                                *aflags |= IXGBE_FLAG_SRIOV_ENABLED;
    0.00 :	    1cf1:       81 8b 18 02 00 00 00    orl    $0x100000,0x218(%rbx)
    0.00 :	    1cf8:       00 10 00 
    0.00 :	    1cfb:       e9 f3 f8 ff ff          jmpq   15f3 <ixgbe_check_options+0x201>
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_max_vfs > bd) {
         :	#endif
         :	                        unsigned int vfs = max_vfs[bd];
    0.00 :	    1d00:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1d07:       00 
         :	                        if (ixgbe_validate_option(&vfs, &opt)) {
    0.00 :	    1d08:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1d0f:       00 
    0.00 :	    1d10:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_max_vfs > bd) {
         :	#endif
         :	                        unsigned int vfs = max_vfs[bd];
    0.00 :	    1d17:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        if (ixgbe_validate_option(&vfs, &opt)) {
    0.00 :	    1d1e:       e8 cd f5 ff ff          callq  12f0 <ixgbe_validate_option>
    0.00 :	    1d23:       85 c0                   test   %eax,%eax
    0.00 :	    1d25:       74 14                   je     1d3b <ixgbe_check_options+0x949>
         :	                                vfs = 0;
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1d27:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
         :	#ifdef module_param_array
         :	                if (num_max_vfs > bd) {
         :	#endif
         :	                        unsigned int vfs = max_vfs[bd];
         :	                        if (ixgbe_validate_option(&vfs, &opt)) {
         :	                                vfs = 0;
    0.00 :	    1d2e:       c7 84 24 9c 00 00 00    movl   $0x0,0x9c(%rsp)
    0.00 :	    1d35:       00 00 00 00 
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1d39:       75 17                   jne    1d52 <ixgbe_check_options+0x960>
         :	                                        "max_vfs out of range "
         :	                                        "Disabling SR-IOV.\n");
         :	                        }
         :
         :	                        adapter->num_vfs = vfs;
    0.00 :	    1d3b:       8b 84 24 9c 00 00 00    mov    0x9c(%rsp),%eax
         :
         :	                        if (vfs)
    0.00 :	    1d42:       85 c0                   test   %eax,%eax
         :	                                DPRINTK(PROBE, INFO,
         :	                                        "max_vfs out of range "
         :	                                        "Disabling SR-IOV.\n");
         :	                        }
         :
         :	                        adapter->num_vfs = vfs;
    0.00 :	    1d44:       89 83 58 7c 00 00       mov    %eax,0x7c58(%rbx)
         :
         :	                        if (vfs)
    0.00 :	    1d4a:       0f 84 99 f8 ff ff       je     15e9 <ixgbe_check_options+0x1f7>
    0.00 :	    1d50:       eb 9f                   jmp    1cf1 <ixgbe_check_options+0x8ff>
         :	                if (num_max_vfs > bd) {
         :	#endif
         :	                        unsigned int vfs = max_vfs[bd];
         :	                        if (ixgbe_validate_option(&vfs, &opt)) {
         :	                                vfs = 0;
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1d52:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1d59:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1d60:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1d67:       31 c0                   xor    %eax,%eax
    0.00 :	    1d69:       e8 00 00 00 00          callq  1d6e <ixgbe_check_options+0x97c>
    0.00 :	    1d6e:       eb cb                   jmp    1d3b <ixgbe_check_options+0x949>
         :	#endif
         :
         :	                /* Check Interoperability */
         :	                if (*aflags & IXGBE_FLAG_SRIOV_ENABLED) {
         :	                        if (!(*aflags & IXGBE_FLAG_SRIOV_CAPABLE)) {
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1d70:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1d77:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1d7e:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1d85:       31 c0                   xor    %eax,%eax
    0.00 :	    1d87:       e8 00 00 00 00          callq  1d8c <ixgbe_check_options+0x99a>
    0.00 :	    1d8c:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    1d92:       e9 81 f8 ff ff          jmpq   1618 <ixgbe_check_options+0x226>
         :	                                        "IOV is not supported on this "
         :	                                        "hardware.  Disabling IOV.\n");
         :	                                *aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
         :	                                adapter->num_vfs = 0;
         :	                        } else if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
    0.00 :	    1d97:       f6 c4 02                test   $0x2,%ah
    0.00 :	    1d9a:       0f 85 8d f8 ff ff       jne    162d <ixgbe_check_options+0x23b>
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1da0:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1da7:       0f 84 6b f8 ff ff       je     1618 <ixgbe_check_options+0x226>
    0.00 :	    1dad:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1db4:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1dbb:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1dc2:       31 c0                   xor    %eax,%eax
    0.00 :	    1dc4:       e8 00 00 00 00          callq  1dc9 <ixgbe_check_options+0x9d7>
    0.00 :	    1dc9:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    1dcf:       e9 44 f8 ff ff          jmpq   1618 <ixgbe_check_options+0x226>
         :	                        } else {
         :	                                if (opt.def == OPTION_ENABLED)
         :	                                        *aflags |= IXGBE_FLAG_FCOE_CAPABLE;
         :	                        }
         :	#endif
         :	                        DPRINTK(PROBE, INFO, "FCoE Offload feature %sabled\n",
    0.00 :	    1dd4:       f6 83 1a 02 00 00 02    testb  $0x2,0x21a(%rbx)
    0.00 :	    1ddb:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1de2:       48 c7 c0 00 00 00 00    mov    $0x0,%rax
    0.00 :	    1de9:       48 c7 c1 00 00 00 00    mov    $0x0,%rcx
    0.00 :	    1df0:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1df7:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1dfe:       48 0f 45 c8             cmovne %rax,%rcx
    0.00 :	    1e02:       31 c0                   xor    %eax,%eax
    0.00 :	    1e04:       e8 00 00 00 00          callq  1e09 <ixgbe_check_options+0xa17>
    0.00 :	    1e09:       e9 20 fa ff ff          jmpq   182e <ixgbe_check_options+0x43c>
         :	                                .def = OPTION_ENABLED
         :	                        };
         :	#ifdef module_param_array
         :	                        if (num_FCoE > bd) {
         :	#endif
         :	                                unsigned int fcoe = FCoE[bd];
    0.00 :	    1e0e:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1e15:       00 
         :
         :	                                ixgbe_validate_option(&fcoe, &opt);
    0.00 :	    1e16:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1e1d:       00 
    0.00 :	    1e1e:       48 89 d6                mov    %rdx,%rsi
         :	                                .def = OPTION_ENABLED
         :	                        };
         :	#ifdef module_param_array
         :	                        if (num_FCoE > bd) {
         :	#endif
         :	                                unsigned int fcoe = FCoE[bd];
    0.00 :	    1e21:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :
         :	                                ixgbe_validate_option(&fcoe, &opt);
    0.00 :	    1e28:       e8 c3 f4 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                                if (fcoe)
    0.00 :	    1e2d:       8b 8c 24 9c 00 00 00    mov    0x9c(%rsp),%ecx
    0.00 :	    1e34:       85 c9                   test   %ecx,%ecx
    0.00 :	    1e36:       0f 84 e5 f9 ff ff       je     1821 <ixgbe_check_options+0x42f>
    0.00 :	    1e3c:       e9 d6 f9 ff ff          jmpq   1817 <ixgbe_check_options+0x425>
         :	                                DPRINTK(PROBE, INFO, "%s turned off\n",
         :	                                        opt.name);
         :	                                adapter->rx_itr_setting = 0;
         :	                                break;
         :	                        case 1:
         :	                                DPRINTK(PROBE, INFO, "dynamic interrupt "
    0.00 :	    1e41:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1e48:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1e4f:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1e56:       31 c0                   xor    %eax,%eax
    0.00 :	    1e58:       e8 00 00 00 00          callq  1e5d <ixgbe_check_options+0xa6b>
    0.00 :	    1e5d:       e9 3a fe ff ff          jmpq   1c9c <ixgbe_check_options+0x8aa>
         :	#ifdef module_param_array
         :	                } else {
         :	                        if (opt.def == OPTION_DISABLED)
         :	                                *aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
         :	                        else
         :	                                *aflags |= IXGBE_FLAG_VMDQ_ENABLED;
    0.00 :	    1e62:       81 8b 18 02 00 00 00    orl    $0x800,0x218(%rbx)
    0.00 :	    1e69:       08 00 00 
    0.00 :	    1e6c:       e9 17 f7 ff ff          jmpq   1588 <ixgbe_check_options+0x196>
         :	                }
         :
         :	#ifdef module_param_array
         :	                if (num_VMDQ > bd) {
         :	#endif
         :	                        unsigned int vmdq = VMDQ[bd];
    0.00 :	    1e71:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1e78:       00 
         :
         :	                        ixgbe_validate_option(&vmdq, &opt);
    0.00 :	    1e79:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1e80:       00 
    0.00 :	    1e81:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                }
         :
         :	#ifdef module_param_array
         :	                if (num_VMDQ > bd) {
         :	#endif
         :	                        unsigned int vmdq = VMDQ[bd];
    0.00 :	    1e88:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :
         :	                        ixgbe_validate_option(&vmdq, &opt);
    0.00 :	    1e8f:       e8 5c f4 ff ff          callq  12f0 <ixgbe_validate_option>
         :
         :	                        /* zero or one both mean disabled from our driver's
         :	                         * perspective */
         :	                        if (vmdq > 1)
    0.00 :	    1e94:       83 bc 24 9c 00 00 00    cmpl   $0x1,0x9c(%rsp)
    0.00 :	    1e9b:       01 
    0.00 :	    1e9c:       76 6e                   jbe    1f0c <ixgbe_check_options+0xb1a>
         :	                                *aflags |= IXGBE_FLAG_VMDQ_ENABLED;
    0.00 :	    1e9e:       81 8b 18 02 00 00 00    orl    $0x800,0x218(%rbx)
    0.00 :	    1ea5:       08 00 00 
         :	                        else
         :	                                *aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
         :
         :	                        feature[RING_F_VMDQ].limit = vmdq;
    0.00 :	    1ea8:       8b 84 24 9c 00 00 00    mov    0x9c(%rsp),%eax
    0.00 :	    1eaf:       66 89 83 d0 0b 00 00    mov    %ax,0xbd0(%rbx)
    0.00 :	    1eb6:       e9 da f6 ff ff          jmpq   1595 <ixgbe_check_options+0x1a3>
         :	                                feature[RING_F_FDIR].limit = rss;
         :
         :	                        feature[RING_F_RSS].limit = rss;
         :	#ifdef module_param_array
         :	                } else if (opt.def == 0) {
         :	                        rss = min_t(int, IXGBE_MAX_RSS_INDICES,
    0.00 :	    1ebb:       48 8b 3d 00 00 00 00    mov    0x0(%rip),%rdi        # 1ec2 <ixgbe_check_options+0xad0>
    0.00 :	    1ec2:       e8 00 00 00 00          callq  1ec7 <ixgbe_check_options+0xad5>
    0.00 :	    1ec7:       ba 10 00 00 00          mov    $0x10,%edx
    0.00 :	    1ecc:       83 f8 10                cmp    $0x10,%eax
    0.00 :	    1ecf:       0f 4e d0                cmovle %eax,%edx
    0.00 :	    1ed2:       89 94 24 9c 00 00 00    mov    %edx,0x9c(%rsp)
         :	                                    num_online_cpus());
         :	                        feature[RING_F_RSS].limit = rss;
    0.00 :	    1ed9:       66 89 93 d8 0b 00 00    mov    %dx,0xbd8(%rbx)
    0.00 :	    1ee0:       e9 3a f6 ff ff          jmpq   151f <ixgbe_check_options+0x12d>
         :	                }
         :	#endif
         :	                /* Check Interoperability */
         :	                if (*aflags & IXGBE_FLAG_VMDQ_ENABLED) {
         :	                        if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1ee5:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1eec:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    1ef3:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    1efa:       31 c0                   xor    %eax,%eax
    0.00 :	    1efc:       e8 00 00 00 00          callq  1f01 <ixgbe_check_options+0xb0f>
    0.00 :	    1f01:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    1f07:       e9 a6 f6 ff ff          jmpq   15b2 <ixgbe_check_options+0x1c0>
         :	                        /* zero or one both mean disabled from our driver's
         :	                         * perspective */
         :	                        if (vmdq > 1)
         :	                                *aflags |= IXGBE_FLAG_VMDQ_ENABLED;
         :	                        else
         :	                                *aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
    0.00 :	    1f0c:       81 a3 18 02 00 00 ff    andl   $0xfffff7ff,0x218(%rbx)
    0.00 :	    1f13:       f7 ff ff 
    0.00 :	    1f16:       eb 90                   jmp    1ea8 <ixgbe_check_options+0xab6>
         :	                unsigned int rss = RSS[bd];
         :
         :	#ifdef module_param_array
         :	                if (num_RSS > bd) {
         :	#endif
         :	                        ixgbe_validate_option(&rss, &opt);
    0.00 :	    1f18:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1f1f:       00 
    0.00 :	    1f20:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
    0.00 :	    1f27:       e8 c4 f3 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        /* base it off num_online_cpus() with hardware limit */
         :	                        if (!rss)
    0.00 :	    1f2c:       8b 84 24 9c 00 00 00    mov    0x9c(%rsp),%eax
    0.00 :	    1f33:       85 c0                   test   %eax,%eax
    0.00 :	    1f35:       74 22                   je     1f59 <ixgbe_check_options+0xb67>
         :	                                rss = min_t(int, IXGBE_MAX_RSS_INDICES,
         :	                                            num_online_cpus());
         :	                        else
         :	                                feature[RING_F_FDIR].limit = rss;
    0.00 :	    1f37:       66 89 83 e0 0b 00 00    mov    %ax,0xbe0(%rbx)
         :
         :	                        feature[RING_F_RSS].limit = rss;
    0.00 :	    1f3e:       66 89 83 d8 0b 00 00    mov    %ax,0xbd8(%rbx)
    0.00 :	    1f45:       e9 d5 f5 ff ff          jmpq   151f <ixgbe_check_options+0x12d>
         :	                        if (opt.def == OPTION_DISABLED)
         :	                                *aflags &= ~IXGBE_FLAG_DCA_CAPABLE;
         :	                }
         :	#endif
         :	                if (dca == IXGBE_MAX_DCA)
         :	                        adapter->flags |= IXGBE_FLAG_DCA_ENABLED_DATA;
    0.00 :	    1f4a:       81 8b 18 02 00 00 00    orl    $0x100,0x218(%rbx)
    0.00 :	    1f51:       01 00 00 
    0.00 :	    1f54:       e9 9a f5 ff ff          jmpq   14f3 <ixgbe_check_options+0x101>
         :	                if (num_RSS > bd) {
         :	#endif
         :	                        ixgbe_validate_option(&rss, &opt);
         :	                        /* base it off num_online_cpus() with hardware limit */
         :	                        if (!rss)
         :	                                rss = min_t(int, IXGBE_MAX_RSS_INDICES,
    0.00 :	    1f59:       48 8b 3d 00 00 00 00    mov    0x0(%rip),%rdi        # 1f60 <ixgbe_check_options+0xb6e>
    0.00 :	    1f60:       e8 00 00 00 00          callq  1f65 <ixgbe_check_options+0xb73>
    0.00 :	    1f65:       ba 10 00 00 00          mov    $0x10,%edx
    0.00 :	    1f6a:       83 f8 10                cmp    $0x10,%eax
    0.00 :	    1f6d:       0f 4e d0                cmovle %eax,%edx
    0.00 :	    1f70:       89 94 24 9c 00 00 00    mov    %edx,0x9c(%rsp)
    0.00 :	    1f77:       89 d0                   mov    %edx,%eax
    0.00 :	    1f79:       eb c3                   jmp    1f3e <ixgbe_check_options+0xb4c>
         :	                unsigned int dca = opt.def;
         :
         :	#ifdef module_param_array
         :	                if (num_DCA > bd) {
         :	#endif
         :	                        dca = DCA[bd];
    0.00 :	    1f7b:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    1f82:       00 
         :	                        ixgbe_validate_option(&dca, &opt);
    0.00 :	    1f83:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    1f8a:       00 
    0.00 :	    1f8b:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                unsigned int dca = opt.def;
         :
         :	#ifdef module_param_array
         :	                if (num_DCA > bd) {
         :	#endif
         :	                        dca = DCA[bd];
    0.00 :	    1f92:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&dca, &opt);
    0.00 :	    1f99:       e8 52 f3 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (!dca)
    0.00 :	    1f9e:       44 8b 9c 24 9c 00 00    mov    0x9c(%rsp),%r11d
    0.00 :	    1fa5:       00 
    0.00 :	    1fa6:       45 85 db                test   %r11d,%r11d
    0.00 :	    1fa9:       75 0a                   jne    1fb5 <ixgbe_check_options+0xbc3>
         :	                                *aflags &= ~IXGBE_FLAG_DCA_CAPABLE;
    0.00 :	    1fab:       81 a3 18 02 00 00 7f    andl   $0xffffff7f,0x218(%rbx)
    0.00 :	    1fb2:       ff ff ff 
         :
         :	                        /* Check Interoperability */
         :	                        if (!(*aflags & IXGBE_FLAG_DCA_CAPABLE)) {
    0.00 :	    1fb5:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    1fbb:       84 c0                   test   %al,%al
    0.00 :	    1fbd:       78 12                   js     1fd1 <ixgbe_check_options+0xbdf>
         :	                                DPRINTK(PROBE, INFO, "DCA is disabled\n");
    0.00 :	    1fbf:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1fc6:       75 50                   jne    2018 <ixgbe_check_options+0xc26>
         :	                                *aflags &= ~IXGBE_FLAG_DCA_ENABLED;
    0.00 :	    1fc8:       83 e0 bf                and    $0xffffffbf,%eax
    0.00 :	    1fcb:       89 83 18 02 00 00       mov    %eax,0x218(%rbx)
         :	                        }
         :
         :	                        if (dca == IXGBE_MAX_DCA) {
    0.00 :	    1fd1:       83 bc 24 9c 00 00 00    cmpl   $0x2,0x9c(%rsp)
    0.00 :	    1fd8:       02 
    0.00 :	    1fd9:       0f 85 14 f5 ff ff       jne    14f3 <ixgbe_check_options+0x101>
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1fdf:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    1fe6:       75 54                   jne    203c <ixgbe_check_options+0xc4a>
         :	                                        "DCA enabled for rx data\n");
         :	                                adapter->flags |= IXGBE_FLAG_DCA_ENABLED_DATA;
    0.00 :	    1fe8:       81 8b 18 02 00 00 00    orl    $0x100,0x218(%rbx)
    0.00 :	    1fef:       01 00 00 
    0.00 :	    1ff2:       e9 ee f4 ff ff          jmpq   14e5 <ixgbe_check_options+0xf3>
         :	                }
         :	#endif
         :	                /* Check Interoperability */
         :	                if (rss > 1) {
         :	                        if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    1ff7:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    1ffe:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    2005:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    200c:       31 c0                   xor    %eax,%eax
    0.00 :	    200e:       e8 00 00 00 00          callq  2013 <ixgbe_check_options+0xc21>
    0.00 :	    2013:       e9 27 f5 ff ff          jmpq   153f <ixgbe_check_options+0x14d>
         :	                        if (!dca)
         :	                                *aflags &= ~IXGBE_FLAG_DCA_CAPABLE;
         :
         :	                        /* Check Interoperability */
         :	                        if (!(*aflags & IXGBE_FLAG_DCA_CAPABLE)) {
         :	                                DPRINTK(PROBE, INFO, "DCA is disabled\n");
    0.00 :	    2018:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    201f:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    2026:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    202d:       31 c0                   xor    %eax,%eax
    0.00 :	    202f:       e8 00 00 00 00          callq  2034 <ixgbe_check_options+0xc42>
    0.00 :	    2034:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    203a:       eb 8c                   jmp    1fc8 <ixgbe_check_options+0xbd6>
         :	                                *aflags &= ~IXGBE_FLAG_DCA_ENABLED;
         :	                        }
         :
         :	                        if (dca == IXGBE_MAX_DCA) {
         :	                                DPRINTK(PROBE, INFO,
    0.00 :	    203c:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    2043:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    204a:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    2051:       31 c0                   xor    %eax,%eax
    0.00 :	    2053:       e8 00 00 00 00          callq  2058 <ixgbe_check_options+0xc66>
    0.00 :	    2058:       eb 8e                   jmp    1fe8 <ixgbe_check_options+0xbf6>
         :	                }
         :	#endif
         :	                /* Check Interoperability */
         :	                if ((*aflags & IXGBE_FLAG_MQ_CAPABLE) &&
         :	                    !(*aflags & IXGBE_FLAG_MSIX_CAPABLE)) {
         :	                        DPRINTK(PROBE, INFO,
    0.00 :	    205a:       f6 83 a8 14 00 00 02    testb  $0x2,0x14a8(%rbx)
    0.00 :	    2061:       75 4f                   jne    20b2 <ixgbe_check_options+0xcc0>
         :	                                "Multiple queues are not supported while MSI-X "
         :	                                "is disabled.  Disabling Multiple Queues.\n");
         :	                        *aflags &= ~IXGBE_FLAG_MQ_CAPABLE;
    0.00 :	    2063:       80 e6 fd                and    $0xfd,%dh
    0.00 :	    2066:       89 93 18 02 00 00       mov    %edx,0x218(%rbx)
    0.00 :	    206c:       e9 44 f4 ff ff          jmpq   14b5 <ixgbe_check_options+0xc3>
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_MQ > bd) {
         :	#endif
         :	                        unsigned int mq = MQ[bd];
    0.00 :	    2071:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    2078:       00 
         :	                        ixgbe_validate_option(&mq, &opt);
    0.00 :	    2079:       48 8d bc 24 9c 00 00    lea    0x9c(%rsp),%rdi
    0.00 :	    2080:       00 
    0.00 :	    2081:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi
         :	                };
         :
         :	#ifdef module_param_array
         :	                if (num_MQ > bd) {
         :	#endif
         :	                        unsigned int mq = MQ[bd];
    0.00 :	    2088:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
         :	                        ixgbe_validate_option(&mq, &opt);
    0.00 :	    208f:       e8 5c f2 ff ff          callq  12f0 <ixgbe_validate_option>
         :	                        if (mq)
    0.00 :	    2094:       8b ac 24 9c 00 00 00    mov    0x9c(%rsp),%ebp
    0.00 :	    209b:       85 ed                   test   %ebp,%ebp
    0.00 :	    209d:       0f 84 f0 f3 ff ff       je     1493 <ixgbe_check_options+0xa1>
         :	                        else
         :	                                *aflags &= ~IXGBE_FLAG_MQ_CAPABLE;
         :	#ifdef module_param_array
         :	                } else {
         :	                        if (opt.def == OPTION_ENABLED)
         :	                                *aflags |= IXGBE_FLAG_MQ_CAPABLE;
    0.00 :	    20a3:       81 8b 18 02 00 00 00    orl    $0x200,0x218(%rbx)
    0.00 :	    20aa:       02 00 00 
    0.00 :	    20ad:       e9 eb f3 ff ff          jmpq   149d <ixgbe_check_options+0xab>
         :	                }
         :	#endif
         :	                /* Check Interoperability */
         :	                if ((*aflags & IXGBE_FLAG_MQ_CAPABLE) &&
         :	                    !(*aflags & IXGBE_FLAG_MSIX_CAPABLE)) {
         :	                        DPRINTK(PROBE, INFO,
    0.00 :	    20b2:       48 8b b3 00 02 00 00    mov    0x200(%rbx),%rsi
    0.00 :	    20b9:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx
    0.00 :	    20c0:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    20c7:       31 c0                   xor    %eax,%eax
    0.00 :	    20c9:       e8 00 00 00 00          callq  20ce <ixgbe_check_options+0xcdc>
    0.00 :	    20ce:       8b 93 18 02 00 00       mov    0x218(%rbx),%edx
    0.00 :	    20d4:       eb 8d                   jmp    2063 <ixgbe_check_options+0xc71>
         :	                        if (int_mode == OPTION_UNSET)
         :	                                int_mode = InterruptType[bd];
         :	                        ixgbe_validate_option(&int_mode, &opt);
         :	                        switch (int_mode) {
         :	                        case IXGBE_INT_MSIX:
         :	                                if (!(*aflags & IXGBE_FLAG_MSIX_CAPABLE))
    0.00 :	    20d6:       f6 83 18 02 00 00 04    testb  $0x4,0x218(%rbx)
    0.00 :	    20dd:       0f 85 96 f3 ff ff       jne    1479 <ixgbe_check_options+0x87>
         :	                                        printk(KERN_INFO
    0.00 :	    20e3:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    20ea:       31 c0                   xor    %eax,%eax
    0.00 :	    20ec:       e8 00 00 00 00          callq  20f1 <ixgbe_check_options+0xcff>
    0.00 :	    20f1:       e9 83 f3 ff ff          jmpq   1479 <ixgbe_check_options+0x87>
         :	                                               "Ignoring MSI-X setting; "
         :	                                               "support unavailable\n");
         :	                                break;
         :	                        case IXGBE_INT_MSI:
         :	                                if (!(*aflags & IXGBE_FLAG_MSI_CAPABLE)) {
    0.00 :	    20f6:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    20fc:       a8 01                   test   $0x1,%al
    0.00 :	    20fe:       74 22                   je     2122 <ixgbe_check_options+0xd30>
         :	                                        printk(KERN_INFO
         :	                                               "Ignoring MSI setting; "
         :	                                               "support unavailable\n");
         :	                                } else {
         :	                                        *aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
    0.00 :	    2100:       83 e0 fb                and    $0xfffffffb,%eax
    0.00 :	    2103:       89 83 18 02 00 00       mov    %eax,0x218(%rbx)
    0.00 :	    2109:       e9 6b f3 ff ff          jmpq   1479 <ixgbe_check_options+0x87>
         :	#ifdef module_param_array
         :	                if (num_IntMode > bd || num_InterruptType > bd) {
         :	#endif
         :	                        int_mode = IntMode[bd];
         :	                        if (int_mode == OPTION_UNSET)
         :	                                int_mode = InterruptType[bd];
    0.00 :	    210e:       42 8b 04 ad 00 00 00    mov    0x0(,%r13,4),%eax
    0.00 :	    2115:       00 
    0.00 :	    2116:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
    0.00 :	    211d:       e9 23 f3 ff ff          jmpq   1445 <ixgbe_check_options+0x53>
         :	                                               "Ignoring MSI-X setting; "
         :	                                               "support unavailable\n");
         :	                                break;
         :	                        case IXGBE_INT_MSI:
         :	                                if (!(*aflags & IXGBE_FLAG_MSI_CAPABLE)) {
         :	                                        printk(KERN_INFO
    0.00 :	    2122:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    2129:       31 c0                   xor    %eax,%eax
    0.00 :	    212b:       e8 00 00 00 00          callq  2130 <ixgbe_check_options+0xd3e>
    0.00 :	    2130:       e9 44 f3 ff ff          jmpq   1479 <ixgbe_check_options+0x87>
         :	        int bd = adapter->bd_number;
         :	        u32 *aflags = &adapter->flags;
         :	        struct ixgbe_ring_feature *feature = adapter->ring_feature;
         :
         :	        if (bd >= IXGBE_MAX_NIC) {
         :	                printk(KERN_NOTICE
    0.00 :	    2135:       44 89 e6                mov    %r12d,%esi
    0.00 :	    2138:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    213f:       31 c0                   xor    %eax,%eax
    0.00 :	    2141:       e8 00 00 00 00          callq  2146 <ixgbe_check_options+0xd54>
         :	                       "Warning: no configuration for board #%d\n", bd);
         :	                printk(KERN_NOTICE "Using defaults for all values\n");
    0.00 :	    2146:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
    0.00 :	    214d:       31 c0                   xor    %eax,%eax
    0.00 :	    214f:       e8 00 00 00 00          callq  2154 <ixgbe_check_options+0xd62>
    0.00 :	    2154:       e9 bb f2 ff ff          jmpq   1414 <ixgbe_check_options+0x22>
         :	                                break;
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        /* default settings */
         :	                        if (opt.def == IXGBE_INT_MSIX &&
    0.00 :	    2159:       8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 215f <ixgbe_check_options+0xd6d>
    0.00 :	    215f:       83 fa 02                cmp    $0x2,%edx
    0.00 :	    2162:       74 1c                   je     2180 <ixgbe_check_options+0xd8e>
         :	                            *aflags & IXGBE_FLAG_MSIX_CAPABLE) {
         :	                                *aflags |= IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
         :	                        } else if (opt.def == IXGBE_INT_MSI &&
    0.00 :	    2164:       83 ea 01                sub    $0x1,%edx
         :	                                break;
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        /* default settings */
         :	                        if (opt.def == IXGBE_INT_MSIX &&
    0.00 :	    2167:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
         :	                            *aflags & IXGBE_FLAG_MSIX_CAPABLE) {
         :	                                *aflags |= IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
         :	                        } else if (opt.def == IXGBE_INT_MSI &&
    0.00 :	    216d:       74 2c                   je     219b <ixgbe_check_options+0xda9>
         :	                            *aflags & IXGBE_FLAG_MSI_CAPABLE) {
         :	                                *aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
         :	                        } else {
         :	                                *aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags &= ~IXGBE_FLAG_MSI_CAPABLE;
    0.00 :	    216f:       83 e0 fa                and    $0xfffffffa,%eax
    0.00 :	    2172:       4d 63 ec                movslq %r12d,%r13
    0.00 :	    2175:       89 83 18 02 00 00       mov    %eax,0x218(%rbx)
    0.00 :	    217b:       e9 f9 f2 ff ff          jmpq   1479 <ixgbe_check_options+0x87>
         :	                                break;
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        /* default settings */
         :	                        if (opt.def == IXGBE_INT_MSIX &&
    0.00 :	    2180:       8b 83 18 02 00 00       mov    0x218(%rbx),%eax
    0.00 :	    2186:       a8 04                   test   $0x4,%al
    0.00 :	    2188:       74 e5                   je     216f <ixgbe_check_options+0xd7d>
         :	                            *aflags & IXGBE_FLAG_MSIX_CAPABLE) {
         :	                                *aflags |= IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
    0.00 :	    218a:       83 c8 05                or     $0x5,%eax
    0.00 :	    218d:       4d 63 ec                movslq %r12d,%r13
    0.00 :	    2190:       89 83 18 02 00 00       mov    %eax,0x218(%rbx)
         :	                                break;
         :	                        }
         :	#ifdef module_param_array
         :	                } else {
         :	                        /* default settings */
         :	                        if (opt.def == IXGBE_INT_MSIX &&
    0.00 :	    2196:       e9 de f2 ff ff          jmpq   1479 <ixgbe_check_options+0x87>
         :	                            *aflags & IXGBE_FLAG_MSIX_CAPABLE) {
         :	                                *aflags |= IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
         :	                        } else if (opt.def == IXGBE_INT_MSI &&
    0.00 :	    219b:       a8 01                   test   $0x1,%al
    0.00 :	    219d:       74 d0                   je     216f <ixgbe_check_options+0xd7d>
         :	                            *aflags & IXGBE_FLAG_MSI_CAPABLE) {
         :	                                *aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
    0.00 :	    219f:       83 e0 fb                and    $0xfffffffb,%eax
    0.00 :	    21a2:       4d 63 ec                movslq %r12d,%r13
    0.00 :	    21a5:       83 c8 01                or     $0x1,%eax
    0.00 :	    21a8:       89 83 18 02 00 00       mov    %eax,0x218(%rbx)
         :	                        /* default settings */
         :	                        if (opt.def == IXGBE_INT_MSIX &&
         :	                            *aflags & IXGBE_FLAG_MSIX_CAPABLE) {
         :	                                *aflags |= IXGBE_FLAG_MSIX_CAPABLE;
         :	                                *aflags |= IXGBE_FLAG_MSI_CAPABLE;
         :	                        } else if (opt.def == IXGBE_INT_MSI &&
  100.00 :	    21ae:       e9 c6 f2 ff ff          jmpq   1479 <ixgbe_check_options+0x87>

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/net/netfilter/nf_conntrack.ko
----------------------------------------------

   50.00 ??:0
   50.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/net/netfilter/nf_conntrack.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000006a40 <tcp_in_window>:
    0.00 :	    6a40:       41 57                   push   %r15
    0.00 :	    6a72:       49 89 fa 41             mov    %ecx,0x2c(%rsp)
    0.00 :	    6a76:       56 41 55 41 54 55 48    mov    0xe0(%rsp),%rcx
    0.00 :	    6a7d:       89 
    0.00 :	    6a7e:       f5 53 48 81             mov    %al,0x2b(%rsp)
    0.00 :	    6a82:       ec a8 00 00 00 89 54    mov    0xe8(%rdi),%rdx
    0.00 :	    6a89:       24 40 0f                sbb    %rax,%rax
    0.00 :	    6a8c:       b6 84 24                and    $0x14,%eax
    0.00 :	    6a8f:       e8 00 00 00             lea    (%rsi,%rax,1),%r13
    0.00 :	    6a93:       83 7c 24 40 01 89 4c    mov    0xe0(%rsp),%rax
    0.00 :	    6a9a:       24 
    0.00 :	    6a9b:       3c 4c 89 44 24          mov    %rdx,0x48(%rsp)
    0.00 :	    6aa0:       30 44 89                mov    0x4(%rcx),%ecx
    0.00 :	    6aa3:       4c 24                   bswap  %ecx
    0.00 :	    6aa5:       2c 48 8b                mov    %rax,%rdx
    0.00 :	    6aa8:       8c 24 e0 00             mov    %ecx,0x50(%rsp)
    0.00 :	    6aac:       00 00 88 44             mov    0x8(%rax),%r12d
    0.00 :	    6ab0:       24 2b 48 8b             movzwl 0xe(%rax),%eax
    0.00 :	    6ab4:       97 e8 00                bswap  %r12d
    0.00 :	    6ab7:       00 00 48 19             rol    $0x8,%ax
    0.00 :	    6abb:       c0 83 e0                movzwl %ax,%eax
    0.00 :	    6abe:       14 4c 8d 2c             mov    %eax,0x58(%rsp)
    0.00 :	    6ac2:       06 48 8b 84             mov    0x68(%r8),%ecx
    0.00 :	    6ac6:       24 e0 00 00             mov    %ecx,0x44(%rsp)
    0.00 :	    6aca:       00 48 89 54 24          movzbl 0xc(%rdx),%r14d
    0.00 :	    6acf:       48 8b 49 04             movzbl 0xd(%rdx),%eax
    0.00 :	    6ad3:       0f c9 48 89             shr    $0x4,%r14b
    0.00 :	    6ad7:       c2 89 4c 24             mov    %al,0x60(%rsp)
    0.00 :	    6adb:       50 44 8b 60 08          testb  $0x2,0x11(%r13)
    0.00 :	    6ae0:       0f b7                   je     6af5 <nf_conntrack_hash_insert+0x69e5>
    0.00 :	    6ae2:       40 0e 41 0f             movzbl %r14b,%eax
    0.00 :	    6ae6:       cc 66 c1 c0 08 0f b7    lea    -0x14(,%rax,4),%ebx
    0.00 :	    6aed:       c0 89                   test   %ebx,%ebx
    0.00 :	    6aef:       44 24 58 41 8b 48       jne    6d60 <nf_conntrack_hash_insert+0x6c50>
    0.00 :	    6af5:       68 89 4c                mov    %r12d,%ebx
    0.00 :	    6af8:       24 44 44 0f b6          cmpb   $0x2,0x2b(%rsp)
    0.00 :	    6afd:       72 0c 0f b6 42 0d       je     6e80 <nf_conntrack_hash_insert+0x6d70>
    0.00 :	    6b03:       41 c0 ee 04 88 44 24    movw   $0x0,0x5e(%rsp)
    0.00 :	    6b0a:       60 41                   xor    %eax,%eax
    0.00 :	    6b0c:       f6 45 11                mov    %ebx,%r15d
    0.00 :	    6b0f:       02 74 13                sub    %eax,%r12d
    0.00 :	    6b12:       41 0f b6                sub    %eax,%r15d
    0.00 :	    6b15:       c6 8d 1c 85 ec ff ff    cmpb   $0x0,0x0(%rip)        # 6b1c <nf_conntrack_hash_insert+0x6a0c>
    0.00 :	    6b1c:       ff 85 db 0f 85          mov    %r12d,0x54(%rsp)
    0.00 :	    6b21:       6b 02 00 00 44 89       jne    73ce <nf_conntrack_hash_insert+0x72be>
    0.00 :	    6b27:       e3 80 7c 24 2b 02 0f    cmpb   $0x0,0x0(%rip)        # 6b2e <nf_conntrack_hash_insert+0x6a1e>
    0.00 :	    6b2e:       84 7d 03 00 00 66       jne    72a0 <nf_conntrack_hash_insert+0x7190>
    0.00 :	    6b34:       c7 44 24 5e 00          movzbl 0x60(%rsp),%eax
    0.00 :	    6b39:       00 31 c0 41 89          movzbl 0x60(%rsp),%edx
    0.00 :	    6b3e:       df 41                   shr    %al
    0.00 :	    6b40:       29 c4 41                and    $0x1,%edx
    0.00 :	    6b43:       29 c7 80                and    $0x1,%eax
    0.00 :	    6b46:       3d 00                   add    %edx,%eax
    0.00 :	    6b48:       00 00 00 00             add    0x44(%rsp),%eax
    0.00 :	    6b4c:       44 89 64 24             movzbl %r14b,%edx
    0.00 :	    6b50:       54 0f 85                shl    $0x2,%edx
    0.00 :	    6b53:       a7 08 00 00 80          mov    0x50(%rsp),%r14d
    0.00 :	    6b58:       3d 00                   sub    %edx,%eax
    0.00 :	    6b5a:       00 00 00 00             sub    0x2c(%rsp),%eax
    0.00 :	    6b5e:       0f 85 6c                add    %eax,%r14d
    0.00 :	    6b61:       07 00 00 0f b6 44 24    cmpb   $0x0,0x0(%rip)        # 6b68 <nf_conntrack_hash_insert+0x6a58>
    0.00 :	    6b68:       60 0f b6 54 24 60       jne    7264 <nf_conntrack_hash_insert+0x7154>
    0.00 :	    6b6e:       d0 e8 83 e2 01 83 e0    cmpb   $0x0,0x0(%rip)        # 6b75 <nf_conntrack_hash_insert+0x6a65>
    0.00 :	    6b75:       01 01 d0 03 44          mov    0x40(%rsp),%r12d
    0.00 :	    6b7a:       24 44 41 0f b6 d6       jne    72ba <nf_conntrack_hash_insert+0x71aa>
    0.00 :	    6b80:       c1 e2 02 44             lea    (%r12,%r12,4),%rax
    0.00 :	    6b84:       8b 74 24 50 29          lea    0x0(%rbp,%rax,4),%rbx
    0.00 :	    6b89:       d0 2b 44                mov    0x8(%rbx),%esi
    0.00 :	    6b8c:       24 2c                   test   %esi,%esi
    0.00 :	    6b8e:       41 01 c6 80 3d 00       jne    6cf0 <nf_conntrack_hash_insert+0x6be0>
    0.00 :	    6b94:       00 00 00 00 0f 85 f6    mov    0xe0(%rsp),%rcx
    0.00 :	    6b9b:       06 
    0.00 :	    6b9c:       00 00 80 3d             testb  $0x2,0xd(%rcx)
    0.00 :	    6ba0:       00 00 00 00 00 44       je     6de0 <nf_conntrack_hash_insert+0x6cd0>
    0.00 :	    6ba6:       8b 64 24 40             mov    %r14d,0x4(%rbx)
    0.00 :	    6baa:       0f 85 3a 07 00          mov    %r14d,0x0(%rbp,%rax,4)
    0.00 :	    6baf:       00 4b 8d 04 a4          mov    $0x1,%eax
    0.00 :	    6bb4:       48 8d 5c 85             mov    0x58(%rsp),%ecx
    0.00 :	    6bb8:       00 8b                   test   %ecx,%ecx
    0.00 :	    6bba:       73 08 85 f6 0f          cmovne 0x58(%rsp),%eax
    0.00 :	    6bbf:       85 5c 01                mov    %rbx,%rcx
    0.00 :	    6bc2:       00 00 48                mov    %eax,0x8(%rbx)
    0.00 :	    6bc5:       8b 8c 24 e0 00 00 00    mov    0xe0(%rsp),%rdx
    0.00 :	    6bcc:       f6 
    0.00 :	    6bcd:       41 0d 02 0f             mov    0x2c(%rsp),%esi
    0.00 :	    6bd1:       84 3a 02 00 00          mov    0x30(%rsp),%rdi
    0.00 :	    6bd6:       44 89 73 04 44          callq  68c0 <nf_conntrack_hash_insert+0x67b0>
    0.00 :	    6bdb:       89 74 85 00             testb  $0x1,0x11(%rbx)
    0.00 :	    6bdf:       b8 01 00 00 00 8b       jne    7080 <nf_conntrack_hash_insert+0x6f70>
    0.00 :	    6be5:       4c 24 58 85             lea    (%r12,%r12,4),%rax
    0.00 :	    6be9:       c9 0f 45 44 24          movb   $0x0,0x10(%r13)
    0.00 :	    6bee:       58 48 89 d9 89          movb   $0x0,0x10(%rbp,%rax,4)
    0.00 :	    6bf3:       43 08 48 8b 94 24 e0    mov    0xe0(%rsp),%rax
    0.00 :	    6bfa:       00 
    0.00 :	    6bfb:       00 00 8b 74 24          mov    $0x1,%ebx
    0.00 :	    6c00:       2c 48 8b 7c             movzbl 0xd(%rax),%edx
    0.00 :	    6c04:       24 30 e8                test   $0x10,%dl
    0.00 :	    6c07:       e5 fc ff ff f6 43       je     6cda <nf_conntrack_hash_insert+0x6bca>
    0.00 :	    6c0d:       11 01 0f 85 9b 04 00    mov    0xe0(%rsp),%rcx
    0.00 :	    6c14:       00 
    0.00 :	    6c15:       4b 8d 04                mov    0xc(%rcx),%eax
    0.00 :	    6c18:       a4 41 c6 45 10          and    $0x1400,%eax
    0.00 :	    6c1d:       00 c6 44 85 10          cmp    $0x1400,%eax
    0.00 :	    6c22:       00 48 8b 84 24 e0       jne    6d26 <nf_conntrack_hash_insert+0x6c16>
    0.00 :	    6c28:       00 00 00 bb 01          mov    0x54(%rsp),%r8d
    0.00 :	    6c2d:       00 00 00                test   %r8d,%r8d
    0.00 :	    6c30:       0f b6 50 0d f6 c2       je     6d1d <nf_conntrack_hash_insert+0x6c0d>
    0.00 :	    6c36:       10 0f 84                and    $0x4,%edx
    0.00 :	    6c39:       cd 00 00 00 48 8b       jne    6d2f <nf_conntrack_hash_insert+0x6c1f>
    0.00 :	    6c3f:       8c                      nop
    0.00 :	    6c40:       24 e0 00 00 00 8b 41    cmpb   $0x0,0x0(%rip)        # 6c47 <nf_conntrack_hash_insert+0x6b37>
    0.00 :	    6c47:       0c 25 00 14 00 00       jne    7325 <nf_conntrack_hash_insert+0x7215>
    0.00 :	    6c4d:       3d 00 14 00 00 0f 85    cmpb   $0x0,0x0(%rip)        # 6c54 <nf_conntrack_hash_insert+0x6b44>
    0.00 :	    6c54:       fe 00 00 00 44 8b       jne    733f <nf_conntrack_hash_insert+0x722f>
    0.00 :	    6c5a:       44 24 54 45 85 c0 0f    cmpb   $0x0,0x0(%rip)        # 6c61 <nf_conntrack_hash_insert+0x6b51>
    0.00 :	    6c61:       84 e7 00 00 00 83       jne    737b <nf_conntrack_hash_insert+0x726b>
    0.00 :	    6c67:       e2 04 0f 85 f0 00 00    cmpb   $0x0,0x0(%rip)        # 6c6e <nf_conntrack_hash_insert+0x6b5e>
    0.00 :	    6c6e:       00 90 80 3d 00 00       jne    73e8 <nf_conntrack_hash_insert+0x72d8>
    0.00 :	    6c74:       00 00 00 0f             lea    (%r12,%r12,4),%rdx
    0.00 :	    6c78:       85 d8 06 00 00          mov    $0xffffffff,%eax
    0.00 :	    6c7d:       80 3d 00 00 00          lea    0x0(%rbp,%rdx,4),%rcx
    0.00 :	    6c82:       00 00 0f                sub    0x4(%rcx),%eax
    0.00 :	    6c85:       85 e5 06 00             add    0x50(%rsp),%eax
    0.00 :	    6c89:       00 80 3d 00 00 00       js     6eb0 <nf_conntrack_hash_insert+0x6da0>
    0.00 :	    6c8f:       00 00 0f 85             lea    (%r12,%r12,4),%rax
    0.00 :	    6c93:       14 07 00 00 80          testb  $0x8,0x11(%rbp,%rax,4)
    0.00 :	    6c98:       3d 00 00 00 00 00       jne    6e20 <nf_conntrack_hash_insert+0x6d10>
    0.00 :	    6c9e:       0f 85 74 07 00 00       mov    0x0(%rip),%ecx        # 6ca4 <nf_conntrack_hash_insert+0x6b94>
    0.00 :	    6ca4:       4b 8d                   test   %ecx,%ecx
    0.00 :	    6ca6:       14 a4 b8 ff ff ff       jne    6e20 <nf_conntrack_hash_insert+0x6d10>
    0.00 :	    6cac:       ff 48 8d 4c 95          mov    0x48(%rsp),%rcx
    0.00 :	    6cb1:       00 2b 41 04 03 44       mov    0x75c(%rcx),%eax
    0.00 :	    6cb7:       24 50 0f                cmp    $0x6,%eax
    0.00 :	    6cba:       88 21 02 00 00 4b       je     7098 <nf_conntrack_hash_insert+0x6f88>
    0.00 :	    6cc0:       8d 04 a4 f6 44          cmp    $0xff,%eax
    0.00 :	    6cc5:       85 11 08 0f 85 82       je     7098 <nf_conntrack_hash_insert+0x6f88>
    0.00 :	    6ccb:       01 00                   xor    %ebx,%ebx
    0.00 :	    6ccd:       00 8b 0d 00 00 00 00    cmpb   $0x0,0x0(%rip)        # 6cd4 <nf_conntrack_hash_insert+0x6bc4>
    0.00 :	    6cd4:       85 c9 0f 85 74 01       jne    6e32 <nf_conntrack_hash_insert+0x6d22>
    0.00 :	    6cda:       00 00 48 8b 4c 24 48    add    $0xa8,%rsp
    0.00 :	    6ce1:       8b 81                   mov    %ebx,%eax
    0.00 :	    6ce3:       5c                      pop    %rbx
    0.00 :	    6ce4:       07                      pop    %rbp
    0.00 :	    6ce5:       00 00                   pop    %r12
    0.00 :	    6ce7:       83 f8                   pop    %r13
    0.00 :	    6ce9:       06 0f                   pop    %r14
    0.00 :	    6ceb:       84 d8                   pop    %r15
    0.00 :	    6ced:       03                      retq   
    0.00 :	    6cee:       00 00                   xchg   %ax,%ax
    0.00 :	    6cf0:       3d ff 00 00             movzbl 0x28(%rbp),%eax
    0.00 :	    6cf4:       00 0f                   cmp    $0x1,%al
    0.00 :	    6cf6:       84 cd 03 00 00 31       je     7010 <nf_conntrack_hash_insert+0x6f00>
    0.00 :	    6cfc:       db 80                   cmp    $0x2,%al
    0.00 :	    6cfe:       3d 00 00 00 00 00       je     7118 <nf_conntrack_hash_insert+0x7008>
    0.00 :	    6d04:       0f 85 58 01             nopl   0x0(%rax)
    0.00 :	    6d08:       00 00 48 81 c4 a8 00    mov    0xe0(%rsp),%rcx
    0.00 :	    6d0f:       00 
    0.00 :	    6d10:       00 89 d8 5b             movzbl 0xd(%rcx),%edx
    0.00 :	    6d14:       5d 41 5c                test   $0x10,%dl
    0.00 :	    6d17:       41 5d 41 5e 41 5f       jne    6c0d <nf_conntrack_hash_insert+0x6afd>
    0.00 :	    6d1d:       c3 66 90 0f             mov    0x0(%r13),%r15d
    0.00 :	    6d21:       b6 45 28 3c 01          mov    %r15d,0x54(%rsp)
    0.00 :	    6d26:       0f 84 14                and    $0x4,%edx
    0.00 :	    6d29:       03 00 00 3c 02 0f       je     6c40 <nf_conntrack_hash_insert+0x6b30>
    0.00 :	    6d2f:       84 14 04 00             mov    0x50(%rsp),%edi
    0.00 :	    6d33:       00 0f                   test   %edi,%edi
    0.00 :	    6d35:       1f 40 00 48 8b 8c       jne    6c40 <nf_conntrack_hash_insert+0x6b30>
    0.00 :	    6d3b:       24 e0 00 00             cmpb   $0x1,0x28(%rbp)
    0.00 :	    6d3f:       00 0f b6 51 0d f6       jne    6c40 <nf_conntrack_hash_insert+0x6b30>
    0.00 :	    6d45:       c2 10 0f 85             lea    (%r12,%r12,4),%rax
    0.00 :	    6d49:       f0 fe ff ff 45          mov    0x0(%rbp,%rax,4),%r14d
    0.00 :	    6d4e:       8b 7d 00 44 89          mov    %r14d,0x50(%rsp)
    0.00 :	    6d53:       7c 24 54 83 e2          jmpq   6c40 <nf_conntrack_hash_insert+0x6b30>
    0.00 :	    6d58:       04 0f 84 11 ff ff ff    nopl   0x0(%rax,%rax,1)
    0.00 :	    6d5f:       8b 
    0.00 :	    6d60:       7c 24                   mov    %ecx,%eax
    0.00 :	    6d62:       50 85 ff 0f             sub    0x6c(%r8),%eax
    0.00 :	    6d66:       85 05 ff                mov    %r9d,%esi
    0.00 :	    6d69:       ff ff 80                add    $0x14,%esi
    0.00 :	    6d6c:       7d 28                   sub    %esi,%eax
    0.00 :	    6d6e:       01 0f                   cmp    %eax,%ebx
    0.00 :	    6d70:       85 fb fe ff ff 4b       jg     7130 <nf_conntrack_hash_insert+0x7020>
    0.00 :	    6d76:       8d 04 a4                movslq %esi,%rax
    0.00 :	    6d79:       44 8b 74 85 00 44 89    add    0xe0(%r8),%rax
    0.00 :	    6d80:       74 24 50                test   %rax,%rax
    0.00 :	    6d83:       e9 e8 fe                mov    %rax,%rdx
    0.00 :	    6d86:       ff ff 0f 1f 84 00       je     7160 <nf_conntrack_hash_insert+0x7050>
    0.00 :	    6d8c:       00 00 00                cmp    $0x30,%ebx
    0.00 :	    6d8f:       00 89 c8 41 2b 40       je     7100 <nf_conntrack_hash_insert+0x6ff0>
    0.00 :	    6d95:       6c 44                   test   %ebx,%ebx
    0.00 :	    6d97:       89 ce 83 c6 14 29       jle    6af5 <nf_conntrack_hash_insert+0x69e5>
    0.00 :	    6d9d:       f0 39 c3                movzbl (%rdx),%eax
    0.00 :	    6da0:       0f 8f ba 03             add    $0x1,%rdx
    0.00 :	    6da4:       00 00                   test   %al,%al
    0.00 :	    6da6:       48 63 c6 49 03 80       je     6af5 <nf_conntrack_hash_insert+0x69e5>
    0.00 :	    6dac:       e0 00                   cmp    $0x1,%al
    0.00 :	    6dae:       00 00 48 85 c0 48       je     7000 <nf_conntrack_hash_insert+0x6ef0>
    0.00 :	    6db4:       89 c2 0f                movzbl (%rdx),%ecx
    0.00 :	    6db7:       84 d4 03                cmp    $0x1,%ecx
    0.00 :	    6dba:       00 00 83 fb 30 0f       jle    6af5 <nf_conntrack_hash_insert+0x69e5>
    0.00 :	    6dc0:       84 6b 03 00             add    $0x1,%rdx
    0.00 :	    6dc4:       00 85                   cmp    %ecx,%ebx
    0.00 :	    6dc6:       db 0f                   jl     6d95 <nf_conntrack_hash_insert+0x6c85>
    0.00 :	    6dc8:       8e 58                   cmp    $0x5,%al
    0.00 :	    6dca:       fd ff ff 0f b6 02       je     71d0 <nf_conntrack_hash_insert+0x70c0>
    0.00 :	    6dd0:       48 83 c2                movslq %ecx,%rax
    0.00 :	    6dd3:       01 84                   sub    %ecx,%ebx
    0.00 :	    6dd5:       c0 0f 84 49 fd          lea    -0x2(%rdx,%rax,1),%rdx
    0.00 :	    6dda:       ff ff                   jmp    6d95 <nf_conntrack_hash_insert+0x6c85>
    0.00 :	    6ddc:       3c 01 0f 84             nopl   0x0(%rax)
    0.00 :	    6de0:       4c 02 00 00 0f          mov    %r14d,0x0(%rbp,%rax,4)
    0.00 :	    6de5:       b6 0a 83 f9             movzbl 0x10(%rbx),%ecx
    0.00 :	    6de9:       01 0f 8e 35 fd          mov    $0x1,%eax
    0.00 :	    6dee:       ff ff 48 83             shll   %cl,0x58(%rsp)
    0.00 :	    6df2:       c2 01 39 cb             mov    0x58(%rsp),%edx
    0.00 :	    6df6:       7c cd                   test   %edx,%edx
    0.00 :	    6df8:       3c 05 0f 84 00          cmovne 0x58(%rsp),%eax
    0.00 :	    6dfd:       04 00 00                mov    %eax,0x8(%rbx)
    0.00 :	    6e00:       48 63 c1                add    %r14d,%eax
    0.00 :	    6e03:       29 cb 48                mov    %eax,0x4(%rbx)
    0.00 :	    6e06:       8d 54 02 fe             mov    0x8(%r13),%r11d
    0.00 :	    6e0a:       eb b9 0f                test   %r11d,%r11d
    0.00 :	    6e0d:       1f 40 00 44 89 74       jne    6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    6e13:       85 00 0f b6             mov    %r15d,0x4(%r13)
    0.00 :	    6e17:       4b 10 b8 01             mov    %r15d,0x0(%r13)
    0.00 :	    6e1b:       00 00 00 d3 64          jmpq   6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    6e20:       24 58 8b 54 24          mov    $0x1,%ebx
    0.00 :	    6e25:       58 85 d2 0f 45 44 24    cmpb   $0x0,0x0(%rip)        # 6e2c <nf_conntrack_hash_insert+0x6d1c>
    0.00 :	    6e2c:       58 89 43 08 44 01       je     6cda <nf_conntrack_hash_insert+0x6bca>
    0.00 :	    6e32:       f0 89 43 04             lea    (%r12,%r12,4),%rax
    0.00 :	    6e36:       45 8b 5d                movzbl %bl,%edx
    0.00 :	    6e39:       08 45 85 db 0f 85 f5    mov    $0x0,%rdi
    0.00 :	    6e40:       fe ff ff 45 89          lea    0x0(%rbp,%rax,4),%rsi
    0.00 :	    6e45:       7d 04 45 89             mov    0x0(%rbp,%rax,4),%ecx
    0.00 :	    6e49:       7d 00 e9 e8             mov    0x8(%r13),%eax
    0.00 :	    6e4d:       fe ff ff bb             mov    %eax,0x10(%rsp)
    0.00 :	    6e51:       01 00 00 00             mov    0x4(%r13),%eax
    0.00 :	    6e55:       80 3d 00 00             mov    %eax,0x8(%rsp)
    0.00 :	    6e59:       00 00 00 0f             mov    0x0(%r13),%eax
    0.00 :	    6e5d:       84 a8 fe                mov    %eax,(%rsp)
    0.00 :	    6e60:       ff ff 4b 8d             mov    0x8(%rsi),%r9d
    0.00 :	    6e64:       04 a4                   xor    %eax,%eax
    0.00 :	    6e66:       0f b6 d3 48             mov    0x4(%rsi),%r8d
    0.00 :	    6e6a:       c7 c7 00 00 00 00 48    mov    $0x0,%rsi
    0.00 :	    6e71:       8d 74 85 00 8b          callq  6e76 <nf_conntrack_hash_insert+0x6d66>
    0.00 :	    6e76:       4c 85 00 41 8b          jmpq   6cda <nf_conntrack_hash_insert+0x6bca>
    0.00 :	    6e7b:       45 08 89 44 24          nopl   0x0(%rax,%rax,1)
    0.00 :	    6e80:       10 41 8b 45 04 89 44    mov    0x0(%rip),%rax        # 6e87 <nf_conntrack_hash_insert+0x6d77>
    0.00 :	    6e87:       24 08 41                test   %rax,%rax
    0.00 :	    6e8a:       8b 45 00 89 04 24       je     6b03 <nf_conntrack_hash_insert+0x69f3>
    0.00 :	    6e90:       44 8b                   xor    %esi,%esi
    0.00 :	    6e92:       4e 08 31 c0 44          cmpl   $0x0,0x40(%rsp)
    0.00 :	    6e97:       8b 46 04 48 c7          lea    -0x1(%r12),%edx
    0.00 :	    6e9c:       c6 00 00                mov    %r10,%rdi
    0.00 :	    6e9f:       00 00 e8 00             sete   %sil
    0.00 :	    6ea3:       00 00                   callq  *%rax
    0.00 :	    6ea5:       00 e9 5f fe ff          mov    %ax,0x5e(%rsp)
    0.00 :	    6eaa:       ff                      cwtl   
    0.00 :	    6eab:       0f 1f 44 00 00          jmpq   6b0c <nf_conntrack_hash_insert+0x69fc>
    0.00 :	    6eb0:       48 8b 05 00             mov    0x0(%rbp,%rdx,4),%edi
    0.00 :	    6eb4:       00 00 00                lea    -0x1(%rdi),%eax
    0.00 :	    6eb7:       48 85 c0 0f             sub    0x8(%r13),%eax
    0.00 :	    6ebb:       84 73 fc                cmp    %r14d,%eax
    0.00 :	    6ebe:       ff ff 31 f6 83 7c       jns    6c8f <nf_conntrack_hash_insert+0x6b7f>
    0.00 :	    6ec4:       24 40 00 41             mov    0x0(%r13),%edx
    0.00 :	    6ec8:       8d 54                   mov    %edx,%eax
    0.00 :	    6eca:       24 ff                   not    %eax
    0.00 :	    6ecc:       4c 89 d7                add    %r15d,%eax
    0.00 :	    6ecf:       40 0f 94 c6 ff d0       jns    6c8f <nf_conntrack_hash_insert+0x6b7f>
    0.00 :	    6ed5:       66 89 44                mov    0x8(%rcx),%esi
    0.00 :	    6ed8:       24 5e 98                sub    $0x1,%edx
    0.00 :	    6edb:       e9 5c fc ff ff          mov    $0x101d0,%eax
    0.00 :	    6ee0:       8b 7c 95 00 8d 47       cmp    $0x101d0,%esi
    0.00 :	    6ee6:       ff 41 2b                cmovae %esi,%eax
    0.00 :	    6ee9:       45 08                   sub    %eax,%edx
    0.00 :	    6eeb:       44 39 f0                cmp    %r15d,%edx
    0.00 :	    6eee:       0f 89 cb fd ff ff       jns    6c8f <nf_conntrack_hash_insert+0x6b7f>
    0.00 :	    6ef4:       41 8b 55 00 89 d0 f7    mov    0xe0(%rsp),%rdx
    0.00 :	    6efb:       d0 
    0.00 :	    6efc:       44 01 f8 0f             testb  $0x2,0xd(%rdx)
    0.00 :	    6f00:       89 ba                   jne    6f0a <nf_conntrack_hash_insert+0x6dfa>
    0.00 :	    6f02:       fd ff ff 8b             movzbl 0x10(%rcx),%ecx
    0.00 :	    6f06:       71 08 83 ea             shll   %cl,0x58(%rsp)
    0.00 :	    6f0a:       01 b8 d0                mov    %r15d,%eax
    0.00 :	    6f0d:       01 01 00 81             sub    0x54(%rsp),%eax
    0.00 :	    6f11:       fe d0 01 01             mov    0x58(%rsp),%ecx
    0.00 :	    6f15:       00 0f 43                lea    (%rax,%rcx,1),%edx
    0.00 :	    6f18:       c6 29                   cmp    %edx,%esi
    0.00 :	    6f1a:       c2 44                   jae    6f28 <nf_conntrack_hash_insert+0x6e18>
    0.00 :	    6f1c:       39 fa 0f 89             lea    (%r12,%r12,4),%rax
    0.00 :	    6f20:       9b fd ff ff             mov    0x0(%rbp,%rax,4),%edi
    0.00 :	    6f24:       48 8b 94 24             mov    %edx,0x8(%rbp,%rax,4)
    0.00 :	    6f28:       e0 00 00                cmp    %r14d,%edi
    0.00 :	    6f2b:       00 f6                   jns    6f3b <nf_conntrack_hash_insert+0x6e2b>
    0.00 :	    6f2d:       42 0d 02 75             lea    (%r12,%r12,4),%rax
   50.00 :	    6f31:       08 0f b6 49 10          orb    $0x10,0x11(%rbp,%rax,4)
    0.00 :	    6f36:       d3 64 24 58 44          mov    %r14d,0x0(%rbp,%rax,4)
    0.00 :	    6f3b:       89 f8 2b 44 24 54 8b    mov    0xe0(%rsp),%rax
    0.00 :	    6f42:       4c 
    0.00 :	    6f43:       24 58 8d 14             testb  $0x10,0xd(%rax)
    0.00 :	    6f47:       08 39                   je     6f6b <nf_conntrack_hash_insert+0x6e5b>
    0.00 :	    6f49:       d6 73 0c 4b             lea    (%r12,%r12,4),%rax
    0.00 :	    6f4d:       8d 04 a4 8b 7c          lea    0x0(%rbp,%rax,4),%rdx
    0.00 :	    6f52:       85 00 89 54             lea    0x10(%rdx),%rax
    0.00 :	    6f56:       85 08 44 39             testb  $0x20,0x1(%rax)
    0.00 :	    6f5a:       f7 79 0e 4b 8d 04       jne    730d <nf_conntrack_hash_insert+0x71fd>
    0.00 :	    6f60:       a4 80 4c 85             mov    0x54(%rsp),%ecx
    0.00 :	    6f64:       11 10 44                mov    %ecx,0xc(%rdx)
    0.00 :	    6f67:       89 74 85 00             orb    $0x20,0x1(%rax)
    0.00 :	    6f6b:       48 8b 84 24             mov    0x8(%r13),%edx
    0.00 :	    6f6f:       e0 00                   test   %edx,%edx
    0.00 :	    6f71:       00 00                   je     6f8a <nf_conntrack_hash_insert+0x6e7a>
    0.00 :	    6f73:       f6 40 0d 10             lea    (%r12,%r12,4),%rax
    0.00 :	    6f77:       74 22 4b 8d             mov    0x4(%rbp,%rax,4),%eax
    0.00 :	    6f7b:       04 a4 48                cmp    %r14d,%eax
    0.00 :	    6f7e:       8d 54                   jns    6f8a <nf_conntrack_hash_insert+0x6e7a>
    0.00 :	    6f80:       85 00                   sub    %eax,%edx
    0.00 :	    6f82:       48 8d 42 10             lea    (%rdx,%r14,1),%eax
    0.00 :	    6f86:       f6 40 01 20             mov    %eax,0x8(%r13)
    0.00 :	    6f8a:       0f 85 ad 03             mov    0x58(%rsp),%edx
    0.00 :	    6f8e:       00 00 8b                add    %r15d,%edx
    0.00 :	    6f91:       4c 24                   mov    %edx,%eax
    0.00 :	    6f93:       54 89                   not    %eax
    0.00 :	    6f95:       4a 0c 80 48             add    0x4(%r13),%eax
    0.00 :	    6f99:       01 20 41 8b 55 08       js     7208 <nf_conntrack_hash_insert+0x70f8>
    0.00 :	    6f9f:       85 d2 74 17             mov    0x54(%rsp),%edx
    0.00 :	    6fa3:       4b 8d 04 a4             cmp    %edx,0x0(%r13)
    0.00 :	    6fa7:       8b 44                   jne    6fae <nf_conntrack_hash_insert+0x6e9e>
    0.00 :	    6fa9:       85 04 44 39 f0          andb   $0xef,0x11(%r13)
    0.00 :	    6fae:       79 0a 29 c2 42          cmpl   $0x3,0x3c(%rsp)
    0.00 :	    6fb3:       8d 04 32 41 89 45       jne    6e20 <nf_conntrack_hash_insert+0x6d10>
    0.00 :	    6fb9:       08 8b 54 24             movzbl 0x29(%rbp),%eax
    0.00 :	    6fbd:       58 44 01 fa             cmp    0x40(%rsp),%eax
    0.00 :	    6fc1:       89 d0 f7 d0 41 03       je     7224 <nf_conntrack_hash_insert+0x7114>
   50.00 :	    6fc7:       45 04 0f 88 69          movzbl 0x40(%rsp),%edx
    0.00 :	    6fcc:       02 00 00 8b 54          mov    $0x1,%ebx
    0.00 :	    6fd1:       24 54 41                mov    %dl,0x29(%rbp)
    0.00 :	    6fd4:       39 55 00 75             mov    0x50(%rsp),%ecx
    0.00 :	    6fd8:       05 41 80                mov    %ecx,0x2c(%rbp)
    0.00 :	    6fdb:       65 11 ef 83             mov    0x54(%rsp),%eax
    0.00 :	    6fdf:       7c 24 3c 03             mov    %r14d,0x34(%rbp)
    0.00 :	    6fe3:       0f 85 67                mov    %eax,0x30(%rbp)
    0.00 :	    6fe6:       fe ff ff 0f b6          movzwl 0x58(%rsp),%edx
    0.00 :	    6feb:       45 29 3b 44             movb   $0x0,0x2a(%rbp)
    0.00 :	    6fef:       24 40 0f 84             mov    %dx,0x38(%rbp)
    0.00 :	    6ff3:       5d 02 00 00 0f          jmpq   6e25 <nf_conntrack_hash_insert+0x6d15>
    0.00 :	    6ff8:       b6 54 24 40 bb 01 00    nopl   0x0(%rax,%rax,1)
    0.00 :	    6fff:       00 
    0.00 :	    7000:       00 88 55                sub    $0x1,%ebx
    0.00 :	    7003:       29 8b 4c 24 50          jmpq   6d95 <nf_conntrack_hash_insert+0x6c85>
    0.00 :	    7008:       89 4d 2c 8b 44 24 54    nopl   0x0(%rax,%rax,1)
    0.00 :	    700f:       44 
    0.00 :	    7010:       89 75 34 89 45          mov    0x40(%rsp),%r10d
    0.00 :	    7015:       30 0f b7                test   %r10d,%r10d
    0.00 :	    7018:       54 24 58 c6 45 2a       jne    6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    701e:       00 66 89 55             lea    (%r12,%r12,4),%rax
    0.00 :	    7022:       38 e9 2d fe ff          cmp    %r14d,0x0(%rbp,%rax,4)
    0.00 :	    7027:       ff 0f 1f 84 00 00 00    lea    0x0(,%rax,4),%rdx
    0.00 :	    702e:       00 
    0.00 :	    702f:       00 83 eb 01 e9 8d       jns    6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    7035:       fd ff ff 0f 1f          lea    0x0(%rbp,%rdx,1),%rdx
    0.00 :	    703a:       84 00 00                mov    %rbx,%rcx
    0.00 :	    703d:       00 00 00 44             mov    %r14d,0x4(%rdx)
    0.00 :	    7041:       8b 54 24 40 45          mov    %r14d,0x0(%rbp,%rax,4)
    0.00 :	    7046:       85 d2 0f 85 ea          mov    $0x1,%eax
    0.00 :	    704b:       fc ff ff 4b 8d          mov    0x58(%rsp),%r9d
    0.00 :	    7050:       04 a4 44                test   %r9d,%r9d
    0.00 :	    7053:       39 74 85 00 48          cmovne 0x58(%rsp),%eax
    0.00 :	    7058:       8d 14 85                mov    %eax,0x8(%rdx)
    0.00 :	    705b:       00 00 00 00 0f 89 d3    mov    0xe0(%rsp),%rdx
    0.00 :	    7062:       fc 
    0.00 :	    7063:       ff ff 48 8d             mov    0x2c(%rsp),%esi
    0.00 :	    7067:       54 15 00 48 89          mov    0x30(%rsp),%rdi
    0.00 :	    706c:       d9 44 89 72 04          callq  68c0 <nf_conntrack_hash_insert+0x67b0>
    0.00 :	    7071:       44 89 74 85 00          jmpq   6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    7076:       b8 01 00 00 00 44 8b    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	    707d:       4c 24 58 
    0.00 :	    7080:       45 85 c9 0f 45          testb  $0x1,0x11(%r13)
    0.00 :	    7085:       44 24 58 89 42 08       jne    6bf3 <nf_conntrack_hash_insert+0x6ae3>
    0.00 :	    708b:       48 8b 94 24 e0          nopl   0x0(%rax,%rax,1)
    0.00 :	    7090:       00 00 00 8b 74          jmpq   6be5 <nf_conntrack_hash_insert+0x6ad5>
    0.00 :	    7095:       24 2c 48                nopl   (%rax)
    0.00 :	    7098:       8b 7c 24 30 e8 4f f8    nopl   0x0(%rax,%rax,1)
    0.00 :	    709f:       ff 
    0.00 :	    70a0:       ff e9 92 fc ff          callq  70a5 <nf_conntrack_hash_insert+0x6f95>
    0.00 :	    70a5:       ff 66                   test   %eax,%eax
    0.00 :	    70a7:       2e 0f 1f 84 00 00       je     6ccb <nf_conntrack_hash_insert+0x6bbb>
    0.00 :	    70ad:       00 00 00 41             lea    (%r12,%r12,4),%rcx
    0.00 :	    70b1:       f6 45 11 01 0f          mov    $0xffffffff,%eax
    0.00 :	    70b6:       85 68 fb ff ff 0f 1f    mov    $0x0,%rdx
    0.00 :	    70bd:       44 00 00 e9 50          lea    0x0(%rbp,%rcx,4),%rsi
    0.00 :	    70c2:       fb ff ff                sub    0x4(%rsi),%eax
    0.00 :	    70c5:       0f 1f 00 0f             add    0x50(%rsp),%eax
    0.00 :	    70c9:       1f 84 00 00 00 00       js     7168 <nf_conntrack_hash_insert+0x7058>
    0.00 :	    70cf:       00 e8 00 00 00          movzbl 0x2b(%rsp),%edi
    0.00 :	    70d4:       00 85 c0 0f 84          mov    %rdx,0x8(%rsp)
    0.00 :	    70d9:       1e fc ff                xor    %r9d,%r9d
    0.00 :	    70dc:       ff 4b 8d 0c a4          mov    0x30(%rsp),%rdx
    0.00 :	    70e1:       b8 ff ff                xor    %r8d,%r8d
    0.00 :	    70e4:       ff ff                   xor    %ecx,%ecx
    0.00 :	    70e6:       48 c7                   xor    %esi,%esi
    0.00 :	    70e8:       c2 00                   xor    %eax,%eax
    0.00 :	    70ea:       00 00 00 48 8d 74 8d    movq   $0x0,(%rsp)
    0.00 :	    70f1:       00 
    0.00 :	    70f2:       2b 46                   xor    %ebx,%ebx
    0.00 :	    70f4:       04 03 44 24 50          callq  70f9 <nf_conntrack_hash_insert+0x6fe9>
    0.00 :	    70f9:       0f 88 99 00 00          jmpq   6e25 <nf_conntrack_hash_insert+0x6d15>
    0.00 :	    70fe:       00 0f                   xchg   %ax,%ax
    0.00 :	    7100:       b6 7c 24 2b 48 89       cmpl   $0xa080101,(%rax)
    0.00 :	    7106:       54 24 08 45 31 c9       jne    6d9d <nf_conntrack_hash_insert+0x6c8d>
    0.00 :	    710c:       48 8b 54 24             nopl   0x0(%rax)
    0.00 :	    7110:       30 45 31 c0 31          jmpq   6af5 <nf_conntrack_hash_insert+0x69e5>
    0.00 :	    7115:       c9 31 f6                nopl   (%rax)
    0.00 :	    7118:       31 c0 48 c7 04          cmpl   $0x1,0x40(%rsp)
    0.00 :	    711d:       24 00 00                nopl   (%rax)
    0.00 :	    7120:       00 00 31 db e8 00       jne    6d08 <nf_conntrack_hash_insert+0x6bf8>
    0.00 :	    7126:       00 00                   xchg   %ax,%ax
    0.00 :	    7128:       00 e9 27 fd ff          jmpq   701e <nf_conntrack_hash_insert+0x6f0e>
    0.00 :	    712d:       ff 66 90                nopl   (%rax)
    0.00 :	    7130:       81 38 01 01 08          lea    0x70(%rsp),%r15
    0.00 :	    7135:       0a 0f 85 91 fc          mov    0x30(%rsp),%rdi
    0.00 :	    713a:       ff ff                   mov    %ebx,%ecx
    0.00 :	    713c:       0f 1f 40 00 e9          mov    %r10,0x20(%rsp)
    0.00 :	    7141:       e0 f9 ff                mov    %r15,%rdx
    0.00 :	    7144:       ff 0f 1f 00 83          callq  7149 <nf_conntrack_hash_insert+0x7039>
    0.00 :	    7149:       7c 24                   test   %eax,%eax
    0.00 :	    714b:       40 01 0f 1f 00          mov    0x20(%rsp),%r10
    0.00 :	    7150:       0f 85                   js     7160 <nf_conntrack_hash_insert+0x7050>
    0.00 :	    7152:       e2 fb ff                mov    %r15,%rax
    0.00 :	    7155:       ff 66 90 e9 f1          jmpq   6d80 <nf_conntrack_hash_insert+0x6c70>
    0.00 :	    715a:       fe ff ff 0f 1f 00       nopw   0x0(%rax,%rax,1)
    0.00 :	    7160:       4c 8d                   ud2    
    0.00 :	    7162:       7c 24                   jmp    7162 <nf_conntrack_hash_insert+0x7052>
    0.00 :	    7164:       70 48 8b 7c             nopl   0x0(%rax)
    0.00 :	    7168:       24 30 89 d9             mov    0x0(%rbp,%rcx,4),%eax
    0.00 :	    716c:       4c 89 54 24 20 4c 89    mov    $0x0,%rdx
    0.00 :	    7173:       fa e8 00                sub    $0x1,%eax
    0.00 :	    7176:       00 00 00 85             sub    0x8(%r13),%eax
    0.00 :	    717a:       c0 4c 8b                cmp    %r14d,%eax
    0.00 :	    717d:       54 24 20 78 0e 4c       jns    70cf <nf_conntrack_hash_insert+0x6fbf>
    0.00 :	    7183:       89 f8 e9 26             mov    0x0(%r13),%ecx
    0.00 :	    7187:       fc ff ff 66 0f 1f 44    mov    $0x0,%rdx
    0.00 :	    718e:       00 00                   mov    %ecx,%eax
    0.00 :	    7190:       0f 0b                   not    %eax
    0.00 :	    7192:       eb fe 0f                add    %r15d,%eax
    0.00 :	    7195:       1f 40 00 8b 44 8d       jns    70cf <nf_conntrack_hash_insert+0x6fbf>
    0.00 :	    719b:       00 48 c7 c2 00 00 00    cmpl   $0x101d0,0x8(%rsi)
    0.00 :	    71a2:       00 83 e8 01 41          mov    $0x101d0,%edx
    0.00 :	    71a7:       2b 45 08                lea    -0x1(%rcx),%eax
    0.00 :	    71aa:       44 39 f0 0f             cmovae 0x8(%rsi),%edx
    0.00 :	    71ae:       89 4c                   sub    %edx,%eax
    0.00 :	    71b0:       ff ff ff 41 8b 4d 00    mov    $0x0,%rdx
    0.00 :	    71b7:       48 c7 c2                cmp    %r15d,%eax
    0.00 :	    71ba:       00 00 00 00 89 c8 f7    mov    $0x0,%rax
    0.00 :	    71c1:       d0 44 01 f8             cmovs  %rax,%rdx
    0.00 :	    71c5:       0f 89 34 ff ff          jmpq   70cf <nf_conntrack_hash_insert+0x6fbf>
    0.00 :	    71ca:       ff 81 7e 08 d0 01       nopw   0x0(%rax,%rax,1)
    0.00 :	    71d0:       01 00 ba                cmp    $0x9,%ecx
    0.00 :	    71d3:       d0 01 01 00 8d 41       jle    6dd0 <nf_conntrack_hash_insert+0x6cc0>
    0.00 :	    71d9:       ff 0f 43                lea    -0x2(%rcx),%esi
    0.00 :	    71dc:       56 08 29 d0             test   $0x7,%sil
    0.00 :	    71e0:       48 c7 c2 00 00 00       jne    6dd0 <nf_conntrack_hash_insert+0x6cc0>
    0.00 :	    71e6:       00 44 39                mov    %r12d,%ecx
    0.00 :	    71e9:       f8 48                   xor    %edi,%edi
    0.00 :	    71eb:       c7 c0 00                movslq %edi,%rax
    0.00 :	    71ee:       00 00 00 48             mov    0x4(%rdx,%rax,1),%ebx
    0.00 :	    71f2:       0f 48                   bswap  %ebx
    0.00 :	    71f4:       d0 e9                   cmp    %ebx,%ecx
    0.00 :	    71f6:       05 ff ff                cmovns %ecx,%ebx
    0.00 :	    71f9:       ff 66 0f                add    $0x8,%edi
    0.00 :	    71fc:       1f 44                   cmp    %edi,%esi
    0.00 :	    71fe:       00 00 83 f9 09 0f       jle    6af8 <nf_conntrack_hash_insert+0x69e8>
    0.00 :	    7204:       8e f7                   mov    %ebx,%ecx
    0.00 :	    7206:       fb ff                   jmp    71eb <nf_conntrack_hash_insert+0x70db>
    0.00 :	    7208:       ff 8d 71 fe             mov    %edx,0x4(%r13)
    0.00 :	    720c:       40 f6 c6 07             mov    0x58(%rsp),%esi
    0.00 :	    7210:       0f 85                   test   %esi,%esi
    0.00 :	    7212:       ea fb ff ff 44 89       jne    6f9f <nf_conntrack_hash_insert+0x6e8f>
    0.00 :	    7218:       e1 31 ff                lea    0x1(%rdx),%eax
    0.00 :	    721b:       48 63 c7 8b             mov    %eax,0x4(%r13)
    0.00 :	    721f:       5c 02 04 0f cb          jmpq   6f9f <nf_conntrack_hash_insert+0x6e8f>
    0.00 :	    7224:       39 d9 0f 49             mov    0x50(%rsp),%ecx
    0.00 :	    7228:       d9 83 c7                cmp    %ecx,0x2c(%rbp)
    0.00 :	    722b:       08 39 fe 0f 8e f4       jne    6fc7 <nf_conntrack_hash_insert+0x6eb7>
    0.00 :	    7231:       f8 ff ff 89             mov    0x54(%rsp),%eax
    0.00 :	    7235:       d9 eb e3                cmp    %eax,0x30(%rbp)
    0.00 :	    7238:       41 89 55 04 8b 74       jne    6fc7 <nf_conntrack_hash_insert+0x6eb7>
    0.00 :	    723e:       24 58 85 f6             cmp    %r14d,0x34(%rbp)
    0.00 :	    7242:       0f 85 87 fd ff ff       jne    6fc7 <nf_conntrack_hash_insert+0x6eb7>
    0.00 :	    7248:       8d 42 01 41             movzwl 0x38(%rbp),%eax
    0.00 :	    724c:       89 45 04 e9             cmp    0x58(%rsp),%eax
    0.00 :	    7250:       7b fd ff ff 8b 4c       jne    6fc7 <nf_conntrack_hash_insert+0x6eb7>
    0.00 :	    7256:       24 50 39 4d             addb   $0x1,0x2a(%rbp)
    0.00 :	    725a:       2c 0f 85 96 fd          mov    $0x1,%ebx
    0.00 :	    725f:       ff ff 8b 44 24          jmpq   6e25 <nf_conntrack_hash_insert+0x6d15>
    0.00 :	    7264:       54 39 45 30             mov    0x58(%rsp),%edx
    0.00 :	    7268:       0f 85 89 fd ff ff       movswl 0x5e(%rsp),%r8d
    0.00 :	    726e:       44 39 75                mov    %r15d,%r9d
    0.00 :	    7271:       34 0f 85 7f             mov    0x54(%rsp),%ecx
    0.00 :	    7275:       fd ff ff 0f b7 45 38    mov    $0x0,%rsi
    0.00 :	    727c:       3b 44 24 58 0f 85 71    mov    $0x0,%rdi
    0.00 :	    7283:       fd ff                   xor    %eax,%eax
    0.00 :	    7285:       ff 80 45 2a 01          mov    %r14d,0x10(%rsp)
    0.00 :	    728a:       bb 01 00 00             mov    %edx,0x8(%rsp)
    0.00 :	    728e:       00 e9 c1 fb             mov    0x50(%rsp),%edx
    0.00 :	    7292:       ff ff 8b 54             mov    %r8d,(%rsp)
    0.00 :	    7296:       24 58 44 0f bf          callq  729b <nf_conntrack_hash_insert+0x718b>
    0.00 :	    729b:       44 24 5e 45 89          jmpq   6b6e <nf_conntrack_hash_insert+0x6a5e>
    0.00 :	    72a0:       f9 8b 4c 24 54 48 c7    mov    $0x0,%rsi
    0.00 :	    72a7:       c6 00 00 00 00 48 c7    mov    $0x0,%rdi
    0.00 :	    72ae:       c7 00                   xor    %eax,%eax
    0.00 :	    72b0:       00 00 00 31 c0          callq  72b5 <nf_conntrack_hash_insert+0x71a5>
    0.00 :	    72b5:       44 89 74 24 10          jmpq   6b34 <nf_conntrack_hash_insert+0x6a24>
    0.00 :	    72ba:       89 54 24 08             lea    (%r12,%r12,4),%rax
    0.00 :	    72be:       8b 54 24 50 44 89 04    mov    $0x0,%rsi
    0.00 :	    72c5:       24 e8 00 00 00 00 e9    mov    $0x0,%rdi
    0.00 :	    72cc:       ce f8 ff ff             mov    0x0(%rbp,%rax,4),%edx
    0.00 :	    72d0:       48 c7 c6 00 00          lea    0x0(%rbp,%rax,4),%rcx
    0.00 :	    72d5:       00 00 48 c7 c7          movzbl 0x10(%r13),%eax
    0.00 :	    72da:       00 00 00 00 31          movzbl 0x10(%rcx),%r9d
    0.00 :	    72df:       c0 e8 00 00             mov    %eax,0x18(%rsp)
    0.00 :	    72e3:       00 00 e9 7a             mov    0x8(%r13),%eax
    0.00 :	    72e7:       f8 ff ff 4b             mov    %eax,0x10(%rsp)
    0.00 :	    72eb:       8d 04 a4 48             mov    0x4(%r13),%eax
    0.00 :	    72ef:       c7 c6 00 00             mov    %eax,0x8(%rsp)
    0.00 :	    72f3:       00 00 48 c7             mov    0x0(%r13),%eax
    0.00 :	    72f7:       c7 00 00                mov    %eax,(%rsp)
    0.00 :	    72fa:       00 00 8b 54             mov    0x8(%rcx),%r8d
    0.00 :	    72fe:       85 00                   xor    %eax,%eax
    0.00 :	    7300:       48 8d 4c                mov    0x4(%rcx),%ecx
    0.00 :	    7303:       85 00 41 0f b6          callq  7308 <nf_conntrack_hash_insert+0x71f8>
    0.00 :	    7308:       45 10 44 0f b6          jmpq   6b80 <nf_conntrack_hash_insert+0x6a70>
    0.00 :	    730d:       49 10 89 44             mov    0x54(%rsp),%eax
    0.00 :	    7311:       24 18 41                cmp    %eax,0xc(%rdx)
    0.00 :	    7314:       8b 45 08 89 44 24       jns    6f6b <nf_conntrack_hash_insert+0x6e5b>
    0.00 :	    731a:       10 41 8b                mov    %eax,0xc(%rdx)
    0.00 :	    731d:       45 04 89                nopl   (%rax)
    0.00 :	    7320:       44 24 08 41 8b          jmpq   6f6b <nf_conntrack_hash_insert+0x6e5b>
    0.00 :	    7325:       45 00 89 04 24 44 8b    mov    $0x0,%rsi
    0.00 :	    732c:       41 08 31 c0 8b 49 04    mov    $0x0,%rdi
    0.00 :	    7333:       e8 00                   xor    %eax,%eax
    0.00 :	    7335:       00 00 00 e9 73          callq  733a <nf_conntrack_hash_insert+0x722a>
    0.00 :	    733a:       f8 ff ff 8b 44          jmpq   6c4d <nf_conntrack_hash_insert+0x6b3d>
    0.00 :	    733f:       24 54 39 42             mov    0x58(%rsp),%eax
    0.00 :	    7343:       0c 0f 89 51 fc ff       movswl 0x5e(%rsp),%r8d
    0.00 :	    7349:       ff 89 42                mov    %r15d,%r9d
    0.00 :	    734c:       0c 0f 1f 00             mov    0x54(%rsp),%ecx
    0.00 :	    7350:       e9 46 fc ff             mov    0x50(%rsp),%edx
    0.00 :	    7354:       ff 48 c7 c6 00 00 00    mov    $0x0,%rsi
    0.00 :	    735b:       00 48 c7 c7 00 00 00    mov    $0x0,%rdi
    0.00 :	    7362:       00 31 c0 e8 00          mov    %r14d,0x10(%rsp)
    0.00 :	    7367:       00 00 00 e9             mov    %eax,0x8(%rsp)
    0.00 :	    736b:       0e f9                   xor    %eax,%eax
    0.00 :	    736d:       ff ff 8b 44             mov    %r8d,(%rsp)
    0.00 :	    7371:       24 58 44 0f bf          callq  7376 <nf_conntrack_hash_insert+0x7266>
    0.00 :	    7376:       44 24 5e 45 89          jmpq   6c5a <nf_conntrack_hash_insert+0x6b4a>
    0.00 :	    737b:       f9 8b 4c 24             lea    (%r12,%r12,4),%rax
    0.00 :	    737f:       54 8b 54 24 50 48 c7    mov    $0x0,%rsi
    0.00 :	    7386:       c6 00 00 00 00 48 c7    mov    $0x0,%rdi
    0.00 :	    738d:       c7 00 00 00             mov    0x0(%rbp,%rax,4),%edx
    0.00 :	    7391:       00 44 89 74 24          lea    0x0(%rbp,%rax,4),%rcx
    0.00 :	    7396:       10 89 44 24 08          movzbl 0x10(%r13),%eax
    0.00 :	    739b:       31 c0 44 89 04          movzbl 0x10(%rcx),%r9d
    0.00 :	    73a0:       24 e8 00 00             mov    %eax,0x18(%rsp)
    0.00 :	    73a4:       00 00 e9 df             mov    0x8(%r13),%eax
    0.00 :	    73a8:       f8 ff ff 4b             mov    %eax,0x10(%rsp)
    0.00 :	    73ac:       8d 04 a4 48             mov    0x4(%r13),%eax
    0.00 :	    73b0:       c7 c6 00 00             mov    %eax,0x8(%rsp)
    0.00 :	    73b4:       00 00 48 c7             mov    0x0(%r13),%eax
    0.00 :	    73b8:       c7 00 00                mov    %eax,(%rsp)
    0.00 :	    73bb:       00 00 8b 54             mov    0x8(%rcx),%r8d
    0.00 :	    73bf:       85 00                   xor    %eax,%eax
    0.00 :	    73c1:       48 8d 4c                mov    0x4(%rcx),%ecx
    0.00 :	    73c4:       85 00 41 0f b6          callq  73c9 <nf_conntrack_hash_insert+0x72b9>
    0.00 :	    73c9:       45 10 44 0f b6          jmpq   6c67 <nf_conntrack_hash_insert+0x6b57>
    0.00 :	    73ce:       49 10 89 44 24 18 41    mov    $0x0,%rsi
    0.00 :	    73d5:       8b 45 08 89 44 24 10    mov    $0x0,%rdi
    0.00 :	    73dc:       41 8b                   xor    %eax,%eax
    0.00 :	    73de:       45 04 89 44 24          callq  73e3 <nf_conntrack_hash_insert+0x72d3>
    0.00 :	    73e3:       08 41 8b 45 00          jmpq   6b27 <nf_conntrack_hash_insert+0x6a17>
    0.00 :	    73e8:       89 04 24 44             lea    (%r12,%r12,4),%rcx
    0.00 :	    73ec:       8b 41 08 31             mov    0x0(%r13),%r8d
    0.00 :	    73f0:       c0 8b 49 04 e8          mov    $0xffffffff,%edx
    0.00 :	    73f5:       00 00 00 00 e9          mov    $0x101d0,%eax
    0.00 :	    73fa:       99 f8 ff ff 48 c7 c6    mov    $0x0,%rdi
    0.00 :	    7401:       00 00 00 00 48          lea    0x0(%rbp,%rcx,4),%rsi
    0.00 :	    7406:       c7 c7 00 00             mov    0x0(%rbp,%rcx,4),%ecx
    0.00 :	    740a:       00 00 31 c0             lea    -0x1(%r8),%r9d
    0.00 :	    740e:       e8 00 00                not    %r8d
    0.00 :	    7411:       00 00 e9 3f f7 ff ff    cmpl   $0x101d0,0x8(%rsi)
    0.00 :	    7418:       4b 8d 0c a4             cmovae 0x8(%rsi),%eax
    0.00 :	    741c:       45 8b                   add    %edx,%ecx
    0.00 :	    741e:       45 00 ba                sub    0x4(%rsi),%edx
    0.00 :	    7421:       ff ff ff ff             sub    0x8(%r13),%ecx
    0.00 :	    7425:       b8 d0 01 01             add    0x50(%rsp),%edx
    0.00 :	    7429:       00 48 c7                add    %r15d,%r8d
    0.00 :	    742c:       c7 00 00 00             shr    $0x1f,%r8d
    0.00 :	    7430:       00 48 8d 74 8d 00 8b    mov    $0x0,%rsi
    0.00 :	    7437:       4c 8d 00                sub    %eax,%r9d
    0.00 :	    743a:       45 8d                   xor    %eax,%eax
    0.00 :	    743c:       48 ff 41                sub    %r15d,%r9d
    0.00 :	    743f:       f7 d0 81                sub    %r14d,%ecx
    0.00 :	    7442:       7e 08 d0                shr    $0x1f,%edx
    0.00 :	    7445:       01 01 00                shr    $0x1f,%ecx
    0.00 :	    7448:       0f 43 46 08             shr    $0x1f,%r9d
    0.00 :	    744c:       01 d1 2b 56 04          callq  7451 <nf_conntrack_hash_insert+0x7341>
    0.00 :	    7451:       41 2b 4d 08 03          jmpq   6c74 <nf_conntrack_hash_insert+0x6b64>
         :	    7456:       54 24 50 45 01 f8 41    nopw   %cs:0x0(%rax,%rax,1)
         :	    745d:       c1 e8 1f 
         :	    7460:       48 c7                   push   %r13
         :	    7462:       c6 00                   push   %r12
         :	    7464:       00 00 00                mov    %edx,%r12d
         :	    7467:       41                      push   %rbp
         :	    7468:       29 c1 31                mov    %rdi,%rbp
         :	    746b:       c0                      push   %rbx
         :	    746c:       45 29 f9                mov    %rsi,%rbx
         :	    746f:       44 29 f1 c1             sub    $0x48,%rsp
         :	    7473:       ea 1f c1                mov    0x68(%rsi),%eax
         :	    7476:       e9 1f 41                sub    0x6c(%rsi),%eax
         :	    7479:       c1 e9                   sub    %edx,%eax
         :	    747b:       1f e8 00                cmp    $0x13,%eax
         :	    747e:       00 00 00 e9 1e f8       jle    7610 <nf_conntrack_hash_insert+0x7500>
         :	    7484:       ff ff 66                movslq %edx,%r8

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib64/ld-2.11.3.so
----------------------------------------------

   50.00 ??:0
   50.00 ??:0
 Percent |	Source code & Disassembly of /lib64/ld-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000092c0 <do_lookup_x>:
    0.00 :	    92c0:       41 57                   push   %r15
    0.00 :	    92c2:       49 89 f3                mov    %rsi,%r11
    0.00 :	    92c5:       41 56                   push   %r14
    0.00 :	    92c7:       41 55                   push   %r13
    0.00 :	    92c9:       41 54                   push   %r12
    0.00 :	    92cb:       55                      push   %rbp
    0.00 :	    92cc:       53                      push   %rbx
    0.00 :	    92cd:       48 81 ec a8 00 00 00    sub    $0xa8,%rsp
    0.00 :	    92d4:       48 8b 84 24 e8 00 00    mov    0xe8(%rsp),%rax
    0.00 :	    92db:       00 
    0.00 :	    92dc:       48 89 54 24 30          mov    %rdx,0x30(%rsp)
    0.00 :	    92e1:       4c 89 44 24 28          mov    %r8,0x28(%rsp)
    0.00 :	    92e6:       48 89 7c 24 78          mov    %rdi,0x78(%rsp)
    0.00 :	    92eb:       48 89 8c 24 88 00 00    mov    %rcx,0x88(%rsp)
    0.00 :	    92f2:       00 
    0.00 :	    92f3:       48 8b ac 24 e0 00 00    mov    0xe0(%rsp),%rbp
    0.00 :	    92fa:       00 
    0.00 :	    92fb:       48 89 44 24 68          mov    %rax,0x68(%rsp)
    0.00 :	    9300:       8b 84 24 f0 00 00 00    mov    0xf0(%rsp),%eax
    0.00 :	    9307:       4c 8b ac 24 f8 00 00    mov    0xf8(%rsp),%r13
    0.00 :	    930e:       00 
    0.00 :	    930f:       89 84 24 94 00 00 00    mov    %eax,0x94(%rsp)
    0.00 :	    9316:       8b 84 24 00 01 00 00    mov    0x100(%rsp),%eax
    0.00 :	    931d:       89 84 24 9c 00 00 00    mov    %eax,0x9c(%rsp)
    0.00 :	    9324:       45 8b 61 08             mov    0x8(%r9),%r12d
    0.00 :	    9328:       48 8d 44 24 60          lea    0x60(%rsp),%rax
    0.00 :	    932d:       49 89 f6                mov    %rsi,%r14
    0.00 :	    9330:       41 89 f7                mov    %esi,%r15d
    0.00 :	    9333:       48 8d 1c ed 00 00 00    lea    0x0(,%rbp,8),%rbx
    0.00 :	    933a:       00 
    0.00 :	    933b:       49 c1 ee 06             shr    $0x6,%r14
    0.00 :	    933f:       49 03 19                add    (%r9),%rbx
    0.00 :	    9342:       41 83 e7 3f             and    $0x3f,%r15d
    0.00 :	    9346:       48 89 44 24 20          mov    %rax,0x20(%rsp)
    0.00 :	    934b:       eb 14                   jmp    9361 <do_lookup_x+0xa1>
    0.00 :	    934d:       0f 1f 00                nopl   (%rax)
    0.00 :	    9350:       48 83 c5 01             add    $0x1,%rbp
    0.00 :	    9354:       48 83 c3 08             add    $0x8,%rbx
    0.00 :	    9358:       49 39 ec                cmp    %rbp,%r12
    0.00 :	    935b:       0f 86 1f 01 00 00       jbe    9480 <do_lookup_x+0x1c0>
    0.00 :	    9361:       c7 84 24 90 00 00 00    movl   $0x0,0x90(%rsp)
    0.00 :	    9368:       00 00 00 00 
    0.00 :	    936c:       48 c7 44 24 60 00 00    movq   $0x0,0x60(%rsp)
    0.00 :	    9373:       00 00 
    0.00 :	    9375:       48 8b 03                mov    (%rbx),%rax
    0.00 :	    9378:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	    937c:       4c 39 e8                cmp    %r13,%rax
    0.00 :	    937f:       48 89 44 24 70          mov    %rax,0x70(%rsp)
    0.00 :	    9384:       74 ca                   je     9350 <do_lookup_x+0x90>
    0.00 :	    9386:       f6 84 24 9c 00 00 00    testb  $0x2,0x9c(%rsp)
    0.00 :	    938d:       02 
    0.00 :	    938e:       74 09                   je     9399 <do_lookup_x+0xd9>
    0.00 :	    9390:       f6 80 14 03 00 00 03    testb  $0x3,0x314(%rax)
    0.00 :	    9397:       74 b7                   je     9350 <do_lookup_x+0x90>
    0.00 :	    9399:       f6 80 15 03 00 00 20    testb  $0x20,0x315(%rax)
    0.00 :	    93a0:       75 ae                   jne    9350 <do_lookup_x+0x90>
    0.00 :	    93a2:       f6 05 77 58 21 00 08    testb  $0x8,0x215877(%rip)        # 21ec20 <_rtld_global_ro>
    0.00 :	    93a9:       0f 85 bf 04 00 00       jne    986e <do_lookup_x+0x5ae>
    0.00 :	    93af:       48 8b 74 24 70          mov    0x70(%rsp),%rsi
    0.00 :	    93b4:       8b be ec 02 00 00       mov    0x2ec(%rsi),%edi
    0.00 :	    93ba:       85 ff                   test   %edi,%edi
    0.00 :	    93bc:       74 92                   je     9350 <do_lookup_x+0x90>
    0.00 :	    93be:       48 8b 46 70             mov    0x70(%rsi),%rax
    0.00 :	    93c2:       4c 8b 48 08             mov    0x8(%rax),%r9
   50.00 :	    93c6:       48 8b 46 68             mov    0x68(%rsi),%rax
    0.00 :	    93ca:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    93ce:       48 89 84 24 80 00 00    mov    %rax,0x80(%rsp)
    0.00 :	    93d5:       00 
    0.00 :	    93d6:       48 8b 96 f8 02 00 00    mov    0x2f8(%rsi),%rdx
    0.00 :	    93dd:       48 85 d2                test   %rdx,%rdx
    0.00 :	    93e0:       0f 84 0e 05 00 00       je     98f4 <do_lookup_x+0x634>
    0.00 :	    93e6:       8b 86 f0 02 00 00       mov    0x2f0(%rsi),%eax
    0.00 :	    93ec:       8b 8e f4 02 00 00       mov    0x2f4(%rsi),%ecx
    0.00 :	    93f2:       44 21 f0                and    %r14d,%eax
    0.00 :	    93f5:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	    93f9:       4c 89 d8                mov    %r11,%rax
    0.00 :	    93fc:       48 d3 e8                shr    %cl,%rax
    0.00 :	    93ff:       48 89 c1                mov    %rax,%rcx
    0.00 :	    9402:       83 e1 3f                and    $0x3f,%ecx
    0.00 :	    9405:       48 89 d0                mov    %rdx,%rax
    0.00 :	    9408:       48 d3 e8                shr    %cl,%rax
    0.00 :	    940b:       44 89 f9                mov    %r15d,%ecx
    0.00 :	    940e:       48 d3 ea                shr    %cl,%rdx
    0.00 :	    9411:       48 21 d0                and    %rdx,%rax
    0.00 :	    9414:       a8 01                   test   $0x1,%al
    0.00 :	    9416:       0f 85 78 05 00 00       jne    9994 <do_lookup_x+0x6d4>
    0.00 :	    941c:       c7 84 24 98 00 00 00    movl   $0x0,0x98(%rsp)
    0.00 :	    9423:       00 00 00 00 
    0.00 :	    9427:       83 bc 24 90 00 00 00    cmpl   $0x1,0x90(%rsp)
    0.00 :	    942e:       01 
    0.00 :	    942f:       74 67                   je     9498 <do_lookup_x+0x1d8>
    0.00 :	    9431:       8b 94 24 98 00 00 00    mov    0x98(%rsp),%edx
    0.00 :	    9438:       85 d2                   test   %edx,%edx
    0.00 :	    943a:       0f 85 10 ff ff ff       jne    9350 <do_lookup_x+0x90>
    0.00 :	    9440:       48 8b 44 24 68          mov    0x68(%rsp),%rax
    0.00 :	    9445:       48 85 c0                test   %rax,%rax
    0.00 :	    9448:       0f 84 02 ff ff ff       je     9350 <do_lookup_x+0x90>
    0.00 :	    944e:       48 8b 78 10             mov    0x10(%rax),%rdi
    0.00 :	    9452:       48 85 ff                test   %rdi,%rdi
    0.00 :	    9455:       0f 84 f5 fe ff ff       je     9350 <do_lookup_x+0x90>
    0.00 :	    945b:       48 8b 74 24 70          mov    0x70(%rsp),%rsi
    0.00 :	    9460:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9465:       e8 16 57 00 00          callq  eb80 <_dl_name_match_p>
    0.00 :	    946a:       85 c0                   test   %eax,%eax
    0.00 :	    946c:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    9471:       0f 84 d9 fe ff ff       je     9350 <do_lookup_x+0x90>
    0.00 :	    9477:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	    947c:       eb 04                   jmp    9482 <do_lookup_x+0x1c2>
    0.00 :	    947e:       66 90                   xchg   %ax,%ax
    0.00 :	    9480:       31 c0                   xor    %eax,%eax
    0.00 :	    9482:       48 81 c4 a8 00 00 00    add    $0xa8,%rsp
    0.00 :	    9489:       5b                      pop    %rbx
    0.00 :	    948a:       5d                      pop    %rbp
    0.00 :	    948b:       41 5c                   pop    %r12
    0.00 :	    948d:       41 5d                   pop    %r13
    0.00 :	    948f:       41 5e                   pop    %r14
    0.00 :	    9491:       41 5f                   pop    %r15
    0.00 :	    9493:       c3                      retq   
    0.00 :	    9494:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    9498:       48 8b 54 24 60          mov    0x60(%rsp),%rdx
    0.00 :	    949d:       48 85 d2                test   %rdx,%rdx
    0.00 :	    94a0:       48 89 54 24 48          mov    %rdx,0x48(%rsp)
    0.00 :	    94a5:       74 8a                   je     9431 <do_lookup_x+0x171>
    0.00 :	    94a7:       48 8b 4c 24 48          mov    0x48(%rsp),%rcx
    0.00 :	    94ac:       0f b6 41 04             movzbl 0x4(%rcx),%eax
    0.00 :	    94b0:       c0 e8 04                shr    $0x4,%al
    0.00 :	    94b3:       3c 02                   cmp    $0x2,%al
    0.00 :	    94b5:       0f 84 75 01 00 00       je     9630 <do_lookup_x+0x370>
    0.00 :	    94bb:       3c 0a                   cmp    $0xa,%al
    0.00 :	    94bd:       74 31                   je     94f0 <do_lookup_x+0x230>
    0.00 :	    94bf:       2c 01                   sub    $0x1,%al
    0.00 :	    94c1:       0f 85 6a ff ff ff       jne    9431 <do_lookup_x+0x171>
    0.00 :	    94c7:       48 8b 44 24 28          mov    0x28(%rsp),%rax
    0.00 :	    94cc:       48 8b 54 24 48          mov    0x48(%rsp),%rdx
    0.00 :	    94d1:       48 89 10                mov    %rdx,(%rax)
    0.00 :	    94d4:       48 8b 44 24 70          mov    0x70(%rsp),%rax
    0.00 :	    94d9:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    0.00 :	    94de:       48 89 41 08             mov    %rax,0x8(%rcx)
    0.00 :	    94e2:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	    94e7:       eb 99                   jmp    9482 <do_lookup_x+0x1c2>
    0.00 :	    94e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    94f0:       48 8b 44 24 70          mov    0x70(%rsp),%rax
    0.00 :	    94f5:       48 8d 2d 6c 5b 21 00    lea    0x215b6c(%rip),%rbp        # 21f068 <_rtld_global+0x8>
    0.00 :	    94fc:       48 8b 40 30             mov    0x30(%rax),%rax
    0.00 :	    9500:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9505:       48 8d 1c c0             lea    (%rax,%rax,8),%rbx
    0.00 :	    9509:       48 89 44 24 58          mov    %rax,0x58(%rsp)
    0.00 :	    950e:       48 8d 05 4b 5b 21 00    lea    0x215b4b(%rip),%rax        # 21f060 <_rtld_global>
    0.00 :	    9515:       48 c1 e3 04             shl    $0x4,%rbx
    0.00 :	    9519:       48 8d 44 18 20          lea    0x20(%rax,%rbx,1),%rax
    0.00 :	    951e:       48 01 dd                add    %rbx,%rbp
    0.00 :	    9521:       48 89 44 24 40          mov    %rax,0x40(%rsp)
    0.00 :	    9526:       48 89 c7                mov    %rax,%rdi
    0.00 :	    9529:       ff 15 11 6a 21 00       callq  *0x216a11(%rip)        # 21ff40 <_rtld_global+0xee0>
    0.00 :	    952f:       48 8b 55 40             mov    0x40(%rbp),%rdx
    0.00 :	    9533:       48 8d 0d 26 5b 21 00    lea    0x215b26(%rip),%rcx        # 21f060 <_rtld_global>
    0.00 :	    953a:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    953f:       48 8d 1c 19             lea    (%rcx,%rbx,1),%rbx
    0.00 :	    9543:       48 85 d2                test   %rdx,%rdx
    0.00 :	    9546:       48 89 54 24 50          mov    %rdx,0x50(%rsp)
    0.00 :	    954b:       4c 8b 73 50             mov    0x50(%rbx),%r14
    0.00 :	    954f:       0f 84 bb 02 00 00       je     9810 <do_lookup_x+0x550>
    0.00 :	    9555:       4c 89 d8                mov    %r11,%rax
    0.00 :	    9558:       31 d2                   xor    %edx,%edx
    0.00 :	    955a:       49 8d 76 fe             lea    -0x2(%r14),%rsi
    0.00 :	    955e:       49 f7 f6                div    %r14
    0.00 :	    9561:       4c 89 d8                mov    %r11,%rax
    0.00 :	    9564:       48 89 d1                mov    %rdx,%rcx
    0.00 :	    9567:       31 d2                   xor    %edx,%edx
    0.00 :	    9569:       48 f7 f6                div    %rsi
    0.00 :	    956c:       4c 8d 6a 01             lea    0x1(%rdx),%r13
    0.00 :	    9570:       48 8b 54 24 78          mov    0x78(%rsp),%rdx
    0.00 :	    9575:       4d 89 ef                mov    %r13,%r15
    0.00 :	    9578:       48 89 54 24 38          mov    %rdx,0x38(%rsp)
    0.00 :	    957d:       49 c1 e7 05             shl    $0x5,%r15
    0.00 :	    9581:       48 8b 6c 24 50          mov    0x50(%rsp),%rbp
    0.00 :	    9586:       4d 8d 64 0d 00          lea    0x0(%r13,%rcx,1),%r12
    0.00 :	    958b:       48 c1 e1 05             shl    $0x5,%rcx
    0.00 :	    958f:       48 01 cd                add    %rcx,%rbp
    0.00 :	    9592:       eb 26                   jmp    95ba <do_lookup_x+0x2fa>
    0.00 :	    9594:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    9598:       48 8b 5d 08             mov    0x8(%rbp),%rbx
    0.00 :	    959c:       48 85 db                test   %rbx,%rbx
    0.00 :	    959f:       0f 84 cb 00 00 00       je     9670 <do_lookup_x+0x3b0>
    0.00 :	    95a5:       4b 8d 14 2c             lea    (%r12,%r13,1),%rdx
    0.00 :	    95a9:       4c 01 fd                add    %r15,%rbp
    0.00 :	    95ac:       48 89 d0                mov    %rdx,%rax
    0.00 :	    95af:       4c 29 e8                sub    %r13,%rax
    0.00 :	    95b2:       49 39 c6                cmp    %rax,%r14
    0.00 :	    95b5:       76 69                   jbe    9620 <do_lookup_x+0x360>
    0.00 :	    95b7:       49 89 d4                mov    %rdx,%r12
    0.00 :	    95ba:       8b 45 00                mov    0x0(%rbp),%eax
    0.00 :	    95bd:       4c 39 d8                cmp    %r11,%rax
    0.00 :	    95c0:       75 d6                   jne    9598 <do_lookup_x+0x2d8>
    0.00 :	    95c2:       48 8b 5d 08             mov    0x8(%rbp),%rbx
    0.00 :	    95c6:       48 8b 74 24 38          mov    0x38(%rsp),%rsi
    0.00 :	    95cb:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    95d0:       48 89 df                mov    %rbx,%rdi
    0.00 :	    95d3:       e8 88 d0 00 00          callq  16660 <strcmp>
    0.00 :	    95d8:       85 c0                   test   %eax,%eax
    0.00 :	    95da:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    95df:       75 bb                   jne    959c <do_lookup_x+0x2dc>
    0.00 :	    95e1:       f6 84 24 9c 00 00 00    testb  $0x2,0x9c(%rsp)
    0.00 :	    95e8:       02 
    0.00 :	    95e9:       0f 84 ec 02 00 00       je     98db <do_lookup_x+0x61b>
    0.00 :	    95ef:       48 8b 44 24 48          mov    0x48(%rsp),%rax
    0.00 :	    95f4:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    0.00 :	    95f9:       48 89 01                mov    %rax,(%rcx)
    0.00 :	    95fc:       48 8b 44 24 70          mov    0x70(%rsp),%rax
    0.00 :	    9601:       48 89 41 08             mov    %rax,0x8(%rcx)
    0.00 :	    9605:       48 8b 7c 24 40          mov    0x40(%rsp),%rdi
    0.00 :	    960a:       ff 15 38 69 21 00       callq  *0x216938(%rip)        # 21ff48 <_rtld_global+0xee8>
    0.00 :	    9610:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	    9615:       e9 68 fe ff ff          jmpq   9482 <do_lookup_x+0x1c2>
    0.00 :	    961a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	    9620:       4c 89 e1                mov    %r12,%rcx
    0.00 :	    9623:       4c 29 f1                sub    %r14,%rcx
    0.00 :	    9626:       e9 56 ff ff ff          jmpq   9581 <do_lookup_x+0x2c1>
    0.00 :	    962b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	    9630:       8b 0d 32 56 21 00       mov    0x215632(%rip),%ecx        # 21ec68 <_rtld_global_ro+0x48>
    0.00 :	    9636:       85 c9                   test   %ecx,%ecx
    0.00 :	    9638:       0f 84 89 fe ff ff       je     94c7 <do_lookup_x+0x207>
    0.00 :	    963e:       48 8b 44 24 28          mov    0x28(%rsp),%rax
    0.00 :	    9643:       48 83 38 00             cmpq   $0x0,(%rax)
    0.00 :	    9647:       0f 85 e4 fd ff ff       jne    9431 <do_lookup_x+0x171>
    0.00 :	    964d:       48 8b 54 24 48          mov    0x48(%rsp),%rdx
    0.00 :	    9652:       48 89 10                mov    %rdx,(%rax)
    0.00 :	    9655:       48 8b 44 24 70          mov    0x70(%rsp),%rax
    0.00 :	    965a:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    0.00 :	    965f:       48 89 41 08             mov    %rax,0x8(%rcx)
    0.00 :	    9663:       e9 c9 fd ff ff          jmpq   9431 <do_lookup_x+0x171>
    0.00 :	    9668:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	    966f:       00 
    0.00 :	    9670:       48 8b 4c 24 58          mov    0x58(%rsp),%rcx
    0.00 :	    9675:       4b 8d 04 76             lea    (%r14,%r14,2),%rax
    0.00 :	    9679:       48 8d 14 c9             lea    (%rcx,%rcx,8),%rdx
    0.00 :	    967d:       48 8d 0d e4 59 21 00    lea    0x2159e4(%rip),%rcx        # 21f068 <_rtld_global+0x8>
    0.00 :	    9684:       48 c1 e2 04             shl    $0x4,%rdx
    0.00 :	    9688:       48 8b 54 11 50          mov    0x50(%rcx,%rdx,1),%rdx
    0.00 :	    968d:       48 c1 e2 02             shl    $0x2,%rdx
    0.00 :	    9691:       48 39 d0                cmp    %rdx,%rax
    0.00 :	    9694:       0f 87 d3 00 00 00       ja     976d <do_lookup_x+0x4ad>
    0.00 :	    969a:       64 8b 04 25 4c 00 00    mov    %fs:0x4c,%eax
    0.00 :	    96a1:       00 
    0.00 :	    96a2:       85 c0                   test   %eax,%eax
    0.00 :	    96a4:       0f 85 9e 04 00 00       jne    9b48 <do_lookup_x+0x888>
    0.00 :	    96aa:       49 8d 7e 01             lea    0x1(%r14),%rdi
    0.00 :	    96ae:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    96b3:       e8 48 54 00 00          callq  eb00 <_dl_higher_prime_number>
    0.00 :	    96b8:       bf 20 00 00 00          mov    $0x20,%edi
    0.00 :	    96bd:       48 89 c6                mov    %rax,%rsi
    0.00 :	    96c0:       49 89 c7                mov    %rax,%r15
    0.00 :	    96c3:       e8 08 74 ff ff          callq  ad0 <calloc@plt>
    0.00 :	    96c8:       48 85 c0                test   %rax,%rax
    0.00 :	    96cb:       49 89 c5                mov    %rax,%r13
    0.00 :	    96ce:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    96d3:       0f 84 da 01 00 00       je     98b3 <do_lookup_x+0x5f3>
    0.00 :	    96d9:       31 ed                   xor    %ebp,%ebp
    0.00 :	    96db:       4d 85 f6                test   %r14,%r14
    0.00 :	    96de:       48 8b 5c 24 50          mov    0x50(%rsp),%rbx
    0.00 :	    96e3:       74 38                   je     971d <do_lookup_x+0x45d>
    0.00 :	    96e5:       0f 1f 00                nopl   (%rax)
    0.00 :	    96e8:       48 8b 4b 08             mov    0x8(%rbx),%rcx
    0.00 :	    96ec:       48 85 c9                test   %rcx,%rcx
    0.00 :	    96ef:       74 1f                   je     9710 <do_lookup_x+0x450>
    0.00 :	    96f1:       4c 8b 4b 18             mov    0x18(%rbx),%r9
    0.00 :	    96f5:       4c 8b 43 10             mov    0x10(%rbx),%r8
    0.00 :	    96f9:       4c 89 fe                mov    %r15,%rsi
    0.00 :	    96fc:       8b 13                   mov    (%rbx),%edx
    0.00 :	    96fe:       4c 89 ef                mov    %r13,%rdi
    0.00 :	    9701:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9706:       e8 a5 f8 ff ff          callq  8fb0 <enter.12145>
    0.00 :	    970b:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    9710:       48 83 c5 01             add    $0x1,%rbp
    0.00 :	    9714:       48 83 c3 20             add    $0x20,%rbx
    0.00 :	    9718:       49 39 ee                cmp    %rbp,%r14
    0.00 :	    971b:       77 cb                   ja     96e8 <do_lookup_x+0x428>
    0.00 :	    971d:       48 8b 44 24 58          mov    0x58(%rsp),%rax
    0.00 :	    9722:       4c 8d 25 37 59 21 00    lea    0x215937(%rip),%r12        # 21f060 <_rtld_global>
    0.00 :	    9729:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    972e:       48 8b 7c 24 50          mov    0x50(%rsp),%rdi
    0.00 :	    9733:       4d 89 fe                mov    %r15,%r14
    0.00 :	    9736:       48 8d 1c c0             lea    (%rax,%rax,8),%rbx
    0.00 :	    973a:       48 c1 e3 04             shl    $0x4,%rbx
    0.00 :	    973e:       49 01 dc                add    %rbx,%r12
    0.00 :	    9741:       41 ff 54 24 60          callq  *0x60(%r12)
    0.00 :	    9746:       48 8b 05 ab 58 21 00    mov    0x2158ab(%rip),%rax        # 21eff8 <_DYNAMIC+0x188>
    0.00 :	    974d:       48 8d 15 14 59 21 00    lea    0x215914(%rip),%rdx        # 21f068 <_rtld_global+0x8>
    0.00 :	    9754:       4d 89 7c 24 50          mov    %r15,0x50(%r12)
    0.00 :	    9759:       4c 89 6c 1a 40          mov    %r13,0x40(%rdx,%rbx,1)
    0.00 :	    975e:       49 89 44 24 60          mov    %rax,0x60(%r12)
    0.00 :	    9763:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    9768:       4c 89 6c 24 50          mov    %r13,0x50(%rsp)
    0.00 :	    976d:       f6 84 24 9c 00 00 00    testb  $0x2,0x9c(%rsp)
    0.00 :	    9774:       02 
    0.00 :	    9775:       75 68                   jne    97df <do_lookup_x+0x51f>
    0.00 :	    9777:       48 8b 54 24 48          mov    0x48(%rsp),%rdx
    0.00 :	    977c:       4c 8b 4c 24 70          mov    0x70(%rsp),%r9
    0.00 :	    9781:       4c 89 f6                mov    %r14,%rsi
    0.00 :	    9784:       48 8b 7c 24 50          mov    0x50(%rsp),%rdi
    0.00 :	    9789:       8b 0a                   mov    (%rdx),%ecx
    0.00 :	    978b:       49 89 d0                mov    %rdx,%r8
    0.00 :	    978e:       44 89 da                mov    %r11d,%edx
    0.00 :	    9791:       48 03 8c 24 80 00 00    add    0x80(%rsp),%rcx
    0.00 :	    9798:       00 
    0.00 :	    9799:       e8 12 f8 ff ff          callq  8fb0 <enter.12145>
    0.00 :	    979e:       48 8b 54 24 70          mov    0x70(%rsp),%rdx
    0.00 :	    97a3:       0f b6 82 14 03 00 00    movzbl 0x314(%rdx),%eax
    0.00 :	    97aa:       83 e0 03                and    $0x3,%eax
    0.00 :	    97ad:       3c 02                   cmp    $0x2,%al
    0.00 :	    97af:       0f 84 f2 00 00 00       je     98a7 <do_lookup_x+0x5e7>
    0.00 :	    97b5:       48 8b 4c 24 58          mov    0x58(%rsp),%rcx
    0.00 :	    97ba:       48 8d 15 a7 58 21 00    lea    0x2158a7(%rip),%rdx        # 21f068 <_rtld_global+0x8>
    0.00 :	    97c1:       48 8d 04 c9             lea    (%rcx,%rcx,8),%rax
    0.00 :	    97c5:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	    97c9:       48 83 44 02 50 01       addq   $0x1,0x50(%rdx,%rax,1)
    0.00 :	    97cf:       48 8b 7c 24 40          mov    0x40(%rsp),%rdi
    0.00 :	    97d4:       ff 15 6e 67 21 00       callq  *0x21676e(%rip)        # 21ff48 <_rtld_global+0xee8>
    0.00 :	    97da:       e9 e8 fc ff ff          jmpq   94c7 <do_lookup_x+0x207>
    0.00 :	    97df:       48 8b 44 24 48          mov    0x48(%rsp),%rax
    0.00 :	    97e4:       4c 8b 8c 24 08 01 00    mov    0x108(%rsp),%r9
    0.00 :	    97eb:       00 
    0.00 :	    97ec:       44 89 da                mov    %r11d,%edx
    0.00 :	    97ef:       4c 8b 84 24 88 00 00    mov    0x88(%rsp),%r8
    0.00 :	    97f6:       00 
    0.00 :	    97f7:       48 8b 7c 24 50          mov    0x50(%rsp),%rdi
    0.00 :	    97fc:       4c 89 f6                mov    %r14,%rsi
    0.00 :	    97ff:       8b 08                   mov    (%rax),%ecx
    0.00 :	    9801:       48 03 8c 24 80 00 00    add    0x80(%rsp),%rcx
    0.00 :	    9808:       00 
    0.00 :	    9809:       e8 a2 f7 ff ff          callq  8fb0 <enter.12145>
    0.00 :	    980e:       eb a5                   jmp    97b5 <do_lookup_x+0x4f5>
    0.00 :	    9810:       64 8b 04 25 4c 00 00    mov    %fs:0x4c,%eax
    0.00 :	    9817:       00 
    0.00 :	    9818:       85 c0                   test   %eax,%eax
    0.00 :	    981a:       0f 85 09 03 00 00       jne    9b29 <do_lookup_x+0x869>
    0.00 :	    9820:       4d 85 f6                test   %r14,%r14
    0.00 :	    9823:       0f 85 d4 02 00 00       jne    9afd <do_lookup_x+0x83d>
    0.00 :	    9829:       be 1f 00 00 00          mov    $0x1f,%esi
    0.00 :	    982e:       bf 20 00 00 00          mov    $0x20,%edi
    0.00 :	    9833:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9838:       e8 93 72 ff ff          callq  ad0 <calloc@plt>
    0.00 :	    983d:       48 85 c0                test   %rax,%rax
    0.00 :	    9840:       48 89 44 24 50          mov    %rax,0x50(%rsp)
    0.00 :	    9845:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    984a:       74 67                   je     98b3 <do_lookup_x+0x5f3>
    0.00 :	    984c:       48 89 45 40             mov    %rax,0x40(%rbp)
    0.00 :	    9850:       48 8b 05 a1 57 21 00    mov    0x2157a1(%rip),%rax        # 21eff8 <_DYNAMIC+0x188>
    0.00 :	    9857:       41 be 1f 00 00 00       mov    $0x1f,%r14d
    0.00 :	    985d:       48 c7 43 50 1f 00 00    movq   $0x1f,0x50(%rbx)
    0.00 :	    9864:       00 
    0.00 :	    9865:       48 89 43 60             mov    %rax,0x60(%rbx)
    0.00 :	    9869:       e9 ff fe ff ff          jmpq   976d <do_lookup_x+0x4ad>
    0.00 :	    986e:       48 8b 50 08             mov    0x8(%rax),%rdx
    0.00 :	    9872:       48 8b 48 30             mov    0x30(%rax),%rcx
    0.00 :	    9876:       80 3a 00                cmpb   $0x0,(%rdx)
    0.00 :	    9879:       75 0a                   jne    9885 <do_lookup_x+0x5c5>
    0.00 :	    987b:       48 8b 05 86 53 21 00    mov    0x215386(%rip),%rax        # 21ec08 <_dl_argv>
    0.00 :	    9882:       48 8b 10                mov    (%rax),%rdx
    0.00 :	    9885:       48 8b 74 24 78          mov    0x78(%rsp),%rsi
    0.00 :	    988a:       48 8d 3d cf 1d 01 00    lea    0x11dcf(%rip),%rdi        # 1b660 <__PRETTY_FUNCTION__.3644+0x12ef>
    0.00 :	    9891:       31 c0                   xor    %eax,%eax
    0.00 :	    9893:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9898:       e8 b3 5a 00 00          callq  f350 <_dl_debug_printf>
    0.00 :	    989d:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    98a2:       e9 08 fb ff ff          jmpq   93af <do_lookup_x+0xef>
    0.00 :	    98a7:       83 8a dc 03 00 00 08    orl    $0x8,0x3dc(%rdx)
    0.00 :	    98ae:       e9 02 ff ff ff          jmpq   97b5 <do_lookup_x+0x4f5>
    0.00 :	    98b3:       48 8b 7c 24 40          mov    0x40(%rsp),%rdi
    0.00 :	    98b8:       ff 15 8a 66 21 00       callq  *0x21668a(%rip)        # 21ff48 <_rtld_global+0xee8>
    0.00 :	    98be:       48 8d 35 7f fe 00 00    lea    0xfe7f(%rip),%rsi        # 19744 <intel_02_known+0x464>
    0.00 :	    98c5:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	    98ca:       31 c0                   xor    %eax,%eax
    0.00 :	    98cc:       e8 2f 59 00 00          callq  f200 <_dl_dprintf>
    0.00 :	    98d1:       bf 7f 00 00 00          mov    $0x7f,%edi
    0.00 :	    98d6:       e8 e5 c9 00 00          callq  162c0 <_Exit>
    0.00 :	    98db:       48 8b 45 10             mov    0x10(%rbp),%rax
    0.00 :	    98df:       48 8b 54 24 28          mov    0x28(%rsp),%rdx
    0.00 :	    98e4:       48 89 02                mov    %rax,(%rdx)
    0.00 :	    98e7:       48 8b 45 18             mov    0x18(%rbp),%rax
    0.00 :	    98eb:       48 89 42 08             mov    %rax,0x8(%rdx)
    0.00 :	    98ef:       e9 11 fd ff ff          jmpq   9605 <do_lookup_x+0x345>
    0.00 :	    98f4:       48 8b 54 24 30          mov    0x30(%rsp),%rdx
    0.00 :	    98f9:       b9 ff ff ff ff          mov    $0xffffffff,%ecx
    0.00 :	    98fe:       48 8b 3a                mov    (%rdx),%rdi
    0.00 :	    9901:       48 39 cf                cmp    %rcx,%rdi
    0.00 :	    9904:       0f 84 41 01 00 00       je     9a4b <do_lookup_x+0x78b>
    0.00 :	    990a:       8b 8e ec 02 00 00       mov    0x2ec(%rsi),%ecx
    0.00 :	    9910:       31 d2                   xor    %edx,%edx
    0.00 :	    9912:       48 89 f8                mov    %rdi,%rax
    0.00 :	    9915:       48 f7 f1                div    %rcx
    0.00 :	    9918:       48 8b 86 08 03 00 00    mov    0x308(%rsi),%rax
    0.00 :	    991f:       8b 04 90                mov    (%rax,%rdx,4),%eax
    0.00 :	    9922:       85 c0                   test   %eax,%eax
    0.00 :	    9924:       89 84 24 98 00 00 00    mov    %eax,0x98(%rsp)
    0.00 :	    992b:       75 30                   jne    995d <do_lookup_x+0x69d>
    0.00 :	    992d:       e9 f5 fa ff ff          jmpq   9427 <do_lookup_x+0x167>
    0.00 :	    9932:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	    9938:       48 8b 54 24 70          mov    0x70(%rsp),%rdx
    0.00 :	    993d:       8b 84 24 98 00 00 00    mov    0x98(%rsp),%eax
    0.00 :	    9944:       48 8b 92 00 03 00 00    mov    0x300(%rdx),%rdx
    0.00 :	    994b:       8b 04 82                mov    (%rdx,%rax,4),%eax
    0.00 :	    994e:       85 c0                   test   %eax,%eax
    0.00 :	    9950:       89 84 24 98 00 00 00    mov    %eax,0x98(%rsp)
    0.00 :	    9957:       0f 84 ca fa ff ff       je     9427 <do_lookup_x+0x167>
    0.00 :	    995d:       89 c7                   mov    %eax,%edi
    0.00 :	    995f:       4c 8b 54 24 20          mov    0x20(%rsp),%r10
    0.00 :	    9964:       4c 89 4c 24 10          mov    %r9,0x10(%rsp)
    0.00 :	    9969:       48 8d 3c 7f             lea    (%rdi,%rdi,2),%rdi
    0.00 :	    996d:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9972:       49 8d 3c f9             lea    (%r9,%rdi,8),%rdi
    0.00 :	    9976:       e8 85 f7 ff ff          callq  9100 <check_match.12097>
    0.00 :	    997b:       48 85 c0                test   %rax,%rax
    0.00 :	    997e:       48 89 44 24 48          mov    %rax,0x48(%rsp)
    0.00 :	    9983:       4c 8b 4c 24 10          mov    0x10(%rsp),%r9
    0.00 :	    9988:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    998d:       74 a9                   je     9938 <do_lookup_x+0x678>
    0.00 :	    998f:       e9 13 fb ff ff          jmpq   94a7 <do_lookup_x+0x1e7>
    0.00 :	    9994:       8b 8e ec 02 00 00       mov    0x2ec(%rsi),%ecx
    0.00 :	    999a:       31 d2                   xor    %edx,%edx
    0.00 :	    999c:       4c 89 d8                mov    %r11,%rax
    0.00 :	    999f:       48 f7 f1                div    %rcx
    0.00 :	    99a2:       48 8b 86 00 03 00 00    mov    0x300(%rsi),%rax
    0.00 :	    99a9:       8b 04 90                mov    (%rax,%rdx,4),%eax
    0.00 :	    99ac:       85 c0                   test   %eax,%eax
    0.00 :	    99ae:       0f 84 68 fa ff ff       je     941c <do_lookup_x+0x15c>
    0.00 :	    99b4:       89 c0                   mov    %eax,%eax
    0.00 :	    99b6:       4c 8d 04 85 00 00 00    lea    0x0(,%rax,4),%r8
    0.00 :	    99bd:       00 
    0.00 :	    99be:       4c 03 86 08 03 00 00    add    0x308(%rsi),%r8
    0.00 :	    99c5:       41 8b 10                mov    (%r8),%edx
   50.00 :	    99c8:       89 d0                   mov    %edx,%eax
    0.00 :	    99ca:       4c 31 d8                xor    %r11,%rax
    0.00 :	    99cd:       48 d1 e8                shr    %rax
    0.00 :	    99d0:       74 1a                   je     99ec <do_lookup_x+0x72c>
    0.00 :	    99d2:       83 e2 01                and    $0x1,%edx
    0.00 :	    99d5:       0f 85 41 fa ff ff       jne    941c <do_lookup_x+0x15c>
    0.00 :	    99db:       49 83 c0 04             add    $0x4,%r8
    0.00 :	    99df:       41 8b 10                mov    (%r8),%edx
    0.00 :	    99e2:       89 d0                   mov    %edx,%eax
    0.00 :	    99e4:       4c 31 d8                xor    %r11,%rax
    0.00 :	    99e7:       48 d1 e8                shr    %rax
    0.00 :	    99ea:       75 e6                   jne    99d2 <do_lookup_x+0x712>
    0.00 :	    99ec:       48 8b 44 24 70          mov    0x70(%rsp),%rax
    0.00 :	    99f1:       4c 89 c7                mov    %r8,%rdi
    0.00 :	    99f4:       4c 8b 54 24 20          mov    0x20(%rsp),%r10
    0.00 :	    99f9:       48 2b b8 08 03 00 00    sub    0x308(%rax),%rdi
    0.00 :	    9a00:       4c 89 44 24 18          mov    %r8,0x18(%rsp)
    0.00 :	    9a05:       4c 89 4c 24 10          mov    %r9,0x10(%rsp)
    0.00 :	    9a0a:       4c 89 5c 24 08          mov    %r11,0x8(%rsp)
    0.00 :	    9a0f:       48 c1 ff 02             sar    $0x2,%rdi
    0.00 :	    9a13:       89 bc 24 98 00 00 00    mov    %edi,0x98(%rsp)
    0.00 :	    9a1a:       89 ff                   mov    %edi,%edi
    0.00 :	    9a1c:       48 8d 3c 7f             lea    (%rdi,%rdi,2),%rdi
    0.00 :	    9a20:       49 8d 3c f9             lea    (%r9,%rdi,8),%rdi
    0.00 :	    9a24:       e8 d7 f6 ff ff          callq  9100 <check_match.12097>
    0.00 :	    9a29:       48 85 c0                test   %rax,%rax
    0.00 :	    9a2c:       48 89 44 24 48          mov    %rax,0x48(%rsp)
    0.00 :	    9a31:       4c 8b 44 24 18          mov    0x18(%rsp),%r8
    0.00 :	    9a36:       4c 8b 4c 24 10          mov    0x10(%rsp),%r9
    0.00 :	    9a3b:       4c 8b 5c 24 08          mov    0x8(%rsp),%r11
    0.00 :	    9a40:       0f 85 61 fa ff ff       jne    94a7 <do_lookup_x+0x1e7>
    0.00 :	    9a46:       41 8b 10                mov    (%r8),%edx
    0.00 :	    9a49:       eb 87                   jmp    99d2 <do_lookup_x+0x712>
    0.00 :	    9a4b:       48 8b 54 24 78          mov    0x78(%rsp),%rdx
    0.00 :	    9a50:       31 ff                   xor    %edi,%edi
    0.00 :	    9a52:       0f b6 02                movzbl (%rdx),%eax
    0.00 :	    9a55:       84 c0                   test   %al,%al
    0.00 :	    9a57:       0f 84 93 00 00 00       je     9af0 <do_lookup_x+0x830>
    0.00 :	    9a5d:       0f b6 c8                movzbl %al,%ecx
    0.00 :	    9a60:       0f b6 42 01             movzbl 0x1(%rdx),%eax
    0.00 :	    9a64:       89 cf                   mov    %ecx,%edi
    0.00 :	    9a66:       84 c0                   test   %al,%al
    0.00 :	    9a68:       0f 84 82 00 00 00       je     9af0 <do_lookup_x+0x830>
    0.00 :	    9a6e:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	    9a72:       0f b6 c0                movzbl %al,%eax
    0.00 :	    9a75:       48 8d 0c 08             lea    (%rax,%rcx,1),%rcx
    0.00 :	    9a79:       0f b6 42 02             movzbl 0x2(%rdx),%eax
    0.00 :	    9a7d:       89 cf                   mov    %ecx,%edi
    0.00 :	    9a7f:       84 c0                   test   %al,%al
    0.00 :	    9a81:       74 6d                   je     9af0 <do_lookup_x+0x830>
    0.00 :	    9a83:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	    9a87:       0f b6 c0                movzbl %al,%eax
    0.00 :	    9a8a:       48 01 c1                add    %rax,%rcx
    0.00 :	    9a8d:       0f b6 42 03             movzbl 0x3(%rdx),%eax
    0.00 :	    9a91:       89 cf                   mov    %ecx,%edi
    0.00 :	    9a93:       84 c0                   test   %al,%al
    0.00 :	    9a95:       74 59                   je     9af0 <do_lookup_x+0x830>
    0.00 :	    9a97:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	    9a9b:       0f b6 c0                movzbl %al,%eax
    0.00 :	    9a9e:       48 01 c1                add    %rax,%rcx
    0.00 :	    9aa1:       0f b6 42 04             movzbl 0x4(%rdx),%eax
    0.00 :	    9aa5:       89 cf                   mov    %ecx,%edi
    0.00 :	    9aa7:       84 c0                   test   %al,%al
    0.00 :	    9aa9:       74 45                   je     9af0 <do_lookup_x+0x830>
    0.00 :	    9aab:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	    9aaf:       0f b6 c0                movzbl %al,%eax
    0.00 :	    9ab2:       4c 8d 42 05             lea    0x5(%rdx),%r8
    0.00 :	    9ab6:       48 01 c1                add    %rax,%rcx
    0.00 :	    9ab9:       0f b6 42 05             movzbl 0x5(%rdx),%eax
    0.00 :	    9abd:       89 cf                   mov    %ecx,%edi
    0.00 :	    9abf:       84 c0                   test   %al,%al
    0.00 :	    9ac1:       74 2d                   je     9af0 <do_lookup_x+0x830>
    0.00 :	    9ac3:       48 c1 e1 04             shl    $0x4,%rcx
    0.00 :	    9ac7:       0f b6 d0                movzbl %al,%edx
    0.00 :	    9aca:       49 83 c0 01             add    $0x1,%r8
    0.00 :	    9ace:       48 01 ca                add    %rcx,%rdx
    0.00 :	    9ad1:       48 89 d0                mov    %rdx,%rax
    0.00 :	    9ad4:       25 00 00 00 f0          and    $0xf0000000,%eax
    0.00 :	    9ad9:       48 89 c1                mov    %rax,%rcx
    0.00 :	    9adc:       48 c1 e8 18             shr    $0x18,%rax
    0.00 :	    9ae0:       48 31 d1                xor    %rdx,%rcx
    0.00 :	    9ae3:       48 31 c1                xor    %rax,%rcx
    0.00 :	    9ae6:       41 0f b6 00             movzbl (%r8),%eax
    0.00 :	    9aea:       84 c0                   test   %al,%al
    0.00 :	    9aec:       75 d5                   jne    9ac3 <do_lookup_x+0x803>
    0.00 :	    9aee:       89 cf                   mov    %ecx,%edi
    0.00 :	    9af0:       48 8b 44 24 30          mov    0x30(%rsp),%rax
    0.00 :	    9af5:       48 89 38                mov    %rdi,(%rax)
    0.00 :	    9af8:       e9 0d fe ff ff          jmpq   990a <do_lookup_x+0x64a>
    0.00 :	    9afd:       f6 05 1d 51 21 00 04    testb  $0x4,0x21511d(%rip)        # 21ec21 <_rtld_global_ro+0x1>
    0.00 :	    9b04:       0f 85 c5 fc ff ff       jne    97cf <do_lookup_x+0x50f>
    0.00 :	    9b0a:       48 8d 0d b6 01 01 00    lea    0x101b6(%rip),%rcx        # 19cc7 <__PRETTY_FUNCTION__.12172>
    0.00 :	    9b11:       48 8d 35 bc 00 01 00    lea    0x100bc(%rip),%rsi        # 19bd4 <__PRETTY_FUNCTION__.12287+0x73>
    0.00 :	    9b18:       48 8d 3d 21 1e 01 00    lea    0x11e21(%rip),%rdi        # 1b940 <__PRETTY_FUNCTION__.3644+0x15cf>
    0.00 :	    9b1f:       ba a2 01 00 00          mov    $0x1a2,%edx
    0.00 :	    9b24:       e8 47 b2 00 00          callq  14d70 <__GI___assert_fail>
    0.00 :	    9b29:       48 8d 0d 97 01 01 00    lea    0x10197(%rip),%rcx        # 19cc7 <__PRETTY_FUNCTION__.12172>
    0.00 :	    9b30:       48 8d 35 9d 00 01 00    lea    0x1009d(%rip),%rsi        # 19bd4 <__PRETTY_FUNCTION__.12287+0x73>
    0.00 :	    9b37:       48 8d 3d 4a 1b 01 00    lea    0x11b4a(%rip),%rdi        # 1b688 <__PRETTY_FUNCTION__.3644+0x1317>
    0.00 :	    9b3e:       ba 97 01 00 00          mov    $0x197,%edx
    0.00 :	    9b43:       e8 28 b2 00 00          callq  14d70 <__GI___assert_fail>
    0.00 :	    9b48:       48 8d 0d 78 01 01 00    lea    0x10178(%rip),%rcx        # 19cc7 <__PRETTY_FUNCTION__.12172>
    0.00 :	    9b4f:       48 8d 35 7e 00 01 00    lea    0x1007e(%rip),%rsi        # 19bd4 <__PRETTY_FUNCTION__.12287+0x73>
    0.00 :	    9b56:       48 8d 3d 2b 1b 01 00    lea    0x11b2b(%rip),%rdi        # 1b688 <__PRETTY_FUNCTION__.3644+0x1317>
    0.00 :	    9b5d:       ba 7a 01 00 00          mov    $0x17a,%edx
    0.00 :	    9b62:       e8 09 b2 00 00          callq  14d70 <__GI___assert_fail>

Sorted summary for file /bin/bash
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /bin/bash
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046c3e0 <strvec_resize>:
    0.00 :	  46c3e0:       48 63 f6                movslq %esi,%rsi
  100.00 :	  46c3e3:       48 c1 e6 03             shl    $0x3,%rsi
    0.00 :	  46c3e7:       e9 44 be fe ff          jmpq   458230 <xrealloc>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000008cd90 <__mbrtowc>:
    0.00 :	   8cd90:       48 89 6c 24 d8          mov    %rbp,-0x28(%rsp)
    0.00 :	   8cd95:       4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
    0.00 :	   8cd9a:       48 89 d5                mov    %rdx,%rbp
    0.00 :	   8cd9d:       4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
    0.00 :	   8cda2:       48 89 5c 24 d0          mov    %rbx,-0x30(%rsp)
    0.00 :	   8cda7:       48 8d 05 ee 7b 2e 00    lea    0x2e7bee(%rip),%rax        # 37499c <state>
    0.00 :	   8cdae:       4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
    0.00 :	   8cdb3:       4c 89 7c 24 f8          mov    %r15,-0x8(%rsp)
    0.00 :	   8cdb8:       48 81 ec a8 00 00 00    sub    $0xa8,%rsp
    0.00 :	   8cdbf:       48 8d 54 24 60          lea    0x60(%rsp),%rdx
    0.00 :	   8cdc4:       48 85 ff                test   %rdi,%rdi
    0.00 :	   8cdc7:       49 89 f5                mov    %rsi,%r13
    0.00 :	   8cdca:       c7 44 24 24 00 00 00    movl   $0x0,0x24(%rsp)
    0.00 :	   8cdd1:       00 
    0.00 :	   8cdd2:       c7 44 24 28 01 00 00    movl   $0x1,0x28(%rsp)
    0.00 :	   8cdd9:       00 
    0.00 :	   8cdda:       48 0f 44 fa             cmove  %rdx,%rdi
    0.00 :	   8cdde:       48 85 c9                test   %rcx,%rcx
    0.00 :	   8cde1:       c7 44 24 20 01 00 00    movl   $0x1,0x20(%rsp)
    0.00 :	   8cde8:       00 
    0.00 :	   8cde9:       48 0f 44 c8             cmove  %rax,%rcx
    0.00 :	   8cded:       48 85 f6                test   %rsi,%rsi
    0.00 :	   8cdf0:       48 c7 44 24 40 00 00    movq   $0x0,0x40(%rsp)
    0.00 :	   8cdf7:       00 00 
    0.00 :	   8cdf9:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
    0.00 :	   8cdfe:       49 89 fe                mov    %rdi,%r14
    0.00 :	   8ce01:       0f 84 59 01 00 00       je     8cf60 <__mbrtowc+0x1d0>
    0.00 :	   8ce07:       49 8d 46 04             lea    0x4(%r14),%rax
    0.00 :	   8ce0b:       64 4c 8b 3c 25 00 00    mov    %fs:0x0,%r15
    0.00 :	   8ce12:       00 00 
    0.00 :	   8ce14:       4c 89 74 24 10          mov    %r14,0x10(%rsp)
    0.00 :	   8ce19:       48 89 44 24 18          mov    %rax,0x18(%rsp)
    0.00 :	   8ce1e:       48 8b 05 63 4f 2e 00    mov    0x2e4f63(%rip),%rax        # 371d88 <_DYNAMIC+0x228>
    0.00 :	   8ce25:       49 8b 04 07             mov    (%r15,%rax,1),%rax
    0.00 :	   8ce29:       48 8b 18                mov    (%rax),%rbx
    0.00 :	   8ce2c:       4c 8b 63 28             mov    0x28(%rbx),%r12
    0.00 :	   8ce30:       4d 85 e4                test   %r12,%r12
    0.00 :	   8ce33:       0f 84 3f 01 00 00       je     8cf78 <__mbrtowc+0x1e8>
    0.00 :	   8ce39:       4c 01 ed                add    %r13,%rbp
    0.00 :	   8ce3c:       48 c7 c0 ff ff ff ff    mov    $0xffffffffffffffff,%rax
    0.00 :	   8ce43:       4c 89 6c 24 50          mov    %r13,0x50(%rsp)
    0.00 :	   8ce48:       48 0f 42 e8             cmovb  %rax,%rbp
    0.00 :	   8ce4c:       49 8b 04 24             mov    (%r12),%rax
    0.00 :	   8ce50:       48 83 38 00             cmpq   $0x0,(%rax)
    0.00 :	   8ce54:       48 8b 58 28             mov    0x28(%rax),%rbx
    0.00 :	   8ce58:       74 0d                   je     8ce67 <__mbrtowc+0xd7>
    0.00 :	   8ce5a:       48 c1 cb 11             ror    $0x11,%rbx
    0.00 :	   8ce5e:       64 48 33 1c 25 30 00    xor    %fs:0x30,%rbx
    0.00 :	   8ce65:       00 00 
    0.00 :	   8ce67:       48 89 df                mov    %rbx,%rdi
    0.00 :	   8ce6a:       e8 a1 5e 08 00          callq  112d10 <_dl_mcount_wrapper_check>
    0.00 :	   8ce6f:       c7 44 24 08 01 00 00    movl   $0x1,0x8(%rsp)
    0.00 :	   8ce76:       00 
    0.00 :	   8ce77:       c7 04 24 00 00 00 00    movl   $0x0,(%rsp)
    0.00 :	   8ce7e:       45 31 c0                xor    %r8d,%r8d
    0.00 :	   8ce81:       48 8d 54 24 50          lea    0x50(%rsp),%rdx
  100.00 :	   8ce86:       48 8d 74 24 10          lea    0x10(%rsp),%rsi
    0.00 :	   8ce8b:       4c 8d 4c 24 58          lea    0x58(%rsp),%r9
    0.00 :	   8ce90:       48 89 e9                mov    %rbp,%rcx
    0.00 :	   8ce93:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	   8ce97:       ff d3                   callq  *%rbx
    0.00 :	   8ce99:       85 c0                   test   %eax,%eax
    0.00 :	   8ce9b:       74 19                   je     8ceb6 <__mbrtowc+0x126>
    0.00 :	   8ce9d:       83 f8 04                cmp    $0x4,%eax
    0.00 :	   8cea0:       74 7e                   je     8cf20 <__mbrtowc+0x190>
    0.00 :	   8cea2:       83 f8 06                cmp    $0x6,%eax
    0.00 :	   8cea5:       74 79                   je     8cf20 <__mbrtowc+0x190>
    0.00 :	   8cea7:       83 f8 07                cmp    $0x7,%eax
    0.00 :	   8ceaa:       74 74                   je     8cf20 <__mbrtowc+0x190>
    0.00 :	   8ceac:       83 f8 05                cmp    $0x5,%eax
    0.00 :	   8ceaf:       90                      nop
    0.00 :	   8ceb0:       0f 85 ea 00 00 00       jne    8cfa0 <__mbrtowc+0x210>
    0.00 :	   8ceb6:       4c 39 74 24 10          cmp    %r14,0x10(%rsp)
    0.00 :	   8cebb:       74 53                   je     8cf10 <__mbrtowc+0x180>
    0.00 :	   8cebd:       41 8b 16                mov    (%r14),%edx
    0.00 :	   8cec0:       85 d2                   test   %edx,%edx
    0.00 :	   8cec2:       75 4c                   jne    8cf10 <__mbrtowc+0x180>
    0.00 :	   8cec4:       48 8b 44 24 30          mov    0x30(%rsp),%rax
    0.00 :	   8cec9:       31 d2                   xor    %edx,%edx
    0.00 :	   8cecb:       8b 00                   mov    (%rax),%eax
    0.00 :	   8cecd:       85 c0                   test   %eax,%eax
    0.00 :	   8cecf:       0f 85 ea 00 00 00       jne    8cfbf <__mbrtowc+0x22f>
    0.00 :	   8ced5:       48 89 d0                mov    %rdx,%rax
    0.00 :	   8ced8:       48 8b 5c 24 78          mov    0x78(%rsp),%rbx
    0.00 :	   8cedd:       48 8b ac 24 80 00 00    mov    0x80(%rsp),%rbp
    0.00 :	   8cee4:       00 
    0.00 :	   8cee5:       4c 8b a4 24 88 00 00    mov    0x88(%rsp),%r12
    0.00 :	   8ceec:       00 
    0.00 :	   8ceed:       4c 8b ac 24 90 00 00    mov    0x90(%rsp),%r13
    0.00 :	   8cef4:       00 
    0.00 :	   8cef5:       4c 8b b4 24 98 00 00    mov    0x98(%rsp),%r14
    0.00 :	   8cefc:       00 
    0.00 :	   8cefd:       4c 8b bc 24 a0 00 00    mov    0xa0(%rsp),%r15
    0.00 :	   8cf04:       00 
    0.00 :	   8cf05:       48 81 c4 a8 00 00 00    add    $0xa8,%rsp
    0.00 :	   8cf0c:       c3                      retq   
    0.00 :	   8cf0d:       0f 1f 00                nopl   (%rax)
    0.00 :	   8cf10:       48 8b 54 24 50          mov    0x50(%rsp),%rdx
    0.00 :	   8cf15:       4c 29 ea                sub    %r13,%rdx
    0.00 :	   8cf18:       eb bb                   jmp    8ced5 <__mbrtowc+0x145>
    0.00 :	   8cf1a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	   8cf20:       85 c0                   test   %eax,%eax
    0.00 :	   8cf22:       74 92                   je     8ceb6 <__mbrtowc+0x126>
    0.00 :	   8cf24:       83 f8 04                cmp    $0x4,%eax
    0.00 :	   8cf27:       74 8d                   je     8ceb6 <__mbrtowc+0x126>
    0.00 :	   8cf29:       83 f8 05                cmp    $0x5,%eax
    0.00 :	   8cf2c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   8cf30:       74 84                   je     8ceb6 <__mbrtowc+0x126>
    0.00 :	   8cf32:       83 f8 07                cmp    $0x7,%eax
    0.00 :	   8cf35:       48 c7 c2 fe ff ff ff    mov    $0xfffffffffffffffe,%rdx
    0.00 :	   8cf3c:       74 97                   je     8ced5 <__mbrtowc+0x145>
    0.00 :	   8cf3e:       48 8b 05 f3 4e 2e 00    mov    0x2e4ef3(%rip),%rax        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   8cf45:       48 c7 c2 ff ff ff ff    mov    $0xffffffffffffffff,%rdx
    0.00 :	   8cf4c:       41 c7 04 07 54 00 00    movl   $0x54,(%r15,%rax,1)
    0.00 :	   8cf53:       00 
    0.00 :	   8cf54:       e9 7c ff ff ff          jmpq   8ced5 <__mbrtowc+0x145>
    0.00 :	   8cf59:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	   8cf60:       49 89 d6                mov    %rdx,%r14
    0.00 :	   8cf63:       4c 8d 2d d6 da 0a 00    lea    0xadad6(%rip),%r13        # 13aa40 <not_available+0x117>
    0.00 :	   8cf6a:       bd 01 00 00 00          mov    $0x1,%ebp
    0.00 :	   8cf6f:       e9 93 fe ff ff          jmpq   8ce07 <__mbrtowc+0x77>
    0.00 :	   8cf74:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	   8cf78:       48 8d 05 c1 2d 2e 00    lea    0x2e2dc1(%rip),%rax        # 36fd40 <_nl_C_LC_CTYPE>
    0.00 :	   8cf7f:       4c 8d 25 7a 24 2e 00    lea    0x2e247a(%rip),%r12        # 36f400 <__wcsmbs_gconv_fcts_c>
    0.00 :	   8cf86:       48 39 c3                cmp    %rax,%rbx
    0.00 :	   8cf89:       0f 84 aa fe ff ff       je     8ce39 <__mbrtowc+0xa9>
    0.00 :	   8cf8f:       48 89 df                mov    %rbx,%rdi
    0.00 :	   8cf92:       e8 59 a3 00 00          callq  972f0 <__wcsmbs_load_conv>
    0.00 :	   8cf97:       4c 8b 63 28             mov    0x28(%rbx),%r12
    0.00 :	   8cf9b:       e9 99 fe ff ff          jmpq   8ce39 <__mbrtowc+0xa9>
    0.00 :	   8cfa0:       48 8d 0d 48 f0 0a 00    lea    0xaf048(%rip),%rcx        # 13bfef <__PRETTY_FUNCTION__.11266>
    0.00 :	   8cfa7:       48 8d 35 37 f0 0a 00    lea    0xaf037(%rip),%rsi        # 13bfe5 <__PRETTY_FUNCTION__.3721+0xb>
    0.00 :	   8cfae:       48 8d 3d 63 33 0b 00    lea    0xb3363(%rip),%rdi        # 140318 <__PRETTY_FUNCTION__.11129+0x293f>
    0.00 :	   8cfb5:       ba 5c 00 00 00          mov    $0x5c,%edx
    0.00 :	   8cfba:       e8 61 e9 f9 ff          callq  2b920 <__assert_fail>
    0.00 :	   8cfbf:       48 8d 0d 29 f0 0a 00    lea    0xaf029(%rip),%rcx        # 13bfef <__PRETTY_FUNCTION__.11266>
    0.00 :	   8cfc6:       48 8d 35 18 f0 0a 00    lea    0xaf018(%rip),%rsi        # 13bfe5 <__PRETTY_FUNCTION__.3721+0xb>
    0.00 :	   8cfcd:       48 8d 3d e4 33 0b 00    lea    0xb33e4(%rip),%rdi        # 1403b8 <__PRETTY_FUNCTION__.11129+0x29df>
    0.00 :	   8cfd4:       ba 65 00 00 00          mov    $0x65,%edx
    0.00 :	   8cfd9:       e8 42 e9 f9 ff          callq  2b920 <__assert_fail>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000001129c0 <_dl_addr>:
    0.00 :	  1129c0:       41 57                   push   %r15
    0.00 :	  1129c2:       49 89 f7                mov    %rsi,%r15
    0.00 :	  1129c5:       41 56                   push   %r14
    0.00 :	  1129c7:       41 55                   push   %r13
    0.00 :	  1129c9:       41 54                   push   %r12
    0.00 :	  1129cb:       55                      push   %rbp
    0.00 :	  1129cc:       48 89 fd                mov    %rdi,%rbp
    0.00 :	  1129cf:       53                      push   %rbx
    0.00 :	  1129d0:       48 83 ec 28             sub    $0x28,%rsp
    0.00 :	  1129d4:       48 8b 05 dd f3 25 00    mov    0x25f3dd(%rip),%rax        # 371db8 <_DYNAMIC+0x258>
    0.00 :	  1129db:       48 89 54 24 10          mov    %rdx,0x10(%rsp)
    0.00 :	  1129e0:       48 89 4c 24 08          mov    %rcx,0x8(%rsp)
    0.00 :	  1129e5:       48 8d b8 08 09 00 00    lea    0x908(%rax),%rdi
    0.00 :	  1129ec:       ff 90 e0 0e 00 00       callq  *0xee0(%rax)
    0.00 :	  1129f2:       48 8b 05 bf f3 25 00    mov    0x25f3bf(%rip),%rax        # 371db8 <_DYNAMIC+0x258>
    0.00 :	  1129f9:       48 83 b8 00 09 00 00    cmpq   $0x0,0x900(%rax)
    0.00 :	  112a00:       00 
    0.00 :	  112a01:       74 63                   je     112a66 <_dl_addr+0xa6>
    0.00 :	  112a03:       49 89 c4                mov    %rax,%r12
    0.00 :	  112a06:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  112a09:       49 8b 1c 24             mov    (%r12),%rbx
    0.00 :	  112a0d:       48 85 db                test   %rbx,%rbx
    0.00 :	  112a10:       74 39                   je     112a4b <_dl_addr+0x8b>
    0.00 :	  112a12:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  112a18:       48 3b ab 40 03 00 00    cmp    0x340(%rbx),%rbp
    0.00 :	  112a1f:       72 21                   jb     112a42 <_dl_addr+0x82>
    0.00 :	  112a21:       48 3b ab 48 03 00 00    cmp    0x348(%rbx),%rbp
    0.00 :	  112a28:       73 18                   jae    112a42 <_dl_addr+0x82>
    0.00 :	  112a2a:       f6 83 15 03 00 00 40    testb  $0x40,0x315(%rbx)
    0.00 :	  112a31:       75 3d                   jne    112a70 <_dl_addr+0xb0>
    0.00 :	  112a33:       48 89 ee                mov    %rbp,%rsi
    0.00 :	  112a36:       48 89 df                mov    %rbx,%rdi
    0.00 :	  112a39:       e8 12 ff ff ff          callq  112950 <_dl_addr_inside_object>
    0.00 :	  112a3e:       85 c0                   test   %eax,%eax
    0.00 :	  112a40:       75 2e                   jne    112a70 <_dl_addr+0xb0>
    0.00 :	  112a42:       48 8b 5b 18             mov    0x18(%rbx),%rbx
    0.00 :	  112a46:       48 85 db                test   %rbx,%rbx
    0.00 :	  112a49:       75 cd                   jne    112a18 <_dl_addr+0x58>
    0.00 :	  112a4b:       48 8b 05 66 f3 25 00    mov    0x25f366(%rip),%rax        # 371db8 <_DYNAMIC+0x258>
    0.00 :	  112a52:       49 83 c5 01             add    $0x1,%r13
    0.00 :	  112a56:       49 81 c4 90 00 00 00    add    $0x90,%r12
    0.00 :	  112a5d:       4c 39 a8 00 09 00 00    cmp    %r13,0x900(%rax)
    0.00 :	  112a64:       77 a3                   ja     112a09 <_dl_addr+0x49>
    0.00 :	  112a66:       31 db                   xor    %ebx,%ebx
    0.00 :	  112a68:       e9 77 01 00 00          jmpq   112be4 <_dl_addr+0x224>
    0.00 :	  112a6d:       0f 1f 00                nopl   (%rax)
    0.00 :	  112a70:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  112a74:       49 89 07                mov    %rax,(%r15)
    0.00 :	  112a77:       48 8b 83 40 03 00 00    mov    0x340(%rbx),%rax
    0.00 :	  112a7e:       49 89 47 08             mov    %rax,0x8(%r15)
    0.00 :	  112a82:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  112a86:       80 38 00                cmpb   $0x0,(%rax)
    0.00 :	  112a89:       0f 84 7a 01 00 00       je     112c09 <_dl_addr+0x249>
    0.00 :	  112a8f:       48 8b 43 70             mov    0x70(%rbx),%rax
    0.00 :	  112a93:       4c 8b 60 08             mov    0x8(%rax),%r12
    0.00 :	  112a97:       48 8b 43 68             mov    0x68(%rbx),%rax
    0.00 :	  112a9b:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	  112a9f:       48 89 44 24 20          mov    %rax,0x20(%rsp)
    0.00 :	  112aa4:       48 8b 83 90 00 00 00    mov    0x90(%rbx),%rax
    0.00 :	  112aab:       8b 40 08                mov    0x8(%rax),%eax
    0.00 :	  112aae:       89 44 24 1c             mov    %eax,0x1c(%rsp)
    0.00 :	  112ab2:       48 83 bb 98 02 00 00    cmpq   $0x0,0x298(%rbx)
    0.00 :	  112ab9:       00 
    0.00 :	  112aba:       0f 84 6b 01 00 00       je     112c2b <_dl_addr+0x26b>
    0.00 :	  112ac0:       44 8b ab ec 02 00 00    mov    0x2ec(%rbx),%r13d
    0.00 :	  112ac7:       45 85 ed                test   %r13d,%r13d
    0.00 :	  112aca:       0f 84 c9 00 00 00       je     112b99 <_dl_addr+0x1d9>
    0.00 :	  112ad0:       4c 8b b3 00 03 00 00    mov    0x300(%rbx),%r14
    0.00 :	  112ad7:       45 31 c9                xor    %r9d,%r9d
    0.00 :	  112ada:       45 31 db                xor    %r11d,%r11d
    0.00 :	  112add:       0f 1f 00                nopl   (%rax)
    0.00 :	  112ae0:       47 8b 04 9e             mov    (%r14,%r11,4),%r8d
    0.00 :	  112ae4:       4c 89 ca                mov    %r9,%rdx
    0.00 :	  112ae7:       45 85 c0                test   %r8d,%r8d
    0.00 :	  112aea:       0f 84 98 00 00 00       je     112b88 <_dl_addr+0x1c8>
    0.00 :	  112af0:       44 89 c0                mov    %r8d,%eax
    0.00 :	  112af3:       48 8d 3c 85 00 00 00    lea    0x0(,%rax,4),%rdi
    0.00 :	  112afa:       00 
    0.00 :	  112afb:       48 03 bb 08 03 00 00    add    0x308(%rbx),%rdi
    0.00 :	  112b02:       eb 12                   jmp    112b16 <_dl_addr+0x156>
    0.00 :	  112b04:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  112b08:       41 83 c0 01             add    $0x1,%r8d
    0.00 :	  112b0c:       48 83 c7 04             add    $0x4,%rdi
    0.00 :	  112b10:       49 89 d1                mov    %rdx,%r9
    0.00 :	  112b13:       44 89 c0                mov    %r8d,%eax
    0.00 :	  112b16:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  112b1a:       49 8d 14 c4             lea    (%r12,%rax,8),%rdx
    0.00 :	  112b1e:       0f b7 72 06             movzwl 0x6(%rdx),%esi
  100.00 :	  112b22:       66 85 f6                test   %si,%si
    0.00 :	  112b25:       75 07                   jne    112b2e <_dl_addr+0x16e>
    0.00 :	  112b27:       48 83 7a 08 00          cmpq   $0x0,0x8(%rdx)
    0.00 :	  112b2c:       74 52                   je     112b80 <_dl_addr+0x1c0>
    0.00 :	  112b2e:       0f b6 42 04             movzbl 0x4(%rdx),%eax
    0.00 :	  112b32:       83 e0 0f                and    $0xf,%eax
    0.00 :	  112b35:       83 f8 06                cmp    $0x6,%eax
    0.00 :	  112b38:       74 46                   je     112b80 <_dl_addr+0x1c0>
    0.00 :	  112b3a:       4c 8b 52 08             mov    0x8(%rdx),%r10
    0.00 :	  112b3e:       4c 89 d1                mov    %r10,%rcx
    0.00 :	  112b41:       48 03 0b                add    (%rbx),%rcx
    0.00 :	  112b44:       48 39 cd                cmp    %rcx,%rbp
    0.00 :	  112b47:       72 37                   jb     112b80 <_dl_addr+0x1c0>
    0.00 :	  112b49:       66 85 f6                test   %si,%si
    0.00 :	  112b4c:       74 09                   je     112b57 <_dl_addr+0x197>
    0.00 :	  112b4e:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  112b52:       48 85 c0                test   %rax,%rax
    0.00 :	  112b55:       75 09                   jne    112b60 <_dl_addr+0x1a0>
    0.00 :	  112b57:       48 39 cd                cmp    %rcx,%rbp
    0.00 :	  112b5a:       74 0c                   je     112b68 <_dl_addr+0x1a8>
    0.00 :	  112b5c:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  112b60:       48 01 c8                add    %rcx,%rax
    0.00 :	  112b63:       48 39 c5                cmp    %rax,%rbp
    0.00 :	  112b66:       73 18                   jae    112b80 <_dl_addr+0x1c0>
    0.00 :	  112b68:       4d 85 c9                test   %r9,%r9
    0.00 :	  112b6b:       74 06                   je     112b73 <_dl_addr+0x1b3>
    0.00 :	  112b6d:       4d 3b 51 08             cmp    0x8(%r9),%r10
    0.00 :	  112b71:       76 0d                   jbe    112b80 <_dl_addr+0x1c0>
    0.00 :	  112b73:       8b 44 24 1c             mov    0x1c(%rsp),%eax
    0.00 :	  112b77:       3b 02                   cmp    (%rdx),%eax
    0.00 :	  112b79:       77 08                   ja     112b83 <_dl_addr+0x1c3>
    0.00 :	  112b7b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  112b80:       4c 89 ca                mov    %r9,%rdx
    0.00 :	  112b83:       f6 07 01                testb  $0x1,(%rdi)
    0.00 :	  112b86:       74 80                   je     112b08 <_dl_addr+0x148>
    0.00 :	  112b88:       49 83 c3 01             add    $0x1,%r11
    0.00 :	  112b8c:       45 39 dd                cmp    %r11d,%r13d
    0.00 :	  112b8f:       76 0f                   jbe    112ba0 <_dl_addr+0x1e0>
    0.00 :	  112b91:       49 89 d1                mov    %rdx,%r9
    0.00 :	  112b94:       e9 47 ff ff ff          jmpq   112ae0 <_dl_addr+0x120>
    0.00 :	  112b99:       31 d2                   xor    %edx,%edx
    0.00 :	  112b9b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  112ba0:       48 83 7c 24 10 00       cmpq   $0x0,0x10(%rsp)
    0.00 :	  112ba6:       74 08                   je     112bb0 <_dl_addr+0x1f0>
    0.00 :	  112ba8:       48 8b 44 24 10          mov    0x10(%rsp),%rax
    0.00 :	  112bad:       48 89 18                mov    %rbx,(%rax)
    0.00 :	  112bb0:       48 83 7c 24 08 00       cmpq   $0x0,0x8(%rsp)
    0.00 :	  112bb6:       74 08                   je     112bc0 <_dl_addr+0x200>
    0.00 :	  112bb8:       48 8b 44 24 08          mov    0x8(%rsp),%rax
    0.00 :	  112bbd:       48 89 10                mov    %rdx,(%rax)
    0.00 :	  112bc0:       48 85 d2                test   %rdx,%rdx
    0.00 :	  112bc3:       0f 84 1f 01 00 00       je     112ce8 <_dl_addr+0x328>
    0.00 :	  112bc9:       8b 02                   mov    (%rdx),%eax
    0.00 :	  112bcb:       48 03 44 24 20          add    0x20(%rsp),%rax
    0.00 :	  112bd0:       49 89 47 10             mov    %rax,0x10(%r15)
    0.00 :	  112bd4:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  112bd8:       48 03 03                add    (%rbx),%rax
    0.00 :	  112bdb:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  112be0:       49 89 47 18             mov    %rax,0x18(%r15)
    0.00 :	  112be4:       48 8b 05 cd f1 25 00    mov    0x25f1cd(%rip),%rax        # 371db8 <_DYNAMIC+0x258>
    0.00 :	  112beb:       48 8d b8 08 09 00 00    lea    0x908(%rax),%rdi
    0.00 :	  112bf2:       ff 90 e8 0e 00 00       callq  *0xee8(%rax)
    0.00 :	  112bf8:       48 83 c4 28             add    $0x28,%rsp
    0.00 :	  112bfc:       89 d8                   mov    %ebx,%eax
    0.00 :	  112bfe:       5b                      pop    %rbx
    0.00 :	  112bff:       5d                      pop    %rbp
    0.00 :	  112c00:       41 5c                   pop    %r12
    0.00 :	  112c02:       41 5d                   pop    %r13
    0.00 :	  112c04:       41 5e                   pop    %r14
    0.00 :	  112c06:       41 5f                   pop    %r15
    0.00 :	  112c08:       c3                      retq   
    0.00 :	  112c09:       f6 83 14 03 00 00 03    testb  $0x3,0x314(%rbx)
    0.00 :	  112c10:       0f 85 79 fe ff ff       jne    112a8f <_dl_addr+0xcf>
    0.00 :	  112c16:       48 8b 05 b3 f3 25 00    mov    0x25f3b3(%rip),%rax        # 371fd0 <_DYNAMIC+0x470>
    0.00 :	  112c1d:       48 8b 00                mov    (%rax),%rax
    0.00 :	  112c20:       48 8b 00                mov    (%rax),%rax
    0.00 :	  112c23:       49 89 07                mov    %rax,(%r15)
    0.00 :	  112c26:       e9 64 fe ff ff          jmpq   112a8f <_dl_addr+0xcf>
    0.00 :	  112c2b:       48 8b 43 60             mov    0x60(%rbx),%rax
    0.00 :	  112c2f:       48 8b 74 24 20          mov    0x20(%rsp),%rsi
    0.00 :	  112c34:       48 85 c0                test   %rax,%rax
    0.00 :	  112c37:       74 0f                   je     112c48 <_dl_addr+0x288>
    0.00 :	  112c39:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	  112c3d:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  112c40:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  112c44:       49 8d 34 c4             lea    (%r12,%rax,8),%rsi
    0.00 :	  112c48:       31 d2                   xor    %edx,%edx
    0.00 :	  112c4a:       49 39 f4                cmp    %rsi,%r12
    0.00 :	  112c4d:       72 16                   jb     112c65 <_dl_addr+0x2a5>
    0.00 :	  112c4f:       e9 45 ff ff ff          jmpq   112b99 <_dl_addr+0x1d9>
    0.00 :	  112c54:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  112c58:       49 83 c4 18             add    $0x18,%r12
    0.00 :	  112c5c:       49 39 f4                cmp    %rsi,%r12
    0.00 :	  112c5f:       0f 83 3b ff ff ff       jae    112ba0 <_dl_addr+0x1e0>
    0.00 :	  112c65:       41 0f b6 4c 24 04       movzbl 0x4(%r12),%ecx
    0.00 :	  112c6b:       89 c8                   mov    %ecx,%eax
    0.00 :	  112c6d:       c0 e8 04                shr    $0x4,%al
    0.00 :	  112c70:       83 e8 01                sub    $0x1,%eax
    0.00 :	  112c73:       3c 01                   cmp    $0x1,%al
    0.00 :	  112c75:       77 e1                   ja     112c58 <_dl_addr+0x298>
    0.00 :	  112c77:       89 c8                   mov    %ecx,%eax
    0.00 :	  112c79:       83 e0 0f                and    $0xf,%eax
    0.00 :	  112c7c:       83 f8 06                cmp    $0x6,%eax
    0.00 :	  112c7f:       74 d7                   je     112c58 <_dl_addr+0x298>
    0.00 :	  112c81:       41 0f b7 44 24 06       movzwl 0x6(%r12),%eax
    0.00 :	  112c87:       66 85 c0                test   %ax,%ax
    0.00 :	  112c8a:       74 4c                   je     112cd8 <_dl_addr+0x318>
    0.00 :	  112c8c:       49 8b 7c 24 08          mov    0x8(%r12),%rdi
    0.00 :	  112c91:       48 89 f9                mov    %rdi,%rcx
    0.00 :	  112c94:       48 03 0b                add    (%rbx),%rcx
    0.00 :	  112c97:       48 39 cd                cmp    %rcx,%rbp
    0.00 :	  112c9a:       72 bc                   jb     112c58 <_dl_addr+0x298>
    0.00 :	  112c9c:       66 85 c0                test   %ax,%ax
    0.00 :	  112c9f:       74 2b                   je     112ccc <_dl_addr+0x30c>
    0.00 :	  112ca1:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  112ca6:       48 85 c0                test   %rax,%rax
    0.00 :	  112ca9:       74 21                   je     112ccc <_dl_addr+0x30c>
    0.00 :	  112cab:       48 01 c8                add    %rcx,%rax
    0.00 :	  112cae:       48 39 c5                cmp    %rax,%rbp
    0.00 :	  112cb1:       73 a5                   jae    112c58 <_dl_addr+0x298>
    0.00 :	  112cb3:       48 85 d2                test   %rdx,%rdx
    0.00 :	  112cb6:       74 06                   je     112cbe <_dl_addr+0x2fe>
    0.00 :	  112cb8:       48 39 7a 08             cmp    %rdi,0x8(%rdx)
    0.00 :	  112cbc:       73 9a                   jae    112c58 <_dl_addr+0x298>
    0.00 :	  112cbe:       8b 44 24 1c             mov    0x1c(%rsp),%eax
    0.00 :	  112cc2:       41 3b 04 24             cmp    (%r12),%eax
    0.00 :	  112cc6:       49 0f 47 d4             cmova  %r12,%rdx
    0.00 :	  112cca:       eb 8c                   jmp    112c58 <_dl_addr+0x298>
    0.00 :	  112ccc:       48 39 cd                cmp    %rcx,%rbp
    0.00 :	  112ccf:       74 e2                   je     112cb3 <_dl_addr+0x2f3>
    0.00 :	  112cd1:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	  112cd6:       eb d3                   jmp    112cab <_dl_addr+0x2eb>
    0.00 :	  112cd8:       49 8b 7c 24 08          mov    0x8(%r12),%rdi
    0.00 :	  112cdd:       48 85 ff                test   %rdi,%rdi
    0.00 :	  112ce0:       0f 84 72 ff ff ff       je     112c58 <_dl_addr+0x298>
    0.00 :	  112ce6:       eb a9                   jmp    112c91 <_dl_addr+0x2d1>
    0.00 :	  112ce8:       49 c7 47 10 00 00 00    movq   $0x0,0x10(%r15)
    0.00 :	  112cef:       00 
    0.00 :	  112cf0:       49 c7 47 18 00 00 00    movq   $0x0,0x18(%r15)
    0.00 :	  112cf7:       00 
    0.00 :	  112cf8:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  112cfd:       e9 e2 fe ff ff          jmpq   112be4 <_dl_addr+0x224>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib64/ld-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/ld-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000015f80 <__close>:
    0.00 :	   15f80:       b8 03 00 00 00          mov    $0x3,%eax
    0.00 :	   15f85:       0f 05                   syscall 
  100.00 :	   15f87:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   15f8d:       73 01                   jae    15f90 <__close+0x10>
    0.00 :	   15f8f:       c3                      retq   
    0.00 :	   15f90:       48 8d 0d ed a1 20 00    lea    0x20a1ed(%rip),%rcx        # 220184 <rtld_errno>
    0.00 :	   15f97:       31 d2                   xor    %edx,%edx
    0.00 :	   15f99:       48 29 c2                sub    %rax,%rdx
    0.00 :	   15f9c:       89 11                   mov    %edx,(%rcx)
    0.00 :	   15f9e:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   15fa2:       eb eb                   jmp    15f8f <__close+0xf>

Sorted summary for file /home/Computational/mark/andres/lib/libpq.so.5.8
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/lib/libpq.so.5.8
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000001dbf0 <pg_encoding_dsplen>:
         :	/*
         :	 * Returns the display length of a multibyte character.
         :	 */
         :	int
         :	pg_encoding_dsplen(int encoding, const char *mbstr)
         :	{
    0.00 :	   1dbf0:       55                      push   %rbp
         :	        return (PG_VALID_ENCODING(encoding) ?
    0.00 :	   1dbf1:       83 ff 29                cmp    $0x29,%edi
         :	/*
         :	 * Returns the display length of a multibyte character.
         :	 */
         :	int
         :	pg_encoding_dsplen(int encoding, const char *mbstr)
         :	{
    0.00 :	   1dbf4:       48 89 e5                mov    %rsp,%rbp
         :	        return (PG_VALID_ENCODING(encoding) ?
    0.00 :	   1dbf7:       76 17                   jbe    1dc10 <pg_encoding_dsplen+0x20>
    0.00 :	   1dbf9:       48 8b 05 d8 a3 20 00    mov    0x20a3d8(%rip),%rax        # 227fd8 <_DYNAMIC+0x1f8>
    0.00 :	   1dc00:       48 89 f7                mov    %rsi,%rdi
    0.00 :	   1dc03:       4c 8b 58 18             mov    0x18(%rax),%r11
         :	           ((*pg_wchar_table[encoding].dsplen) ((const unsigned char *) mbstr)) :
         :	        ((*pg_wchar_table[PG_SQL_ASCII].dsplen) ((const unsigned char *) mbstr)));
         :	}
    0.00 :	   1dc07:       c9                      leaveq 
         :	 * Returns the display length of a multibyte character.
         :	 */
         :	int
         :	pg_encoding_dsplen(int encoding, const char *mbstr)
         :	{
         :	        return (PG_VALID_ENCODING(encoding) ?
    0.00 :	   1dc08:       41 ff e3                jmpq   *%r11
    0.00 :	   1dc0b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	   1dc10:       48 63 c7                movslq %edi,%rax
    0.00 :	   1dc13:       48 89 f7                mov    %rsi,%rdi
    0.00 :	   1dc16:       48 8d 44 40 01          lea    0x1(%rax,%rax,2),%rax
    0.00 :	   1dc1b:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	   1dc1f:       48 03 05 b2 a3 20 00    add    0x20a3b2(%rip),%rax        # 227fd8 <_DYNAMIC+0x1f8>
    0.00 :	   1dc26:       4c 8b 58 08             mov    0x8(%rax),%r11
         :	           ((*pg_wchar_table[encoding].dsplen) ((const unsigned char *) mbstr)) :
         :	        ((*pg_wchar_table[PG_SQL_ASCII].dsplen) ((const unsigned char *) mbstr)));
         :	}
  100.00 :	   1dc2a:       c9                      leaveq 
         :	 * Returns the display length of a multibyte character.
         :	 */
         :	int
         :	pg_encoding_dsplen(int encoding, const char *mbstr)
         :	{
         :	        return (PG_VALID_ENCODING(encoding) ?
    0.00 :	   1dc2b:       41 ff e3                jmpq   *%r11

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1296
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000046f260 <slot_getsomeattrs>:
         :	 *              This function forces the entries of the slot's Datum/isnull
         :	 *              arrays to be valid at least up through the attnum'th entry.
         :	 */
         :	void
         :	slot_getsomeattrs(TupleTableSlot *slot, int attnum)
         :	{
    0.00 :	  46f260:       55                      push   %rbp
    0.00 :	  46f261:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  46f264:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/common/heaptuple.c:1296
  100.00 :	  46f268:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  46f26c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  46f26f:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  46f273:       48 83 ec 20             sub    $0x20,%rsp
         :	        HeapTuple       tuple;
         :	        int                     attno;
         :
         :	        /* Quick out if we have 'em all already */
         :	        if (slot->tts_nvalid >= attnum)
    0.00 :	  46f277:       39 77 24                cmp    %esi,0x24(%rdi)
         :	 *              This function forces the entries of the slot's Datum/isnull
         :	 *              arrays to be valid at least up through the attnum'th entry.
         :	 */
         :	void
         :	slot_getsomeattrs(TupleTableSlot *slot, int attnum)
         :	{
    0.00 :	  46f27a:       41 89 f5                mov    %esi,%r13d
         :	        HeapTuple       tuple;
         :	        int                     attno;
         :
         :	        /* Quick out if we have 'em all already */
         :	        if (slot->tts_nvalid >= attnum)
    0.00 :	  46f27d:       7d 67                   jge    46f2e6 <slot_getsomeattrs+0x86>
         :	                return;
         :
         :	        /* Check for caller error */
         :	        if (attnum <= 0 || attnum > slot->tts_tupleDescriptor->natts)
    0.00 :	  46f27f:       85 f6                   test   %esi,%esi
    0.00 :	  46f281:       7e 75                   jle    46f2f8 <slot_getsomeattrs+0x98>
    0.00 :	  46f283:       48 8b 47 10             mov    0x10(%rdi),%rax
    0.00 :	  46f287:       3b 30                   cmp    (%rax),%esi
    0.00 :	  46f289:       7f 6d                   jg     46f2f8 <slot_getsomeattrs+0x98>
         :
         :	        /*
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        tuple = slot->tts_tuple;
    0.00 :	  46f28b:       48 8b 47 08             mov    0x8(%rdi),%rax
         :	        if (tuple == NULL)                      /* internal error */
    0.00 :	  46f28f:       48 85 c0                test   %rax,%rax
    0.00 :	  46f292:       0f 84 8d 00 00 00       je     46f325 <slot_getsomeattrs+0xc5>
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
         :
         :	        /*
         :	         * load up any slots available from physical tuple
         :	         */
         :	        attno = HeapTupleHeaderGetNatts(tuple->t_data);
    0.00 :	  46f298:       48 8b 40 10             mov    0x10(%rax),%rax
    0.00 :	  46f29c:       0f b7 40 12             movzwl 0x12(%rax),%eax
    0.00 :	  46f2a0:       25 ff 07 00 00          and    $0x7ff,%eax
         :	        attno = Min(attno, attnum);
    0.00 :	  46f2a5:       39 c6                   cmp    %eax,%esi
    0.00 :	  46f2a7:       89 c3                   mov    %eax,%ebx
    0.00 :	  46f2a9:       0f 4e de                cmovle %esi,%ebx
         :
         :	        slot_deform_tuple(slot, attno);
    0.00 :	  46f2ac:       89 de                   mov    %ebx,%esi
    0.00 :	  46f2ae:       e8 5d fc ff ff          callq  46ef10 <slot_deform_tuple>
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2b3:       41 39 dd                cmp    %ebx,%r13d
    0.00 :	  46f2b6:       7e 29                   jle    46f2e1 <slot_getsomeattrs+0x81>
    0.00 :	  46f2b8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	  46f2bf:       00 
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
    0.00 :	  46f2c0:       49 8b 54 24 28          mov    0x28(%r12),%rdx
    0.00 :	  46f2c5:       48 63 c3                movslq %ebx,%rax
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2c8:       83 c3 01                add    $0x1,%ebx
    0.00 :	  46f2cb:       41 39 dd                cmp    %ebx,%r13d
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
    0.00 :	  46f2ce:       48 c7 04 c2 00 00 00    movq   $0x0,(%rdx,%rax,8)
    0.00 :	  46f2d5:       00 
         :	                slot->tts_isnull[attno] = true;
    0.00 :	  46f2d6:       49 8b 54 24 30          mov    0x30(%r12),%rdx
    0.00 :	  46f2db:       c6 04 02 01             movb   $0x1,(%rdx,%rax,1)
         :
         :	        /*
         :	         * If tuple doesn't have all the atts indicated by tupleDesc, read the
         :	         * rest as null
         :	         */
         :	        for (; attno < attnum; attno++)
    0.00 :	  46f2df:       7f df                   jg     46f2c0 <slot_getsomeattrs+0x60>
         :	        {
         :	                slot->tts_values[attno] = (Datum) 0;
         :	                slot->tts_isnull[attno] = true;
         :	        }
         :	        slot->tts_nvalid = attnum;
    0.00 :	  46f2e1:       45 89 6c 24 24          mov    %r13d,0x24(%r12)
         :	}
    0.00 :	  46f2e6:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  46f2ea:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  46f2ee:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  46f2f2:       c9                      leaveq 
    0.00 :	  46f2f3:       c3                      retq   
    0.00 :	  46f2f4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        if (slot->tts_nvalid >= attnum)
         :	                return;
         :
         :	        /* Check for caller error */
         :	        if (attnum <= 0 || attnum > slot->tts_tupleDescriptor->natts)
         :	                elog(ERROR, "invalid attribute number %d", attnum);
    0.00 :	  46f2f8:       ba c0 f6 7a 00          mov    $0x7af6c0,%edx
    0.00 :	  46f2fd:       be 1a 05 00 00          mov    $0x51a,%esi
    0.00 :	  46f302:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f307:       e8 14 c1 30 00          callq  77b420 <elog_start>
    0.00 :	  46f30c:       44 89 ea                mov    %r13d,%edx
    0.00 :	  46f30f:       be 13 f6 7a 00          mov    $0x7af613,%esi
    0.00 :	  46f314:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f319:       31 c0                   xor    %eax,%eax
    0.00 :	  46f31b:       e8 10 bf 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f320:       e8 ab a1 ff ff          callq  4694d0 <abort@plt>
         :	         * otherwise we had better have a physical tuple (tts_nvalid should equal
         :	         * natts in all virtual-tuple cases)
         :	         */
         :	        tuple = slot->tts_tuple;
         :	        if (tuple == NULL)                      /* internal error */
         :	                elog(ERROR, "cannot extract attribute from empty tuple slot");
    0.00 :	  46f325:       ba c0 f6 7a 00          mov    $0x7af6c0,%edx
    0.00 :	  46f32a:       be 22 05 00 00          mov    $0x522,%esi
    0.00 :	  46f32f:       bf f4 f5 7a 00          mov    $0x7af5f4,%edi
    0.00 :	  46f334:       e8 e7 c0 30 00          callq  77b420 <elog_start>
    0.00 :	  46f339:       be b0 f7 7a 00          mov    $0x7af7b0,%esi
    0.00 :	  46f33e:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  46f343:       31 c0                   xor    %eax,%eax
    0.00 :	  46f345:       e8 e6 be 30 00          callq  77b230 <elog_finish>
    0.00 :	  46f34a:       e8 81 a1 ff ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:47
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004906f0 <hashint4>:
         :	        return hash_uint32((int32) PG_GETARG_INT16(0));
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:47
  100.00 :	  4906f0:       55                      push   %rbp
         :	        return hash_uint32(PG_GETARG_INT32(0));
    0.00 :	  4906f1:       48 8b 7f 20             mov    0x20(%rdi),%rdi
         :	        return hash_uint32((int32) PG_GETARG_INT16(0));
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  4906f5:       48 89 e5                mov    %rsp,%rbp
         :	        return hash_uint32(PG_GETARG_INT32(0));
         :	}
    0.00 :	  4906f8:       c9                      leaveq 
         :	}
         :
         :	Datum
         :	hashint4(PG_FUNCTION_ARGS)
         :	{
         :	        return hash_uint32(PG_GETARG_INT32(0));
    0.00 :	  4906f9:       e9 62 ff ff ff          jmpq   490660 <hash_uint32>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:119
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000490890 <hashfloat8>:
         :	        return hash_any((unsigned char *) &key8, sizeof(key8));
         :	}
         :
         :	Datum
         :	hashfloat8(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  490890:       55                      push   %rbp
    0.00 :	  490891:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  490894:       48 83 ec 10             sub    $0x10,%rsp
         :	        float8          key = PG_GETARG_FLOAT8(0);
    0.00 :	  490898:       48 8b 7f 20             mov    0x20(%rdi),%rdi
    0.00 :	  49089c:       e8 2f d1 2e 00          callq  77d9d0 <DatumGetFloat8>
         :	        /*
         :	         * On IEEE-float machines, minus zero and zero have different bit patterns
         :	         * but should compare as equal.  We must ensure that they have the same
         :	         * hash value, which is most reliably done this way:
         :	         */
         :	        if (key == (float8) 0)
    0.00 :	  4908a1:       31 c0                   xor    %eax,%eax
    0.00 :	  4908a3:       66 0f 2e 05 2d 1a 32    ucomisd 0x321a2d(%rip),%xmm0        # 7b22d8 <__func__.14992+0xcf>
    0.00 :	  4908aa:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/access/hash/hashfunc.c:119
  100.00 :	  4908ab:       7a 0b                   jp     4908b8 <hashfloat8+0x28>
    0.00 :	  4908ad:       75 09                   jne    4908b8 <hashfloat8+0x28>
         :	                PG_RETURN_UINT32(0);
         :
         :	        return hash_any((unsigned char *) &key, sizeof(key));
         :	}
    0.00 :	  4908af:       c9                      leaveq 
    0.00 :	  4908b0:       c3                      retq   
    0.00 :	  4908b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	}
         :
         :	Datum
         :	hashfloat8(PG_FUNCTION_ARGS)
         :	{
         :	        float8          key = PG_GETARG_FLOAT8(0);
    0.00 :	  4908b8:       f2 0f 11 45 f8          movsd  %xmm0,-0x8(%rbp)
         :	         * hash value, which is most reliably done this way:
         :	         */
         :	        if (key == (float8) 0)
         :	                PG_RETURN_UINT32(0);
         :
         :	        return hash_any((unsigned char *) &key, sizeof(key));
    0.00 :	  4908bd:       48 8d 7d f8             lea    -0x8(%rbp),%rdi
    0.00 :	  4908c1:       be 08 00 00 00          mov    $0x8,%esi
    0.00 :	  4908c6:       e8 85 fa ff ff          callq  490350 <hash_any>
         :	}
    0.00 :	  4908cb:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:824
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a50c0 <index_getprocinfo>:
         :	 */
         :	FmgrInfo *
         :	index_getprocinfo(Relation irel,
         :	                                  AttrNumber attnum,
         :	                                  uint16 procnum)
         :	{
    0.00 :	  4a50c0:       55                      push   %rbp
    0.00 :	  4a50c1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a50c4:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  4a50c8:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
    0.00 :	  4a50cc:       49 89 fc                mov    %rdi,%r12
    0.00 :	  4a50cf:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  4a50d3:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
         :
         :	        nproc = irel->rd_am->amsupport;
         :
         :	        Assert(procnum > 0 && procnum <= (uint16) nproc);
         :
         :	        procindex = (nproc * (attnum - 1)) + (procnum - 1);
    0.00 :	  4a50d7:       44 0f b7 ea             movzwl %dx,%r13d
         :	 */
         :	FmgrInfo *
         :	index_getprocinfo(Relation irel,
         :	                                  AttrNumber attnum,
         :	                                  uint16 procnum)
         :	{
    0.00 :	  4a50db:       48 83 ec 20             sub    $0x20,%rsp
         :
         :	        locinfo = irel->rd_supportinfo;
         :
         :	        Assert(locinfo != NULL);
         :
         :	        locinfo += procindex;
    0.00 :	  4a50df:       48 8b 97 b0 00 00 00    mov    0xb0(%rdi),%rdx
         :
         :	        nproc = irel->rd_am->amsupport;
         :
         :	        Assert(procnum > 0 && procnum <= (uint16) nproc);
         :
         :	        procindex = (nproc * (attnum - 1)) + (procnum - 1);
    0.00 :	  4a50e6:       44 0f bf f6             movswl %si,%r14d
         :
         :	        locinfo = irel->rd_supportinfo;
         :
         :	        Assert(locinfo != NULL);
         :
         :	        locinfo += procindex;
    0.00 :	  4a50ea:       41 8d 46 ff             lea    -0x1(%r14),%eax
    0.00 :	  4a50ee:       0f bf 52 42             movswl 0x42(%rdx),%edx
 /home/Computational/mark/src/postgres-andres/src/backend/access/index/indexam.c:824
  100.00 :	  4a50f2:       0f af c2                imul   %edx,%eax
    0.00 :	  4a50f5:       41 8d 44 05 ff          lea    -0x1(%r13,%rax,1),%eax
    0.00 :	  4a50fa:       48 63 d0                movslq %eax,%rdx
    0.00 :	  4a50fd:       48 8d 1c 52             lea    (%rdx,%rdx,2),%rbx
    0.00 :	  4a5101:       48 c1 e3 04             shl    $0x4,%rbx
    0.00 :	  4a5105:       48 03 9f e0 00 00 00    add    0xe0(%rdi),%rbx
         :
         :	        /* Initialize the lookup info if first time through */
         :	        if (locinfo->fn_oid == InvalidOid)
    0.00 :	  4a510c:       8b 43 08                mov    0x8(%rbx),%eax
    0.00 :	  4a510f:       85 c0                   test   %eax,%eax
    0.00 :	  4a5111:       75 1e                   jne    4a5131 <index_getprocinfo+0x71>
         :	                RegProcedure *loc = irel->rd_support;
         :	                RegProcedure procId;
         :
         :	                Assert(loc != NULL);
         :
         :	                procId = loc[procindex];
    0.00 :	  4a5113:       48 8b 87 d8 00 00 00    mov    0xd8(%rdi),%rax
    0.00 :	  4a511a:       8b 3c 90                mov    (%rax,%rdx,4),%edi
         :	                 * Complain if function was not found during IndexSupportInitialize.
         :	                 * This should not happen unless the system tables contain bogus
         :	                 * entries for the index opclass.  (If an AM wants to allow a support
         :	                 * function to be optional, it can use index_getprocid.)
         :	                 */
         :	                if (!RegProcedureIsValid(procId))
    0.00 :	  4a511d:       85 ff                   test   %edi,%edi
    0.00 :	  4a511f:       74 28                   je     4a5149 <index_getprocinfo+0x89>
         :	                        elog(ERROR, "missing support function %d for attribute %d of index \"%s\"",
         :	                                 procnum, attnum, RelationGetRelationName(irel));
         :
         :	                fmgr_info_cxt(procId, locinfo, irel->rd_indexcxt);
    0.00 :	  4a5121:       49 8b 94 24 b8 00 00    mov    0xb8(%r12),%rdx
    0.00 :	  4a5128:       00 
    0.00 :	  4a5129:       48 89 de                mov    %rbx,%rsi
    0.00 :	  4a512c:       e8 1f af 2d 00          callq  780050 <fmgr_info_cxt>
         :	        }
         :
         :	        return locinfo;
         :	}
    0.00 :	  4a5131:       48 89 d8                mov    %rbx,%rax
    0.00 :	  4a5134:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  4a5139:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  4a513d:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  4a5142:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  4a5147:       c9                      leaveq 
    0.00 :	  4a5148:       c3                      retq   
         :	                 * This should not happen unless the system tables contain bogus
         :	                 * entries for the index opclass.  (If an AM wants to allow a support
         :	                 * function to be optional, it can use index_getprocid.)
         :	                 */
         :	                if (!RegProcedureIsValid(procId))
         :	                        elog(ERROR, "missing support function %d for attribute %d of index \"%s\"",
    0.00 :	  4a5149:       ba e0 3b 7b 00          mov    $0x7b3be0,%edx
    0.00 :	  4a514e:       be 4c 03 00 00          mov    $0x34c,%esi
    0.00 :	  4a5153:       bf 33 3b 7b 00          mov    $0x7b3b33,%edi
    0.00 :	  4a5158:       e8 c3 62 2d 00          callq  77b420 <elog_start>
    0.00 :	  4a515d:       4d 8b 44 24 30          mov    0x30(%r12),%r8
    0.00 :	  4a5162:       44 89 f1                mov    %r14d,%ecx
    0.00 :	  4a5165:       44 89 ea                mov    %r13d,%edx
    0.00 :	  4a5168:       be c8 19 7b 00          mov    $0x7b19c8,%esi
    0.00 :	  4a516d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4a5172:       31 c0                   xor    %eax,%eax
    0.00 :	  4a5174:       e8 b7 60 2d 00          callq  77b230 <elog_finish>
    0.00 :	  4a5179:       e8 52 43 fc ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:727
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a8fd0 <_bt_relbuf>:
         :	 *
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:727
  100.00 :	  4a8fd0:       55                      push   %rbp
    0.00 :	  4a8fd1:       89 f7                   mov    %esi,%edi
    0.00 :	  4a8fd3:       48 89 e5                mov    %rsp,%rbp
         :	        UnlockReleaseBuffer(buf);
         :	}
    0.00 :	  4a8fd6:       c9                      leaveq 
         :	 * Lock and pin (refcount) are both dropped.
         :	 */
         :	void
         :	_bt_relbuf(Relation rel, Buffer buf)
         :	{
         :	        UnlockReleaseBuffer(buf);
    0.00 :	  4a8fd7:       e9 54 bf 1c 00          jmpq   674f30 <UnlockReleaseBuffer>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:708
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004a8fe0 <_bt_relandgetbuf>:
         :	 * convenience.  The only case where it saves work over _bt_relbuf/_bt_getbuf
         :	 * is when the target page is the same one already in the buffer.
         :	 */
         :	Buffer
         :	_bt_relandgetbuf(Relation rel, Buffer obuf, BlockNumber blkno, int access)
         :	{
    0.00 :	  4a8fe0:       55                      push   %rbp
    0.00 :	  4a8fe1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4a8fe4:       48 89 5d e0             mov    %rbx,-0x20(%rbp)
    0.00 :	  4a8fe8:       4c 89 65 e8             mov    %r12,-0x18(%rbp)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtpage.c:708
  100.00 :	  4a8fec:       89 f3                   mov    %esi,%ebx
    0.00 :	  4a8fee:       4c 89 6d f0             mov    %r13,-0x10(%rbp)
    0.00 :	  4a8ff2:       4c 89 75 f8             mov    %r14,-0x8(%rbp)
    0.00 :	  4a8ff6:       48 83 ec 20             sub    $0x20,%rsp
         :	        Buffer          buf;
         :
         :	        Assert(blkno != P_NEW);
         :	        if (BufferIsValid(obuf))
    0.00 :	  4a8ffa:       85 f6                   test   %esi,%esi
         :	 * convenience.  The only case where it saves work over _bt_relbuf/_bt_getbuf
         :	 * is when the target page is the same one already in the buffer.
         :	 */
         :	Buffer
         :	_bt_relandgetbuf(Relation rel, Buffer obuf, BlockNumber blkno, int access)
         :	{
    0.00 :	  4a8ffc:       49 89 fe                mov    %rdi,%r14
    0.00 :	  4a8fff:       41 89 d4                mov    %edx,%r12d
    0.00 :	  4a9002:       41 89 cd                mov    %ecx,%r13d
         :	        Buffer          buf;
         :
         :	        Assert(blkno != P_NEW);
         :	        if (BufferIsValid(obuf))
    0.00 :	  4a9005:       74 09                   je     4a9010 <_bt_relandgetbuf+0x30>
         :	                LockBuffer(obuf, BUFFER_LOCK_UNLOCK);
    0.00 :	  4a9007:       31 f6                   xor    %esi,%esi
    0.00 :	  4a9009:       89 df                   mov    %ebx,%edi
    0.00 :	  4a900b:       e8 00 b7 1c 00          callq  674710 <LockBuffer>
         :	        buf = ReleaseAndReadBuffer(obuf, rel, blkno);
    0.00 :	  4a9010:       44 89 e2                mov    %r12d,%edx
    0.00 :	  4a9013:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  4a9016:       89 df                   mov    %ebx,%edi
    0.00 :	  4a9018:       e8 a3 d6 1c 00          callq  6766c0 <ReleaseAndReadBuffer>
         :	        LockBuffer(buf, access);
    0.00 :	  4a901d:       44 89 ee                mov    %r13d,%esi
         :	        Buffer          buf;
         :
         :	        Assert(blkno != P_NEW);
         :	        if (BufferIsValid(obuf))
         :	                LockBuffer(obuf, BUFFER_LOCK_UNLOCK);
         :	        buf = ReleaseAndReadBuffer(obuf, rel, blkno);
    0.00 :	  4a9020:       89 c3                   mov    %eax,%ebx
         :	        LockBuffer(buf, access);
    0.00 :	  4a9022:       89 c7                   mov    %eax,%edi
    0.00 :	  4a9024:       e8 e7 b6 1c 00          callq  674710 <LockBuffer>
         :	        _bt_checkpage(rel, buf);
    0.00 :	  4a9029:       89 de                   mov    %ebx,%esi
    0.00 :	  4a902b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  4a902e:       e8 9d fa ff ff          callq  4a8ad0 <_bt_checkpage>
         :	        return buf;
         :	}
    0.00 :	  4a9033:       89 d8                   mov    %ebx,%eax
    0.00 :	  4a9035:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  4a903a:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  4a903e:       4c 8b 6c 24 10          mov    0x10(%rsp),%r13
    0.00 :	  4a9043:       4c 8b 74 24 18          mov    0x18(%rsp),%r14
    0.00 :	  4a9048:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1306
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ae1b0 <_bt_mark_scankey_required>:
         :	 * from scan to scan within a query, and so we'd just re-mark the same way
         :	 * anyway on a rescan.  Something to keep an eye on though.
         :	 */
         :	static void
         :	_bt_mark_scankey_required(ScanKey skey)
         :	{
    0.00 :	  4ae1b0:       55                      push   %rbp
    0.00 :	  4ae1b1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  4ae1b4:       53                      push   %rbx
    0.00 :	  4ae1b5:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  4ae1b8:       48 83 ec 08             sub    $0x8,%rsp
         :	        int                     addflags;
         :
         :	        switch (skey->sk_strategy)
    0.00 :	  4ae1bc:       66 83 7f 06 05          cmpw   $0x5,0x6(%rdi)
    0.00 :	  4ae1c1:       76 35                   jbe    4ae1f8 <_bt_mark_scankey_required+0x48>
         :	                case BTGreaterEqualStrategyNumber:
         :	                case BTGreaterStrategyNumber:
         :	                        addflags = SK_BT_REQBKWD;
         :	                        break;
         :	                default:
         :	                        elog(ERROR, "unrecognized StrategyNumber: %d",
    0.00 :	  4ae1c3:       ba 80 4b 7b 00          mov    $0x7b4b80,%edx
    0.00 :	  4ae1c8:       be 29 05 00 00          mov    $0x529,%esi
    0.00 :	  4ae1cd:       bf 17 49 7b 00          mov    $0x7b4917,%edi
    0.00 :	  4ae1d2:       e8 49 d2 2c 00          callq  77b420 <elog_start>
    0.00 :	  4ae1d7:       0f b7 53 06             movzwl 0x6(%rbx),%edx
    0.00 :	  4ae1db:       be 78 49 7b 00          mov    $0x7b4978,%esi
    0.00 :	  4ae1e0:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  4ae1e5:       31 c0                   xor    %eax,%eax
    0.00 :	  4ae1e7:       e8 44 d0 2c 00          callq  77b230 <elog_finish>
    0.00 :	  4ae1ec:       e8 df b2 fb ff          callq  4694d0 <abort@plt>
    0.00 :	  4ae1f1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	static void
         :	_bt_mark_scankey_required(ScanKey skey)
         :	{
         :	        int                     addflags;
         :
         :	        switch (skey->sk_strategy)
    0.00 :	  4ae1f8:       0f b7 47 06             movzwl 0x6(%rdi),%eax
    0.00 :	  4ae1fc:       ff 24 c5 70 4a 7b 00    jmpq   *0x7b4a70(,%rax,8)
    0.00 :	  4ae203:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  4ae208:       be 00 00 02 00          mov    $0x20000,%esi
         :	                                 (int) skey->sk_strategy);
         :	                        addflags = 0;           /* keep compiler quiet */
         :	                        break;
         :	        }
         :
         :	        skey->sk_flags |= addflags;
    0.00 :	  4ae20d:       89 f0                   mov    %esi,%eax
    0.00 :	  4ae20f:       0b 03                   or     (%rbx),%eax
         :
         :	        if (skey->sk_flags & SK_ROW_HEADER)
    0.00 :	  4ae211:       a8 04                   test   $0x4,%al
         :	                                 (int) skey->sk_strategy);
         :	                        addflags = 0;           /* keep compiler quiet */
         :	                        break;
         :	        }
         :
         :	        skey->sk_flags |= addflags;
    0.00 :	  4ae213:       89 03                   mov    %eax,(%rbx)
         :
         :	        if (skey->sk_flags & SK_ROW_HEADER)
    0.00 :	  4ae215:       74 41                   je     4ae258 <_bt_mark_scankey_required+0xa8>
         :	        {
         :	                ScanKey         subkey = (ScanKey) DatumGetPointer(skey->sk_argument);
    0.00 :	  4ae217:       48 8b 53 40             mov    0x40(%rbx),%rdx
         :	                AttrNumber      attno = skey->sk_attno;
    0.00 :	  4ae21b:       0f b7 4b 04             movzwl 0x4(%rbx),%ecx
         :	                Assert(subkey->sk_attno == attno);
         :
         :	                for (;;)
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        if (subkey->sk_attno != attno)
    0.00 :	  4ae21f:       66 3b 4a 04             cmp    0x4(%rdx),%cx
    0.00 :	  4ae223:       74 25                   je     4ae24a <_bt_mark_scankey_required+0x9a>
    0.00 :	  4ae225:       eb 31                   jmp    4ae258 <_bt_mark_scankey_required+0xa8>
    0.00 :	  4ae227:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae22e:       00 00 
         :	                                break;                  /* non-adjacent key, so not required */
         :	                        if (subkey->sk_strategy != skey->sk_strategy)
         :	                                break;                  /* wrong direction, so not required */
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4ae230:       89 f0                   mov    %esi,%eax
    0.00 :	  4ae232:       0b 02                   or     (%rdx),%eax
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ae234:       a8 10                   test   $0x10,%al
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        if (subkey->sk_attno != attno)
         :	                                break;                  /* non-adjacent key, so not required */
         :	                        if (subkey->sk_strategy != skey->sk_strategy)
         :	                                break;                  /* wrong direction, so not required */
         :	                        subkey->sk_flags |= addflags;
    0.00 :	  4ae236:       89 02                   mov    %eax,(%rdx)
         :	                        if (subkey->sk_flags & SK_ROW_END)
    0.00 :	  4ae238:       75 1e                   jne    4ae258 <_bt_mark_scankey_required+0xa8>
         :	                                break;
         :	                        subkey++;
    0.00 :	  4ae23a:       48 83 c2 48             add    $0x48,%rdx
         :	                        attno++;
    0.00 :	  4ae23e:       8d 41 01                lea    0x1(%rcx),%eax
         :	                Assert(subkey->sk_attno == attno);
         :
         :	                for (;;)
         :	                {
         :	                        Assert(subkey->sk_flags & SK_ROW_MEMBER);
         :	                        if (subkey->sk_attno != attno)
    0.00 :	  4ae241:       0f b7 4a 04             movzwl 0x4(%rdx),%ecx
    0.00 :	  4ae245:       66 39 c1                cmp    %ax,%cx
    0.00 :	  4ae248:       75 0e                   jne    4ae258 <_bt_mark_scankey_required+0xa8>
         :	                                break;                  /* non-adjacent key, so not required */
         :	                        if (subkey->sk_strategy != skey->sk_strategy)
    0.00 :	  4ae24a:       0f b7 42 06             movzwl 0x6(%rdx),%eax
    0.00 :	  4ae24e:       66 3b 43 06             cmp    0x6(%rbx),%ax
    0.00 :	  4ae252:       74 dc                   je     4ae230 <_bt_mark_scankey_required+0x80>
    0.00 :	  4ae254:       0f 1f 40 00             nopl   0x0(%rax)
         :	                                break;
         :	                        subkey++;
         :	                        attno++;
         :	                }
         :	        }
         :	}
    0.00 :	  4ae258:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  4ae25c:       5b                      pop    %rbx
    0.00 :	  4ae25d:       c9                      leaveq 
    0.00 :	  4ae25e:       c3                      retq   
    0.00 :	  4ae25f:       90                      nop
         :	static void
         :	_bt_mark_scankey_required(ScanKey skey)
         :	{
         :	        int                     addflags;
         :
         :	        switch (skey->sk_strategy)
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:1306
  100.00 :	  4ae260:       be 00 00 03 00          mov    $0x30000,%esi
    0.00 :	  4ae265:       eb a6                   jmp    4ae20d <_bt_mark_scankey_required+0x5d>
    0.00 :	  4ae267:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  4ae26e:       00 00 
         :	                case BTGreaterEqualStrategyNumber:
         :	                case BTGreaterStrategyNumber:
         :	                        addflags = SK_BT_REQBKWD;
         :	                        break;
         :	                default:
         :	                        elog(ERROR, "unrecognized StrategyNumber: %d",
    0.00 :	  4ae270:       be 00 00 01 00          mov    $0x10000,%esi
    0.00 :	  4ae275:       eb 96                   jmp    4ae20d <_bt_mark_scankey_required+0x5d>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:165
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004af870 <_bt_freestack>:
         :	/*
         :	 * free a retracement stack made by _bt_search.
         :	 */
         :	void
         :	_bt_freestack(BTStack stack)
         :	{
    0.00 :	  4af870:       55                      push   %rbp
    0.00 :	  4af871:       48 89 e5                mov    %rsp,%rbp
 /home/Computational/mark/src/postgres-andres/src/backend/access/nbtree/nbtutils.c:165
  100.00 :	  4af874:       53                      push   %rbx
    0.00 :	  4af875:       48 83 ec 08             sub    $0x8,%rsp
         :	        BTStack         ostack;
         :
         :	        while (stack != NULL)
    0.00 :	  4af879:       48 85 ff                test   %rdi,%rdi
    0.00 :	  4af87c:       75 05                   jne    4af883 <_bt_freestack+0x13>
    0.00 :	  4af87e:       eb 12                   jmp    4af892 <_bt_freestack+0x22>
    0.00 :	  4af880:       48 89 df                mov    %rbx,%rdi
         :	        {
         :	                ostack = stack;
         :	                stack = stack->bts_parent;
    0.00 :	  4af883:       48 8b 5f 10             mov    0x10(%rdi),%rbx
         :	                pfree(ostack);
    0.00 :	  4af887:       e8 f4 92 2e 00          callq  798b80 <pfree>
         :	void
         :	_bt_freestack(BTStack stack)
         :	{
         :	        BTStack         ostack;
         :
         :	        while (stack != NULL)
    0.00 :	  4af88c:       48 85 db                test   %rbx,%rbx
    0.00 :	  4af88f:       90                      nop
    0.00 :	  4af890:       75 ee                   jne    4af880 <_bt_freestack+0x10>
         :	        {
         :	                ostack = stack;
         :	                stack = stack->bts_parent;
         :	                pfree(ostack);
         :	        }
         :	}
    0.00 :	  4af892:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  4af896:       5b                      pop    %rbx
    0.00 :	  4af897:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/catalog/namespace.c:2988
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000004ec980 <isTempToastNamespace>:
         :	 *              namespace?
         :	 */
         :	bool
         :	isTempToastNamespace(Oid namespaceId)
         :	{
         :	        if (OidIsValid(myTempToastNamespace) && myTempToastNamespace == namespaceId)
    0.00 :	  4ec980:       8b 15 4a cd 68 00       mov    0x68cd4a(%rip),%edx        # b796d0 <myTempToastNamespace>
         :	 * isTempToastNamespace - is the given namespace my temporary-toast-table
         :	 *              namespace?
         :	 */
         :	bool
         :	isTempToastNamespace(Oid namespaceId)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/catalog/namespace.c:2988
  100.00 :	  4ec986:       55                      push   %rbp
         :	        if (OidIsValid(myTempToastNamespace) && myTempToastNamespace == namespaceId)
    0.00 :	  4ec987:       31 c0                   xor    %eax,%eax
         :	 * isTempToastNamespace - is the given namespace my temporary-toast-table
         :	 *              namespace?
         :	 */
         :	bool
         :	isTempToastNamespace(Oid namespaceId)
         :	{
    0.00 :	  4ec989:       48 89 e5                mov    %rsp,%rbp
         :	        if (OidIsValid(myTempToastNamespace) && myTempToastNamespace == namespaceId)
    0.00 :	  4ec98c:       85 d2                   test   %edx,%edx
    0.00 :	  4ec98e:       74 05                   je     4ec995 <isTempToastNamespace+0x15>
    0.00 :	  4ec990:       39 fa                   cmp    %edi,%edx
    0.00 :	  4ec992:       0f 94 c0                sete   %al
         :	                return true;
         :	        return false;
         :	}
    0.00 :	  4ec995:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:369
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005a8e70 <LookupTupleHashEntry>:
         :	 * zeroed.
         :	 */
         :	TupleHashEntry
         :	LookupTupleHashEntry(TupleHashTable hashtable, TupleTableSlot *slot,
         :	                                         bool *isnew)
         :	{
    0.00 :	  5a8e70:       55                      push   %rbp
    0.00 :	  5a8e71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5a8e74:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  5a8e78:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  5a8e7c:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5a8e7f:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  5a8e83:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  5a8e87:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5a8e8a:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  5a8e8e:       48 83 ec 50             sub    $0x50,%rsp
         :	        TupleHashTable saveCurHT;
         :	        TupleHashEntryData dummy;
         :	        bool            found;
         :
         :	        /* If first time through, clone the input slot to make table slot */
         :	        if (hashtable->tableslot == NULL)
    0.00 :	  5a8e92:       48 83 7f 40 00          cmpq   $0x0,0x40(%rdi)
         :	 * zeroed.
         :	 */
         :	TupleHashEntry
         :	LookupTupleHashEntry(TupleHashTable hashtable, TupleTableSlot *slot,
         :	                                         bool *isnew)
         :	{
    0.00 :	  5a8e97:       49 89 d5                mov    %rdx,%r13
         :	        TupleHashTable saveCurHT;
         :	        TupleHashEntryData dummy;
         :	        bool            found;
         :
         :	        /* If first time through, clone the input slot to make table slot */
         :	        if (hashtable->tableslot == NULL)
    0.00 :	  5a8e9a:       0f 84 08 01 00 00       je     5a8fa8 <LookupTupleHashEntry+0x138>
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5a8ea0:       48 8b 05 b9 19 61 00    mov    0x6119b9(%rip),%rax        # bba860 <CurrentMemoryContext>
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8ea7:       31 d2                   xor    %edx,%edx
    0.00 :	  5a8ea9:       48 8d 4d cf             lea    -0x31(%rbp),%rcx
    0.00 :	  5a8ead:       4d 85 ed                test   %r13,%r13
    0.00 :	  5a8eb0:       48 8d 75 c0             lea    -0x40(%rbp),%rsi
         :
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
    0.00 :	  5a8eb4:       48 c7 45 c0 00 00 00    movq   $0x0,-0x40(%rbp)
    0.00 :	  5a8ebb:       00 
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8ebc:       0f 95 c2                setne  %dl
    0.00 :	  5a8ebf:       48 89 45 b8             mov    %rax,-0x48(%rbp)
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a8ec3:       49 8b 44 24 30          mov    0x30(%r12),%rax
    0.00 :	  5a8ec8:       48 89 05 91 19 61 00    mov    %rax,0x611991(%rip)        # bba860 <CurrentMemoryContext>
         :	         *
         :	         * We save and restore CurTupleHashTable just in case someone manages to
         :	         * invoke this code re-entrantly.
         :	         */
         :	        hashtable->inputslot = slot;
         :	        hashtable->in_hash_funcs = hashtable->tab_hash_funcs;
    0.00 :	  5a8ecf:       49 8b 44 24 18          mov    0x18(%r12),%rax
         :	         * Set up data needed by hash and match functions
         :	         *
         :	         * We save and restore CurTupleHashTable just in case someone manages to
         :	         * invoke this code re-entrantly.
         :	         */
         :	        hashtable->inputslot = slot;
    0.00 :	  5a8ed4:       4d 89 74 24 48          mov    %r14,0x48(%r12)
         :	        hashtable->in_hash_funcs = hashtable->tab_hash_funcs;
    0.00 :	  5a8ed9:       49 89 44 24 50          mov    %rax,0x50(%r12)
         :	        hashtable->cur_eq_funcs = hashtable->tab_eq_funcs;
    0.00 :	  5a8ede:       49 8b 44 24 20          mov    0x20(%r12),%rax
    0.00 :	  5a8ee3:       49 89 44 24 58          mov    %rax,0x58(%r12)
         :
         :	        saveCurHT = CurTupleHashTable;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execGrouping.c:369
  100.00 :	  5a8ee8:       4c 8b 3d d1 09 5d 00    mov    0x5d09d1(%rip),%r15        # b798c0 <CurTupleHashTable>
         :	        CurTupleHashTable = hashtable;
    0.00 :	  5a8eef:       4c 89 25 ca 09 5d 00    mov    %r12,0x5d09ca(%rip)        # b798c0 <CurTupleHashTable>
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8ef6:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5a8efa:       e8 a1 b7 1d 00          callq  7846a0 <hash_search>
         :	                                                                                 &dummy,
         :	                                                                                 isnew ? HASH_ENTER : HASH_FIND,
         :	                                                                                 &found);
         :
         :	        if (isnew)
    0.00 :	  5a8eff:       4d 85 ed                test   %r13,%r13
         :	        saveCurHT = CurTupleHashTable;
         :	        CurTupleHashTable = hashtable;
         :
         :	        /* Search the hash table */
         :	        dummy.firstTuple = NULL;        /* flag to reference inputslot */
         :	        entry = (TupleHashEntry) hash_search(hashtable->hashtab,
    0.00 :	  5a8f02:       48 89 c3                mov    %rax,%rbx
         :	                                                                                 &dummy,
         :	                                                                                 isnew ? HASH_ENTER : HASH_FIND,
         :	                                                                                 &found);
         :
         :	        if (isnew)
    0.00 :	  5a8f05:       74 41                   je     5a8f48 <LookupTupleHashEntry+0xd8>
         :	        {
         :	                if (found)
    0.00 :	  5a8f07:       80 7d cf 00             cmpb   $0x0,-0x31(%rbp)
    0.00 :	  5a8f0b:       75 6b                   jne    5a8f78 <LookupTupleHashEntry+0x108>
         :	                         *
         :	                         * Zero any caller-requested space in the entry.  (This zaps the
         :	                         * "key data" dynahash.c copied into the new entry, but we don't
         :	                         * care since we're about to overwrite it anyway.)
         :	                         */
         :	                        MemSet(entry, 0, hashtable->entrysize);
    0.00 :	  5a8f0d:       49 8b 54 24 38          mov    0x38(%r12),%rdx
    0.00 :	  5a8f12:       48 09 d0                or     %rdx,%rax
    0.00 :	  5a8f15:       a8 07                   test   $0x7,%al
    0.00 :	  5a8f17:       75 09                   jne    5a8f22 <LookupTupleHashEntry+0xb2>
    0.00 :	  5a8f19:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	  5a8f20:       76 5e                   jbe    5a8f80 <LookupTupleHashEntry+0x110>
    0.00 :	  5a8f22:       31 f6                   xor    %esi,%esi
    0.00 :	  5a8f24:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5a8f27:       e8 f4 04 ec ff          callq  469420 <memset@plt>
    0.00 :	  5a8f2c:       49 8b 44 24 28          mov    0x28(%r12),%rax
         :
         :	                        /* Copy the first tuple into the table context */
         :	                        MemoryContextSwitchTo(hashtable->tablecxt);
         :	                        entry->firstTuple = ExecCopySlotMinimalTuple(slot);
    0.00 :	  5a8f31:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5a8f34:       48 89 05 25 19 61 00    mov    %rax,0x611925(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5a8f3b:       e8 c0 af 00 00          callq  5b3f00 <ExecCopySlotMinimalTuple>
    0.00 :	  5a8f40:       48 89 03                mov    %rax,(%rbx)
         :
         :	                        *isnew = true;
    0.00 :	  5a8f43:       41 c6 45 00 01          movb   $0x1,0x0(%r13)
    0.00 :	  5a8f48:       48 8b 45 b8             mov    -0x48(%rbp),%rax
         :	                }
         :	        }
         :
         :	        CurTupleHashTable = saveCurHT;
    0.00 :	  5a8f4c:       4c 89 3d 6d 09 5d 00    mov    %r15,0x5d096d(%rip)        # b798c0 <CurTupleHashTable>
         :
         :	        MemoryContextSwitchTo(oldContext);
         :
         :	        return entry;
         :	}
    0.00 :	  5a8f53:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5a8f57:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5a8f5b:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5a8f5f:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5a8f63:       48 89 05 f6 18 61 00    mov    %rax,0x6118f6(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5a8f6a:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5a8f6d:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5a8f71:       c9                      leaveq 
    0.00 :	  5a8f72:       c3                      retq   
    0.00 :	  5a8f73:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	        if (isnew)
         :	        {
         :	                if (found)
         :	                {
         :	                        /* found pre-existing entry */
         :	                        *isnew = false;
    0.00 :	  5a8f78:       41 c6 45 00 00          movb   $0x0,0x0(%r13)
    0.00 :	  5a8f7d:       eb c9                   jmp    5a8f48 <LookupTupleHashEntry+0xd8>
    0.00 :	  5a8f7f:       90                      nop
         :	                         *
         :	                         * Zero any caller-requested space in the entry.  (This zaps the
         :	                         * "key data" dynahash.c copied into the new entry, but we don't
         :	                         * care since we're about to overwrite it anyway.)
         :	                         */
         :	                        MemSet(entry, 0, hashtable->entrysize);
    0.00 :	  5a8f80:       48 8d 14 13             lea    (%rbx,%rdx,1),%rdx
    0.00 :	  5a8f84:       48 89 d8                mov    %rbx,%rax
    0.00 :	  5a8f87:       48 39 d3                cmp    %rdx,%rbx
    0.00 :	  5a8f8a:       73 a0                   jae    5a8f2c <LookupTupleHashEntry+0xbc>
    0.00 :	  5a8f8c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	  5a8f90:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
    0.00 :	  5a8f97:       48 83 c0 08             add    $0x8,%rax
    0.00 :	  5a8f9b:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  5a8f9e:       77 f0                   ja     5a8f90 <LookupTupleHashEntry+0x120>
    0.00 :	  5a8fa0:       eb 8a                   jmp    5a8f2c <LookupTupleHashEntry+0xbc>
    0.00 :	  5a8fa2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5a8fa8:       48 8b 47 28             mov    0x28(%rdi),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5a8fac:       48 8b 1d ad 18 61 00    mov    0x6118ad(%rip),%rbx        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5a8fb3:       48 89 05 a6 18 61 00    mov    %rax,0x6118a6(%rip)        # bba860 <CurrentMemoryContext>
         :
         :	                /*
         :	                 * We copy the input tuple descriptor just for safety --- we assume
         :	                 * all input tuples will have equivalent descriptors.
         :	                 */
         :	                tupdesc = CreateTupleDescCopy(slot->tts_tupleDescriptor);
    0.00 :	  5a8fba:       48 8b 7e 10             mov    0x10(%rsi),%rdi
    0.00 :	  5a8fbe:       e8 bd be ec ff          callq  474e80 <CreateTupleDescCopy>
    0.00 :	  5a8fc3:       48 89 c7                mov    %rax,%rdi
         :	                hashtable->tableslot = MakeSingleTupleTableSlot(tupdesc);
    0.00 :	  5a8fc6:       e8 85 b7 00 00          callq  5b4750 <MakeSingleTupleTableSlot>
    0.00 :	  5a8fcb:       49 89 44 24 40          mov    %rax,0x40(%r12)
    0.00 :	  5a8fd0:       48 89 1d 89 18 61 00    mov    %rbx,0x611889(%rip)        # bba860 <CurrentMemoryContext>
    0.00 :	  5a8fd7:       e9 c4 fe ff ff          jmpq   5a8ea0 <LookupTupleHashEntry+0x30>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2745
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005aca90 <ExecEvalOr>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalOr(BoolExprState *orExpr, ExprContext *econtext,
         :	                   bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5aca90:       55                      push   %rbp
         :	        List       *clauses = orExpr->args;
         :	        ListCell   *clause;
         :	        bool            AnyNull;
         :
         :	        if (isDone)
    0.00 :	  5aca91:       48 85 c9                test   %rcx,%rcx
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalOr(BoolExprState *orExpr, ExprContext *econtext,
         :	                   bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5aca94:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5aca97:       41 56                   push   %r14
    0.00 :	  5aca99:       49 89 f6                mov    %rsi,%r14
    0.00 :	  5aca9c:       41 55                   push   %r13
    0.00 :	  5aca9e:       41 54                   push   %r12
    0.00 :	  5acaa0:       49 89 d4                mov    %rdx,%r12
    0.00 :	  5acaa3:       53                      push   %rbx
         :	        List       *clauses = orExpr->args;
    0.00 :	  5acaa4:       48 8b 47 18             mov    0x18(%rdi),%rax
         :	        ListCell   *clause;
         :	        bool            AnyNull;
         :
         :	        if (isDone)
    0.00 :	  5acaa8:       74 06                   je     5acab0 <ExecEvalOr+0x20>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5acaaa:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5acab0:       48 85 c0                test   %rax,%rax
    0.00 :	  5acab3:       74 4b                   je     5acb00 <ExecEvalOr+0x70>
    0.00 :	  5acab5:       48 8b 58 08             mov    0x8(%rax),%rbx
         :	         * that we "don't know" what the OR's result should be --- perhaps one of
         :	         * the "don't knows" would have been TRUE if we'd known its value.  Only
         :	         * when all the inputs are known to be FALSE can we state confidently that
         :	         * the OR's result is FALSE.
         :	         */
         :	        foreach(clause, clauses)
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:2745
  100.00 :	  5acab9:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acabc:       74 42                   je     5acb00 <ExecEvalOr+0x70>
    0.00 :	  5acabe:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5acac1:       eb 14                   jmp    5acad7 <ExecEvalOr+0x47>
    0.00 :	  5acac3:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                clause_value = ExecEvalExpr(clausestate, econtext, isNull, NULL);
         :
         :	                /*
         :	                 * if we have a non-null true result, then return it.
         :	                 */
         :	                if (*isNull)
    0.00 :	  5acac8:       41 bd 01 00 00 00       mov    $0x1,%r13d
         :	         * that we "don't know" what the OR's result should be --- perhaps one of
         :	         * the "don't knows" would have been TRUE if we'd known its value.  Only
         :	         * when all the inputs are known to be FALSE can we state confidently that
         :	         * the OR's result is FALSE.
         :	         */
         :	        foreach(clause, clauses)
    0.00 :	  5acace:       48 8b 5b 08             mov    0x8(%rbx),%rbx
    0.00 :	  5acad2:       48 85 db                test   %rbx,%rbx
    0.00 :	  5acad5:       74 31                   je     5acb08 <ExecEvalOr+0x78>
         :	        {
         :	                ExprState  *clausestate = (ExprState *) lfirst(clause);
    0.00 :	  5acad7:       48 8b 03                mov    (%rbx),%rax
         :	                Datum           clause_value;
         :
         :	                clause_value = ExecEvalExpr(clausestate, econtext, isNull, NULL);
    0.00 :	  5acada:       31 c9                   xor    %ecx,%ecx
    0.00 :	  5acadc:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  5acadf:       4c 89 f6                mov    %r14,%rsi
    0.00 :	  5acae2:       48 89 c7                mov    %rax,%rdi
    0.00 :	  5acae5:       ff 50 10                callq  *0x10(%rax)
         :
         :	                /*
         :	                 * if we have a non-null true result, then return it.
         :	                 */
         :	                if (*isNull)
    0.00 :	  5acae8:       41 80 3c 24 00          cmpb   $0x0,(%r12)
    0.00 :	  5acaed:       75 d9                   jne    5acac8 <ExecEvalOr+0x38>
         :	                        AnyNull = true;         /* remember we got a null */
         :	                else if (DatumGetBool(clause_value))
    0.00 :	  5acaef:       84 c0                   test   %al,%al
    0.00 :	  5acaf1:       74 db                   je     5acace <ExecEvalOr+0x3e>
         :	        }
         :
         :	        /* AnyNull is true if at least one clause evaluated to NULL */
         :	        *isNull = AnyNull;
         :	        return BoolGetDatum(false);
         :	}
    0.00 :	  5acaf3:       5b                      pop    %rbx
    0.00 :	  5acaf4:       41 5c                   pop    %r12
    0.00 :	  5acaf6:       41 5d                   pop    %r13
    0.00 :	  5acaf8:       41 5e                   pop    %r14
    0.00 :	  5acafa:       c9                      leaveq 
    0.00 :	  5acafb:       c3                      retq   
    0.00 :	  5acafc:       0f 1f 40 00             nopl   0x0(%rax)
         :	         * that we "don't know" what the OR's result should be --- perhaps one of
         :	         * the "don't knows" would have been TRUE if we'd known its value.  Only
         :	         * when all the inputs are known to be FALSE can we state confidently that
         :	         * the OR's result is FALSE.
         :	         */
         :	        foreach(clause, clauses)
    0.00 :	  5acb00:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5acb03:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                else if (DatumGetBool(clause_value))
         :	                        return clause_value;
         :	        }
         :
         :	        /* AnyNull is true if at least one clause evaluated to NULL */
         :	        *isNull = AnyNull;
    0.00 :	  5acb08:       45 88 2c 24             mov    %r13b,(%r12)
    0.00 :	  5acb0c:       31 c0                   xor    %eax,%eax
         :	        return BoolGetDatum(false);
         :	}
    0.00 :	  5acb0e:       5b                      pop    %rbx
    0.00 :	  5acb0f:       41 5c                   pop    %r12
    0.00 :	  5acb11:       41 5d                   pop    %r13
    0.00 :	  5acb13:       41 5e                   pop    %r14
    0.00 :	  5acb15:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1082
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b2630 <ExecEvalParamExec>:
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalParamExec(ExprState *exprstate, ExprContext *econtext,
         :	                                  bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5b2630:       55                      push   %rbp
         :	        Param      *expression = (Param *) exprstate->expr;
         :	        int                     thisParamId = expression->paramid;
         :	        ParamExecData *prm;
         :
         :	        if (isDone)
    0.00 :	  5b2631:       48 85 c9                test   %rcx,%rcx
         :	 * ----------------------------------------------------------------
         :	 */
         :	static Datum
         :	ExecEvalParamExec(ExprState *exprstate, ExprContext *econtext,
         :	                                  bool *isNull, ExprDoneCond *isDone)
         :	{
    0.00 :	  5b2634:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b2637:       41 54                   push   %r12
    0.00 :	  5b2639:       49 89 d4                mov    %rdx,%r12
    0.00 :	  5b263c:       53                      push   %rbx
         :	        Param      *expression = (Param *) exprstate->expr;
         :	        int                     thisParamId = expression->paramid;
    0.00 :	  5b263d:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5b2641:       8b 40 08                mov    0x8(%rax),%eax
         :	        ParamExecData *prm;
         :
         :	        if (isDone)
    0.00 :	  5b2644:       74 06                   je     5b264c <ExecEvalParamExec+0x1c>
         :	                *isDone = ExprSingleResult;
    0.00 :	  5b2646:       c7 01 00 00 00 00       movl   $0x0,(%rcx)
         :
         :	        /*
         :	         * PARAM_EXEC params (internal executor parameters) are stored in the
         :	         * ecxt_param_exec_vals array, and can be accessed by array index.
         :	         */
         :	        prm = &(econtext->ecxt_param_exec_vals[thisParamId]);
    0.00 :	  5b264c:       48 98                   cltq   
    0.00 :	  5b264e:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	  5b2652:       48 8d 1c c5 00 00 00    lea    0x0(,%rax,8),%rbx
    0.00 :	  5b2659:       00 
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execQual.c:1082
  100.00 :	  5b265a:       48 03 5e 30             add    0x30(%rsi),%rbx
         :	        if (prm->execPlan != NULL)
    0.00 :	  5b265e:       48 8b 3b                mov    (%rbx),%rdi
    0.00 :	  5b2661:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5b2664:       74 05                   je     5b266b <ExecEvalParamExec+0x3b>
         :	        {
         :	                /* Parameter not evaluated yet, so go do it */
         :	                ExecSetParamPlan(prm->execPlan, econtext);
    0.00 :	  5b2666:       e8 f5 5a 01 00          callq  5c8160 <ExecSetParamPlan>
         :	                /* ExecSetParamPlan should have processed this param... */
         :	                Assert(prm->execPlan == NULL);
         :	        }
         :	        *isNull = prm->isnull;
    0.00 :	  5b266b:       0f b6 43 10             movzbl 0x10(%rbx),%eax
    0.00 :	  5b266f:       41 88 04 24             mov    %al,(%r12)
    0.00 :	  5b2673:       48 8b 43 08             mov    0x8(%rbx),%rax
         :	        return prm->value;
         :	}
    0.00 :	  5b2677:       5b                      pop    %rbx
    0.00 :	  5b2678:       41 5c                   pop    %r12
    0.00 :	  5b267a:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:338
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b35f0 <ExecScanReScan>:
         :	 * that uses ExecScan().
         :	 */
         :	void
         :	ExecScanReScan(ScanState *node)
         :	{
         :	        EState     *estate = node->ps.state;
    0.00 :	  5b35f0:       48 8b 47 10             mov    0x10(%rdi),%rax
         :	 * This must be called within the ReScan function of any plan node type
         :	 * that uses ExecScan().
         :	 */
         :	void
         :	ExecScanReScan(ScanState *node)
         :	{
    0.00 :	  5b35f4:       55                      push   %rbp
         :	        EState     *estate = node->ps.state;
         :
         :	        /* Stop projecting any tuples from SRFs in the targetlist */
         :	        node->ps.ps_TupFromTlist = false;
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execScan.c:338
  100.00 :	  5b35f5:       c6 47 70 00             movb   $0x0,0x70(%rdi)
         :	 * This must be called within the ReScan function of any plan node type
         :	 * that uses ExecScan().
         :	 */
         :	void
         :	ExecScanReScan(ScanState *node)
         :	{
    0.00 :	  5b35f9:       48 89 e5                mov    %rsp,%rbp
         :
         :	        /* Stop projecting any tuples from SRFs in the targetlist */
         :	        node->ps.ps_TupFromTlist = false;
         :
         :	        /* Rescan EvalPlanQual tuple if we're inside an EvalPlanQual recheck */
         :	        if (estate->es_epqScanDone != NULL)
    0.00 :	  5b35fc:       48 8b 90 e0 00 00 00    mov    0xe0(%rax),%rdx
    0.00 :	  5b3603:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5b3606:       74 0e                   je     5b3616 <ExecScanReScan+0x26>
         :	        {
         :	                Index           scanrelid = ((Scan *) node->ps.plan)->scanrelid;
         :
         :	                Assert(scanrelid > 0);
         :
         :	                estate->es_epqScanDone[scanrelid - 1] = false;
    0.00 :	  5b3608:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  5b360c:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5b360f:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5b3612:       c6 04 02 00             movb   $0x0,(%rdx,%rax,1)
         :	        }
         :	}
    0.00 :	  5b3616:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execUtils.c:1480
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b4a00 <ShutdownExprContext>:
         :	 * If isCommit is false, just clean the callback list but don't call 'em.
         :	 * (See comment for FreeExprContext.)
         :	 */
         :	static void
         :	ShutdownExprContext(ExprContext *econtext, bool isCommit)
         :	{
    0.00 :	  5b4a00:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execUtils.c:1480
  100.00 :	  5b4a01:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b4a04:       41 56                   push   %r14
    0.00 :	  5b4a06:       41 55                   push   %r13
    0.00 :	  5b4a08:       41 89 f5                mov    %esi,%r13d
    0.00 :	  5b4a0b:       41 54                   push   %r12
    0.00 :	  5b4a0d:       49 89 fc                mov    %rdi,%r12
    0.00 :	  5b4a10:       53                      push   %rbx
         :	        ExprContext_CB *ecxt_callback;
         :	        MemoryContext oldcontext;
         :
         :	        /* Fast path in normal case where there's nothing to do. */
         :	        if (econtext->ecxt_callbacks == NULL)
    0.00 :	  5b4a11:       48 83 7f 78 00          cmpq   $0x0,0x78(%rdi)
    0.00 :	  5b4a16:       74 57                   je     5b4a6f <ShutdownExprContext+0x6f>
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5b4a18:       48 8b 47 28             mov    0x28(%rdi),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5b4a1c:       4c 8b 35 3d 5e 60 00    mov    0x605e3d(%rip),%r14        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5b4a23:       48 89 05 36 5e 60 00    mov    %rax,0x605e36(%rip)        # bba860 <CurrentMemoryContext>
         :	        oldcontext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        /*
         :	         * Call each callback function in reverse registration order.
         :	         */
         :	        while ((ecxt_callback = econtext->ecxt_callbacks) != NULL)
    0.00 :	  5b4a2a:       48 8b 5f 78             mov    0x78(%rdi),%rbx
    0.00 :	  5b4a2e:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b4a31:       75 17                   jne    5b4a4a <ShutdownExprContext+0x4a>
    0.00 :	  5b4a33:       eb 33                   jmp    5b4a68 <ShutdownExprContext+0x68>
    0.00 :	  5b4a35:       0f 1f 00                nopl   (%rax)
         :	        {
         :	                econtext->ecxt_callbacks = ecxt_callback->next;
         :	                if (isCommit)
         :	                        (*ecxt_callback->function) (ecxt_callback->arg);
         :	                pfree(ecxt_callback);
    0.00 :	  5b4a38:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5b4a3b:       e8 40 41 1e 00          callq  798b80 <pfree>
         :	        oldcontext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
         :
         :	        /*
         :	         * Call each callback function in reverse registration order.
         :	         */
         :	        while ((ecxt_callback = econtext->ecxt_callbacks) != NULL)
    0.00 :	  5b4a40:       49 8b 5c 24 78          mov    0x78(%r12),%rbx
    0.00 :	  5b4a45:       48 85 db                test   %rbx,%rbx
    0.00 :	  5b4a48:       74 1e                   je     5b4a68 <ShutdownExprContext+0x68>
         :	        {
         :	                econtext->ecxt_callbacks = ecxt_callback->next;
    0.00 :	  5b4a4a:       48 8b 03                mov    (%rbx),%rax
         :	                if (isCommit)
    0.00 :	  5b4a4d:       45 84 ed                test   %r13b,%r13b
         :	        /*
         :	         * Call each callback function in reverse registration order.
         :	         */
         :	        while ((ecxt_callback = econtext->ecxt_callbacks) != NULL)
         :	        {
         :	                econtext->ecxt_callbacks = ecxt_callback->next;
    0.00 :	  5b4a50:       49 89 44 24 78          mov    %rax,0x78(%r12)
         :	                if (isCommit)
    0.00 :	  5b4a55:       74 e1                   je     5b4a38 <ShutdownExprContext+0x38>
         :	                        (*ecxt_callback->function) (ecxt_callback->arg);
    0.00 :	  5b4a57:       48 8b 7b 10             mov    0x10(%rbx),%rdi
    0.00 :	  5b4a5b:       ff 53 08                callq  *0x8(%rbx)
    0.00 :	  5b4a5e:       66 90                   xchg   %ax,%ax
    0.00 :	  5b4a60:       eb d6                   jmp    5b4a38 <ShutdownExprContext+0x38>
    0.00 :	  5b4a62:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	  5b4a68:       4c 89 35 f1 5d 60 00    mov    %r14,0x605df1(%rip)        # bba860 <CurrentMemoryContext>
         :	                pfree(ecxt_callback);
         :	        }
         :
         :	        MemoryContextSwitchTo(oldcontext);
         :	}
    0.00 :	  5b4a6f:       5b                      pop    %rbx
    0.00 :	  5b4a70:       41 5c                   pop    %r12
    0.00 :	  5b4a72:       41 5d                   pop    %r13
    0.00 :	  5b4a74:       41 5e                   pop    %r14
    0.00 :	  5b4a76:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/execUtils.c:383
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b5180 <ReScanExprContext>:
         :	 *
         :	 * Note we make no assumption about the caller's memory context.
         :	 */
         :	void
         :	ReScanExprContext(ExprContext *econtext)
         :	{
    0.00 :	  5b5180:       55                      push   %rbp
         :	        /* Call any registered callbacks */
         :	        ShutdownExprContext(econtext, true);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/execUtils.c:383
  100.00 :	  5b5181:       be 01 00 00 00          mov    $0x1,%esi
         :	 *
         :	 * Note we make no assumption about the caller's memory context.
         :	 */
         :	void
         :	ReScanExprContext(ExprContext *econtext)
         :	{
    0.00 :	  5b5186:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b5189:       53                      push   %rbx
    0.00 :	  5b518a:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  5b518d:       48 83 ec 08             sub    $0x8,%rsp
         :	        /* Call any registered callbacks */
         :	        ShutdownExprContext(econtext, true);
    0.00 :	  5b5191:       e8 6a f8 ff ff          callq  5b4a00 <ShutdownExprContext>
         :	        /* And clean up the memory used */
         :	        MemoryContextReset(econtext->ecxt_per_tuple_memory);
    0.00 :	  5b5196:       48 8b 7b 28             mov    0x28(%rbx),%rdi
         :	}
    0.00 :	  5b519a:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  5b519e:       5b                      pop    %rbx
    0.00 :	  5b519f:       c9                      leaveq 
         :	ReScanExprContext(ExprContext *econtext)
         :	{
         :	        /* Call any registered callbacks */
         :	        ShutdownExprContext(econtext, true);
         :	        /* And clean up the memory used */
         :	        MemoryContextReset(econtext->ecxt_per_tuple_memory);
    0.00 :	  5b51a0:       e9 0b 38 1e 00          jmpq   7989b0 <MemoryContextReset>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:1043
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005b9d80 <ExecAgg>:
         :	 *        stored in the expression context to be used when ExecProject evaluates
         :	 *        the result tuple.
         :	 */
         :	TupleTableSlot *
         :	ExecAgg(AggState *node)
         :	{
    0.00 :	  5b9d80:       55                      push   %rbp
    0.00 :	  5b9d81:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5b9d84:       41 57                   push   %r15
    0.00 :	  5b9d86:       41 56                   push   %r14
    0.00 :	  5b9d88:       49 89 fe                mov    %rdi,%r14
    0.00 :	  5b9d8b:       41 55                   push   %r13
    0.00 :	  5b9d8d:       41 54                   push   %r12
    0.00 :	  5b9d8f:       53                      push   %rbx
    0.00 :	  5b9d90:       48 81 ec d8 00 00 00    sub    $0xd8,%rsp
         :	        /*
         :	         * Check to see if we're still projecting out tuples from a previous agg
         :	         * tuple (because there is a function-returning-set in the projection
         :	         * expressions).  If so, try to project another one.
         :	         */
         :	        if (node->ss.ps.ps_TupFromTlist)
    0.00 :	  5b9d97:       80 7f 70 00             cmpb   $0x0,0x70(%rdi)
    0.00 :	  5b9d9b:       74 1c                   je     5b9db9 <ExecAgg+0x39>
         :	        {
         :	                TupleTableSlot *result;
         :	                ExprDoneCond isDone;
         :
         :	                result = ExecProject(node->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5b9d9d:       48 8b 7f 68             mov    0x68(%rdi),%rdi
    0.00 :	  5b9da1:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5b9da5:       e8 56 32 ff ff          callq  5ad000 <ExecProject>
         :	                if (isDone == ExprMultipleResult)
    0.00 :	  5b9daa:       83 7d d4 01             cmpl   $0x1,-0x2c(%rbp)
    0.00 :	  5b9dae:       0f 84 04 02 00 00       je     5b9fb8 <ExecAgg+0x238>
         :	                        return result;
         :	                /* Done with that source tuple... */
         :	                node->ss.ps.ps_TupFromTlist = false;
    0.00 :	  5b9db4:       41 c6 46 70 00          movb   $0x0,0x70(%r14)
         :	        /*
         :	         * Exit if nothing left to do.  (We must do the ps_TupFromTlist check
         :	         * first, because in some cases agg_done gets set before we emit the final
         :	         * aggregate tuple, and we have to finish running SRFs for it.)
         :	         */
         :	        if (node->agg_done)
    0.00 :	  5b9db9:       31 c0                   xor    %eax,%eax
    0.00 :	  5b9dbb:       41 80 be d0 00 00 00    cmpb   $0x0,0xd0(%r14)
    0.00 :	  5b9dc2:       00 
    0.00 :	  5b9dc3:       0f 85 ef 01 00 00       jne    5b9fb8 <ExecAgg+0x238>
         :	                return NULL;
         :
         :	        /* Dispatch based on strategy */
         :	        if (((Agg *) node->ss.ps.plan)->aggstrategy == AGG_HASHED)
    0.00 :	  5b9dc9:       49 8b 46 08             mov    0x8(%r14),%rax
    0.00 :	  5b9dcd:       48 89 85 10 ff ff ff    mov    %rax,-0xf0(%rbp)
    0.00 :	  5b9dd4:       83 78 60 02             cmpl   $0x2,0x60(%rax)
    0.00 :	  5b9dd8:       0f 85 ec 01 00 00       jne    5b9fca <ExecAgg+0x24a>
         :	        {
         :	                if (!node->table_filled)
    0.00 :	  5b9dde:       31 c0                   xor    %eax,%eax
    0.00 :	  5b9de0:       41 80 be 00 01 00 00    cmpb   $0x0,0x100(%r14)
    0.00 :	  5b9de7:       00 
    0.00 :	  5b9de8:       4d 8d be 08 01 00 00    lea    0x108(%r14),%r15
    0.00 :	  5b9def:       0f 84 5d 07 00 00       je     5ba552 <ExecAgg+0x7d2>
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9df5:       4d 8b 6e 60             mov    0x60(%r14),%r13
         :	        aggvalues = econtext->ecxt_aggvalues;
    0.00 :	  5b9df9:       49 8b 55 40             mov    0x40(%r13),%rdx
    0.00 :	  5b9dfd:       48 89 95 30 ff ff ff    mov    %rdx,-0xd0(%rbp)
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9e04:       49 8b 55 48             mov    0x48(%r13),%rdx
    0.00 :	  5b9e08:       48 89 95 28 ff ff ff    mov    %rdx,-0xd8(%rbp)
         :	        peragg = aggstate->peragg;
    0.00 :	  5b9e0f:       49 8b 96 b0 00 00 00    mov    0xb0(%r14),%rdx
    0.00 :	  5b9e16:       48 89 95 20 ff ff ff    mov    %rdx,-0xe0(%rbp)
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5b9e1d:       49 8b 96 88 00 00 00    mov    0x88(%r14),%rdx
    0.00 :	  5b9e24:       48 89 95 18 ff ff ff    mov    %rdx,-0xe8(%rbp)
         :
         :	        /*
         :	         * We loop retrieving groups until we find one satisfying
         :	         * aggstate->ss.ps.qual
         :	         */
         :	        while (!aggstate->agg_done)
    0.00 :	  5b9e2b:       84 c0                   test   %al,%al
    0.00 :	  5b9e2d:       0f 85 83 01 00 00       jne    5b9fb6 <ExecAgg+0x236>
         :	        {
         :	                /*
         :	                 * Find the next entry in the hash table
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
    0.00 :	  5b9e33:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5b9e36:       e8 85 9c 1c 00          callq  783ac0 <hash_seq_search>
         :	                if (entry == NULL)
    0.00 :	  5b9e3b:       48 85 c0                test   %rax,%rax
         :	        while (!aggstate->agg_done)
         :	        {
         :	                /*
         :	                 * Find the next entry in the hash table
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
    0.00 :	  5b9e3e:       49 89 c4                mov    %rax,%r12
         :	                if (entry == NULL)
    0.00 :	  5b9e41:       0f 84 fc 06 00 00       je     5ba543 <ExecAgg+0x7c3>
         :	                 *
         :	                 * We intentionally don't use ReScanExprContext here; if any aggs have
         :	                 * registered shutdown callbacks, they mustn't be called yet, since we
         :	                 * might not be done with that agg.
         :	                 */
         :	                ResetExprContext(econtext);
    0.00 :	  5b9e47:       49 8b 7d 28             mov    0x28(%r13),%rdi
    0.00 :	  5b9e4b:       e8 60 eb 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                /*
         :	                 * Store the copied first input tuple in the tuple table slot reserved
         :	                 * for it, so that it can be used in ExecProject.
         :	                 */
         :	                ExecStoreMinimalTuple(entry->shared.firstTuple,
    0.00 :	  5b9e50:       48 8b b5 18 ff ff ff    mov    -0xe8(%rbp),%rsi
    0.00 :	  5b9e57:       49 8b 3c 24             mov    (%r12),%rdi
    0.00 :	  5b9e5b:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9e5d:       e8 7e a5 ff ff          callq  5b43e0 <ExecStoreMinimalTuple>
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9e62:       41 8b 96 98 00 00 00    mov    0x98(%r14),%edx
    0.00 :	  5b9e69:       85 d2                   test   %edx,%edx
    0.00 :	  5b9e6b:       7e 49                   jle    5b9eb6 <ExecAgg+0x136>
    0.00 :	  5b9e6d:       31 db                   xor    %ebx,%ebx
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
         :
         :	                        Assert(peraggstate->numSortCols == 0);
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9e6f:       48 8b 85 30 ff ff ff    mov    -0xd0(%rbp),%rax
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
    0.00 :	  5b9e76:       48 63 fb                movslq %ebx,%rdi
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9e79:       83 c3 01                add    $0x1,%ebx
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
         :
         :	                        Assert(peraggstate->numSortCols == 0);
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9e7c:       48 69 f7 a8 04 00 00    imul   $0x4a8,%rdi,%rsi
    0.00 :	  5b9e83:       48 03 b5 20 ff ff ff    add    -0xe0(%rbp),%rsi
    0.00 :	  5b9e8a:       48 8d 0c f8             lea    (%rax,%rdi,8),%rcx
    0.00 :	  5b9e8e:       48 89 f8                mov    %rdi,%rax
    0.00 :	  5b9e91:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  5b9e95:       49 8d 54 04 08          lea    0x8(%r12,%rax,1),%rdx
    0.00 :	  5b9e9a:       48 8b 85 28 ff ff ff    mov    -0xd8(%rbp),%rax
    0.00 :	  5b9ea1:       4c 8d 04 38             lea    (%rax,%rdi,1),%r8
    0.00 :	  5b9ea5:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b9ea8:       e8 13 fc ff ff          callq  5b9ac0 <finalize_aggregate>
         :
         :	                /*
         :	                 * Finalize each aggregate calculation, and stash results in the
         :	                 * per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9ead:       41 3b 9e 98 00 00 00    cmp    0x98(%r14),%ebx
    0.00 :	  5b9eb4:       7c b9                   jl     5b9e6f <ExecAgg+0xef>
         :
         :	                /*
         :	                 * Use the representative input tuple for any references to
         :	                 * non-aggregated input columns in the qual and tlist.
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5b9eb6:       48 8b 95 18 ff ff ff    mov    -0xe8(%rbp),%rdx
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9ebd:       4c 89 ee                mov    %r13,%rsi
         :
         :	                /*
         :	                 * Use the representative input tuple for any references to
         :	                 * non-aggregated input columns in the qual and tlist.
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5b9ec0:       49 89 55 18             mov    %rdx,0x18(%r13)
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9ec4:       49 8b 7e 28             mov    0x28(%r14),%rdi
    0.00 :	  5b9ec8:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9eca:       e8 41 30 ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b9ecf:       84 c0                   test   %al,%al
    0.00 :	  5b9ed1:       0f 85 4e 06 00 00       jne    5ba525 <ExecAgg+0x7a5>
         :	                                        (isDone == ExprMultipleResult);
         :	                                return result;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(aggstate, 1);
    0.00 :	  5b9ed7:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5b9edb:       48 85 c0                test   %rax,%rax
    0.00 :	  5b9ede:       74 18                   je     5b9ef8 <ExecAgg+0x178>
    0.00 :	  5b9ee0:       f2 0f 10 05 70 52 1f    movsd  0x1f5270(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b9ee7:       00 
    0.00 :	  5b9ee8:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b9eef:       00 
    0.00 :	  5b9ef0:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b9ef7:       00 
    0.00 :	  5b9ef8:       41 0f b6 86 d0 00 00    movzbl 0xd0(%r14),%eax
    0.00 :	  5b9eff:       00 
    0.00 :	  5b9f00:       e9 26 ff ff ff          jmpq   5b9e2b <ExecAgg+0xab>
         :	                        MemoryContextReset(workcontext);
         :
         :	                ExecClearTuple(slot1);
         :	        }
         :
         :	        if (slot2)
    0.00 :	  5b9f05:       4d 85 ff                test   %r15,%r15
    0.00 :	  5b9f08:       74 08                   je     5b9f12 <ExecAgg+0x192>
         :	                ExecClearTuple(slot2);
    0.00 :	  5b9f0a:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5b9f0d:       e8 fe a1 ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	        tuplesort_end(peraggstate->sortstate);
    0.00 :	  5b9f12:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5b9f19:       00 
    0.00 :	  5b9f1a:       e8 c1 52 1e 00          callq  79f1e0 <tuplesort_end>
         :	        peraggstate->sortstate = NULL;
    0.00 :	  5b9f1f:       49 c7 84 24 f8 00 00    movq   $0x0,0xf8(%r12)
    0.00 :	  5b9f26:       00 00 00 00 00 
         :	                                        process_ordered_aggregate_multi(aggstate,
         :	                                                                                                        peraggstate,
         :	                                                                                                        pergroupstate);
         :	                        }
         :
         :	                        finalize_aggregate(aggstate, peraggstate, pergroupstate,
    0.00 :	  5b9f2b:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	  5b9f2f:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	  5b9f36:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5b9f39:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5b9f3c:       48 8d 0c d0             lea    (%rax,%rdx,8),%rcx
    0.00 :	  5b9f40:       48 8b 85 60 ff ff ff    mov    -0xa0(%rbp),%rax
    0.00 :	  5b9f47:       4c 8d 04 10             lea    (%rax,%rdx,1),%r8
    0.00 :	  5b9f4b:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5b9f52:       e8 69 fb ff ff          callq  5b9ac0 <finalize_aggregate>
         :
         :	                /*
         :	                 * Done scanning input tuple group. Finalize each aggregate
         :	                 * calculation, and stash results in the per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5b9f57:       83 85 44 ff ff ff 01    addl   $0x1,-0xbc(%rbp)
    0.00 :	  5b9f5e:       8b 95 44 ff ff ff       mov    -0xbc(%rbp),%edx
    0.00 :	  5b9f64:       41 3b 96 98 00 00 00    cmp    0x98(%r14),%edx
    0.00 :	  5b9f6b:       0f 8c f6 01 00 00       jl     5ba167 <ExecAgg+0x3e7>
         :
         :	                /*
         :	                 * Check the qual (HAVING clause); if the group does not match, ignore
         :	                 * it and loop back to try to process another group.
         :	                 */
         :	                if (ExecQual(aggstate->ss.ps.qual, econtext, false))
    0.00 :	  5b9f71:       49 8b 7e 28             mov    0x28(%r14),%rdi
    0.00 :	  5b9f75:       48 8b b5 78 ff ff ff    mov    -0x88(%rbp),%rsi
    0.00 :	  5b9f7c:       31 d2                   xor    %edx,%edx
    0.00 :	  5b9f7e:       e8 8d 2f ff ff          callq  5acf10 <ExecQual>
    0.00 :	  5b9f83:       84 c0                   test   %al,%al
    0.00 :	  5b9f85:       0f 85 18 05 00 00       jne    5ba4a3 <ExecAgg+0x723>
         :	                                        (isDone == ExprMultipleResult);
         :	                                return result;
         :	                        }
         :	                }
         :	                else
         :	                        InstrCountFiltered1(aggstate, 1);
    0.00 :	  5b9f8b:       49 8b 46 18             mov    0x18(%r14),%rax
    0.00 :	  5b9f8f:       48 85 c0                test   %rax,%rax
    0.00 :	  5b9f92:       74 18                   je     5b9fac <ExecAgg+0x22c>
    0.00 :	  5b9f94:       f2 0f 10 05 bc 51 1f    movsd  0x1f51bc(%rip),%xmm0        # 7af158 <__func__.15777+0x10>
    0.00 :	  5b9f9b:       00 
    0.00 :	  5b9f9c:       f2 0f 58 80 c8 00 00    addsd  0xc8(%rax),%xmm0
    0.00 :	  5b9fa3:       00 
    0.00 :	  5b9fa4:       f2 0f 11 80 c8 00 00    movsd  %xmm0,0xc8(%rax)
    0.00 :	  5b9fab:       00 
         :
         :	        /*
         :	         * We loop retrieving groups until we find one matching
         :	         * aggstate->ss.ps.qual
         :	         */
         :	        while (!aggstate->agg_done)
    0.00 :	  5b9fac:       41 80 be d0 00 00 00    cmpb   $0x0,0xd0(%r14)
    0.00 :	  5b9fb3:       00 
    0.00 :	  5b9fb4:       74 75                   je     5ba02b <ExecAgg+0x2ab>
    0.00 :	  5b9fb6:       31 c0                   xor    %eax,%eax
         :	                        agg_fill_hash_table(node);
         :	                return agg_retrieve_hash_table(node);
         :	        }
         :	        else
         :	                return agg_retrieve_direct(node);
         :	}
    0.00 :	  5b9fb8:       48 81 c4 d8 00 00 00    add    $0xd8,%rsp
    0.00 :	  5b9fbf:       5b                      pop    %rbx
    0.00 :	  5b9fc0:       41 5c                   pop    %r12
    0.00 :	  5b9fc2:       41 5d                   pop    %r13
    0.00 :	  5b9fc4:       41 5e                   pop    %r14
    0.00 :	  5b9fc6:       41 5f                   pop    %r15
    0.00 :	  5b9fc8:       c9                      leaveq 
    0.00 :	  5b9fc9:       c3                      retq   
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9fca:       49 8b 56 60             mov    0x60(%r14),%rdx
         :	        int                     aggno;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5b9fce:       49 8b 46 30             mov    0x30(%r14),%rax
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
    0.00 :	  5b9fd2:       48 89 95 78 ff ff ff    mov    %rdx,-0x88(%rbp)
         :	        int                     aggno;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5b9fd9:       48 89 45 80             mov    %rax,-0x80(%rbp)
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
    0.00 :	  5b9fdd:       48 8b 42 40             mov    0x40(%rdx),%rax
    0.00 :	  5b9fe1:       48 89 85 68 ff ff ff    mov    %rax,-0x98(%rbp)
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9fe8:       48 8b 52 48             mov    0x48(%rdx),%rdx
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5b9fec:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
    0.00 :	  5b9ff3:       48 89 95 60 ff ff ff    mov    %rdx,-0xa0(%rbp)
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
    0.00 :	  5b9ffa:       49 8b 96 b0 00 00 00    mov    0xb0(%r14),%rdx
         :	        /* econtext is the per-output-tuple expression context */
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5ba001:       48 89 85 70 ff ff ff    mov    %rax,-0x90(%rbp)
         :	        peragg = aggstate->peragg;
         :	        pergroup = aggstate->pergroup;
    0.00 :	  5ba008:       49 8b 86 d8 00 00 00    mov    0xd8(%r14),%rax
         :	        econtext = aggstate->ss.ps.ps_ExprContext;
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
    0.00 :	  5ba00f:       48 89 95 58 ff ff ff    mov    %rdx,-0xa8(%rbp)
         :	        pergroup = aggstate->pergroup;
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5ba016:       49 8b 96 88 00 00 00    mov    0x88(%r14),%rdx
         :	        aggvalues = econtext->ecxt_aggvalues;
         :	        aggnulls = econtext->ecxt_aggnulls;
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
         :	        peragg = aggstate->peragg;
         :	        pergroup = aggstate->pergroup;
    0.00 :	  5ba01d:       48 89 85 50 ff ff ff    mov    %rax,-0xb0(%rbp)
         :	        firstSlot = aggstate->ss.ss_ScanTupleSlot;
    0.00 :	  5ba024:       48 89 95 48 ff ff ff    mov    %rdx,-0xb8(%rbp)
         :	        {
         :	                /*
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
    0.00 :	  5ba02b:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	  5ba032:       00 
    0.00 :	  5ba033:       0f 84 a4 04 00 00       je     5ba4dd <ExecAgg+0x75d>
         :	                 * We use ReScanExprContext not just ResetExprContext because we want
         :	                 * any registered shutdown callbacks to be called.  That allows
         :	                 * aggregate functions to ensure they've cleaned up any non-memory
         :	                 * resources.
         :	                 */
         :	                ReScanExprContext(econtext);
    0.00 :	  5ba039:       48 8b bd 78 ff ff ff    mov    -0x88(%rbp),%rdi
    0.00 :	  5ba040:       e8 3b b1 ff ff          callq  5b5180 <ReScanExprContext>
         :
         :	                MemoryContextResetAndDeleteChildren(aggstate->aggcontext);
    0.00 :	  5ba045:       49 8b be b8 00 00 00    mov    0xb8(%r14),%rdi
    0.00 :	  5ba04c:       e8 bf eb 1d 00          callq  798c10 <MemoryContextResetAndDeleteChildren>
         :
         :	                /*
         :	                 * Initialize working state for a new input tuple group
         :	                 */
         :	                initialize_aggregates(aggstate, peragg, pergroup);
    0.00 :	  5ba051:       48 8b 95 50 ff ff ff    mov    -0xb0(%rbp),%rdx
    0.00 :	  5ba058:       48 8b b5 58 ff ff ff    mov    -0xa8(%rbp),%rsi
    0.00 :	  5ba05f:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba062:       e8 69 f5 ff ff          callq  5b95d0 <initialize_aggregates>
         :
         :	                if (aggstate->grp_firstTuple != NULL)
    0.00 :	  5ba067:       49 8b be e0 00 00 00    mov    0xe0(%r14),%rdi
    0.00 :	  5ba06e:       48 85 ff                test   %rdi,%rdi
    0.00 :	  5ba071:       0f 84 c5 00 00 00       je     5ba13c <ExecAgg+0x3bc>
         :	                        /*
         :	                         * Store the copied first input tuple in the tuple table slot
         :	                         * reserved for it.  The tuple will be deleted when it is cleared
         :	                         * from the slot.
         :	                         */
         :	                        ExecStoreTuple(aggstate->grp_firstTuple,
    0.00 :	  5ba077:       48 8b b5 48 ff ff ff    mov    -0xb8(%rbp),%rsi
    0.00 :	  5ba07e:       31 d2                   xor    %edx,%edx
    0.00 :	  5ba080:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	  5ba085:       e8 f6 a3 ff ff          callq  5b4480 <ExecStoreTuple>
         :	                                                   InvalidBuffer,
         :	                                                   true);
         :	                        aggstate->grp_firstTuple = NULL;        /* don't keep two pointers */
         :
         :	                        /* set up for first advance_aggregates call */
         :	                        tmpcontext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba08a:       48 8b 85 48 ff ff ff    mov    -0xb8(%rbp),%rax
    0.00 :	  5ba091:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
         :	                         */
         :	                        ExecStoreTuple(aggstate->grp_firstTuple,
         :	                                                   firstSlot,
         :	                                                   InvalidBuffer,
         :	                                                   true);
         :	                        aggstate->grp_firstTuple = NULL;        /* don't keep two pointers */
    0.00 :	  5ba098:       49 c7 86 e0 00 00 00    movq   $0x0,0xe0(%r14)
    0.00 :	  5ba09f:       00 00 00 00 
         :
         :	                        /* set up for first advance_aggregates call */
         :	                        tmpcontext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba0a3:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	                         * Process each outer-plan tuple, and then fetch the next one,
         :	                         * until we exhaust the outer plan or cross a group boundary.
         :	                         */
         :	                        for (;;)
         :	                        {
         :	                                advance_aggregates(aggstate, pergroup);
    0.00 :	  5ba0a7:       48 8b b5 50 ff ff ff    mov    -0xb0(%rbp),%rsi
    0.00 :	  5ba0ae:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba0b1:       e8 9a f8 ff ff          callq  5b9950 <advance_aggregates>
         :
         :	                                /* Reset per-input-tuple context after each tuple */
         :	                                ResetExprContext(tmpcontext);
    0.00 :	  5ba0b6:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  5ba0bd:       48 8b 7a 28             mov    0x28(%rdx),%rdi
    0.00 :	  5ba0c1:       e8 ea e8 1d 00          callq  7989b0 <MemoryContextReset>
         :
         :	                                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba0c6:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  5ba0ca:       e8 d1 23 ff ff          callq  5ac4a0 <ExecProcNode>
         :	                                if (TupIsNull(outerslot))
    0.00 :	  5ba0cf:       48 85 c0                test   %rax,%rax
         :	                                advance_aggregates(aggstate, pergroup);
         :
         :	                                /* Reset per-input-tuple context after each tuple */
         :	                                ResetExprContext(tmpcontext);
         :
         :	                                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba0d2:       48 89 c3                mov    %rax,%rbx
         :	                                if (TupIsNull(outerslot))
    0.00 :	  5ba0d5:       0f 84 f5 03 00 00       je     5ba4d0 <ExecAgg+0x750>
    0.00 :	  5ba0db:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba0df:       0f 85 eb 03 00 00       jne    5ba4d0 <ExecAgg+0x750>
         :	                                        /* no more outer-plan tuples available */
         :	                                        aggstate->agg_done = true;
         :	                                        break;
         :	                                }
         :	                                /* set up for next advance_aggregates call */
         :	                                tmpcontext->ecxt_outertuple = outerslot;
    0.00 :	  5ba0e5:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5ba0ec:       48 89 58 18             mov    %rbx,0x18(%rax)
         :
         :	                                /*
         :	                                 * If we are grouping, check whether we've crossed a group
         :	                                 * boundary.
         :	                                 */
         :	                                if (node->aggstrategy == AGG_SORTED)
    0.00 :	  5ba0f0:       48 8b 95 10 ff ff ff    mov    -0xf0(%rbp),%rdx
    0.00 :	  5ba0f7:       83 7a 60 01             cmpl   $0x1,0x60(%rdx)
    0.00 :	  5ba0fb:       75 aa                   jne    5ba0a7 <ExecAgg+0x327>
         :	                                {
         :	                                        if (!execTuplesMatch(firstSlot,
    0.00 :	  5ba0fd:       48 8b 85 70 ff ff ff    mov    -0x90(%rbp),%rax
    0.00 :	  5ba104:       48 8b 4a 68             mov    0x68(%rdx),%rcx
    0.00 :	  5ba108:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5ba10b:       8b 52 64                mov    0x64(%rdx),%edx
    0.00 :	  5ba10e:       4d 8b 86 a0 00 00 00    mov    0xa0(%r14),%r8
    0.00 :	  5ba115:       48 8b bd 48 ff ff ff    mov    -0xb8(%rbp),%rdi
    0.00 :	  5ba11c:       4c 8b 48 28             mov    0x28(%rax),%r9
    0.00 :	  5ba120:       e8 1b f3 fe ff          callq  5a9440 <execTuplesMatch>
    0.00 :	  5ba125:       84 c0                   test   %al,%al
    0.00 :	  5ba127:       0f 85 7a ff ff ff       jne    5ba0a7 <ExecAgg+0x327>
         :	                                                                                 tmpcontext->ecxt_per_tuple_memory))
         :	                                        {
         :	                                                /*
         :	                                                 * Save the first input tuple of the next group.
         :	                                                 */
         :	                                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
    0.00 :	  5ba12d:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba130:       e8 7b 9e ff ff          callq  5b3fb0 <ExecCopySlotTuple>
    0.00 :	  5ba135:       49 89 86 e0 00 00 00    mov    %rax,0xe0(%r14)
         :	                 * qual, and the tlist.  (If we are not grouping, and there are no
         :	                 * input rows at all, we will come here with an empty firstSlot ...
         :	                 * but if not grouping, there can't be any references to
         :	                 * non-aggregated input columns, so no problem.)
         :	                 */
         :	                econtext->ecxt_outertuple = firstSlot;
    0.00 :	  5ba13c:       48 8b 85 48 ff ff ff    mov    -0xb8(%rbp),%rax
    0.00 :	  5ba143:       48 8b 95 78 ff ff ff    mov    -0x88(%rbp),%rdx
    0.00 :	  5ba14a:       48 89 42 18             mov    %rax,0x18(%rdx)
         :
         :	                /*
         :	                 * Done scanning input tuple group. Finalize each aggregate
         :	                 * calculation, and stash results in the per-output-tuple context.
         :	                 */
         :	                for (aggno = 0; aggno < aggstate->numaggs; aggno++)
    0.00 :	  5ba14e:       41 8b 86 98 00 00 00    mov    0x98(%r14),%eax
    0.00 :	  5ba155:       85 c0                   test   %eax,%eax
    0.00 :	  5ba157:       0f 8e 14 fe ff ff       jle    5b9f71 <ExecAgg+0x1f1>
    0.00 :	  5ba15d:       c7 85 44 ff ff ff 00    movl   $0x0,-0xbc(%rbp)
    0.00 :	  5ba164:       00 00 00 
         :	                {
         :	                        AggStatePerAgg peraggstate = &peragg[aggno];
    0.00 :	  5ba167:       48 63 95 44 ff ff ff    movslq -0xbc(%rbp),%rdx
    0.00 :	  5ba16e:       4c 8b a5 58 ff ff ff    mov    -0xa8(%rbp),%r12
    0.00 :	  5ba175:       48 69 c2 a8 04 00 00    imul   $0x4a8,%rdx,%rax
    0.00 :	  5ba17c:       48 89 55 88             mov    %rdx,-0x78(%rbp)
    0.00 :	  5ba180:       49 01 c4                add    %rax,%r12
         :	                        AggStatePerGroup pergroupstate = &pergroup[aggno];
    0.00 :	  5ba183:       48 89 d0                mov    %rdx,%rax
    0.00 :	  5ba186:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  5ba18a:       48 03 85 50 ff ff ff    add    -0xb0(%rbp),%rax
    0.00 :	  5ba191:       48 89 85 38 ff ff ff    mov    %rax,-0xc8(%rbp)
         :
         :	                        if (peraggstate->numSortCols > 0)
    0.00 :	  5ba198:       41 8b 84 24 8c 00 00    mov    0x8c(%r12),%eax
    0.00 :	  5ba19f:       00 
    0.00 :	  5ba1a0:       85 c0                   test   %eax,%eax
    0.00 :	  5ba1a2:       0f 8e 83 fd ff ff       jle    5b9f2b <ExecAgg+0x1ab>
         :	                        {
         :	                                if (peraggstate->numInputs == 1)
    0.00 :	  5ba1a8:       41 83 7c 24 14 01       cmpl   $0x1,0x14(%r12)
    0.00 :	  5ba1ae:       0f 84 3e 01 00 00       je     5ba2f2 <ExecAgg+0x572>
         :	static void
         :	process_ordered_aggregate_multi(AggState *aggstate,
         :	                                                                AggStatePerAgg peraggstate,
         :	                                                                AggStatePerGroup pergroupstate)
         :	{
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba1b4:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
    0.00 :	  5ba1bb:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ba1bf:       48 89 45 c0             mov    %rax,-0x40(%rbp)
         :	        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :	        TupleTableSlot *slot1 = peraggstate->evalslot;
         :	        TupleTableSlot *slot2 = peraggstate->uniqslot;
         :	        int                     numTransInputs = peraggstate->numTransInputs;
         :	        int                     numDistinctCols = peraggstate->numDistinctCols;
    0.00 :	  5ba1c3:       41 8b 84 24 90 00 00    mov    0x90(%r12),%eax
    0.00 :	  5ba1ca:       00 
         :	                                                                AggStatePerAgg peraggstate,
         :	                                                                AggStatePerGroup pergroupstate)
         :	{
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
         :	        FunctionCallInfo fcinfo = &peraggstate->transfn_fcinfo;
         :	        TupleTableSlot *slot1 = peraggstate->evalslot;
    0.00 :	  5ba1cb:       49 8b 9c 24 e8 00 00    mov    0xe8(%r12),%rbx
    0.00 :	  5ba1d2:       00 
         :	        TupleTableSlot *slot2 = peraggstate->uniqslot;
    0.00 :	  5ba1d3:       4d 8b bc 24 f0 00 00    mov    0xf0(%r12),%r15
    0.00 :	  5ba1da:       00 
         :	        int                     numTransInputs = peraggstate->numTransInputs;
    0.00 :	  5ba1db:       45 8b 6c 24 18          mov    0x18(%r12),%r13d
         :	        int                     numDistinctCols = peraggstate->numDistinctCols;
    0.00 :	  5ba1e0:       89 45 bc                mov    %eax,-0x44(%rbp)
         :	        bool            haveOldValue = false;
         :	        int                     i;
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
    0.00 :	  5ba1e3:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba1ea:       00 
    0.00 :	  5ba1eb:       e8 00 7e 1e 00          callq  7a1ff0 <tuplesort_performsort>
         :
         :	        ExecClearTuple(slot1);
    0.00 :	  5ba1f0:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba1f3:       e8 18 9f ff ff          callq  5b4110 <ExecClearTuple>
         :	        if (slot2)
    0.00 :	  5ba1f8:       4d 85 ff                test   %r15,%r15
    0.00 :	  5ba1fb:       74 08                   je     5ba205 <ExecAgg+0x485>
         :	                ExecClearTuple(slot2);
    0.00 :	  5ba1fd:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba200:       e8 0b 9f ff ff          callq  5b4110 <ExecClearTuple>
    0.00 :	  5ba205:       c6 45 bb 00             movb   $0x0,-0x45(%rbp)
    0.00 :	  5ba209:       eb 3d                   jmp    5ba248 <ExecAgg+0x4c8>
         :	                 * transfn.  (This will help execTuplesMatch too, so we do it
         :	                 * immediately.)
         :	                 */
         :	                slot_getsomeattrs(slot1, numTransInputs);
         :
         :	                if (numDistinctCols == 0 ||
    0.00 :	  5ba20b:       80 7d bb 00             cmpb   $0x0,-0x45(%rbp)
    0.00 :	  5ba20f:       90                      nop
    0.00 :	  5ba210:       74 6c                   je     5ba27e <ExecAgg+0x4fe>
    0.00 :	  5ba212:       49 8b 8c 24 98 00 00    mov    0x98(%r12),%rcx
    0.00 :	  5ba219:       00 
    0.00 :	  5ba21a:       4c 8b 4d c0             mov    -0x40(%rbp),%r9
    0.00 :	  5ba21e:       4c 89 fe                mov    %r15,%rsi
    0.00 :	  5ba221:       4d 8b 84 24 b8 00 00    mov    0xb8(%r12),%r8
    0.00 :	  5ba228:       00 
    0.00 :	  5ba229:       8b 55 bc                mov    -0x44(%rbp),%edx
    0.00 :	  5ba22c:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba22f:       e8 0c f2 fe ff          callq  5a9440 <execTuplesMatch>
    0.00 :	  5ba234:       84 c0                   test   %al,%al
    0.00 :	  5ba236:       74 46                   je     5ba27e <ExecAgg+0x4fe>
    0.00 :	  5ba238:       c6 45 bb 01             movb   $0x1,-0x45(%rbp)
    0.00 :	  5ba23c:       0f 1f 40 00             nopl   0x0(%rax)
         :
         :	                /* Reset context each time, unless execTuplesMatch did it for us */
         :	                if (numDistinctCols == 0)
         :	                        MemoryContextReset(workcontext);
         :
         :	                ExecClearTuple(slot1);
    0.00 :	  5ba240:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba243:       e8 c8 9e ff ff          callq  5b4110 <ExecClearTuple>
         :
         :	        ExecClearTuple(slot1);
         :	        if (slot2)
         :	                ExecClearTuple(slot2);
         :
         :	        while (tuplesort_gettupleslot(peraggstate->sortstate, true, slot1))
    0.00 :	  5ba248:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba24f:       00 
    0.00 :	  5ba250:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5ba253:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5ba258:       e8 33 40 1e 00          callq  79e290 <tuplesort_gettupleslot>
    0.00 :	  5ba25d:       84 c0                   test   %al,%al
    0.00 :	  5ba25f:       0f 84 a0 fc ff ff       je     5b9f05 <ExecAgg+0x185>
         :	                /*
         :	                 * Extract the first numTransInputs columns as datums to pass to the
         :	                 * transfn.  (This will help execTuplesMatch too, so we do it
         :	                 * immediately.)
         :	                 */
         :	                slot_getsomeattrs(slot1, numTransInputs);
    0.00 :	  5ba265:       44 89 ee                mov    %r13d,%esi
    0.00 :	  5ba268:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba26b:       e8 f0 4f eb ff          callq  46f260 <slot_getsomeattrs>
         :
         :	                if (numDistinctCols == 0 ||
    0.00 :	  5ba270:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  5ba273:       85 c0                   test   %eax,%eax
    0.00 :	  5ba275:       0f 94 85 0f ff ff ff    sete   -0xf1(%rbp)
    0.00 :	  5ba27c:       75 8d                   jne    5ba20b <ExecAgg+0x48b>
         :	                                                         peraggstate->equalfns,
         :	                                                         workcontext))
         :	                {
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5ba27e:       45 85 ed                test   %r13d,%r13d
    0.00 :	  5ba281:       7e 2e                   jle    5ba2b1 <ExecAgg+0x531>
    0.00 :	  5ba283:       31 d2                   xor    %edx,%edx
    0.00 :	  5ba285:       0f 1f 00                nopl   (%rax)
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot1->tts_values[i];
    0.00 :	  5ba288:       48 8b 43 28             mov    0x28(%rbx),%rax
    0.00 :	  5ba28c:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  5ba290:       49 89 84 d4 28 01 00    mov    %rax,0x128(%r12,%rdx,8)
    0.00 :	  5ba297:       00 
         :	                                fcinfo->argnull[i + 1] = slot1->tts_isnull[i];
    0.00 :	  5ba298:       48 8b 43 30             mov    0x30(%rbx),%rax
    0.00 :	  5ba29c:       0f b6 04 10             movzbl (%rax,%rdx,1),%eax
    0.00 :	  5ba2a0:       41 88 84 14 41 04 00    mov    %al,0x441(%r12,%rdx,1)
    0.00 :	  5ba2a7:       00 
    0.00 :	  5ba2a8:       48 83 c2 01             add    $0x1,%rdx
         :	                                                         peraggstate->equalfns,
         :	                                                         workcontext))
         :	                {
         :	                        /* Load values into fcinfo */
         :	                        /* Start from 1, since the 0th arg will be the transition value */
         :	                        for (i = 0; i < numTransInputs; i++)
    0.00 :	  5ba2ac:       41 39 d5                cmp    %edx,%r13d
    0.00 :	  5ba2af:       7f d7                   jg     5ba288 <ExecAgg+0x508>
         :	                        {
         :	                                fcinfo->arg[i + 1] = slot1->tts_values[i];
         :	                                fcinfo->argnull[i + 1] = slot1->tts_isnull[i];
         :	                        }
         :
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba2b1:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba2b8:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba2bb:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba2be:       e8 cd f4 ff ff          callq  5b9790 <advance_transition_function>
         :
         :	                        if (numDistinctCols > 0)
    0.00 :	  5ba2c3:       8b 45 bc                mov    -0x44(%rbp),%eax
    0.00 :	  5ba2c6:       85 c0                   test   %eax,%eax
    0.00 :	  5ba2c8:       7e 0d                   jle    5ba2d7 <ExecAgg+0x557>
    0.00 :	  5ba2ca:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba2cd:       c6 45 bb 01             movb   $0x1,-0x45(%rbp)
    0.00 :	  5ba2d1:       4c 89 fb                mov    %r15,%rbx
    0.00 :	  5ba2d4:       49 89 ff                mov    %rdi,%r15
         :	                                haveOldValue = true;
         :	                        }
         :	                }
         :
         :	                /* Reset context each time, unless execTuplesMatch did it for us */
         :	                if (numDistinctCols == 0)
    0.00 :	  5ba2d7:       80 bd 0f ff ff ff 00    cmpb   $0x0,-0xf1(%rbp)
    0.00 :	  5ba2de:       0f 84 5c ff ff ff       je     5ba240 <ExecAgg+0x4c0>
         :	                        MemoryContextReset(workcontext);
    0.00 :	  5ba2e4:       48 8b 7d c0             mov    -0x40(%rbp),%rdi
    0.00 :	  5ba2e8:       e8 c3 e6 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba2ed:       e9 4e ff ff ff          jmpq   5ba240 <ExecAgg+0x4c0>
         :	                                                                 AggStatePerGroup pergroupstate)
         :	{
         :	        Datum           oldVal = (Datum) 0;
         :	        bool            oldIsNull = true;
         :	        bool            haveOldVal = false;
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba2f2:       49 8b 86 c0 00 00 00    mov    0xc0(%r14),%rax
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba2f9:       45 31 ed                xor    %r13d,%r13d
    0.00 :	  5ba2fc:       bb 01 00 00 00          mov    $0x1,%ebx
    0.00 :	  5ba301:       45 31 ff                xor    %r15d,%r15d
         :	                                                                 AggStatePerGroup pergroupstate)
         :	{
         :	        Datum           oldVal = (Datum) 0;
         :	        bool            oldIsNull = true;
         :	        bool            haveOldVal = false;
         :	        MemoryContext workcontext = aggstate->tmpcontext->ecxt_per_tuple_memory;
    0.00 :	  5ba304:       48 8b 40 28             mov    0x28(%rax),%rax
    0.00 :	  5ba308:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :	        MemoryContext oldContext;
         :	        bool            isDistinct = (peraggstate->numDistinctCols > 0);
    0.00 :	  5ba30c:       41 8b 84 24 90 00 00    mov    0x90(%r12),%eax
    0.00 :	  5ba313:       00 
    0.00 :	  5ba314:       89 45 b4                mov    %eax,-0x4c(%rbp)
         :	        Datum      *newVal;
         :	        bool       *isNull;
         :
         :	        Assert(peraggstate->numDistinctCols < 2);
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
    0.00 :	  5ba317:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba31e:       00 
    0.00 :	  5ba31f:       e8 cc 7c 1e 00          callq  7a1ff0 <tuplesort_performsort>
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
    0.00 :	  5ba324:       49 8d 94 24 28 01 00    lea    0x128(%r12),%rdx
    0.00 :	  5ba32b:       00 
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba32c:       49 8d 84 24 41 04 00    lea    0x441(%r12),%rax
    0.00 :	  5ba333:       00 
         :	        Assert(peraggstate->numDistinctCols < 2);
         :
         :	        tuplesort_performsort(peraggstate->sortstate);
         :
         :	        /* Load the column into argument 1 (arg 0 will be transition value) */
         :	        newVal = fcinfo->arg + 1;
    0.00 :	  5ba334:       48 89 55 98             mov    %rdx,-0x68(%rbp)
         :	        isNull = fcinfo->argnull + 1;
    0.00 :	  5ba338:       48 89 45 90             mov    %rax,-0x70(%rbp)
    0.00 :	  5ba33c:       eb 3c                   jmp    5ba37a <ExecAgg+0x5fa>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba33e:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba345:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba348:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba34b:       e8 40 f4 ff ff          callq  5b9790 <advance_transition_function>
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba350:       84 db                   test   %bl,%bl
    0.00 :	  5ba352:       0f 84 98 00 00 00       je     5ba3f0 <ExecAgg+0x670>
         :	                                pfree(DatumGetPointer(oldVal));
         :	                        /* and remember the new one for subsequent equality checks */
         :	                        oldVal = *newVal;
         :	                        oldIsNull = *isNull;
    0.00 :	  5ba358:       41 0f b6 9c 24 41 04    movzbl 0x441(%r12),%ebx
    0.00 :	  5ba35f:       00 00 
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
         :	                                pfree(DatumGetPointer(oldVal));
         :	                        /* and remember the new one for subsequent equality checks */
         :	                        oldVal = *newVal;
    0.00 :	  5ba361:       4d 8b bc 24 28 01 00    mov    0x128(%r12),%r15
    0.00 :	  5ba368:       00 
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ba369:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  5ba36d:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  5ba373:       48 89 15 e6 04 60 00    mov    %rdx,0x6004e6(%rip)        # bba860 <CurrentMemoryContext>
         :	         * Note: if input type is pass-by-ref, the datums returned by the sort are
         :	         * freshly palloc'd in the per-query context, so we must be careful to
         :	         * pfree them when they are no longer needed.
         :	         */
         :
         :	        while (tuplesort_getdatum(peraggstate->sortstate, true,
    0.00 :	  5ba37a:       49 8b bc 24 f8 00 00    mov    0xf8(%r12),%rdi
    0.00 :	  5ba381:       00 
    0.00 :	  5ba382:       48 8b 4d 90             mov    -0x70(%rbp),%rcx
    0.00 :	  5ba386:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  5ba38b:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  5ba38f:       e8 2c 3e 1e 00          callq  79e1c0 <tuplesort_getdatum>
    0.00 :	  5ba394:       84 c0                   test   %al,%al
    0.00 :	  5ba396:       0f 84 e0 00 00 00       je     5ba47c <ExecAgg+0x6fc>
         :	        {
         :	                /*
         :	                 * Clear and select the working context for evaluation of the equality
         :	                 * function and transition function.
         :	                 */
         :	                MemoryContextReset(workcontext);
    0.00 :	  5ba39c:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  5ba3a0:       e8 0b e6 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba3a5:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ba3a9:       48 8b 15 b0 04 60 00    mov    0x6004b0(%rip),%rdx        # bba860 <CurrentMemoryContext>
         :
         :	        CurrentMemoryContext = context;
    0.00 :	  5ba3b0:       48 89 05 a9 04 60 00    mov    %rax,0x6004a9(%rip)        # bba860 <CurrentMemoryContext>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba3b7:       8b 45 b4                mov    -0x4c(%rbp),%eax
         :	#endif   /* !PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(MCXT_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE MemoryContext
         :	MemoryContextSwitchTo(MemoryContext context)
         :	{
         :	        MemoryContext old = CurrentMemoryContext;
    0.00 :	  5ba3ba:       48 89 55 a0             mov    %rdx,-0x60(%rbp)
    0.00 :	  5ba3be:       85 c0                   test   %eax,%eax
    0.00 :	  5ba3c0:       0f 8e 78 ff ff ff       jle    5ba33e <ExecAgg+0x5be>
    0.00 :	  5ba3c6:       45 84 ed                test   %r13b,%r13b
    0.00 :	  5ba3c9:       0f 84 6f ff ff ff       je     5ba33e <ExecAgg+0x5be>
    0.00 :	  5ba3cf:       84 db                   test   %bl,%bl
    0.00 :	  5ba3d1:       75 39                   jne    5ba40c <ExecAgg+0x68c>
    0.00 :	  5ba3d3:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba3da:       00 00 
    0.00 :	  5ba3dc:       74 50                   je     5ba42e <ExecAgg+0x6ae>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba3de:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba3e5:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba3e8:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba3eb:       e8 a0 f3 ff ff          callq  5b9790 <advance_transition_function>
         :	                        /* forget the old value, if any */
         :	                        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba3f0:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba3f7:       00 00 
    0.00 :	  5ba3f9:       0f 85 59 ff ff ff       jne    5ba358 <ExecAgg+0x5d8>
         :	                                pfree(DatumGetPointer(oldVal));
    0.00 :	  5ba3ff:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba402:       e8 79 e7 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba407:       e9 4c ff ff ff          jmpq   5ba358 <ExecAgg+0x5d8>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba40c:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba413:       00 00 
    0.00 :	  5ba415:       75 35                   jne    5ba44c <ExecAgg+0x6cc>
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
         :	                                pfree(DatumGetPointer(*newVal));
         :	                }
         :	                else
         :	                {
         :	                        advance_transition_function(aggstate, peraggstate, pergroupstate);
    0.00 :	  5ba417:       48 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%rdx
    0.00 :	  5ba41e:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba421:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba424:       e8 67 f3 ff ff          callq  5b9790 <advance_transition_function>
    0.00 :	  5ba429:       e9 2a ff ff ff          jmpq   5ba358 <ExecAgg+0x5d8>
         :	                /*
         :	                 * If DISTINCT mode, and not distinct from prior, skip it.
         :	                 *
         :	                 * Note: we assume equality functions don't care about collation.
         :	                 */
         :	                if (isDistinct &&
    0.00 :	  5ba42e:       49 8b 8c 24 28 01 00    mov    0x128(%r12),%rcx
    0.00 :	  5ba435:       00 
    0.00 :	  5ba436:       49 8b bc 24 b8 00 00    mov    0xb8(%r12),%rdi
    0.00 :	  5ba43d:       00 
    0.00 :	  5ba43e:       31 f6                   xor    %esi,%esi
    0.00 :	  5ba440:       4c 89 fa                mov    %r15,%rdx
    0.00 :	  5ba443:       e8 e8 3b 1c 00          callq  77e030 <FunctionCall2Coll>
    0.00 :	  5ba448:       84 c0                   test   %al,%al
    0.00 :	  5ba44a:       74 92                   je     5ba3de <ExecAgg+0x65e>
         :	                         (!oldIsNull && !*isNull &&
         :	                          DatumGetBool(FunctionCall2(&peraggstate->equalfns[0],
         :	                                                                                 oldVal, *newVal)))))
         :	                {
         :	                        /* equal to prior, so forget this one */
         :	                        if (!peraggstate->inputtypeByVal && !*isNull)
    0.00 :	  5ba44c:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba453:       00 00 
    0.00 :	  5ba455:       0f 85 0e ff ff ff       jne    5ba369 <ExecAgg+0x5e9>
    0.00 :	  5ba45b:       41 80 bc 24 41 04 00    cmpb   $0x0,0x441(%r12)
    0.00 :	  5ba462:       00 00 
    0.00 :	  5ba464:       0f 85 ff fe ff ff       jne    5ba369 <ExecAgg+0x5e9>
         :	                                pfree(DatumGetPointer(*newVal));
    0.00 :	  5ba46a:       49 8b bc 24 28 01 00    mov    0x128(%r12),%rdi
    0.00 :	  5ba471:       00 
    0.00 :	  5ba472:       e8 09 e7 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba477:       e9 ed fe ff ff          jmpq   5ba369 <ExecAgg+0x5e9>
         :	                }
         :
         :	                MemoryContextSwitchTo(oldContext);
         :	        }
         :
         :	        if (!oldIsNull && !peraggstate->inputtypeByVal)
    0.00 :	  5ba47c:       84 db                   test   %bl,%bl
    0.00 :	  5ba47e:       0f 85 8e fa ff ff       jne    5b9f12 <ExecAgg+0x192>
    0.00 :	  5ba484:       41 80 bc 24 d0 00 00    cmpb   $0x0,0xd0(%r12)
    0.00 :	  5ba48b:       00 00 
    0.00 :	  5ba48d:       0f 1f 00                nopl   (%rax)
    0.00 :	  5ba490:       0f 85 7c fa ff ff       jne    5b9f12 <ExecAgg+0x192>
         :	                pfree(DatumGetPointer(oldVal));
    0.00 :	  5ba496:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba499:       e8 e2 e6 1d 00          callq  798b80 <pfree>
    0.00 :	  5ba49e:       e9 6f fa ff ff          jmpq   5b9f12 <ExecAgg+0x192>
         :	                         * and the representative input tuple.
         :	                         */
         :	                        TupleTableSlot *result;
         :	                        ExprDoneCond isDone;
         :
         :	                        result = ExecProject(aggstate->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5ba4a3:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5ba4a7:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5ba4ab:       e8 50 2b ff ff          callq  5ad000 <ExecProject>
         :
         :	                        if (isDone != ExprEndResult)
    0.00 :	  5ba4b0:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5ba4b3:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5ba4b6:       0f 84 f0 fa ff ff       je     5b9fac <ExecAgg+0x22c>
         :	                        {
         :	                                aggstate->ss.ps.ps_TupFromTlist =
    0.00 :	  5ba4bc:       83 ea 01                sub    $0x1,%edx
    0.00 :	  5ba4bf:       41 0f 94 46 70          sete   0x70(%r14)
    0.00 :	  5ba4c4:       e9 ef fa ff ff          jmpq   5b9fb8 <ExecAgg+0x238>
    0.00 :	  5ba4c9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                                outerslot = ExecProcNode(outerPlan);
         :	                                if (TupIsNull(outerslot))
         :	                                {
         :	                                        /* no more outer-plan tuples available */
         :	                                        aggstate->agg_done = true;
    0.00 :	  5ba4d0:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba4d7:       01 
    0.00 :	  5ba4d8:       e9 5f fc ff ff          jmpq   5ba13c <ExecAgg+0x3bc>
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
         :	                {
         :	                        outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba4dd:       48 8b 7d 80             mov    -0x80(%rbp),%rdi
    0.00 :	  5ba4e1:       e8 ba 1f ff ff          callq  5ac4a0 <ExecProcNode>
         :	                        if (!TupIsNull(outerslot))
    0.00 :	  5ba4e6:       48 85 c0                test   %rax,%rax
         :	                 * If we don't already have the first tuple of the new group, fetch it
         :	                 * from the outer plan.
         :	                 */
         :	                if (aggstate->grp_firstTuple == NULL)
         :	                {
         :	                        outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba4e9:       48 89 c7                mov    %rax,%rdi
         :	                        if (!TupIsNull(outerslot))
    0.00 :	  5ba4ec:       74 06                   je     5ba4f4 <ExecAgg+0x774>
    0.00 :	  5ba4ee:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba4f2:       74 1f                   je     5ba513 <ExecAgg+0x793>
         :	                        else
         :	                        {
         :	                                /* outer plan produced no tuples at all */
         :	                                aggstate->agg_done = true;
         :	                                /* If we are grouping, we should produce no tuples too */
         :	                                if (node->aggstrategy != AGG_PLAIN)
    0.00 :	  5ba4f4:       48 8b 85 10 ff ff ff    mov    -0xf0(%rbp),%rax
         :	                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
         :	                        }
         :	                        else
         :	                        {
         :	                                /* outer plan produced no tuples at all */
         :	                                aggstate->agg_done = true;
    0.00 :	  5ba4fb:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba502:       01 
         :	                                /* If we are grouping, we should produce no tuples too */
         :	                                if (node->aggstrategy != AGG_PLAIN)
    0.00 :	  5ba503:       8b 40 60                mov    0x60(%rax),%eax
    0.00 :	  5ba506:       85 c0                   test   %eax,%eax
    0.00 :	  5ba508:       0f 84 2b fb ff ff       je     5ba039 <ExecAgg+0x2b9>
    0.00 :	  5ba50e:       e9 a3 fa ff ff          jmpq   5b9fb6 <ExecAgg+0x236>
         :	                        {
         :	                                /*
         :	                                 * Make a copy of the first input tuple; we will use this for
         :	                                 * comparisons (in group mode) and for projection.
         :	                                 */
         :	                                aggstate->grp_firstTuple = ExecCopySlotTuple(outerslot);
    0.00 :	  5ba513:       e8 98 9a ff ff          callq  5b3fb0 <ExecCopySlotTuple>
    0.00 :	  5ba518:       49 89 86 e0 00 00 00    mov    %rax,0xe0(%r14)
    0.00 :	  5ba51f:       90                      nop
    0.00 :	  5ba520:       e9 14 fb ff ff          jmpq   5ba039 <ExecAgg+0x2b9>
         :	                         * and the representative input tuple.
         :	                         */
         :	                        TupleTableSlot *result;
         :	                        ExprDoneCond isDone;
         :
         :	                        result = ExecProject(aggstate->ss.ps.ps_ProjInfo, &isDone);
    0.00 :	  5ba525:       49 8b 7e 68             mov    0x68(%r14),%rdi
    0.00 :	  5ba529:       48 8d 75 d4             lea    -0x2c(%rbp),%rsi
    0.00 :	  5ba52d:       e8 ce 2a ff ff          callq  5ad000 <ExecProject>
         :
         :	                        if (isDone != ExprEndResult)
    0.00 :	  5ba532:       8b 55 d4                mov    -0x2c(%rbp),%edx
    0.00 :	  5ba535:       83 fa 02                cmp    $0x2,%edx
    0.00 :	  5ba538:       0f 84 ba f9 ff ff       je     5b9ef8 <ExecAgg+0x178>
    0.00 :	  5ba53e:       e9 79 ff ff ff          jmpq   5ba4bc <ExecAgg+0x73c>
         :	                 */
         :	                entry = (AggHashEntry) ScanTupleHashTable(&aggstate->hashiter);
         :	                if (entry == NULL)
         :	                {
         :	                        /* No more entries in hashtable, so done */
         :	                        aggstate->agg_done = TRUE;
    0.00 :	  5ba543:       41 c6 86 d0 00 00 00    movb   $0x1,0xd0(%r14)
    0.00 :	  5ba54a:       01 
    0.00 :	  5ba54b:       31 c0                   xor    %eax,%eax
    0.00 :	  5ba54d:       e9 66 fa ff ff          jmpq   5b9fb8 <ExecAgg+0x238>
         :	        TupleTableSlot *outerslot;
         :
         :	        /*
         :	         * get state info from node
         :	         */
         :	        outerPlan = outerPlanState(aggstate);
    0.00 :	  5ba552:       4d 8b 6e 30             mov    0x30(%r14),%r13
         :	        /* tmpcontext is the per-input-tuple expression context */
         :	        tmpcontext = aggstate->tmpcontext;
    0.00 :	  5ba556:       4d 8b be c0 00 00 00    mov    0xc0(%r14),%r15
         :	         * Process each outer-plan tuple, and then fetch the next one, until we
         :	         * exhaust the outer plan.
         :	         */
         :	        for (;;)
         :	        {
         :	                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba55d:       4c 89 ef                mov    %r13,%rdi
    0.00 :	  5ba560:       e8 3b 1f ff ff          callq  5ac4a0 <ExecProcNode>
         :	                if (TupIsNull(outerslot))
    0.00 :	  5ba565:       48 85 c0                test   %rax,%rax
         :	         * Process each outer-plan tuple, and then fetch the next one, until we
         :	         * exhaust the outer plan.
         :	         */
         :	        for (;;)
         :	        {
         :	                outerslot = ExecProcNode(outerPlan);
    0.00 :	  5ba568:       48 89 c3                mov    %rax,%rbx
         :	                if (TupIsNull(outerslot))
    0.00 :	  5ba56b:       0f 84 db 00 00 00       je     5ba64c <ExecAgg+0x8cc>
    0.00 :	  5ba571:       80 78 04 00             cmpb   $0x0,0x4(%rax)
    0.00 :	  5ba575:       0f 85 d1 00 00 00       jne    5ba64c <ExecAgg+0x8cc>
         :	                        break;
         :	                /* set up for advance_aggregates call */
         :	                tmpcontext->ecxt_outertuple = outerslot;
    0.00 :	  5ba57b:       49 89 47 18             mov    %rax,0x18(%r15)
         :	 * When called, CurrentMemoryContext should be the per-query context.
         :	 */
         :	static AggHashEntry
         :	lookup_hash_entry(AggState *aggstate, TupleTableSlot *inputslot)
         :	{
         :	        TupleTableSlot *hashslot = aggstate->hashslot;
    0.00 :	  5ba57f:       4d 8b a6 f0 00 00 00    mov    0xf0(%r14),%r12
         :	        ListCell   *l;
         :	        AggHashEntry entry;
         :	        bool            isnew;
         :
         :	        /* if first time through, initialize hashslot by cloning input slot */
         :	        if (hashslot->tts_tupleDescriptor == NULL)
    0.00 :	  5ba586:       49 83 7c 24 10 00       cmpq   $0x0,0x10(%r12)
    0.00 :	  5ba58c:       75 14                   jne    5ba5a2 <ExecAgg+0x822>
         :	        {
         :	                ExecSetSlotDescriptor(hashslot, inputslot->tts_tupleDescriptor);
    0.00 :	  5ba58e:       48 8b 70 10             mov    0x10(%rax),%rsi
    0.00 :	  5ba592:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ba595:       e8 16 a0 ff ff          callq  5b45b0 <ExecSetSlotDescriptor>
         :	                /* Make sure all unused columns are NULLs */
         :	                ExecStoreAllNullTuple(hashslot);
    0.00 :	  5ba59a:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  5ba59d:       e8 1e 9d ff ff          callq  5b42c0 <ExecStoreAllNullTuple>
         :	        }
         :
         :	        /* transfer just the needed columns into hashslot */
         :	        slot_getsomeattrs(inputslot, linitial_int(aggstate->hash_needed));
    0.00 :	  5ba5a2:       49 8b 96 f8 00 00 00    mov    0xf8(%r14),%rdx
         :	#endif   /* PG_USE_INLINE */
         :	#if defined(PG_USE_INLINE) || defined(PG_LIST_INCLUDE_DEFINITIONS)
         :	STATIC_IF_INLINE ListCell *
         :	list_head(const List *l)
         :	{
         :	        return l ? l->head : NULL;
    0.00 :	  5ba5a9:       31 c0                   xor    %eax,%eax
    0.00 :	  5ba5ab:       48 85 d2                test   %rdx,%rdx
    0.00 :	  5ba5ae:       74 04                   je     5ba5b4 <ExecAgg+0x834>
    0.00 :	  5ba5b0:       48 8b 42 08             mov    0x8(%rdx),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeAgg.c:1043
  100.00 :	  5ba5b4:       8b 30                   mov    (%rax),%esi
    0.00 :	  5ba5b6:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5ba5b9:       e8 a2 4c eb ff          callq  46f260 <slot_getsomeattrs>
         :	        foreach(l, aggstate->hash_needed)
    0.00 :	  5ba5be:       49 8b 86 f8 00 00 00    mov    0xf8(%r14),%rax
    0.00 :	  5ba5c5:       48 85 c0                test   %rax,%rax
    0.00 :	  5ba5c8:       74 3a                   je     5ba604 <ExecAgg+0x884>
    0.00 :	  5ba5ca:       48 8b 70 08             mov    0x8(%rax),%rsi
    0.00 :	  5ba5ce:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5ba5d1:       74 31                   je     5ba604 <ExecAgg+0x884>
         :	        {
         :	                int                     varNumber = lfirst_int(l) - 1;
         :
         :	                hashslot->tts_values[varNumber] = inputslot->tts_values[varNumber];
    0.00 :	  5ba5d3:       8b 06                   mov    (%rsi),%eax
    0.00 :	  5ba5d5:       48 8b 53 28             mov    0x28(%rbx),%rdx
    0.00 :	  5ba5d9:       49 8b 4c 24 28          mov    0x28(%r12),%rcx
    0.00 :	  5ba5de:       83 e8 01                sub    $0x1,%eax
    0.00 :	  5ba5e1:       48 98                   cltq   
    0.00 :	  5ba5e3:       48 8b 14 c2             mov    (%rdx,%rax,8),%rdx
    0.00 :	  5ba5e7:       48 89 14 c1             mov    %rdx,(%rcx,%rax,8)
         :	                hashslot->tts_isnull[varNumber] = inputslot->tts_isnull[varNumber];
    0.00 :	  5ba5eb:       48 8b 53 30             mov    0x30(%rbx),%rdx
    0.00 :	  5ba5ef:       49 8b 4c 24 30          mov    0x30(%r12),%rcx
    0.00 :	  5ba5f4:       0f b6 14 02             movzbl (%rdx,%rax,1),%edx
    0.00 :	  5ba5f8:       88 14 01                mov    %dl,(%rcx,%rax,1)
         :	                ExecStoreAllNullTuple(hashslot);
         :	        }
         :
         :	        /* transfer just the needed columns into hashslot */
         :	        slot_getsomeattrs(inputslot, linitial_int(aggstate->hash_needed));
         :	        foreach(l, aggstate->hash_needed)
    0.00 :	  5ba5fb:       48 8b 76 08             mov    0x8(%rsi),%rsi
    0.00 :	  5ba5ff:       48 85 f6                test   %rsi,%rsi
    0.00 :	  5ba602:       75 cf                   jne    5ba5d3 <ExecAgg+0x853>
         :	                hashslot->tts_values[varNumber] = inputslot->tts_values[varNumber];
         :	                hashslot->tts_isnull[varNumber] = inputslot->tts_isnull[varNumber];
         :	        }
         :
         :	        /* find or create the hashtable entry using the filtered tuple */
         :	        entry = (AggHashEntry) LookupTupleHashEntry(aggstate->hashtable,
    0.00 :	  5ba604:       49 8b be e8 00 00 00    mov    0xe8(%r14),%rdi
    0.00 :	  5ba60b:       48 8d 55 d4             lea    -0x2c(%rbp),%rdx
    0.00 :	  5ba60f:       4c 89 e6                mov    %r12,%rsi
    0.00 :	  5ba612:       e8 59 e8 fe ff          callq  5a8e70 <LookupTupleHashEntry>
         :	                                                                                                hashslot,
         :	                                                                                                &isnew);
         :
         :	        if (isnew)
    0.00 :	  5ba617:       80 7d d4 00             cmpb   $0x0,-0x2c(%rbp)
    0.00 :	  5ba61b:       48 8d 58 08             lea    0x8(%rax),%rbx
    0.00 :	  5ba61f:       74 12                   je     5ba633 <ExecAgg+0x8b3>
         :	        {
         :	                /* initialize aggregates for new tuple group */
         :	                initialize_aggregates(aggstate, aggstate->peragg, entry->pergroup);
    0.00 :	  5ba621:       49 8b b6 b0 00 00 00    mov    0xb0(%r14),%rsi
    0.00 :	  5ba628:       48 89 da                mov    %rbx,%rdx
    0.00 :	  5ba62b:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba62e:       e8 9d ef ff ff          callq  5b95d0 <initialize_aggregates>
         :
         :	                /* Find or build hashtable entry for this tuple's group */
         :	                entry = lookup_hash_entry(aggstate, outerslot);
         :
         :	                /* Advance the aggregates */
         :	                advance_aggregates(aggstate, entry->pergroup);
    0.00 :	  5ba633:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  5ba636:       48 89 de                mov    %rbx,%rsi
    0.00 :	  5ba639:       e8 12 f3 ff ff          callq  5b9950 <advance_aggregates>
         :
         :	                /* Reset per-input-tuple context after each tuple */
         :	                ResetExprContext(tmpcontext);
    0.00 :	  5ba63e:       49 8b 7f 28             mov    0x28(%r15),%rdi
    0.00 :	  5ba642:       e8 69 e3 1d 00          callq  7989b0 <MemoryContextReset>
    0.00 :	  5ba647:       e9 11 ff ff ff          jmpq   5ba55d <ExecAgg+0x7dd>
         :	        }
         :
         :	        aggstate->table_filled = true;
         :	        /* Initialize to walk the hash table */
         :	        ResetTupleHashIterator(aggstate->hashtable, &aggstate->hashiter);
    0.00 :	  5ba64c:       49 8b 86 e8 00 00 00    mov    0xe8(%r14),%rax
         :
         :	                /* Reset per-input-tuple context after each tuple */
         :	                ResetExprContext(tmpcontext);
         :	        }
         :
         :	        aggstate->table_filled = true;
    0.00 :	  5ba653:       41 c6 86 00 01 00 00    movb   $0x1,0x100(%r14)
    0.00 :	  5ba65a:       01 
         :	        /* Initialize to walk the hash table */
         :	        ResetTupleHashIterator(aggstate->hashtable, &aggstate->hashiter);
    0.00 :	  5ba65b:       4d 8d be 08 01 00 00    lea    0x108(%r14),%r15
    0.00 :	  5ba662:       48 8b 38                mov    (%rax),%rdi
    0.00 :	  5ba665:       e8 f6 92 1c 00          callq  783960 <hash_freeze>
    0.00 :	  5ba66a:       49 8b 86 e8 00 00 00    mov    0xe8(%r14),%rax
    0.00 :	  5ba671:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5ba674:       48 8b 30                mov    (%rax),%rsi
    0.00 :	  5ba677:       e8 b4 97 1c 00          callq  783e30 <hash_seq_init>
    0.00 :	  5ba67c:       41 0f b6 86 d0 00 00    movzbl 0xd0(%r14),%eax
    0.00 :	  5ba683:       00 
    0.00 :	  5ba684:       e9 6c f7 ff ff          jmpq   5b9df5 <ExecAgg+0x75>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:856
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005bc410 <ExecHashTableInsert>:
         :	 */
         :	void
         :	ExecHashTableInsert(HashJoinTable hashtable,
         :	                                        TupleTableSlot *slot,
         :	                                        uint32 hashvalue)
         :	{
    0.00 :	  5bc410:       55                      push   %rbp
    0.00 :	  5bc411:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5bc414:       48 89 5d d8             mov    %rbx,-0x28(%rbp)
    0.00 :	  5bc418:       4c 89 6d e8             mov    %r13,-0x18(%rbp)
    0.00 :	  5bc41c:       49 89 fd                mov    %rdi,%r13
    0.00 :	  5bc41f:       4c 89 7d f8             mov    %r15,-0x8(%rbp)
    0.00 :	  5bc423:       4c 89 65 e0             mov    %r12,-0x20(%rbp)
    0.00 :	  5bc427:       48 89 f7                mov    %rsi,%rdi
    0.00 :	  5bc42a:       4c 89 75 f0             mov    %r14,-0x10(%rbp)
    0.00 :	  5bc42e:       48 83 ec 40             sub    $0x40,%rsp
    0.00 :	  5bc432:       89 d3                   mov    %edx,%ebx
         :	        MinimalTuple tuple = ExecFetchSlotMinimalTuple(slot);
    0.00 :	  5bc434:       e8 17 7b ff ff          callq  5b3f50 <ExecFetchSlotMinimalTuple>
    0.00 :	  5bc439:       49 89 c7                mov    %rax,%r15
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
    0.00 :	  5bc43c:       41 8b 45 40             mov    0x40(%r13),%eax
         :	ExecHashGetBucketAndBatch(HashJoinTable hashtable,
         :	                                                  uint32 hashvalue,
         :	                                                  int *bucketno,
         :	                                                  int *batchno)
         :	{
         :	        uint32          nbuckets = (uint32) hashtable->nbuckets;
    0.00 :	  5bc440:       41 8b 55 00             mov    0x0(%r13),%edx
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
    0.00 :	  5bc444:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  5bc447:       0f 86 0b 01 00 00       jbe    5bc558 <ExecHashTableInsert+0x148>
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc44d:       41 8b 4d 04             mov    0x4(%r13),%ecx
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc451:       44 8d 72 ff             lea    -0x1(%rdx),%r14d
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc455:       89 da                   mov    %ebx,%edx
    0.00 :	  5bc457:       83 e8 01                sub    $0x1,%eax
         :	        uint32          nbatch = (uint32) hashtable->nbatch;
         :
         :	        if (nbatch > 1)
         :	        {
         :	                /* we can do MOD by masking, DIV by shifting */
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc45a:       41 21 de                and    %ebx,%r14d
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
    0.00 :	  5bc45d:       d3 ea                   shr    %cl,%edx
    0.00 :	  5bc45f:       21 c2                   and    %eax,%edx
         :	                                                          &bucketno, &batchno);
         :
         :	        /*
         :	         * decide whether to put the tuple in the hash table or a temp file
         :	         */
         :	        if (batchno == hashtable->curbatch)
    0.00 :	  5bc461:       41 39 55 44             cmp    %edx,0x44(%r13)
    0.00 :	  5bc465:       74 31                   je     5bc498 <ExecHashTableInsert+0x88>
         :	        {
         :	                /*
         :	                 * put the tuple into a temp file for later batches
         :	                 */
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
    0.00 :	  5bc467:       48 63 d2                movslq %edx,%rdx
    0.00 :	  5bc46a:       89 de                   mov    %ebx,%esi
    0.00 :	  5bc46c:       4c 89 ff                mov    %r15,%rdi
    0.00 :	  5bc46f:       48 c1 e2 03             shl    $0x3,%rdx
    0.00 :	  5bc473:       49 03 55 68             add    0x68(%r13),%rdx
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc477:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc47b:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc47f:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc483:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc487:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc48b:       c9                      leaveq 
         :	        {
         :	                /*
         :	                 * put the tuple into a temp file for later batches
         :	                 */
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
    0.00 :	  5bc48c:       e9 cf 10 00 00          jmpq   5bd560 <ExecHashJoinSaveTuple>
    0.00 :	  5bc491:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * put the tuple in hash table
         :	                 */
         :	                HashJoinTuple hashTuple;
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
    0.00 :	  5bc498:       f2 41 0f 10 45 58       movsd  0x58(%r13),%xmm0
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc49e:       4c 89 ef                mov    %r13,%rdi
         :	                /*
         :	                 * put the tuple in hash table
         :	                 */
         :	                HashJoinTuple hashTuple;
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
    0.00 :	  5bc4a1:       f2 0f 11 45 c0          movsd  %xmm0,-0x40(%rbp)
    0.00 :	  5bc4a6:       f2 41 0f 10 4d 60       movsd  0x60(%r13),%xmm1
    0.00 :	  5bc4ac:       f2 0f 11 4d c8          movsd  %xmm1,-0x38(%rbp)
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc4b1:       41 8b 07                mov    (%r15),%eax
    0.00 :	  5bc4b4:       83 c0 10                add    $0x10,%eax
    0.00 :	  5bc4b7:       48 98                   cltq   
    0.00 :	  5bc4b9:       48 89 c6                mov    %rax,%rsi
    0.00 :	  5bc4bc:       48 89 45 d0             mov    %rax,-0x30(%rbp)
    0.00 :	  5bc4c0:       e8 fb fa ff ff          callq  5bbfc0 <dense_alloc>
         :
         :	                hashTuple->hashvalue = hashvalue;
    0.00 :	  5bc4c5:       89 58 08                mov    %ebx,0x8(%rax)
         :	                memcpy(HJTUPLE_MINTUPLE(hashTuple), tuple, tuple->t_len);
 /home/Computational/mark/src/postgres-andres/src/backend/executor/nodeHash.c:856
  100.00 :	  5bc4c8:       41 8b 17                mov    (%r15),%edx
    0.00 :	  5bc4cb:       48 8d 58 10             lea    0x10(%rax),%rbx
    0.00 :	  5bc4cf:       4c 89 fe                mov    %r15,%rsi
         :	                int                     hashTupleSize;
         :	                double          ntuples = (hashtable->totalTuples - hashtable->skewTuples);
         :
         :	                /* Create the HashJoinTuple */
         :	                hashTupleSize = HJTUPLE_OVERHEAD + tuple->t_len;
         :	                hashTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize);
    0.00 :	  5bc4d2:       49 89 c4                mov    %rax,%r12
         :
         :	                hashTuple->hashvalue = hashvalue;
         :	                memcpy(HJTUPLE_MINTUPLE(hashTuple), tuple, tuple->t_len);
    0.00 :	  5bc4d5:       48 89 df                mov    %rbx,%rdi
    0.00 :	  5bc4d8:       e8 13 d7 ea ff          callq  469bf0 <memcpy@plt>
         :	                 * We always reset the tuple-matched flag on insertion.  This is okay
         :	                 * even when reloading a tuple from a batch file, since the tuple
         :	                 * could not possibly have been matched to an outer tuple before it
         :	                 * went into the batch file.
         :	                 */
         :	                HeapTupleHeaderClearMatch(HJTUPLE_MINTUPLE(hashTuple));
    0.00 :	  5bc4dd:       66 81 63 0a ff 7f       andw   $0x7fff,0xa(%rbx)
         :
         :	                /* Push it onto the front of the bucket's list */
         :	                hashTuple->next = hashtable->buckets[bucketno];
    0.00 :	  5bc4e3:       49 63 d6                movslq %r14d,%rdx
    0.00 :	  5bc4e6:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  5bc4ea:       48 8b 04 d0             mov    (%rax,%rdx,8),%rax
    0.00 :	  5bc4ee:       49 89 04 24             mov    %rax,(%r12)
         :	                hashtable->buckets[bucketno] = hashTuple;
    0.00 :	  5bc4f2:       49 8b 45 18             mov    0x18(%r13),%rax
    0.00 :	  5bc4f6:       4c 89 24 d0             mov    %r12,(%rax,%rdx,8)
         :
         :	                /*
         :	                 * Increase the (optimal) number of buckets if we just exceeded the
         :	                 * NTUP_PER_BUCKET threshold, but only when there's still a single batch.
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
    0.00 :	  5bc4fa:       41 83 7d 40 01          cmpl   $0x1,0x40(%r13)
    0.00 :	  5bc4ff:       74 7f                   je     5bc580 <ExecHashTableInsert+0x170>
    0.00 :	  5bc501:       41 8b 55 0c             mov    0xc(%r13),%edx
         :	                        hashtable->nbuckets_optimal *= 2;
         :	                        hashtable->log2_nbuckets_optimal += 1;
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
    0.00 :	  5bc505:       48 8b 45 d0             mov    -0x30(%rbp),%rax
    0.00 :	  5bc509:       49 03 85 90 00 00 00    add    0x90(%r13),%rax
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
    0.00 :	  5bc510:       49 3b 85 a0 00 00 00    cmp    0xa0(%r13),%rax
         :	                        hashtable->nbuckets_optimal *= 2;
         :	                        hashtable->log2_nbuckets_optimal += 1;
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
    0.00 :	  5bc517:       49 89 85 90 00 00 00    mov    %rax,0x90(%r13)
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
    0.00 :	  5bc51e:       77 50                   ja     5bc570 <ExecHashTableInsert+0x160>
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
    0.00 :	  5bc520:       48 63 c2                movslq %edx,%rax
    0.00 :	  5bc523:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  5bc527:       49 03 85 90 00 00 00    add    0x90(%r13),%rax
    0.00 :	  5bc52e:       49 3b 85 98 00 00 00    cmp    0x98(%r13),%rax
    0.00 :	  5bc535:       0f 87 8d 00 00 00       ja     5bc5c8 <ExecHashTableInsert+0x1b8>
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc53b:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc53f:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc543:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc547:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc54b:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc54f:       c9                      leaveq 
    0.00 :	  5bc550:       c3                      retq   
    0.00 :	  5bc551:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                *bucketno = hashvalue & (nbuckets - 1);
         :	                *batchno = (hashvalue >> hashtable->log2_nbuckets) & (nbatch - 1);
         :	        }
         :	        else
         :	        {
         :	                *bucketno = hashvalue & (nbuckets - 1);
    0.00 :	  5bc558:       44 8d 72 ff             lea    -0x1(%rdx),%r14d
    0.00 :	  5bc55c:       31 d2                   xor    %edx,%edx
    0.00 :	  5bc55e:       41 21 de                and    %ebx,%r14d
    0.00 :	  5bc561:       e9 fb fe ff ff          jmpq   5bc461 <ExecHashTableInsert+0x51>
    0.00 :	  5bc566:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  5bc56d:       00 00 00 
         :	                }
         :
         :	                /* Account for space used, and back off if we've used too much */
         :	                hashtable->spaceUsed += hashTupleSize;
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
    0.00 :	  5bc570:       49 89 85 a0 00 00 00    mov    %rax,0xa0(%r13)
    0.00 :	  5bc577:       eb a7                   jmp    5bc520 <ExecHashTableInsert+0x110>
    0.00 :	  5bc579:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :
         :	                /*
         :	                 * Increase the (optimal) number of buckets if we just exceeded the
         :	                 * NTUP_PER_BUCKET threshold, but only when there's still a single batch.
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
    0.00 :	  5bc580:       41 8b 55 0c             mov    0xc(%r13),%edx
    0.00 :	  5bc584:       81 fa ff ff ff 3f       cmp    $0x3fffffff,%edx
    0.00 :	  5bc58a:       0f 8f 75 ff ff ff       jg     5bc505 <ExecHashTableInsert+0xf5>
    0.00 :	  5bc590:       f2 0f 10 45 c0          movsd  -0x40(%rbp),%xmm0
    0.00 :	  5bc595:       f2 0f 5c 45 c8          subsd  -0x38(%rbp),%xmm0
    0.00 :	  5bc59a:       f2 0f 11 45 c0          movsd  %xmm0,-0x40(%rbp)
    0.00 :	  5bc59f:       f2 0f 2a c2             cvtsi2sd %edx,%xmm0
    0.00 :	  5bc5a3:       f2 0f 10 4d c0          movsd  -0x40(%rbp),%xmm1
    0.00 :	  5bc5a8:       66 0f 2e c8             ucomisd %xmm0,%xmm1
    0.00 :	  5bc5ac:       0f 82 53 ff ff ff       jb     5bc505 <ExecHashTableInsert+0xf5>
         :	                        (hashtable->nbuckets_optimal <= INT_MAX/2) &&   /* overflow protection */
         :	                        (ntuples >= (hashtable->nbuckets_optimal * NTUP_PER_BUCKET)))
         :	                {
         :	                        hashtable->nbuckets_optimal *= 2;
    0.00 :	  5bc5b2:       8d 04 12                lea    (%rdx,%rdx,1),%eax
         :	                        hashtable->log2_nbuckets_optimal += 1;
    0.00 :	  5bc5b5:       41 83 45 10 01          addl   $0x1,0x10(%r13)
         :	                 */
         :	                if ((hashtable->nbatch == 1) &&
         :	                        (hashtable->nbuckets_optimal <= INT_MAX/2) &&   /* overflow protection */
         :	                        (ntuples >= (hashtable->nbuckets_optimal * NTUP_PER_BUCKET)))
         :	                {
         :	                        hashtable->nbuckets_optimal *= 2;
    0.00 :	  5bc5ba:       41 89 45 0c             mov    %eax,0xc(%r13)
    0.00 :	  5bc5be:       89 c2                   mov    %eax,%edx
    0.00 :	  5bc5c0:       e9 40 ff ff ff          jmpq   5bc505 <ExecHashTableInsert+0xf5>
    0.00 :	  5bc5c5:       0f 1f 00                nopl   (%rax)
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
         :	                        hashtable->nbuckets_optimal * sizeof(HashJoinTuple)
         :	                        > hashtable->spaceAllowed)
         :	                        ExecHashIncreaseNumBatches(hashtable);
    0.00 :	  5bc5c8:       4c 89 ef                mov    %r13,%rdi
         :	                Assert(batchno > hashtable->curbatch);
         :	                ExecHashJoinSaveTuple(tuple,
         :	                                                          hashvalue,
         :	                                                          &hashtable->innerBatchFile[batchno]);
         :	        }
         :	}
    0.00 :	  5bc5cb:       48 8b 5d d8             mov    -0x28(%rbp),%rbx
    0.00 :	  5bc5cf:       4c 8b 65 e0             mov    -0x20(%rbp),%r12
    0.00 :	  5bc5d3:       4c 8b 6d e8             mov    -0x18(%rbp),%r13
    0.00 :	  5bc5d7:       4c 8b 75 f0             mov    -0x10(%rbp),%r14
    0.00 :	  5bc5db:       4c 8b 7d f8             mov    -0x8(%rbp),%r15
    0.00 :	  5bc5df:       c9                      leaveq 
         :	                if (hashtable->spaceUsed > hashtable->spacePeak)
         :	                        hashtable->spacePeak = hashtable->spaceUsed;
         :	                if (hashtable->spaceUsed +
         :	                        hashtable->nbuckets_optimal * sizeof(HashJoinTuple)
         :	                        > hashtable->spaceAllowed)
         :	                        ExecHashIncreaseNumBatches(hashtable);
    0.00 :	  5bc5e0:       e9 fb fa ff ff          jmpq   5bc0e0 <ExecHashIncreaseNumBatches>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/nodes/bitmapset.c:179
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000005e2f70 <bms_make_singleton>:
         :	/*
         :	 * bms_make_singleton - build a bitmapset containing a single member
         :	 */
         :	Bitmapset *
         :	bms_make_singleton(int x)
         :	{
    0.00 :	  5e2f70:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/nodes/bitmapset.c:179
  100.00 :	  5e2f71:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  5e2f74:       4c 89 6d f8             mov    %r13,-0x8(%rbp)
    0.00 :	  5e2f78:       48 89 5d e8             mov    %rbx,-0x18(%rbp)
    0.00 :	  5e2f7c:       41 89 fd                mov    %edi,%r13d
    0.00 :	  5e2f7f:       4c 89 65 f0             mov    %r12,-0x10(%rbp)
    0.00 :	  5e2f83:       48 83 ec 20             sub    $0x20,%rsp
         :	        Bitmapset  *result;
         :	        int                     wordnum,
         :	                                bitnum;
         :
         :	        if (x < 0)
    0.00 :	  5e2f87:       85 ff                   test   %edi,%edi
    0.00 :	  5e2f89:       78 3f                   js     5e2fca <bms_make_singleton+0x5a>
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        wordnum = WORDNUM(x);
    0.00 :	  5e2f8b:       89 fb                   mov    %edi,%ebx
         :	        bitnum = BITNUM(x);
         :	        result = (Bitmapset *) palloc0(BITMAPSET_SIZE(wordnum + 1));
         :	        result->nwords = wordnum + 1;
         :	        result->words[wordnum] = ((bitmapword) 1 << bitnum);
    0.00 :	  5e2f8d:       41 83 e5 1f             and    $0x1f,%r13d
         :	        int                     wordnum,
         :	                                bitnum;
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        wordnum = WORDNUM(x);
    0.00 :	  5e2f91:       c1 fb 05                sar    $0x5,%ebx
         :	        bitnum = BITNUM(x);
         :	        result = (Bitmapset *) palloc0(BITMAPSET_SIZE(wordnum + 1));
    0.00 :	  5e2f94:       44 8d 63 01             lea    0x1(%rbx),%r12d
         :	        result->nwords = wordnum + 1;
         :	        result->words[wordnum] = ((bitmapword) 1 << bitnum);
    0.00 :	  5e2f98:       48 63 db                movslq %ebx,%rbx
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        wordnum = WORDNUM(x);
         :	        bitnum = BITNUM(x);
         :	        result = (Bitmapset *) palloc0(BITMAPSET_SIZE(wordnum + 1));
    0.00 :	  5e2f9b:       49 63 fc                movslq %r12d,%rdi
    0.00 :	  5e2f9e:       48 8d 3c bd 04 00 00    lea    0x4(,%rdi,4),%rdi
    0.00 :	  5e2fa5:       00 
    0.00 :	  5e2fa6:       e8 c5 5f 1b 00          callq  798f70 <palloc0>
         :	        result->nwords = wordnum + 1;
         :	        result->words[wordnum] = ((bitmapword) 1 << bitnum);
    0.00 :	  5e2fab:       44 89 e9                mov    %r13d,%ecx
    0.00 :	  5e2fae:       ba 01 00 00 00          mov    $0x1,%edx
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
         :	        wordnum = WORDNUM(x);
         :	        bitnum = BITNUM(x);
         :	        result = (Bitmapset *) palloc0(BITMAPSET_SIZE(wordnum + 1));
         :	        result->nwords = wordnum + 1;
    0.00 :	  5e2fb3:       44 89 20                mov    %r12d,(%rax)
         :	        result->words[wordnum] = ((bitmapword) 1 << bitnum);
    0.00 :	  5e2fb6:       d3 e2                   shl    %cl,%edx
    0.00 :	  5e2fb8:       89 54 98 04             mov    %edx,0x4(%rax,%rbx,4)
         :	        return result;
         :	}
    0.00 :	  5e2fbc:       48 8b 5d e8             mov    -0x18(%rbp),%rbx
    0.00 :	  5e2fc0:       4c 8b 65 f0             mov    -0x10(%rbp),%r12
    0.00 :	  5e2fc4:       4c 8b 6d f8             mov    -0x8(%rbp),%r13
    0.00 :	  5e2fc8:       c9                      leaveq 
    0.00 :	  5e2fc9:       c3                      retq   
         :	        Bitmapset  *result;
         :	        int                     wordnum,
         :	                                bitnum;
         :
         :	        if (x < 0)
         :	                elog(ERROR, "negative bitmapset member not allowed");
    0.00 :	  5e2fca:       ba b0 24 89 00          mov    $0x8924b0,%edx
    0.00 :	  5e2fcf:       be b9 00 00 00          mov    $0xb9,%esi
    0.00 :	  5e2fd4:       bf e2 21 89 00          mov    $0x8921e2,%edi
    0.00 :	  5e2fd9:       e8 42 84 19 00          callq  77b420 <elog_start>
    0.00 :	  5e2fde:       be 08 22 89 00          mov    $0x892208,%esi
    0.00 :	  5e2fe3:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  5e2fe8:       31 c0                   xor    %eax,%eax
    0.00 :	  5e2fea:       e8 41 82 19 00          callq  77b230 <elog_finish>
    0.00 :	  5e2fef:       e8 dc 64 e8 ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:5014
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000643b20 <PgstatCollectorMain>:
         :	 *      The argc/argv parameters are valid only in EXEC_BACKEND case.
         :	 * ----------
         :	 */
         :	NON_EXEC_STATIC void
         :	PgstatCollectorMain(int argc, char *argv[])
         :	{
    0.00 :	  643b20:       55                      push   %rbp
    0.00 :	  643b21:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  643b24:       41 57                   push   %r15
    0.00 :	  643b26:       41 56                   push   %r14
    0.00 :	  643b28:       41 55                   push   %r13
    0.00 :	  643b2a:       41 54                   push   %r12
    0.00 :	  643b2c:       53                      push   %rbx
    0.00 :	  643b2d:       48 81 ec 18 08 00 00    sub    $0x818,%rsp
         :	        int                     len;
         :	        PgStat_Msg      msg;
         :	        int                     wr;
         :
         :	        IsUnderPostmaster = true;       /* we are a postmaster subprocess now */
    0.00 :	  643b34:       c6 05 82 65 57 00 01    movb   $0x1,0x576582(%rip)        # bba0bd <IsUnderPostmaster>
         :
         :	        MyProcPid = getpid();           /* reset MyProcPid */
    0.00 :	  643b3b:       e8 10 5c e2 ff          callq  469750 <getpid@plt>
         :
         :	        MyStartTime = time(NULL);       /* record Start Time for logging */
    0.00 :	  643b40:       31 ff                   xor    %edi,%edi
         :	        PgStat_Msg      msg;
         :	        int                     wr;
         :
         :	        IsUnderPostmaster = true;       /* we are a postmaster subprocess now */
         :
         :	        MyProcPid = getpid();           /* reset MyProcPid */
    0.00 :	  643b42:       89 05 9c c1 57 00       mov    %eax,0x57c19c(%rip)        # bbfce4 <MyProcPid>
         :
         :	        MyStartTime = time(NULL);       /* record Start Time for logging */
    0.00 :	  643b48:       e8 53 66 e2 ff          callq  46a1a0 <time@plt>
    0.00 :	  643b4d:       48 89 05 b4 c9 57 00    mov    %rax,0x57c9b4(%rip)        # bc0508 <MyStartTime>
         :	         * can signal any child processes too.  (pgstat probably never has any
         :	         * child processes, but for consistency we make all postmaster child
         :	         * processes do this.)
         :	         */
         :	#ifdef HAVE_SETSID
         :	        if (setsid() < 0)
    0.00 :	  643b54:       e8 07 59 e2 ff          callq  469460 <setsid@plt>
    0.00 :	  643b59:       85 c0                   test   %eax,%eax
    0.00 :	  643b5b:       0f 88 56 0d 00 00       js     6448b7 <PgstatCollectorMain+0xd97>
         :	                elog(FATAL, "setsid() failed: %m");
         :	#endif
         :
         :	        InitializeLatchSupport();       /* needed for latch waits */
    0.00 :	  643b61:       e8 fa 59 ff ff          callq  639560 <InitializeLatchSupport>
         :
         :	        /* Initialize private latch for use by signal handlers */
         :	        InitLatch(&pgStatLatch);
    0.00 :	  643b66:       bf 58 bd b7 00          mov    $0xb7bd58,%edi
         :	                         */
         :	#ifdef WIN32
         :	                        pgwin32_noblock = 1;
         :	#endif
         :
         :	                        len = recv(pgStatSock, (char *) &msg,
    0.00 :	  643b6b:       4c 8d ad e0 fb ff ff    lea    -0x420(%rbp),%r13
         :	#endif
         :
         :	        InitializeLatchSupport();       /* needed for latch waits */
         :
         :	        /* Initialize private latch for use by signal handlers */
         :	        InitLatch(&pgStatLatch);
    0.00 :	  643b72:       e8 79 54 ff ff          callq  638ff0 <InitLatch>
         :	        /*
         :	         * Ignore all signals usually bound to some action in the postmaster,
         :	         * except SIGHUP and SIGQUIT.  Note we don't need a SIGUSR1 handler to
         :	         * support latch operations, because pgStatLatch is local not shared.
         :	         */
         :	        pqsignal(SIGHUP, pgstat_sighup_handler);
    0.00 :	  643b77:       be e0 49 64 00          mov    $0x6449e0,%esi
    0.00 :	  643b7c:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  643b81:       e8 7a 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGINT, SIG_IGN);
    0.00 :	  643b86:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643b8b:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	  643b90:       e8 6b 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGTERM, SIG_IGN);
    0.00 :	  643b95:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643b9a:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  643b9f:       e8 5c 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGQUIT, pgstat_exit);
    0.00 :	  643ba4:       be a0 49 64 00          mov    $0x6449a0,%esi
    0.00 :	  643ba9:       bf 03 00 00 00          mov    $0x3,%edi
    0.00 :	  643bae:       e8 4d 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGALRM, SIG_IGN);
    0.00 :	  643bb3:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643bb8:       bf 0e 00 00 00          mov    $0xe,%edi
    0.00 :	  643bbd:       e8 3e 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGPIPE, SIG_IGN);
    0.00 :	  643bc2:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643bc7:       bf 0d 00 00 00          mov    $0xd,%edi
    0.00 :	  643bcc:       e8 2f 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGUSR1, SIG_IGN);
    0.00 :	  643bd1:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643bd6:       bf 0a 00 00 00          mov    $0xa,%edi
    0.00 :	  643bdb:       e8 20 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGUSR2, SIG_IGN);
    0.00 :	  643be0:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643be5:       bf 0c 00 00 00          mov    $0xc,%edi
    0.00 :	  643bea:       e8 11 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGCHLD, SIG_DFL);
    0.00 :	  643bef:       31 f6                   xor    %esi,%esi
    0.00 :	  643bf1:       bf 11 00 00 00          mov    $0x11,%edi
    0.00 :	  643bf6:       e8 05 8f 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGTTIN, SIG_DFL);
    0.00 :	  643bfb:       31 f6                   xor    %esi,%esi
    0.00 :	  643bfd:       bf 15 00 00 00          mov    $0x15,%edi
    0.00 :	  643c02:       e8 f9 8e 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGTTOU, SIG_DFL);
    0.00 :	  643c07:       31 f6                   xor    %esi,%esi
    0.00 :	  643c09:       bf 16 00 00 00          mov    $0x16,%edi
    0.00 :	  643c0e:       e8 ed 8e 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGCONT, SIG_DFL);
    0.00 :	  643c13:       31 f6                   xor    %esi,%esi
    0.00 :	  643c15:       bf 12 00 00 00          mov    $0x12,%edi
    0.00 :	  643c1a:       e8 e1 8e 16 00          callq  7acb00 <pqsignal>
         :	        pqsignal(SIGWINCH, SIG_DFL);
    0.00 :	  643c1f:       31 f6                   xor    %esi,%esi
    0.00 :	  643c21:       bf 1c 00 00 00          mov    $0x1c,%edi
    0.00 :	  643c26:       e8 d5 8e 16 00          callq  7acb00 <pqsignal>
         :	        PG_SETMASK(&UnBlockSig);
    0.00 :	  643c2b:       31 d2                   xor    %edx,%edx
    0.00 :	  643c2d:       be 40 f8 bb 00          mov    $0xbbf840,%esi
    0.00 :	  643c32:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	  643c37:       e8 84 5e e2 ff          callq  469ac0 <sigprocmask@plt>
         :
         :	        /*
         :	         * Identify myself via ps
         :	         */
         :	        init_ps_display("stats collector process", "", "", "");
    0.00 :	  643c3c:       b9 96 16 8e 00          mov    $0x8e1696,%ecx
    0.00 :	  643c41:       bf 7d f0 89 00          mov    $0x89f07d,%edi
    0.00 :	  643c46:       48 89 ca                mov    %rcx,%rdx
    0.00 :	  643c49:       48 89 ce                mov    %rcx,%rsi
    0.00 :	  643c4c:       e8 8f 20 15 00          callq  795ce0 <init_ps_display>
         :	        /*
         :	         * Read in an existing statistics stats file or initialize the stats to
         :	         * zero.
         :	         */
         :	        pgStatRunningInCollector = true;
         :	        pgStatDBHash = pgstat_read_statsfiles(InvalidOid, true, true);
    0.00 :	  643c51:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  643c56:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643c5b:       31 ff                   xor    %edi,%edi
         :
         :	        /*
         :	         * Read in an existing statistics stats file or initialize the stats to
         :	         * zero.
         :	         */
         :	        pgStatRunningInCollector = true;
    0.00 :	  643c5d:       c6 05 24 80 53 00 01    movb   $0x1,0x538024(%rip)        # b7bc88 <pgStatRunningInCollector>
         :	        pgStatDBHash = pgstat_read_statsfiles(InvalidOid, true, true);
    0.00 :	  643c64:       e8 97 d4 ff ff          callq  641100 <pgstat_read_statsfiles>
         :	        }
         :	        else
         :	        {
         :	                /* Successful archival operation */
         :	                ++archiverStats.archived_count;
         :	                memcpy(archiverStats.last_archived_wal, msg->m_xlog,
    0.00 :	  643c69:       49 8d 55 09             lea    0x9(%r13),%rdx
         :	        /*
         :	         * Read in an existing statistics stats file or initialize the stats to
         :	         * zero.
         :	         */
         :	        pgStatRunningInCollector = true;
         :	        pgStatDBHash = pgstat_read_statsfiles(InvalidOid, true, true);
    0.00 :	  643c6d:       48 89 05 64 7f 53 00    mov    %rax,0x537f64(%rip)        # b7bbd8 <pgStatDBHash>
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
    0.00 :	  643c74:       49 8d 45 10             lea    0x10(%r13),%rax
         :	        }
         :	        else
         :	        {
         :	                /* Successful archival operation */
         :	                ++archiverStats.archived_count;
         :	                memcpy(archiverStats.last_archived_wal, msg->m_xlog,
    0.00 :	  643c78:       48 89 95 c8 f7 ff ff    mov    %rdx,-0x838(%rbp)
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
    0.00 :	  643c7f:       48 89 85 d0 f7 ff ff    mov    %rax,-0x830(%rbp)
    0.00 :	  643c86:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  643c8d:       00 00 00 
         :	         * action.
         :	         */
         :	        for (;;)
         :	        {
         :	                /* Clear any already-pending wakeups */
         :	                ResetLatch(&pgStatLatch);
    0.00 :	  643c90:       bf 58 bd b7 00          mov    $0xb7bd58,%edi
    0.00 :	  643c95:       e8 a6 53 ff ff          callq  639040 <ResetLatch>
         :
         :	                /*
         :	                 * Quit if we get SIGQUIT from the postmaster.
         :	                 */
         :	                if (need_exit)
    0.00 :	  643c9a:       0f b6 05 a7 80 53 00    movzbl 0x5380a7(%rip),%eax        # b7bd48 <need_exit>
    0.00 :	  643ca1:       84 c0                   test   %al,%al
    0.00 :	  643ca3:       74 40                   je     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  643ca5:       e9 aa 00 00 00          jmpq   643d54 <PgstatCollectorMain+0x234>
    0.00 :	  643caa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	 * ----------
         :	 */
         :	static bool
         :	pgstat_write_statsfile_needed(void)
         :	{
         :	        if (!slist_is_empty(&last_statrequests))
    0.00 :	  643cb0:       48 83 3d 98 80 53 00    cmpq   $0x0,0x538098(%rip)        # b7bd50 <last_statrequests>
    0.00 :	  643cb7:       00 
    0.00 :	  643cb8:       74 09                   je     643cc3 <PgstatCollectorMain+0x1a3>
         :	                        /*
         :	                         * Write the stats file if a new request has arrived that is not
         :	                         * satisfied by existing file.
         :	                         */
         :	                        if (pgstat_write_statsfile_needed())
         :	                                pgstat_write_statsfiles(false, false);
    0.00 :	  643cba:       31 f6                   xor    %esi,%esi
    0.00 :	  643cbc:       31 ff                   xor    %edi,%edi
    0.00 :	  643cbe:       e8 1d fb ff ff          callq  6437e0 <pgstat_write_statsfiles>
         :	                         */
         :	#ifdef WIN32
         :	                        pgwin32_noblock = 1;
         :	#endif
         :
         :	                        len = recv(pgStatSock, (char *) &msg,
    0.00 :	  643cc3:       8b 3d 47 49 52 00       mov    0x524947(%rip),%edi        # b68610 <pgStatSock>
    0.00 :	  643cc9:       31 c9                   xor    %ecx,%ecx
    0.00 :	  643ccb:       ba e8 03 00 00          mov    $0x3e8,%edx
    0.00 :	  643cd0:       4c 89 ee                mov    %r13,%rsi
    0.00 :	  643cd3:       e8 88 59 e2 ff          callq  469660 <recv@plt>
         :
         :	#ifdef WIN32
         :	                        pgwin32_noblock = 0;
         :	#endif
         :
         :	                        if (len < 0)
    0.00 :	  643cd8:       85 c0                   test   %eax,%eax
    0.00 :	  643cda:       0f 88 90 00 00 00       js     643d70 <PgstatCollectorMain+0x250>
         :	                        }
         :
         :	                        /*
         :	                         * We ignore messages that are smaller than our common header
         :	                         */
         :	                        if (len < sizeof(PgStat_MsgHdr))
    0.00 :	  643ce0:       83 f8 07                cmp    $0x7,%eax
    0.00 :	  643ce3:       77 2b                   ja     643d10 <PgstatCollectorMain+0x1f0>
         :
         :	                /*
         :	                 * Inner loop iterates as long as we keep getting messages, or until
         :	                 * need_exit becomes set.
         :	                 */
         :	                while (!need_exit)
    0.00 :	  643ce5:       0f b6 05 5c 80 53 00    movzbl 0x53805c(%rip),%eax        # b7bd48 <need_exit>
    0.00 :	  643cec:       84 c0                   test   %al,%al
    0.00 :	  643cee:       75 40                   jne    643d30 <PgstatCollectorMain+0x210>
         :	                {
         :	                        /*
         :	                         * Reload configuration if we got SIGHUP from the postmaster.
         :	                         */
         :	                        if (got_SIGHUP)
    0.00 :	  643cf0:       0f b6 05 52 80 53 00    movzbl 0x538052(%rip),%eax        # b7bd49 <got_SIGHUP>
    0.00 :	  643cf7:       84 c0                   test   %al,%al
    0.00 :	  643cf9:       74 b5                   je     643cb0 <PgstatCollectorMain+0x190>
         :	                        {
         :	                                got_SIGHUP = false;
         :	                                ProcessConfigFile(PGC_SIGHUP);
    0.00 :	  643cfb:       bf 02 00 00 00          mov    $0x2,%edi
         :	                        /*
         :	                         * Reload configuration if we got SIGHUP from the postmaster.
         :	                         */
         :	                        if (got_SIGHUP)
         :	                        {
         :	                                got_SIGHUP = false;
    0.00 :	  643d00:       c6 05 42 80 53 00 00    movb   $0x0,0x538042(%rip)        # b7bd49 <got_SIGHUP>
         :	                                ProcessConfigFile(PGC_SIGHUP);
    0.00 :	  643d07:       e8 f4 0a 15 00          callq  794800 <ProcessConfigFile>
    0.00 :	  643d0c:       eb a2                   jmp    643cb0 <PgstatCollectorMain+0x190>
    0.00 :	  643d0e:       66 90                   xchg   %ax,%ax
         :	                                continue;
         :
         :	                        /*
         :	                         * The received length must match the length in the header
         :	                         */
         :	                        if (msg.msg_hdr.m_size != len)
    0.00 :	  643d10:       39 85 e4 fb ff ff       cmp    %eax,-0x41c(%rbp)
    0.00 :	  643d16:       75 cd                   jne    643ce5 <PgstatCollectorMain+0x1c5>
         :	                                continue;
         :
         :	                        /*
         :	                         * O.K. - we accept this message.  Process it.
         :	                         */
         :	                        switch (msg.msg_hdr.m_type)
    0.00 :	  643d18:       83 bd e0 fb ff ff 11    cmpl   $0x11,-0x420(%rbp)
    0.00 :	  643d1f:       77 c4                   ja     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  643d21:       8b 85 e0 fb ff ff       mov    -0x420(%rbp),%eax
    0.00 :	  643d27:       ff 24 c5 80 f7 89 00    jmpq   *0x89f780(,%rax,8)
    0.00 :	  643d2e:       66 90                   xchg   %ax,%ax
         :	                        }
         :	                }                                               /* end of inner message-processing loop */
         :
         :	                /* Sleep until there's something to do */
         :	#ifndef WIN32
         :	                wr = WaitLatchOrSocket(&pgStatLatch,
    0.00 :	  643d30:       8b 15 da 48 52 00       mov    0x5248da(%rip),%edx        # b68610 <pgStatSock>
    0.00 :	  643d36:       48 c7 c1 ff ff ff ff    mov    $0xffffffffffffffff,%rcx
    0.00 :	  643d3d:       be 13 00 00 00          mov    $0x13,%esi
    0.00 :	  643d42:       bf 58 bd b7 00          mov    $0xb7bd58,%edi
    0.00 :	  643d47:       e8 04 54 ff ff          callq  639150 <WaitLatchOrSocket>
         :
         :	                /*
         :	                 * Emergency bailout if postmaster has died.  This is to avoid the
         :	                 * necessity for manual cleanup of all postmaster children.
         :	                 */
         :	                if (wr & WL_POSTMASTER_DEATH)
    0.00 :	  643d4c:       a8 10                   test   $0x10,%al
    0.00 :	  643d4e:       0f 84 3c ff ff ff       je     643c90 <PgstatCollectorMain+0x170>
         :	        }                                                       /* end of outer loop */
         :
         :	        /*
         :	         * Save the final stats to reuse at next startup.
         :	         */
         :	        pgstat_write_statsfiles(true, true);
    0.00 :	  643d54:       bf 01 00 00 00          mov    $0x1,%edi
    0.00 :	  643d59:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643d5e:       e8 7d fa ff ff          callq  6437e0 <pgstat_write_statsfiles>
         :
         :	        exit(0);
    0.00 :	  643d63:       31 ff                   xor    %edi,%edi
    0.00 :	  643d65:       e8 26 58 e2 ff          callq  469590 <exit@plt>
    0.00 :	  643d6a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	                        pgwin32_noblock = 0;
         :	#endif
         :
         :	                        if (len < 0)
         :	                        {
         :	                                if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
    0.00 :	  643d70:       e8 4b 5f e2 ff          callq  469cc0 <__errno_location@plt>
    0.00 :	  643d75:       8b 00                   mov    (%rax),%eax
    0.00 :	  643d77:       83 f8 0b                cmp    $0xb,%eax
    0.00 :	  643d7a:       74 b4                   je     643d30 <PgstatCollectorMain+0x210>
    0.00 :	  643d7c:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  643d7f:       90                      nop
    0.00 :	  643d80:       74 ae                   je     643d30 <PgstatCollectorMain+0x210>
         :	                                        break;          /* out of inner loop */
         :	                                ereport(ERROR,
    0.00 :	  643d82:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  643d85:       b9 60 f9 89 00          mov    $0x89f960,%ecx
    0.00 :	  643d8a:       ba d0 0c 00 00          mov    $0xcd0,%edx
    0.00 :	  643d8f:       be 88 ef 89 00          mov    $0x89ef88,%esi
    0.00 :	  643d94:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  643d99:       e8 22 6d 13 00          callq  77aac0 <errstart>
    0.00 :	  643d9e:       84 c0                   test   %al,%al
    0.00 :	  643da0:       0f 85 af 0a 00 00       jne    644855 <PgstatCollectorMain+0xd35>
         :	                        hash_destroy(dbentry->functions);
         :
         :	                if (hash_search(pgStatDBHash,
         :	                                                (void *) &dbid,
         :	                                                HASH_REMOVE, NULL) == NULL)
         :	                        ereport(ERROR,
    0.00 :	  643da6:       e8 25 57 e2 ff          callq  4694d0 <abort@plt>
         :	static void
         :	pgstat_recv_deadlock(PgStat_MsgDeadlock *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  643dab:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  643db1:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643db6:       e8 55 d1 ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        dbentry->n_deadlocks++;
    0.00 :	  643dbb:       48 83 80 90 00 00 00    addq   $0x1,0x90(%rax)
    0.00 :	  643dc2:       01 
         :	                                        pgstat_recv_recoveryconflict((PgStat_MsgRecoveryConflict *) &msg, len);
         :	                                        break;
         :
         :	                                case PGSTAT_MTYPE_DEADLOCK:
         :	                                        pgstat_recv_deadlock((PgStat_MsgDeadlock *) &msg, len);
         :	                                        break;
    0.00 :	  643dc3:       e9 1d ff ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	{
         :	        slist_iter      iter;
         :	        DBWriteRequest *newreq;
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        elog(DEBUG2, "received inquiry for %d", msg->databaseid);
    0.00 :	  643dc8:       ba 80 f9 89 00          mov    $0x89f980,%edx
    0.00 :	  643dcd:       be bf 11 00 00          mov    $0x11bf,%esi
    0.00 :	  643dd2:       bf 88 ef 89 00          mov    $0x89ef88,%edi
    0.00 :	  643dd7:       e8 44 76 13 00          callq  77b420 <elog_start>
    0.00 :	  643ddc:       8b 95 f8 fb ff ff       mov    -0x408(%rbp),%edx
    0.00 :	  643de2:       31 c0                   xor    %eax,%eax
    0.00 :	  643de4:       be 95 f0 89 00          mov    $0x89f095,%esi
    0.00 :	  643de9:       bf 0d 00 00 00          mov    $0xd,%edi
    0.00 :	  643dee:       e8 3d 74 13 00          callq  77b230 <elog_finish>
         :	         * Note that if a request is found, we return early and skip the below
         :	         * check for clock skew.  This is okay, since the only way for a DB
         :	         * request to be present in the list is that we have been here since the
         :	         * last write round.
         :	         */
         :	        slist_foreach(iter, &last_statrequests)
    0.00 :	  643df3:       48 8b 05 56 7f 53 00    mov    0x537f56(%rip),%rax        # b7bd50 <last_statrequests>
    0.00 :	  643dfa:       48 85 c0                test   %rax,%rax
    0.00 :	  643dfd:       74 2e                   je     643e2d <PgstatCollectorMain+0x30d>
         :	        {
         :	                DBWriteRequest *req = slist_container(DBWriteRequest, next, iter.cur);
         :
         :	                if (req->databaseid != msg->databaseid)
    0.00 :	  643dff:       8b 8d f8 fb ff ff       mov    -0x408(%rbp),%ecx
    0.00 :	  643e05:       39 48 f0                cmp    %ecx,-0x10(%rax)
         :	         * request to be present in the list is that we have been here since the
         :	         * last write round.
         :	         */
         :	        slist_foreach(iter, &last_statrequests)
         :	        {
         :	                DBWriteRequest *req = slist_container(DBWriteRequest, next, iter.cur);
    0.00 :	  643e08:       48 8d 50 f0             lea    -0x10(%rax),%rdx
         :
         :	                if (req->databaseid != msg->databaseid)
    0.00 :	  643e0c:       75 17                   jne    643e25 <PgstatCollectorMain+0x305>
    0.00 :	  643e0e:       e9 5f 09 00 00          jmpq   644772 <PgstatCollectorMain+0xc52>
    0.00 :	  643e13:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  643e18:       39 48 f0                cmp    %ecx,-0x10(%rax)
         :	         * request to be present in the list is that we have been here since the
         :	         * last write round.
         :	         */
         :	        slist_foreach(iter, &last_statrequests)
         :	        {
         :	                DBWriteRequest *req = slist_container(DBWriteRequest, next, iter.cur);
    0.00 :	  643e1b:       48 8d 50 f0             lea    -0x10(%rax),%rdx
         :
         :	                if (req->databaseid != msg->databaseid)
    0.00 :	  643e1f:       0f 84 4d 09 00 00       je     644772 <PgstatCollectorMain+0xc52>
         :	         * Note that if a request is found, we return early and skip the below
         :	         * check for clock skew.  This is okay, since the only way for a DB
         :	         * request to be present in the list is that we have been here since the
         :	         * last write round.
         :	         */
         :	        slist_foreach(iter, &last_statrequests)
    0.00 :	  643e25:       48 8b 00                mov    (%rax),%rax
    0.00 :	  643e28:       48 85 c0                test   %rax,%rax
    0.00 :	  643e2b:       75 eb                   jne    643e18 <PgstatCollectorMain+0x2f8>
         :	        }
         :
         :	        /*
         :	         * There's no request for this DB yet, so create one.
         :	         */
         :	        newreq = palloc(sizeof(DBWriteRequest));
    0.00 :	  643e2d:       bf 18 00 00 00          mov    $0x18,%edi
    0.00 :	  643e32:       e8 19 4f 15 00          callq  798d50 <palloc>
    0.00 :	  643e37:       48 89 85 d8 f7 ff ff    mov    %rax,-0x828(%rbp)
         :
         :	        newreq->databaseid = msg->databaseid;
    0.00 :	  643e3e:       8b 85 f8 fb ff ff       mov    -0x408(%rbp),%eax
         :	         * the more likely explanation is just delayed message receipt.  It is
         :	         * worth expending a GetCurrentTimestamp call to be sure, since a large
         :	         * retreat in the system clock reading could otherwise cause us to neglect
         :	         * to update the stats file for a long time.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->databaseid, false);
    0.00 :	  643e44:       31 f6                   xor    %esi,%esi
         :	        /*
         :	         * There's no request for this DB yet, so create one.
         :	         */
         :	        newreq = palloc(sizeof(DBWriteRequest));
         :
         :	        newreq->databaseid = msg->databaseid;
    0.00 :	  643e46:       48 8b 95 d8 f7 ff ff    mov    -0x828(%rbp),%rdx
    0.00 :	  643e4d:       89 02                   mov    %eax,(%rdx)
         :	        newreq->request_time = msg->clock_time;
    0.00 :	  643e4f:       48 8b 85 e8 fb ff ff    mov    -0x418(%rbp),%rax
    0.00 :	  643e56:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	 * Insert a node at the beginning of the list.
         :	 */
         :	STATIC_IF_INLINE void
         :	slist_push_head(slist_head *head, slist_node *node)
         :	{
         :	        node->next = head->head.next;
    0.00 :	  643e5a:       48 8b 05 ef 7e 53 00    mov    0x537eef(%rip),%rax        # b7bd50 <last_statrequests>
    0.00 :	  643e61:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	         * the more likely explanation is just delayed message receipt.  It is
         :	         * worth expending a GetCurrentTimestamp call to be sure, since a large
         :	         * retreat in the system clock reading could otherwise cause us to neglect
         :	         * to update the stats file for a long time.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->databaseid, false);
    0.00 :	  643e65:       8b bd f8 fb ff ff       mov    -0x408(%rbp),%edi
         :	        head->head.next = node;
    0.00 :	  643e6b:       48 89 d0                mov    %rdx,%rax
    0.00 :	  643e6e:       48 83 c0 10             add    $0x10,%rax
    0.00 :	  643e72:       48 89 05 d7 7e 53 00    mov    %rax,0x537ed7(%rip)        # b7bd50 <last_statrequests>
    0.00 :	  643e79:       e8 92 d0 ff ff          callq  640f10 <pgstat_get_db_entry>
         :	        if ((dbentry != NULL) && (msg->clock_time < dbentry->stats_timestamp))
    0.00 :	  643e7e:       48 85 c0                test   %rax,%rax
         :	         * the more likely explanation is just delayed message receipt.  It is
         :	         * worth expending a GetCurrentTimestamp call to be sure, since a large
         :	         * retreat in the system clock reading could otherwise cause us to neglect
         :	         * to update the stats file for a long time.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->databaseid, false);
    0.00 :	  643e81:       49 89 c6                mov    %rax,%r14
         :	        if ((dbentry != NULL) && (msg->clock_time < dbentry->stats_timestamp))
    0.00 :	  643e84:       0f 84 5b fe ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  643e8a:       48 8b 80 b0 00 00 00    mov    0xb0(%rax),%rax
    0.00 :	  643e91:       48 39 85 e8 fb ff ff    cmp    %rax,-0x418(%rbp)
    0.00 :	  643e98:       0f 8d 47 fe ff ff       jge    643ce5 <PgstatCollectorMain+0x1c5>
         :	        {
         :	                TimestampTz cur_ts = GetCurrentTimestamp();
    0.00 :	  643e9e:       e8 cd 24 10 00          callq  746370 <GetCurrentTimestamp>
         :
         :	                if (cur_ts < dbentry->stats_timestamp)
    0.00 :	  643ea3:       49 8b be b0 00 00 00    mov    0xb0(%r14),%rdi
         :	         * to update the stats file for a long time.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->databaseid, false);
         :	        if ((dbentry != NULL) && (msg->clock_time < dbentry->stats_timestamp))
         :	        {
         :	                TimestampTz cur_ts = GetCurrentTimestamp();
    0.00 :	  643eaa:       49 89 c7                mov    %rax,%r15
         :
         :	                if (cur_ts < dbentry->stats_timestamp)
    0.00 :	  643ead:       48 39 f8                cmp    %rdi,%rax
    0.00 :	  643eb0:       0f 8d 2f fe ff ff       jge    643ce5 <PgstatCollectorMain+0x1c5>
         :	                         */
         :	                        char       *writetime;
         :	                        char       *mytime;
         :
         :	                        /* Copy because timestamptz_to_str returns a static buffer */
         :	                        writetime = pstrdup(timestamptz_to_str(dbentry->stats_timestamp));
    0.00 :	  643eb6:       e8 f5 23 10 00          callq  7462b0 <timestamptz_to_str>
    0.00 :	  643ebb:       48 89 c7                mov    %rax,%rdi
    0.00 :	  643ebe:       e8 8d 50 15 00          callq  798f50 <pstrdup>
         :	                        mytime = pstrdup(timestamptz_to_str(cur_ts));
    0.00 :	  643ec3:       4c 89 ff                mov    %r15,%rdi
         :	                         */
         :	                        char       *writetime;
         :	                        char       *mytime;
         :
         :	                        /* Copy because timestamptz_to_str returns a static buffer */
         :	                        writetime = pstrdup(timestamptz_to_str(dbentry->stats_timestamp));
    0.00 :	  643ec6:       49 89 c4                mov    %rax,%r12
         :	                        mytime = pstrdup(timestamptz_to_str(cur_ts));
    0.00 :	  643ec9:       e8 e2 23 10 00          callq  7462b0 <timestamptz_to_str>
    0.00 :	  643ece:       48 89 c7                mov    %rax,%rdi
    0.00 :	  643ed1:       e8 7a 50 15 00          callq  798f50 <pstrdup>
         :	                        elog(LOG,
    0.00 :	  643ed6:       ba 80 f9 89 00          mov    $0x89f980,%edx
    0.00 :	  643edb:       be fa 11 00 00          mov    $0x11fa,%esi
    0.00 :	  643ee0:       bf 88 ef 89 00          mov    $0x89ef88,%edi
         :	                        char       *writetime;
         :	                        char       *mytime;
         :
         :	                        /* Copy because timestamptz_to_str returns a static buffer */
         :	                        writetime = pstrdup(timestamptz_to_str(dbentry->stats_timestamp));
         :	                        mytime = pstrdup(timestamptz_to_str(cur_ts));
    0.00 :	  643ee5:       48 89 c3                mov    %rax,%rbx
         :	                        elog(LOG,
    0.00 :	  643ee8:       e8 33 75 13 00          callq  77b420 <elog_start>
    0.00 :	  643eed:       45 8b 06                mov    (%r14),%r8d
    0.00 :	  643ef0:       4c 89 e2                mov    %r12,%rdx
    0.00 :	  643ef3:       31 c0                   xor    %eax,%eax
    0.00 :	  643ef5:       48 89 d9                mov    %rbx,%rcx
    0.00 :	  643ef8:       be c0 f3 89 00          mov    $0x89f3c0,%esi
    0.00 :	  643efd:       bf 0f 00 00 00          mov    $0xf,%edi
    0.00 :	  643f02:       e8 29 73 13 00          callq  77b230 <elog_finish>
         :	                        "stats_timestamp %s is later than collector's time %s for db %d",
         :	                                 writetime, mytime, dbentry->databaseid);
         :	                        pfree(writetime);
    0.00 :	  643f07:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  643f0a:       e8 71 4c 15 00          callq  798b80 <pfree>
         :	                        pfree(mytime);
    0.00 :	  643f0f:       48 89 df                mov    %rbx,%rdi
    0.00 :	  643f12:       e8 69 4c 15 00          callq  798b80 <pfree>
         :
         :	                        newreq->request_time = cur_ts;
    0.00 :	  643f17:       48 8b 95 d8 f7 ff ff    mov    -0x828(%rbp),%rdx
         :	                        dbentry->stats_timestamp = cur_ts - 1;
    0.00 :	  643f1e:       49 8d 47 ff             lea    -0x1(%r15),%rax
         :	                        "stats_timestamp %s is later than collector's time %s for db %d",
         :	                                 writetime, mytime, dbentry->databaseid);
         :	                        pfree(writetime);
         :	                        pfree(mytime);
         :
         :	                        newreq->request_time = cur_ts;
    0.00 :	  643f22:       4c 89 7a 08             mov    %r15,0x8(%rdx)
         :	                        dbentry->stats_timestamp = cur_ts - 1;
    0.00 :	  643f26:       49 89 86 b0 00 00 00    mov    %rax,0xb0(%r14)
    0.00 :	  643f2d:       e9 b3 fd ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        PgStat_StatDBEntry *dbentry;
         :	        PgStat_StatTabEntry *tabentry;
         :	        int                     i;
         :	        bool            found;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  643f32:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  643f38:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  643f3d:       e8 ce cf ff ff          callq  640f10 <pgstat_get_db_entry>
    0.00 :	  643f42:       49 89 c4                mov    %rax,%r12
         :
         :	        /*
         :	         * Update database-wide stats.
         :	         */
         :	        dbentry->n_xact_commit += (PgStat_Counter) (msg->m_xact_commit);
    0.00 :	  643f45:       48 63 85 f0 fb ff ff    movslq -0x410(%rbp),%rax
    0.00 :	  643f4c:       49 01 44 24 08          add    %rax,0x8(%r12)
         :	        dbentry->n_xact_rollback += (PgStat_Counter) (msg->m_xact_rollback);
    0.00 :	  643f51:       48 63 85 f4 fb ff ff    movslq -0x40c(%rbp),%rax
    0.00 :	  643f58:       49 01 44 24 10          add    %rax,0x10(%r12)
         :	        dbentry->n_block_read_time += msg->m_block_read_time;
    0.00 :	  643f5d:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
    0.00 :	  643f64:       49 01 84 24 98 00 00    add    %rax,0x98(%r12)
    0.00 :	  643f6b:       00 
         :	        dbentry->n_block_write_time += msg->m_block_write_time;
    0.00 :	  643f6c:       48 8b 85 00 fc ff ff    mov    -0x400(%rbp),%rax
    0.00 :	  643f73:       49 01 84 24 a0 00 00    add    %rax,0xa0(%r12)
    0.00 :	  643f7a:       00 
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  643f7b:       44 8b 9d ec fb ff ff    mov    -0x414(%rbp),%r11d
    0.00 :	  643f82:       45 85 db                test   %r11d,%r11d
    0.00 :	  643f85:       0f 8e 5a fd ff ff       jle    643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  643f8b:       45 31 ff                xor    %r15d,%r15d
    0.00 :	  643f8e:       e9 7d 01 00 00          jmpq   644110 <PgstatCollectorMain+0x5f0>
         :	                {
         :	                        /*
         :	                         * If it's a new table entry, initialize counters to the values we
         :	                         * just got.
         :	                         */
         :	                        tabentry->numscans = tabmsg->t_counts.t_numscans;
    0.00 :	  643f93:       48 8b 84 1d 10 fc ff    mov    -0x3f0(%rbp,%rbx,1),%rax
    0.00 :	  643f9a:       ff 
    0.00 :	  643f9b:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                        tabentry->tuples_returned = tabmsg->t_counts.t_tuples_returned;
    0.00 :	  643f9f:       48 8b 84 1d 18 fc ff    mov    -0x3e8(%rbp,%rbx,1),%rax
    0.00 :	  643fa6:       ff 
    0.00 :	  643fa7:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	                        tabentry->tuples_fetched = tabmsg->t_counts.t_tuples_fetched;
    0.00 :	  643fab:       48 8b 84 1d 20 fc ff    mov    -0x3e0(%rbp,%rbx,1),%rax
    0.00 :	  643fb2:       ff 
    0.00 :	  643fb3:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	                        tabentry->tuples_inserted = tabmsg->t_counts.t_tuples_inserted;
    0.00 :	  643fb7:       48 8b 84 1d 28 fc ff    mov    -0x3d8(%rbp,%rbx,1),%rax
    0.00 :	  643fbe:       ff 
    0.00 :	  643fbf:       48 89 42 20             mov    %rax,0x20(%rdx)
         :	                        tabentry->tuples_updated = tabmsg->t_counts.t_tuples_updated;
    0.00 :	  643fc3:       48 8b 84 1d 30 fc ff    mov    -0x3d0(%rbp,%rbx,1),%rax
    0.00 :	  643fca:       ff 
    0.00 :	  643fcb:       48 89 42 28             mov    %rax,0x28(%rdx)
         :	                        tabentry->tuples_deleted = tabmsg->t_counts.t_tuples_deleted;
    0.00 :	  643fcf:       48 8b 84 1d 38 fc ff    mov    -0x3c8(%rbp,%rbx,1),%rax
    0.00 :	  643fd6:       ff 
    0.00 :	  643fd7:       48 89 42 30             mov    %rax,0x30(%rdx)
         :	                        tabentry->tuples_hot_updated = tabmsg->t_counts.t_tuples_hot_updated;
    0.00 :	  643fdb:       48 8b 84 1d 40 fc ff    mov    -0x3c0(%rbp,%rbx,1),%rax
    0.00 :	  643fe2:       ff 
    0.00 :	  643fe3:       48 89 42 38             mov    %rax,0x38(%rdx)
         :	                        tabentry->n_live_tuples = tabmsg->t_counts.t_delta_live_tuples;
    0.00 :	  643fe7:       48 8b 84 1d 48 fc ff    mov    -0x3b8(%rbp,%rbx,1),%rax
    0.00 :	  643fee:       ff 
    0.00 :	  643fef:       48 89 42 40             mov    %rax,0x40(%rdx)
         :	                        tabentry->n_dead_tuples = tabmsg->t_counts.t_delta_dead_tuples;
    0.00 :	  643ff3:       48 8b 84 1d 50 fc ff    mov    -0x3b0(%rbp,%rbx,1),%rax
    0.00 :	  643ffa:       ff 
    0.00 :	  643ffb:       48 89 42 48             mov    %rax,0x48(%rdx)
         :	                        tabentry->changes_since_analyze = tabmsg->t_counts.t_changed_tuples;
    0.00 :	  643fff:       48 8b 84 1d 58 fc ff    mov    -0x3a8(%rbp,%rbx,1),%rax
    0.00 :	  644006:       ff 
    0.00 :	  644007:       48 89 42 50             mov    %rax,0x50(%rdx)
         :	                        tabentry->blocks_fetched = tabmsg->t_counts.t_blocks_fetched;
    0.00 :	  64400b:       48 8b 84 1d 60 fc ff    mov    -0x3a0(%rbp,%rbx,1),%rax
    0.00 :	  644012:       ff 
    0.00 :	  644013:       48 89 42 58             mov    %rax,0x58(%rdx)
         :	                        tabentry->blocks_hit = tabmsg->t_counts.t_blocks_hit;
    0.00 :	  644017:       48 8b 84 1d 68 fc ff    mov    -0x398(%rbp,%rbx,1),%rax
    0.00 :	  64401e:       ff 
         :
         :	                        tabentry->vacuum_timestamp = 0;
    0.00 :	  64401f:       48 c7 42 68 00 00 00    movq   $0x0,0x68(%rdx)
    0.00 :	  644026:       00 
         :	                        tabentry->vacuum_count = 0;
    0.00 :	  644027:       48 c7 42 70 00 00 00    movq   $0x0,0x70(%rdx)
    0.00 :	  64402e:       00 
         :	                        tabentry->autovac_vacuum_timestamp = 0;
    0.00 :	  64402f:       48 c7 42 78 00 00 00    movq   $0x0,0x78(%rdx)
    0.00 :	  644036:       00 
         :	                        tabentry->autovac_vacuum_count = 0;
    0.00 :	  644037:       48 c7 82 80 00 00 00    movq   $0x0,0x80(%rdx)
    0.00 :	  64403e:       00 00 00 00 
         :	                        tabentry->tuples_hot_updated = tabmsg->t_counts.t_tuples_hot_updated;
         :	                        tabentry->n_live_tuples = tabmsg->t_counts.t_delta_live_tuples;
         :	                        tabentry->n_dead_tuples = tabmsg->t_counts.t_delta_dead_tuples;
         :	                        tabentry->changes_since_analyze = tabmsg->t_counts.t_changed_tuples;
         :	                        tabentry->blocks_fetched = tabmsg->t_counts.t_blocks_fetched;
         :	                        tabentry->blocks_hit = tabmsg->t_counts.t_blocks_hit;
    0.00 :	  644042:       48 89 42 60             mov    %rax,0x60(%rdx)
         :
         :	                        tabentry->vacuum_timestamp = 0;
         :	                        tabentry->vacuum_count = 0;
         :	                        tabentry->autovac_vacuum_timestamp = 0;
         :	                        tabentry->autovac_vacuum_count = 0;
         :	                        tabentry->analyze_timestamp = 0;
    0.00 :	  644046:       48 c7 82 88 00 00 00    movq   $0x0,0x88(%rdx)
    0.00 :	  64404d:       00 00 00 00 
         :	                        tabentry->analyze_count = 0;
    0.00 :	  644051:       48 c7 82 90 00 00 00    movq   $0x0,0x90(%rdx)
    0.00 :	  644058:       00 00 00 00 
         :	                        tabentry->autovac_analyze_timestamp = 0;
    0.00 :	  64405c:       48 c7 82 98 00 00 00    movq   $0x0,0x98(%rdx)
    0.00 :	  644063:       00 00 00 00 
         :	                        tabentry->autovac_analyze_count = 0;
    0.00 :	  644067:       48 c7 82 a0 00 00 00    movq   $0x0,0xa0(%rdx)
    0.00 :	  64406e:       00 00 00 00 
         :	                        tabentry->blocks_fetched += tabmsg->t_counts.t_blocks_fetched;
         :	                        tabentry->blocks_hit += tabmsg->t_counts.t_blocks_hit;
         :	                }
         :
         :	                /* Clamp n_live_tuples in case of negative delta_live_tuples */
         :	                tabentry->n_live_tuples = Max(tabentry->n_live_tuples, 0);
    0.00 :	  644072:       48 83 7a 40 00          cmpq   $0x0,0x40(%rdx)
    0.00 :	  644077:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  64407c:       48 0f 49 42 40          cmovns 0x40(%rdx),%rax
         :	                /* Likewise for n_dead_tuples */
         :	                tabentry->n_dead_tuples = Max(tabentry->n_dead_tuples, 0);
    0.00 :	  644081:       48 83 7a 48 00          cmpq   $0x0,0x48(%rdx)
         :	                        tabentry->blocks_fetched += tabmsg->t_counts.t_blocks_fetched;
         :	                        tabentry->blocks_hit += tabmsg->t_counts.t_blocks_hit;
         :	                }
         :
         :	                /* Clamp n_live_tuples in case of negative delta_live_tuples */
         :	                tabentry->n_live_tuples = Max(tabentry->n_live_tuples, 0);
    0.00 :	  644086:       48 89 42 40             mov    %rax,0x40(%rdx)
         :	                /* Likewise for n_dead_tuples */
         :	                tabentry->n_dead_tuples = Max(tabentry->n_dead_tuples, 0);
    0.00 :	  64408a:       b8 00 00 00 00          mov    $0x0,%eax
    0.00 :	  64408f:       48 0f 49 42 48          cmovns 0x48(%rdx),%rax
         :	        dbentry->n_block_write_time += msg->m_block_write_time;
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  644094:       41 83 c7 01             add    $0x1,%r15d
         :	                }
         :
         :	                /* Clamp n_live_tuples in case of negative delta_live_tuples */
         :	                tabentry->n_live_tuples = Max(tabentry->n_live_tuples, 0);
         :	                /* Likewise for n_dead_tuples */
         :	                tabentry->n_dead_tuples = Max(tabentry->n_dead_tuples, 0);
    0.00 :	  644098:       48 89 42 48             mov    %rax,0x48(%rdx)
         :
         :	                /*
         :	                 * Add per-table stats to the per-database entry, too.
         :	                 */
         :	                dbentry->n_tuples_returned += tabmsg->t_counts.t_tuples_returned;
    0.00 :	  64409c:       4b 8d 04 76             lea    (%r14,%r14,2),%rax
    0.00 :	  6440a0:       49 8d 04 86             lea    (%r14,%rax,4),%rax
    0.00 :	  6440a4:       48 c1 e0 03             shl    $0x3,%rax
    0.00 :	  6440a8:       48 8b 94 05 18 fc ff    mov    -0x3e8(%rbp,%rax,1),%rdx
    0.00 :	  6440af:       ff 
    0.00 :	  6440b0:       49 01 54 24 28          add    %rdx,0x28(%r12)
         :	                dbentry->n_tuples_fetched += tabmsg->t_counts.t_tuples_fetched;
    0.00 :	  6440b5:       48 8b 94 05 20 fc ff    mov    -0x3e0(%rbp,%rax,1),%rdx
    0.00 :	  6440bc:       ff 
    0.00 :	  6440bd:       49 01 54 24 30          add    %rdx,0x30(%r12)
         :	                dbentry->n_tuples_inserted += tabmsg->t_counts.t_tuples_inserted;
    0.00 :	  6440c2:       48 8b 94 05 28 fc ff    mov    -0x3d8(%rbp,%rax,1),%rdx
    0.00 :	  6440c9:       ff 
    0.00 :	  6440ca:       49 01 54 24 38          add    %rdx,0x38(%r12)
         :	                dbentry->n_tuples_updated += tabmsg->t_counts.t_tuples_updated;
    0.00 :	  6440cf:       48 8b 94 05 30 fc ff    mov    -0x3d0(%rbp,%rax,1),%rdx
    0.00 :	  6440d6:       ff 
    0.00 :	  6440d7:       49 01 54 24 40          add    %rdx,0x40(%r12)
         :	                dbentry->n_tuples_deleted += tabmsg->t_counts.t_tuples_deleted;
    0.00 :	  6440dc:       48 8b 94 05 38 fc ff    mov    -0x3c8(%rbp,%rax,1),%rdx
    0.00 :	  6440e3:       ff 
    0.00 :	  6440e4:       49 01 54 24 48          add    %rdx,0x48(%r12)
         :	                dbentry->n_blocks_fetched += tabmsg->t_counts.t_blocks_fetched;
    0.00 :	  6440e9:       48 8b 94 05 60 fc ff    mov    -0x3a0(%rbp,%rax,1),%rdx
    0.00 :	  6440f0:       ff 
    0.00 :	  6440f1:       49 01 54 24 18          add    %rdx,0x18(%r12)
         :	                dbentry->n_blocks_hit += tabmsg->t_counts.t_blocks_hit;
    0.00 :	  6440f6:       48 8b 84 05 68 fc ff    mov    -0x398(%rbp,%rax,1),%rax
    0.00 :	  6440fd:       ff 
    0.00 :	  6440fe:       49 01 44 24 20          add    %rax,0x20(%r12)
         :	        dbentry->n_block_write_time += msg->m_block_write_time;
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  644103:       44 3b bd ec fb ff ff    cmp    -0x414(%rbp),%r15d
    0.00 :	  64410a:       0f 8d d5 fb ff ff       jge    643ce5 <PgstatCollectorMain+0x1c5>
         :	        {
         :	                PgStat_TableEntry *tabmsg = &(msg->m_entry[i]);
    0.00 :	  644110:       4d 63 f7                movslq %r15d,%r14
         :
         :	                tabentry = (PgStat_StatTabEntry *) hash_search(dbentry->tables,
    0.00 :	  644113:       49 8b bc 24 b8 00 00    mov    0xb8(%r12),%rdi
    0.00 :	  64411a:       00 
    0.00 :	  64411b:       48 8d 4d cc             lea    -0x34(%rbp),%rcx
    0.00 :	  64411f:       4b 8d 04 76             lea    (%r14,%r14,2),%rax
    0.00 :	  644123:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  644128:       49 8d 04 86             lea    (%r14,%rax,4),%rax
    0.00 :	  64412c:       48 8d 1c c5 00 00 00    lea    0x0(,%rax,8),%rbx
    0.00 :	  644133:       00 
    0.00 :	  644134:       49 8d 74 1d 28          lea    0x28(%r13,%rbx,1),%rsi
    0.00 :	  644139:       e8 62 05 14 00          callq  7846a0 <hash_search>
         :	                                                                                                        (void *) &(tabmsg->t_id),
         :	                                                                                                           HASH_ENTER, &found);
         :
         :	                if (!found)
    0.00 :	  64413e:       80 7d cc 00             cmpb   $0x0,-0x34(%rbp)
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
         :	        {
         :	                PgStat_TableEntry *tabmsg = &(msg->m_entry[i]);
         :
         :	                tabentry = (PgStat_StatTabEntry *) hash_search(dbentry->tables,
    0.00 :	  644142:       48 89 c2                mov    %rax,%rdx
         :	                                                                                                        (void *) &(tabmsg->t_id),
         :	                                                                                                           HASH_ENTER, &found);
         :
         :	                if (!found)
    0.00 :	  644145:       0f 84 48 fe ff ff       je     643f93 <PgstatCollectorMain+0x473>
         :	                else
         :	                {
         :	                        /*
         :	                         * Otherwise add the values to the existing entry.
         :	                         */
         :	                        tabentry->numscans += tabmsg->t_counts.t_numscans;
    0.00 :	  64414b:       48 8b 84 1d 10 fc ff    mov    -0x3f0(%rbp,%rbx,1),%rax
    0.00 :	  644152:       ff 
    0.00 :	  644153:       48 01 42 08             add    %rax,0x8(%rdx)
         :	                        tabentry->tuples_returned += tabmsg->t_counts.t_tuples_returned;
    0.00 :	  644157:       48 8b 84 1d 18 fc ff    mov    -0x3e8(%rbp,%rbx,1),%rax
    0.00 :	  64415e:       ff 
    0.00 :	  64415f:       48 01 42 10             add    %rax,0x10(%rdx)
         :	                        tabentry->tuples_fetched += tabmsg->t_counts.t_tuples_fetched;
    0.00 :	  644163:       48 8b 84 1d 20 fc ff    mov    -0x3e0(%rbp,%rbx,1),%rax
    0.00 :	  64416a:       ff 
    0.00 :	  64416b:       48 01 42 18             add    %rax,0x18(%rdx)
         :	                        tabentry->tuples_inserted += tabmsg->t_counts.t_tuples_inserted;
    0.00 :	  64416f:       48 8b 84 1d 28 fc ff    mov    -0x3d8(%rbp,%rbx,1),%rax
    0.00 :	  644176:       ff 
    0.00 :	  644177:       48 01 42 20             add    %rax,0x20(%rdx)
         :	                        tabentry->tuples_updated += tabmsg->t_counts.t_tuples_updated;
    0.00 :	  64417b:       48 8b 84 1d 30 fc ff    mov    -0x3d0(%rbp,%rbx,1),%rax
    0.00 :	  644182:       ff 
    0.00 :	  644183:       48 01 42 28             add    %rax,0x28(%rdx)
         :	                        tabentry->tuples_deleted += tabmsg->t_counts.t_tuples_deleted;
    0.00 :	  644187:       48 8b 84 1d 38 fc ff    mov    -0x3c8(%rbp,%rbx,1),%rax
    0.00 :	  64418e:       ff 
    0.00 :	  64418f:       48 01 42 30             add    %rax,0x30(%rdx)
         :	                        tabentry->tuples_hot_updated += tabmsg->t_counts.t_tuples_hot_updated;
    0.00 :	  644193:       48 8b 84 1d 40 fc ff    mov    -0x3c0(%rbp,%rbx,1),%rax
    0.00 :	  64419a:       ff 
    0.00 :	  64419b:       48 01 42 38             add    %rax,0x38(%rdx)
         :	                        tabentry->n_live_tuples += tabmsg->t_counts.t_delta_live_tuples;
    0.00 :	  64419f:       48 8b 84 1d 48 fc ff    mov    -0x3b8(%rbp,%rbx,1),%rax
    0.00 :	  6441a6:       ff 
    0.00 :	  6441a7:       48 01 42 40             add    %rax,0x40(%rdx)
         :	                        tabentry->n_dead_tuples += tabmsg->t_counts.t_delta_dead_tuples;
    0.00 :	  6441ab:       48 8b 84 1d 50 fc ff    mov    -0x3b0(%rbp,%rbx,1),%rax
    0.00 :	  6441b2:       ff 
    0.00 :	  6441b3:       48 01 42 48             add    %rax,0x48(%rdx)
         :	                        tabentry->changes_since_analyze += tabmsg->t_counts.t_changed_tuples;
    0.00 :	  6441b7:       48 8b 84 1d 58 fc ff    mov    -0x3a8(%rbp,%rbx,1),%rax
    0.00 :	  6441be:       ff 
    0.00 :	  6441bf:       48 01 42 50             add    %rax,0x50(%rdx)
         :	                        tabentry->blocks_fetched += tabmsg->t_counts.t_blocks_fetched;
    0.00 :	  6441c3:       48 8b 84 1d 60 fc ff    mov    -0x3a0(%rbp,%rbx,1),%rax
    0.00 :	  6441ca:       ff 
    0.00 :	  6441cb:       48 01 42 58             add    %rax,0x58(%rdx)
         :	                        tabentry->blocks_hit += tabmsg->t_counts.t_blocks_hit;
    0.00 :	  6441cf:       48 8b 84 1d 68 fc ff    mov    -0x398(%rbp,%rbx,1),%rax
    0.00 :	  6441d6:       ff 
    0.00 :	  6441d7:       48 01 42 60             add    %rax,0x60(%rdx)
    0.00 :	  6441db:       e9 92 fe ff ff          jmpq   644072 <PgstatCollectorMain+0x552>
         :	        PgStat_StatTabEntry *tabentry;
         :
         :	        /*
         :	         * Store the data in the table's hashtable entry.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  6441e0:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  6441e6:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  6441eb:       e8 20 cd ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        tabentry = pgstat_get_tab_entry(dbentry, msg->m_tableoid, true);
    0.00 :	  6441f0:       8b b5 ec fb ff ff       mov    -0x414(%rbp),%esi
    0.00 :	  6441f6:       ba 01 00 00 00          mov    $0x1,%edx
         :	        PgStat_StatTabEntry *tabentry;
         :
         :	        /*
         :	         * Store the data in the table's hashtable entry.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  6441fb:       48 89 c7                mov    %rax,%rdi
         :
         :	        tabentry = pgstat_get_tab_entry(dbentry, msg->m_tableoid, true);
    0.00 :	  6441fe:       e8 6d cd ff ff          callq  640f70 <pgstat_get_tab_entry>
    0.00 :	  644203:       48 89 c2                mov    %rax,%rdx
         :
         :	        tabentry->n_live_tuples = msg->m_live_tuples;
    0.00 :	  644206:       48 8b 85 00 fc ff ff    mov    -0x400(%rbp),%rax
    0.00 :	  64420d:       48 89 42 40             mov    %rax,0x40(%rdx)
         :	        tabentry->n_dead_tuples = msg->m_dead_tuples;
    0.00 :	  644211:       48 8b 85 08 fc ff ff    mov    -0x3f8(%rbp),%rax
    0.00 :	  644218:       48 89 42 48             mov    %rax,0x48(%rdx)
         :
         :	        if (msg->m_autovacuum)
    0.00 :	  64421c:       80 bd f0 fb ff ff 00    cmpb   $0x0,-0x410(%rbp)
    0.00 :	  644223:       0f 84 e0 05 00 00       je     644809 <PgstatCollectorMain+0xce9>
         :	        {
         :	                tabentry->autovac_vacuum_timestamp = msg->m_vacuumtime;
    0.00 :	  644229:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
         :	                tabentry->autovac_vacuum_count++;
    0.00 :	  644230:       48 83 82 80 00 00 00    addq   $0x1,0x80(%rdx)
    0.00 :	  644237:       01 
         :	        tabentry->n_live_tuples = msg->m_live_tuples;
         :	        tabentry->n_dead_tuples = msg->m_dead_tuples;
         :
         :	        if (msg->m_autovacuum)
         :	        {
         :	                tabentry->autovac_vacuum_timestamp = msg->m_vacuumtime;
    0.00 :	  644238:       48 89 42 78             mov    %rax,0x78(%rdx)
    0.00 :	  64423c:       e9 a4 fa ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        PgStat_StatTabEntry *tabentry;
         :
         :	        /*
         :	         * Store the data in the table's hashtable entry.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  644241:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  644247:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  64424c:       e8 bf cc ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        tabentry = pgstat_get_tab_entry(dbentry, msg->m_tableoid, true);
    0.00 :	  644251:       8b b5 ec fb ff ff       mov    -0x414(%rbp),%esi
    0.00 :	  644257:       ba 01 00 00 00          mov    $0x1,%edx
         :	        PgStat_StatTabEntry *tabentry;
         :
         :	        /*
         :	         * Store the data in the table's hashtable entry.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  64425c:       48 89 c7                mov    %rax,%rdi
         :
         :	        tabentry = pgstat_get_tab_entry(dbentry, msg->m_tableoid, true);
    0.00 :	  64425f:       e8 0c cd ff ff          callq  640f70 <pgstat_get_tab_entry>
    0.00 :	  644264:       48 89 c2                mov    %rax,%rdx
         :
         :	        tabentry->n_live_tuples = msg->m_live_tuples;
    0.00 :	  644267:       48 8b 85 00 fc ff ff    mov    -0x400(%rbp),%rax
    0.00 :	  64426e:       48 89 42 40             mov    %rax,0x40(%rdx)
         :	        tabentry->n_dead_tuples = msg->m_dead_tuples;
    0.00 :	  644272:       48 8b 85 08 fc ff ff    mov    -0x3f8(%rbp),%rax
         :
         :	        /*
         :	         * We reset changes_since_analyze to zero, forgetting any changes that
         :	         * occurred while the ANALYZE was in progress.
         :	         */
         :	        tabentry->changes_since_analyze = 0;
    0.00 :	  644279:       48 c7 42 50 00 00 00    movq   $0x0,0x50(%rdx)
    0.00 :	  644280:       00 
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
         :
         :	        tabentry = pgstat_get_tab_entry(dbentry, msg->m_tableoid, true);
         :
         :	        tabentry->n_live_tuples = msg->m_live_tuples;
         :	        tabentry->n_dead_tuples = msg->m_dead_tuples;
    0.00 :	  644281:       48 89 42 48             mov    %rax,0x48(%rdx)
         :	         * We reset changes_since_analyze to zero, forgetting any changes that
         :	         * occurred while the ANALYZE was in progress.
         :	         */
         :	        tabentry->changes_since_analyze = 0;
         :
         :	        if (msg->m_autovacuum)
    0.00 :	  644285:       80 bd f0 fb ff ff 00    cmpb   $0x0,-0x410(%rbp)
    0.00 :	  64428c:       0f 84 5c 05 00 00       je     6447ee <PgstatCollectorMain+0xcce>
         :	        {
         :	                tabentry->autovac_analyze_timestamp = msg->m_analyzetime;
    0.00 :	  644292:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
         :	                tabentry->autovac_analyze_count++;
    0.00 :	  644299:       48 83 82 a0 00 00 00    addq   $0x1,0xa0(%rdx)
    0.00 :	  6442a0:       01 
         :	         */
         :	        tabentry->changes_since_analyze = 0;
         :
         :	        if (msg->m_autovacuum)
         :	        {
         :	                tabentry->autovac_analyze_timestamp = msg->m_analyzetime;
    0.00 :	  6442a1:       48 89 82 98 00 00 00    mov    %rax,0x98(%rdx)
    0.00 :	  6442a8:       e9 38 fa ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Lookup the database in the hashtable.  Nothing to do if not there.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6442ad:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  6442b3:       31 f6                   xor    %esi,%esi
    0.00 :	  6442b5:       e8 56 cc ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        if (!dbentry)
    0.00 :	  6442ba:       48 85 c0                test   %rax,%rax
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Lookup the database in the hashtable.  Nothing to do if not there.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6442bd:       48 89 c3                mov    %rax,%rbx
         :
         :	        if (!dbentry)
    0.00 :	  6442c0:       0f 84 1f fa ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
         :
         :	        /*
         :	         * We simply throw away all the database's table entries by recreating a
         :	         * new hash table for them.
         :	         */
         :	        if (dbentry->tables != NULL)
    0.00 :	  6442c6:       48 8b b8 b8 00 00 00    mov    0xb8(%rax),%rdi
    0.00 :	  6442cd:       48 85 ff                test   %rdi,%rdi
    0.00 :	  6442d0:       74 05                   je     6442d7 <PgstatCollectorMain+0x7b7>
         :	                hash_destroy(dbentry->tables);
    0.00 :	  6442d2:       e8 29 04 14 00          callq  784700 <hash_destroy>
         :	        if (dbentry->functions != NULL)
    0.00 :	  6442d7:       48 8b bb c0 00 00 00    mov    0xc0(%rbx),%rdi
    0.00 :	  6442de:       48 85 ff                test   %rdi,%rdi
    0.00 :	  6442e1:       74 05                   je     6442e8 <PgstatCollectorMain+0x7c8>
         :	                hash_destroy(dbentry->functions);
    0.00 :	  6442e3:       e8 18 04 14 00          callq  784700 <hash_destroy>
         :
         :	        dbentry->tables = NULL;
    0.00 :	  6442e8:       48 c7 83 b8 00 00 00    movq   $0x0,0xb8(%rbx)
    0.00 :	  6442ef:       00 00 00 00 
         :	        dbentry->functions = NULL;
    0.00 :	  6442f3:       48 c7 83 c0 00 00 00    movq   $0x0,0xc0(%rbx)
    0.00 :	  6442fa:       00 00 00 00 
         :
         :	        /*
         :	         * Reset database-level stats, too.  This creates empty hash tables for
         :	         * tables and functions.
         :	         */
         :	        reset_dbentry_counters(dbentry);
    0.00 :	  6442fe:       48 89 df                mov    %rbx,%rdi
    0.00 :	  644301:       e8 7a ca ff ff          callq  640d80 <reset_dbentry_counters>
    0.00 :	  644306:       e9 da f9 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        PgStat_StatDBEntry *dbentry;
         :	        PgStat_StatFuncEntry *funcentry;
         :	        int                     i;
         :	        bool            found;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  64430b:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  644311:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  644316:       e8 f5 cb ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
    0.00 :	  64431b:       44 8b 8d ec fb ff ff    mov    -0x414(%rbp),%r9d
         :	        PgStat_StatDBEntry *dbentry;
         :	        PgStat_StatFuncEntry *funcentry;
         :	        int                     i;
         :	        bool            found;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  644322:       49 89 c6                mov    %rax,%r14
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
    0.00 :	  644325:       45 85 c9                test   %r9d,%r9d
    0.00 :	  644328:       0f 8e b7 f9 ff ff       jle    643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  64432e:       48 8b 9d d0 f7 ff ff    mov    -0x830(%rbp),%rbx
    0.00 :	  644335:       45 31 e4                xor    %r12d,%r12d
    0.00 :	  644338:       eb 2d                   jmp    644367 <PgstatCollectorMain+0x847>
         :	                {
         :	                        /*
         :	                         * If it's a new function entry, initialize counters to the values
         :	                         * we just got.
         :	                         */
         :	                        funcentry->f_numcalls = funcmsg->f_numcalls;
    0.00 :	  64433a:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  64433e:       48 89 42 08             mov    %rax,0x8(%rdx)
         :	                        funcentry->f_total_time = funcmsg->f_total_time;
    0.00 :	  644342:       48 8b 43 10             mov    0x10(%rbx),%rax
    0.00 :	  644346:       48 89 42 10             mov    %rax,0x10(%rdx)
         :	                        funcentry->f_self_time = funcmsg->f_self_time;
    0.00 :	  64434a:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  64434e:       48 89 42 18             mov    %rax,0x18(%rdx)
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
    0.00 :	  644352:       41 83 c4 01             add    $0x1,%r12d
    0.00 :	  644356:       44 3b a5 ec fb ff ff    cmp    -0x414(%rbp),%r12d
    0.00 :	  64435d:       0f 8d 82 f9 ff ff       jge    643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  644363:       48 83 c3 20             add    $0x20,%rbx
         :	        {
         :	                funcentry = (PgStat_StatFuncEntry *) hash_search(dbentry->functions,
    0.00 :	  644367:       49 8b be c0 00 00 00    mov    0xc0(%r14),%rdi
    0.00 :	  64436e:       48 8d 4d cc             lea    -0x34(%rbp),%rcx
    0.00 :	  644372:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  644377:       48 89 de                mov    %rbx,%rsi
    0.00 :	  64437a:       e8 21 03 14 00          callq  7846a0 <hash_search>
         :	                                                                                                   (void *) &(funcmsg->f_id),
         :	                                                                                                                 HASH_ENTER, &found);
         :
         :	                if (!found)
    0.00 :	  64437f:       80 7d cc 00             cmpb   $0x0,-0x34(%rbp)
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++, funcmsg++)
         :	        {
         :	                funcentry = (PgStat_StatFuncEntry *) hash_search(dbentry->functions,
    0.00 :	  644383:       48 89 c2                mov    %rax,%rdx
         :	                                                                                                   (void *) &(funcmsg->f_id),
         :	                                                                                                                 HASH_ENTER, &found);
         :
         :	                if (!found)
    0.00 :	  644386:       74 b2                   je     64433a <PgstatCollectorMain+0x81a>
         :	                else
         :	                {
         :	                        /*
         :	                         * Otherwise add the values to the existing entry.
         :	                         */
         :	                        funcentry->f_numcalls += funcmsg->f_numcalls;
    0.00 :	  644388:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  64438c:       48 01 42 08             add    %rax,0x8(%rdx)
         :	                        funcentry->f_total_time += funcmsg->f_total_time;
    0.00 :	  644390:       48 8b 43 10             mov    0x10(%rbx),%rax
    0.00 :	  644394:       48 01 42 10             add    %rax,0x10(%rdx)
         :	                        funcentry->f_self_time += funcmsg->f_self_time;
    0.00 :	  644398:       48 8b 43 18             mov    0x18(%rbx),%rax
    0.00 :	  64439c:       48 01 42 18             add    %rax,0x18(%rdx)
    0.00 :	  6443a0:       eb b0                   jmp    644352 <PgstatCollectorMain+0x832>
         :	pgstat_recv_funcpurge(PgStat_MsgFuncpurge *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :	        int                     i;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6443a2:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  6443a8:       31 f6                   xor    %esi,%esi
    0.00 :	  6443aa:       e8 61 cb ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        /*
         :	         * No need to purge if we don't even know the database.
         :	         */
         :	        if (!dbentry || !dbentry->functions)
    0.00 :	  6443af:       48 85 c0                test   %rax,%rax
         :	pgstat_recv_funcpurge(PgStat_MsgFuncpurge *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :	        int                     i;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6443b2:       49 89 c4                mov    %rax,%r12
         :
         :	        /*
         :	         * No need to purge if we don't even know the database.
         :	         */
         :	        if (!dbentry || !dbentry->functions)
    0.00 :	  6443b5:       0f 84 2a f9 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  6443bb:       48 8b b8 c0 00 00 00    mov    0xc0(%rax),%rdi
    0.00 :	  6443c2:       48 85 ff                test   %rdi,%rdi
    0.00 :	  6443c5:       0f 84 1a f9 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
         :	                return;
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  6443cb:       44 8b 85 ec fb ff ff    mov    -0x414(%rbp),%r8d
    0.00 :	  6443d2:       45 85 c0                test   %r8d,%r8d
    0.00 :	  6443d5:       0f 8e 0a f9 ff ff       jle    643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  6443db:       31 db                   xor    %ebx,%ebx
    0.00 :	  6443dd:       eb 09                   jmp    6443e8 <PgstatCollectorMain+0x8c8>
    0.00 :	  6443df:       90                      nop
    0.00 :	  6443e0:       49 8b bc 24 c0 00 00    mov    0xc0(%r12),%rdi
    0.00 :	  6443e7:       00 
         :	        {
         :	                /* Remove from hashtable if present; we don't care if it's not. */
         :	                (void) hash_search(dbentry->functions,
    0.00 :	  6443e8:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  6443eb:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6443ed:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  6443f2:       49 8d 74 b5 10          lea    0x10(%r13,%rsi,4),%rsi
         :	                return;
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  6443f7:       83 c3 01                add    $0x1,%ebx
         :	        {
         :	                /* Remove from hashtable if present; we don't care if it's not. */
         :	                (void) hash_search(dbentry->functions,
    0.00 :	  6443fa:       e8 a1 02 14 00          callq  7846a0 <hash_search>
         :	                return;
         :
         :	        /*
         :	         * Process all function entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  6443ff:       3b 9d ec fb ff ff       cmp    -0x414(%rbp),%ebx
    0.00 :	  644405:       7c d9                   jl     6443e0 <PgstatCollectorMain+0x8c0>
    0.00 :	  644407:       e9 d9 f8 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	static void
         :	pgstat_recv_recoveryconflict(PgStat_MsgRecoveryConflict *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  64440c:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  644412:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  644417:       e8 f4 ca ff ff          callq  640f10 <pgstat_get_db_entry>
    0.00 :	  64441c:       48 89 c2                mov    %rax,%rdx
         :
         :	        switch (msg->m_reason)
    0.00 :	  64441f:       8b 85 ec fb ff ff       mov    -0x414(%rbp),%eax
    0.00 :	  644425:       83 e8 03                sub    $0x3,%eax
    0.00 :	  644428:       83 f8 04                cmp    $0x4,%eax
    0.00 :	  64442b:       0f 87 b4 f8 ff ff       ja     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  644431:       89 c0                   mov    %eax,%eax
    0.00 :	  644433:       ff 24 c5 10 f8 89 00    jmpq   *0x89f810(,%rax,8)
         :	static void
         :	pgstat_recv_tempfile(PgStat_MsgTempFile *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  64443a:       41 8b 7d 08             mov    0x8(%r13),%edi
    0.00 :	  64443e:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  644443:       e8 c8 ca ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        dbentry->n_temp_bytes += msg->m_filesize;
    0.00 :	  644448:       49 8b 55 10             mov    0x10(%r13),%rdx
         :	        dbentry->n_temp_files += 1;
    0.00 :	  64444c:       48 83 80 80 00 00 00    addq   $0x1,0x80(%rax)
    0.00 :	  644453:       01 
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
         :
         :	        dbentry->n_temp_bytes += msg->m_filesize;
    0.00 :	  644454:       48 01 90 88 00 00 00    add    %rdx,0x88(%rax)
    0.00 :	  64445b:       e9 85 f8 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	 * ----------
         :	 */
         :	static void
         :	pgstat_recv_archiver(PgStat_MsgArchiver *msg, int len)
         :	{
         :	        if (msg->m_failed)
    0.00 :	  644460:       80 bd e8 fb ff ff 00    cmpb   $0x0,-0x418(%rbp)
    0.00 :	  644467:       0f 84 1f 03 00 00       je     64478c <PgstatCollectorMain+0xc6c>
         :	        {
         :	                /* Failed archival attempt */
         :	                ++archiverStats.failed_count;
         :	                memcpy(archiverStats.last_failed_wal, msg->m_xlog,
    0.00 :	  64446d:       48 8b 95 c8 f7 ff ff    mov    -0x838(%rbp),%rdx
         :	pgstat_recv_archiver(PgStat_MsgArchiver *msg, int len)
         :	{
         :	        if (msg->m_failed)
         :	        {
         :	                /* Failed archival attempt */
         :	                ++archiverStats.failed_count;
    0.00 :	  644474:       48 83 05 e4 79 53 00    addq   $0x1,0x5379e4(%rip)        # b7be60 <archiverStats+0x40>
    0.00 :	  64447b:       01 
         :	                memcpy(archiverStats.last_failed_wal, msg->m_xlog,
    0.00 :	  64447c:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  64447f:       48 89 05 e2 79 53 00    mov    %rax,0x5379e2(%rip)        # b7be68 <archiverStats+0x48>
    0.00 :	  644486:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  64448a:       48 89 05 df 79 53 00    mov    %rax,0x5379df(%rip)        # b7be70 <archiverStats+0x50>
    0.00 :	  644491:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  644495:       48 89 05 dc 79 53 00    mov    %rax,0x5379dc(%rip)        # b7be78 <archiverStats+0x58>
    0.00 :	  64449c:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  6444a0:       48 89 05 d9 79 53 00    mov    %rax,0x5379d9(%rip)        # b7be80 <archiverStats+0x60>
    0.00 :	  6444a7:       48 8b 42 20             mov    0x20(%rdx),%rax
    0.00 :	  6444ab:       48 89 05 d6 79 53 00    mov    %rax,0x5379d6(%rip)        # b7be88 <archiverStats+0x68>
    0.00 :	  6444b2:       0f b6 42 28             movzbl 0x28(%rdx),%eax
    0.00 :	  6444b6:       88 05 d4 79 53 00       mov    %al,0x5379d4(%rip)        # b7be90 <archiverStats+0x70>
         :	                           sizeof(archiverStats.last_failed_wal));
         :	                archiverStats.last_failed_timestamp = msg->m_timestamp;
    0.00 :	  6444bc:       48 8b 85 18 fc ff ff    mov    -0x3e8(%rbp),%rax
    0.00 :	  6444c3:       48 89 05 ce 79 53 00    mov    %rax,0x5379ce(%rip)        # b7be98 <archiverStats+0x78>
    0.00 :	  6444ca:       e9 16 f8 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	 * ----------
         :	 */
         :	static void
         :	pgstat_recv_bgwriter(PgStat_MsgBgWriter *msg, int len)
         :	{
         :	        globalStats.timed_checkpoints += msg->m_timed_checkpoints;
    0.00 :	  6444cf:       48 8b 85 e8 fb ff ff    mov    -0x418(%rbp),%rax
 /home/Computational/mark/src/postgres-andres/src/backend/postmaster/pgstat.c:5014
  100.00 :	  6444d6:       48 01 05 eb 79 53 00    add    %rax,0x5379eb(%rip)        # b7bec8 <globalStats+0x8>
         :	        globalStats.requested_checkpoints += msg->m_requested_checkpoints;
    0.00 :	  6444dd:       48 8b 85 f0 fb ff ff    mov    -0x410(%rbp),%rax
    0.00 :	  6444e4:       48 01 05 e5 79 53 00    add    %rax,0x5379e5(%rip)        # b7bed0 <globalStats+0x10>
         :	        globalStats.checkpoint_write_time += msg->m_checkpoint_write_time;
    0.00 :	  6444eb:       48 8b 85 28 fc ff ff    mov    -0x3d8(%rbp),%rax
    0.00 :	  6444f2:       48 01 05 df 79 53 00    add    %rax,0x5379df(%rip)        # b7bed8 <globalStats+0x18>
         :	        globalStats.checkpoint_sync_time += msg->m_checkpoint_sync_time;
    0.00 :	  6444f9:       48 8b 85 30 fc ff ff    mov    -0x3d0(%rbp),%rax
    0.00 :	  644500:       48 01 05 d9 79 53 00    add    %rax,0x5379d9(%rip)        # b7bee0 <globalStats+0x20>
         :	        globalStats.buf_written_checkpoints += msg->m_buf_written_checkpoints;
    0.00 :	  644507:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
    0.00 :	  64450e:       48 01 05 d3 79 53 00    add    %rax,0x5379d3(%rip)        # b7bee8 <globalStats+0x28>
         :	        globalStats.buf_written_clean += msg->m_buf_written_clean;
    0.00 :	  644515:       48 8b 85 00 fc ff ff    mov    -0x400(%rbp),%rax
    0.00 :	  64451c:       48 01 05 cd 79 53 00    add    %rax,0x5379cd(%rip)        # b7bef0 <globalStats+0x30>
         :	        globalStats.maxwritten_clean += msg->m_maxwritten_clean;
    0.00 :	  644523:       48 8b 85 08 fc ff ff    mov    -0x3f8(%rbp),%rax
    0.00 :	  64452a:       48 01 05 c7 79 53 00    add    %rax,0x5379c7(%rip)        # b7bef8 <globalStats+0x38>
         :	        globalStats.buf_written_backend += msg->m_buf_written_backend;
    0.00 :	  644531:       48 8b 85 10 fc ff ff    mov    -0x3f0(%rbp),%rax
    0.00 :	  644538:       48 01 05 c1 79 53 00    add    %rax,0x5379c1(%rip)        # b7bf00 <globalStats+0x40>
         :	        globalStats.buf_fsync_backend += msg->m_buf_fsync_backend;
    0.00 :	  64453f:       48 8b 85 18 fc ff ff    mov    -0x3e8(%rbp),%rax
    0.00 :	  644546:       48 01 05 bb 79 53 00    add    %rax,0x5379bb(%rip)        # b7bf08 <globalStats+0x48>
         :	        globalStats.buf_alloc += msg->m_buf_alloc;
    0.00 :	  64454d:       48 8b 85 20 fc ff ff    mov    -0x3e0(%rbp),%rax
    0.00 :	  644554:       48 01 05 b5 79 53 00    add    %rax,0x5379b5(%rip)        # b7bf10 <globalStats+0x50>
         :	                                        pgstat_recv_archiver((PgStat_MsgArchiver *) &msg, len);
         :	                                        break;
         :
         :	                                case PGSTAT_MTYPE_BGWRITER:
         :	                                        pgstat_recv_bgwriter((PgStat_MsgBgWriter *) &msg, len);
         :	                                        break;
    0.00 :	  64455b:       e9 85 f7 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	pgstat_recv_tabpurge(PgStat_MsgTabpurge *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :	        int                     i;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  644560:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  644566:       31 f6                   xor    %esi,%esi
    0.00 :	  644568:       e8 a3 c9 ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        /*
         :	         * No need to purge if we don't even know the database.
         :	         */
         :	        if (!dbentry || !dbentry->tables)
    0.00 :	  64456d:       48 85 c0                test   %rax,%rax
         :	pgstat_recv_tabpurge(PgStat_MsgTabpurge *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :	        int                     i;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  644570:       49 89 c4                mov    %rax,%r12
         :
         :	        /*
         :	         * No need to purge if we don't even know the database.
         :	         */
         :	        if (!dbentry || !dbentry->tables)
    0.00 :	  644573:       0f 84 6c f7 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  644579:       48 8b b8 b8 00 00 00    mov    0xb8(%rax),%rdi
    0.00 :	  644580:       48 85 ff                test   %rdi,%rdi
    0.00 :	  644583:       0f 84 5c f7 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
         :	                return;
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  644589:       44 8b 95 ec fb ff ff    mov    -0x414(%rbp),%r10d
    0.00 :	  644590:       45 85 d2                test   %r10d,%r10d
    0.00 :	  644593:       0f 8e 4c f7 ff ff       jle    643ce5 <PgstatCollectorMain+0x1c5>
    0.00 :	  644599:       31 db                   xor    %ebx,%ebx
    0.00 :	  64459b:       eb 0b                   jmp    6445a8 <PgstatCollectorMain+0xa88>
    0.00 :	  64459d:       0f 1f 00                nopl   (%rax)
    0.00 :	  6445a0:       49 8b bc 24 b8 00 00    mov    0xb8(%r12),%rdi
    0.00 :	  6445a7:       00 
         :	        {
         :	                /* Remove from hashtable if present; we don't care if it's not. */
         :	                (void) hash_search(dbentry->tables,
    0.00 :	  6445a8:       48 63 f3                movslq %ebx,%rsi
    0.00 :	  6445ab:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6445ad:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  6445b2:       49 8d 74 b5 10          lea    0x10(%r13,%rsi,4),%rsi
         :	                return;
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  6445b7:       83 c3 01                add    $0x1,%ebx
         :	        {
         :	                /* Remove from hashtable if present; we don't care if it's not. */
         :	                (void) hash_search(dbentry->tables,
    0.00 :	  6445ba:       e8 e1 00 14 00          callq  7846a0 <hash_search>
         :	                return;
         :
         :	        /*
         :	         * Process all table entries in the message.
         :	         */
         :	        for (i = 0; i < msg->m_nentries; i++)
    0.00 :	  6445bf:       3b 9d ec fb ff ff       cmp    -0x414(%rbp),%ebx
    0.00 :	  6445c5:       7c d9                   jl     6445a0 <PgstatCollectorMain+0xa80>
    0.00 :	  6445c7:       e9 19 f7 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	 * ----------
         :	 */
         :	static void
         :	pgstat_recv_dropdb(PgStat_MsgDropdb *msg, int len)
         :	{
         :	        Oid                     dbid = msg->m_databaseid;
    0.00 :	  6445cc:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Lookup the database in the hashtable.
         :	         */
         :	        dbentry = pgstat_get_db_entry(dbid, false);
    0.00 :	  6445d2:       31 f6                   xor    %esi,%esi
         :	 * ----------
         :	 */
         :	static void
         :	pgstat_recv_dropdb(PgStat_MsgDropdb *msg, int len)
         :	{
         :	        Oid                     dbid = msg->m_databaseid;
    0.00 :	  6445d4:       89 7d cc                mov    %edi,-0x34(%rbp)
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Lookup the database in the hashtable.
         :	         */
         :	        dbentry = pgstat_get_db_entry(dbid, false);
    0.00 :	  6445d7:       e8 34 c9 ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        /*
         :	         * If found, remove it (along with the db statfile).
         :	         */
         :	        if (dbentry)
    0.00 :	  6445dc:       48 85 c0                test   %rax,%rax
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Lookup the database in the hashtable.
         :	         */
         :	        dbentry = pgstat_get_db_entry(dbid, false);
    0.00 :	  6445df:       48 89 c3                mov    %rax,%rbx
         :
         :	        /*
         :	         * If found, remove it (along with the db statfile).
         :	         */
         :	        if (dbentry)
    0.00 :	  6445e2:       0f 84 fd f6 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
         :	        {
         :	                char            statfile[MAXPGPATH];
         :
         :	                get_dbstat_filename(false, false, dbid, statfile, MAXPGPATH);
    0.00 :	  6445e8:       8b 55 cc                mov    -0x34(%rbp),%edx
    0.00 :	  6445eb:       48 8d 8d e0 f7 ff ff    lea    -0x820(%rbp),%rcx
    0.00 :	  6445f2:       41 b8 00 04 00 00       mov    $0x400,%r8d
    0.00 :	  6445f8:       31 f6                   xor    %esi,%esi
    0.00 :	  6445fa:       31 ff                   xor    %edi,%edi
    0.00 :	  6445fc:       e8 7f ca ff ff          callq  641080 <get_dbstat_filename>
         :
         :	                elog(DEBUG2, "removing %s", statfile);
    0.00 :	  644601:       ba a0 f9 89 00          mov    $0x89f9a0,%edx
    0.00 :	  644606:       be a5 12 00 00          mov    $0x12a5,%esi
    0.00 :	  64460b:       bf 88 ef 89 00          mov    $0x89ef88,%edi
    0.00 :	  644610:       e8 0b 6e 13 00          callq  77b420 <elog_start>
    0.00 :	  644615:       48 8d 95 e0 f7 ff ff    lea    -0x820(%rbp),%rdx
    0.00 :	  64461c:       31 c0                   xor    %eax,%eax
    0.00 :	  64461e:       be ad f0 89 00          mov    $0x89f0ad,%esi
    0.00 :	  644623:       bf 0d 00 00 00          mov    $0xd,%edi
    0.00 :	  644628:       e8 03 6c 13 00          callq  77b230 <elog_finish>
         :	                unlink(statfile);
    0.00 :	  64462d:       48 8d bd e0 f7 ff ff    lea    -0x820(%rbp),%rdi
    0.00 :	  644634:       e8 77 50 e2 ff          callq  4696b0 <unlink@plt>
         :
         :	                if (dbentry->tables != NULL)
    0.00 :	  644639:       48 8b bb b8 00 00 00    mov    0xb8(%rbx),%rdi
    0.00 :	  644640:       48 85 ff                test   %rdi,%rdi
    0.00 :	  644643:       74 05                   je     64464a <PgstatCollectorMain+0xb2a>
         :	                        hash_destroy(dbentry->tables);
    0.00 :	  644645:       e8 b6 00 14 00          callq  784700 <hash_destroy>
         :	                if (dbentry->functions != NULL)
    0.00 :	  64464a:       48 8b bb c0 00 00 00    mov    0xc0(%rbx),%rdi
    0.00 :	  644651:       48 85 ff                test   %rdi,%rdi
    0.00 :	  644654:       74 05                   je     64465b <PgstatCollectorMain+0xb3b>
         :	                        hash_destroy(dbentry->functions);
    0.00 :	  644656:       e8 a5 00 14 00          callq  784700 <hash_destroy>
         :
         :	                if (hash_search(pgStatDBHash,
    0.00 :	  64465b:       48 8b 3d 76 75 53 00    mov    0x537576(%rip),%rdi        # b7bbd8 <pgStatDBHash>
    0.00 :	  644662:       48 8d 75 cc             lea    -0x34(%rbp),%rsi
    0.00 :	  644666:       31 c9                   xor    %ecx,%ecx
    0.00 :	  644668:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  64466d:       e8 2e 00 14 00          callq  7846a0 <hash_search>
    0.00 :	  644672:       48 85 c0                test   %rax,%rax
    0.00 :	  644675:       0f 85 6a f6 ff ff       jne    643ce5 <PgstatCollectorMain+0x1c5>
         :	                                                (void *) &dbid,
         :	                                                HASH_REMOVE, NULL) == NULL)
         :	                        ereport(ERROR,
    0.00 :	  64467b:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  64467e:       b9 a0 f9 89 00          mov    $0x89f9a0,%ecx
    0.00 :	  644683:       ba b1 12 00 00          mov    $0x12b1,%edx
    0.00 :	  644688:       be 88 ef 89 00          mov    $0x89ef88,%esi
    0.00 :	  64468d:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  644692:       e8 29 64 13 00          callq  77aac0 <errstart>
    0.00 :	  644697:       84 c0                   test   %al,%al
    0.00 :	  644699:       0f 84 07 f7 ff ff       je     643da6 <PgstatCollectorMain+0x286>
    0.00 :	  64469f:       bf 00 f4 89 00          mov    $0x89f400,%edi
    0.00 :	  6446a4:       31 c0                   xor    %eax,%eax
    0.00 :	  6446a6:       e8 f5 81 13 00          callq  77c8a0 <errmsg>
    0.00 :	  6446ab:       89 c7                   mov    %eax,%edi
    0.00 :	  6446ad:       31 c0                   xor    %eax,%eax
    0.00 :	  6446af:       e8 2c 5f 13 00          callq  77a5e0 <errfinish>
    0.00 :	  6446b4:       e9 ed f6 ff ff          jmpq   643da6 <PgstatCollectorMain+0x286>
    0.00 :	  6446b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	static void
         :	pgstat_recv_resetsinglecounter(PgStat_MsgResetsinglecounter *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6446c0:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  6446c6:       31 f6                   xor    %esi,%esi
    0.00 :	  6446c8:       e8 43 c8 ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        if (!dbentry)
    0.00 :	  6446cd:       48 85 c0                test   %rax,%rax
         :	static void
         :	pgstat_recv_resetsinglecounter(PgStat_MsgResetsinglecounter *msg, int len)
         :	{
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, false);
    0.00 :	  6446d0:       48 89 c3                mov    %rax,%rbx
         :
         :	        if (!dbentry)
    0.00 :	  6446d3:       0f 84 0c f6 ff ff       je     643ce5 <PgstatCollectorMain+0x1c5>
         :	                return;
         :
         :	        /* Set the reset timestamp for the whole database */
         :	        dbentry->stat_reset_timestamp = GetCurrentTimestamp();
    0.00 :	  6446d9:       e8 92 1c 10 00          callq  746370 <GetCurrentTimestamp>
    0.00 :	  6446de:       48 89 83 a8 00 00 00    mov    %rax,0xa8(%rbx)
         :
         :	        /* Remove object if it exists, ignore it if not */
         :	        if (msg->m_resettype == RESET_TABLE)
    0.00 :	  6446e5:       8b 85 ec fb ff ff       mov    -0x414(%rbp),%eax
    0.00 :	  6446eb:       85 c0                   test   %eax,%eax
    0.00 :	  6446ed:       0f 84 a5 01 00 00       je     644898 <PgstatCollectorMain+0xd78>
         :	                (void) hash_search(dbentry->tables, (void *) &(msg->m_objectid),
         :	                                                   HASH_REMOVE, NULL);
         :	        else if (msg->m_resettype == RESET_FUNCTION)
    0.00 :	  6446f3:       83 e8 01                sub    $0x1,%eax
    0.00 :	  6446f6:       0f 85 e9 f5 ff ff       jne    643ce5 <PgstatCollectorMain+0x1c5>
         :	                (void) hash_search(dbentry->functions, (void *) &(msg->m_objectid),
    0.00 :	  6446fc:       48 8b bb c0 00 00 00    mov    0xc0(%rbx),%rdi
    0.00 :	  644703:       48 8b b5 d0 f7 ff ff    mov    -0x830(%rbp),%rsi
    0.00 :	  64470a:       31 c9                   xor    %ecx,%ecx
    0.00 :	  64470c:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  644711:       e8 8a ff 13 00          callq  7846a0 <hash_search>
    0.00 :	  644716:       e9 ca f5 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        PgStat_StatDBEntry *dbentry;
         :
         :	        /*
         :	         * Store the last autovacuum time in the database's hashtable entry.
         :	         */
         :	        dbentry = pgstat_get_db_entry(msg->m_databaseid, true);
    0.00 :	  64471b:       8b bd e8 fb ff ff       mov    -0x418(%rbp),%edi
    0.00 :	  644721:       be 01 00 00 00          mov    $0x1,%esi
    0.00 :	  644726:       e8 e5 c7 ff ff          callq  640f10 <pgstat_get_db_entry>
         :
         :	        dbentry->last_autovac_time = msg->m_start_time;
    0.00 :	  64472b:       48 8b 95 f0 fb ff ff    mov    -0x410(%rbp),%rdx
    0.00 :	  644732:       48 89 50 50             mov    %rdx,0x50(%rax)
         :	                                                                                                   len);
         :	                                        break;
         :
         :	                                case PGSTAT_MTYPE_AUTOVAC_START:
         :	                                        pgstat_recv_autovac((PgStat_MsgAutovacStart *) &msg, len);
         :	                                        break;
    0.00 :	  644736:       e9 aa f5 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	 * ----------
         :	 */
         :	static void
         :	pgstat_recv_resetsharedcounter(PgStat_MsgResetsharedcounter *msg, int len)
         :	{
         :	        if (msg->m_resettarget == RESET_BGWRITER)
    0.00 :	  64473b:       8b 85 e8 fb ff ff       mov    -0x418(%rbp),%eax
    0.00 :	  644741:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  644744:       0f 84 2e 01 00 00       je     644878 <PgstatCollectorMain+0xd58>
         :	        {
         :	                /* Reset the global background writer statistics for the cluster. */
         :	                memset(&globalStats, 0, sizeof(globalStats));
         :	                globalStats.stat_reset_timestamp = GetCurrentTimestamp();
         :	        }
         :	        else if (msg->m_resettarget == RESET_ARCHIVER)
    0.00 :	  64474a:       85 c0                   test   %eax,%eax
    0.00 :	  64474c:       0f 85 93 f5 ff ff       jne    643ce5 <PgstatCollectorMain+0x1c5>
         :	        {
         :	                /* Reset the archiver statistics for the cluster. */
         :	                memset(&archiverStats, 0, sizeof(archiverStats));
    0.00 :	  644752:       31 c0                   xor    %eax,%eax
    0.00 :	  644754:       bf 20 be b7 00          mov    $0xb7be20,%edi
    0.00 :	  644759:       b9 11 00 00 00          mov    $0x11,%ecx
    0.00 :	  64475e:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                archiverStats.stat_reset_timestamp = GetCurrentTimestamp();
    0.00 :	  644761:       e8 0a 1c 10 00          callq  746370 <GetCurrentTimestamp>
    0.00 :	  644766:       48 89 05 33 77 53 00    mov    %rax,0x537733(%rip)        # b7bea0 <archiverStats+0x80>
    0.00 :	  64476d:       e9 73 f5 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                DBWriteRequest *req = slist_container(DBWriteRequest, next, iter.cur);
         :
         :	                if (req->databaseid != msg->databaseid)
         :	                        continue;
         :
         :	                if (msg->cutoff_time > req->request_time)
    0.00 :	  644772:       48 8b 85 f0 fb ff ff    mov    -0x410(%rbp),%rax
    0.00 :	  644779:       48 3b 42 08             cmp    0x8(%rdx),%rax
    0.00 :	  64477d:       0f 8e 62 f5 ff ff       jle    643ce5 <PgstatCollectorMain+0x1c5>
         :	                        req->request_time = msg->cutoff_time;
    0.00 :	  644783:       48 89 42 08             mov    %rax,0x8(%rdx)
    0.00 :	  644787:       e9 59 f5 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        }
         :	        else
         :	        {
         :	                /* Successful archival operation */
         :	                ++archiverStats.archived_count;
         :	                memcpy(archiverStats.last_archived_wal, msg->m_xlog,
    0.00 :	  64478c:       48 8b 95 c8 f7 ff ff    mov    -0x838(%rbp),%rdx
         :	                archiverStats.last_failed_timestamp = msg->m_timestamp;
         :	        }
         :	        else
         :	        {
         :	                /* Successful archival operation */
         :	                ++archiverStats.archived_count;
    0.00 :	  644793:       48 83 05 85 76 53 00    addq   $0x1,0x537685(%rip)        # b7be20 <archiverStats>
    0.00 :	  64479a:       01 
         :	                memcpy(archiverStats.last_archived_wal, msg->m_xlog,
    0.00 :	  64479b:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  64479e:       48 89 05 83 76 53 00    mov    %rax,0x537683(%rip)        # b7be28 <archiverStats+0x8>
    0.00 :	  6447a5:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  6447a9:       48 89 05 80 76 53 00    mov    %rax,0x537680(%rip)        # b7be30 <archiverStats+0x10>
    0.00 :	  6447b0:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  6447b4:       48 89 05 7d 76 53 00    mov    %rax,0x53767d(%rip)        # b7be38 <archiverStats+0x18>
    0.00 :	  6447bb:       48 8b 42 18             mov    0x18(%rdx),%rax
    0.00 :	  6447bf:       48 89 05 7a 76 53 00    mov    %rax,0x53767a(%rip)        # b7be40 <archiverStats+0x20>
    0.00 :	  6447c6:       48 8b 42 20             mov    0x20(%rdx),%rax
    0.00 :	  6447ca:       48 89 05 77 76 53 00    mov    %rax,0x537677(%rip)        # b7be48 <archiverStats+0x28>
    0.00 :	  6447d1:       0f b6 42 28             movzbl 0x28(%rdx),%eax
    0.00 :	  6447d5:       88 05 75 76 53 00       mov    %al,0x537675(%rip)        # b7be50 <archiverStats+0x30>
         :	                           sizeof(archiverStats.last_archived_wal));
         :	                archiverStats.last_archived_timestamp = msg->m_timestamp;
    0.00 :	  6447db:       48 8b 85 18 fc ff ff    mov    -0x3e8(%rbp),%rax
    0.00 :	  6447e2:       48 89 05 6f 76 53 00    mov    %rax,0x53766f(%rip)        # b7be58 <archiverStats+0x38>
    0.00 :	  6447e9:       e9 f7 f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                tabentry->autovac_analyze_timestamp = msg->m_analyzetime;
         :	                tabentry->autovac_analyze_count++;
         :	        }
         :	        else
         :	        {
         :	                tabentry->analyze_timestamp = msg->m_analyzetime;
    0.00 :	  6447ee:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
         :	                tabentry->analyze_count++;
    0.00 :	  6447f5:       48 83 82 90 00 00 00    addq   $0x1,0x90(%rdx)
    0.00 :	  6447fc:       01 
         :	                tabentry->autovac_analyze_timestamp = msg->m_analyzetime;
         :	                tabentry->autovac_analyze_count++;
         :	        }
         :	        else
         :	        {
         :	                tabentry->analyze_timestamp = msg->m_analyzetime;
    0.00 :	  6447fd:       48 89 82 88 00 00 00    mov    %rax,0x88(%rdx)
    0.00 :	  644804:       e9 dc f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                tabentry->autovac_vacuum_timestamp = msg->m_vacuumtime;
         :	                tabentry->autovac_vacuum_count++;
         :	        }
         :	        else
         :	        {
         :	                tabentry->vacuum_timestamp = msg->m_vacuumtime;
    0.00 :	  644809:       48 8b 85 f8 fb ff ff    mov    -0x408(%rbp),%rax
         :	                tabentry->vacuum_count++;
    0.00 :	  644810:       48 83 42 70 01          addq   $0x1,0x70(%rdx)
         :	                tabentry->autovac_vacuum_timestamp = msg->m_vacuumtime;
         :	                tabentry->autovac_vacuum_count++;
         :	        }
         :	        else
         :	        {
         :	                tabentry->vacuum_timestamp = msg->m_vacuumtime;
    0.00 :	  644815:       48 89 42 68             mov    %rax,0x68(%rdx)
    0.00 :	  644819:       e9 c7 f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:
         :	                        dbentry->n_conflict_snapshot++;
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:
         :	                        dbentry->n_conflict_bufferpin++;
    0.00 :	  64481e:       48 83 42 70 01          addq   $0x1,0x70(%rdx)
    0.00 :	  644823:       e9 bd f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_LOCK:
         :	                        dbentry->n_conflict_lock++;
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:
         :	                        dbentry->n_conflict_snapshot++;
    0.00 :	  644828:       48 83 42 68 01          addq   $0x1,0x68(%rdx)
    0.00 :	  64482d:       e9 b3 f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_TABLESPACE:
         :	                        dbentry->n_conflict_tablespace++;
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_LOCK:
         :	                        dbentry->n_conflict_lock++;
    0.00 :	  644832:       48 83 42 60 01          addq   $0x1,0x60(%rdx)
    0.00 :	  644837:       e9 a9 f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                         * Since we drop the information about the database as soon as it
         :	                         * replicates, there is no point in counting these conflicts.
         :	                         */
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_TABLESPACE:
         :	                        dbentry->n_conflict_tablespace++;
    0.00 :	  64483c:       48 83 42 58 01          addq   $0x1,0x58(%rdx)
    0.00 :	  644841:       e9 9f f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:
         :	                        dbentry->n_conflict_bufferpin++;
         :	                        break;
         :	                case PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:
         :	                        dbentry->n_conflict_startup_deadlock++;
    0.00 :	  644846:       48 83 42 78 01          addq   $0x1,0x78(%rdx)
    0.00 :	  64484b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	  644850:       e9 90 f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :
         :	                        if (len < 0)
         :	                        {
         :	                                if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
         :	                                        break;          /* out of inner loop */
         :	                                ereport(ERROR,
    0.00 :	  644855:       bf 98 f3 89 00          mov    $0x89f398,%edi
    0.00 :	  64485a:       31 c0                   xor    %eax,%eax
    0.00 :	  64485c:       e8 3f 80 13 00          callq  77c8a0 <errmsg>
    0.00 :	  644861:       89 c3                   mov    %eax,%ebx
    0.00 :	  644863:       e8 e8 81 13 00          callq  77ca50 <errcode_for_socket_access>
    0.00 :	  644868:       89 de                   mov    %ebx,%esi
    0.00 :	  64486a:       89 c7                   mov    %eax,%edi
    0.00 :	  64486c:       31 c0                   xor    %eax,%eax
    0.00 :	  64486e:       e8 6d 5d 13 00          callq  77a5e0 <errfinish>
    0.00 :	  644873:       e9 2e f5 ff ff          jmpq   643da6 <PgstatCollectorMain+0x286>
         :	pgstat_recv_resetsharedcounter(PgStat_MsgResetsharedcounter *msg, int len)
         :	{
         :	        if (msg->m_resettarget == RESET_BGWRITER)
         :	        {
         :	                /* Reset the global background writer statistics for the cluster. */
         :	                memset(&globalStats, 0, sizeof(globalStats));
    0.00 :	  644878:       31 c0                   xor    %eax,%eax
    0.00 :	  64487a:       b9 0c 00 00 00          mov    $0xc,%ecx
    0.00 :	  64487f:       bf c0 be b7 00          mov    $0xb7bec0,%edi
    0.00 :	  644884:       f3 48 ab                rep stos %rax,%es:(%rdi)
         :	                globalStats.stat_reset_timestamp = GetCurrentTimestamp();
    0.00 :	  644887:       e8 e4 1a 10 00          callq  746370 <GetCurrentTimestamp>
    0.00 :	  64488c:       48 89 05 85 76 53 00    mov    %rax,0x537685(%rip)        # b7bf18 <globalStats+0x58>
    0.00 :	  644893:       e9 4d f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	        /* Set the reset timestamp for the whole database */
         :	        dbentry->stat_reset_timestamp = GetCurrentTimestamp();
         :
         :	        /* Remove object if it exists, ignore it if not */
         :	        if (msg->m_resettype == RESET_TABLE)
         :	                (void) hash_search(dbentry->tables, (void *) &(msg->m_objectid),
    0.00 :	  644898:       48 8b bb b8 00 00 00    mov    0xb8(%rbx),%rdi
    0.00 :	  64489f:       48 8b b5 d0 f7 ff ff    mov    -0x830(%rbp),%rsi
    0.00 :	  6448a6:       31 c9                   xor    %ecx,%ecx
    0.00 :	  6448a8:       ba 02 00 00 00          mov    $0x2,%edx
    0.00 :	  6448ad:       e8 ee fd 13 00          callq  7846a0 <hash_search>
    0.00 :	  6448b2:       e9 2e f4 ff ff          jmpq   643ce5 <PgstatCollectorMain+0x1c5>
         :	         * child processes, but for consistency we make all postmaster child
         :	         * processes do this.)
         :	         */
         :	#ifdef HAVE_SETSID
         :	        if (setsid() < 0)
         :	                elog(FATAL, "setsid() failed: %m");
    0.00 :	  6448b7:       ba 60 f9 89 00          mov    $0x89f960,%edx
    0.00 :	  6448bc:       be 60 0c 00 00          mov    $0xc60,%esi
    0.00 :	  6448c1:       bf 88 ef 89 00          mov    $0x89ef88,%edi
    0.00 :	  6448c6:       e8 55 6b 13 00          callq  77b420 <elog_start>
    0.00 :	  6448cb:       be 83 fe 7b 00          mov    $0x7bfe83,%esi
    0.00 :	  6448d0:       bf 15 00 00 00          mov    $0x15,%edi
    0.00 :	  6448d5:       31 c0                   xor    %eax,%eax
    0.00 :	  6448d7:       e8 54 69 13 00          callq  77b230 <elog_finish>
    0.00 :	  6448dc:       e8 ef 4b e2 ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/buf_table.c:108
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000673da0 <BufTableInsert>:
         :	 *
         :	 * Caller must hold exclusive lock on BufMappingLock for tag's partition
         :	 */
         :	int
         :	BufTableInsert(BufferTag *tagPtr, int buf_id)
         :	{
    0.00 :	  673da0:       55                      push   %rbp
    0.00 :	  673da1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  673da4:       48 83 ec 20             sub    $0x20,%rsp
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
    0.00 :	  673da8:       48 8b 07                mov    (%rdi),%rax
    0.00 :	  673dab:       48 89 45 e0             mov    %rax,-0x20(%rbp)
    0.00 :	  673daf:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  673db3:       48 89 45 e8             mov    %rax,-0x18(%rbp)
    0.00 :	  673db7:       8b 47 10                mov    0x10(%rdi),%eax
         :	        ent.id = buf_id;
         :
         :	        Assert(buf_id >= 0);            /* -1 is reserved for not-in-table */
         :	        Assert(tagPtr->blockNum != P_NEW);      /* invalid tag */
         :
         :	        if (CHashInsert(SharedBufHash, &ent))
    0.00 :	  673dba:       48 8b 3d 97 92 50 00    mov    0x509297(%rip),%rdi        # b7d058 <SharedBufHash>
         :	BufTableInsert(BufferTag *tagPtr, int buf_id)
         :	{
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
         :	        ent.id = buf_id;
    0.00 :	  673dc1:       89 75 f4                mov    %esi,-0xc(%rbp)
         :
         :	        Assert(buf_id >= 0);            /* -1 is reserved for not-in-table */
         :	        Assert(tagPtr->blockNum != P_NEW);      /* invalid tag */
         :
         :	        if (CHashInsert(SharedBufHash, &ent))
    0.00 :	  673dc4:       48 8d 75 e0             lea    -0x20(%rbp),%rsi
         :	int
         :	BufTableInsert(BufferTag *tagPtr, int buf_id)
         :	{
         :	        BufferLookupEnt ent;
         :
         :	        ent.key = *tagPtr;
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/buf_table.c:108
  100.00 :	  673dc8:       89 45 f0                mov    %eax,-0x10(%rbp)
         :	        ent.id = buf_id;
         :
         :	        Assert(buf_id >= 0);            /* -1 is reserved for not-in-table */
         :	        Assert(tagPtr->blockNum != P_NEW);      /* invalid tag */
         :
         :	        if (CHashInsert(SharedBufHash, &ent))
    0.00 :	  673dcb:       e8 50 f1 10 00          callq  782f20 <CHashInsert>
    0.00 :	  673dd0:       89 c2                   mov    %eax,%edx
    0.00 :	  673dd2:       b8 ff ff ff ff          mov    $0xffffffff,%eax
    0.00 :	  673dd7:       84 d2                   test   %dl,%dl
    0.00 :	  673dd9:       0f 44 45 f4             cmove  -0xc(%rbp),%eax
         :	                return -1;
         :
         :	        return ent.id;
         :	}
    0.00 :	  673ddd:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3304
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674440 <StartBufferIO>:
         :	 * Returns TRUE if we successfully marked the buffer as I/O busy,
         :	 * FALSE if someone else already did the work.
         :	 */
         :	static bool
         :	StartBufferIO(volatile BufferDesc *buf, bool forInput)
         :	{
    0.00 :	  674440:       55                      push   %rbp
    0.00 :	  674441:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674444:       41 56                   push   %r14
    0.00 :	  674446:       41 89 f6                mov    %esi,%r14d
    0.00 :	  674449:       41 55                   push   %r13
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  67444b:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  674451:       41 54                   push   %r12
    0.00 :	  674453:       4c 8d 67 20             lea    0x20(%rdi),%r12
    0.00 :	  674457:       53                      push   %rbx
    0.00 :	  674458:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  67445b:       eb 20                   jmp    67447d <StartBufferIO+0x3d>
    0.00 :	  67445d:       0f 1f 00                nopl   (%rax)
         :	                 */
         :	                LWLockAcquire(buf->io_in_progress_lock, LW_EXCLUSIVE);
         :
         :	                LockBufHdr(buf);
         :
         :	                if (!(buf->flags & BM_IO_IN_PROGRESS))
    0.00 :	  674460:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  674464:       a8 08                   test   $0x8,%al
    0.00 :	  674466:       74 46                   je     6744ae <StartBufferIO+0x6e>
         :	                 * The only way BM_IO_IN_PROGRESS could be set when the io_in_progress
         :	                 * lock isn't held is if the process doing the I/O is recovering from
         :	                 * an error (see AbortBufferIO).  If that's the case, we must wait for
         :	                 * him to get unwedged.
         :	                 */
         :	                UnlockBufHdr(buf);
    0.00 :	  674468:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                LWLockRelease(buf->io_in_progress_lock);
    0.00 :	  67446c:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  674470:       e8 2b af 01 00          callq  68f3a0 <LWLockRelease>
         :	                WaitIO(buf);
    0.00 :	  674475:       48 89 df                mov    %rbx,%rdi
    0.00 :	  674478:       e8 43 ff ff ff          callq  6743c0 <WaitIO>
         :	        {
         :	                /*
         :	                 * Grab the io_in_progress lock so that other processes can wait for
         :	                 * me to finish the I/O.
         :	                 */
         :	                LWLockAcquire(buf->io_in_progress_lock, LW_EXCLUSIVE);
    0.00 :	  67447d:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  674481:       31 f6                   xor    %esi,%esi
    0.00 :	  674483:       e8 68 b6 01 00          callq  68faf0 <LWLockAcquire>
    0.00 :	  674488:       44 89 e8                mov    %r13d,%eax
    0.00 :	  67448b:       f0 41 86 04 24          lock xchg %al,(%r12)
         :
         :	                LockBufHdr(buf);
    0.00 :	  674490:       84 c0                   test   %al,%al
    0.00 :	  674492:       74 cc                   je     674460 <StartBufferIO+0x20>
    0.00 :	  674494:       ba c6 0c 00 00          mov    $0xcc6,%edx
    0.00 :	  674499:       be 53 9d 8a 00          mov    $0x8a9d53,%esi
    0.00 :	  67449e:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  6744a1:       e8 9a bb 01 00          callq  690040 <s_lock>
         :
         :	                if (!(buf->flags & BM_IO_IN_PROGRESS))
    0.00 :	  6744a6:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6744aa:       a8 08                   test   $0x8,%al
    0.00 :	  6744ac:       75 ba                   jne    674468 <StartBufferIO+0x28>
         :	                WaitIO(buf);
         :	        }
         :
         :	        /* Once we get here, there is definitely no I/O active on this buffer */
         :
         :	        if (forInput ? (buf->flags & BM_VALID) : !(buf->flags & BM_DIRTY))
    0.00 :	  6744ae:       45 84 f6                test   %r14b,%r14b
    0.00 :	  6744b1:       74 3d                   je     6744f0 <StartBufferIO+0xb0>
    0.00 :	  6744b3:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6744b7:       d1 e8                   shr    %eax
    0.00 :	  6744b9:       83 e0 01                and    $0x1,%eax
    0.00 :	  6744bc:       84 c0                   test   %al,%al
    0.00 :	  6744be:       75 3d                   jne    6744fd <StartBufferIO+0xbd>
         :	                UnlockBufHdr(buf);
         :	                LWLockRelease(buf->io_in_progress_lock);
         :	                return false;
         :	        }
         :
         :	        buf->flags |= BM_IO_IN_PROGRESS;
    0.00 :	  6744c0:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6744c4:       83 c8 08                or     $0x8,%eax
    0.00 :	  6744c7:       66 89 43 14             mov    %ax,0x14(%rbx)
         :
         :	        UnlockBufHdr(buf);
    0.00 :	  6744cb:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :
         :	        InProgressBuf = buf;
    0.00 :	  6744cf:       48 89 1d 92 8b 50 00    mov    %rbx,0x508b92(%rip)        # b7d068 <InProgressBuf>
         :	        IsForInput = forInput;
    0.00 :	  6744d6:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  6744db:       44 88 35 c3 8b 50 00    mov    %r14b,0x508bc3(%rip)        # b7d0a5 <IsForInput>
         :
         :	        return true;
         :	}
    0.00 :	  6744e2:       5b                      pop    %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:3304
  100.00 :	  6744e3:       41 5c                   pop    %r12
    0.00 :	  6744e5:       41 5d                   pop    %r13
    0.00 :	  6744e7:       41 5e                   pop    %r14
    0.00 :	  6744e9:       c9                      leaveq 
    0.00 :	  6744ea:       c3                      retq   
    0.00 :	  6744eb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
         :	                WaitIO(buf);
         :	        }
         :
         :	        /* Once we get here, there is definitely no I/O active on this buffer */
         :
         :	        if (forInput ? (buf->flags & BM_VALID) : !(buf->flags & BM_DIRTY))
    0.00 :	  6744f0:       0f b7 43 14             movzwl 0x14(%rbx),%eax
    0.00 :	  6744f4:       f7 d0                   not    %eax
    0.00 :	  6744f6:       83 e0 01                and    $0x1,%eax
    0.00 :	  6744f9:       84 c0                   test   %al,%al
    0.00 :	  6744fb:       74 c3                   je     6744c0 <StartBufferIO+0x80>
         :	        {
         :	                /* someone else already did the I/O */
         :	                UnlockBufHdr(buf);
    0.00 :	  6744fd:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	                LWLockRelease(buf->io_in_progress_lock);
    0.00 :	  674501:       48 8b 7b 30             mov    0x30(%rbx),%rdi
    0.00 :	  674505:       e8 96 ae 01 00          callq  68f3a0 <LWLockRelease>
         :
         :	        InProgressBuf = buf;
         :	        IsForInput = forInput;
         :
         :	        return true;
         :	}
    0.00 :	  67450a:       5b                      pop    %rbx
    0.00 :	  67450b:       41 5c                   pop    %r12
    0.00 :	  67450d:       41 5d                   pop    %r13
         :
         :	        if (forInput ? (buf->flags & BM_VALID) : !(buf->flags & BM_DIRTY))
         :	        {
         :	                /* someone else already did the I/O */
         :	                UnlockBufHdr(buf);
         :	                LWLockRelease(buf->io_in_progress_lock);
    0.00 :	  67450f:       31 c0                   xor    %eax,%eax
         :
         :	        InProgressBuf = buf;
         :	        IsForInput = forInput;
         :
         :	        return true;
         :	}
    0.00 :	  674511:       41 5e                   pop    %r14
    0.00 :	  674513:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2812
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674b60 <IncrBufferRefCount>:
         :	 *              This function cannot be used on a buffer we do not have pinned,
         :	 *              because it doesn't change the shared buffer state.
         :	 */
         :	void
         :	IncrBufferRefCount(Buffer buffer)
         :	{
    0.00 :	  674b60:       55                      push   %rbp
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2812
  100.00 :	  674b61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674b64:       53                      push   %rbx
    0.00 :	  674b65:       89 fb                   mov    %edi,%ebx
    0.00 :	  674b67:       48 83 ec 08             sub    $0x8,%rsp
         :	        Assert(BufferIsPinned(buffer));
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
    0.00 :	  674b6b:       48 8b 3d 4e 5d 54 00    mov    0x545d4e(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674b72:       e8 f9 62 12 00          callq  79ae70 <ResourceOwnerEnlargeBuffers>
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);
    0.00 :	  674b77:       48 8b 3d 42 5d 54 00    mov    0x545d42(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674b7e:       89 de                   mov    %ebx,%esi
    0.00 :	  674b80:       e8 1b 56 12 00          callq  79a1a0 <ResourceOwnerRememberBuffer>
         :	        if (BufferIsLocal(buffer))
    0.00 :	  674b85:       85 db                   test   %ebx,%ebx
    0.00 :	  674b87:       78 1f                   js     674ba8 <IncrBufferRefCount+0x48>
         :	                LocalRefCount[-buffer - 1]++;
         :	        else
         :	        {
         :	                PrivateRefCountEntry *ref;
         :	                ref = GetPrivateRefCountEntry(buffer, false, true);
    0.00 :	  674b89:       89 df                   mov    %ebx,%edi
    0.00 :	  674b8b:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  674b90:       31 f6                   xor    %esi,%esi
    0.00 :	  674b92:       e8 89 f9 ff ff          callq  674520 <GetPrivateRefCountEntry>
         :	                Assert(ref != NULL);
         :	                ref->refcount++;
    0.00 :	  674b97:       83 40 04 01             addl   $0x1,0x4(%rax)
         :	        }
         :	}
    0.00 :	  674b9b:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674b9f:       5b                      pop    %rbx
    0.00 :	  674ba0:       c9                      leaveq 
    0.00 :	  674ba1:       c3                      retq   
    0.00 :	  674ba2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :	{
         :	        Assert(BufferIsPinned(buffer));
         :	        ResourceOwnerEnlargeBuffers(CurrentResourceOwner);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);
         :	        if (BufferIsLocal(buffer))
         :	                LocalRefCount[-buffer - 1]++;
    0.00 :	  674ba8:       f7 d3                   not    %ebx
    0.00 :	  674baa:       48 63 c3                movslq %ebx,%rax
    0.00 :	  674bad:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  674bb1:       48 03 05 68 85 50 00    add    0x508568(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  674bb8:       83 00 01                addl   $0x1,(%rax)
         :	                PrivateRefCountEntry *ref;
         :	                ref = GetPrivateRefCountEntry(buffer, false, true);
         :	                Assert(ref != NULL);
         :	                ref->refcount++;
         :	        }
         :	}
    0.00 :	  674bbb:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674bbf:       5b                      pop    %rbx
    0.00 :	  674bc0:       c9                      leaveq 

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1335
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674bd0 <PinBuffer_Locked>:
         :	 * to save a spin lock/unlock cycle, because we need to pin a buffer before
         :	 * its state can change under us.
         :	 */
         :	static void
         :	PinBuffer_Locked(volatile BufferDesc *buf)
         :	{
    0.00 :	  674bd0:       55                      push   %rbp
         :	        int                     b = buf->buf_id;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674bd1:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	  674bd6:       be 01 00 00 00          mov    $0x1,%esi
         :	 * to save a spin lock/unlock cycle, because we need to pin a buffer before
         :	 * its state can change under us.
         :	 */
         :	static void
         :	PinBuffer_Locked(volatile BufferDesc *buf)
         :	{
    0.00 :	  674bdb:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674bde:       53                      push   %rbx
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:1335
  100.00 :	  674bdf:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  674be2:       48 83 ec 08             sub    $0x8,%rsp
         :	        int                     b = buf->buf_id;
    0.00 :	  674be6:       8b 7f 24                mov    0x24(%rdi),%edi
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674be9:       83 c7 01                add    $0x1,%edi
    0.00 :	  674bec:       e8 2f f9 ff ff          callq  674520 <GetPrivateRefCountEntry>
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674bf1:       8b 48 04                mov    0x4(%rax),%ecx
         :	PinBuffer_Locked(volatile BufferDesc *buf)
         :	{
         :	        int                     b = buf->buf_id;
         :	        PrivateRefCountEntry *ref;
         :
         :	        ref = GetPrivateRefCountEntry(b + 1, true, true);
    0.00 :	  674bf4:       48 89 c2                mov    %rax,%rdx
         :
         :	        if (ref->refcount == 0)
    0.00 :	  674bf7:       85 c9                   test   %ecx,%ecx
    0.00 :	  674bf9:       75 09                   jne    674c04 <PinBuffer_Locked+0x34>
         :	                buf->refcount++;
    0.00 :	  674bfb:       8b 43 18                mov    0x18(%rbx),%eax
    0.00 :	  674bfe:       83 c0 01                add    $0x1,%eax
    0.00 :	  674c01:       89 43 18                mov    %eax,0x18(%rbx)
         :	        UnlockBufHdr(buf);
    0.00 :	  674c04:       c6 43 20 00             movb   $0x0,0x20(%rbx)
         :	        ref->refcount++;
    0.00 :	  674c08:       83 42 04 01             addl   $0x1,0x4(%rdx)
         :	        Assert(ref->refcount > 0);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner,
    0.00 :	  674c0c:       8b 73 24                mov    0x24(%rbx),%esi
    0.00 :	  674c0f:       48 8b 3d aa 5c 54 00    mov    0x545caa(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
         :	                                                                BufferDescriptorGetBuffer(buf));
         :	}
    0.00 :	  674c16:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  674c1a:       5b                      pop    %rbx
    0.00 :	  674c1b:       c9                      leaveq 
         :	        if (ref->refcount == 0)
         :	                buf->refcount++;
         :	        UnlockBufHdr(buf);
         :	        ref->refcount++;
         :	        Assert(ref->refcount > 0);
         :	        ResourceOwnerRememberBuffer(CurrentResourceOwner,
    0.00 :	  674c1c:       83 c6 01                add    $0x1,%esi
    0.00 :	  674c1f:       e9 7c 55 12 00          jmpq   79a1a0 <ResourceOwnerRememberBuffer>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2771
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000674e60 <ReleaseBuffer>:
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e60:       55                      push   %rbp
    0.00 :	  674e61:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  674e64:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  674e68:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  674e6c:       48 83 ec 10             sub    $0x10,%rsp
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e70:       85 ff                   test   %edi,%edi
         :	/*
         :	 * ReleaseBuffer -- release the pin on a buffer
         :	 */
         :	void
         :	ReleaseBuffer(Buffer buffer)
         :	{
    0.00 :	  674e72:       89 fb                   mov    %edi,%ebx
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
    0.00 :	  674e74:       74 7f                   je     674ef5 <ReleaseBuffer+0x95>
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
         :
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
    0.00 :	  674e76:       89 fe                   mov    %edi,%esi
    0.00 :	  674e78:       48 8b 3d 41 5a 54 00    mov    0x545a41(%rip),%rdi        # bba8c0 <CurrentResourceOwner>
    0.00 :	  674e7f:       e8 7c 5a 12 00          callq  79a900 <ResourceOwnerForgetBuffer>
         :
         :	        if (BufferIsLocal(buffer))
 /home/Computational/mark/src/postgres-andres/src/backend/storage/buffer/bufmgr.c:2771
  100.00 :	  674e84:       85 db                   test   %ebx,%ebx
    0.00 :	  674e86:       78 38                   js     674ec0 <ReleaseBuffer+0x60>
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
    0.00 :	  674e88:       31 d2                   xor    %edx,%edx
    0.00 :	  674e8a:       31 f6                   xor    %esi,%esi
    0.00 :	  674e8c:       89 df                   mov    %ebx,%edi
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
         :	                return;
         :	        }
         :
         :	        bufHdr = &BufferDescriptors[buffer - 1];
    0.00 :	  674e8e:       4c 8b 25 6b ac 54 00    mov    0x54ac6b(%rip),%r12        # bbfb00 <BufferDescriptors>
         :
         :	        ref = GetPrivateRefCountEntry(buffer, false, false);
    0.00 :	  674e95:       e8 86 f6 ff ff          callq  674520 <GetPrivateRefCountEntry>
    0.00 :	  674e9a:       48 89 c2                mov    %rax,%rdx
         :	        Assert(ref != NULL);
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
    0.00 :	  674e9d:       8b 40 04                mov    0x4(%rax),%eax
    0.00 :	  674ea0:       83 f8 01                cmp    $0x1,%eax
    0.00 :	  674ea3:       7e 33                   jle    674ed8 <ReleaseBuffer+0x78>
         :	                ref->refcount--;
    0.00 :	  674ea5:       83 e8 01                sub    $0x1,%eax
    0.00 :	  674ea8:       89 42 04                mov    %eax,0x4(%rdx)
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674eab:       48 8b 1c 24             mov    (%rsp),%rbx
    0.00 :	  674eaf:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eb4:       c9                      leaveq 
    0.00 :	  674eb5:       c3                      retq   
    0.00 :	  674eb6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  674ebd:       00 00 00 
         :	        ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);
         :
         :	        if (BufferIsLocal(buffer))
         :	        {
         :	                Assert(LocalRefCount[-buffer - 1] > 0);
         :	                LocalRefCount[-buffer - 1]--;
    0.00 :	  674ec0:       f7 d3                   not    %ebx
    0.00 :	  674ec2:       48 63 c3                movslq %ebx,%rax
    0.00 :	  674ec5:       48 c1 e0 02             shl    $0x2,%rax
    0.00 :	  674ec9:       48 03 05 50 82 50 00    add    0x508250(%rip),%rax        # b7d120 <LocalRefCount>
    0.00 :	  674ed0:       83 28 01                subl   $0x1,(%rax)
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
         :	}
    0.00 :	  674ed3:       eb d6                   jmp    674eab <ReleaseBuffer+0x4b>
    0.00 :	  674ed5:       0f 1f 00                nopl   (%rax)
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ed8:       48 63 c3                movslq %ebx,%rax
         :	}
    0.00 :	  674edb:       48 8b 1c 24             mov    (%rsp),%rbx
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674edf:       31 f6                   xor    %esi,%esi
    0.00 :	  674ee1:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	  674ee5:       49 8d 7c 04 c0          lea    -0x40(%r12,%rax,1),%rdi
         :	}
    0.00 :	  674eea:       4c 8b 64 24 08          mov    0x8(%rsp),%r12
    0.00 :	  674eef:       c9                      leaveq 
         :	        Assert(ref->refcount > 0);
         :
         :	        if (ref->refcount > 1)
         :	                ref->refcount--;
         :	        else
         :	                UnpinBuffer(bufHdr, false);
    0.00 :	  674ef0:       e9 3b fe ff ff          jmpq   674d30 <UnpinBuffer>
         :	{
         :	        volatile BufferDesc *bufHdr;
         :	        PrivateRefCountEntry *ref;
         :
         :	        if (!BufferIsValid(buffer))
         :	                elog(ERROR, "bad buffer ID: %d", buffer);
    0.00 :	  674ef5:       ba 34 a0 8a 00          mov    $0x8aa034,%edx
    0.00 :	  674efa:       be cf 0a 00 00          mov    $0xacf,%esi
    0.00 :	  674eff:       bf 53 9d 8a 00          mov    $0x8a9d53,%edi
    0.00 :	  674f04:       e8 17 65 10 00          callq  77b420 <elog_start>
    0.00 :	  674f09:       31 d2                   xor    %edx,%edx
    0.00 :	  674f0b:       be 5c 9d 8a 00          mov    $0x8a9d5c,%esi
    0.00 :	  674f10:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  674f15:       31 c0                   xor    %eax,%eax
    0.00 :	  674f17:       e8 14 63 10 00          callq  77b230 <elog_finish>
    0.00 :	  674f1c:       e8 af 45 df ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3089
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000069b9e0 <check_stack_depth>:
         :	 * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves
         :	 * before hitting the hardware limit.
         :	 */
         :	void
         :	check_stack_depth(void)
         :	{
    0.00 :	  69b9e0:       55                      push   %rbp
    0.00 :	  69b9e1:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  69b9e4:       48 89 5d f0             mov    %rbx,-0x10(%rbp)
    0.00 :	  69b9e8:       4c 89 65 f8             mov    %r12,-0x8(%rbp)
    0.00 :	  69b9ec:       48 83 ec 20             sub    $0x20,%rsp
         :	        long            stack_depth;
         :
         :	        /*
         :	         * Compute distance from reference point to my local variables
         :	         */
         :	        stack_depth = (long) (stack_base_ptr - &stack_top_loc);
    0.00 :	  69b9f0:       48 8b 0d f9 2d 4e 00    mov    0x4e2df9(%rip),%rcx        # b7e7f0 <stack_base_ptr>
    0.00 :	  69b9f7:       48 8d 45 ef             lea    -0x11(%rbp),%rax
    0.00 :	  69b9fb:       48 89 ca                mov    %rcx,%rdx
    0.00 :	  69b9fe:       48 29 c2                sub    %rax,%rdx
    0.00 :	  69ba01:       48 89 d0                mov    %rdx,%rax
         :	         * The test on stack_base_ptr prevents us from erroring out if called
         :	         * during process setup or in a non-backend process.  Logically it should
         :	         * be done first, but putting it here avoids wasting cycles during normal
         :	         * cases.
         :	         */
         :	        if (stack_depth > max_stack_depth_bytes &&
    0.00 :	  69ba04:       48 c1 fa 3f             sar    $0x3f,%rdx
    0.00 :	  69ba08:       48 31 d0                xor    %rdx,%rax
 /home/Computational/mark/src/postgres-andres/src/backend/tcop/postgres.c:3089
  100.00 :	  69ba0b:       48 29 d0                sub    %rdx,%rax
    0.00 :	  69ba0e:       48 39 05 a3 cd 4c 00    cmp    %rax,0x4ccda3(%rip)        # b687b8 <max_stack_depth_bytes>
    0.00 :	  69ba15:       7d 05                   jge    69ba1c <check_stack_depth+0x3c>
    0.00 :	  69ba17:       48 85 c9                test   %rcx,%rcx
    0.00 :	  69ba1a:       75 0a                   jne    69ba26 <check_stack_depth+0x46>
         :	                                 errhint("Increase the configuration parameter \"max_stack_depth\" (currently %dkB), "
         :	                          "after ensuring the platform's stack depth limit is adequate.",
         :	                                                 max_stack_depth)));
         :	        }
         :	#endif   /* IA64 */
         :	}
    0.00 :	  69ba1c:       48 8b 5d f0             mov    -0x10(%rbp),%rbx
    0.00 :	  69ba20:       4c 8b 65 f8             mov    -0x8(%rbp),%r12
    0.00 :	  69ba24:       c9                      leaveq 
    0.00 :	  69ba25:       c3                      retq   
         :	         * cases.
         :	         */
         :	        if (stack_depth > max_stack_depth_bytes &&
         :	                stack_base_ptr != NULL)
         :	        {
         :	                ereport(ERROR,
    0.00 :	  69ba26:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  69ba29:       b9 e0 00 8b 00          mov    $0x8b00e0,%ecx
    0.00 :	  69ba2e:       ba 19 0c 00 00          mov    $0xc19,%edx
    0.00 :	  69ba33:       be d0 e8 8a 00          mov    $0x8ae8d0,%esi
    0.00 :	  69ba38:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  69ba3d:       e8 7e f0 0d 00          callq  77aac0 <errstart>
    0.00 :	  69ba42:       84 c0                   test   %al,%al
    0.00 :	  69ba44:       75 05                   jne    69ba4b <check_stack_depth+0x6b>
    0.00 :	  69ba46:       e8 85 da dc ff          callq  4694d0 <abort@plt>
    0.00 :	  69ba4b:       8b 35 5b cd 4c 00       mov    0x4ccd5b(%rip),%esi        # b687ac <max_stack_depth>
    0.00 :	  69ba51:       bf 60 f0 8a 00          mov    $0x8af060,%edi
    0.00 :	  69ba56:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba58:       e8 43 02 0e 00          callq  77bca0 <errhint>
    0.00 :	  69ba5d:       bf 00 ea 8a 00          mov    $0x8aea00,%edi
    0.00 :	  69ba62:       41 89 c4                mov    %eax,%r12d
    0.00 :	  69ba65:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba67:       e8 34 0e 0e 00          callq  77c8a0 <errmsg>
    0.00 :	  69ba6c:       bf 05 01 00 01          mov    $0x1000105,%edi
    0.00 :	  69ba71:       89 c3                   mov    %eax,%ebx
    0.00 :	  69ba73:       e8 d8 12 0e 00          callq  77cd50 <errcode>
    0.00 :	  69ba78:       44 89 e2                mov    %r12d,%edx
    0.00 :	  69ba7b:       89 c7                   mov    %eax,%edi
    0.00 :	  69ba7d:       89 de                   mov    %ebx,%esi
    0.00 :	  69ba7f:       31 c0                   xor    %eax,%eax
    0.00 :	  69ba81:       e8 5a eb 0d 00          callq  77a5e0 <errfinish>
    0.00 :	  69ba86:       eb be                   jmp    69ba46 <check_stack_depth+0x66>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/date.c:321
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000006c6b10 <date_le>:
         :	        PG_RETURN_BOOL(dateVal1 < dateVal2);
         :	}
         :
         :	Datum
         :	date_le(PG_FUNCTION_ARGS)
         :	{
 /home/Computational/mark/src/postgres-andres/src/backend/utils/adt/date.c:321
  100.00 :	  6c6b10:       48 8b 47 28             mov    0x28(%rdi),%rax
    0.00 :	  6c6b14:       39 47 20                cmp    %eax,0x20(%rdi)
    0.00 :	  6c6b17:       55                      push   %rbp
    0.00 :	  6c6b18:       48 89 e5                mov    %rsp,%rbp
         :	        DateADT         dateVal1 = PG_GETARG_DATEADT(0);
         :	        DateADT         dateVal2 = PG_GETARG_DATEADT(1);
         :
         :	        PG_RETURN_BOOL(dateVal1 <= dateVal2);
         :	}
    0.00 :	  6c6b1b:       c9                      leaveq 
         :	        PG_RETURN_BOOL(dateVal1 < dateVal2);
         :	}
         :
         :	Datum
         :	date_le(PG_FUNCTION_ARGS)
         :	{
    0.00 :	  6c6b1c:       0f 9e c0                setle  %al
    0.00 :	  6c6b1f:       0f b6 c0                movzbl %al,%eax

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:855
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000784050 <hash_search_with_hash_value>:
         :	hash_search_with_hash_value(HTAB *hashp,
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
    0.00 :	  784050:       55                      push   %rbp
    0.00 :	  784051:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  784054:       41 57                   push   %r15
    0.00 :	  784056:       41 89 d7                mov    %edx,%r15d
    0.00 :	  784059:       41 56                   push   %r14
    0.00 :	  78405b:       49 89 fe                mov    %rdi,%r14
    0.00 :	  78405e:       41 55                   push   %r13
    0.00 :	  784060:       41 54                   push   %r12
    0.00 :	  784062:       53                      push   %rbx
    0.00 :	  784063:       48 83 ec 68             sub    $0x68,%rsp
    0.00 :	  784067:       89 8d 7c ff ff ff       mov    %ecx,-0x84(%rbp)
    0.00 :	  78406d:       48 89 75 80             mov    %rsi,-0x80(%rbp)
    0.00 :	  784071:       4c 89 85 70 ff ff ff    mov    %r8,-0x90(%rbp)
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784078:       48 8b 07                mov    (%rdi),%rax
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  78407b:       83 f9 03                cmp    $0x3,%ecx
    0.00 :	  78407e:       0f 94 45 8f             sete   -0x71(%rbp)
    0.00 :	  784082:       83 e9 01                sub    $0x1,%ecx
         :	                                                        const void *keyPtr,
         :	                                                        uint32 hashvalue,
         :	                                                        HASHACTION action,
         :	                                                        bool *foundPtr)
         :	{
         :	        HASHHDR    *hctl = hashp->hctl;
    0.00 :	  784085:       48 89 45 90             mov    %rax,-0x70(%rbp)
         :	         * NOTE: failure to expand table is not a fatal error, it just means we
         :	         * have to run at higher fill factor than we wanted.  However, if we're
         :	         * using the palloc allocator then it will throw error anyway on
         :	         * out-of-memory, so we must do this before modifying the table.
         :	         */
         :	        if (action == HASH_ENTER || action == HASH_ENTER_NULL)
    0.00 :	  784089:       0f 84 d9 00 00 00       je     784168 <hash_search_with_hash_value+0x118>
    0.00 :	  78408f:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  784093:       0f 85 cf 00 00 00       jne    784168 <hash_search_with_hash_value+0x118>
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
         :	        *newlink = NULL;
    0.00 :	  784099:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78409c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  7840a0:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7840a4:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  7840a8:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  7840ac:       44 89 fb                mov    %r15d,%ebx
    0.00 :	  7840af:       23 5a 2c                and    0x2c(%rdx),%ebx
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7840b2:       39 f3                   cmp    %esi,%ebx
    0.00 :	  7840b4:       76 03                   jbe    7840b9 <hash_search_with_hash_value+0x69>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7840b6:       23 5a 30                and    0x30(%rdx),%ebx
         :	        bucket = calc_bucket(hctl, hashvalue);
         :
         :	        segment_num = bucket >> hashp->sshift;
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
    0.00 :	  7840b9:       89 d8                   mov    %ebx,%eax
    0.00 :	  7840bb:       49 8b 56 08             mov    0x8(%r14),%rdx
    0.00 :	  7840bf:       d3 e8                   shr    %cl,%eax
    0.00 :	  7840c1:       89 c0                   mov    %eax,%eax
    0.00 :	  7840c3:       4c 8b 24 c2             mov    (%rdx,%rax,8),%r12
         :
         :	        if (segp == NULL)
    0.00 :	  7840c7:       4d 85 e4                test   %r12,%r12
    0.00 :	  7840ca:       0f 84 b7 02 00 00       je     784387 <hash_search_with_hash_value+0x337>
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d0:       89 d8                   mov    %ebx,%eax
    0.00 :	  7840d2:       44 21 e8                and    %r13d,%eax
         :	        currBucket = *prevBucketPtr;
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
    0.00 :	  7840d5:       4d 8b 6e 18             mov    0x18(%r14),%r13
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
    0.00 :	  7840d9:       4d 8d 24 c4             lea    (%r12,%rax,8),%r12
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
    0.00 :	  7840dd:       49 8b 46 48             mov    0x48(%r14),%rax
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
         :
         :	        prevBucketPtr = &segp[segment_ndx];
         :	        currBucket = *prevBucketPtr;
    0.00 :	  7840e1:       49 8b 1c 24             mov    (%r12),%rbx
         :
         :	        /*
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
    0.00 :	  7840e5:       48 89 45 98             mov    %rax,-0x68(%rbp)
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840e9:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840ec:       75 0d                   jne    7840fb <hash_search_with_hash_value+0xab>
    0.00 :	  7840ee:       eb 28                   jmp    784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
         :	                        match(ELEMENTKEY(currBucket), keyPtr, keysize) == 0)
         :	                        break;
         :	                prevBucketPtr = &(currBucket->link);
    0.00 :	  7840f0:       49 89 dc                mov    %rbx,%r12
         :	                currBucket = *prevBucketPtr;
    0.00 :	  7840f3:       48 8b 1b                mov    (%rbx),%rbx
         :	         * Follow collision chain looking for matching key
         :	         */
         :	        match = hashp->match;           /* save one fetch in inner loop */
         :	        keysize = hashp->keysize;       /* ditto */
         :
         :	        while (currBucket != NULL)
    0.00 :	  7840f6:       48 85 db                test   %rbx,%rbx
    0.00 :	  7840f9:       74 1d                   je     784118 <hash_search_with_hash_value+0xc8>
         :	        {
         :	                if (currBucket->hashvalue == hashvalue &&
    0.00 :	  7840fb:       44 39 7b 08             cmp    %r15d,0x8(%rbx)
    0.00 :	  7840ff:       90                      nop
    0.00 :	  784100:       75 ee                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784102:       48 8d 7b 10             lea    0x10(%rbx),%rdi
    0.00 :	  784106:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  78410a:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78410e:       41 ff d5                callq  *%r13
    0.00 :	  784111:       85 c0                   test   %eax,%eax
    0.00 :	  784113:       75 db                   jne    7840f0 <hash_search_with_hash_value+0xa0>
    0.00 :	  784115:       0f 1f 00                nopl   (%rax)
         :	                hash_collisions++;
         :	                hctl->collisions++;
         :	#endif
         :	        }
         :
         :	        if (foundPtr)
    0.00 :	  784118:       48 83 bd 70 ff ff ff    cmpq   $0x0,-0x90(%rbp)
    0.00 :	  78411f:       00 
    0.00 :	  784120:       74 0d                   je     78412f <hash_search_with_hash_value+0xdf>
         :	                *foundPtr = (bool) (currBucket != NULL);
    0.00 :	  784122:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	  784129:       48 85 db                test   %rbx,%rbx
    0.00 :	  78412c:       0f 95 02                setne  (%rdx)
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  78412f:       83 bd 7c ff ff ff 01    cmpl   $0x1,-0x84(%rbp)
    0.00 :	  784136:       0f 84 5c 01 00 00       je     784298 <hash_search_with_hash_value+0x248>
    0.00 :	  78413c:       0f 83 ee 00 00 00       jae    784230 <hash_search_with_hash_value+0x1e0>
         :	        {
         :	                case HASH_FIND:
         :	                        if (currBucket != NULL)
    0.00 :	  784142:       48 85 db                test   %rbx,%rbx
    0.00 :	  784145:       0f 84 35 02 00 00       je     784380 <hash_search_with_hash_value+0x330>
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
    0.00 :	  78414b:       48 83 c3 10             add    $0x10,%rbx
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  78414f:       48 83 c4 68             add    $0x68,%rsp
    0.00 :	  784153:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784156:       5b                      pop    %rbx
    0.00 :	  784157:       41 5c                   pop    %r12
    0.00 :	  784159:       41 5d                   pop    %r13
    0.00 :	  78415b:       41 5e                   pop    %r14
    0.00 :	  78415d:       41 5f                   pop    %r15
    0.00 :	  78415f:       c9                      leaveq 
    0.00 :	  784160:       c3                      retq   
    0.00 :	  784161:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784168:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78416c:       48 83 7a 48 00          cmpq   $0x0,0x48(%rdx)
    0.00 :	  784171:       0f 85 09 01 00 00       jne    784280 <hash_search_with_hash_value+0x230>
    0.00 :	  784177:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  78417c:       0f 85 e6 01 00 00       jne    784368 <hash_search_with_hash_value+0x318>
    0.00 :	  784182:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784186:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78418a:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  78418d:       8d 56 01                lea    0x1(%rsi),%edx
    0.00 :	  784190:       41 89 f0                mov    %esi,%r8d
    0.00 :	  784193:       89 55 d4                mov    %edx,-0x2c(%rbp)
    0.00 :	  784196:       41 89 d4                mov    %edx,%r12d
    0.00 :	  784199:       48 8b 50 08             mov    0x8(%rax),%rdx
    0.00 :	  78419d:       48 89 d0                mov    %rdx,%rax
    0.00 :	  7841a0:       48 c1 fa 3f             sar    $0x3f,%rdx
    0.00 :	  7841a4:       49 f7 fc                idiv   %r12
 /home/Computational/mark/src/postgres-andres/src/backend/utils/hash/dynahash.c:855
  100.00 :	  7841a7:       48 3b 43 50             cmp    0x50(%rbx),%rax
    0.00 :	  7841ab:       0f 8c eb fe ff ff       jl     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841b1:       8b 3d 09 5a 43 00       mov    0x435a09(%rip),%edi        # bb9bc0 <num_seq_scans>
    0.00 :	  7841b7:       85 ff                   test   %edi,%edi
    0.00 :	  7841b9:       7e 2c                   jle    7841e7 <hash_search_with_hash_value+0x197>
         :	        {
         :	                if (seq_scan_tables[i] == hashp)
    0.00 :	  7841bb:       31 d2                   xor    %edx,%edx
    0.00 :	  7841bd:       4c 3b 35 1c 5a 43 00    cmp    0x435a1c(%rip),%r14        # bb9be0 <seq_scan_tables>
    0.00 :	  7841c4:       b9 e8 9b bb 00          mov    $0xbb9be8,%ecx
    0.00 :	  7841c9:       75 15                   jne    7841e0 <hash_search_with_hash_value+0x190>
    0.00 :	  7841cb:       e9 cc fe ff ff          jmpq   78409c <hash_search_with_hash_value+0x4c>
    0.00 :	  7841d0:       48 8b 01                mov    (%rcx),%rax
    0.00 :	  7841d3:       48 83 c1 08             add    $0x8,%rcx
    0.00 :	  7841d7:       49 39 c6                cmp    %rax,%r14
    0.00 :	  7841da:       0f 84 bc fe ff ff       je     78409c <hash_search_with_hash_value+0x4c>
         :	static bool
         :	has_seq_scans(HTAB *hashp)
         :	{
         :	        int                     i;
         :
         :	        for (i = 0; i < num_seq_scans; i++)
    0.00 :	  7841e0:       83 c2 01                add    $0x1,%edx
    0.00 :	  7841e3:       39 fa                   cmp    %edi,%edx
    0.00 :	  7841e5:       7c e9                   jl     7841d0 <hash_search_with_hash_value+0x180>
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841e7:       49 8b 46 50             mov    0x50(%r14),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841eb:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  7841ef:       4c 89 e3                mov    %r12,%rbx
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
    0.00 :	  7841f2:       4c 8d 68 ff             lea    -0x1(%rax),%r13
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  7841f6:       48 8b 45 90             mov    -0x70(%rbp),%rax
         :	#ifdef HASH_STATISTICS
         :	        hash_expansions++;
         :	#endif
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
    0.00 :	  7841fa:       48 d3 fb                sar    %cl,%rbx
    0.00 :	  7841fd:       48 89 5d c0             mov    %rbx,-0x40(%rbp)
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784201:       48 3b 58 20             cmp    0x20(%rax),%rbx
    0.00 :	  784205:       0f 8c 05 02 00 00       jl     784410 <hash_search_with_hash_value+0x3c0>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
    0.00 :	  78420b:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  78420f:       48 8b 58 18             mov    0x18(%rax),%rbx
    0.00 :	  784213:       48 39 5d c0             cmp    %rbx,-0x40(%rbp)
    0.00 :	  784217:       0f 8c 1d 03 00 00       jl     78453a <hash_search_with_hash_value+0x4ea>
         :	        HASHSEGMENT *old_p;
         :	        long            new_dsize;
         :	        long            old_dirsize;
         :	        long            new_dirsize;
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
    0.00 :	  78421d:       48 83 78 58 ff          cmpq   $0xffffffffffffffff,0x58(%rax)
    0.00 :	  784222:       0f 84 4a 03 00 00       je     784572 <hash_search_with_hash_value+0x522>
         :	                hashp->dir = p;
         :	                hashp->hctl->dsize = new_dsize;
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784228:       44 89 c6                mov    %r8d,%esi
    0.00 :	  78422b:       e9 78 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                *foundPtr = (bool) (currBucket != NULL);
         :
         :	        /*
         :	         * OK, now what?
         :	         */
         :	        switch (action)
    0.00 :	  784230:       83 bd 7c ff ff ff 02    cmpl   $0x2,-0x84(%rbp)
    0.00 :	  784237:       0f 84 d6 00 00 00       je     784313 <hash_search_with_hash_value+0x2c3>
    0.00 :	  78423d:       83 bd 7c ff ff ff 03    cmpl   $0x3,-0x84(%rbp)
    0.00 :	  784244:       74 52                   je     784298 <hash_search_with_hash_value+0x248>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784246:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  78424b:       be df 03 00 00          mov    $0x3df,%esi
    0.00 :	  784250:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  784255:       e8 c6 71 ff ff          callq  77b420 <elog_start>
    0.00 :	  78425a:       8b 95 7c ff ff ff       mov    -0x84(%rbp),%edx
    0.00 :	  784260:       be f0 5a 8d 00          mov    $0x8d5af0,%esi
    0.00 :	  784265:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78426a:       31 c0                   xor    %eax,%eax
    0.00 :	  78426c:       e8 bf 6f ff ff          callq  77b230 <elog_finish>
    0.00 :	  784271:       e8 5a 52 ce ff          callq  4694d0 <abort@plt>
    0.00 :	  784276:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	  78427d:       00 00 00 
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784280:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784284:       8b 72 28                mov    0x28(%rdx),%esi
    0.00 :	  784287:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  78428b:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78428f:       e9 14 fe ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
    0.00 :	  784294:       0f 1f 40 00             nopl   0x0(%rax)
         :	                        Assert(hashp->alloc != DynaHashAlloc);
         :	                        /* FALL THRU */
         :
         :	                case HASH_ENTER:
         :	                        /* Return existing element if found, else create one */
         :	                        if (currBucket != NULL)
    0.00 :	  784298:       48 85 db                test   %rbx,%rbx
    0.00 :	  78429b:       0f 85 aa fe ff ff       jne    78414b <hash_search_with_hash_value+0xfb>
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
    0.00 :	  7842a1:       41 80 7e 42 00          cmpb   $0x0,0x42(%r14)
    0.00 :	  7842a6:       0f 85 a3 03 00 00       jne    78464f <hash_search_with_hash_value+0x5ff>
         :	 */
         :	static HASHBUCKET
         :	get_hash_entry(HTAB *hashp)
         :	{
         :	        /* use volatile pointer to prevent code rearrangement */
         :	        volatile HASHHDR *hctlv = hashp->hctl;
    0.00 :	  7842ac:       49 8b 1e                mov    (%r14),%rbx
         :	static __inline__ int
         :	tas(volatile slock_t *lock)
         :	{
         :	        register slock_t _res = 1;
         :
         :	        __asm__ __volatile__(
    0.00 :	  7842af:       41 bd 01 00 00 00       mov    $0x1,%r13d
    0.00 :	  7842b5:       eb 35                   jmp    7842ec <hash_search_with_hash_value+0x29c>
    0.00 :	  7842b7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	  7842be:       00 00 
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
         :	                        SpinLockAcquire(&hctlv->mutex);
         :
         :	                /* try to get an entry from the freelist */
         :	                newElement = hctlv->freeList;
    0.00 :	  7842c0:       48 8b 53 10             mov    0x10(%rbx),%rdx
         :	                if (newElement != NULL)
    0.00 :	  7842c4:       48 85 d2                test   %rdx,%rdx
    0.00 :	  7842c7:       0f 85 04 02 00 00       jne    7844d1 <hash_search_with_hash_value+0x481>
         :	                        break;
         :
         :	                /* no free elements.  allocate another chunk of buckets */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842cd:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842d1:       48 85 c0                test   %rax,%rax
    0.00 :	  7842d4:       74 03                   je     7842d9 <hash_search_with_hash_value+0x289>
         :	                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  7842d6:       c6 03 00                movb   $0x0,(%rbx)
         :
         :	                if (!element_alloc(hashp, hctlv->nelem_alloc))
    0.00 :	  7842d9:       8b 73 6c                mov    0x6c(%rbx),%esi
    0.00 :	  7842dc:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  7842df:       e8 dc fb ff ff          callq  783ec0 <element_alloc>
    0.00 :	  7842e4:       84 c0                   test   %al,%al
    0.00 :	  7842e6:       0f 84 be 00 00 00       je     7843aa <hash_search_with_hash_value+0x35a>
         :	        HASHBUCKET      newElement;
         :
         :	        for (;;)
         :	        {
         :	                /* if partitioned, must lock to touch nentries and freeList */
         :	                if (IS_PARTITIONED(hctlv))
    0.00 :	  7842ec:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7842f0:       48 85 c0                test   %rax,%rax
    0.00 :	  7842f3:       74 cb                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842f5:       44 89 e8                mov    %r13d,%eax
    0.00 :	  7842f8:       f0 86 03                lock xchg %al,(%rbx)
         :	                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  7842fb:       84 c0                   test   %al,%al
    0.00 :	  7842fd:       74 c1                   je     7842c0 <hash_search_with_hash_value+0x270>
    0.00 :	  7842ff:       ba 87 04 00 00          mov    $0x487,%edx
    0.00 :	  784304:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  784309:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78430c:       e8 2f bd f0 ff          callq  690040 <s_lock>
    0.00 :	  784311:       eb ad                   jmp    7842c0 <hash_search_with_hash_value+0x270>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :	                        return NULL;
         :
         :	                case HASH_REMOVE:
         :	                        if (currBucket != NULL)
    0.00 :	  784313:       48 85 db                test   %rbx,%rbx
    0.00 :	  784316:       74 68                   je     784380 <hash_search_with_hash_value+0x330>
         :	                        {
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784318:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  78431c:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784320:       48 85 c0                test   %rax,%rax
    0.00 :	  784323:       74 0c                   je     784331 <hash_search_with_hash_value+0x2e1>
    0.00 :	  784325:       b8 01 00 00 00          mov    $0x1,%eax
    0.00 :	  78432a:       f0 86 02                lock xchg %al,(%rdx)
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  78432d:       84 c0                   test   %al,%al
    0.00 :	  78432f:       75 64                   jne    784395 <hash_search_with_hash_value+0x345>
         :
         :	                                Assert(hctlv->nentries > 0);
         :	                                hctlv->nentries--;
    0.00 :	  784331:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784335:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	  784339:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78433d:       48 89 42 08             mov    %rax,0x8(%rdx)
         :
         :	                                /* remove record from hash bucket's chain. */
         :	                                *prevBucketPtr = currBucket->link;
    0.00 :	  784341:       48 8b 03                mov    (%rbx),%rax
    0.00 :	  784344:       49 89 04 24             mov    %rax,(%r12)
         :
         :	                                /* add the record to the freelist for this table.  */
         :	                                currBucket->link = hctlv->freeList;
    0.00 :	  784348:       48 8b 42 10             mov    0x10(%rdx),%rax
    0.00 :	  78434c:       48 89 03                mov    %rax,(%rbx)
         :	                                hctlv->freeList = currBucket;
    0.00 :	  78434f:       48 89 5a 10             mov    %rbx,0x10(%rdx)
         :
         :	                                if (IS_PARTITIONED(hctlv))
    0.00 :	  784353:       48 8b 42 48             mov    0x48(%rdx),%rax
    0.00 :	  784357:       48 85 c0                test   %rax,%rax
    0.00 :	  78435a:       0f 84 eb fd ff ff       je     78414b <hash_search_with_hash_value+0xfb>
         :	                                        SpinLockRelease(&hctlv->mutex);
    0.00 :	  784360:       c6 02 00                movb   $0x0,(%rdx)
    0.00 :	  784363:       e9 e3 fd ff ff          jmpq   78414b <hash_search_with_hash_value+0xfb>
         :	                /*
         :	                 * Can't split if running in partitioned mode, nor if frozen, nor if
         :	                 * table is the subject of any active hash_seq_search scans.  Strange
         :	                 * order of these tests is to try to check cheaper conditions first.
         :	                 */
         :	                if (!IS_PARTITIONED(hctl) && !hashp->frozen &&
    0.00 :	  784368:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78436c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784370:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784374:       8b 73 28                mov    0x28(%rbx),%esi
    0.00 :	  784377:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  78437b:       e9 28 fd ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>
         :	                         */
         :
         :	                        return (void *) ELEMENTKEY(currBucket);
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
    0.00 :	  784380:       31 db                   xor    %ebx,%ebx
    0.00 :	  784382:       e9 c8 fd ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        segment_ndx = MOD(bucket, hashp->ssize);
         :
         :	        segp = hashp->dir[segment_num];
         :
         :	        if (segp == NULL)
         :	                hash_corrupted(hashp);
    0.00 :	  784387:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  78438a:       e8 01 f8 ff ff          callq  783b90 <hash_corrupted>
    0.00 :	  78438f:       90                      nop
    0.00 :	  784390:       e9 3b fd ff ff          jmpq   7840d0 <hash_search_with_hash_value+0x80>
         :	                                /* use volatile pointer to prevent code rearrangement */
         :	                                volatile HASHHDR *hctlv = hctl;
         :
         :	                                /* if partitioned, must lock to touch nentries and freeList */
         :	                                if (IS_PARTITIONED(hctlv))
         :	                                        SpinLockAcquire(&hctlv->mutex);
    0.00 :	  784395:       48 8b 7d 90             mov    -0x70(%rbp),%rdi
    0.00 :	  784399:       ba 95 03 00 00          mov    $0x395,%edx
    0.00 :	  78439e:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843a3:       e8 98 bc f0 ff          callq  690040 <s_lock>
    0.00 :	  7843a8:       eb 87                   jmp    784331 <hash_search_with_hash_value+0x2e1>
         :
         :	                        currBucket = get_hash_entry(hashp);
         :	                        if (currBucket == NULL)
         :	                        {
         :	                                /* out of memory */
         :	                                if (action == HASH_ENTER_NULL)
    0.00 :	  7843aa:       80 7d 8f 00             cmpb   $0x0,-0x71(%rbp)
    0.00 :	  7843ae:       75 d0                   jne    784380 <hash_search_with_hash_value+0x330>
         :	                                        return NULL;
         :	                                /* report a generic message */
         :	                                if (hashp->isshared)
    0.00 :	  7843b0:       41 80 7e 40 00          cmpb   $0x0,0x40(%r14)
    0.00 :	  7843b5:       0f 1f 00                nopl   (%rax)
    0.00 :	  7843b8:       0f 84 4a 02 00 00       je     784608 <hash_search_with_hash_value+0x5b8>
         :	                                        ereport(ERROR,
    0.00 :	  7843be:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  7843c1:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  7843c6:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  7843cb:       ba c6 03 00 00          mov    $0x3c6,%edx
    0.00 :	  7843d0:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  7843d5:       e8 e6 66 ff ff          callq  77aac0 <errstart>
    0.00 :	  7843da:       84 c0                   test   %al,%al
    0.00 :	  7843dc:       bf 47 ba 8a 00          mov    $0x8aba47,%edi
    0.00 :	  7843e1:       0f 84 8a fe ff ff       je     784271 <hash_search_with_hash_value+0x221>
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  7843e7:       31 c0                   xor    %eax,%eax
    0.00 :	  7843e9:       e8 b2 84 ff ff          callq  77c8a0 <errmsg>
    0.00 :	  7843ee:       bf c5 20 00 00          mov    $0x20c5,%edi
    0.00 :	  7843f3:       89 c3                   mov    %eax,%ebx
    0.00 :	  7843f5:       e8 56 89 ff ff          callq  77cd50 <errcode>
    0.00 :	  7843fa:       89 de                   mov    %ebx,%esi
    0.00 :	  7843fc:       89 c7                   mov    %eax,%edi
    0.00 :	  7843fe:       31 c0                   xor    %eax,%eax
    0.00 :	  784400:       e8 db 61 ff ff          callq  77a5e0 <errfinish>
    0.00 :	  784405:       e9 67 fe ff ff          jmpq   784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78440a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
         :
         :	        new_bucket = hctl->max_bucket + 1;
         :	        new_segnum = new_bucket >> hashp->sshift;
         :	        new_segndx = MOD(new_bucket, hashp->ssize);
         :
         :	        if (new_segnum >= hctl->nsegs)
    0.00 :	  784410:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  784413:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784417:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  78441b:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  78441f:       4d 89 e1                mov    %r12,%r9
         :	                        return false;
         :	                hctl->nsegs++;
         :	        }
         :
         :	        /* OK, we created a new bucket */
         :	        hctl->max_bucket++;
    0.00 :	  784422:       89 43 28                mov    %eax,0x28(%rbx)
         :	         * *Before* changing masks, find old bucket corresponding to same hash
         :	         * values; values in that bucket may need to be relocated to new bucket.
         :	         * Note that new_bucket is certainly larger than low_mask at this point,
         :	         * so we can skip the first step of the regular hash mask calc.
         :	         */
         :	        old_bucket = (new_bucket & hctl->low_mask);
    0.00 :	  784425:       8b 43 30                mov    0x30(%rbx),%eax
    0.00 :	  784428:       49 21 c1                and    %rax,%r9
         :
         :	        /*
         :	         * If we crossed a power of 2, readjust masks.
         :	         */
         :	        if ((uint32) new_bucket > hctl->high_mask)
    0.00 :	  78442b:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  78442e:       39 45 d4                cmp    %eax,-0x2c(%rbp)
    0.00 :	  784431:       76 0c                   jbe    78443f <hash_search_with_hash_value+0x3ef>
         :	        {
         :	                hctl->low_mask = hctl->high_mask;
    0.00 :	  784433:       89 43 30                mov    %eax,0x30(%rbx)
         :	                hctl->high_mask = (uint32) new_bucket | hctl->low_mask;
    0.00 :	  784436:       09 45 d4                or     %eax,-0x2c(%rbp)
    0.00 :	  784439:       8b 45 d4                mov    -0x2c(%rbp),%eax
    0.00 :	  78443c:       89 43 2c                mov    %eax,0x2c(%rbx)
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  78443f:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  784443:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784447:       4c 89 ca                mov    %r9,%rdx
         :	         * that might not be true!
         :	         */
         :	        old_segnum = old_bucket >> hashp->sshift;
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
    0.00 :	  78444a:       49 8b 76 08             mov    0x8(%r14),%rsi
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78444e:       4d 21 ec                and    %r13,%r12
    0.00 :	  784451:       4a 8d 3c e5 00 00 00    lea    0x0(,%r12,8),%rdi
    0.00 :	  784458:       00 
         :	        old_segndx = MOD(old_bucket, hashp->ssize);
         :
         :	        old_seg = hashp->dir[old_segnum];
         :	        new_seg = hashp->dir[new_segnum];
         :
         :	        oldlink = &old_seg[old_segndx];
    0.00 :	  784459:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	  78445d:       48 d3 fa                sar    %cl,%rdx
    0.00 :	  784460:       4c 21 c8                and    %r9,%rax
    0.00 :	  784463:       4c 8d 04 c5 00 00 00    lea    0x0(,%rax,8),%r8
    0.00 :	  78446a:       00 
    0.00 :	  78446b:       4c 03 04 d6             add    (%rsi,%rdx,8),%r8
         :	        newlink = &new_seg[new_segndx];
    0.00 :	  78446f:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	  784473:       48 03 3c 16             add    (%rsi,%rdx,1),%rdi
         :
         :	        for (currElement = *oldlink;
    0.00 :	  784477:       49 8b 10                mov    (%r8),%rdx
         :	                 currElement != NULL;
    0.00 :	  78447a:       48 85 d2                test   %rdx,%rdx
    0.00 :	  78447d:       75 17                   jne    784496 <hash_search_with_hash_value+0x446>
    0.00 :	  78447f:       eb 39                   jmp    7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784481:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
         :	                        *oldlink = currElement;
         :	                        oldlink = &currElement->link;
         :	                }
         :	                else
         :	                {
         :	                        *newlink = currElement;
    0.00 :	  784488:       48 89 17                mov    %rdx,(%rdi)
         :	                        newlink = &currElement->link;
    0.00 :	  78448b:       48 89 d7                mov    %rdx,%rdi
         :
         :	        oldlink = &old_seg[old_segndx];
         :	        newlink = &new_seg[new_segndx];
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
    0.00 :	  78448e:       48 85 c9                test   %rcx,%rcx
    0.00 :	  784491:       74 27                   je     7844ba <hash_search_with_hash_value+0x46a>
    0.00 :	  784493:       48 89 ca                mov    %rcx,%rdx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  784496:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
         :
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
    0.00 :	  78449a:       48 8b 0a                mov    (%rdx),%rcx
         :	static inline uint32
         :	calc_bucket(HASHHDR *hctl, uint32 hash_val)
         :	{
         :	        uint32          bucket;
         :
         :	        bucket = hash_val & hctl->high_mask;
    0.00 :	  78449d:       8b 43 2c                mov    0x2c(%rbx),%eax
    0.00 :	  7844a0:       23 42 08                and    0x8(%rdx),%eax
         :	        if (bucket > hctl->max_bucket)
    0.00 :	  7844a3:       3b 43 28                cmp    0x28(%rbx),%eax
    0.00 :	  7844a6:       76 03                   jbe    7844ab <hash_search_with_hash_value+0x45b>
         :	                bucket = bucket & hctl->low_mask;
    0.00 :	  7844a8:       23 43 30                and    0x30(%rbx),%eax
         :	        for (currElement = *oldlink;
         :	                 currElement != NULL;
         :	                 currElement = nextElement)
         :	        {
         :	                nextElement = currElement->link;
         :	                if ((long) calc_bucket(hctl, currElement->hashvalue) == old_bucket)
    0.00 :	  7844ab:       89 c0                   mov    %eax,%eax
    0.00 :	  7844ad:       49 39 c1                cmp    %rax,%r9
    0.00 :	  7844b0:       75 d6                   jne    784488 <hash_search_with_hash_value+0x438>
         :	                {
         :	                        *oldlink = currElement;
    0.00 :	  7844b2:       49 89 10                mov    %rdx,(%r8)
         :	                        oldlink = &currElement->link;
    0.00 :	  7844b5:       49 89 d0                mov    %rdx,%r8
    0.00 :	  7844b8:       eb d4                   jmp    78448e <hash_search_with_hash_value+0x43e>
         :	                        *newlink = currElement;
         :	                        newlink = &currElement->link;
         :	                }
         :	        }
         :	        /* don't forget to terminate the rebuilt hash chains... */
         :	        *oldlink = NULL;
    0.00 :	  7844ba:       49 c7 00 00 00 00 00    movq   $0x0,(%r8)
         :	        *newlink = NULL;
    0.00 :	  7844c1:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7844c8:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  7844cc:       e9 c8 fb ff ff          jmpq   784099 <hash_search_with_hash_value+0x49>
         :	                        return NULL;
         :	                }
         :	        }
         :
         :	        /* remove entry from freelist, bump nentries */
         :	        hctlv->freeList = newElement->link;
    0.00 :	  7844d1:       48 8b 02                mov    (%rdx),%rax
    0.00 :	  7844d4:       48 89 43 10             mov    %rax,0x10(%rbx)
         :	        hctlv->nentries++;
    0.00 :	  7844d8:       48 8b 43 08             mov    0x8(%rbx),%rax
    0.00 :	  7844dc:       48 83 c0 01             add    $0x1,%rax
    0.00 :	  7844e0:       48 89 43 08             mov    %rax,0x8(%rbx)
         :
         :	        if (IS_PARTITIONED(hctlv))
    0.00 :	  7844e4:       48 8b 43 48             mov    0x48(%rbx),%rax
    0.00 :	  7844e8:       48 85 c0                test   %rax,%rax
    0.00 :	  7844eb:       74 03                   je     7844f0 <hash_search_with_hash_value+0x4a0>
         :	                SpinLockRelease(&hctlv->mutex);
    0.00 :	  7844ed:       c6 03 00                movb   $0x0,(%rbx)
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  7844f0:       48 8d 5a 10             lea    0x10(%rdx),%rbx
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
    0.00 :	  7844f4:       49 89 14 24             mov    %rdx,(%r12)
         :	                        currBucket->link = NULL;
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
    0.00 :	  7844f8:       44 89 7a 08             mov    %r15d,0x8(%rdx)
         :	                                                         errmsg("out of memory")));
         :	                        }
         :
         :	                        /* link into hashbucket chain */
         :	                        *prevBucketPtr = currBucket;
         :	                        currBucket->link = NULL;
    0.00 :	  7844fc:       48 c7 02 00 00 00 00    movq   $0x0,(%rdx)
         :
         :	                        /* copy key into record */
         :	                        currBucket->hashvalue = hashvalue;
         :	                        hashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);
    0.00 :	  784503:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	  784507:       48 8b 75 80             mov    -0x80(%rbp),%rsi
    0.00 :	  78450b:       48 89 df                mov    %rbx,%rdi
    0.00 :	  78450e:       41 ff 56 20             callq  *0x20(%r14)
         :	        }
         :
         :	        elog(ERROR, "unrecognized hash action code: %d", (int) action);
         :
         :	        return NULL;                            /* keep compiler quiet */
         :	}
    0.00 :	  784512:       e9 38 fc ff ff          jmpq   78414f <hash_search_with_hash_value+0xff>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  784517:       31 f6                   xor    %esi,%esi
    0.00 :	  784519:       e8 02 4f ce ff          callq  469420 <memset@plt>
         :	                hashp->dir = p;
    0.00 :	  78451e:       48 8b 45 a8             mov    -0x58(%rbp),%rax
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  784522:       48 8b 55 b8             mov    -0x48(%rbp),%rdx
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
         :	                hashp->dir = p;
    0.00 :	  784526:       49 89 46 08             mov    %rax,0x8(%r14)
         :	                hashp->hctl->dsize = new_dsize;
    0.00 :	  78452a:       49 8b 06                mov    (%r14),%rax
    0.00 :	  78452d:       48 89 50 18             mov    %rdx,0x18(%rax)
         :
         :	                /* XXX assume the allocator is palloc, so we know how to free */
         :	                Assert(hashp->alloc == DynaHashAlloc);
         :	                pfree(old_p);
    0.00 :	  784531:       48 8b 7d b0             mov    -0x50(%rbp),%rdi
    0.00 :	  784535:       e8 46 46 01 00          callq  798b80 <pfree>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78453a:       48 8b 5d c0             mov    -0x40(%rbp),%rbx
    0.00 :	  78453e:       4c 89 f7                mov    %r14,%rdi
    0.00 :	  784541:       48 c1 e3 03             shl    $0x3,%rbx
    0.00 :	  784545:       48 89 5d c8             mov    %rbx,-0x38(%rbp)
    0.00 :	  784549:       49 03 5e 08             add    0x8(%r14),%rbx
    0.00 :	  78454d:       e8 7e fa ff ff          callq  783fd0 <seg_alloc>
    0.00 :	  784552:       48 85 c0                test   %rax,%rax
    0.00 :	  784555:       48 89 03                mov    %rax,(%rbx)
    0.00 :	  784558:       0f 84 1f 01 00 00       je     78467d <hash_search_with_hash_value+0x62d>
         :	                        return false;
         :	                hctl->nsegs++;
    0.00 :	  78455e:       48 8b 55 90             mov    -0x70(%rbp),%rdx
    0.00 :	  784562:       8b 42 28                mov    0x28(%rdx),%eax
    0.00 :	  784565:       48 83 42 20 01          addq   $0x1,0x20(%rdx)
    0.00 :	  78456a:       83 c0 01                add    $0x1,%eax
    0.00 :	  78456d:       e9 a9 fe ff ff          jmpq   78441b <hash_search_with_hash_value+0x3cb>
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784572:       48 8d 14 1b             lea    (%rbx,%rbx,1),%rdx
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
    0.00 :	  784576:       48 89 d8                mov    %rbx,%rax
    0.00 :	  784579:       48 c1 e0 04             shl    $0x4,%rax
    0.00 :	  78457d:       48 89 45 a0             mov    %rax,-0x60(%rbp)
         :
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
    0.00 :	  784581:       48 89 55 b8             mov    %rdx,-0x48(%rbp)
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784585:       49 8b 46 30             mov    0x30(%r14),%rax
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784589:       49 8b 56 08             mov    0x8(%r14),%rdx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78458d:       48 8b 7d a0             mov    -0x60(%rbp),%rdi
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
    0.00 :	  784591:       48 89 55 b0             mov    %rdx,-0x50(%rbp)
         :	        CurrentDynaHashCxt = hashp->hcxt;
    0.00 :	  784595:       48 89 05 2c 56 43 00    mov    %rax,0x43562c(%rip)        # bb9bc8 <CurrentDynaHashCxt>
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  78459c:       41 ff 56 28             callq  *0x28(%r14)
         :
         :	        if (p != NULL)
    0.00 :	  7845a0:       48 85 c0                test   %rax,%rax
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
         :	        new_dirsize = new_dsize * sizeof(HASHSEGMENT);
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
    0.00 :	  7845a3:       48 89 45 a8             mov    %rax,-0x58(%rbp)
         :
         :	        if (p != NULL)
    0.00 :	  7845a7:       0f 84 89 00 00 00       je     784636 <hash_search_with_hash_value+0x5e6>
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845ad:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845b1:       48 8b 75 b0             mov    -0x50(%rbp),%rsi
         :	        if (hashp->hctl->max_dsize != NO_MAX_DSIZE)
         :	                return false;
         :
         :	        /* Reallocate directory */
         :	        new_dsize = hashp->hctl->dsize << 1;
         :	        old_dirsize = hashp->hctl->dsize * sizeof(HASHSEGMENT);
    0.00 :	  7845b5:       48 c1 e3 03             shl    $0x3,%rbx
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
         :	        {
         :	                memcpy(p, old_p, old_dirsize);
    0.00 :	  7845b9:       48 89 da                mov    %rbx,%rdx
    0.00 :	  7845bc:       e8 2f 56 ce ff          callq  469bf0 <memcpy@plt>
         :	                MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);
    0.00 :	  7845c1:       48 8b 7d a8             mov    -0x58(%rbp),%rdi
    0.00 :	  7845c5:       48 8b 55 a0             mov    -0x60(%rbp),%rdx
    0.00 :	  7845c9:       48 01 df                add    %rbx,%rdi
    0.00 :	  7845cc:       48 29 da                sub    %rbx,%rdx
    0.00 :	  7845cf:       40 f6 c7 07             test   $0x7,%dil
    0.00 :	  7845d3:       0f 85 3e ff ff ff       jne    784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845d9:       48 81 fa 00 04 00 00    cmp    $0x400,%rdx
    0.00 :	  7845e0:       0f 87 31 ff ff ff       ja     784517 <hash_search_with_hash_value+0x4c7>
    0.00 :	  7845e6:       48 8d 04 17             lea    (%rdi,%rdx,1),%rax
    0.00 :	  7845ea:       48 39 c7                cmp    %rax,%rdi
    0.00 :	  7845ed:       0f 83 2b ff ff ff       jae    78451e <hash_search_with_hash_value+0x4ce>
    0.00 :	  7845f3:       48 c7 07 00 00 00 00    movq   $0x0,(%rdi)
    0.00 :	  7845fa:       48 83 c7 08             add    $0x8,%rdi
    0.00 :	  7845fe:       48 39 f8                cmp    %rdi,%rax
    0.00 :	  784601:       77 f0                   ja     7845f3 <hash_search_with_hash_value+0x5a3>
    0.00 :	  784603:       e9 16 ff ff ff          jmpq   78451e <hash_search_with_hash_value+0x4ce>
         :	                                if (hashp->isshared)
         :	                                        ereport(ERROR,
         :	                                                        (errcode(ERRCODE_OUT_OF_MEMORY),
         :	                                                         errmsg("out of shared memory")));
         :	                                else
         :	                                        ereport(ERROR,
    0.00 :	  784608:       45 31 c0                xor    %r8d,%r8d
    0.00 :	  78460b:       b9 f0 5b 8d 00          mov    $0x8d5bf0,%ecx
    0.00 :	  784610:       ba ca 03 00 00          mov    $0x3ca,%edx
    0.00 :	  784615:       be 33 59 8d 00          mov    $0x8d5933,%esi
    0.00 :	  78461a:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  78461f:       e8 9c 64 ff ff          callq  77aac0 <errstart>
    0.00 :	  784624:       84 c0                   test   %al,%al
    0.00 :	  784626:       0f 84 45 fc ff ff       je     784271 <hash_search_with_hash_value+0x221>
    0.00 :	  78462c:       bf 04 9c 7b 00          mov    $0x7b9c04,%edi
    0.00 :	  784631:       e9 b1 fd ff ff          jmpq   7843e7 <hash_search_with_hash_value+0x397>
         :
         :	        old_p = hashp->dir;
         :	        CurrentDynaHashCxt = hashp->hcxt;
         :	        p = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);
         :
         :	        if (p != NULL)
    0.00 :	  784636:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78463a:       48 8b 5d 90             mov    -0x70(%rbp),%rbx
    0.00 :	  78463e:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784642:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784646:       44 8b 43 28             mov    0x28(%rbx),%r8d
    0.00 :	  78464a:       e9 d9 fb ff ff          jmpq   784228 <hash_search_with_hash_value+0x1d8>
         :	                        if (currBucket != NULL)
         :	                                return (void *) ELEMENTKEY(currBucket);
         :
         :	                        /* disallow inserts if frozen */
         :	                        if (hashp->frozen)
         :	                                elog(ERROR, "cannot insert into frozen hashtable \"%s\"",
    0.00 :	  78464f:       ba f0 5b 8d 00          mov    $0x8d5bf0,%edx
    0.00 :	  784654:       be ba 03 00 00          mov    $0x3ba,%esi
    0.00 :	  784659:       bf 33 59 8d 00          mov    $0x8d5933,%edi
    0.00 :	  78465e:       e8 bd 6d ff ff          callq  77b420 <elog_start>
    0.00 :	  784663:       49 8b 56 38             mov    0x38(%r14),%rdx
    0.00 :	  784667:       be c0 5a 8d 00          mov    $0x8d5ac0,%esi
    0.00 :	  78466c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  784671:       31 c0                   xor    %eax,%eax
    0.00 :	  784673:       e8 b8 6b ff ff          callq  77b230 <elog_finish>
    0.00 :	  784678:       e8 53 4e ce ff          callq  4694d0 <abort@plt>
         :	        {
         :	                /* Allocate new segment if necessary -- could fail if dir full */
         :	                if (new_segnum >= hctl->dsize)
         :	                        if (!dir_realloc(hashp))
         :	                                return false;
         :	                if (!(hashp->dir[new_segnum] = seg_alloc(hashp)))
    0.00 :	  78467d:       48 8b 45 90             mov    -0x70(%rbp),%rax
    0.00 :	  784681:       41 8b 4e 58             mov    0x58(%r14),%ecx
    0.00 :	  784685:       8b 70 28                mov    0x28(%rax),%esi
    0.00 :	  784688:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	  78468c:       4c 8d 68 ff             lea    -0x1(%rax),%r13
    0.00 :	  784690:       e9 13 fa ff ff          jmpq   7840a8 <hash_search_with_hash_value+0x58>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:705
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798d50 <palloc>:
         :	        return ret;
         :	}
         :
         :	void *
         :	palloc(Size size)
         :	{
    0.00 :	  798d50:       55                      push   %rbp
    0.00 :	  798d51:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  798d54:       53                      push   %rbx
    0.00 :	  798d55:       48 89 fb                mov    %rdi,%rbx
    0.00 :	  798d58:       48 83 ec 08             sub    $0x8,%rsp
         :	        void       *ret;
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
    0.00 :	  798d5c:       48 81 ff ff ff ff 3f    cmp    $0x3fffffff,%rdi
    0.00 :	  798d63:       77 25                   ja     798d8a <palloc+0x3a>
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798d65:       48 8b 05 f4 1a 42 00    mov    0x421af4(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798d6c:       48 89 de                mov    %rbx,%rsi
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798d6f:       c6 40 30 00             movb   $0x0,0x30(%rax)
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798d73:       48 8b 3d e6 1a 42 00    mov    0x421ae6(%rip),%rdi        # bba860 <CurrentMemoryContext>
    0.00 :	  798d7a:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  798d7e:       4c 8b 18                mov    (%rax),%r11
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        return ret;
         :	}
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:705
  100.00 :	  798d81:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	  798d85:       5b                      pop    %rbx
    0.00 :	  798d86:       c9                      leaveq 
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798d87:       41 ff e3                jmpq   *%r11
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
    0.00 :	  798d8a:       ba 18 20 8e 00          mov    $0x8e2018,%edx
    0.00 :	  798d8f:       be b9 02 00 00          mov    $0x2b9,%esi
    0.00 :	  798d94:       bf 8e 1f 8e 00          mov    $0x8e1f8e,%edi
    0.00 :	  798d99:       e8 82 26 fe ff          callq  77b420 <elog_start>
    0.00 :	  798d9e:       48 89 da                mov    %rbx,%rdx
    0.00 :	  798da1:       be b8 1f 8e 00          mov    $0x8e1fb8,%esi
    0.00 :	  798da6:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  798dab:       31 c0                   xor    %eax,%eax
    0.00 :	  798dad:       e8 7e 24 fe ff          callq  77b230 <elog_finish>
    0.00 :	  798db2:       e8 19 07 cd ff          callq  4694d0 <abort@plt>

Sorted summary for file /home/Computational/mark/andres/bin/postgres
----------------------------------------------

  100.00 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:716
 Percent |	Source code & Disassembly of /home/Computational/mark/andres/bin/postgres
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000798f70 <palloc0>:
         :	        return ret;
         :	}
         :
         :	void *
         :	palloc0(Size size)
         :	{
    0.00 :	  798f70:       55                      push   %rbp
         :	        void       *ret;
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
 /home/Computational/mark/src/postgres-andres/src/backend/utils/mmgr/mcxt.c:716
  100.00 :	  798f71:       48 81 ff ff ff ff 3f    cmp    $0x3fffffff,%rdi
         :	        return ret;
         :	}
         :
         :	void *
         :	palloc0(Size size)
         :	{
    0.00 :	  798f78:       48 89 e5                mov    %rsp,%rbp
    0.00 :	  798f7b:       41 54                   push   %r12
    0.00 :	  798f7d:       53                      push   %rbx
    0.00 :	  798f7e:       48 89 fb                mov    %rdi,%rbx
         :	        void       *ret;
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
    0.00 :	  798f81:       77 6d                   ja     798ff0 <palloc0+0x80>
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798f83:       48 8b 05 d6 18 42 00    mov    0x4218d6(%rip),%rax        # bba860 <CurrentMemoryContext>
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798f8a:       48 89 de                mov    %rbx,%rsi
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
    0.00 :	  798f8d:       c6 40 30 00             movb   $0x0,0x30(%rax)
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798f91:       48 8b 3d c8 18 42 00    mov    0x4218c8(%rip),%rdi        # bba860 <CurrentMemoryContext>
    0.00 :	  798f98:       48 8b 47 08             mov    0x8(%rdi),%rax
    0.00 :	  798f9c:       ff 10                   callq  *(%rax)
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798f9e:       f6 c3 07                test   $0x7,%bl
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
         :
         :	        CurrentMemoryContext->isReset = false;
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
    0.00 :	  798fa1:       49 89 c4                mov    %rax,%r12
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798fa4:       75 09                   jne    798faf <palloc0+0x3f>
    0.00 :	  798fa6:       48 81 fb 00 04 00 00    cmp    $0x400,%rbx
    0.00 :	  798fad:       76 19                   jbe    798fc8 <palloc0+0x58>
    0.00 :	  798faf:       48 89 da                mov    %rbx,%rdx
    0.00 :	  798fb2:       31 f6                   xor    %esi,%esi
    0.00 :	  798fb4:       4c 89 e7                mov    %r12,%rdi
    0.00 :	  798fb7:       e8 64 04 cd ff          callq  469420 <memset@plt>
         :
         :	        return ret;
         :	}
    0.00 :	  798fbc:       5b                      pop    %rbx
    0.00 :	  798fbd:       4c 89 e0                mov    %r12,%rax
    0.00 :	  798fc0:       41 5c                   pop    %r12
    0.00 :	  798fc2:       c9                      leaveq 
    0.00 :	  798fc3:       c3                      retq   
    0.00 :	  798fc4:       0f 1f 40 00             nopl   0x0(%rax)
         :	        CurrentMemoryContext->isReset = false;
         :
         :	        ret = (*CurrentMemoryContext->methods->alloc) (CurrentMemoryContext, size);
         :	        VALGRIND_MEMPOOL_ALLOC(CurrentMemoryContext, ret, size);
         :
         :	        MemSetAligned(ret, 0, size);
    0.00 :	  798fc8:       49 8d 14 1c             lea    (%r12,%rbx,1),%rdx
    0.00 :	  798fcc:       49 39 d4                cmp    %rdx,%r12
    0.00 :	  798fcf:       73 eb                   jae    798fbc <palloc0+0x4c>
    0.00 :	  798fd1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	  798fd8:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
    0.00 :	  798fdf:       48 83 c0 08             add    $0x8,%rax
    0.00 :	  798fe3:       48 39 c2                cmp    %rax,%rdx
    0.00 :	  798fe6:       77 f0                   ja     798fd8 <palloc0+0x68>
         :
         :	        return ret;
         :	}
    0.00 :	  798fe8:       5b                      pop    %rbx
    0.00 :	  798fe9:       4c 89 e0                mov    %r12,%rax
    0.00 :	  798fec:       41 5c                   pop    %r12
    0.00 :	  798fee:       c9                      leaveq 
    0.00 :	  798fef:       c3                      retq   
         :
         :	        AssertArg(MemoryContextIsValid(CurrentMemoryContext));
         :	        AssertNotInCriticalSection(CurrentMemoryContext);
         :
         :	        if (!AllocSizeIsValid(size))
         :	                elog(ERROR, "invalid memory alloc request size %zu", size);
    0.00 :	  798ff0:       ba 10 20 8e 00          mov    $0x8e2010,%edx
    0.00 :	  798ff5:       be cd 02 00 00          mov    $0x2cd,%esi
    0.00 :	  798ffa:       bf 8e 1f 8e 00          mov    $0x8e1f8e,%edi
    0.00 :	  798fff:       e8 1c 24 fe ff          callq  77b420 <elog_start>
    0.00 :	  799004:       48 89 da                mov    %rbx,%rdx
    0.00 :	  799007:       be b8 1f 8e 00          mov    $0x8e1fb8,%esi
    0.00 :	  79900c:       bf 14 00 00 00          mov    $0x14,%edi
    0.00 :	  799011:       31 c0                   xor    %eax,%eax
    0.00 :	  799013:       e8 18 22 fe ff          callq  77b230 <elog_finish>
    0.00 :	  799018:       e8 b3 04 cd ff          callq  4694d0 <abort@plt>

Sorted summary for file /lib64/libc-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/libc-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000db0c0 <__lseek>:
    0.00 :	   db0c0:       83 3d ed c5 29 00 00    cmpl   $0x0,0x29c5ed(%rip)        # 3776b4 <__libc_multiple_threads>
 ??:0
  100.00 :	   db0c7:       75 10                   jne    db0d9 <__lseek_nocancel+0x10>
         :
         :	00000000000db0c9 <__lseek_nocancel>:
    0.00 :	   db0c9:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	   db0ce:       0f 05                   syscall 
    0.00 :	   db0d0:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   db0d6:       73 31                   jae    db109 <__lseek_nocancel+0x40>
    0.00 :	   db0d8:       c3                      retq   
    0.00 :	   db0d9:       48 83 ec 08             sub    $0x8,%rsp
    0.00 :	   db0dd:       e8 4e d1 00 00          callq  e8230 <__libc_enable_asynccancel>
    0.00 :	   db0e2:       48 89 04 24             mov    %rax,(%rsp)
    0.00 :	   db0e6:       b8 08 00 00 00          mov    $0x8,%eax
    0.00 :	   db0eb:       0f 05                   syscall 
    0.00 :	   db0ed:       48 8b 3c 24             mov    (%rsp),%rdi
    0.00 :	   db0f1:       48 89 c2                mov    %rax,%rdx
    0.00 :	   db0f4:       e8 97 d1 00 00          callq  e8290 <__libc_disable_asynccancel>
    0.00 :	   db0f9:       48 89 d0                mov    %rdx,%rax
    0.00 :	   db0fc:       48 83 c4 08             add    $0x8,%rsp
    0.00 :	   db100:       48 3d 01 f0 ff ff       cmp    $0xfffffffffffff001,%rax
    0.00 :	   db106:       73 01                   jae    db109 <__lseek_nocancel+0x40>
    0.00 :	   db108:       c3                      retq   
    0.00 :	   db109:       48 8b 0d 28 6d 29 00    mov    0x296d28(%rip),%rcx        # 371e38 <_DYNAMIC+0x2d8>
    0.00 :	   db110:       31 d2                   xor    %edx,%edx
    0.00 :	   db112:       48 29 c2                sub    %rax,%rdx
    0.00 :	   db115:       64 89 11                mov    %edx,%fs:(%rcx)
    0.00 :	   db118:       48 83 c8 ff             or     $0xffffffffffffffff,%rax
    0.00 :	   db11c:       eb ea                   jmp    db108 <__lseek_nocancel+0x3f>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/net/ipv4/netfilter/ip_tables.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/net/ipv4/netfilter/ip_tables.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	00000000000025c0 <ipt_do_table>:
    0.00 :	    25c0:       41 57                   push   %r15
    0.00 :	    25f2:       48 c7 c0 00 00 00 00    mov    0xd8(%rdi),%r13
    0.00 :	    25f9:       41 56 41 55 41          mov    0x70(%rsp),%rcx
    0.00 :	    25fe:       54 49 89 fc 55          mov    0x70(%rsp),%rsi
    0.00 :	    2603:       53 4c 89                add    %rdx,%r13
    0.00 :	    2606:       c3 48 81 ec 08 01       cmpq   $0x0,0x70(%rsp)
    0.00 :	    260c:       00 00 48 89             cmove  %rax,%rcx
    0.00 :	    2610:       4c 24 68 48 89 54       cmpq   $0x0,0x68(%rsp)
    0.00 :	    2616:       24 70 89 74 24 78       cmovne 0x68(%rsp),%rax
    0.00 :	    261c:       8b 97 c4 00 00 00 4c    mov    %rcx,0x80(%rsp)
    0.00 :	    2623:       8b 
    0.00 :	    2624:       af d8 00 00 00 48 8b    mov    %rax,0x88(%rsp)
    0.00 :	    262b:       4c 
    0.00 :	    262c:       24 70 48 8b 74          movzwl 0x6(%r13),%eax
    0.00 :	    2631:       24 70 49 01             rol    $0x8,%ax
    0.00 :	    2635:       d5 48 83 7c 24          and    $0x1fff,%eax
    0.00 :	    263a:       70 00 48 0f 44 c8 48    mov    %eax,0xf0(%rsp)
    0.00 :	    2641:       83 7c 24 68 00 48 0f    mov    0xd8(%rdi),%rax
    0.00 :	    2648:       45 44 24 68 48          mov    0x68(%rsp),%rdi
    0.00 :	    264d:       89 8c 24 80             movzbl (%rax,%rdx,1),%eax
    0.00 :	    2651:       00 00 00 48 89 84 24    movb   $0x0,0xfd(%rsp)
    0.00 :	    2658:       88 
    0.00 :	    2659:       00 00 00 41 0f b7 45    mov    %rsi,0xe0(%rsp)
    0.00 :	    2660:       06 
    0.00 :	    2661:       66 c1 c0 08 25 ff 1f    mov    %rdi,0xe8(%rsp)
    0.00 :	    2668:       00 
    0.00 :	    2669:       00 89 84 24 f0 00 00    movb   $0x2,0xfc(%rsp)
    0.00 :	    2670:       00 
    0.00 :	    2671:       48 8b 87                and    $0xf,%eax
    0.00 :	    2674:       d8 00 00                shl    $0x2,%eax
    0.00 :	    2677:       00 48 8b 7c 24 68 0f    mov    %eax,0xf4(%rsp)
    0.00 :	    267e:       b6 04 10 c6             mov    0x78(%rsp),%eax
    0.00 :	    2682:       84 24 fd 00 00 00 00    mov    %eax,0xf8(%rsp)
    0.00 :	    2689:       48 89 b4 24 e0          callq  268e <icmp_checkentry+0x265e>
    0.00 :	    268e:       00 00 00 48 89 bc 24    mov    %gs:0x0,%eax
    0.00 :	    2695:       e8 
    0.00 :	    2696:       00 00 00                add    $0x1,%eax
    0.00 :	    2699:       c6 84 24                and    $0x1,%eax
    0.00 :	    269c:       fc 00 00 00 02 83 e0    mov    %eax,0xb4(%rsp)
    0.00 :	    26a3:       0f c1 e0 02 89 84 24    add    %eax,%gs:0x0
    0.00 :	    26aa:       f4 
    0.00 :	    26ab:       00 00 00 8b             mov    0x18(%rbx),%rdx
    0.00 :	    26af:       44 24 78 89             add    $0x30,%rbx
    0.00 :	    26b3:       84 24 f8 00 00 00 e8    mov    %rdx,0xa8(%rsp)
    0.00 :	    26ba:       00 
    0.00 :	    26bb:       00 00 00 65 8b 04 25    mov    0xa8(%rsp),%rcx
    0.00 :	    26c2:       00 
    0.00 :	    26c3:       00 00 00 83 c0 01 83    mov    %gs:0x0,%edx
    0.00 :	    26ca:       e0 
    0.00 :	    26cb:       01 89                   mov    %edx,%edx
    0.00 :	    26cd:       84 24 b4 00 00 00 65    mov    0xa8(%rsp),%rsi
    0.00 :	    26d4:       01 
    0.00 :	    26d5:       04 25 00 00 00          mov    0x48(%rcx,%rdx,8),%rcx
    0.00 :	    26da:       00 48 8b 53 18 48 83    mov    %rcx,0x90(%rsp)
    0.00 :	    26e1:       c3 
    0.00 :	    26e2:       30 48 89 94             mov    0x40(%rsi),%rax
    0.00 :	    26e6:       24 a8 00 00             mov    (%rax,%rdx,8),%rax
    0.00 :	    26ea:       00 48 8b 8c 24 a8 00    mov    %rax,0x98(%rsp)
    0.00 :	    26f1:       00 
    0.00 :	    26f2:       00 65 8b 14             mov    0x38(%rsi),%r15
    0.00 :	    26f6:       25 00 00 00 00 89 d2    add    0x0(,%rdx,8),%r15
    0.00 :	    26fd:       48 
    0.00 :	    26fe:       8b b4 24 a8             mov    0x78(%rsp),%eax
    0.00 :	    2702:       00 00 00 48 8b 4c d1    cmpb   $0x0,0x0(%rip)        # 2709 <icmp_checkentry+0x26d9>
    0.00 :	    2709:       48 48 89                mov    (%r15),%edi
    0.00 :	    270c:       8c 24 90 00 00          mov    %rax,0x50(%rsp)
    0.00 :	    2711:       00 48 8b 46 40 48 8b    mov    %edi,0xa4(%rsp)
    0.00 :	    2718:       04 d0 48 89             mov    0xc(%rsi,%rax,4),%ebp
    0.00 :	    271c:       84 24 98 00 00          mov    %rbx,0x58(%rsp)
    0.00 :	    2721:       00 4c 8b 7e 38 4c       jne    2bd3 <icmp_checkentry+0x2ba3>
    0.00 :	    2727:       03 3c d5 00 00          mov    0x50(%rsp),%rdx
    0.00 :	    272c:       00 00                   mov    %ebp,%eax
    0.00 :	    272e:       8b 44 24 78 80 3d 00    mov    0x90(%rsp),%rbp
    0.00 :	    2735:       00 
    0.00 :	    2736:       00 00 00 41 8b 3f 48    lea    0xd0(%rsp),%r14
    0.00 :	    273d:       89 
    0.00 :	    273e:       44 24 50 89 bc 24 a4    movl   $0x0,0x7c(%rsp)
    0.00 :	    2745:       00 
    0.00 :	    2746:       00 00 8b 6c             add    $0x8,%rdx
    0.00 :	    274a:       86 0c 48                add    %rax,%rbp
    0.00 :	    274d:       89 5c 24 58 0f          mov    %rdx,0x48(%rsp)
    0.00 :	    2752:       85 ac 04 00 00 48       nopw   0x0(%rax,%rax,1)
    0.00 :	    2758:       8b 54 24 50             movzbl 0x53(%rbp),%ecx
    0.00 :	    275c:       89 e8 48                mov    0x8(%rbp),%eax
    0.00 :	    275f:       8b ac 24 90             and    0xc(%r13),%eax
    0.00 :	    2763:       00 00 00 4c 8d b4 24    mov    0xf0(%rsp),%esi
    0.00 :	    276a:       d0 00 00                cmp    0x0(%rbp),%eax
    0.00 :	    276d:       00 c7                   mov    %ecx,%eax
    0.00 :	    276f:       44 24 7c                setne  %dl
    0.00 :	    2772:       00 00 00                shr    $0x3,%eax
    0.00 :	    2775:       00 48 83                and    $0x1,%eax
    0.00 :	    2778:       c2 08                   cmp    %al,%dl
    0.00 :	    277a:       48 01                   jne    27f8 <icmp_checkentry+0x27c8>
    0.00 :	    277c:       c5 48 89                mov    0xc(%rbp),%eax
    0.00 :	    277f:       54 24 48 66             and    0x10(%r13),%eax
    0.00 :	    2783:       0f 1f 44                cmp    0x4(%rbp),%eax
    0.00 :	    2786:       00 00                   mov    %ecx,%eax
    0.00 :	    2788:       0f b6 4d                setne  %dl
    0.00 :	    278b:       53 8b 45                shr    $0x4,%eax
    0.00 :	    278e:       08 41 23                and    $0x1,%eax
 ??:0
  100.00 :	    2791:       45 0c                   cmp    %al,%dl
    0.00 :	    2793:       8b b4                   jne    27f8 <icmp_checkentry+0x27c8>
    0.00 :	    2795:       24 f0 00 00 00 3b 45    mov    0x80(%rsp),%rbx
    0.00 :	    279c:       00 
    0.00 :	    279d:       89 c8 0f 95             mov    0x8(%rbx),%rdx
    0.00 :	    27a1:       c2 c1 e8                mov    (%rbx),%rax
    0.00 :	    27a4:       03 83 e0 01             xor    0x18(%rbp),%rdx
    0.00 :	    27a8:       38 c2 75 7c             xor    0x10(%rbp),%rax
    0.00 :	    27ac:       8b 45 0c 41             and    0x38(%rbp),%rdx
    0.00 :	    27b0:       23 45 10 3b             and    0x30(%rbp),%rax
    0.00 :	    27b4:       45 04 89                or     %rax,%rdx
    0.00 :	    27b7:       c8 0f                   mov    %ecx,%eax
    0.00 :	    27b9:       95 c2 c1                setne  %dl
    0.00 :	    27bc:       e8 04 83                and    $0x1,%eax
    0.00 :	    27bf:       e0 01                   cmp    %al,%dl
    0.00 :	    27c1:       38 c2                   jne    27f8 <icmp_checkentry+0x27c8>
    0.00 :	    27c3:       75 63 48 8b 9c 24 80    mov    0x88(%rsp),%rdi
    0.00 :	    27ca:       00 
    0.00 :	    27cb:       00 00 48 8b             mov    0x8(%rdi),%rdx
    0.00 :	    27cf:       53 08 48                mov    (%rdi),%rax
    0.00 :	    27d2:       8b 03 48 33             xor    0x28(%rbp),%rdx
    0.00 :	    27d6:       55 18 48 33             xor    0x20(%rbp),%rax
    0.00 :	    27da:       45 10 48 23             and    0x48(%rbp),%rdx
    0.00 :	    27de:       55 38 48 23             and    0x40(%rbp),%rax
    0.00 :	    27e2:       45 30 48                or     %rax,%rdx
    0.00 :	    27e5:       09 c2                   mov    %ecx,%eax
    0.00 :	    27e7:       89 c8 0f                setne  %dl
    0.00 :	    27ea:       95 c2                   shr    %eax
    0.00 :	    27ec:       83 e0 01                and    $0x1,%eax
    0.00 :	    27ef:       38 c2                   cmp    %al,%dl
    0.00 :	    27f1:       75 35                   je     2860 <icmp_checkentry+0x2830>
    0.00 :	    27f3:       48 8b bc 24 88          nopl   0x0(%rax,%rax,1)
    0.00 :	    27f8:       00 00 00 48             movzwl 0x5a(%rbp),%eax
    0.00 :	    27fc:       8b 57 08                add    %rax,%rbp
    0.00 :	    27ff:       48 8b 07 48 33 55 28    cmpb   $0x0,0xfd(%rsp)
    0.00 :	    2806:       48 
    0.00 :	    2807:       33 45 20 48 23 55       je     2758 <icmp_checkentry+0x2728>
    0.00 :	    280d:       48 48 23 45 40 48 09    cmpb   $0x0,0x0(%rip)        # 2814 <icmp_checkentry+0x27e4>
    0.00 :	    2814:       c2 89 c8 0f 95 c2       jne    2bff <icmp_checkentry+0x2bcf>
    0.00 :	    281a:       d1 e8 83 e0 01 38 c2    mov    0xa4(%rsp),%eax
    0.00 :	    2821:       74 6d 0f                mov    %eax,(%r15)
    0.00 :	    2824:       1f 44 00 00 0f b7 45    mov    0xb4(%rsp),%edx
    0.00 :	    282b:       5a 48 01 c5 80 bc 24    add    %edx,%gs:0x0
    0.00 :	    2832:       fd 
    0.00 :	    2833:       00 00 00 00 0f          callq  2838 <icmp_checkentry+0x2808>
    0.00 :	    2838:       84 4b ff ff ff 80 3d    cmpb   $0x0,0xfd(%rsp)
    0.00 :	    283f:       00 
    0.00 :	    2840:       00 00 00 00 0f          mov    $0x0,%eax
    0.00 :	    2845:       85 e5 03 00 00          cmove  0x7c(%rsp),%eax
    0.00 :	    284a:       8b 84 24 a4             mov    %eax,0x7c(%rsp)
    0.00 :	    284e:       00 00 00 41 89 07 8b    add    $0x108,%rsp
    0.00 :	    2855:       94                      pop    %rbx
    0.00 :	    2856:       24                      pop    %rbp
    0.00 :	    2857:       b4 00                   pop    %r12
    0.00 :	    2859:       00 00                   pop    %r13
    0.00 :	    285b:       65 01                   pop    %r14
    0.00 :	    285d:       14 25                   pop    %r15
    0.00 :	    285f:       00                      retq   
    0.00 :	    2860:       00 00 00 e8             movzwl 0x50(%rbp),%edx
    0.00 :	    2864:       00 00 00                test   %dx,%dx
    0.00 :	    2867:       00 80                   je     2884 <icmp_checkentry+0x2854>
    0.00 :	    2869:       bc 24 fd 00 00          movzbl 0x9(%r13),%eax
    0.00 :	    286e:       00 00 b8                cmp    %ax,%dx
    0.00 :	    2871:       00 00                   mov    %ecx,%eax
    0.00 :	    2873:       00 00 0f                setne  %dl
    0.00 :	    2876:       44 44 24                shr    $0x6,%eax
    0.00 :	    2879:       7c 89 44                and    $0x1,%eax
    0.00 :	    287c:       24 7c                   cmp    %al,%dl
    0.00 :	    287e:       48 81 c4 08 01 00       jne    27f8 <icmp_checkentry+0x27c8>
    0.00 :	    2884:       00 5b                   test   %esi,%esi
    0.00 :	    2886:       5d 41 5c                sete   %al
    0.00 :	    2889:       41 5d 41                and    0x52(%rbp),%al
    0.00 :	    288c:       5e 41 5f                shr    $0x5,%ecx
    0.00 :	    288f:       c3 0f                   mov    %ecx,%edx
    0.00 :	    2891:       b7 55 50                and    $0x1,%edx
    0.00 :	    2894:       66 85                   cmp    %dl,%al
    0.00 :	    2896:       d2 74 1b 41 0f b6       jne    27f8 <icmp_checkentry+0x27c8>
    0.00 :	    289c:       45 09 66 39             movzwl 0x58(%rbp),%eax
    0.00 :	    28a0:       c2 89 c8 0f             lea    0x70(%rbp),%rbx
    0.00 :	    28a4:       95 c2 c1 e8 06          lea    0x0(%rbp,%rax,1),%rax
    0.00 :	    28a9:       83 e0 01                cmp    %rax,%rbx
    0.00 :	    28ac:       38 c2                   jb     28c4 <icmp_checkentry+0x2894>
    0.00 :	    28ae:       0f 85                   jmp    28f0 <icmp_checkentry+0x28c0>
    0.00 :	    28b0:       74 ff ff                movzwl (%rbx),%eax
    0.00 :	    28b3:       ff 85 f6                add    %rax,%rbx
    0.00 :	    28b6:       0f 94 c0 22             movzwl 0x58(%rbp),%eax
    0.00 :	    28ba:       45 52 c1 e9 05          lea    0x0(%rbp,%rax,1),%rax
    0.00 :	    28bf:       89 ca 83                cmp    %rax,%rbx
    0.00 :	    28c2:       e2 01                   jae    28f0 <icmp_checkentry+0x28c0>
    0.00 :	    28c4:       38 d0 0f 85             mov    0x8(%rbx),%rax
    0.00 :	    28c8:       5c ff ff ff             lea    0x20(%rbx),%rdx
    0.00 :	    28cc:       0f b7 45                mov    %r14,%rsi
    0.00 :	    28cf:       58 48 8d                mov    %r12,%rdi
    0.00 :	    28d2:       5d 70 48 8d 44 05 00    mov    %rdx,0xd8(%rsp)
    0.00 :	    28d9:       48 
    0.00 :	    28da:       39 c3 72 16 eb 40 0f    mov    %rax,0xd0(%rsp)
    0.00 :	    28e1:       b7 
    0.00 :	    28e2:       03 48 01                callq  *0x30(%rax)
    0.00 :	    28e5:       c3 0f                   test   %al,%al
    0.00 :	    28e7:       b7 45                   jne    28b0 <icmp_checkentry+0x2880>
    0.00 :	    28e9:       58 48 8d 44 05          jmpq   27f8 <icmp_checkentry+0x27c8>
    0.00 :	    28ee:       00 48                   xchg   %ax,%ax
    0.00 :	    28f0:       39 c3 73 2c 48          mov    0x68(%r12),%eax
    0.00 :	    28f5:       8b 43 08 48 8d          addq   $0x1,0x60(%rbp)
    0.00 :	    28fa:       53 20 4c 89             add    %rax,0x68(%rbp)
    0.00 :	    28fe:       f6 4c 89 e7             movzwl 0x58(%rbp),%eax
    0.00 :	    2902:       48 89 94 24 d8 00       cmpb   $0x0,0x7d(%r12)
    0.00 :	    2908:       00 00 48 89 84          mov    %ax,0x36(%rsp)
    0.00 :	    290d:       24 d0 00                movzwl %ax,%eax
    0.00 :	    2910:       00 00 ff 50 30          lea    0x0(%rbp,%rax,1),%rbx
    0.00 :	    2915:       84 c0 75 c7 e9 0a       js     2a90 <icmp_checkentry+0x2a60>
    0.00 :	    291b:       ff ff ff 66             mov    0x8(%rbx),%rax
    0.00 :	    291f:       90 41 8b 44 24          cmpq   $0x0,0x30(%rax)
    0.00 :	    2924:       68 48                   je     2980 <icmp_checkentry+0x2950>
    0.00 :	    2926:       83 45 60 01 48 01 45    mov    %rax,0xd0(%rsp)
    0.00 :	    292d:       68 
    0.00 :	    292e:       0f b7 45 58             lea    0x20(%rbx),%rax
    0.00 :	    2932:       41 80 7c                mov    %r14,%rsi
    0.00 :	    2935:       24 7d 00                mov    %r12,%rdi
    0.00 :	    2938:       66 89 44 24 36 0f b7    mov    %rax,0xd8(%rsp)
    0.00 :	    293f:       c0 
    0.00 :	    2940:       48 8d 5c 05             mov    0x8(%rbx),%rax
    0.00 :	    2944:       00 0f 88                callq  *0x30(%rax)
    0.00 :	    2947:       75 01 00 00             mov    %eax,0x7c(%rsp)
    0.00 :	    294b:       48 8b 43 08 48          cmpl   $0xffffffff,0x7c(%rsp)
    0.00 :	    2950:       83 78 30 00 74 5a 48    mov    0xd8(%r12),%rcx
    0.00 :	    2957:       89 
    0.00 :	    2958:       84 24 d0 00 00 00 48    mov    0xc4(%r12),%eax
    0.00 :	    295f:       8d 
    0.00 :	    2960:       43 20 4c 89 f6 4c       jne    280d <icmp_checkentry+0x27dd>
    0.00 :	    2966:       89 e7                   mov    %eax,%edx
    0.00 :	    2968:       48 89 84 24             movzwl 0x5a(%rbp),%eax
    0.00 :	    296c:       d8 00 00 00             lea    (%rcx,%rdx,1),%r13
    0.00 :	    2970:       48 8b 43                add    %rax,%rbp
    0.00 :	    2973:       08 ff 50 30 89          jmpq   27ff <icmp_checkentry+0x27cf>
    0.00 :	    2978:       44 24 7c 83 7c 24 7c    nopl   0x0(%rax,%rax,1)
    0.00 :	    297f:       ff 
    0.00 :	    2980:       49 8b 8c                mov    0x20(%rbx),%ebx
    0.00 :	    2983:       24 d8                   test   %ebx,%ebx
    0.00 :	    2985:       00 00                   js     29ed <icmp_checkentry+0x29bd>
    0.00 :	    2987:       00 41 8b 84             movzwl 0x5a(%rbp),%eax
    0.00 :	    298b:       24 c4 00                movslq %ebx,%rdx
    0.00 :	    298e:       00 00 0f 85 a7 fe ff    add    0x90(%rsp),%rdx
    0.00 :	    2995:       ff 
    0.00 :	    2996:       89 c2 0f b7 45          lea    0x0(%rbp,%rax,1),%rax
    0.00 :	    299b:       5a 4c 8d                cmp    %rax,%rdx
    0.00 :	    299e:       2c 11                   je     29db <icmp_checkentry+0x29ab>
    0.00 :	    29a0:       48 01 c5 e9             testb  $0x2,0x52(%rbp)
    0.00 :	    29a4:       87 fe                   jne    29db <icmp_checkentry+0x29ab>
    0.00 :	    29a6:       ff ff 0f 1f 84 00 00    mov    0xa8(%rsp),%rsi
    0.00 :	    29ad:       00 
    0.00 :	    29ae:       00 00 8b                mov    (%r15),%ecx
    0.00 :	    29b1:       5b 20 85                cmp    0x34(%rsi),%ecx
    0.00 :	    29b4:       db 78 66 0f b7 45       jae    2c93 <icmp_checkentry+0x2c63>
    0.00 :	    29ba:       5a 48 63 d3 48 03 94    mov    0x98(%rsp),%rdi
    0.00 :	    29c1:       24 
    0.00 :	    29c2:       90 00                   mov    %ecx,%eax
    0.00 :	    29c4:       00 00 48 8d             mov    %rbp,(%rdi,%rax,8)
    0.00 :	    29c8:       44 05 00                lea    0x1(%rcx),%eax
    0.00 :	    29cb:       48 39 c2                mov    %eax,(%r15)
    0.00 :	    29ce:       74 3b f6 45 52 02 75    cmpb   $0x0,0x0(%rip)        # 29d5 <icmp_checkentry+0x29a5>
    0.00 :	    29d5:       35 48 8b b4 24 a8       jne    2ca0 <icmp_checkentry+0x2c70>
    0.00 :	    29db:       00 00 00 41 8b 0f 3b    mov    0x90(%rsp),%rbp
    0.00 :	    29e2:       4e 
    0.00 :	    29e3:       34 0f                   mov    %ebx,%eax
    0.00 :	    29e5:       83 d9 02                add    %rax,%rbp
    0.00 :	    29e8:       00 00 48 8b bc          jmpq   27ff <icmp_checkentry+0x27cf>
    0.00 :	    29ed:       24 98 00                cmp    $0xfffffffb,%ebx
    0.00 :	    29f0:       00 00 89 c8 48 89       jne    2c88 <icmp_checkentry+0x2c58>
    0.00 :	    29f6:       2c c7 8d                mov    (%r15),%eax
    0.00 :	    29f9:       41 01 41 89 07 80 3d    cmp    %eax,0xa4(%rsp)
    0.00 :	    2a00:       00 00                   jb     2a50 <icmp_checkentry+0x2a20>
    0.00 :	    2a02:       00 00 00 0f 85          mov    0x48(%rsp),%rdx
    0.00 :	    2a07:       c5 02 00 00 48 8b ac    mov    0xa8(%rsp),%rcx
    0.00 :	    2a0e:       24 
    0.00 :	    2a0f:       90 00 00 00 89 d8 48    mov    0x90(%rsp),%rbp
    0.00 :	    2a16:       01 
    0.00 :	    2a17:       c5 e9 12                mov    (%rcx,%rdx,4),%eax
    0.00 :	    2a1a:       fe ff ff                add    %rax,%rbp
    0.00 :	    2a1d:       83 fb fb 0f 85 92 02    cmpb   $0x0,0x0(%rip)        # 2a24 <icmp_checkentry+0x29f4>
    0.00 :	    2a24:       00 00 41 8b 07 39       je     27ff <icmp_checkentry+0x27cf>
    0.00 :	    2a2a:       84 24 a4                mov    %rbp,%rdx
    0.00 :	    2a2d:       00 00 00 72 4e 48 8b    mov    $0x0,%rsi
    0.00 :	    2a34:       54 24 48 48 8b 8c 24    mov    $0x0,%rdi
    0.00 :	    2a3b:       a8 00                   xor    %eax,%eax
    0.00 :	    2a3d:       00 00 48 8b ac          callq  2a42 <icmp_checkentry+0x2a12>
    0.00 :	    2a42:       24 90 00 00 00          jmpq   27ff <icmp_checkentry+0x27cf>
    0.00 :	    2a47:       8b 04 91 48 01 c5 80    nopw   0x0(%rax,%rax,1)
    0.00 :	    2a4e:       3d 00 
    0.00 :	    2a50:       00 00 00                lea    -0x1(%rax),%ecx
    0.00 :	    2a53:       00 0f 84                mov    %ecx,(%r15)
    0.00 :	    2a56:       d5 fd ff ff 48 89 ea    cmpb   $0x0,0x0(%rip)        # 2a5d <icmp_checkentry+0x2a2d>
    0.00 :	    2a5d:       48 c7                   mov    %ecx,%eax
    0.00 :	    2a5f:       c6 00 00 00 00 48 c7    mov    0x98(%rsp),%rbx
    0.00 :	    2a66:       c7 
    0.00 :	    2a67:       00 00 00 00             mov    (%rbx,%rax,8),%rbp
    0.00 :	    2a6b:       31 c0 e8 00 00 00       je     27f8 <icmp_checkentry+0x27c8>
    0.00 :	    2a71:       00 e9 b8                mov    %rbp,%rdx
    0.00 :	    2a74:       fd ff ff 66 0f 1f 84    mov    $0x0,%rsi
    0.00 :	    2a7b:       00 00 00 00 00 8d 48    mov    $0x0,%rdi
    0.00 :	    2a82:       ff 41                   xor    %eax,%eax
    0.00 :	    2a84:       89 0f 80 3d 00          callq  2a89 <icmp_checkentry+0x2a59>
    0.00 :	    2a89:       00 00 00 00 89          jmpq   27f8 <icmp_checkentry+0x27c8>
    0.00 :	    2a8e:       c8 48                   xchg   %ax,%ax
    0.00 :	    2a90:       8b 9c 24 98 00 00 00    mov    0xa8(%rsp),%rsi
    0.00 :	    2a97:       48 
    0.00 :	    2a98:       8b 2c c3 0f 84          mov    0x50(%rsp),%rcx
    0.00 :	    2a9d:       87 fd ff                xor    %r9d,%r9d
    0.00 :	    2aa0:       ff 48 89 ea 48          mov    0x50(%rsp),%rdi
    0.00 :	    2aa5:       c7 c6 00 00 00 00 48    mov    %gs:0x0,%eax
    0.00 :	    2aac:       c7 
    0.00 :	    2aad:       c7 00 00 00             mov    0xc(%rsi,%rcx,4),%edx
    0.00 :	    2ab1:       00 31                   cltq   
    0.00 :	    2ab3:       c0 e8 00 00 00 00 e9    mov    0x0(,%rdi,8),%rdi
    0.00 :	    2aba:       6a 
    0.00 :	    2abb:       fd ff                   mov    %edx,%ecx
    0.00 :	    2abd:       ff 66 90 48 8b          add    0x48(%rsi,%rax,8),%rcx
    0.00 :	    2ac2:       b4 24 a8 00 00 00 48    movq   $0x0,0xb8(%rsp)
    0.00 :	    2ac9:       8b 4c 24 50 45 
    0.00 :	    2ace:       31 c9 48 8b 7c 24 50    mov    %rdi,0xc0(%rsp)
    0.00 :	    2ad5:       65 
    0.00 :	    2ad6:       8b 04                   mov    (%rsi),%eax
    0.00 :	    2ad8:       25 00                   sub    %edx,%eax
    0.00 :	    2ada:       00 00 00 8b             lea    (%rcx,%rax,1),%rax
    0.00 :	    2ade:       54 8e 0c                cmp    %rax,%rcx
    0.00 :	    2ae1:       48 98 48 8b 3c fd 00    mov    %rax,0xc8(%rsp)
    0.00 :	    2ae8:       00 
    0.00 :	    2ae9:       00 00                   jae    2b53 <icmp_checkentry+0x2b23>
    0.00 :	    2aeb:       89 d1 48 03 4c c6 48    mov    0xc0(%rsp),%r11
    0.00 :	    2af2:       48 
    0.00 :	    2af3:       c7 84 24 b8 00          mov    %rcx,0x38(%rsp)
    0.00 :	    2af8:       00 00 00                xor    %r9d,%r9d
    0.00 :	    2afb:       00 00 00 48 89          mov    0x38(%rsp),%rdx
    0.00 :	    2b00:       bc 24 c0 00 00 00 8b    mov    $0x0,%rdi
    0.00 :	    2b07:       06 29 d0 48 8d          mov    $0x6,%ecx
    0.00 :	    2b0c:       04 01 48 39             movzwl 0x58(%rdx),%eax
    0.00 :	    2b10:       c1 48 89                mov    %rdx,%r8
    0.00 :	    2b13:       84 24 c8                add    %rax,%r8
    0.00 :	    2b16:       00 00 00 73             mov    0x8(%r8),%r10
    0.00 :	    2b1a:       68 4c 8b 9c             lea    0x10(%r10),%rsi
    0.00 :	    2b1e:       24 c0                   repz cmpsb %es:(%rdi),%ds:(%rsi)
    0.00 :	    2b20:       00 00 00 48 89 4c       jne    2bad <icmp_checkentry+0x2b7d>
    0.00 :	    2b26:       24 38 45 31             lea    0x20(%r8),%r11
    0.00 :	    2b2a:       c9 48 8b                xor    %r9d,%r9d
    0.00 :	    2b2d:       54 24 38 48 c7          mov    0x38(%rsp),%rdx
    0.00 :	    2b32:       c7 00 00 00 00 b9 06    mov    0xc8(%rsp),%rcx
    0.00 :	    2b39:       00 
    0.00 :	    2b3a:       00 00 0f b7             movzwl 0x5a(%rdx),%eax
    0.00 :	    2b3e:       42 58 49                add    %rax,%rdx
    0.00 :	    2b41:       89 d0 49                cmp    %rcx,%rdx
    0.00 :	    2b44:       01 c0 4d 8b 50          mov    %rdx,0x38(%rsp)
    0.00 :	    2b49:       08 49                   jb     2afb <icmp_checkentry+0x2acb>
    0.00 :	    2b4b:       8d 72 10 f3 a6 0f 85    mov    %r11,0xc0(%rsp)
    0.00 :	    2b52:       87 
    0.00 :	    2b53:       00 00 00 4d 8d 58 20    mov    0xb8(%rsp),%rsi
    0.00 :	    2b5a:       45 
    0.00 :	    2b5b:       31 c9 48 8b 54 24 38    mov    0xc0(%rsp),%rdi
    0.00 :	    2b62:       48 
    0.00 :	    2b63:       8b 8c 24                mov    %r12,%rdx
    0.00 :	    2b66:       c8 00 00 00 0f          mov    0x58(%rsp),%rax
    0.00 :	    2b6b:       b7 42 5a 48 01          mov    0x68(%rsp),%r8
    0.00 :	    2b70:       c2 48 39 ca 48          mov    0x70(%rsp),%rcx
    0.00 :	    2b75:       89 54 24 38 72          mov    %r9d,0x20(%rsp)
    0.00 :	    2b7a:       b0 4c 89 9c 24 c0 00    mov    $0x0,%r9
    0.00 :	    2b81:       00 00 48 8b b4          mov    %rsi,0x18(%rsp)
    0.00 :	    2b86:       24 b8 00 00             mov    0x78(%rsp),%esi
    0.00 :	    2b8a:       00 48 8b bc 24          mov    %rdi,0x10(%rsp)
    0.00 :	    2b8f:       c0 00 00 00 4c          mov    %rax,0x8(%rsp)
    0.00 :	    2b94:       89 e2 48 8b 44          mov    $0x2,%edi
    0.00 :	    2b99:       24 58                   xor    %eax,%eax
    0.00 :	    2b9b:       4c 8b 44 24 68 48 8b    movq   $0x0,(%rsp)
    0.00 :	    2ba2:       4c 
    0.00 :	    2ba3:       24 70 44 89 4c          callq  2ba8 <icmp_checkentry+0x2b78>
    0.00 :	    2ba8:       24 20 49 c7 c1          jmpq   291b <icmp_checkentry+0x28eb>
    0.00 :	    2bad:       00 00 00 00 48          cmp    0x38(%rsp),%rbp
    0.00 :	    2bb2:       89 74                   je     2bbd <icmp_checkentry+0x2b8d>
    0.00 :	    2bb4:       24 18 8b 74             add    $0x1,%r9d
    0.00 :	    2bb8:       24 78 48 89 7c          jmpq   2b2d <icmp_checkentry+0x2afd>
    0.00 :	    2bbd:       24 10 48 89 44 24       cmpw   $0x70,0x36(%rsp)
    0.00 :	    2bc3:       08 bf                   je     2c2b <icmp_checkentry+0x2bfb>
    0.00 :	    2bc5:       02 00 00 00 31 c0 48    mov    %r11,0xc0(%rsp)
    0.00 :	    2bcc:       c7 
    0.00 :	    2bcd:       04 24 00 00             add    $0x1,%r9d
    0.00 :	    2bd1:       00 00                   jmp    2b53 <icmp_checkentry+0x2b23>
    0.00 :	    2bd3:       e8 00 00 00 00          mov    0x20(%rsi,%rax,4),%r9d
    0.00 :	    2bd8:       e9 6e fd                mov    %edi,%r8d
    0.00 :	    2bdb:       ff ff 48                mov    %rbx,%rdx
    0.00 :	    2bde:       3b 6c 24 38 74 09 41    mov    $0x0,%rsi
    0.00 :	    2be5:       83 c1 01 e9 70 ff ff    mov    $0x0,%rdi
    0.00 :	    2bec:       ff 66                   xor    %eax,%eax
    0.00 :	    2bee:       83 7c 24                add    %rcx,%r9
    0.00 :	    2bf1:       36 70 74 66             mov    0x78(%rsp),%ecx
    0.00 :	    2bf5:       4c 89 9c 24 c0          callq  2bfa <icmp_checkentry+0x2bca>
    0.00 :	    2bfa:       00 00 00 41 83          jmpq   2727 <icmp_checkentry+0x26f7>
    0.00 :	    2bff:       c1 01 eb 80 44 8b 4c    mov    0xa4(%rsp),%r8d
    0.00 :	    2c06:       86 
    0.00 :	    2c07:       20 41 89                mov    (%r15),%ecx
    0.00 :	    2c0a:       f8 48 89 da 48 c7 c6    mov    $0x0,%rdx
    0.00 :	    2c11:       00 00 00 00 48 c7 c7    mov    $0x0,%rsi
    0.00 :	    2c18:       00 00 00 00 31 c0 49    mov    $0x0,%rdi
    0.00 :	    2c1f:       01 c9                   xor    %eax,%eax
    0.00 :	    2c21:       8b 4c 24 78 e8          callq  2c26 <icmp_checkentry+0x2bf6>
    0.00 :	    2c26:       00 00 00 00 e9          jmpq   281a <icmp_checkentry+0x27ea>
    0.00 :	    2c2b:       28 fb ff ff 44          cmpb   $0x0,0x10(%r10)
    0.00 :	    2c30:       8b 84                   jne    2bc5 <icmp_checkentry+0x2b95>
    0.00 :	    2c32:       24 a4 00 00             mov    0x20(%r8),%r8d
    0.00 :	    2c36:       00 41 8b                test   %r8d,%r8d
    0.00 :	    2c39:       0f 48                   jns    2bc5 <icmp_checkentry+0x2b95>
    0.00 :	    2c3b:       c7 c2 00 00 00          mov    $0x54,%ecx
    0.00 :	    2c40:       00 48 c7                mov    %rbp,%rsi
    0.00 :	    2c43:       c6 00 00 00 00 48 c7    mov    $0x0,%rdi
    0.00 :	    2c4a:       c7 00                   repz cmpsb %es:(%rdi),%ds:(%rsi)
    0.00 :	    2c4c:       00 00 00 31 c0 e8       jne    2bc5 <icmp_checkentry+0x2b95>
    0.00 :	    2c52:       00 00 00 00 e9 ef fb    cmp    %r11,0xc0(%rsp)
    0.00 :	    2c59:       ff 
    0.00 :	    2c5a:       ff 41 80 7a 10 00 75    movq   $0x0,0xb8(%rsp)
    0.00 :	    2c61:       93 45 8b 40 20 
    0.00 :	    2c66:       45 85 c0 79 8a b9       je     2bcd <icmp_checkentry+0x2b9d>
    0.00 :	    2c6c:       54 00 00 00 48 89 ee    movq   $0x0,0xb8(%rsp)
    0.00 :	    2c73:       48 c7 c7 00 00 
    0.00 :	    2c78:       00 00 f3 a6 0f 85 73    mov    %r11,0xc0(%rsp)
    0.00 :	    2c7f:       ff 
    0.00 :	    2c80:       ff ff 4c 39 9c          jmpq   2bcd <icmp_checkentry+0x2b9d>
    0.00 :	    2c85:       24 c0 00                nopl   (%rax)
    0.00 :	    2c88:       00 00                   not    %ebx
    0.00 :	    2c8a:       48 c7 84 24             mov    %ebx,0x7c(%rsp)
    0.00 :	    2c8e:       b8 00 00 00 00          jmpq   280d <icmp_checkentry+0x27dd>
    0.00 :	    2c93:       00 00 00 0f 84 61 ff    movl   $0x0,0x7c(%rsp)
    0.00 :	    2c9a:       ff 
    0.00 :	    2c9b:       ff 48 c7 84 24          jmpq   280d <icmp_checkentry+0x27dd>
    0.00 :	    2ca0:       b8 00 00                mov    %rbp,%rdx
    0.00 :	    2ca3:       00 00 00 00 00 4c 89    mov    $0x0,%rsi
    0.00 :	    2caa:       9c 24 c0 00 00 00 e9    mov    $0x0,%rdi
    0.00 :	    2cb1:       48 ff                   xor    %eax,%eax
    0.00 :	    2cb3:       ff ff 0f 1f 00          callq  2cb8 <icmp_checkentry+0x2c88>
    0.00 :	    2cb8:       f7 d3 89 5c 24          jmpq   29db <icmp_checkentry+0x29ab>
         :	    2cbd:       7c e9 7a                nopl   (%rax)
         :	    2cc0:       fb ff                   push   %r15
         :	    2cc2:       ff c7 44 24 7c          mov    $0x80d0,%esi
         :	    2cc7:       00 00                   push   %r14
         :	    2cc9:       00 00 e9                mov    %rdi,%r14
         :	    2ccc:       6d fb                   push   %r13
         :	    2cce:       ff ff                   push   %r12
         :	    2cd0:       48 89 ea                xor    %r12d,%r12d
         :	    2cd3:       48                      push   %rbp
         :	    2cd4:       c7                      push   %rbx
         :	    2cd5:       c6 00 00 00             sub    $0x8,%rsp
         :	    2cd9:       00 48 c7                mov    0x10(%rdi),%ebp
         :	    2cdc:       c7 00                   mov    %ebp,%edi
         :	    2cde:       00 00 00 31 c0          callq  2ce3 <icmp_checkentry+0x2cb3>
         :	    2ce3:       e8 00 00                mov    %eax,%r15d
         :	    2ce6:       00 00                   mov    %eax,%eax
         :	    2ce8:       e9 1e fd ff             lea    (%rax,%rax,8),%rdx

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/net/ethernet/intel/igb/igb.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000000700 <igb_update_stats>:
    0.00 :	     700:       53                      push   %rbx
    0.00 :	     731:       48 89 fb 48 83          mov    $0x2b8,%edi
    0.00 :	     736:       ec 10 66                xor    %r10d,%r10d
    0.00 :	     739:       83 bf f8                xor    %r9d,%r9d
    0.00 :	     73c:       03 00                   test   %edi,%edi
    0.00 :	     73e:       00 00                   jle    78c <dma_unmap_page+0x75c>
    0.00 :	     740:       48 8b 87                mov    %rbx,%r8
    0.00 :	     743:       a0 04                   xor    %edi,%edi
    0.00 :	     745:       00 00 74                xor    %r10d,%r10d
    0.00 :	     748:       09 83 b8                xor    %r9d,%r9d
    0.00 :	     74b:       88 00 00 00 01          mov    $0xc030,%ecx
    0.00 :	     750:       74 0e 48                mov    %rcx,%rax
    0.00 :	     753:       83 c4 10 5b c3 0f 1f    add    0x570(%rbx),%rax
    0.00 :	     75a:       84 00                   mov    (%rax),%eax
    0.00 :	     75c:       00 00                   test   %eax,%eax
    0.00 :	     75e:       00 00 8b bf b8 02 00    mov    0x2c0(%r8),%rdx
    0.00 :	     765:       00 45                   je     771 <dma_unmap_page+0x741>
    0.00 :	     767:       31 d2                   mov    %eax,%eax
    0.00 :	     769:       45 31 c9 85             add    %rax,0x68(%rdx)
    0.00 :	     76d:       ff 7e 4c 49             add    %rax,0x70(%rsi)
    0.00 :	     771:       89 d8 31 ff             add    0x60(%rdx),%r10
    0.00 :	     775:       45 31 d2 45             add    0x58(%rdx),%r9
    0.00 :	     779:       31 c9 b9                add    $0x1,%edi
    0.00 :	     77c:       30 c0 00 00             add    $0x40,%rcx
    0.00 :	     780:       48 89 c8 48             add    $0x8,%r8
    0.00 :	     784:       03 83 70 05 00 00       cmp    %edi,0x2b8(%rbx)
    0.00 :	     78a:       8b 00                   jg     750 <dma_unmap_page+0x720>
    0.00 :	     78c:       85 c0 49 8b             mov    %r10,0x10(%rsi)
    0.00 :	     790:       90 c0 02                mov    %r9,(%rsi)
    0.00 :	     793:       00 00                   xor    %edi,%edi
    0.00 :	     795:       74 0a 89 c0 48 01 42    mov    0x234(%rbx),%r8d
    0.00 :	     79c:       68 48                   xor    %ecx,%ecx
    0.00 :	     79e:       01 46 70                test   %r8d,%r8d
    0.00 :	     7a1:       4c 03                   jle    7c9 <dma_unmap_page+0x799>
    0.00 :	     7a3:       52 60                   xor    %edi,%edi
    0.00 :	     7a5:       4c 03                   xor    %ecx,%ecx
    0.00 :	     7a7:       4a 58                   xor    %edx,%edx
    0.00 :	     7a9:       83 c7 01 48 83 c1 40    nopl   0x0(%rax)
    0.00 :	     7b0:       49 83 c0 08 39 bb b8    mov    0x238(%rbx,%rdx,8),%rax
    0.00 :	     7b7:       02 
    0.00 :	     7b8:       00 00 7f c4             add    $0x1,%rdx
    0.00 :	     7bc:       4c 89 56 10             add    0x58(%rax),%rdi
    0.00 :	     7c0:       4c 89 0e 31             add    0x50(%rax),%rcx
    0.00 :	     7c4:       ff 44 8b                cmp    %edx,%r8d
    0.00 :	     7c7:       83 34                   jg     7b0 <dma_unmap_page+0x780>
    0.00 :	     7c9:       02 00 00 31             mov    %rdi,0x18(%rsi)
    0.00 :	     7cd:       c9 45 85 c0             mov    %rcx,0x8(%rsi)
    0.00 :	     7d1:       7e 26 31 ff 31 c9 31    mov    0x570(%rbx),%rax
    0.00 :	     7d8:       d2 0f 1f 80 00 00 00    mov    0x9c8(%rbx),%rdx
    0.00 :	     7df:       00 48 8b 84 d3 38       add    $0x4000,%rax
    0.00 :	     7e5:       02 00                   mov    (%rax),%eax
    0.00 :	     7e7:       00 48                   mov    %eax,%eax
    0.00 :	     7e9:       83 c2 01                add    %rdx,%rax
    0.00 :	     7ec:       48 03 78 58 48 03 48    mov    0xa98(%rbx),%rdx
    0.00 :	     7f3:       50 41 39 d0 7f e7 48    mov    %rax,0x9c8(%rbx)
    0.00 :	     7fa:       89 7e 18 48 89 4e 08    mov    0x570(%rbx),%rax
    0.00 :	     801:       48 8b 83 70 05 00       add    $0x4074,%rax
    0.00 :	     807:       00 48                   mov    (%rax),%eax
    0.00 :	     809:       8b 93                   mov    %eax,%eax
    0.00 :	     80b:       c8 09 00                add    %rdx,%rax
    0.00 :	     80e:       00 48 05 00 40 00 00    mov    0xab8(%rbx),%rdx
    0.00 :	     815:       8b 00 89 c0 48 01 d0    mov    %rax,0xa98(%rbx)
    0.00 :	     81c:       48 8b 93 98 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     823:       48 89 83 c8 09 00       add    $0x4088,%rax
    0.00 :	     829:       00 48                   mov    (%rax),%eax
    0.00 :	     82b:       8b 83                   mov    %eax,%eax
    0.00 :	     82d:       70 05 00                add    %rdx,%rax
    0.00 :	     830:       00 48 05 74 40 00 00    mov    %rax,0xab8(%rbx)
    0.00 :	     837:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     83e:       48 8b 93 b8 0a 00       add    $0x408c,%rax
    0.00 :	     844:       00 48                   mov    (%rax),%eax
    0.00 :	     846:       89 83 98 0a 00 00 48    mov    0x570(%rbx),%rax
    0.00 :	     84d:       8b 83 70 05 00 00 48    mov    0xaa0(%rbx),%rdx
    0.00 :	     854:       05 88 40 00 00 8b       add    $0x4078,%rax
    0.00 :	     85a:       00 89                   mov    (%rax),%eax
    0.00 :	     85c:       c0 48                   mov    %eax,%eax
    0.00 :	     85e:       01 d0 48                add    %rdx,%rax
    0.00 :	     861:       89 83 b8 0a 00 00 48    mov    0xaa8(%rbx),%rdx
    0.00 :	     868:       8b 83 70 05 00 00 48    mov    %rax,0xaa0(%rbx)
    0.00 :	     86f:       05 8c 40 00 00 8b 00    mov    0x570(%rbx),%rax
    0.00 :	     876:       48 8b 83 70 05 00       add    $0x407c,%rax
    0.00 :	     87c:       00 48                   mov    (%rax),%eax
    0.00 :	     87e:       8b 93                   mov    %eax,%eax
    0.00 :	     880:       a0 0a 00                add    %rdx,%rax
    0.00 :	     883:       00 48 05 78 40 00 00    mov    0xae0(%rbx),%rdx
    0.00 :	     88a:       8b 00 89 c0 48 01 d0    mov    %rax,0xaa8(%rbx)
    0.00 :	     891:       48 8b 93 a8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     898:       48 89 83 a0 0a 00       add    $0x40ac,%rax
    0.00 :	     89e:       00 48                   mov    (%rax),%eax
    0.00 :	     8a0:       8b 83                   mov    %eax,%eax
    0.00 :	     8a2:       70 05 00                add    %rdx,%rax
    0.00 :	     8a5:       00 48 05 7c 40 00 00    mov    0xa68(%rbx),%rdx
    0.00 :	     8ac:       8b 00 89 c0 48 01 d0    mov    %rax,0xae0(%rbx)
    0.00 :	     8b3:       48 8b 93 e0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8ba:       48 89 83 a8 0a 00       add    $0x405c,%rax
    0.00 :	     8c0:       00 48                   mov    (%rax),%eax
    0.00 :	     8c2:       8b 83                   mov    %eax,%eax
    0.00 :	     8c4:       70 05 00                add    %rdx,%rax
    0.00 :	     8c7:       00 48 05 ac 40 00 00    mov    0xa70(%rbx),%rdx
    0.00 :	     8ce:       8b 00 89 c0 48 01 d0    mov    %rax,0xa68(%rbx)
    0.00 :	     8d5:       48 8b 93 68 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8dc:       48 89 83 e0 0a 00       add    $0x4060,%rax
    0.00 :	     8e2:       00 48                   mov    (%rax),%eax
    0.00 :	     8e4:       8b 83                   mov    %eax,%eax
    0.00 :	     8e6:       70 05 00                add    %rdx,%rax
    0.00 :	     8e9:       00 48 05 5c 40 00 00    mov    0xa78(%rbx),%rdx
    0.00 :	     8f0:       8b 00 89 c0 48 01 d0    mov    %rax,0xa70(%rbx)
    0.00 :	     8f7:       48 8b 93 70 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     8fe:       48 89 83 68 0a 00       add    $0x4064,%rax
    0.00 :	     904:       00 48                   mov    (%rax),%eax
    0.00 :	     906:       8b 83                   mov    %eax,%eax
    0.00 :	     908:       70 05 00                add    %rdx,%rax
    0.00 :	     90b:       00 48 05 60 40 00 00    mov    0xa80(%rbx),%rdx
    0.00 :	     912:       8b 00 89 c0 48 01 d0    mov    %rax,0xa78(%rbx)
    0.00 :	     919:       48 8b 93 78 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     920:       48 89 83 70 0a 00       add    $0x4068,%rax
    0.00 :	     926:       00 48                   mov    (%rax),%eax
    0.00 :	     928:       8b 83                   mov    %eax,%eax
    0.00 :	     92a:       70 05 00                add    %rdx,%rax
    0.00 :	     92d:       00 48 05 64 40 00 00    mov    0xa88(%rbx),%rdx
    0.00 :	     934:       8b 00 89 c0 48 01 d0    mov    %rax,0xa80(%rbx)
    0.00 :	     93b:       48 8b 93 80 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     942:       48 89 83 78 0a 00       add    $0x406c,%rax
    0.00 :	     948:       00 48                   mov    (%rax),%eax
    0.00 :	     94a:       8b 83                   mov    %eax,%eax
    0.00 :	     94c:       70 05 00                add    %rdx,%rax
    0.00 :	     94f:       00 48 05 68 40 00 00    mov    0xa90(%rbx),%rdx
    0.00 :	     956:       8b 00 89 c0 48 01 d0    mov    %rax,0xa88(%rbx)
    0.00 :	     95d:       48 8b 93 88 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     964:       48 89 83 80 0a 00       add    $0x4070,%rax
    0.00 :	     96a:       00 48                   mov    (%rax),%eax
    0.00 :	     96c:       8b 83                   mov    %eax,%eax
    0.00 :	     96e:       70 05 00                add    %rdx,%rax
    0.00 :	     971:       00 48 05 6c 40 00 00    mov    0x9d8(%rbx),%rdx
    0.00 :	     978:       8b 00 89 c0 48 01 d0    mov    %rax,0xa90(%rbx)
    0.00 :	     97f:       48 8b 93 90 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     986:       48 89 83 88 0a 00       add    $0x4008,%rax
    0.00 :	     98c:       00 48                   mov    (%rax),%eax
    0.00 :	     98e:       8b 83                   mov    %eax,%eax
    0.00 :	     990:       70 05 00                add    %rdx,%rax
    0.00 :	     993:       00 48 05 70 40 00 00    mov    0xa28(%rbx),%rdx
    0.00 :	     99a:       8b 00 89 c0 48 01 d0    mov    %rax,0x9d8(%rbx)
    0.00 :	     9a1:       48 8b 93 d8 09 00 00    mov    0x570(%rbx),%rax
    0.00 :	     9a8:       48 89 83 90 0a 00       add    $0x4038,%rax
    0.00 :	     9ae:       00 48                   mov    (%rax),%eax
    0.00 :	     9b0:       8b 83                   mov    %eax,%eax
    0.00 :	     9b2:       70 05 00                add    %rdx,%rax
    0.00 :	     9b5:       00 48 05 08 40 00 00    mov    %rax,0xa28(%rbx)
    0.00 :	     9bc:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     9c3:       48 8b 93 28 0a 00       add    $0x4010,%rax
    0.00 :	     9c9:       00 48                   mov    (%rax),%eax
    0.00 :	     9cb:       89 83                   mov    %eax,%eax
    0.00 :	     9cd:       d8 09 00 00 48 8b 83    add    %rax,0x9e8(%rbx)
    0.00 :	     9d4:       70 05 00 00             add    %rax,0x70(%rsi)
    0.00 :	     9d8:       48 05 38 40 00 00 8b    mov    0x570(%rbx),%rax
    0.00 :	     9df:       00 89 c0 48 01 d0 48    mov    0x9f0(%rbx),%rdx
    0.00 :	     9e6:       89 83 28 0a 00 00       add    $0x4014,%rax
    0.00 :	     9ec:       48 8b                   mov    (%rax),%eax
    0.00 :	     9ee:       83 70                   mov    %eax,%eax
    0.00 :	     9f0:       05 00 00                add    %rdx,%rax
    0.00 :	     9f3:       48 05 10 40 00 00 8b    mov    0x9f8(%rbx),%rdx
    0.00 :	     9fa:       00 89 c0 48 01 83 e8    mov    %rax,0x9f0(%rbx)
    0.00 :	     a01:       09 00 00 48 01 46 70    mov    0x570(%rbx),%rax
    0.00 :	     a08:       48 8b 83 70 05 00       add    $0x4018,%rax
    0.00 :	     a0e:       00 48                   mov    (%rax),%eax
    0.00 :	     a10:       8b 93                   mov    %eax,%eax
    0.00 :	     a12:       f0 09 00                add    %rdx,%rax
    0.00 :	     a15:       00 48 05 14 40 00 00    mov    0xa00(%rbx),%rdx
    0.00 :	     a1c:       8b 00 89 c0 48 01 d0    mov    %rax,0x9f8(%rbx)
    0.00 :	     a23:       48 8b 93 f8 09 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a2a:       48 89 83 f0 09 00       add    $0x401c,%rax
    0.00 :	     a30:       00 48                   mov    (%rax),%eax
    0.00 :	     a32:       8b 83                   mov    %eax,%eax
    0.00 :	     a34:       70 05 00                add    %rdx,%rax
    0.00 :	     a37:       00 48 05 18 40 00 00    mov    0xa08(%rbx),%rdx
    0.00 :	     a3e:       8b 00 89 c0 48 01 d0    mov    %rax,0xa00(%rbx)
    0.00 :	     a45:       48 8b 93 00 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a4c:       48 89 83 f8 09 00       add    $0x4020,%rax
    0.00 :	     a52:       00 48                   mov    (%rax),%eax
    0.00 :	     a54:       8b 83                   mov    %eax,%eax
    0.00 :	     a56:       70 05 00                add    %rdx,%rax
    0.00 :	     a59:       00 48 05 1c 40 00 00    mov    0xa18(%rbx),%rdx
    0.00 :	     a60:       8b 00 89 c0 48 01 d0    mov    %rax,0xa08(%rbx)
    0.00 :	     a67:       48 8b 93 08 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a6e:       48 89 83 00 0a 00       add    $0x4030,%rax
    0.00 :	     a74:       00 48                   mov    (%rax),%eax
    0.00 :	     a76:       8b 83                   mov    %eax,%eax
    0.00 :	     a78:       70 05 00                add    %rdx,%rax
    0.00 :	     a7b:       00 48 05 20 40 00 00    mov    0xa38(%rbx),%rdx
    0.00 :	     a82:       8b 00 89 c0 48 01 d0    mov    %rax,0xa18(%rbx)
    0.00 :	     a89:       48 8b 93 18 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     a90:       48 89 83 08 0a 00       add    $0x4040,%rax
    0.00 :	     a96:       00 48                   mov    (%rax),%eax
    0.00 :	     a98:       8b 83                   mov    %eax,%eax
    0.00 :	     a9a:       70 05 00                add    %rdx,%rax
    0.00 :	     a9d:       00 48 05 30 40 00 00    mov    0xa40(%rbx),%rdx
    0.00 :	     aa4:       8b 00 89 c0 48 01 d0    mov    %rax,0xa38(%rbx)
    0.00 :	     aab:       48 8b 93 38 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ab2:       48 89 83 18 0a 00       add    $0x4048,%rax
    0.00 :	     ab8:       00 48                   mov    (%rax),%eax
    0.00 :	     aba:       8b 83                   mov    %eax,%eax
    0.00 :	     abc:       70 05 00                add    %rdx,%rax
    0.00 :	     abf:       00 48 05 40 40 00 00    mov    0xa48(%rbx),%rdx
    0.00 :	     ac6:       8b 00 89 c0 48 01 d0    mov    %rax,0xa40(%rbx)
    0.00 :	     acd:       48 8b 93 40 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ad4:       48 89 83 38 0a 00       add    $0x404c,%rax
    0.00 :	     ada:       00 48                   mov    (%rax),%eax
    0.00 :	     adc:       8b 83                   mov    %eax,%eax
    0.00 :	     ade:       70 05 00                add    %rdx,%rax
    0.00 :	     ae1:       00 48 05 48 40 00 00    mov    0xa50(%rbx),%rdx
    0.00 :	     ae8:       8b 00 89 c0 48 01 d0    mov    %rax,0xa48(%rbx)
    0.00 :	     aef:       48 8b 93 48 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     af6:       48 89 83 40 0a 00       add    $0x4050,%rax
    0.00 :	     afc:       00 48                   mov    (%rax),%eax
    0.00 :	     afe:       8b 83                   mov    %eax,%eax
    0.00 :	     b00:       70 05 00                add    %rdx,%rax
    0.00 :	     b03:       00 48 05 4c 40 00 00    mov    0xa58(%rbx),%rdx
    0.00 :	     b0a:       8b 00 89 c0 48 01 d0    mov    %rax,0xa50(%rbx)
    0.00 :	     b11:       48 8b 93 50 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b18:       48 89 83 48 0a 00       add    $0x4054,%rax
    0.00 :	     b1e:       00 48                   mov    (%rax),%eax
    0.00 :	     b20:       8b 83                   mov    %eax,%eax
    0.00 :	     b22:       70 05 00                add    %rdx,%rax
    0.00 :	     b25:       00 48 05 50 40 00 00    mov    0xa60(%rbx),%rdx
    0.00 :	     b2c:       8b 00 89 c0 48 01 d0    mov    %rax,0xa58(%rbx)
    0.00 :	     b33:       48 8b 93 58 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b3a:       48 89 83 50 0a 00       add    $0x4058,%rax
    0.00 :	     b40:       00 48                   mov    (%rax),%eax
    0.00 :	     b42:       8b 83                   mov    %eax,%eax
    0.00 :	     b44:       70 05 00                add    %rdx,%rax
    0.00 :	     b47:       00 48 05 54 40 00 00    mov    0xab0(%rbx),%rdx
    0.00 :	     b4e:       8b 00 89 c0 48 01 d0    mov    %rax,0xa60(%rbx)
    0.00 :	     b55:       48 8b 93 60 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b5c:       48 89 83 58 0a 00       add    $0x4080,%rax
    0.00 :	     b62:       00 48                   mov    (%rax),%eax
 ??:0
  100.00 :	     b64:       8b 83                   mov    %eax,%eax
    0.00 :	     b66:       70 05 00                add    %rdx,%rax
    0.00 :	     b69:       00 48 05 58 40 00 00    mov    0xac0(%rbx),%rdx
    0.00 :	     b70:       8b 00 89 c0 48 01 d0    mov    %rax,0xab0(%rbx)
    0.00 :	     b77:       48 8b 93 b0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     b7e:       48 89 83 60 0a 00       add    $0x4090,%rax
    0.00 :	     b84:       00 48                   mov    (%rax),%eax
    0.00 :	     b86:       8b 83                   mov    %eax,%eax
    0.00 :	     b88:       70 05 00                add    %rdx,%rax
    0.00 :	     b8b:       00 48 05 80 40 00 00    mov    %rax,0xac0(%rbx)
    0.00 :	     b92:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     b99:       48 8b 93 c0 0a 00       add    $0x4094,%rax
    0.00 :	     b9f:       00 48                   mov    (%rax),%eax
    0.00 :	     ba1:       89 83 b0 0a 00 00 48    mov    0x570(%rbx),%rax
    0.00 :	     ba8:       8b 83 70 05 00 00 48    mov    0xac8(%rbx),%rdx
    0.00 :	     baf:       05 90 40 00 00 8b       add    $0x40a0,%rax
    0.00 :	     bb5:       00 89                   mov    (%rax),%eax
    0.00 :	     bb7:       c0 48                   mov    %eax,%eax
    0.00 :	     bb9:       01 d0 48                add    %rdx,%rax
    0.00 :	     bbc:       89 83 c0 0a 00 00 48    mov    0xad0(%rbx),%rdx
    0.00 :	     bc3:       8b 83 70 05 00 00 48    mov    %rax,0xac8(%rbx)
    0.00 :	     bca:       05 94 40 00 00 8b 00    mov    0x570(%rbx),%rax
    0.00 :	     bd1:       48 8b 83 70 05 00       add    $0x40a4,%rax
    0.00 :	     bd7:       00 48                   mov    (%rax),%eax
    0.00 :	     bd9:       8b 93                   mov    %eax,%eax
    0.00 :	     bdb:       c8 0a 00                add    %rdx,%rax
    0.00 :	     bde:       00 48 05 a0 40 00 00    mov    0xad8(%rbx),%rdx
    0.00 :	     be5:       8b 00 89 c0 48 01 d0    mov    %rax,0xad0(%rbx)
    0.00 :	     bec:       48 8b 93 d0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     bf3:       48 89 83 c8 0a 00       add    $0x40a8,%rax
    0.00 :	     bf9:       00 48                   mov    (%rax),%eax
    0.00 :	     bfb:       8b 83                   mov    %eax,%eax
    0.00 :	     bfd:       70 05 00                add    %rdx,%rax
    0.00 :	     c00:       00 48 05 a4 40 00 00    mov    0xae8(%rbx),%rdx
    0.00 :	     c07:       8b 00 89 c0 48 01 d0    mov    %rax,0xad8(%rbx)
    0.00 :	     c0e:       48 8b 93 d8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c15:       48 89 83 d0 0a 00       add    $0x40b0,%rax
    0.00 :	     c1b:       00 48                   mov    (%rax),%eax
    0.00 :	     c1d:       8b 83                   mov    %eax,%eax
    0.00 :	     c1f:       70 05 00                add    %rdx,%rax
    0.00 :	     c22:       00 48 05 a8 40 00 00    mov    0xb08(%rbx),%rdx
    0.00 :	     c29:       8b 00 89 c0 48 01 d0    mov    %rax,0xae8(%rbx)
    0.00 :	     c30:       48 8b 93 e8 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c37:       48 89 83 d8 0a 00       add    $0x40c4,%rax
    0.00 :	     c3d:       00 48                   mov    (%rax),%eax
    0.00 :	     c3f:       8b 83                   mov    %eax,%eax
    0.00 :	     c41:       70 05 00                add    %rdx,%rax
    0.00 :	     c44:       00 48 05 b0 40 00 00    mov    0xb10(%rbx),%rdx
    0.00 :	     c4b:       8b 00 89 c0 48 01 d0    mov    %rax,0xb08(%rbx)
    0.00 :	     c52:       48 8b 93 08 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c59:       48 89 83 e8 0a 00       add    $0x40cc,%rax
    0.00 :	     c5f:       00 48                   mov    (%rax),%eax
    0.00 :	     c61:       8b 83                   mov    %eax,%eax
    0.00 :	     c63:       70 05 00                add    %rdx,%rax
    0.00 :	     c66:       00 48 05 c4 40 00 00    mov    0xb18(%rbx),%rdx
    0.00 :	     c6d:       8b 00 89 c0 48 01 d0    mov    %rax,0xb10(%rbx)
    0.00 :	     c74:       48 8b 93 10 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c7b:       48 89 83 08 0b 00       add    $0x40d0,%rax
    0.00 :	     c81:       00 48                   mov    (%rax),%eax
    0.00 :	     c83:       8b 83                   mov    %eax,%eax
    0.00 :	     c85:       70 05 00                add    %rdx,%rax
    0.00 :	     c88:       00 48 05 cc 40 00 00    mov    0xb28(%rbx),%rdx
    0.00 :	     c8f:       8b 00 89 c0 48 01 d0    mov    %rax,0xb18(%rbx)
    0.00 :	     c96:       48 8b 93 18 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     c9d:       48 89 83 10 0b 00       add    $0x40d8,%rax
    0.00 :	     ca3:       00 48                   mov    (%rax),%eax
    0.00 :	     ca5:       8b 83                   mov    %eax,%eax
    0.00 :	     ca7:       70 05 00                add    %rdx,%rax
    0.00 :	     caa:       00 48 05 d0 40 00 00    mov    0xb30(%rbx),%rdx
    0.00 :	     cb1:       8b 00 89 c0 48 01 d0    mov    %rax,0xb28(%rbx)
    0.00 :	     cb8:       48 8b 93 28 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     cbf:       48 89 83 18 0b 00       add    $0x40dc,%rax
    0.00 :	     cc5:       00 48                   mov    (%rax),%eax
    0.00 :	     cc7:       8b 83                   mov    %eax,%eax
    0.00 :	     cc9:       70 05 00                add    %rdx,%rax
    0.00 :	     ccc:       00 48 05 d8 40 00 00    mov    0xb38(%rbx),%rdx
    0.00 :	     cd3:       8b 00 89 c0 48 01 d0    mov    %rax,0xb30(%rbx)
    0.00 :	     cda:       48 8b 93 30 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ce1:       48 89 83 28 0b 00       add    $0x40e0,%rax
    0.00 :	     ce7:       00 48                   mov    (%rax),%eax
    0.00 :	     ce9:       8b 83                   mov    %eax,%eax
    0.00 :	     ceb:       70 05 00                add    %rdx,%rax
    0.00 :	     cee:       00 48 05 dc 40 00 00    mov    0xb40(%rbx),%rdx
    0.00 :	     cf5:       8b 00 89 c0 48 01 d0    mov    %rax,0xb38(%rbx)
    0.00 :	     cfc:       48 8b 93 38 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d03:       48 89 83 30 0b 00       add    $0x40e4,%rax
    0.00 :	     d09:       00 48                   mov    (%rax),%eax
    0.00 :	     d0b:       8b 83                   mov    %eax,%eax
    0.00 :	     d0d:       70 05 00                add    %rdx,%rax
    0.00 :	     d10:       00 48 05 e0 40 00 00    mov    0xb48(%rbx),%rdx
    0.00 :	     d17:       8b 00 89 c0 48 01 d0    mov    %rax,0xb40(%rbx)
    0.00 :	     d1e:       48 8b 93 40 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d25:       48 89 83 38 0b 00       add    $0x40e8,%rax
    0.00 :	     d2b:       00 48                   mov    (%rax),%eax
    0.00 :	     d2d:       8b 83                   mov    %eax,%eax
    0.00 :	     d2f:       70 05 00                add    %rdx,%rax
    0.00 :	     d32:       00 48 05 e4 40 00 00    mov    0xb50(%rbx),%rdx
    0.00 :	     d39:       8b 00 89 c0 48 01 d0    mov    %rax,0xb48(%rbx)
    0.00 :	     d40:       48 8b 93 48 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d47:       48 89 83 40 0b 00       add    $0x40ec,%rax
    0.00 :	     d4d:       00 48                   mov    (%rax),%eax
    0.00 :	     d4f:       8b 83                   mov    %eax,%eax
    0.00 :	     d51:       70 05 00                add    %rdx,%rax
    0.00 :	     d54:       00 48 05 e8 40 00 00    mov    0xb58(%rbx),%rdx
    0.00 :	     d5b:       8b 00 89 c0 48 01 d0    mov    %rax,0xb50(%rbx)
    0.00 :	     d62:       48 8b 93 50 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d69:       48 89 83 48 0b 00       add    $0x40f0,%rax
    0.00 :	     d6f:       00 48                   mov    (%rax),%eax
    0.00 :	     d71:       8b 83                   mov    %eax,%eax
    0.00 :	     d73:       70 05 00                add    %rdx,%rax
    0.00 :	     d76:       00 48 05 ec 40 00 00    mov    0xb60(%rbx),%rdx
    0.00 :	     d7d:       8b 00 89 c0 48 01 d0    mov    %rax,0xb58(%rbx)
    0.00 :	     d84:       48 8b 93 58 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     d8b:       48 89 83 50 0b 00       add    $0x40f4,%rax
    0.00 :	     d91:       00 48                   mov    (%rax),%eax
    0.00 :	     d93:       8b 83                   mov    %eax,%eax
    0.00 :	     d95:       70 05 00                add    %rdx,%rax
    0.00 :	     d98:       00 48 05 f0 40 00 00    mov    0xb20(%rbx),%rdx
    0.00 :	     d9f:       8b 00 89 c0 48 01 d0    mov    %rax,0xb60(%rbx)
    0.00 :	     da6:       48 8b 93 60 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     dad:       48 89 83 58 0b 00       add    $0x40d4,%rax
    0.00 :	     db3:       00 48                   mov    (%rax),%eax
    0.00 :	     db5:       8b 83                   mov    %eax,%eax
    0.00 :	     db7:       70 05 00                add    %rdx,%rax
    0.00 :	     dba:       00 48 05 f4 40 00 00    mov    0xa10(%rbx),%rdx
    0.00 :	     dc1:       8b 00 89 c0 48 01 d0    mov    %rax,0xb20(%rbx)
    0.00 :	     dc8:       48 8b 93 20 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     dcf:       48 89 83 60 0b 00       add    $0x4028,%rax
    0.00 :	     dd5:       00 48                   mov    (%rax),%eax
    0.00 :	     dd7:       8b 83                   mov    %eax,%eax
    0.00 :	     dd9:       70 05 00                add    %rdx,%rax
    0.00 :	     ddc:       00 48 05 d4 40 00 00    mov    0x9d0(%rbx),%rdx
    0.00 :	     de3:       8b 00 89 c0 48 01 d0    mov    %rax,0xa10(%rbx)
    0.00 :	     dea:       48 8b 93 10 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     df1:       48 89 83 20 0b 00       add    $0x4004,%rax
    0.00 :	     df7:       00 48                   mov    (%rax),%eax
    0.00 :	     df9:       8b 83                   mov    %eax,%eax
    0.00 :	     dfb:       70 05 00                add    %rdx,%rax
    0.00 :	     dfe:       00 48 05 28 40 00 00    mov    %rax,0x9d0(%rbx)
    0.00 :	     e05:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	     e0c:       48 8b 93 d0             add    $0x18,%rax
    0.00 :	     e10:       09 00                   mov    (%rax),%eax
    0.00 :	     e12:       00 48 89 83 10          test   $0xc00000,%eax
    0.00 :	     e17:       0a 00                   jne    e6c <dma_unmap_page+0xe3c>
    0.00 :	     e19:       00 48 8b 83 70 05 00    mov    0x570(%rbx),%rax
    0.00 :	     e20:       00 48 05 04 40 00 00    mov    0x9e0(%rbx),%rdx
    0.00 :	     e27:       8b 00 89 c0 48 01       add    $0x400c,%rax
    0.00 :	     e2d:       d0 48                   mov    (%rax),%eax
    0.00 :	     e2f:       89 83                   mov    %eax,%eax
    0.00 :	     e31:       d0 09 00                add    %rdx,%rax
    0.00 :	     e34:       00 48 8b 83 70 05 00    mov    %rax,0x9e0(%rbx)
    0.00 :	     e3b:       00 48 83 c0 18 8b       mov    0x5e4(%rbx),%eax
    0.00 :	     e41:       00 a9 00                sub    $0x5,%eax
    0.00 :	     e44:       00 c0 00                cmp    $0x1,%eax
    0.00 :	     e47:       75 53                   jbe    e6c <dma_unmap_page+0xe3c>
    0.00 :	     e49:       48 8b 83 70 05 00 00    mov    0x570(%rbx),%rdx
    0.00 :	     e50:       48 8b 93 e0 09 00 00    mov    0xa20(%rbx),%rax
    0.00 :	     e57:       48 05 0c 40 00 00 8b    add    $0x4034,%rdx
    0.00 :	     e5e:       00 89                   mov    (%rdx),%edx
    0.00 :	     e60:       c0 48                   mov    %edx,%edx
    0.00 :	     e62:       01 d0 48                add    %rax,%rdx
    0.00 :	     e65:       89 83 e0 09 00 00 8b    mov    %rdx,0xa20(%rbx)
    0.00 :	     e6c:       83 e4 05 00 00 83 e8    mov    0x570(%rbx),%rax
    0.00 :	     e73:       05 83 f8 01 76 23 48    mov    0xb68(%rbx),%rdx
    0.00 :	     e7a:       8b 93 70 05 00 00       add    $0x40f8,%rax
    0.00 :	     e80:       48 8b                   mov    (%rax),%eax
    0.00 :	     e82:       83 20                   mov    %eax,%eax
    0.00 :	     e84:       0a 00 00                add    %rdx,%rax
    0.00 :	     e87:       48 81 c2 34 40 00 00    mov    0xb70(%rbx),%rdx
    0.00 :	     e8e:       8b 12 89 d2 48 01 c2    mov    %rax,0xb68(%rbx)
    0.00 :	     e95:       48 89 93 20 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	     e9c:       48 8b 83 70 05 00       add    $0x40fc,%rax
    0.00 :	     ea2:       00 48                   mov    (%rax),%eax
    0.00 :	     ea4:       8b 93                   mov    %eax,%eax
    0.00 :	     ea6:       68 0b 00                add    %rdx,%rax
    0.00 :	     ea9:       00 48 05 f8 40 00 00    mov    0xb78(%rbx),%rdx
    0.00 :	     eb0:       8b 00 89 c0 48 01 d0    mov    %rax,0xb70(%rbx)
    0.00 :	     eb7:       48 8b 93 70 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ebe:       48 89 83 68 0b 00       add    $0x4100,%rax
    0.00 :	     ec4:       00 48                   mov    (%rax),%eax
    0.00 :	     ec6:       8b 83                   mov    %eax,%eax
    0.00 :	     ec8:       70 05 00                add    %rdx,%rax
    0.00 :	     ecb:       00 48 05 fc 40 00 00    mov    0xbb8(%rbx),%rdx
    0.00 :	     ed2:       8b 00 89 c0 48 01 d0    mov    %rax,0xb78(%rbx)
    0.00 :	     ed9:       48 8b 93 78 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     ee0:       48 89 83 70 0b 00       add    $0x4124,%rax
    0.00 :	     ee6:       00 48                   mov    (%rax),%eax
    0.00 :	     ee8:       8b 83                   mov    %eax,%eax
    0.00 :	     eea:       70 05 00                add    %rdx,%rax
    0.00 :	     eed:       00 48 05 00 41 00 00    mov    0xb80(%rbx),%rdx
    0.00 :	     ef4:       8b 00 89 c0 48 01 d0    mov    %rax,0xbb8(%rbx)
    0.00 :	     efb:       48 8b 93 b8 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f02:       48 89 83 78 0b 00       add    $0x4104,%rax
    0.00 :	     f08:       00 48                   mov    (%rax),%eax
    0.00 :	     f0a:       8b 83                   mov    %eax,%eax
    0.00 :	     f0c:       70 05 00                add    %rdx,%rax
    0.00 :	     f0f:       00 48 05 24 41 00 00    mov    0xb88(%rbx),%rdx
    0.00 :	     f16:       8b 00 89 c0 48 01 d0    mov    %rax,0xb80(%rbx)
    0.00 :	     f1d:       48 8b 93 80 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f24:       48 89 83 b8 0b 00       add    $0x4108,%rax
    0.00 :	     f2a:       00 48                   mov    (%rax),%eax
    0.00 :	     f2c:       8b 83                   mov    %eax,%eax
    0.00 :	     f2e:       70 05 00                add    %rdx,%rax
    0.00 :	     f31:       00 48 05 04 41 00 00    mov    0xb90(%rbx),%rdx
    0.00 :	     f38:       8b 00 89 c0 48 01 d0    mov    %rax,0xb88(%rbx)
    0.00 :	     f3f:       48 8b 93 88 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f46:       48 89 83 80 0b 00       add    $0x410c,%rax
    0.00 :	     f4c:       00 48                   mov    (%rax),%eax
    0.00 :	     f4e:       8b 83                   mov    %eax,%eax
    0.00 :	     f50:       70 05 00                add    %rdx,%rax
    0.00 :	     f53:       00 48 05 08 41 00 00    mov    0xb98(%rbx),%rdx
    0.00 :	     f5a:       8b 00 89 c0 48 01 d0    mov    %rax,0xb90(%rbx)
    0.00 :	     f61:       48 8b 93 90 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f68:       48 89 83 88 0b 00       add    $0x4110,%rax
    0.00 :	     f6e:       00 48                   mov    (%rax),%eax
    0.00 :	     f70:       8b 83                   mov    %eax,%eax
    0.00 :	     f72:       70 05 00                add    %rdx,%rax
    0.00 :	     f75:       00 48 05 0c 41 00 00    mov    0xba0(%rbx),%rdx
    0.00 :	     f7c:       8b 00 89 c0 48 01 d0    mov    %rax,0xb98(%rbx)
    0.00 :	     f83:       48 8b 93 98 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     f8a:       48 89 83 90 0b 00       add    $0x4118,%rax
    0.00 :	     f90:       00 48                   mov    (%rax),%eax
    0.00 :	     f92:       8b 83                   mov    %eax,%eax
    0.00 :	     f94:       70 05 00                add    %rdx,%rax
    0.00 :	     f97:       00 48 05 10 41 00 00    mov    0xba8(%rbx),%rdx
    0.00 :	     f9e:       8b 00 89 c0 48 01 d0    mov    %rax,0xba0(%rbx)
    0.00 :	     fa5:       48 8b 93 a0 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     fac:       48 89 83 98 0b 00       add    $0x411c,%rax
    0.00 :	     fb2:       00 48                   mov    (%rax),%eax
    0.00 :	     fb4:       8b 83                   mov    %eax,%eax
    0.00 :	     fb6:       70 05 00                add    %rdx,%rax
    0.00 :	     fb9:       00 48 05 18 41 00 00    mov    0xbb0(%rbx),%rdx
    0.00 :	     fc0:       8b 00 89 c0 48 01 d0    mov    %rax,0xba8(%rbx)
    0.00 :	     fc7:       48 8b 93 a8 0b 00 00    mov    0x570(%rbx),%rax
    0.00 :	     fce:       48 89 83 a0 0b 00       add    $0x4120,%rax
    0.00 :	     fd4:       00 48                   mov    (%rax),%eax
    0.00 :	     fd6:       8b 83                   mov    %eax,%eax
    0.00 :	     fd8:       70 05 00                add    %rdx,%rax
    0.00 :	     fdb:       00 48 05 1c 41 00 00    mov    %rax,0xbb0(%rbx)
    0.00 :	     fe2:       8b 00 89 c0 48 01 d0    mov    0xaa8(%rbx),%rax
    0.00 :	     fe9:       48 8b 93 b0             mov    %rax,0x40(%rsi)
    0.00 :	     fed:       0b 00 00 48 89 83 a8    mov    0xa10(%rbx),%rax
    0.00 :	     ff4:       0b 00 00 48             mov    %rax,0x48(%rsi)
    0.00 :	     ff8:       8b 83 70 05 00 00 48    mov    0x9c8(%rbx),%rax
    0.00 :	     fff:       05 20 41 00 00 8b 00    add    0x9e0(%rbx),%rax
    0.00 :	    1006:       89 c0 48 01 d0 48 89    add    0x9d0(%rbx),%rax
    0.00 :	    100d:       83 b0 0b 00 00 48 8b    add    0xad0(%rbx),%rax
    0.00 :	    1014:       83 a8 0a 00 00 48 89    add    0xae0(%rbx),%rax
    0.00 :	    101b:       46 40 48 8b 83 10 0a    add    0xa30(%rbx),%rax
    0.00 :	    1022:       00 00 48 89             mov    %rax,0x20(%rsi)
    0.00 :	    1026:       46 48 48 8b 83 c8 09    mov    0xae0(%rbx),%rax
    0.00 :	    102d:       00 00 48 03 83 e0 09    add    0xad0(%rbx),%rax
    0.00 :	    1034:       00 00 48 03             mov    %rax,0x50(%rsi)
    0.00 :	    1038:       83 d0 09 00 00 48 03    mov    0x9c8(%rbx),%rax
    0.00 :	    103f:       83 d0 0a 00             mov    %rax,0x60(%rsi)
    0.00 :	    1043:       00 48 03 83 e0 0a 00    mov    0x9d0(%rbx),%rax
    0.00 :	    104a:       00 48 03 83             mov    %rax,0x68(%rsi)
    0.00 :	    104e:       30 0a 00 00 48 89 46    mov    0x9e8(%rbx),%rax
    0.00 :	    1055:       20 48 8b 83             mov    %rax,0x78(%rsi)
    0.00 :	    1059:       e0 0a 00 00 48 03 83    mov    0xa08(%rbx),%rax
    0.00 :	    1060:       d0 0a 00 00 48 89 46    add    0x9f8(%rbx),%rax
    0.00 :	    1067:       50 48 8b 83             mov    %rax,0x28(%rsi)
    0.00 :	    106b:       c8 09 00 00 48 89 46    mov    0x9f8(%rbx),%rax
    0.00 :	    1072:       60 48 8b 83 d0 09 00    mov    %rax,0x80(%rsi)
    0.00 :	    1079:       00 48 89 46 68 48 8b    mov    0xa08(%rbx),%rax
    0.00 :	    1080:       83 e8 09 00 00 48 89    mov    %rax,0xa0(%rsi)
    0.00 :	    1087:       46 78 48 8b 83 08 0a    mov    0xa20(%rbx),%rax
    0.00 :	    108e:       00 00 48 03 83 f8 09    mov    %rax,0x88(%rsi)
    0.00 :	    1095:       00 00 48 89 46 28 48    cmpl   $0x1,0x8bc(%rbx)
    0.00 :	    109c:       8b 83 f8 09 00 00       je     11b0 <dma_unmap_page+0x1180>
    0.00 :	    10a2:       48 89 86 80 00 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10a9:       48 8b 83 08 0a 00 00    mov    0xb00(%rbx),%rdx
    0.00 :	    10b0:       48 89 86 a0 00 00       add    $0x40bc,%rax
    0.00 :	    10b6:       00 48                   mov    (%rax),%eax
    0.00 :	    10b8:       8b 83                   mov    %eax,%eax
    0.00 :	    10ba:       20 0a 00                add    %rdx,%rax
    0.00 :	    10bd:       00 48 89 86 88 00 00    mov    0xaf0(%rbx),%rdx
    0.00 :	    10c4:       00 83 bb bc 08 00 00    mov    %rax,0xb00(%rbx)
    0.00 :	    10cb:       01 0f 84 0e 01 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10d2:       48 8b 83 70 05 00       add    $0x40b4,%rax
    0.00 :	    10d8:       00 48                   mov    (%rax),%eax
    0.00 :	    10da:       8b 93                   mov    %eax,%eax
    0.00 :	    10dc:       00 0b 00                add    %rdx,%rax
    0.00 :	    10df:       00 48 05 bc 40 00 00    mov    0xaf8(%rbx),%rdx
    0.00 :	    10e6:       8b 00 89 c0 48 01 d0    mov    %rax,0xaf0(%rbx)
    0.00 :	    10ed:       48 8b 93 f0 0a 00 00    mov    0x570(%rbx),%rax
    0.00 :	    10f4:       48 89 83 00 0b 00       add    $0x40b8,%rax
    0.00 :	    10fa:       00 48                   mov    (%rax),%eax
    0.00 :	    10fc:       8b 83                   mov    %eax,%eax
    0.00 :	    10fe:       70 05 00                add    %rdx,%rax
    0.00 :	    1101:       00 48 05 b4 40 00 00    mov    %rax,0xaf8(%rbx)
    0.00 :	    1108:       8b 00 89 c0 48 01 d0    mov    0x570(%rbx),%rax
    0.00 :	    110f:       48 8b 93 f8 0a 00       add    $0x5820,%rax
    0.00 :	    1115:       00 48                   mov    (%rax),%eax
    0.00 :	    1117:       89 83 f0 0a 00          test   $0x10000000,%eax
    0.00 :	    111c:       00 48 8b 83 70 05       je     722 <dma_unmap_page+0x6f2>
    0.00 :	    1122:       00 00 48 05 b8 40 00    mov    0x570(%rbx),%rax
    0.00 :	    1129:       00 8b 00 89 c0 48 01    mov    0xc28(%rbx),%rdx
    0.00 :	    1130:       d0 48 89 83 f8 0a       add    $0x8fe4,%rax
    0.00 :	    1136:       00 00                   mov    (%rax),%eax
    0.00 :	    1138:       48 8b                   mov    %eax,%eax
    0.00 :	    113a:       83 70 05                add    %rdx,%rax
    0.00 :	    113d:       00 00 48 05 20 58 00    mov    0xc30(%rbx),%rdx
    0.00 :	    1144:       00 8b 00 a9 00 00 00    mov    %rax,0xc28(%rbx)
    0.00 :	    114b:       10 0f 84 00 f6 ff ff    mov    0x570(%rbx),%rax
    0.00 :	    1152:       48 8b 83 70 05 00       add    $0x415c,%rax
    0.00 :	    1158:       00 48                   mov    (%rax),%eax
    0.00 :	    115a:       8b 93                   mov    %eax,%eax
    0.00 :	    115c:       28 0c 00                add    %rdx,%rax
    0.00 :	    115f:       00 48 05 e4 8f 00 00    mov    0xc38(%rbx),%rdx
    0.00 :	    1166:       8b 00 89 c0 48 01 d0    mov    %rax,0xc30(%rbx)
    0.00 :	    116d:       48 8b 93 30 0c 00 00    mov    0x570(%rbx),%rax
    0.00 :	    1174:       48 89 83 28 0c 00       add    $0x8fe0,%rax
    0.00 :	    117a:       00 48                   mov    (%rax),%eax
    0.00 :	    117c:       8b 83                   mov    %eax,%eax
    0.00 :	    117e:       70 05 00                add    %rdx,%rax
    0.00 :	    1181:       00 48 05 5c 41 00 00    mov    0xc40(%rbx),%rdx
    0.00 :	    1188:       8b 00 89 c0 48 01 d0    mov    %rax,0xc38(%rbx)
    0.00 :	    118f:       48 8b 93 38 0c 00 00    mov    0x570(%rbx),%rax
    0.00 :	    1196:       48 89 83 30 0c 00       add    $0x4158,%rax
    0.00 :	    119c:       00 48                   mov    (%rax),%eax
    0.00 :	    119e:       8b 83                   mov    %eax,%eax
    0.00 :	    11a0:       70 05 00                add    %rdx,%rax
    0.00 :	    11a3:       00 48 05 e0 8f 00 00    mov    %rax,0xc40(%rbx)
    0.00 :	    11aa:       8b 00 89 c0             add    $0x10,%rsp
    0.00 :	    11ae:       48                      pop    %rbx
    0.00 :	    11af:       01                      retq   
    0.00 :	    11b0:       d0 48 8b 93 40 0c 00    cmpw   $0x3e8,0x3f8(%rbx)
    0.00 :	    11b7:       00 48 
    0.00 :	    11b9:       89 83 38 0c 00 00       jne    10a2 <dma_unmap_page+0x1072>
    0.00 :	    11bf:       48 8b 83 70 05 00 00    mov    0x860(%rbx),%rax
    0.00 :	    11c6:       48 05 58                test   %rax,%rax
    0.00 :	    11c9:       41 00                   je     11e6 <dma_unmap_page+0x11b6>
    0.00 :	    11cb:       00 8b 00 89 c0          lea    0xe(%rsp),%rdx
    0.00 :	    11d0:       48 01 d0 48 89 83 40    lea    0x568(%rbx),%rdi
    0.00 :	    11d7:       0c 00 00 48 83          mov    $0xa,%esi
    0.00 :	    11dc:       c4 10                   callq  *%rax
    0.00 :	    11de:       5b c3                   test   %eax,%eax
    0.00 :	    11e0:       66 81 bb f8 03 00       jne    10a2 <dma_unmap_page+0x1072>
    0.00 :	    11e6:       00 e8 03 0f 85          movzbl 0xe(%rsp),%eax
    0.00 :	    11eb:       e3 fe ff ff 48          mov    %ax,0xe(%rsp)
    0.00 :	    11f0:       8b 83 60                movzwl %ax,%eax
    0.00 :	    11f3:       08 00 00 48 85 c0       add    %eax,0xcf8(%rbx)
    0.00 :	    11f9:       74 1b 48 8d 54          jmpq   10a2 <dma_unmap_page+0x1072>
         :	    11fe:       24 0e                   xchg   %ax,%ax
         :	    1200:       48 8d bb 68             sub    $0x18,%rsp
         :	    1204:       05 00 00 be             mov    %rbx,(%rsp)
         :	    1208:       0a 00 00 00 ff          mov    %rbp,0x8(%rsp)
         :	    120d:       d0 85 c0                mov    %rdi,%rbx
         :	    1210:       0f 85 bc fe ff          mov    %r12,0x10(%rsp)
         :	    1215:       ff 0f b6 44             mov    0x20(%rdi),%rsi
         :	    1219:       24 0e 66                mov    (%rdi),%rbp
         :	    121c:       89 44 24                test   %rsi,%rsi
         :	    121f:       0e 0f b7 c0 01 83       je     13b0 <dma_unmap_page+0x1380>
         :	    1225:       f8 0c 00 00 e9 a4 fe    testb  $0x3,0x220(%rbp)
         :	    122c:       ff ff                   je     127b <dma_unmap_page+0x124b>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib/modules/3.0.101-0.15-default/kernel/drivers/cpufreq/mperf.ko
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib/modules/3.0.101-0.15-default/kernel/drivers/cpufreq/mperf.ko
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	0000000000000000 <cpufreq_get_measured_perf>:
 ??:0
  100.00 :	   0:   55                      push   %rbp
    0.00 :	  31:   b9 01 00 00             mov    0x8(%rsp),%eax
    0.00 :	  35:   00 48 89 fd 53 89 f3    mov    0x0(,%rax,8),%rsi
    0.00 :	  3c:   48 
    0.00 :	  3d:   c7 c6 00                mov    %rdi,%rdx
    0.00 :	  40:   00 00 00 89             mov    (%rsp),%rcx
    0.00 :	  44:   df 48 83                add    %rsi,%rdx
    0.00 :	  47:   ec 18 48 89             sub    0x8(%rdx),%r8
    0.00 :	  4b:   e2 e8 00                sub    (%rdx),%rcx
    0.00 :	  4e:   00 00 00 31             shr    $0xa,%r8
    0.00 :	  52:   d2 85 c0                test   %r8,%r8
    0.00 :	  55:   75 53                   jne    88 <cpufreq_get_measured_perf+0x58>
    0.00 :	  57:   89 d8 48 c7             mov    (%rsp),%rdx
    0.00 :	  5b:   c7 00 00                mov    %rdi,%rax
    0.00 :	  5e:   00 00 4c 8b             mov    %rdx,(%rax,%rsi,1)
    0.00 :	  62:   44 24 08 48 8b          mov    0x8(%rsp),%rdx
    0.00 :	  67:   34 c5 00 00 00          mov    %rdx,0x8(%rax,%rsi,1)
    0.00 :	  6c:   00 48 89                mov    0x18(%rbp),%eax
    0.00 :	  6f:   fa 48 8b 0c             imul   %rax,%rcx
    0.00 :	  73:   24 48 01                mov    %rcx,%rdx
    0.00 :	  76:   f2 4c 2b 42             shr    $0xa,%rdx
    0.00 :	  7a:   08 48 2b 0a             add    $0x18,%rsp
    0.00 :	  7e:   49 c1                   mov    %edx,%eax
    0.00 :	  80:   e8                      pop    %rbx
    0.00 :	  81:   0a                      pop    %rbp
    0.00 :	  82:   4d                      retq   
    0.00 :	  83:   85 c0 75 31 48          nopl   0x0(%rax,%rax,1)
    0.00 :	  88:   8b 14 24                mov    %rcx,%rax
    0.00 :	  8b:   48 89                   xor    %edx,%edx
    0.00 :	  8d:   f8 48 89                div    %r8
    0.00 :	  90:   14 30 48                mov    %rax,%rcx
    0.00 :	  93:   8b 54                   jmp    57 <cpufreq_get_measured_perf+0x27>
         :	  95:   24 08 48 89 54 30 08    data32 nopw %cs:0x0(%rax,%rax,1)
         :	  9c:   8b 45 18 48 
         :	  a0:   0f af c8 48             sub    $0x38,%rsp
         :	  a4:   89 ca 48 c1 ea 0a 48    mov    0x0(%rip),%rdx        # ab <cpufreq_get_measured_perf+0x7b>
         :	  ab:   83 c4 18 89 d0 5b 5d    movabs $0x1000000000000000,%rax
         :	  b2:   c3 0f 1f 
         :	  b5:   44 00 00 48 89          mov    %rbx,0x18(%rsp)
         :	  ba:   c8 31 d2 49 f7          mov    %rbp,0x20(%rsp)
         :	  bf:   f0 48 89                mov    %rdi,%rbx
         :	  c2:   c1 eb c2 66 66          mov    %r12,0x28(%rsp)

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file /lib64/ld-2.11.3.so
----------------------------------------------

  100.00 ??:0
 Percent |	Source code & Disassembly of /lib64/ld-2.11.3.so
------------------------------------------------
         :
         :
         :
         :	Disassembly of section .text:
         :
         :	000000000000b070 <_dl_relocate_object>:
    0.00 :	    b070:       55                      push   %rbp
    0.00 :	    b071:       48 89 e5                mov    %rsp,%rbp
    0.00 :	    b074:       41 57                   push   %r15
    0.00 :	    b076:       41 56                   push   %r14
    0.00 :	    b078:       49 89 fe                mov    %rdi,%r14
    0.00 :	    b07b:       41 55                   push   %r13
    0.00 :	    b07d:       41 54                   push   %r12
    0.00 :	    b07f:       41 89 d4                mov    %edx,%r12d
    0.00 :	    b082:       41 83 e4 01             and    $0x1,%r12d
    0.00 :	    b086:       53                      push   %rbx
    0.00 :	    b087:       48 81 ec b8 00 00 00    sub    $0xb8,%rsp
    0.00 :	    b08e:       81 e2 00 00 00 08       and    $0x8000000,%edx
    0.00 :	    b094:       48 89 b5 58 ff ff ff    mov    %rsi,-0xa8(%rbp)
    0.00 :	    b09b:       89 8d 54 ff ff ff       mov    %ecx,-0xac(%rbp)
    0.00 :	    b0a1:       75 15                   jne    b0b8 <_dl_relocate_object+0x48>
    0.00 :	    b0a3:       31 c0                   xor    %eax,%eax
    0.00 :	    b0a5:       48 83 3d 83 3c 21 00    cmpq   $0x0,0x213c83(%rip)        # 21ed30 <_rtld_global_ro+0x110>
    0.00 :	    b0ac:       00 
    0.00 :	    b0ad:       0f 95 c0                setne  %al
    0.00 :	    b0b0:       09 c1                   or     %eax,%ecx
    0.00 :	    b0b2:       89 8d 54 ff ff ff       mov    %ecx,-0xac(%rbp)
    0.00 :	    b0b8:       41 f6 86 14 03 00 00    testb  $0x4,0x314(%r14)
    0.00 :	    b0bf:       04 
    0.00 :	    b0c0:       0f 85 1a 02 00 00       jne    b2e0 <_dl_relocate_object+0x270>
    0.00 :	    b0c6:       44 8b 8d 54 ff ff ff    mov    -0xac(%rbp),%r9d
    0.00 :	    b0cd:       45 85 c9                test   %r9d,%r9d
    0.00 :	    b0d0:       0f 84 52 0a 00 00       je     bb28 <_dl_relocate_object+0xab8>
    0.00 :	    b0d6:       f6 05 43 3b 21 00 20    testb  $0x20,0x213b43(%rip)        # 21ec20 <_rtld_global_ro>
    0.00 :	    b0dd:       0f 85 cf 0f 00 00       jne    c0b2 <_dl_relocate_object+0x1042>
    0.00 :	    b0e3:       49 83 be f0 00 00 00    cmpq   $0x0,0xf0(%r14)
    0.00 :	    b0ea:       00 
    0.00 :	    b0eb:       0f 85 ba 0e 00 00       jne    bfab <_dl_relocate_object+0xf3b>
    0.00 :	    b0f1:       48 c7 85 68 ff ff ff    movq   $0x0,-0x98(%rbp)
    0.00 :	    b0f8:       00 00 00 00 
    0.00 :	    b0fc:       49 8b 46 68             mov    0x68(%r14),%rax
    0.00 :	    b100:       45 85 e4                test   %r12d,%r12d
    0.00 :	    b103:       0f 95 c3                setne  %bl
    0.00 :	    b106:       49 83 be f8 00 00 00    cmpq   $0x0,0xf8(%r14)
    0.00 :	    b10d:       00 
    0.00 :	    b10e:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b112:       48 89 85 60 ff ff ff    mov    %rax,-0xa0(%rbp)
    0.00 :	    b119:       0f 85 19 07 00 00       jne    b838 <_dl_relocate_object+0x7c8>
    0.00 :	    b11f:       84 db                   test   %bl,%bl
    0.00 :	    b121:       49 8b 86 88 02 00 00    mov    0x288(%r14),%rax
    0.00 :	    b128:       74 17                   je     b141 <_dl_relocate_object+0xd1>
    0.00 :	    b12a:       48 85 c0                test   %rax,%rax
    0.00 :	    b12d:       74 12                   je     b141 <_dl_relocate_object+0xd1>
    0.00 :	    b12f:       49 8b 16                mov    (%r14),%rdx
    0.00 :	    b132:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b136:       48 8d 0d 53 aa 00 00    lea    0xaa53(%rip),%rcx        # 15b90 <_dl_tlsdesc_resolve_rela>
    0.00 :	    b13d:       48 89 0c 02             mov    %rcx,(%rdx,%rax,1)
    0.00 :	    b141:       49 8b 46 78             mov    0x78(%r14),%rax
    0.00 :	    b145:       c7 45 a0 00 00 00 00    movl   $0x0,-0x60(%rbp)
    0.00 :	    b14c:       48 c7 45 b0 00 00 00    movq   $0x0,-0x50(%rbp)
    0.00 :	    b153:       00 
    0.00 :	    b154:       48 c7 45 98 00 00 00    movq   $0x0,-0x68(%rbp)
    0.00 :	    b15b:       00 
    0.00 :	    b15c:       48 c7 45 90 00 00 00    movq   $0x0,-0x70(%rbp)
    0.00 :	    b163:       00 
    0.00 :	    b164:       48 85 c0                test   %rax,%rax
    0.00 :	    b167:       74 17                   je     b180 <_dl_relocate_object+0x110>
    0.00 :	    b169:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b16d:       48 89 45 90             mov    %rax,-0x70(%rbp)
    0.00 :	    b171:       49 8b 86 80 00 00 00    mov    0x80(%r14),%rax
    0.00 :	    b178:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b17c:       48 89 45 98             mov    %rax,-0x68(%rbp)
    0.00 :	    b180:       49 83 be e0 00 00 00    cmpq   $0x0,0xe0(%r14)
    0.00 :	    b187:       00 
    0.00 :	    b188:       74 37                   je     b1c1 <_dl_relocate_object+0x151>
    0.00 :	    b18a:       49 8b 86 f8 00 00 00    mov    0xf8(%r14),%rax
    0.00 :	    b191:       84 db                   test   %bl,%bl
    0.00 :	    b193:       48 8b 48 08             mov    0x8(%rax),%rcx
    0.00 :	    b197:       75 14                   jne    b1ad <_dl_relocate_object+0x13d>
    0.00 :	    b199:       48 8b 55 98             mov    -0x68(%rbp),%rdx
    0.00 :	    b19d:       48 89 d0                mov    %rdx,%rax
    0.00 :	    b1a0:       48 03 45 90             add    -0x70(%rbp),%rax
    0.00 :	    b1a4:       48 39 c8                cmp    %rcx,%rax
    0.00 :	    b1a7:       0f 84 b1 0a 00 00       je     bc5e <_dl_relocate_object+0xbee>
    0.00 :	    b1ad:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	    b1b1:       48 89 4d a8             mov    %rcx,-0x58(%rbp)
    0.00 :	    b1b5:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b1b9:       44 89 65 b8             mov    %r12d,-0x48(%rbp)
    0.00 :	    b1bd:       48 89 45 b0             mov    %rax,-0x50(%rbp)
    0.00 :	    b1c1:       48 8d 75 90             lea    -0x70(%rbp),%rsi
    0.00 :	    b1c5:       48 8d 45 c8             lea    -0x38(%rbp),%rax
    0.00 :	    b1c9:       48 89 b5 48 ff ff ff    mov    %rsi,-0xb8(%rbp)
    0.00 :	    b1d0:       48 89 75 88             mov    %rsi,-0x78(%rbp)
    0.00 :	    b1d4:       48 89 85 40 ff ff ff    mov    %rax,-0xc0(%rbp)
    0.00 :	    b1db:       48 8b 55 88             mov    -0x78(%rbp),%rdx
    0.00 :	    b1df:       4d 8b 1e                mov    (%r14),%r11
    0.00 :	    b1e2:       48 8b 4a 08             mov    0x8(%rdx),%rcx
    0.00 :	    b1e6:       48 8b 1a                mov    (%rdx),%rbx
    0.00 :	    b1e9:       48 8d 34 0b             lea    (%rbx,%rcx,1),%rsi
    0.00 :	    b1ed:       48 89 b5 78 ff ff ff    mov    %rsi,-0x88(%rbp)
    0.00 :	    b1f4:       8b 7a 10                mov    0x10(%rdx),%edi
    0.00 :	    b1f7:       85 ff                   test   %edi,%edi
    0.00 :	    b1f9:       0f 84 31 01 00 00       je     b330 <_dl_relocate_object+0x2c0>
    0.00 :	    b1ff:       48 39 f3                cmp    %rsi,%rbx
    0.00 :	    b202:       72 52                   jb     b256 <_dl_relocate_object+0x1e6>
    0.00 :	    b204:       e9 87 00 00 00          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b209:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    b210:       48 83 f8 24             cmp    $0x24,%rax
    0.00 :	    b214:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b218:       0f 84 d2 00 00 00       je     b2f0 <_dl_relocate_object+0x280>
    0.00 :	    b21e:       48 83 f8 25             cmp    $0x25,%rax
    0.00 :	    b222:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	    b228:       0f 85 53 0c 00 00       jne    be81 <_dl_relocate_object+0xe11>
    0.00 :	    b22e:       48 8b 43 10             mov    0x10(%rbx),%rax
    0.00 :	    b232:       49 03 06                add    (%r14),%rax
    0.00 :	    b235:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b23c:       ff d0                   callq  *%rax
    0.00 :	    b23e:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	    b242:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b249:       48 83 c3 18             add    $0x18,%rbx
    0.00 :	    b24d:       48 39 9d 78 ff ff ff    cmp    %rbx,-0x88(%rbp)
    0.00 :	    b254:       76 3a                   jbe    b290 <_dl_relocate_object+0x220>
    0.00 :	    b256:       8b 43 08                mov    0x8(%rbx),%eax
    0.00 :	    b259:       4d 89 dc                mov    %r11,%r12
    0.00 :	    b25c:       4c 03 23                add    (%rbx),%r12
    0.00 :	    b25f:       48 83 f8 07             cmp    $0x7,%rax
    0.00 :	    b263:       75 ab                   jne    b210 <_dl_relocate_object+0x1a0>
    0.00 :	    b265:       49 8b 96 e8 03 00 00    mov    0x3e8(%r14),%rdx
    0.00 :	    b26c:       48 85 d2                test   %rdx,%rdx
    0.00 :	    b26f:       0f 85 9b 00 00 00       jne    b310 <_dl_relocate_object+0x2a0>
    0.00 :	    b275:       4d 01 1c 24             add    %r11,(%r12)
    0.00 :	    b279:       48 83 c3 18             add    $0x18,%rbx
    0.00 :	    b27d:       48 39 9d 78 ff ff ff    cmp    %rbx,-0x88(%rbp)
    0.00 :	    b284:       77 d0                   ja     b256 <_dl_relocate_object+0x1e6>
    0.00 :	    b286:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
    0.00 :	    b28d:       00 00 00 
    0.00 :	    b290:       48 8b 85 48 ff ff ff    mov    -0xb8(%rbp),%rax
    0.00 :	    b297:       48 83 45 88 18          addq   $0x18,-0x78(%rbp)
    0.00 :	    b29c:       48 83 c0 30             add    $0x30,%rax
    0.00 :	    b2a0:       48 39 45 88             cmp    %rax,-0x78(%rbp)
    0.00 :	    b2a4:       0f 85 31 ff ff ff       jne    b1db <_dl_relocate_object+0x16b>
    0.00 :	    b2aa:       8b 85 54 ff ff ff       mov    -0xac(%rbp),%eax
    0.00 :	    b2b0:       85 c0                   test   %eax,%eax
    0.00 :	    b2b2:       0f 85 84 0e 00 00       jne    c13c <_dl_relocate_object+0x10cc>
    0.00 :	    b2b8:       41 80 8e 14 03 00 00    orb    $0x4,0x314(%r14)
    0.00 :	    b2bf:       04 
    0.00 :	    b2c0:       48 83 bd 68 ff ff ff    cmpq   $0x0,-0x98(%rbp)
    0.00 :	    b2c7:       00 
    0.00 :	    b2c8:       0f 85 37 0e 00 00       jne    c105 <_dl_relocate_object+0x1095>
    0.00 :	    b2ce:       49 83 be 60 04 00 00    cmpq   $0x0,0x460(%r14)
    0.00 :	    b2d5:       00 
    0.00 :	    b2d6:       74 08                   je     b2e0 <_dl_relocate_object+0x270>
    0.00 :	    b2d8:       4c 89 f7                mov    %r14,%rdi
    0.00 :	    b2db:       e8 90 fb ff ff          callq  ae70 <_dl_protect_relro>
    0.00 :	    b2e0:       48 8d 65 d8             lea    -0x28(%rbp),%rsp
    0.00 :	    b2e4:       5b                      pop    %rbx
    0.00 :	    b2e5:       41 5c                   pop    %r12
    0.00 :	    b2e7:       41 5d                   pop    %r13
    0.00 :	    b2e9:       41 5e                   pop    %r14
    0.00 :	    b2eb:       41 5f                   pop    %r15
    0.00 :	    b2ed:       c9                      leaveq 
    0.00 :	    b2ee:       c3                      retq   
    0.00 :	    b2ef:       90                      nop
    0.00 :	    b2f0:       49 89 5c 24 08          mov    %rbx,0x8(%r12)
    0.00 :	    b2f5:       49 8b 96 90 02 00 00    mov    0x290(%r14),%rdx
    0.00 :	    b2fc:       49 8b 06                mov    (%r14),%rax
    0.00 :	    b2ff:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    b303:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	    b307:       e9 3d ff ff ff          jmpq   b249 <_dl_relocate_object+0x1d9>
    0.00 :	    b30c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b310:       4c 89 e0                mov    %r12,%rax
    0.00 :	    b313:       49 2b 86 f0 03 00 00    sub    0x3f0(%r14),%rax
    0.00 :	    b31a:       48 8d 04 42             lea    (%rdx,%rax,2),%rax
    0.00 :	    b31e:       49 89 04 24             mov    %rax,(%r12)
    0.00 :	    b322:       e9 22 ff ff ff          jmpq   b249 <_dl_relocate_object+0x1d9>
    0.00 :	    b327:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	    b32e:       00 00 
    0.00 :	    b330:       49 8b 46 70             mov    0x70(%r14),%rax
    0.00 :	    b334:       49 8b 96 80 01 00 00    mov    0x180(%r14),%rdx
    0.00 :	    b33b:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b33f:       48 89 45 80             mov    %rax,-0x80(%rbp)
    0.00 :	    b343:       31 c0                   xor    %eax,%eax
    0.00 :	    b345:       48 85 d2                test   %rdx,%rdx
    0.00 :	    b348:       74 2a                   je     b374 <_dl_relocate_object+0x304>
    0.00 :	    b34a:       8b 72 08                mov    0x8(%rdx),%esi
    0.00 :	    b34d:       48 89 c8                mov    %rcx,%rax
    0.00 :	    b350:       48 ba ab aa aa aa aa    movabs $0xaaaaaaaaaaaaaaab,%rdx
    0.00 :	    b357:       aa aa aa 
    0.00 :	    b35a:       48 f7 e2                mul    %rdx
    0.00 :	    b35d:       48 c1 ea 04             shr    $0x4,%rdx
    0.00 :	    b361:       48 39 d6                cmp    %rdx,%rsi
    0.00 :	    b364:       48 0f 46 d6             cmovbe %rsi,%rdx
    0.00 :	    b368:       48 8d 14 52             lea    (%rdx,%rdx,2),%rdx
    0.00 :	    b36c:       48 8d 04 d5 00 00 00    lea    0x0(,%rdx,8),%rax
    0.00 :	    b373:       00 
    0.00 :	    b374:       4c 8d 24 03             lea    (%rbx,%rax,1),%r12
    0.00 :	    b378:       48 8d 05 51 46 21 00    lea    0x214651(%rip),%rax        # 21f9d0 <_rtld_global+0x970>
    0.00 :	    b37f:       49 39 c6                cmp    %rax,%r14
    0.00 :	    b382:       74 39                   je     b3bd <_dl_relocate_object+0x34d>
    0.00 :	    b384:       4d 85 db                test   %r11,%r11
    0.00 :	    b387:       0f 84 93 04 00 00       je     b820 <_dl_relocate_object+0x7b0>
    0.00 :	    b38d:       4c 39 e3                cmp    %r12,%rbx
    0.00 :	    b390:       73 2b                   jae    b3bd <_dl_relocate_object+0x34d>
    0.00 :	    b392:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    0.00 :	    b398:       83 7b 08 08             cmpl   $0x8,0x8(%rbx)
    0.00 :	    b39c:       48 8b 03                mov    (%rbx),%rax
    0.00 :	    b39f:       90                      nop
    0.00 :	    b3a0:       0f 85 ea 0a 00 00       jne    be90 <_dl_relocate_object+0xe20>
    0.00 :	    b3a6:       4a 8d 14 18             lea    (%rax,%r11,1),%rdx
    0.00 :	    b3aa:       4c 89 d8                mov    %r11,%rax
    0.00 :	    b3ad:       48 03 43 10             add    0x10(%rbx),%rax
    0.00 :	    b3b1:       48 83 c3 18             add    $0x18,%rbx
    0.00 :	    b3b5:       49 39 dc                cmp    %rbx,%r12
    0.00 :	    b3b8:       48 89 02                mov    %rax,(%rdx)
    0.00 :	    b3bb:       77 db                   ja     b398 <_dl_relocate_object+0x328>
    0.00 :	    b3bd:       49 8b 86 c8 01 00 00    mov    0x1c8(%r14),%rax
    0.00 :	    b3c4:       48 85 c0                test   %rax,%rax
    0.00 :	    b3c7:       0f 84 cf 01 00 00       je     b59c <_dl_relocate_object+0x52c>
    0.00 :	    b3cd:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b3d4:       48 8b 40 08             mov    0x8(%rax),%rax
    0.00 :	    b3d8:       48 89 85 70 ff ff ff    mov    %rax,-0x90(%rbp)
    0.00 :	    b3df:       0f 86 ab fe ff ff       jbe    b290 <_dl_relocate_object+0x220>
    0.00 :	    b3e5:       0f 1f 00                nopl   (%rax)
    0.00 :	    b3e8:       41 8b 44 24 0c          mov    0xc(%r12),%eax
    0.00 :	    b3ed:       48 8b 95 70 ff ff ff    mov    -0x90(%rbp),%rdx
    0.00 :	    b3f4:       4d 89 da                mov    %r11,%r10
    0.00 :	    b3f7:       48 8b 4d 80             mov    -0x80(%rbp),%rcx
    0.00 :	    b3fb:       4d 03 14 24             add    (%r12),%r10
    0.00 :	    b3ff:       4d 8b 86 e0 02 00 00    mov    0x2e0(%r14),%r8
    0.00 :	    b406:       0f b7 3c 42             movzwl (%rdx,%rax,2),%edi
 ??:0
  100.00 :	    b40a:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	    b40e:       4c 8d 2c c1             lea    (%rcx,%rax,8),%r13
    0.00 :	    b412:       4c 89 6d c8             mov    %r13,-0x38(%rbp)
    0.00 :	    b416:       41 8b 5c 24 08          mov    0x8(%r12),%ebx
    0.00 :	    b41b:       48 83 fb 08             cmp    $0x8,%rbx
    0.00 :	    b41f:       0f 84 4b 03 00 00       je     b770 <_dl_relocate_object+0x700>
    0.00 :	    b425:       48 85 db                test   %rbx,%rbx
    0.00 :	    b428:       0f 84 2a 03 00 00       je     b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b42e:       41 0f b6 45 04          movzbl 0x4(%r13),%eax
    0.00 :	    b433:       4d 89 f7                mov    %r14,%r15
    0.00 :	    b436:       4c 89 ea                mov    %r13,%rdx
    0.00 :	    b439:       c0 e8 04                shr    $0x4,%al
    0.00 :	    b43c:       84 c0                   test   %al,%al
    0.00 :	    b43e:       0f 84 d5 00 00 00       je     b519 <_dl_relocate_object+0x4a9>
    0.00 :	    b444:       4d 3b ae 00 04 00 00    cmp    0x400(%r14),%r13
    0.00 :	    b44b:       0f 84 7f 06 00 00       je     bad0 <_dl_relocate_object+0xa60>
    0.00 :	    b451:       48 83 fb 07             cmp    $0x7,%rbx
    0.00 :	    b455:       40 0f 94 c6             sete   %sil
    0.00 :	    b459:       48 83 fb 10             cmp    $0x10,%rbx
    0.00 :	    b45d:       0f 94 c2                sete   %dl
    0.00 :	    b460:       84 d2                   test   %dl,%dl
    0.00 :	    b462:       75 09                   jne    b46d <_dl_relocate_object+0x3fd>
    0.00 :	    b464:       40 84 f6                test   %sil,%sil
    0.00 :	    b467:       0f 84 db 01 00 00       je     b648 <_dl_relocate_object+0x5d8>
    0.00 :	    b46d:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    b472:       89 c8                   mov    %ecx,%eax
    0.00 :	    b474:       83 c8 02                or     $0x2,%eax
    0.00 :	    b477:       48 83 fb 05             cmp    $0x5,%rbx
    0.00 :	    b47b:       0f 44 c8                cmove  %eax,%ecx
    0.00 :	    b47e:       48 89 f8                mov    %rdi,%rax
    0.00 :	    b481:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    b485:       41 89 8e 08 04 00 00    mov    %ecx,0x408(%r14)
    0.00 :	    b48c:       25 ff 7f 00 00          and    $0x7fff,%eax
    0.00 :	    b491:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	    b495:       49 89 96 00 04 00 00    mov    %rdx,0x400(%r14)
    0.00 :	    b49c:       49 8d 04 c0             lea    (%r8,%rax,8),%rax
    0.00 :	    b4a0:       48 85 c0                test   %rax,%rax
    0.00 :	    b4a3:       74 0e                   je     b4b3 <_dl_relocate_object+0x443>
    0.00 :	    b4a5:       8b 70 08                mov    0x8(%rax),%esi
    0.00 :	    b4a8:       85 f6                   test   %esi,%esi
    0.00 :	    b4aa:       be 00 00 00 00          mov    $0x0,%esi
    0.00 :	    b4af:       48 0f 44 c6             cmove  %rsi,%rax
    0.00 :	    b4b3:       8b 3a                   mov    (%rdx),%edi
    0.00 :	    b4b5:       41 89 c9                mov    %ecx,%r9d
    0.00 :	    b4b8:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	    b4bf:       48 03 bd 60 ff ff ff    add    -0xa0(%rbp),%rdi
    0.00 :	    b4c6:       48 8b 8d 58 ff ff ff    mov    -0xa8(%rbp),%rcx
    0.00 :	    b4cd:       49 89 c0                mov    %rax,%r8
    0.00 :	    b4d0:       4c 89 f6                mov    %r14,%rsi
    0.00 :	    b4d3:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    b4da:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b4e1:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
    0.00 :	    b4e8:       00 00 
    0.00 :	    b4ea:       c7 04 24 01 00 00 00    movl   $0x1,(%rsp)
    0.00 :	    b4f1:       e8 7a e6 ff ff          callq  9b70 <_dl_lookup_symbol_x>
    0.00 :	    b4f6:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    b4fa:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b501:       49 89 c7                mov    %rax,%r15
    0.00 :	    b504:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    b50b:       49 89 86 10 04 00 00    mov    %rax,0x410(%r14)
    0.00 :	    b512:       49 89 96 18 04 00 00    mov    %rdx,0x418(%r14)
    0.00 :	    b519:       31 c9                   xor    %ecx,%ecx
    0.00 :	    b51b:       48 85 d2                test   %rdx,%rdx
    0.00 :	    b51e:       74 17                   je     b537 <_dl_relocate_object+0x4c7>
    0.00 :	    b520:       0f b6 42 04             movzbl 0x4(%rdx),%eax
    0.00 :	    b524:       48 8b 4a 08             mov    0x8(%rdx),%rcx
    0.00 :	    b528:       49 03 0f                add    (%r15),%rcx
    0.00 :	    b52b:       83 e0 0f                and    $0xf,%eax
    0.00 :	    b52e:       83 f8 0a                cmp    $0xa,%eax
    0.00 :	    b531:       0f 84 99 02 00 00       je     b7d0 <_dl_relocate_object+0x760>
    0.00 :	    b537:       48 83 fb 25             cmp    $0x25,%rbx
    0.00 :	    b53b:       0f 86 57 02 00 00       jbe    b798 <_dl_relocate_object+0x728>
    0.00 :	    b541:       31 d2                   xor    %edx,%edx
    0.00 :	    b543:       89 de                   mov    %ebx,%esi
    0.00 :	    b545:       4c 89 f7                mov    %r14,%rdi
    0.00 :	    b548:       e8 43 f8 ff ff          callq  ad90 <_dl_reloc_bad_type>
    0.00 :	    b54d:       48 83 7d c8 00          cmpq   $0x0,-0x38(%rbp)
    0.00 :	    b552:       0f 84 57 09 00 00       je     beaf <_dl_relocate_object+0xe3f>
    0.00 :	    b558:       49 8b 87 48 04 00 00    mov    0x448(%r15),%rax
    0.00 :	    b55f:       48 83 f8 01             cmp    $0x1,%rax
    0.00 :	    b563:       0f 84 d5 09 00 00       je     bf3e <_dl_relocate_object+0xece>
    0.00 :	    b569:       48 85 c0                test   %rax,%rax
    0.00 :	    b56c:       0f 84 a0 09 00 00       je     bf12 <_dl_relocate_object+0xea2>
    0.00 :	    b572:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    b576:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    b57b:       48 8d 0d 4e a5 00 00    lea    0xa54e(%rip),%rcx        # 15ad0 <_dl_tlsdesc_return>
    0.00 :	    b582:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    b586:       49 2b 87 48 04 00 00    sub    0x448(%r15),%rax
    0.00 :	    b58d:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    b591:       49 89 0a                mov    %rcx,(%r10)
    0.00 :	    b594:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b598:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b59c:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b5a3:       0f 86 e7 fc ff ff       jbe    b290 <_dl_relocate_object+0x220>
    0.00 :	    b5a9:       41 8b 44 24 0c          mov    0xc(%r12),%eax
    0.00 :	    b5ae:       48 8b 55 80             mov    -0x80(%rbp),%rdx
    0.00 :	    b5b2:       4d 89 da                mov    %r11,%r10
    0.00 :	    b5b5:       4d 03 14 24             add    (%r12),%r10
    0.00 :	    b5b9:       48 8d 04 40             lea    (%rax,%rax,2),%rax
    0.00 :	    b5bd:       4c 8d 2c c2             lea    (%rdx,%rax,8),%r13
    0.00 :	    b5c1:       4c 89 6d c8             mov    %r13,-0x38(%rbp)
    0.00 :	    b5c5:       41 8b 5c 24 08          mov    0x8(%r12),%ebx
    0.00 :	    b5ca:       48 83 fb 08             cmp    $0x8,%rbx
    0.00 :	    b5ce:       0f 84 34 02 00 00       je     b808 <_dl_relocate_object+0x798>
    0.00 :	    b5d4:       48 85 db                test   %rbx,%rbx
    0.00 :	    b5d7:       74 bf                   je     b598 <_dl_relocate_object+0x528>
    0.00 :	    b5d9:       41 0f b6 45 04          movzbl 0x4(%r13),%eax
    0.00 :	    b5de:       4d 89 f7                mov    %r14,%r15
    0.00 :	    b5e1:       4c 89 ea                mov    %r13,%rdx
    0.00 :	    b5e4:       c0 e8 04                shr    $0x4,%al
    0.00 :	    b5e7:       84 c0                   test   %al,%al
    0.00 :	    b5e9:       0f 84 01 01 00 00       je     b6f0 <_dl_relocate_object+0x680>
    0.00 :	    b5ef:       4d 3b ae 00 04 00 00    cmp    0x400(%r14),%r13
    0.00 :	    b5f6:       74 7d                   je     b675 <_dl_relocate_object+0x605>
    0.00 :	    b5f8:       48 83 fb 07             cmp    $0x7,%rbx
    0.00 :	    b5fc:       40 0f 94 c6             sete   %sil
    0.00 :	    b600:       48 83 fb 10             cmp    $0x10,%rbx
    0.00 :	    b604:       0f 94 c2                sete   %dl
    0.00 :	    b607:       84 d2                   test   %dl,%dl
    0.00 :	    b609:       0f 85 81 05 00 00       jne    bb90 <_dl_relocate_object+0xb20>
    0.00 :	    b60f:       40 84 f6                test   %sil,%sil
    0.00 :	    b612:       0f 85 78 05 00 00       jne    bb90 <_dl_relocate_object+0xb20>
    0.00 :	    b618:       48 83 fb 11             cmp    $0x11,%rbx
    0.00 :	    b61c:       0f 84 6e 05 00 00       je     bb90 <_dl_relocate_object+0xb20>
    0.00 :	    b622:       48 83 fb 12             cmp    $0x12,%rbx
    0.00 :	    b626:       0f 84 64 05 00 00       je     bb90 <_dl_relocate_object+0xb20>
    0.00 :	    b62c:       48 83 fb 24             cmp    $0x24,%rbx
    0.00 :	    b630:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	    b635:       0f 84 66 05 00 00       je     bba1 <_dl_relocate_object+0xb31>
    0.00 :	    b63b:       30 d2                   xor    %dl,%dl
    0.00 :	    b63d:       0f 1f 00                nopl   (%rax)
    0.00 :	    b640:       e9 50 05 00 00          jmpq   bb95 <_dl_relocate_object+0xb25>
    0.00 :	    b645:       0f 1f 00                nopl   (%rax)
    0.00 :	    b648:       48 83 fb 11             cmp    $0x11,%rbx
    0.00 :	    b64c:       0f 84 1b fe ff ff       je     b46d <_dl_relocate_object+0x3fd>
    0.00 :	    b652:       48 83 fb 12             cmp    $0x12,%rbx
    0.00 :	    b656:       0f 84 11 fe ff ff       je     b46d <_dl_relocate_object+0x3fd>
    0.00 :	    b65c:       48 83 fb 24             cmp    $0x24,%rbx
    0.00 :	    b660:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    b665:       0f 84 13 fe ff ff       je     b47e <_dl_relocate_object+0x40e>
    0.00 :	    b66b:       30 c9                   xor    %cl,%cl
    0.00 :	    b66d:       0f 1f 00                nopl   (%rax)
    0.00 :	    b670:       e9 fd fd ff ff          jmpq   b472 <_dl_relocate_object+0x402>
    0.00 :	    b675:       48 83 fb 07             cmp    $0x7,%rbx
    0.00 :	    b679:       40 0f 94 c6             sete   %sil
    0.00 :	    b67d:       48 83 fb 10             cmp    $0x10,%rbx
    0.00 :	    b681:       0f 94 c2                sete   %dl
    0.00 :	    b684:       40 84 f6                test   %sil,%sil
    0.00 :	    b687:       0f 85 7b 08 00 00       jne    bf08 <_dl_relocate_object+0xe98>
    0.00 :	    b68d:       84 d2                   test   %dl,%dl
    0.00 :	    b68f:       0f 85 73 08 00 00       jne    bf08 <_dl_relocate_object+0xe98>
    0.00 :	    b695:       48 83 fb 11             cmp    $0x11,%rbx
    0.00 :	    b699:       0f 84 69 08 00 00       je     bf08 <_dl_relocate_object+0xe98>
    0.00 :	    b69f:       48 83 fb 12             cmp    $0x12,%rbx
    0.00 :	    b6a3:       0f 84 5f 08 00 00       je     bf08 <_dl_relocate_object+0xe98>
    0.00 :	    b6a9:       48 83 fb 24             cmp    $0x24,%rbx
    0.00 :	    b6ad:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    b6b2:       74 0e                   je     b6c2 <_dl_relocate_object+0x652>
    0.00 :	    b6b4:       30 c9                   xor    %cl,%cl
    0.00 :	    b6b6:       89 c8                   mov    %ecx,%eax
    0.00 :	    b6b8:       83 c8 02                or     $0x2,%eax
    0.00 :	    b6bb:       48 83 fb 05             cmp    $0x5,%rbx
    0.00 :	    b6bf:       0f 44 c8                cmove  %eax,%ecx
    0.00 :	    b6c2:       41 39 8e 08 04 00 00    cmp    %ecx,0x408(%r14)
    0.00 :	    b6c9:       0f 85 38 ff ff ff       jne    b607 <_dl_relocate_object+0x597>
    0.00 :	    b6cf:       48 83 05 e1 42 21 00    addq   $0x1,0x2142e1(%rip)        # 21f9b8 <_rtld_global+0x958>
    0.00 :	    b6d6:       01 
    0.00 :	    b6d7:       49 8b 86 18 04 00 00    mov    0x418(%r14),%rax
    0.00 :	    b6de:       4d 8b be 10 04 00 00    mov    0x410(%r14),%r15
    0.00 :	    b6e5:       48 89 45 c8             mov    %rax,-0x38(%rbp)
    0.00 :	    b6e9:       48 89 c2                mov    %rax,%rdx
    0.00 :	    b6ec:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b6f0:       31 c9                   xor    %ecx,%ecx
    0.00 :	    b6f2:       48 85 d2                test   %rdx,%rdx
    0.00 :	    b6f5:       74 17                   je     b70e <_dl_relocate_object+0x69e>
    0.00 :	    b6f7:       0f b6 42 04             movzbl 0x4(%rdx),%eax
    0.00 :	    b6fb:       48 8b 4a 08             mov    0x8(%rdx),%rcx
    0.00 :	    b6ff:       49 03 0f                add    (%r15),%rcx
    0.00 :	    b702:       83 e0 0f                and    $0xf,%eax
    0.00 :	    b705:       83 f8 0a                cmp    $0xa,%eax
    0.00 :	    b708:       0f 84 2f 04 00 00       je     bb3d <_dl_relocate_object+0xacd>
    0.00 :	    b70e:       48 83 fb 25             cmp    $0x25,%rbx
    0.00 :	    b712:       0f 87 29 fe ff ff       ja     b541 <_dl_relocate_object+0x4d1>
    0.00 :	    b718:       48 8d 35 21 d3 00 00    lea    0xd321(%rip),%rsi        # 18a40 <expected2.12835+0x17>
    0.00 :	    b71f:       48 63 04 9e             movslq (%rsi,%rbx,4),%rax
    0.00 :	    b723:       48 01 f0                add    %rsi,%rax
    0.00 :	    b726:       ff e0                   jmpq   *%rax
    0.00 :	    b728:       48 83 7d c8 00          cmpq   $0x0,-0x38(%rbp)
    0.00 :	    b72d:       74 29                   je     b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b72f:       49 83 bf 48 04 00 00    cmpq   $0x1,0x448(%r15)
    0.00 :	    b736:       01 
    0.00 :	    b737:       0f 86 a2 07 00 00       jbe    bedf <_dl_relocate_object+0xe6f>
    0.00 :	    b73d:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    b741:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    b746:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    b74a:       49 2b 87 48 04 00 00    sub    0x448(%r15),%rax
    0.00 :	    b751:       49 89 02                mov    %rax,(%r10)
    0.00 :	    b754:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b758:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b75c:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b763:       0f 87 7f fc ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    b769:       e9 22 fb ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b76e:       66 90                   xchg   %ax,%ax
    0.00 :	    b770:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    b775:       49 03 06                add    (%r14),%rax
    0.00 :	    b778:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b77c:       49 89 02                mov    %rax,(%r10)
    0.00 :	    b77f:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b786:       0f 87 5c fc ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    b78c:       e9 ff fa ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b791:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    b798:       48 8d 15 39 d3 00 00    lea    0xd339(%rip),%rdx        # 18ad8 <expected2.12835+0xaf>
    0.00 :	    b79f:       48 63 04 9a             movslq (%rdx,%rbx,4),%rax
    0.00 :	    b7a3:       48 01 d0                add    %rdx,%rax
    0.00 :	    b7a6:       ff e0                   jmpq   *%rax
    0.00 :	    b7a8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    0.00 :	    b7af:       00 
    0.00 :	    b7b0:       49 03 4c 24 10          add    0x10(%r12),%rcx
    0.00 :	    b7b5:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b7b9:       49 89 0a                mov    %rcx,(%r10)
    0.00 :	    b7bc:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b7c3:       0f 87 1f fc ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    b7c9:       e9 c2 fa ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b7ce:       66 90                   xchg   %ax,%ax
    0.00 :	    b7d0:       66 83 7a 06 00          cmpw   $0x0,0x6(%rdx)
    0.00 :	    b7d5:       0f 84 5c fd ff ff       je     b537 <_dl_relocate_object+0x4c7>
    0.00 :	    b7db:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    b7e2:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b7e9:       ff d1                   callq  *%rcx
    0.00 :	    b7eb:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b7f2:       48 89 c1                mov    %rax,%rcx
    0.00 :	    b7f5:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    b7fc:       e9 36 fd ff ff          jmpq   b537 <_dl_relocate_object+0x4c7>
    0.00 :	    b801:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    b808:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    b80d:       49 03 06                add    (%r14),%rax
    0.00 :	    b810:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b814:       49 89 02                mov    %rax,(%r10)
    0.00 :	    b817:       e9 80 fd ff ff          jmpq   b59c <_dl_relocate_object+0x52c>
    0.00 :	    b81c:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b820:       49 83 be 38 02 00 00    cmpq   $0x0,0x238(%r14)
    0.00 :	    b827:       00 
    0.00 :	    b828:       0f 85 8f fb ff ff       jne    b3bd <_dl_relocate_object+0x34d>
    0.00 :	    b82e:       e9 5a fb ff ff          jmpq   b38d <_dl_relocate_object+0x31d>
    0.00 :	    b833:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	    b838:       84 db                   test   %bl,%bl
    0.00 :	    b83a:       0f 84 df f8 ff ff       je     b11f <_dl_relocate_object+0xaf>
    0.00 :	    b840:       49 8b 46 58             mov    0x58(%r14),%rax
    0.00 :	    b844:       48 8b 50 08             mov    0x8(%rax),%rdx
    0.00 :	    b848:       48 8b 42 08             mov    0x8(%rdx),%rax
    0.00 :	    b84c:       48 85 c0                test   %rax,%rax
    0.00 :	    b84f:       74 15                   je     b866 <_dl_relocate_object+0x7f6>
    0.00 :	    b851:       49 03 06                add    (%r14),%rax
    0.00 :	    b854:       49 89 86 e8 03 00 00    mov    %rax,0x3e8(%r14)
    0.00 :	    b85b:       48 8d 42 18             lea    0x18(%rdx),%rax
    0.00 :	    b85f:       49 89 86 f0 03 00 00    mov    %rax,0x3f0(%r14)
    0.00 :	    b866:       4c 89 72 08             mov    %r14,0x8(%rdx)
    0.00 :	    b86a:       44 8b 85 54 ff ff ff    mov    -0xac(%rbp),%r8d
    0.00 :	    b871:       45 85 c0                test   %r8d,%r8d
    0.00 :	    b874:       0f 84 f4 02 00 00       je     bb6e <_dl_relocate_object+0xafe>
    0.00 :	    b87a:       48 8d 0d 7f 84 00 00    lea    0x847f(%rip),%rcx        # 13d00 <_dl_runtime_profile>
    0.00 :	    b881:       48 89 4a 10             mov    %rcx,0x10(%rdx)
    0.00 :	    b885:       48 8b 3d 14 34 21 00    mov    0x213414(%rip),%rdi        # 21eca0 <_rtld_global_ro+0x80>
    0.00 :	    b88c:       48 85 ff                test   %rdi,%rdi
    0.00 :	    b88f:       0f 84 8a f8 ff ff       je     b11f <_dl_relocate_object+0xaf>
    0.00 :	    b895:       4c 89 f6                mov    %r14,%rsi
    0.00 :	    b898:       e8 e3 32 00 00          callq  eb80 <_dl_name_match_p>
    0.00 :	    b89d:       85 c0                   test   %eax,%eax
    0.00 :	    b89f:       0f 84 7a f8 ff ff       je     b11f <_dl_relocate_object+0xaf>
    0.00 :	    b8a5:       4c 89 35 fc 40 21 00    mov    %r14,0x2140fc(%rip)        # 21f9a8 <_rtld_global+0x948>
    0.00 :	    b8ac:       e9 6e f8 ff ff          jmpq   b11f <_dl_relocate_object+0xaf>
    0.00 :	    b8b1:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    b8b6:       49 03 06                add    (%r14),%rax
    0.00 :	    b8b9:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b8bd:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    b8c4:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b8cb:       ff d0                   callq  *%rax
    0.00 :	    b8cd:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    b8d4:       49 89 02                mov    %rax,(%r10)
    0.00 :	    b8d7:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b8de:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b8e5:       0f 87 fd fa ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    b8eb:       e9 a0 f9 ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b8f0:       48 89 c8                mov    %rcx,%rax
    0.00 :	    b8f3:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	    b8f8:       ba ff ff ff ff          mov    $0xffffffff,%edx
    0.00 :	    b8fd:       48 39 d0                cmp    %rdx,%rax
    0.00 :	    b900:       41 89 02                mov    %eax,(%r10)
    0.00 :	    b903:       0f 86 4f fe ff ff       jbe    b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b909:       48 8d 3d e8 01 01 00    lea    0x101e8(%rip),%rdi        # 1baf8 <__PRETTY_FUNCTION__.3644+0x1787>
    0.00 :	    b910:       48 8b 05 f1 32 21 00    mov    0x2132f1(%rip),%rax        # 21ec08 <_dl_argv>
    0.00 :	    b917:       49 8b 76 68             mov    0x68(%r14),%rsi
    0.00 :	    b91b:       48 8d 0d 88 dc 00 00    lea    0xdc88(%rip),%rcx        # 195aa <intel_02_known+0x2ca>
    0.00 :	    b922:       48 8b 10                mov    (%rax),%rdx
    0.00 :	    b925:       48 85 d2                test   %rdx,%rdx
    0.00 :	    b928:       48 0f 44 d1             cmove  %rcx,%rdx
    0.00 :	    b92c:       41 8b 4d 00             mov    0x0(%r13),%ecx
    0.00 :	    b930:       31 c0                   xor    %eax,%eax
    0.00 :	    b932:       48 03 4e 08             add    0x8(%rsi),%rcx
    0.00 :	    b936:       48 89 fe                mov    %rdi,%rsi
    0.00 :	    b939:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	    b93e:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b945:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    b949:       e8 b2 38 00 00          callq  f200 <_dl_dprintf>
    0.00 :	    b94e:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    b955:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b95c:       0f 87 86 fa ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    b962:       e9 29 f9 ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    b967:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	    b96e:       00 00 
    0.00 :	    b970:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    b974:       48 85 c0                test   %rax,%rax
    0.00 :	    b977:       0f 84 db fd ff ff       je     b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b97d:       49 8b 55 10             mov    0x10(%r13),%rdx
    0.00 :	    b981:       48 39 50 10             cmp    %rdx,0x10(%rax)
    0.00 :	    b985:       48 89 ce                mov    %rcx,%rsi
    0.00 :	    b988:       48 0f 46 50 10          cmovbe 0x10(%rax),%rdx
    0.00 :	    b98d:       4c 89 d7                mov    %r10,%rdi
    0.00 :	    b990:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    b997:       e8 54 b9 00 00          callq  172f0 <memcpy>
    0.00 :	    b99c:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    b9a0:       49 8b 75 10             mov    0x10(%r13),%rsi
    0.00 :	    b9a4:       48 8d 3d cd 01 01 00    lea    0x101cd(%rip),%rdi        # 1bb78 <__PRETTY_FUNCTION__.3644+0x1807>
    0.00 :	    b9ab:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    b9b2:       48 39 70 10             cmp    %rsi,0x10(%rax)
    0.00 :	    b9b6:       0f 87 54 ff ff ff       ja     b910 <_dl_relocate_object+0x8a0>
    0.00 :	    b9bc:       0f 83 96 fd ff ff       jae    b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b9c2:       8b 0d 8c 32 21 00       mov    0x21328c(%rip),%ecx        # 21ec54 <_rtld_global_ro+0x34>
    0.00 :	    b9c8:       48 8d 3d a9 01 01 00    lea    0x101a9(%rip),%rdi        # 1bb78 <__PRETTY_FUNCTION__.3644+0x1807>
    0.00 :	    b9cf:       85 c9                   test   %ecx,%ecx
    0.00 :	    b9d1:       0f 85 39 ff ff ff       jne    b910 <_dl_relocate_object+0x8a0>
    0.00 :	    b9d7:       e9 7c fd ff ff          jmpq   b758 <_dl_relocate_object+0x6e8>
    0.00 :	    b9dc:       0f 1f 40 00             nopl   0x0(%rax)
    0.00 :	    b9e0:       48 89 c8                mov    %rcx,%rax
    0.00 :	    b9e3:       48 8d 3d 4e 01 01 00    lea    0x1014e(%rip),%rdi        # 1bb38 <__PRETTY_FUNCTION__.3644+0x17c7>
    0.00 :	    b9ea:       4c 29 d0                sub    %r10,%rax
    0.00 :	    b9ed:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	    b9f2:       48 63 d0                movslq %eax,%rdx
    0.00 :	    b9f5:       41 89 02                mov    %eax,(%r10)
    0.00 :	    b9f8:       48 39 d0                cmp    %rdx,%rax
    0.00 :	    b9fb:       0f 85 0f ff ff ff       jne    b910 <_dl_relocate_object+0x8a0>
    0.00 :	    ba01:       e9 52 fd ff ff          jmpq   b758 <_dl_relocate_object+0x6e8>
    0.00 :	    ba06:       48 83 7d c8 00          cmpq   $0x0,-0x38(%rbp)
    0.00 :	    ba0b:       0f 84 b6 04 00 00       je     bec7 <_dl_relocate_object+0xe57>
    0.00 :	    ba11:       49 8b 87 48 04 00 00    mov    0x448(%r15),%rax
    0.00 :	    ba18:       48 83 f8 01             cmp    $0x1,%rax
    0.00 :	    ba1c:       0f 84 79 02 00 00       je     bc9b <_dl_relocate_object+0xc2b>
    0.00 :	    ba22:       48 85 c0                test   %rax,%rax
    0.00 :	    ba25:       0f 84 44 02 00 00       je     bc6f <_dl_relocate_object+0xbff>
    0.00 :	    ba2b:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    ba2f:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    ba34:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    ba38:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    ba3c:       49 2b 87 48 04 00 00    sub    0x448(%r15),%rax
    0.00 :	    ba43:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    ba47:       48 8d 05 82 a0 00 00    lea    0xa082(%rip),%rax        # 15ad0 <_dl_tlsdesc_return>
    0.00 :	    ba4e:       49 89 02                mov    %rax,(%r10)
    0.00 :	    ba51:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    ba58:       0f 87 8a f9 ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    ba5e:       e9 2d f8 ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    ba63:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    0.00 :	    ba68:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    ba6c:       48 85 d2                test   %rdx,%rdx
    0.00 :	    ba6f:       0f 84 e3 fc ff ff       je     b758 <_dl_relocate_object+0x6e8>
    0.00 :	    ba75:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    ba7a:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    ba7e:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    ba82:       49 89 02                mov    %rax,(%r10)
    0.00 :	    ba85:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    ba8c:       0f 87 56 f9 ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    ba92:       e9 f9 f7 ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    ba97:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    0.00 :	    ba9e:       00 00 
    0.00 :	    baa0:       4d 85 ff                test   %r15,%r15
    0.00 :	    baa3:       0f 84 af fc ff ff       je     b758 <_dl_relocate_object+0x6e8>
    0.00 :	    baa9:       49 8b 87 50 04 00 00    mov    0x450(%r15),%rax
    0.00 :	    bab0:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    bab4:       49 89 02                mov    %rax,(%r10)
    0.00 :	    bab7:       4c 39 a5 78 ff ff ff    cmp    %r12,-0x88(%rbp)
    0.00 :	    babe:       0f 87 24 f9 ff ff       ja     b3e8 <_dl_relocate_object+0x378>
    0.00 :	    bac4:       e9 c7 f7 ff ff          jmpq   b290 <_dl_relocate_object+0x220>
    0.00 :	    bac9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    0.00 :	    bad0:       48 83 fb 07             cmp    $0x7,%rbx
    0.00 :	    bad4:       40 0f 94 c6             sete   %sil
    0.00 :	    bad8:       48 83 fb 10             cmp    $0x10,%rbx
    0.00 :	    badc:       0f 94 c2                sete   %dl
    0.00 :	    badf:       40 84 f6                test   %sil,%sil
    0.00 :	    bae2:       0f 84 41 01 00 00       je     bc29 <_dl_relocate_object+0xbb9>
    0.00 :	    bae8:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    baed:       89 c8                   mov    %ecx,%eax
    0.00 :	    baef:       83 c8 02                or     $0x2,%eax
    0.00 :	    baf2:       48 83 fb 05             cmp    $0x5,%rbx
    0.00 :	    baf6:       0f 44 c8                cmove  %eax,%ecx
    0.00 :	    baf9:       41 39 8e 08 04 00 00    cmp    %ecx,0x408(%r14)
    0.00 :	    bb00:       0f 85 5a f9 ff ff       jne    b460 <_dl_relocate_object+0x3f0>
    0.00 :	    bb06:       48 83 05 aa 3e 21 00    addq   $0x1,0x213eaa(%rip)        # 21f9b8 <_rtld_global+0x958>
    0.00 :	    bb0d:       01 
    0.00 :	    bb0e:       49 8b 86 18 04 00 00    mov    0x418(%r14),%rax
    0.00 :	    bb15:       4d 8b be 10 04 00 00    mov    0x410(%r14),%r15
    0.00 :	    bb1c:       48 89 45 c8             mov    %rax,-0x38(%rbp)
    0.00 :	    bb20:       48 89 c2                mov    %rax,%rdx
    0.00 :	    bb23:       e9 f1 f9 ff ff          jmpq   b519 <_dl_relocate_object+0x4a9>
    0.00 :	    bb28:       49 83 be 00 01 00 00    cmpq   $0x0,0x100(%r14)
    0.00 :	    bb2f:       00 
    0.00 :	    bb30:       44 0f 45 a5 54 ff ff    cmovne -0xac(%rbp),%r12d
    0.00 :	    bb37:       ff 
    0.00 :	    bb38:       e9 99 f5 ff ff          jmpq   b0d6 <_dl_relocate_object+0x66>
    0.00 :	    bb3d:       66 83 7a 06 00          cmpw   $0x0,0x6(%rdx)
    0.00 :	    bb42:       0f 84 c6 fb ff ff       je     b70e <_dl_relocate_object+0x69e>
    0.00 :	    bb48:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bb4f:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bb56:       ff d1                   callq  *%rcx
    0.00 :	    bb58:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bb5f:       48 89 c1                mov    %rax,%rcx
    0.00 :	    bb62:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bb69:       e9 a0 fb ff ff          jmpq   b70e <_dl_relocate_object+0x69e>
    0.00 :	    bb6e:       48 8d 35 1b 81 00 00    lea    0x811b(%rip),%rsi        # 13c90 <_dl_runtime_resolve>
    0.00 :	    bb75:       84 db                   test   %bl,%bl
    0.00 :	    bb77:       48 89 72 10             mov    %rsi,0x10(%rdx)
    0.00 :	    bb7b:       49 8b 86 88 02 00 00    mov    0x288(%r14),%rax
    0.00 :	    bb82:       0f 84 b9 f5 ff ff       je     b141 <_dl_relocate_object+0xd1>
    0.00 :	    bb88:       e9 9d f5 ff ff          jmpq   b12a <_dl_relocate_object+0xba>
    0.00 :	    bb8d:       0f 1f 00                nopl   (%rax)
    0.00 :	    bb90:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	    bb95:       89 d0                   mov    %edx,%eax
    0.00 :	    bb97:       83 c8 02                or     $0x2,%eax
    0.00 :	    bb9a:       48 83 fb 05             cmp    $0x5,%rbx
    0.00 :	    bb9e:       0f 44 d0                cmove  %eax,%edx
    0.00 :	    bba1:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    bba5:       41 89 96 08 04 00 00    mov    %edx,0x408(%r14)
    0.00 :	    bbac:       41 89 d1                mov    %edx,%r9d
    0.00 :	    bbaf:       48 8b 8d 58 ff ff ff    mov    -0xa8(%rbp),%rcx
    0.00 :	    bbb6:       48 8b 95 40 ff ff ff    mov    -0xc0(%rbp),%rdx
    0.00 :	    bbbd:       45 31 c0                xor    %r8d,%r8d
    0.00 :	    bbc0:       4c 89 f6                mov    %r14,%rsi
    0.00 :	    bbc3:       49 89 86 00 04 00 00    mov    %rax,0x400(%r14)
    0.00 :	    bbca:       8b 38                   mov    (%rax),%edi
    0.00 :	    bbcc:       48 03 bd 60 ff ff ff    add    -0xa0(%rbp),%rdi
    0.00 :	    bbd3:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bbda:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bbe1:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
    0.00 :	    bbe8:       00 00 
    0.00 :	    bbea:       c7 04 24 01 00 00 00    movl   $0x1,(%rsp)
    0.00 :	    bbf1:       e8 7a df ff ff          callq  9b70 <_dl_lookup_symbol_x>
    0.00 :	    bbf6:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    bbfa:       31 c9                   xor    %ecx,%ecx
    0.00 :	    bbfc:       49 89 c7                mov    %rax,%r15
    0.00 :	    bbff:       49 89 86 10 04 00 00    mov    %rax,0x410(%r14)
    0.00 :	    bc06:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bc0d:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bc14:       48 85 d2                test   %rdx,%rdx
    0.00 :	    bc17:       49 89 96 18 04 00 00    mov    %rdx,0x418(%r14)
    0.00 :	    bc1e:       0f 85 d3 fa ff ff       jne    b6f7 <_dl_relocate_object+0x687>
    0.00 :	    bc24:       e9 e5 fa ff ff          jmpq   b70e <_dl_relocate_object+0x69e>
    0.00 :	    bc29:       84 d2                   test   %dl,%dl
    0.00 :	    bc2b:       0f 85 b7 fe ff ff       jne    bae8 <_dl_relocate_object+0xa78>
    0.00 :	    bc31:       48 83 fb 11             cmp    $0x11,%rbx
    0.00 :	    bc35:       0f 1f 00                nopl   (%rax)
    0.00 :	    bc38:       0f 84 aa fe ff ff       je     bae8 <_dl_relocate_object+0xa78>
    0.00 :	    bc3e:       48 83 fb 12             cmp    $0x12,%rbx
    0.00 :	    bc42:       0f 84 a0 fe ff ff       je     bae8 <_dl_relocate_object+0xa78>
    0.00 :	    bc48:       48 83 fb 24             cmp    $0x24,%rbx
    0.00 :	    bc4c:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    bc51:       0f 84 a2 fe ff ff       je     baf9 <_dl_relocate_object+0xa89>
    0.00 :	    bc57:       30 c9                   xor    %cl,%cl
    0.00 :	    bc59:       e9 8f fe ff ff          jmpq   baed <_dl_relocate_object+0xa7d>
    0.00 :	    bc5e:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	    bc62:       48 03 50 08             add    0x8(%rax),%rdx
    0.00 :	    bc66:       48 89 55 98             mov    %rdx,-0x68(%rbp)
    0.00 :	    bc6a:       e9 52 f5 ff ff          jmpq   b1c1 <_dl_relocate_object+0x151>
    0.00 :	    bc6f:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bc72:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bc79:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bc80:       e8 db f2 ff ff          callq  af60 <_dl_try_allocate_static_tls>
    0.00 :	    bc85:       85 c0                   test   %eax,%eax
    0.00 :	    bc87:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bc8e:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bc95:       0f 84 90 fd ff ff       je     ba2b <_dl_relocate_object+0x9bb>
    0.00 :	    bc9b:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    bc9f:       49 8b 74 24 10          mov    0x10(%r12),%rsi
    0.00 :	    bca4:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bca7:       48 03 70 08             add    0x8(%rax),%rsi
    0.00 :	    bcab:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bcb2:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bcb9:       e8 42 99 00 00          callq  15600 <_dl_make_tlsdesc_dynamic>
    0.00 :	    bcbe:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bcc5:       48 8d 35 24 9e 00 00    lea    0x9e24(%rip),%rsi        # 15af0 <_dl_tlsdesc_dynamic>
    0.00 :	    bccc:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    bcd0:       49 89 32                mov    %rsi,(%r10)
    0.00 :	    bcd3:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bcda:       e9 79 fa ff ff          jmpq   b758 <_dl_relocate_object+0x6e8>
    0.00 :	    bcdf:       49 03 4c 24 10          add    0x10(%r12),%rcx
    0.00 :	    bce4:       49 83 c4 18             add    $0x18,%r12
    0.00 :	    bce8:       49 89 0a                mov    %rcx,(%r10)
    0.00 :	    bceb:       e9 ac f8 ff ff          jmpq   b59c <_dl_relocate_object+0x52c>
    0.00 :	    bcf0:       4d 85 ff                test   %r15,%r15
    0.00 :	    bcf3:       0f 84 9f f8 ff ff       je     b598 <_dl_relocate_object+0x528>
    0.00 :	    bcf9:       49 8b 87 50 04 00 00    mov    0x450(%r15),%rax
    0.00 :	    bd00:       49 89 02                mov    %rax,(%r10)
    0.00 :	    bd03:       e9 90 f8 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    bd08:       48 89 c8                mov    %rcx,%rax
    0.00 :	    bd0b:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	    bd10:       be ff ff ff ff          mov    $0xffffffff,%esi
    0.00 :	    bd15:       48 39 f0                cmp    %rsi,%rax
    0.00 :	    bd18:       41 89 02                mov    %eax,(%r10)
    0.00 :	    bd1b:       0f 86 77 f8 ff ff       jbe    b598 <_dl_relocate_object+0x528>
    0.00 :	    bd21:       48 8d 3d d0 fd 00 00    lea    0xfdd0(%rip),%rdi        # 1baf8 <__PRETTY_FUNCTION__.3644+0x1787>
    0.00 :	    bd28:       48 8b 05 d9 2e 21 00    mov    0x212ed9(%rip),%rax        # 21ec08 <_dl_argv>
    0.00 :	    bd2f:       49 8b 76 68             mov    0x68(%r14),%rsi
    0.00 :	    bd33:       41 8b 4d 00             mov    0x0(%r13),%ecx
    0.00 :	    bd37:       48 8b 10                mov    (%rax),%rdx
    0.00 :	    bd3a:       48 8d 05 69 d8 00 00    lea    0xd869(%rip),%rax        # 195aa <intel_02_known+0x2ca>
    0.00 :	    bd41:       48 85 d2                test   %rdx,%rdx
    0.00 :	    bd44:       48 0f 44 d0             cmove  %rax,%rdx
    0.00 :	    bd48:       48 03 4e 08             add    0x8(%rsi),%rcx
    0.00 :	    bd4c:       31 c0                   xor    %eax,%eax
    0.00 :	    bd4e:       48 89 fe                mov    %rdi,%rsi
    0.00 :	    bd51:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	    bd56:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bd5d:       e8 9e 34 00 00          callq  f200 <_dl_dprintf>
    0.00 :	    bd62:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bd69:       e9 2a f8 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    bd6e:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    bd72:       48 85 c0                test   %rax,%rax
    0.00 :	    bd75:       0f 84 1d f8 ff ff       je     b598 <_dl_relocate_object+0x528>
    0.00 :	    bd7b:       49 8b 55 10             mov    0x10(%r13),%rdx
    0.00 :	    bd7f:       48 39 50 10             cmp    %rdx,0x10(%rax)
    0.00 :	    bd83:       4c 89 d7                mov    %r10,%rdi
    0.00 :	    bd86:       48 0f 46 50 10          cmovbe 0x10(%rax),%rdx
    0.00 :	    bd8b:       48 89 ce                mov    %rcx,%rsi
    0.00 :	    bd8e:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bd95:       e8 56 b5 00 00          callq  172f0 <memcpy>
    0.00 :	    bd9a:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    bd9e:       49 8b 55 10             mov    0x10(%r13),%rdx
    0.00 :	    bda2:       48 8d 3d cf fd 00 00    lea    0xfdcf(%rip),%rdi        # 1bb78 <__PRETTY_FUNCTION__.3644+0x1807>
    0.00 :	    bda9:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bdb0:       48 39 50 10             cmp    %rdx,0x10(%rax)
    0.00 :	    bdb4:       0f 87 6e ff ff ff       ja     bd28 <_dl_relocate_object+0xcb8>
    0.00 :	    bdba:       0f 83 d8 f7 ff ff       jae    b598 <_dl_relocate_object+0x528>
    0.00 :	    bdc0:       8b 15 8e 2e 21 00       mov    0x212e8e(%rip),%edx        # 21ec54 <_rtld_global_ro+0x34>
    0.00 :	    bdc6:       48 8d 3d ab fd 00 00    lea    0xfdab(%rip),%rdi        # 1bb78 <__PRETTY_FUNCTION__.3644+0x1807>
    0.00 :	    bdcd:       85 d2                   test   %edx,%edx
    0.00 :	    bdcf:       0f 85 53 ff ff ff       jne    bd28 <_dl_relocate_object+0xcb8>
    0.00 :	    bdd5:       e9 be f7 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    bdda:       48 89 c8                mov    %rcx,%rax
    0.00 :	    bddd:       48 8d 3d 54 fd 00 00    lea    0xfd54(%rip),%rdi        # 1bb38 <__PRETTY_FUNCTION__.3644+0x17c7>
    0.00 :	    bde4:       4c 29 d0                sub    %r10,%rax
    0.00 :	    bde7:       49 03 44 24 10          add    0x10(%r12),%rax
    0.00 :	    bdec:       48 63 d0                movslq %eax,%rdx
    0.00 :	    bdef:       41 89 02                mov    %eax,(%r10)
    0.00 :	    bdf2:       48 39 d0                cmp    %rdx,%rax
    0.00 :	    bdf5:       0f 85 2d ff ff ff       jne    bd28 <_dl_relocate_object+0xcb8>
    0.00 :	    bdfb:       e9 98 f7 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    be00:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    be05:       49 03 06                add    (%r14),%rax
    0.00 :	    be08:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    be0f:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    be16:       ff d0                   callq  *%rax
    0.00 :	    be18:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    be1f:       49 89 02                mov    %rax,(%r10)
    0.00 :	    be22:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    be29:       e9 6a f7 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    be2e:       48 83 7d c8 00          cmpq   $0x0,-0x38(%rbp)
    0.00 :	    be33:       0f 84 5f f7 ff ff       je     b598 <_dl_relocate_object+0x528>
    0.00 :	    be39:       49 83 bf 48 04 00 00    cmpq   $0x1,0x448(%r15)
    0.00 :	    be40:       01 
    0.00 :	    be41:       0f 86 3b 01 00 00       jbe    bf82 <_dl_relocate_object+0xf12>
    0.00 :	    be47:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    be4b:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    be50:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    be54:       49 2b 87 48 04 00 00    sub    0x448(%r15),%rax
    0.00 :	    be5b:       49 89 02                mov    %rax,(%r10)
    0.00 :	    be5e:       e9 35 f7 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    be63:       48 8b 55 c8             mov    -0x38(%rbp),%rdx
    0.00 :	    be67:       48 85 d2                test   %rdx,%rdx
    0.00 :	    be6a:       0f 84 28 f7 ff ff       je     b598 <_dl_relocate_object+0x528>
    0.00 :	    be70:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    be75:       48 03 42 08             add    0x8(%rdx),%rax
    0.00 :	    be79:       49 89 02                mov    %rax,(%r10)
    0.00 :	    be7c:       e9 17 f7 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    be81:       ba 01 00 00 00          mov    $0x1,%edx
    0.00 :	    be86:       89 c6                   mov    %eax,%esi
    0.00 :	    be88:       4c 89 f7                mov    %r14,%rdi
    0.00 :	    be8b:       e8 00 ef ff ff          callq  ad90 <_dl_reloc_bad_type>
    0.00 :	    be90:       48 8d 0d 19 08 01 00    lea    0x10819(%rip),%rcx        # 1c6b0 <__PRETTY_FUNCTION__.11640>
    0.00 :	    be97:       48 8d 35 4a e7 00 00    lea    0xe74a(%rip),%rsi        # 1a5e8 <__PRETTY_FUNCTION__.3644+0x277>
    0.00 :	    be9e:       48 8d 3d 63 e7 00 00    lea    0xe763(%rip),%rdi        # 1a608 <__PRETTY_FUNCTION__.3644+0x297>
    0.00 :	    bea5:       ba d2 01 00 00          mov    $0x1d2,%edx
    0.00 :	    beaa:       e8 c1 8e 00 00          callq  14d70 <__GI___assert_fail>
    0.00 :	    beaf:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    beb4:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    beb8:       48 8d 05 21 9c 00 00    lea    0x9c21(%rip),%rax        # 15ae0 <_dl_tlsdesc_undefweak>
    0.00 :	    bebf:       49 89 02                mov    %rax,(%r10)
    0.00 :	    bec2:       e9 d1 f6 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    bec7:       49 8b 44 24 10          mov    0x10(%r12),%rax
    0.00 :	    becc:       48 8d 0d 0d 9c 00 00    lea    0x9c0d(%rip),%rcx        # 15ae0 <_dl_tlsdesc_undefweak>
    0.00 :	    bed3:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    bed7:       49 89 0a                mov    %rcx,(%r10)
    0.00 :	    beda:       e9 79 f8 ff ff          jmpq   b758 <_dl_relocate_object+0x6e8>
    0.00 :	    bedf:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bee2:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bee9:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bef0:       e8 3b f1 ff ff          callq  b030 <_dl_allocate_static_tls>
    0.00 :	    bef5:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    befc:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bf03:       e9 35 f8 ff ff          jmpq   b73d <_dl_relocate_object+0x6cd>
    0.00 :	    bf08:       b9 01 00 00 00          mov    $0x1,%ecx
    0.00 :	    bf0d:       e9 a4 f7 ff ff          jmpq   b6b6 <_dl_relocate_object+0x646>
    0.00 :	    bf12:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bf15:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bf1c:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bf23:       e8 38 f0 ff ff          callq  af60 <_dl_try_allocate_static_tls>
    0.00 :	    bf28:       85 c0                   test   %eax,%eax
    0.00 :	    bf2a:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bf31:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bf38:       0f 84 34 f6 ff ff       je     b572 <_dl_relocate_object+0x502>
    0.00 :	    bf3e:       48 8b 45 c8             mov    -0x38(%rbp),%rax
    0.00 :	    bf42:       49 8b 74 24 10          mov    0x10(%r12),%rsi
    0.00 :	    bf47:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bf4a:       48 03 70 08             add    0x8(%rax),%rsi
    0.00 :	    bf4e:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bf55:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bf5c:       e8 9f 96 00 00          callq  15600 <_dl_make_tlsdesc_dynamic>
    0.00 :	    bf61:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bf68:       48 8d 15 81 9b 00 00    lea    0x9b81(%rip),%rdx        # 15af0 <_dl_tlsdesc_dynamic>
    0.00 :	    bf6f:       49 89 42 08             mov    %rax,0x8(%r10)
    0.00 :	    bf73:       49 89 12                mov    %rdx,(%r10)
    0.00 :	    bf76:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bf7d:       e9 16 f6 ff ff          jmpq   b598 <_dl_relocate_object+0x528>
    0.00 :	    bf82:       4c 89 ff                mov    %r15,%rdi
    0.00 :	    bf85:       4c 89 95 38 ff ff ff    mov    %r10,-0xc8(%rbp)
    0.00 :	    bf8c:       4c 89 9d 30 ff ff ff    mov    %r11,-0xd0(%rbp)
    0.00 :	    bf93:       e8 98 f0 ff ff          callq  b030 <_dl_allocate_static_tls>
    0.00 :	    bf98:       4c 8b 9d 30 ff ff ff    mov    -0xd0(%rbp),%r11
    0.00 :	    bf9f:       4c 8b 95 38 ff ff ff    mov    -0xc8(%rbp),%r10
    0.00 :	    bfa6:       e9 9c fe ff ff          jmpq   be47 <_dl_relocate_object+0xdd7>
    0.00 :	    bfab:       41 0f b7 8e b0 02 00    movzwl 0x2b0(%r14),%ecx
    0.00 :	    bfb2:       00 
    0.00 :	    bfb3:       49 8b 9e a0 02 00 00    mov    0x2a0(%r14),%rbx
    0.00 :	    bfba:       48 8d 14 cd 00 00 00    lea    0x0(,%rcx,8),%rdx
    0.00 :	    bfc1:       00 
    0.00 :	    bfc2:       48 89 c8                mov    %rcx,%rax
    0.00 :	    bfc5:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	    bfc9:       48 29 d0                sub    %rdx,%rax
    0.00 :	    bfcc:       48 8d 04 03             lea    (%rbx,%rax,1),%rax
    0.00 :	    bfd0:       48 39 c3                cmp    %rax,%rbx
    0.00 :	    bfd3:       0f 83 18 f1 ff ff       jae    b0f1 <_dl_relocate_object+0x81>
    0.00 :	    bfd9:       48 c7 85 68 ff ff ff    movq   $0x0,-0x98(%rbp)
    0.00 :	    bfe0:       00 00 00 00 
    0.00 :	    bfe4:       49 bf ff ff ff ff 02    movabs $0x2ffffffff,%r15
    0.00 :	    bfeb:       00 00 00 
    0.00 :	    bfee:       eb 26                   jmp    c016 <_dl_relocate_object+0xfa6>
    0.00 :	    bff0:       48 8d 14 cd 00 00 00    lea    0x0(,%rcx,8),%rdx
    0.00 :	    bff7:       00 
    0.00 :	    bff8:       48 89 c8                mov    %rcx,%rax
    0.00 :	    bffb:       48 83 c3 38             add    $0x38,%rbx
    0.00 :	    bfff:       48 c1 e0 06             shl    $0x6,%rax
    0.00 :	    c003:       48 29 d0                sub    %rdx,%rax
    0.00 :	    c006:       49 03 86 a0 02 00 00    add    0x2a0(%r14),%rax
    0.00 :	    c00d:       48 39 c3                cmp    %rax,%rbx
    0.00 :	    c010:       0f 83 e6 f0 ff ff       jae    b0fc <_dl_relocate_object+0x8c>
    0.00 :	    c016:       4c 89 f8                mov    %r15,%rax
    0.00 :	    c019:       48 23 03                and    (%rbx),%rax
    0.00 :	    c01c:       48 83 e8 01             sub    $0x1,%rax
    0.00 :	    c020:       75 ce                   jne    bff0 <_dl_relocate_object+0xf80>
    0.00 :	    c022:       48 8b 4b 10             mov    0x10(%rbx),%rcx
    0.00 :	    c026:       48 8b 35 0b 2c 21 00    mov    0x212c0b(%rip),%rsi        # 21ec38 <_rtld_global_ro+0x18>
    0.00 :	    c02d:       48 83 ec 30             sub    $0x30,%rsp
    0.00 :	    c031:       4c 8d 6c 24 1f          lea    0x1f(%rsp),%r13
    0.00 :	    c036:       48 89 ca                mov    %rcx,%rdx
    0.00 :	    c039:       48 03 53 28             add    0x28(%rbx),%rdx
    0.00 :	    c03d:       48 89 f0                mov    %rsi,%rax
    0.00 :	    c040:       48 f7 d8                neg    %rax
    0.00 :	    c043:       49 83 e5 f0             and    $0xfffffffffffffff0,%r13
    0.00 :	    c047:       48 8d 74 16 ff          lea    -0x1(%rsi,%rdx,1),%rsi
    0.00 :	    c04c:       ba 03 00 00 00          mov    $0x3,%edx
    0.00 :	    c051:       48 21 c6                and    %rax,%rsi
    0.00 :	    c054:       48 21 c8                and    %rcx,%rax
    0.00 :	    c057:       48 29 c6                sub    %rax,%rsi
    0.00 :	    c05a:       49 89 75 08             mov    %rsi,0x8(%r13)
    0.00 :	    c05e:       48 8b 3d d3 2b 21 00    mov    0x212bd3(%rip),%rdi        # 21ec38 <_rtld_global_ro+0x18>
    0.00 :	    c065:       48 f7 df                neg    %rdi
    0.00 :	    c068:       48 23 7b 10             and    0x10(%rbx),%rdi
    0.00 :	    c06c:       49 03 3e                add    (%r14),%rdi
    0.00 :	    c06f:       49 89 7d 00             mov    %rdi,0x0(%r13)
    0.00 :	    c073:       e8 b8 a1 00 00          callq  16230 <__mprotect>
    0.00 :	    c078:       85 c0                   test   %eax,%eax
    0.00 :	    c07a:       78 71                   js     c0ed <_dl_relocate_object+0x107d>
    0.00 :	    c07c:       8b 4b 04                mov    0x4(%rbx),%ecx
    0.00 :	    c07f:       b8 40 62 51 73          mov    $0x73516240,%eax
    0.00 :	    c084:       83 e1 07                and    $0x7,%ecx
    0.00 :	    c087:       c1 e1 02                shl    $0x2,%ecx
    0.00 :	    c08a:       d3 f8                   sar    %cl,%eax
    0.00 :	    c08c:       83 e0 0f                and    $0xf,%eax
    0.00 :	    c08f:       41 89 45 10             mov    %eax,0x10(%r13)
    0.00 :	    c093:       48 8b 85 68 ff ff ff    mov    -0x98(%rbp),%rax
    0.00 :	    c09a:       49 89 45 18             mov    %rax,0x18(%r13)
    0.00 :	    c09e:       4c 89 ad 68 ff ff ff    mov    %r13,-0x98(%rbp)
    0.00 :	    c0a5:       41 0f b7 8e b0 02 00    movzwl 0x2b0(%r14),%ecx
    0.00 :	    c0ac:       00 
    0.00 :	    c0ad:       e9 3e ff ff ff          jmpq   bff0 <_dl_relocate_object+0xf80>
    0.00 :	    c0b2:       49 8b 76 08             mov    0x8(%r14),%rsi
    0.00 :	    c0b6:       48 8d 15 20 d7 00 00    lea    0xd720(%rip),%rdx        # 197dd <intel_02_known+0x4fd>
    0.00 :	    c0bd:       48 8d 05 35 dc 00 00    lea    0xdc35(%rip),%rax        # 19cf9 <__PRETTY_FUNCTION__.12494+0x1a>
    0.00 :	    c0c4:       45 85 e4                test   %r12d,%r12d
    0.00 :	    c0c7:       48 0f 45 d0             cmovne %rax,%rdx
    0.00 :	    c0cb:       80 3e 00                cmpb   $0x0,(%rsi)
    0.00 :	    c0ce:       75 0a                   jne    c0da <_dl_relocate_object+0x106a>
    0.00 :	    c0d0:       48 8b 05 31 2b 21 00    mov    0x212b31(%rip),%rax        # 21ec08 <_dl_argv>
    0.00 :	    c0d7:       48 8b 30                mov    (%rax),%rsi
    0.00 :	    c0da:       48 8d 3d 20 dc 00 00    lea    0xdc20(%rip),%rdi        # 19d01 <__PRETTY_FUNCTION__.12494+0x22>
    0.00 :	    c0e1:       31 c0                   xor    %eax,%eax
    0.00 :	    c0e3:       e8 68 32 00 00          callq  f350 <_dl_debug_printf>
    0.00 :	    c0e8:       e9 f6 ef ff ff          jmpq   b0e3 <_dl_relocate_object+0x73>
    0.00 :	    c0ed:       48 8d 0d d4 f9 00 00    lea    0xf9d4(%rip),%rcx        # 1bac8 <__PRETTY_FUNCTION__.3644+0x1757>
    0.00 :	    c0f4:       49 8b 76 08             mov    0x8(%r14),%rsi
    0.00 :	    c0f8:       8b 3d 86 40 21 00       mov    0x214086(%rip),%edi        # 220184 <rtld_errno>
    0.00 :	    c0fe:       31 d2                   xor    %edx,%edx
    0.00 :	    c100:       e8 fb 1d 00 00          callq  df00 <_dl_signal_error>
    0.00 :	    c105:       48 8b 8d 68 ff ff ff    mov    -0x98(%rbp),%rcx
    0.00 :	    c10c:       8b 51 10                mov    0x10(%rcx),%edx
    0.00 :	    c10f:       48 8b 71 08             mov    0x8(%rcx),%rsi
    0.00 :	    c113:       48 8b 39                mov    (%rcx),%rdi
    0.00 :	    c116:       e8 15 a1 00 00          callq  16230 <__mprotect>
    0.00 :	    c11b:       85 c0                   test   %eax,%eax
    0.00 :	    c11d:       78 7d                   js     c19c <_dl_relocate_object+0x112c>
    0.00 :	    c11f:       48 8b b5 68 ff ff ff    mov    -0x98(%rbp),%rsi
    0.00 :	    c126:       48 8b 76 18             mov    0x18(%rsi),%rsi
    0.00 :	    c12a:       48 85 f6                test   %rsi,%rsi
    0.00 :	    c12d:       48 89 b5 68 ff ff ff    mov    %rsi,-0x98(%rbp)
    0.00 :	    c134:       0f 84 94 f1 ff ff       je     b2ce <_dl_relocate_object+0x25e>
    0.00 :	    c13a:       eb c9                   jmp    c105 <_dl_relocate_object+0x1095>
    0.00 :	    c13c:       49 8b 46 50             mov    0x50(%r14),%rax
    0.00 :	    c140:       48 85 c0                test   %rax,%rax
    0.00 :	    c143:       74 63                   je     c1a8 <_dl_relocate_object+0x1138>
    0.00 :	    c145:       48 8b 70 08             mov    0x8(%rax),%rsi
    0.00 :	    c149:       bf 20 00 00 00          mov    $0x20,%edi
    0.00 :	    c14e:       e8 7d 49 ff ff          callq  ad0 <calloc@plt>
    0.00 :	    c153:       48 85 c0                test   %rax,%rax
    0.00 :	    c156:       49 89 86 28 03 00 00    mov    %rax,0x328(%r14)
    0.00 :	    c15d:       48 8d 35 8c fa 00 00    lea    0xfa8c(%rip),%rsi        # 1bbf0 <__PRETTY_FUNCTION__.3644+0x187f>
    0.00 :	    c164:       0f 85 4e f1 ff ff       jne    b2b8 <_dl_relocate_object+0x248>
    0.00 :	    c16a:       48 8b 05 97 2a 21 00    mov    0x212a97(%rip),%rax        # 21ec08 <_dl_argv>
    0.00 :	    c171:       49 8b 4e 08             mov    0x8(%r14),%rcx
    0.00 :	    c175:       48 8d 15 2e d4 00 00    lea    0xd42e(%rip),%rdx        # 195aa <intel_02_known+0x2ca>
    0.00 :	    c17c:       bf 02 00 00 00          mov    $0x2,%edi
    0.00 :	    c181:       48 8b 00                mov    (%rax),%rax
    0.00 :	    c184:       48 85 c0                test   %rax,%rax
    0.00 :	    c187:       48 0f 45 d0             cmovne %rax,%rdx
    0.00 :	    c18b:       31 c0                   xor    %eax,%eax
    0.00 :	    c18d:       e8 6e 30 00 00          callq  f200 <_dl_dprintf>
    0.00 :	    c192:       bf 7f 00 00 00          mov    $0x7f,%edi
    0.00 :	    c197:       e8 24 a1 00 00          callq  162c0 <_Exit>
    0.00 :	    c19c:       48 8d 0d 85 fa 00 00    lea    0xfa85(%rip),%rcx        # 1bc28 <__PRETTY_FUNCTION__.3644+0x18b7>
    0.00 :	    c1a3:       e9 4c ff ff ff          jmpq   c0f4 <_dl_relocate_object+0x1084>
    0.00 :	    c1a8:       48 8d 35 19 fa 00 00    lea    0xfa19(%rip),%rsi        # 1bbc8 <__PRETTY_FUNCTION__.3644+0x1857>
    0.00 :	    c1af:       eb b9                   jmp    c16a <_dl_relocate_object+0x10fa>

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------

Sorted summary for file 
----------------------------------------------

 Nothing higher than 0.5%
 Percent |	Source code & Disassembly of 
------------------------------------------------
